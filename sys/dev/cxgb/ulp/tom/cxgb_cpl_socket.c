begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007-2008, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockstate.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_config.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_osdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/sys/mbufq.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tcp_offload.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_offload.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/t3cdev.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_firmware_exports.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_t3_cpl.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_tcb.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_ctl_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_offload.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/sys/mvec.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/toecore/cxgb_toedev.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tom.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_t3_ddp.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_toepcb.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tcp.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_vm.h>
end_include

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|pru_sosend
function_decl|)
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|top
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|pru_soreceive
function_decl|)
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|paddr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|TMP_IOV_MAX
value|16
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PG_FRAME
end_ifndef

begin_define
define|#
directive|define
name|PG_FRAME
value|~PAGE_MASK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SBLOCKWAIT
parameter_list|(
name|f
parameter_list|)
value|(((f)& MSG_DONTWAIT) ? M_NOWAIT : M_WAITOK)
end_define

begin_function
name|void
name|t3_init_socket_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|protosw
modifier|*
name|prp
decl_stmt|;
name|prp
operator|=
name|pffindtype
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|)
expr_stmt|;
name|pru_sosend
operator|=
name|prp
operator|->
name|pr_usrreqs
operator|->
name|pru_sosend
expr_stmt|;
name|pru_soreceive
operator|=
name|prp
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|cxgb_dma_info
block|{
name|size_t
name|cdi_mapped
decl_stmt|;
name|int
name|cdi_nsegs
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|cdi_segs
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|cxgb_dma_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|cxgb_dma_info
modifier|*
name|cdi
init|=
name|arg
decl_stmt|;
name|cdi
operator|->
name|cdi_mapped
operator|=
name|mapsize
expr_stmt|;
name|cdi
operator|->
name|cdi_nsegs
operator|=
name|nsegs
expr_stmt|;
name|cdi
operator|->
name|cdi_segs
operator|=
name|segs
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iov_adj
parameter_list|(
name|struct
name|iovec
modifier|*
modifier|*
name|iov
parameter_list|,
name|int
modifier|*
name|iovcnt
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|struct
name|iovec
modifier|*
name|iovtmp
decl_stmt|;
name|int
name|iovcnttmp
decl_stmt|;
name|caddr_t
name|ptmp
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|iovtmp
operator|=
operator|*
name|iov
expr_stmt|;
name|iovcnttmp
operator|=
operator|*
name|iovcnt
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|<
name|iovtmp
operator|->
name|iov_len
condition|)
block|{
name|ptmp
operator|=
name|iovtmp
operator|->
name|iov_base
expr_stmt|;
name|ptmp
operator|+=
name|count
expr_stmt|;
name|iovtmp
operator|->
name|iov_base
operator|=
name|ptmp
expr_stmt|;
name|iovtmp
operator|->
name|iov_len
operator|-=
name|count
expr_stmt|;
break|break;
block|}
else|else
name|count
operator|-=
name|iovtmp
operator|->
name|iov_len
expr_stmt|;
name|iovtmp
operator|++
expr_stmt|;
name|iovcnttmp
operator|--
expr_stmt|;
block|}
operator|*
name|iov
operator|=
name|iovtmp
expr_stmt|;
operator|*
name|iovcnt
operator|=
name|iovcnttmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|iovtmp
operator|=
operator|&
operator|(
operator|*
name|iov
operator|)
index|[
operator|*
name|iovcnt
operator|-
literal|1
index|]
expr_stmt|;
name|iovcnttmp
operator|=
operator|*
name|iovcnt
expr_stmt|;
while|while
condition|(
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|-
name|count
operator|<
name|iovtmp
operator|->
name|iov_len
condition|)
block|{
name|iovtmp
operator|->
name|iov_len
operator|+=
name|count
expr_stmt|;
break|break;
block|}
else|else
name|count
operator|+=
name|iovtmp
operator|->
name|iov_len
expr_stmt|;
name|iovtmp
operator|--
expr_stmt|;
name|iovcnttmp
operator|--
expr_stmt|;
block|}
operator|*
name|iovcnt
operator|=
name|iovcnttmp
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_zero_copy_free
parameter_list|(
name|void
modifier|*
name|cl
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mbuf_vec
modifier|*
name|mv
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|cl
decl_stmt|;
name|mv
operator|=
name|mtomv
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Physical addresses, don't try to free should be unheld separately from sbdrop 	 * 	 */
name|mv
operator|->
name|mv_count
operator|=
literal|0
expr_stmt|;
name|m_free_iovec
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_hold_iovec_pages
parameter_list|(
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|held
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|iovec
modifier|*
name|iov
init|=
name|uio
operator|->
name|uio_iov
decl_stmt|;
name|int
name|iovcnt
init|=
name|uio
operator|->
name|uio_iovcnt
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|,
name|count
decl_stmt|,
name|totcount
decl_stmt|,
name|maxcount
decl_stmt|,
name|totbytes
decl_stmt|,
name|npages
decl_stmt|,
name|curbytes
decl_stmt|;
name|uint64_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|vm_page_t
modifier|*
name|mp
decl_stmt|;
name|totbytes
operator|=
name|totcount
operator|=
literal|0
expr_stmt|;
name|maxcount
operator|=
operator|*
name|held
expr_stmt|;
name|mp
operator|=
name|m
expr_stmt|;
for|for
control|(
name|totcount
operator|=
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|iovcnt
operator|)
operator|&&
operator|(
name|totcount
operator|<
name|maxcount
operator|)
condition|;
name|i
operator|++
operator|,
name|iov
operator|++
control|)
block|{
name|count
operator|=
name|maxcount
operator|-
name|totcount
expr_stmt|;
name|start
operator|=
operator|(
name|uintptr_t
operator|)
name|iov
operator|->
name|iov_base
expr_stmt|;
name|end
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
operator|(
name|caddr_t
operator|)
name|iov
operator|->
name|iov_base
operator|+
name|iov
operator|->
name|iov_len
argument_list|)
expr_stmt|;
name|start
operator|&=
name|PG_FRAME
expr_stmt|;
name|end
operator|+=
name|PAGE_MASK
expr_stmt|;
name|end
operator|&=
name|PG_FRAME
expr_stmt|;
name|npages
operator|=
operator|(
name|end
operator|-
name|start
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|count
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|err
operator|=
name|vm_fault_hold_user_pages
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|iov
operator|->
name|iov_base
argument_list|,
name|mp
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|vm_fault_unhold_pages
argument_list|(
name|m
argument_list|,
name|totcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|mp
operator|+=
name|count
expr_stmt|;
name|totcount
operator|+=
name|count
expr_stmt|;
name|curbytes
operator|=
name|iov
operator|->
name|iov_len
expr_stmt|;
if|if
condition|(
name|count
operator|!=
name|npages
condition|)
name|curbytes
operator|=
name|count
operator|*
name|PAGE_SIZE
operator|-
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|iov
operator|->
name|iov_base
operator|)
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|totbytes
operator|+=
name|curbytes
expr_stmt|;
block|}
name|uio
operator|->
name|uio_resid
operator|-=
name|totbytes
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns whether a connection should enable DDP.  This happens when all of  * the following conditions are met:  * - the connection's ULP mode is DDP  * - DDP is not already enabled  * - the last receive was above the DDP threshold  * - receive buffers are in user space  * - receive side isn't shutdown (handled by caller)  * - the connection's receive window is big enough so that sizable buffers  *   can be posted without closing the window in the middle of DDP (checked  *   when the connection is offloaded)  */
end_comment

begin_function
specifier|static
name|int
name|so_should_ddp
parameter_list|(
specifier|const
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|last_recv_len
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"ulp_mode=%d last_recv_len=%d ddp_thresh=%d rcv_wnd=%ld ddp_copy_limit=%d\n"
argument_list|,
name|toep
operator|->
name|tp_ulp_mode
argument_list|,
name|last_recv_len
argument_list|,
name|TOM_TUNABLE
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|,
name|ddp_thres
argument_list|)
argument_list|,
name|toep
operator|->
name|tp_tp
operator|->
name|rcv_wnd
argument_list|,
operator|(
name|TOM_TUNABLE
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|,
name|ddp_copy_limit
argument_list|)
operator|+
name|DDP_RSVD_WIN
operator|)
argument_list|)
expr_stmt|;
return|return
name|toep
operator|->
name|tp_ulp_mode
operator|==
name|ULP_MODE_TCPDDP
operator|&&
operator|(
name|toep
operator|->
name|tp_ddp_state
operator|.
name|kbuf
index|[
literal|0
index|]
operator|==
name|NULL
operator|)
operator|&&
name|last_recv_len
operator|>
name|TOM_TUNABLE
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|,
name|ddp_thres
argument_list|)
operator|&&
name|toep
operator|->
name|tp_tp
operator|->
name|rcv_wnd
operator|>
operator|(
name|TOM_TUNABLE
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|,
name|ddp_copy_limit
argument_list|)
operator|+
name|DDP_RSVD_WIN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|is_ddp
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_DDP
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|is_ddp_psh
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
operator|(
name|is_ddp
argument_list|(
name|m
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|DDP_BF_PSH
operator|)
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|m_uiomove
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|int
name|curlen
decl_stmt|,
name|startlen
decl_stmt|,
name|resid_init
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"m_uiomove(m=%p, offset=%d, len=%d, ...)\n"
argument_list|,
name|m
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|startlen
operator|=
name|len
expr_stmt|;
name|resid_init
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
while|while
condition|(
name|m
operator|&&
name|len
condition|)
block|{
name|buf
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|curlen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|offset
operator|&&
operator|(
name|offset
operator|<
name|curlen
operator|)
condition|)
block|{
name|curlen
operator|-=
name|offset
expr_stmt|;
name|buf
operator|+=
name|offset
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
condition|)
block|{
name|offset
operator|-=
name|curlen
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
continue|continue;
block|}
name|err
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|min
argument_list|(
name|len
argument_list|,
name|curlen
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"uiomove returned %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|len
operator|-=
name|min
argument_list|(
name|len
argument_list|,
name|curlen
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"copied %d bytes - resid_init=%d uio_resid=%d\n"
argument_list|,
name|startlen
operator|-
name|len
argument_list|,
name|resid_init
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy data from an sk_buff to an iovec.  Deals with RX_DATA, which carry the  * data in the sk_buff body, and with RX_DATA_DDP, which place the data in a  * DDP buffer.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|copy_data
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|struct
name|iovec
modifier|*
name|to
init|=
name|uio
operator|->
name|uio_iov
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|!
name|is_ddp
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
comment|/* RX_DATA */
return|return
name|m_uiomove
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
return|;
if|if
condition|(
name|__predict_true
argument_list|(
name|m
operator|->
name|m_ddp_flags
operator|&
name|DDP_BF_NOCOPY
argument_list|)
condition|)
block|{
comment|/* user DDP */
name|to
operator|->
name|iov_len
operator|-=
name|len
expr_stmt|;
name|to
operator|->
name|iov_base
operator|=
operator|(
operator|(
name|caddr_t
operator|)
name|to
operator|->
name|iov_base
operator|)
operator|+
name|len
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|=
name|to
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|-=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|err
operator|=
name|t3_ddp_copy
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|uio
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* kernel DDP */
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_wait_dma_completion
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|rwlock
modifier|*
name|lock
decl_stmt|;
name|lock
operator|=
operator|&
name|toep
operator|->
name|tp_tp
operator|->
name|t_inpcb
operator|->
name|inp_lock
expr_stmt|;
name|inp_wlock
argument_list|(
name|toep
operator|->
name|tp_tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|cv_wait_unlock
argument_list|(
operator|&
name|toep
operator|->
name|tp_cv
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_vm_page_to_miov
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|seg_count
decl_stmt|,
name|err
decl_stmt|,
name|type
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|cxgb_dma_info
name|cdi
decl_stmt|;
name|struct
name|mbuf_vec
modifier|*
name|mv
decl_stmt|;
name|struct
name|mbuf_iovec
modifier|*
name|mi
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|err
operator|=
name|bus_dmamap_load_uio
argument_list|(
name|toep
operator|->
name|tp_tx_dmat
argument_list|,
name|toep
operator|->
name|tp_dmamap
argument_list|,
name|uio
argument_list|,
name|cxgb_dma_callback
argument_list|,
operator|&
name|cdi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|seg_count
operator|=
name|cdi
operator|.
name|cdi_nsegs
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|=
name|mcl_alloc
argument_list|(
name|seg_count
argument_list|,
operator|&
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|toep
operator|->
name|tp_tx_dmat
argument_list|,
name|toep
operator|->
name|tp_dmamap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|segs
operator|=
name|cdi
operator|.
name|cdi_segs
expr_stmt|;
name|m0
operator|->
name|m_type
operator|=
name|type
expr_stmt|;
name|m0
operator|->
name|m_flags
operator|=
operator|(
name|M_EXT
operator||
name|M_NOFREE
operator|)
expr_stmt|;
name|m0
operator|->
name|m_ext
operator|.
name|ext_type
operator|=
name|EXT_EXTREF
expr_stmt|;
name|m0
operator|->
name|m_ext
operator|.
name|ext_free
operator|=
name|cxgb_zero_copy_free
expr_stmt|;
name|m0
operator|->
name|m_ext
operator|.
name|ext_args
operator|=
name|NULL
expr_stmt|;
comment|/* XXX: probably wrong /phk */
name|mv
operator|=
name|mtomv
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|mv
operator|->
name|mv_count
operator|=
name|seg_count
expr_stmt|;
name|mv
operator|->
name|mv_first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mi
operator|=
name|mv
operator|->
name|mv_vec
init|;
name|i
operator|<
name|seg_count
condition|;
name|mi
operator|++
operator|,
name|segs
operator|++
operator|,
name|i
operator|++
control|)
name|mi_collapse_sge
argument_list|(
name|mi
argument_list|,
name|segs
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|m0
expr_stmt|;
comment|/* 	 * This appears to be a no-op at the moment 	 * as busdma is all or nothing need to make 	 * sure the tag values are large enough 	 * 	 */
if|if
condition|(
name|cdi
operator|.
name|cdi_mapped
operator|<
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|uio
operator|->
name|uio_resid
operator|-=
name|cdi
operator|.
name|cdi_mapped
expr_stmt|;
block|}
else|else
name|uio
operator|->
name|uio_resid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_sosend
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|int
name|rv
decl_stmt|,
name|count
decl_stmt|,
name|hold_resid
decl_stmt|,
name|sent
decl_stmt|,
name|iovcnt
decl_stmt|;
name|struct
name|iovec
name|iovtmp
index|[
name|TMP_IOV_MAX
index|]
decl_stmt|,
modifier|*
name|iovtmpp
decl_stmt|,
modifier|*
name|iov
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|uio
name|uiotmp
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|snd
decl_stmt|;
comment|/* 	 * Events requiring iteration: 	 *  - number of pages exceeds max hold pages for process or system 	 *  - number of pages exceeds maximum sg entries for a single WR 	 * 	 * We're limited to holding 128 pages at once - and we're limited to 	 * 34 SG entries per work request, but each SG entry can be any number  	 * of contiguous pages 	 * 	 */
name|uiotmp
operator|=
operator|*
name|uio
expr_stmt|;
name|iovcnt
operator|=
name|uio
operator|->
name|uio_iovcnt
expr_stmt|;
name|iov
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
name|sent
operator|=
literal|0
expr_stmt|;
name|snd
operator|=
name|so_sockbuf_snd
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sendmore
label|:
comment|/* 	 * Make sure we don't exceed the socket buffer 	 */
name|count
operator|=
name|min
argument_list|(
name|toep
operator|->
name|tp_page_count
argument_list|,
operator|(
name|sockbuf_sbspace
argument_list|(
name|snd
argument_list|)
operator|>>
name|PAGE_SHIFT
operator|)
operator|+
literal|2
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|rv
operator|=
name|cxgb_hold_iovec_pages
argument_list|(
operator|&
name|uiotmp
argument_list|,
name|toep
operator|->
name|tp_pages
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hold_resid
operator|=
name|uiotmp
operator|.
name|uio_resid
expr_stmt|;
if|if
condition|(
name|rv
condition|)
return|return
operator|(
name|rv
operator|)
return|;
comment|/* 	 * Bump past sent and shave off the unheld amount 	 */
if|if
condition|(
name|hold_resid
operator|>
literal|0
condition|)
block|{
name|iovtmpp
operator|=
name|iovtmp
expr_stmt|;
name|memcpy
argument_list|(
name|iovtmp
argument_list|,
name|iov
argument_list|,
name|iovcnt
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|iov
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
condition|)
name|iov_adj
argument_list|(
operator|&
name|iovtmpp
argument_list|,
operator|&
name|iovcnt
argument_list|,
name|sent
argument_list|)
expr_stmt|;
name|iov_adj
argument_list|(
operator|&
name|iovtmpp
argument_list|,
operator|&
name|iovcnt
argument_list|,
operator|-
name|hold_resid
argument_list|)
expr_stmt|;
name|uiotmp
operator|.
name|uio_iov
operator|=
name|iovtmpp
expr_stmt|;
name|uiotmp
operator|.
name|uio_iovcnt
operator|=
name|iovcnt
expr_stmt|;
block|}
name|uiotmp
operator|.
name|uio_resid
operator|=
name|uio
operator|->
name|uio_resid
operator|-
name|hold_resid
expr_stmt|;
comment|/* 	 * Push off all held pages 	 * 	 */
while|while
condition|(
name|uiotmp
operator|.
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|rv
operator|=
name|cxgb_vm_page_to_miov
argument_list|(
name|toep
argument_list|,
operator|&
name|uiotmp
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|vm_fault_unhold_pages
argument_list|(
name|toep
operator|->
name|tp_pages
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|uio
operator|->
name|uio_resid
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|sent
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|sbappend
argument_list|(
name|snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|t3_push_frames
argument_list|(
name|so
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|iov_adj
argument_list|(
operator|&
name|uiotmp
operator|.
name|uio_iov
argument_list|,
operator|&
name|iovcnt
argument_list|,
name|uiotmp
operator|.
name|uio_resid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for pending I/O to be DMA'd to the card  	 *  	 */
name|cxgb_wait_dma_completion
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|vm_fault_unhold_pages
argument_list|(
name|toep
operator|->
name|tp_pages
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * If there is more data to send adjust local copy of iov 	 * to point to teh start 	 */
if|if
condition|(
name|hold_resid
condition|)
block|{
name|iovtmpp
operator|=
name|iovtmp
expr_stmt|;
name|memcpy
argument_list|(
name|iovtmp
argument_list|,
name|iov
argument_list|,
name|iovcnt
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|iov
argument_list|)
argument_list|)
expr_stmt|;
name|iov_adj
argument_list|(
operator|&
name|iovtmpp
argument_list|,
operator|&
name|iovcnt
argument_list|,
name|sent
argument_list|)
expr_stmt|;
name|uiotmp
operator|=
operator|*
name|uio
expr_stmt|;
name|uiotmp
operator|.
name|uio_iov
operator|=
name|iovtmpp
expr_stmt|;
name|uiotmp
operator|.
name|uio_iovcnt
operator|=
name|iovcnt
expr_stmt|;
goto|goto
name|sendmore
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_sosend
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|top
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tdev
decl_stmt|;
name|int
name|zcopy_thres
decl_stmt|,
name|zcopy_enabled
decl_stmt|,
name|rv
decl_stmt|;
comment|/* 	 * In order to use DMA direct from userspace the following 	 * conditions must be met: 	 *  - the connection is currently offloaded 	 *  - ddp is enabled 	 *  - the number of bytes to be transferred exceeds the threshold 	 *  - the number of bytes currently in flight won't exceed the in-flight 	 *    threshold XXX TODO 	 *  - vm_fault_hold_user_pages succeeds 	 *  - blocking socket XXX for now 	 * 	 */
if|if
condition|(
name|tp
operator|&&
name|tp
operator|->
name|t_flags
operator|&
name|TF_TOE
condition|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|tdev
operator|=
name|toep
operator|->
name|tp_toedev
expr_stmt|;
name|zcopy_thres
operator|=
name|TOM_TUNABLE
argument_list|(
name|tdev
argument_list|,
name|zcopy_sosend_partial_thres
argument_list|)
expr_stmt|;
name|zcopy_enabled
operator|=
name|TOM_TUNABLE
argument_list|(
name|tdev
argument_list|,
name|zcopy_sosend_enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|>
name|zcopy_thres
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_iovcnt
operator|<
name|TMP_IOV_MAX
operator|)
operator|&&
operator|(
operator|(
name|so_state_get
argument_list|(
name|so
argument_list|)
operator|&
name|SS_NBIO
operator|)
operator|==
literal|0
operator|)
operator|&&
name|zcopy_enabled
condition|)
block|{
name|rv
operator|=
name|t3_sosend
argument_list|(
name|so
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|EAGAIN
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
block|}
return|return
name|pru_sosend
argument_list|(
name|so
argument_list|,
name|addr
argument_list|,
name|uio
argument_list|,
name|top
argument_list|,
name|control
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Following replacement or removal of the first mbuf on the first mbuf chain  * of a socket buffer, push necessary state changes back into the socket  * buffer so that other consumers see the values consistently.  'nextrecord'  * is the callers locally stored value of the original value of  * sb->sb_mb->m_nextpkt which must be restored when the lead mbuf changes.  * NOTE: 'nextrecord' may be NULL.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|sockbuf_pushsync
parameter_list|(
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|nextrecord
parameter_list|)
block|{
name|sockbuf_lock_assert
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* 	 * First, update for the new value of nextrecord.  If necessary, make 	 * it the first record. 	 */
if|if
condition|(
name|sb
operator|->
name|sb_mb
operator|!=
name|NULL
condition|)
name|sb
operator|->
name|sb_mb
operator|->
name|m_nextpkt
operator|=
name|nextrecord
expr_stmt|;
else|else
name|sb
operator|->
name|sb_mb
operator|=
name|nextrecord
expr_stmt|;
comment|/*          * Now update any dependent socket buffer fields to reflect the new          * state.  This is an expanded inline of SB_EMPTY_FIXUP(), with the 	 * addition of a second clause that takes care of the case where 	 * sb_mb has been updated, but remains the last record.          */
if|if
condition|(
name|sb
operator|->
name|sb_mb
operator|==
name|NULL
condition|)
block|{
name|sb
operator|->
name|sb_mbtail
operator|=
name|NULL
expr_stmt|;
name|sb
operator|->
name|sb_lastrecord
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|->
name|sb_mb
operator|->
name|m_nextpkt
operator|==
name|NULL
condition|)
name|sb
operator|->
name|sb_lastrecord
operator|=
name|sb
operator|->
name|sb_mb
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IS_NONBLOCKING
parameter_list|(
name|so
parameter_list|)
value|(so_state_get(so)& SS_NBIO)
end_define

begin_function
specifier|static
name|int
name|t3_soreceive
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|int
name|err
decl_stmt|,
name|flags
decl_stmt|,
name|avail
decl_stmt|,
name|len
decl_stmt|,
name|copied
decl_stmt|,
name|copied_unacked
decl_stmt|;
name|int
name|target
decl_stmt|;
comment|/* Read at least this many bytes */
name|int
name|user_ddp_ok
decl_stmt|;
name|struct
name|ddp_state
modifier|*
name|p
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|so_sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|socket_state
decl_stmt|,
name|socket_error
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|rcv
decl_stmt|;
name|avail
operator|=
name|offset
operator|=
name|copied
operator|=
name|copied_unacked
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|flagsp
condition|?
operator|(
operator|*
name|flagsp
operator|&
operator|~
name|MSG_EOR
operator|)
else|:
literal|0
expr_stmt|;
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|err
operator|=
name|sblock
argument_list|(
name|rcv
argument_list|,
name|SBLOCKWAIT
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|toep
operator|->
name|tp_ddp_state
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_TOE
operator|)
operator|==
literal|0
condition|)
block|{
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|err
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done_unlocked
goto|;
block|}
name|p
operator|->
name|user_ddp_pending
operator|=
literal|0
expr_stmt|;
name|restart
label|:
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_TOE
operator|)
operator|==
literal|0
condition|)
block|{
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|err
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done_unlocked
goto|;
block|}
name|len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|m
operator|=
name|rcv
operator|->
name|sb_mb
expr_stmt|;
name|target
operator|=
operator|(
name|flags
operator|&
name|MSG_WAITALL
operator|)
condition|?
name|len
else|:
name|rcv
operator|->
name|sb_lowat
expr_stmt|;
name|user_ddp_ok
operator|=
name|p
operator|->
name|ubuf_ddp_ready
expr_stmt|;
name|p
operator|->
name|cancel_ubuf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|m
condition|)
goto|goto
name|got_mbuf
goto|;
comment|/* empty receive queue */
if|if
condition|(
name|copied
operator|>=
name|target
operator|&&
operator|(
name|rcv
operator|->
name|sb_mb
operator|==
name|NULL
operator|)
operator|&&
operator|!
name|p
operator|->
name|user_ddp_pending
condition|)
goto|goto
name|done
goto|;
name|socket_state
operator|=
name|so_state_get
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|socket_error
operator|=
name|so_error_get
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|copied
condition|)
block|{
if|if
condition|(
name|socket_error
operator|||
name|tp
operator|->
name|t_state
operator|==
name|TCPS_CLOSED
operator|||
operator|(
name|socket_state
operator|&
operator|(
name|SS_ISDISCONNECTING
operator||
name|SS_ISDISCONNECTED
operator|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
else|else
block|{
if|if
condition|(
name|socket_state
operator|&
name|SS_NOFDREF
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|socket_error
condition|)
block|{
name|err
operator|=
name|socket_error
expr_stmt|;
name|socket_error
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|rcv
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|socket_state
operator|&
operator|(
name|SS_ISDISCONNECTING
operator||
name|SS_ISDISCONNECTED
operator|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_CLOSED
condition|)
block|{
name|err
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|rcv
operator|->
name|sb_mb
operator|&&
operator|!
name|p
operator|->
name|user_ddp_pending
condition|)
block|{
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|inp_wlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|t3_cleanup_rbuf
argument_list|(
name|tp
argument_list|,
name|copied_unacked
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|copied_unacked
operator|=
literal|0
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|kbuf
index|[
literal|0
index|]
operator|&&
name|user_ddp_ok
operator|&&
operator|!
name|p
operator|->
name|user_ddp_pending
operator|&&
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|>
name|p
operator|->
name|kbuf
index|[
literal|0
index|]
operator|->
name|dgl_length
operator|&&
name|p
operator|->
name|ubuf_ddp_ready
condition|)
block|{
name|p
operator|->
name|user_ddp_pending
operator|=
operator|!
name|t3_overlay_ubuf
argument_list|(
name|toep
argument_list|,
name|rcv
argument_list|,
name|uio
argument_list|,
name|IS_NONBLOCKING
argument_list|(
name|so
argument_list|)
argument_list|,
name|flags
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|user_ddp_pending
condition|)
block|{
name|p
operator|->
name|kbuf_posted
operator|++
expr_stmt|;
name|user_ddp_ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|kbuf
index|[
literal|0
index|]
operator|&&
operator|(
name|p
operator|->
name|kbuf_posted
operator|==
literal|0
operator|)
condition|)
block|{
name|t3_post_kbuf
argument_list|(
name|toep
argument_list|,
literal|1
argument_list|,
name|IS_NONBLOCKING
argument_list|(
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|kbuf_posted
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|user_ddp_pending
condition|)
block|{
comment|/* One shot at DDP if we already have enough data */
if|if
condition|(
name|copied
operator|>=
name|target
condition|)
name|user_ddp_ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rcv
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
goto|goto
name|done
goto|;
name|CTR0
argument_list|(
name|KTR_TOM
argument_list|,
literal|"ddp pending -- waiting"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|sbwait
argument_list|(
name|rcv
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|//for timers to work			await_ddp_completion(sk, flags,&timeo);
block|}
elseif|else
if|if
condition|(
name|copied
operator|>=
name|target
condition|)
goto|goto
name|done
goto|;
else|else
block|{
if|if
condition|(
name|copied_unacked
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|inp_wlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|t3_cleanup_rbuf
argument_list|(
name|tp
argument_list|,
name|copied_unacked
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|copied_unacked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mp_ncpus
operator|>
literal|1
condition|)
while|while
condition|(
name|i
operator|++
operator|<
literal|200
operator|&&
name|rcv
operator|->
name|sb_mb
operator|==
name|NULL
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rcv
operator|->
name|sb_mb
condition|)
goto|goto
name|restart
goto|;
if|if
condition|(
name|rcv
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
goto|goto
name|done
goto|;
name|CTR0
argument_list|(
name|KTR_TOM
argument_list|,
literal|"no buffers -- waiting"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|sbwait
argument_list|(
name|rcv
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
goto|goto
name|restart
goto|;
name|got_mbuf
label|:
comment|/* 	 * Adjust the mbuf seqno if it has already been partially processed by 	 * soreceive_generic 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|!=
name|m
operator|->
name|m_len
condition|)
block|{
name|m
operator|->
name|m_seq
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|CTR6
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_soreceive: ddp_flags=0x%x m_len=%u resid=%u "
literal|"m_seq=0x%08x c_seq=0x%08x c_unack=%u"
argument_list|,
operator|(
name|is_ddp
argument_list|(
name|m
argument_list|)
condition|?
name|m
operator|->
name|m_ddp_flags
else|:
literal|0
operator|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|len
argument_list|,
name|m
operator|->
name|m_seq
argument_list|,
name|toep
operator|->
name|tp_copied_seq
argument_list|,
name|copied_unacked
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|==
name|EXT_EXTREF
operator|)
operator|)
operator|||
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
argument_list|,
operator|(
literal|"unexpected type M_EXT=%d ext_type=%d m_len=%d m_pktlen=%d\n"
operator|,
operator|!
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|,
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|,
name|m
operator|->
name|m_len
operator|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_next
operator|!=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0xffffffff
argument_list|,
operator|(
literal|"bad next value m_next=%p m_nextpkt=%p"
literal|" m_flags=0x%x m->m_len=%d"
operator|,
name|m
operator|->
name|m_next
operator|,
name|m
operator|->
name|m_nextpkt
operator|,
name|m
operator|->
name|m_flags
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_ddp_flags
operator|&
name|DDP_BF_NOCOPY
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"empty mbuf and NOCOPY not set\n"
argument_list|)
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_TOM
argument_list|,
literal|"ddp done notification"
argument_list|)
expr_stmt|;
name|p
operator|->
name|user_ddp_pending
operator|=
literal|0
expr_stmt|;
name|sbdroprecord_locked
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|KASSERT
argument_list|(
call|(
name|int32_t
call|)
argument_list|(
name|toep
operator|->
name|tp_copied_seq
operator|+
name|copied_unacked
operator|-
name|m
operator|->
name|m_seq
argument_list|)
operator|>=
literal|0
argument_list|,
operator|(
literal|"offset will go negative: offset=%d copied_seq=0x%08x copied_unacked=%d m_seq=0x%08x"
operator|,
name|offset
operator|,
name|toep
operator|->
name|tp_copied_seq
operator|,
name|copied_unacked
operator|,
name|m
operator|->
name|m_seq
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|toep
operator|->
name|tp_copied_seq
operator|+
name|copied_unacked
operator|-
name|m
operator|->
name|m_seq
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
name|panic
argument_list|(
literal|"t3_soreceive: OFFSET>= LEN offset %d copied_seq 0x%x "
literal|"seq 0x%x pktlen %d ddp flags 0x%x"
argument_list|,
name|offset
argument_list|,
name|toep
operator|->
name|tp_copied_seq
operator|+
name|copied_unacked
argument_list|,
name|m
operator|->
name|m_seq
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|m
operator|->
name|m_ddp_flags
argument_list|)
expr_stmt|;
name|avail
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|avail
condition|)
block|{
if|if
condition|(
name|is_ddp
argument_list|(
name|m
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|m_ddp_flags
operator|&
name|DDP_BF_NOCOPY
operator|)
condition|)
name|panic
argument_list|(
literal|"bad state in t3_soreceive len=%d avail=%d offset=%d\n"
argument_list|,
name|len
argument_list|,
name|avail
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|avail
operator|=
name|len
expr_stmt|;
name|rcv
operator|->
name|sb_flags
operator||=
name|SB_IN_TOE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|kbuf_posted
operator|==
literal|0
operator|&&
name|p
operator|->
name|user_ddp_pending
operator|==
literal|0
condition|)
name|rcv
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_IN_TOE
expr_stmt|;
ifdef|#
directive|ifdef
name|URGENT_DATA_SUPPORTED
comment|/* 	 * Check if the data we are preparing to copy contains urgent 	 * data.  Either stop short of urgent data or skip it if it's 	 * first and we are not delivering urgent data inline. 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|toep
operator|->
name|tp_urg_data
argument_list|)
condition|)
block|{
name|uint32_t
name|urg_offset
init|=
name|tp
operator|->
name|rcv_up
operator|-
name|tp
operator|->
name|copied_seq
operator|+
name|copied_unacked
decl_stmt|;
if|if
condition|(
name|urg_offset
operator|<
name|avail
condition|)
block|{
if|if
condition|(
name|urg_offset
condition|)
block|{
comment|/* stop short of the urgent data */
name|avail
operator|=
name|urg_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|so_options_get
argument_list|(
name|so
argument_list|)
operator|&
name|SO_OOBINLINE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* First byte is urgent, skip */
name|toep
operator|->
name|tp_copied_seq
operator|++
expr_stmt|;
name|offset
operator|++
expr_stmt|;
name|avail
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|avail
condition|)
goto|goto
name|skip_copy
goto|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|is_ddp_psh
argument_list|(
name|m
argument_list|)
operator|||
name|offset
operator|||
operator|(
name|rcv
operator|->
name|sb_mb
operator|&&
operator|!
name|is_ddp
argument_list|(
name|m
argument_list|)
operator|)
condition|)
block|{
name|user_ddp_ok
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE0
argument_list|(
name|TIDTB
argument_list|(
name|so
argument_list|)
argument_list|,
literal|"t3_sosend: PSH"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|user_ddp_ok
operator|&&
operator|!
name|p
operator|->
name|user_ddp_pending
operator|&&
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|>
name|p
operator|->
name|kbuf
index|[
literal|0
index|]
operator|->
name|dgl_length
operator|&&
name|p
operator|->
name|ubuf_ddp_ready
condition|)
block|{
name|p
operator|->
name|user_ddp_pending
operator|=
operator|!
name|t3_overlay_ubuf
argument_list|(
name|toep
argument_list|,
name|rcv
argument_list|,
name|uio
argument_list|,
name|IS_NONBLOCKING
argument_list|(
name|so
argument_list|)
argument_list|,
name|flags
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|user_ddp_pending
condition|)
block|{
name|p
operator|->
name|kbuf_posted
operator|++
expr_stmt|;
name|user_ddp_ok
operator|=
literal|0
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"user_ddp_pending=%d\n"
argument_list|,
name|p
operator|->
name|user_ddp_pending
argument_list|)
expr_stmt|;
block|}
else|else
name|DPRINTF
argument_list|(
literal|"user_ddp_ok=%d user_ddp_pending=%d iov_len=%ld dgl_length=%d ubuf_ddp_ready=%d ulp_mode=%d is_ddp(m)=%d flags=0x%x ubuf=%p kbuf_posted=%d\n"
argument_list|,
name|user_ddp_ok
argument_list|,
name|p
operator|->
name|user_ddp_pending
argument_list|,
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
argument_list|,
name|p
operator|->
name|kbuf
index|[
literal|0
index|]
condition|?
name|p
operator|->
name|kbuf
index|[
literal|0
index|]
operator|->
name|dgl_length
else|:
literal|0
argument_list|,
name|p
operator|->
name|ubuf_ddp_ready
argument_list|,
name|toep
operator|->
name|tp_ulp_mode
argument_list|,
operator|!
operator|!
name|is_ddp
argument_list|(
name|m
argument_list|)
argument_list|,
name|m
operator|->
name|m_ddp_flags
argument_list|,
name|p
operator|->
name|ubuf
argument_list|,
name|p
operator|->
name|kbuf_posted
argument_list|)
expr_stmt|;
comment|/* 	 * If MSG_TRUNC is specified the data is discarded. 	 * XXX need to check pr_atomic 	 */
name|KASSERT
argument_list|(
name|avail
operator|>
literal|0
argument_list|,
operator|(
literal|"avail=%d resid=%d offset=%d"
operator|,
name|avail
operator|,
name|uio
operator|->
name|uio_resid
operator|,
name|offset
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|MSG_TRUNC
operator|)
argument_list|)
condition|)
block|{
name|int
name|resid
init|=
name|uio
operator|->
name|uio_resid
decl_stmt|;
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|copy_data
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|avail
argument_list|,
name|uio
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|err
condition|)
name|err
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done_unlocked
goto|;
block|}
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|!=
operator|(
name|resid
operator|-
name|uio
operator|->
name|uio_resid
operator|)
condition|)
name|printf
argument_list|(
literal|"didn't copy all bytes :-/ avail=%d offset=%d pktlen=%d resid=%d uio_resid=%d copied=%d copied_unacked=%d is_ddp(m)=%d\n"
argument_list|,
name|avail
argument_list|,
name|offset
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|resid
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|copied
argument_list|,
name|copied_unacked
argument_list|,
name|is_ddp
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_TOE
operator|)
operator|==
literal|0
condition|)
block|{
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|err
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done_unlocked
goto|;
block|}
block|}
name|copied
operator|+=
name|avail
expr_stmt|;
name|copied_unacked
operator|+=
name|avail
expr_stmt|;
name|len
operator|-=
name|avail
expr_stmt|;
ifdef|#
directive|ifdef
name|URGENT_DATA_SUPPORTED
name|skip_copy
label|:
if|if
condition|(
name|tp
operator|->
name|urg_data
operator|&&
name|after
argument_list|(
name|tp
operator|->
name|copied_seq
operator|+
name|copied_unacked
argument_list|,
name|tp
operator|->
name|urg_seq
argument_list|)
condition|)
name|tp
operator|->
name|urg_data
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If the buffer is fully consumed free it.  If it's a DDP 	 * buffer also handle any events it indicates. 	 */
if|if
condition|(
name|avail
operator|+
name|offset
operator|>=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|unsigned
name|int
name|fl
init|=
name|m
operator|->
name|m_ddp_flags
decl_stmt|;
name|int
name|exitnow
decl_stmt|,
name|got_psh
init|=
literal|0
decl_stmt|,
name|nomoredata
init|=
literal|0
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nextrecord
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|kbuf
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|is_ddp
argument_list|(
name|m
argument_list|)
operator|&&
operator|(
name|fl
operator|&
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|is_ddp_psh
argument_list|(
name|m
argument_list|)
operator|&&
name|p
operator|->
name|user_ddp_pending
condition|)
name|got_psh
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fl
operator|&
name|DDP_BF_NOCOPY
condition|)
name|p
operator|->
name|user_ddp_pending
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fl
operator|&
name|DDP_BF_NODATA
operator|)
operator|&&
name|IS_NONBLOCKING
argument_list|(
name|so
argument_list|)
condition|)
block|{
name|p
operator|->
name|kbuf_posted
operator|--
expr_stmt|;
name|nomoredata
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|kbuf_posted
operator|--
expr_stmt|;
name|p
operator|->
name|ubuf_ddp_ready
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|nextrecord
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|count
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|count
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|==
name|EXT_EXTREF
operator|)
operator|)
operator|||
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
argument_list|,
operator|(
literal|"unexpected type M_EXT=%d ext_type=%d m_len=%d\n"
operator|,
operator|!
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|,
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_TOM
argument_list|,
literal|"freeing mbuf m_len = %d pktlen = %d"
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|sbfree
argument_list|(
name|rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|rcv
operator|->
name|sb_mb
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|rcv
operator|->
name|sb_mb
expr_stmt|;
block|}
name|sockbuf_pushsync
argument_list|(
name|rcv
argument_list|,
name|nextrecord
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|sbdrop_locked(rcv, m->m_pkthdr.len);
endif|#
directive|endif
name|exitnow
operator|=
name|got_psh
operator|||
name|nomoredata
expr_stmt|;
if|if
condition|(
name|copied
operator|>=
name|target
operator|&&
operator|(
name|rcv
operator|->
name|sb_mb
operator|==
name|NULL
operator|)
operator|&&
name|exitnow
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|copied_unacked
operator|>
operator|(
name|rcv
operator|->
name|sb_hiwat
operator|>>
literal|2
operator|)
condition|)
block|{
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|inp_wlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|t3_cleanup_rbuf
argument_list|(
name|tp
argument_list|,
name|copied_unacked
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|copied_unacked
operator|=
literal|0
expr_stmt|;
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
goto|goto
name|restart
goto|;
name|done
label|:
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_TOE
operator|)
operator|==
literal|0
condition|)
block|{
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|err
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done_unlocked
goto|;
block|}
comment|/* 	 * If we can still receive decide what to do in preparation for the 	 * next receive.  Note that RCV_SHUTDOWN is set if the connection 	 * transitioned to CLOSE but not if it was in that state to begin with. 	 */
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|so_state_get
argument_list|(
name|so
argument_list|)
operator|&
operator|(
name|SS_ISDISCONNECTING
operator||
name|SS_ISDISCONNECTED
operator|)
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|user_ddp_pending
condition|)
block|{
name|user_ddp_ok
operator|=
literal|0
expr_stmt|;
name|t3_cancel_ubuf
argument_list|(
name|toep
argument_list|,
name|rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcv
operator|->
name|sb_mb
condition|)
block|{
if|if
condition|(
name|copied
operator|<
literal|0
condition|)
name|copied
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
goto|goto
name|restart
goto|;
block|}
name|p
operator|->
name|user_ddp_pending
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|->
name|kbuf
index|[
literal|0
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|p
operator|->
name|kbuf_posted
operator|==
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE0
argument_list|(
name|TIDTB
argument_list|(
name|so
argument_list|)
argument_list|,
literal|"chelsio_recvmsg: about to exit, repost kbuf"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t3_post_kbuf
argument_list|(
name|toep
argument_list|,
literal|1
argument_list|,
name|IS_NONBLOCKING
argument_list|(
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|kbuf_posted
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|so_should_ddp
argument_list|(
name|toep
argument_list|,
name|copied
argument_list|)
operator|&&
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|1
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_TOM
argument_list|,
literal|"entering ddp on tid=%u"
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t3_enter_ddp
argument_list|(
name|toep
argument_list|,
name|TOM_TUNABLE
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|,
name|ddp_copy_limit
argument_list|)
argument_list|,
literal|0
argument_list|,
name|IS_NONBLOCKING
argument_list|(
name|so
argument_list|)
argument_list|)
condition|)
block|{
name|rcv
operator|->
name|sb_flags
operator||=
name|SB_IN_TOE
expr_stmt|;
name|p
operator|->
name|kbuf_posted
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE5
argument_list|(
name|TIDTB
argument_list|(
name|so
argument_list|)
argument_list|,
literal|"chelsio_recvmsg<-: copied %d len %d buffers_freed %d "
literal|"kbuf_posted %d user_ddp_pending %u"
argument_list|,
name|copied
argument_list|,
name|len
argument_list|,
name|buffers_freed
argument_list|,
name|p
condition|?
name|p
operator|->
name|kbuf_posted
else|:
operator|-
literal|1
argument_list|,
name|p
operator|->
name|user_ddp_pending
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|done_unlocked
label|:
if|if
condition|(
name|copied_unacked
operator|&&
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_TOE
operator|)
condition|)
block|{
name|inp_wlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|t3_cleanup_rbuf
argument_list|(
name|tp
argument_list|,
name|copied_unacked
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|sbunlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_soreceive
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|psa
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
block|{
name|struct
name|toedev
modifier|*
name|tdev
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|zcopy_thres
decl_stmt|,
name|zcopy_enabled
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|rcv
init|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|flags
operator|=
name|flagsp
condition|?
operator|*
name|flagsp
operator|&
operator|~
name|MSG_EOR
else|:
literal|0
expr_stmt|;
comment|/* 	 * In order to use DMA direct from userspace the following 	 * conditions must be met: 	 *  - the connection is currently offloaded 	 *  - ddp is enabled 	 *  - the number of bytes to be transferred exceeds the threshold 	 *  - the number of bytes currently in flight won't exceed the in-flight 	 *    threshold XXX TODO 	 *  - vm_fault_hold_user_pages succeeds 	 *  - blocking socket XXX for now 	 *  - iovcnt is 1 	 * 	 */
if|if
condition|(
name|tp
operator|&&
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_TOE
operator|)
operator|&&
name|uio
operator|&&
operator|(
operator|(
name|flags
operator|&
operator|(
name|MSG_OOB
operator||
name|MSG_PEEK
operator||
name|MSG_DONTWAIT
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|1
operator|)
operator|&&
operator|(
name|mp0
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|rcv
operator|->
name|sb_flags
operator|&
name|SB_IN_TOE
operator|)
operator|||
operator|(
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|tdev
operator|=
name|toep
operator|->
name|tp_toedev
expr_stmt|;
name|zcopy_thres
operator|=
name|TOM_TUNABLE
argument_list|(
name|tdev
argument_list|,
name|ddp_thres
argument_list|)
expr_stmt|;
name|zcopy_enabled
operator|=
name|TOM_TUNABLE
argument_list|(
name|tdev
argument_list|,
name|ddp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rcv
operator|->
name|sb_flags
operator|&
name|SB_IN_TOE
operator|)
operator|||
operator|(
operator|(
name|uio
operator|->
name|uio_resid
operator|>
name|zcopy_thres
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|1
operator|)
operator|&&
name|zcopy_enabled
operator|)
condition|)
block|{
name|CTR4
argument_list|(
name|KTR_TOM
argument_list|,
literal|"cxgb_soreceive: sb_flags=0x%x t_flags=0x%x flags=0x%x uio_resid=%d"
argument_list|,
name|rcv
operator|->
name|sb_flags
argument_list|,
name|tp
operator|->
name|t_flags
argument_list|,
name|flags
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|rv
operator|=
name|t3_soreceive
argument_list|(
name|so
argument_list|,
name|flagsp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|EAGAIN
condition|)
return|return
operator|(
name|rv
operator|)
return|;
else|else
name|printf
argument_list|(
literal|"returned EAGAIN\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tp
operator|&&
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_TOE
operator|)
operator|&&
name|uio
operator|&&
name|mp0
operator|==
name|NULL
condition|)
block|{
name|struct
name|sockbuf
modifier|*
name|rcv
init|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"skipping t3_soreceive flags=0x%x iovcnt=%d sb_state=0x%x\n"
argument_list|,
name|flags
argument_list|,
name|uio
operator|->
name|uio_iovcnt
argument_list|,
name|rcv
operator|->
name|sb_state
argument_list|)
expr_stmt|;
block|}
return|return
name|pru_soreceive
argument_list|(
name|so
argument_list|,
name|psa
argument_list|,
name|uio
argument_list|,
name|mp0
argument_list|,
name|controlp
argument_list|,
name|flagsp
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|protosw
name|cxgb_protosw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pr_usrreqs
name|cxgb_tcp_usrreqs
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|t3_install_socket_ops
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
specifier|static
name|int
name|copied
init|=
literal|0
decl_stmt|;
name|struct
name|pr_usrreqs
modifier|*
name|pru
decl_stmt|;
name|struct
name|protosw
modifier|*
name|psw
decl_stmt|;
if|if
condition|(
name|copied
operator|==
literal|0
condition|)
block|{
name|psw
operator|=
name|so_protosw_get
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|pru
operator|=
name|psw
operator|->
name|pr_usrreqs
expr_stmt|;
name|bcopy
argument_list|(
name|psw
argument_list|,
operator|&
name|cxgb_protosw
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|psw
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|pru
argument_list|,
operator|&
name|cxgb_tcp_usrreqs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pru
argument_list|)
argument_list|)
expr_stmt|;
name|cxgb_protosw
operator|.
name|pr_ctloutput
operator|=
name|t3_ctloutput
expr_stmt|;
name|cxgb_protosw
operator|.
name|pr_usrreqs
operator|=
operator|&
name|cxgb_tcp_usrreqs
expr_stmt|;
name|cxgb_tcp_usrreqs
operator|.
name|pru_sosend
operator|=
name|cxgb_sosend
expr_stmt|;
name|cxgb_tcp_usrreqs
operator|.
name|pru_soreceive
operator|=
name|cxgb_soreceive
expr_stmt|;
block|}
name|so_protosw_set
argument_list|(
name|so
argument_list|,
operator|&
name|cxgb_protosw
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|so->so_proto->pr_usrreqs->pru_sosend = cxgb_sosend; 	so->so_proto->pr_usrreqs->pru_soreceive = cxgb_soreceive;
endif|#
directive|endif
block|}
end_function

end_unit

