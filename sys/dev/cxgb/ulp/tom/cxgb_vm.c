begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007-2008, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<ulp/tom/cxgb_vm.h>
end_include

begin_comment
comment|/*  * This routine takes a user's map, array of pages, number of pages, and flags  * and then does the following:  *  - validate that the user has access to those pages (flags indicates read  *	or write) - if not fail  *  - validate that count is enough to hold range number of pages - if not fail  *  - fault in any non-resident pages  *  - if the user is doing a read force a write fault for any COWed pages  *  - if the user is doing a read mark all pages as dirty  *  - hold all pages  */
end_comment

begin_function
name|int
name|vm_fault_hold_user_pages
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_page_t
modifier|*
name|mp
parameter_list|,
name|int
name|count
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|end
decl_stmt|,
name|va
decl_stmt|;
name|int
name|faults
decl_stmt|,
name|rv
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
modifier|*
name|pages
decl_stmt|;
name|pmap
operator|=
name|vm_map_pmap
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|pages
operator|=
name|mp
expr_stmt|;
name|addr
operator|&=
operator|~
name|PAGE_MASK
expr_stmt|;
comment|/* 	 * Check that virtual address range is legal 	 * This check is somewhat bogus as on some architectures kernel 	 * and user do not share VA - however, it appears that all FreeBSD 	 * architectures define it 	 */
name|end
operator|=
name|addr
operator|+
operator|(
name|count
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|VM_MAXUSER_ADDRESS
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"bad address passed to vm_fault_hold_user_pages"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* 	 * First optimistically assume that all pages are resident  	 * (and R/W if for write) if so just mark pages as held (and  	 * dirty if for write) and return 	 */
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
for|for
control|(
name|pages
operator|=
name|mp
operator|,
name|faults
operator|=
literal|0
operator|,
name|va
operator|=
name|addr
init|;
name|va
operator|<
name|end
condition|;
name|va
operator|+=
name|PAGE_SIZE
operator|,
name|pages
operator|++
control|)
block|{
comment|/* 		 * page queue mutex is recursable so this is OK 		 * it would be really nice if we had an unlocked 		 * version of this so we were only acquiring the  		 * pmap lock 1 time as opposed to potentially 		 * many dozens of times 		 */
operator|*
name|pages
operator|=
name|m
operator|=
name|pmap_extract_and_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|faults
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Preemptively mark dirty - the pages 		 * will never have the modified bit set if 		 * they are only changed via DMA 		 */
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
name|faults
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Pages either have insufficient permissions or are not present 	 * trigger a fault where neccessary 	 *  	 */
name|rv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pages
operator|=
name|mp
operator|,
name|va
operator|=
name|addr
init|;
name|va
operator|<
name|end
condition|;
name|va
operator|+=
name|PAGE_SIZE
operator|,
name|pages
operator|++
control|)
block|{
comment|/* 		 * Account for a very narrow race where the page may be 		 * taken away from us before it is held 		 */
while|while
condition|(
operator|*
name|pages
operator|==
name|NULL
condition|)
block|{
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|prot
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|error
goto|;
operator|*
name|pages
operator|=
name|pmap_extract_and_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|prot
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vm_fault bad return rv=%d va=0x%zx\n"
argument_list|,
name|rv
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
for|for
control|(
name|pages
operator|=
name|mp
operator|,
name|va
operator|=
name|addr
init|;
name|va
operator|<
name|end
condition|;
name|va
operator|+=
name|PAGE_SIZE
operator|,
name|pages
operator|++
control|)
if|if
condition|(
operator|*
name|pages
condition|)
block|{
name|vm_page_unhold
argument_list|(
operator|*
name|pages
argument_list|)
expr_stmt|;
operator|*
name|pages
operator|=
name|NULL
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vm_fault_unhold_pages
parameter_list|(
name|vm_page_t
modifier|*
name|mp
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|count
operator|>=
literal|0
argument_list|,
operator|(
literal|"negative count %d"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|vm_page_unhold
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|++
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

