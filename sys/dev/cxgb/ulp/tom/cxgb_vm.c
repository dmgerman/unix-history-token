begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<ulp/tom/cxgb_vm.h>
end_include

begin_define
define|#
directive|define
name|TRACE_ENTER
value|printf("%s:%s entered", __FUNCTION__, __FILE__)
end_define

begin_define
define|#
directive|define
name|TRACE_EXIT
value|printf("%s:%s:%d exited", __FUNCTION__, __FILE__, __LINE__)
end_define

begin_comment
comment|/*  * This routine takes a user address range and does the following:  *  - validate that the user has access to those pages (flags indicates read or write) - if not fail  *  - validate that count is enough to hold range number of pages - if not fail  *  - fault in any non-resident pages  *  - if the user is doing a read force a write fault for any COWed pages  *  - if the user is doing a read mark all pages as dirty  *  - hold all pages  *  - return number of pages in count  */
end_comment

begin_function
name|int
name|vm_fault_hold_user_pages
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|,
name|vm_page_t
modifier|*
name|mp
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_offset_t
name|end
decl_stmt|,
name|va
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|int
name|faults
decl_stmt|,
name|rv
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
modifier|*
name|pages
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
comment|/* 	 * Check that virtual address range is legal 	 * This check is somewhat bogus as on some architectures kernel 	 * and user do not share VA - however, it appears that all FreeBSD 	 * architectures define it 	 */
name|end
operator|=
name|addr
operator|+
operator|(
name|count
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|VM_MAXUSER_ADDRESS
condition|)
block|{
name|printf
argument_list|(
literal|"bad address passed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|td
operator|=
name|curthread
expr_stmt|;
name|map
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|pmap
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
name|pages
operator|=
name|mp
expr_stmt|;
name|prot
operator|=
name|VM_PROT_READ
expr_stmt|;
name|prot
operator||=
operator|(
name|flags
operator|&
name|VM_HOLD_WRITEABLE
operator|)
condition|?
name|VM_PROT_WRITE
else|:
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|pages
argument_list|,
sizeof|sizeof
argument_list|(
name|vm_page_t
operator|*
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|retry
label|:
comment|/* 	 * First optimistically assume that all pages are resident (and R/W if for write) 	 * if so just mark pages as held (and dirty if for write) and return 	 */
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
for|for
control|(
name|pages
operator|=
name|mp
operator|,
name|faults
operator|=
literal|0
operator|,
name|va
operator|=
name|addr
init|;
name|va
operator|<
name|end
condition|;
name|va
operator|+=
name|PAGE_SIZE
operator|,
name|pages
operator|++
control|)
block|{
comment|/* 		 * Assure that we only hold the page once 		 */
if|if
condition|(
operator|*
name|pages
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * page queue mutex is recursable so this is OK 			 * it would be really nice if we had an unlocked version of this so 			 * we were only acquiring the pmap lock 1 time as opposed to potentially 			 * many dozens of times 			 */
name|m
operator|=
name|pmap_extract_and_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|faults
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|pages
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VM_HOLD_WRITEABLE
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
name|faults
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Pages either have insufficient permissions or are not present 	 * trigger a fault where neccessary 	 *  	 */
for|for
control|(
name|va
operator|=
name|addr
init|;
name|va
operator|<
name|end
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
name|pa
operator|=
name|pmap_extract
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pa
condition|)
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VM_HOLD_WRITEABLE
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_WRITEABLE
operator|)
operator|==
literal|0
condition|)
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|VM_PROT_WRITE
argument_list|,
name|VM_FAULT_DIRTY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|VM_PROT_READ
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|printf
argument_list|(
literal|"vm_fault bad return rv=%d va=0x%zx\n"
argument_list|,
name|rv
argument_list|,
name|va
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
goto|goto
name|retry
goto|;
name|error
label|:
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
for|for
control|(
name|pages
operator|=
name|mp
operator|,
name|va
operator|=
name|addr
init|;
name|va
operator|<
name|end
condition|;
name|va
operator|+=
name|PAGE_SIZE
operator|,
name|pages
operator|++
control|)
if|if
condition|(
operator|*
name|pages
condition|)
name|vm_page_unhold
argument_list|(
operator|*
name|pages
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vm_fault_unhold_pages
parameter_list|(
name|vm_page_t
modifier|*
name|mp
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|count
operator|>=
literal|0
argument_list|,
operator|(
literal|"negative count %d"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|vm_page_unhold
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|++
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

