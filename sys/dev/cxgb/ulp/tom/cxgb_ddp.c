begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007-2008, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockstate.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_osdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/sys/mbufq.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tcp_offload.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_offload.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/t3cdev.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_firmware_exports.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_t3_cpl.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_tcb.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_ctl_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_offload.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/sys/mvec.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/toecore/cxgb_toedev.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tom.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_t3_ddp.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_toepcb.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tcp.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_vm.h>
end_include

begin_define
define|#
directive|define
name|MAX_SCHEDULE_TIMEOUT
value|300
end_define

begin_comment
comment|/*  * Return the # of page pods needed to accommodate a # of pages.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|pages2ppods
parameter_list|(
name|unsigned
name|int
name|pages
parameter_list|)
block|{
return|return
operator|(
name|pages
operator|+
name|PPOD_PAGES
operator|-
literal|1
operator|)
operator|/
name|PPOD_PAGES
operator|+
name|NUM_SENTINEL_PPODS
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_pin_pages - pin a user memory range and prepare it for DDP  *	@addr - the starting address  *	@len - the length of the range  *	@newgl - contains the pages and physical addresses of the pinned range  *	@gl - an existing gather list, may be %NULL  *  *	Pins the pages in the user-space memory range [addr, addr + len) and  *	maps them for DMA.  Returns a gather list with the pinned pages and  *	their physical addresses.  If @gl is non NULL the pages it describes  *	are compared against the pages for [addr, addr + len), and if the  *	existing gather list already covers the range a new list is not  *	allocated.  Returns 0 on success, or a negative errno.  On success if  *	a new gather list was allocated it is returned in @newgl.  */
end_comment

begin_function
specifier|static
name|int
name|t3_pin_pages
parameter_list|(
name|bus_dma_tag_t
name|tag
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|ddp_gather_list
modifier|*
modifier|*
name|newgl
parameter_list|,
specifier|const
name|struct
name|ddp_gather_list
modifier|*
name|gl
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|err
decl_stmt|;
name|size_t
name|pg_off
decl_stmt|;
name|unsigned
name|int
name|npages
decl_stmt|;
name|struct
name|ddp_gather_list
modifier|*
name|p
decl_stmt|;
comment|/* 	 * XXX need x86 agnostic check 	 */
if|if
condition|(
name|addr
operator|+
name|len
operator|>
name|VM_MAXUSER_ADDRESS
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|pg_off
operator|=
name|addr
operator|&
name|PAGE_MASK
expr_stmt|;
name|npages
operator|=
operator|(
name|pg_off
operator|+
name|len
operator|+
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ddp_gather_list
argument_list|)
operator|+
name|npages
operator|*
sizeof|sizeof
argument_list|(
name|vm_page_t
operator|*
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|err
operator|=
name|vm_fault_hold_user_pages
argument_list|(
name|addr
argument_list|,
name|p
operator|->
name|dgl_pages
argument_list|,
name|npages
argument_list|,
name|VM_HOLD_WRITEABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|free_gl
goto|;
if|if
condition|(
name|gl
operator|&&
name|gl
operator|->
name|dgl_offset
operator|==
name|pg_off
operator|&&
name|gl
operator|->
name|dgl_nelem
operator|>=
name|npages
operator|&&
name|gl
operator|->
name|dgl_length
operator|>=
name|len
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|dgl_pages
index|[
name|i
index|]
operator|!=
name|gl
operator|->
name|dgl_pages
index|[
name|i
index|]
condition|)
goto|goto
name|different_gl
goto|;
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|unpin
goto|;
block|}
name|different_gl
label|:
name|p
operator|->
name|dgl_length
operator|=
name|len
expr_stmt|;
name|p
operator|->
name|dgl_offset
operator|=
name|pg_off
expr_stmt|;
name|p
operator|->
name|dgl_nelem
operator|=
name|npages
expr_stmt|;
ifdef|#
directive|ifdef
name|NEED_BUSDMA
name|p
operator|->
name|phys_addr
index|[
literal|0
index|]
operator|=
name|pci_map_page
argument_list|(
name|pdev
argument_list|,
name|p
operator|->
name|pages
index|[
literal|0
index|]
argument_list|,
name|pg_off
argument_list|,
name|PAGE_SIZE
operator|-
name|pg_off
argument_list|,
name|PCI_DMA_FROMDEVICE
argument_list|)
operator|-
name|pg_off
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npages
condition|;
operator|++
name|i
control|)
name|p
operator|->
name|phys_addr
index|[
name|i
index|]
operator|=
name|pci_map_page
argument_list|(
name|pdev
argument_list|,
name|p
operator|->
name|pages
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PCI_DMA_FROMDEVICE
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|newgl
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|unpin
label|:
name|vm_fault_unhold_pages
argument_list|(
name|p
operator|->
name|dgl_pages
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|free_gl
label|:
name|free
argument_list|(
name|p
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
operator|*
name|newgl
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unmap_ddp_gl
parameter_list|(
specifier|const
name|struct
name|ddp_gather_list
modifier|*
name|gl
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NEED_BUSDMA
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|gl
operator|->
name|nelem
condition|)
return|return;
name|pci_unmap_page
argument_list|(
name|pdev
argument_list|,
name|gl
operator|->
name|phys_addr
index|[
literal|0
index|]
operator|+
name|gl
operator|->
name|offset
argument_list|,
name|PAGE_SIZE
operator|-
name|gl
operator|->
name|offset
argument_list|,
name|PCI_DMA_FROMDEVICE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|gl
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
name|pci_unmap_page
argument_list|(
name|pdev
argument_list|,
name|gl
operator|->
name|phys_addr
index|[
name|i
index|]
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PCI_DMA_FROMDEVICE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|ddp_gl_free_pages
parameter_list|(
name|struct
name|ddp_gather_list
modifier|*
name|gl
parameter_list|,
name|int
name|dirty
parameter_list|)
block|{
comment|/* 	 * XXX mark pages as dirty before unholding  	 */
name|vm_fault_unhold_pages
argument_list|(
name|gl
operator|->
name|dgl_pages
argument_list|,
name|gl
operator|->
name|dgl_nelem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_free_ddp_gl
parameter_list|(
name|struct
name|ddp_gather_list
modifier|*
name|gl
parameter_list|)
block|{
name|unmap_ddp_gl
argument_list|(
name|gl
argument_list|)
expr_stmt|;
name|ddp_gl_free_pages
argument_list|(
name|gl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gl
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Max # of page pods for a buffer, enough for 1MB buffer at 4KB page size */
end_comment

begin_define
define|#
directive|define
name|MAX_PPODS
value|64U
end_define

begin_comment
comment|/*  * Allocate page pods for DDP buffer 1 (the user buffer) and set up the tag in  * the TCB.  We allocate page pods in multiples of PPOD_CLUSTER_SIZE.  First we  * try to allocate enough page pods to accommodate the whole buffer, subject to  * the MAX_PPODS limit.  If that fails we try to allocate PPOD_CLUSTER_SIZE page  * pods before failing entirely.  */
end_comment

begin_function
specifier|static
name|int
name|alloc_buf1_ppods
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|ddp_state
modifier|*
name|p
parameter_list|,
name|unsigned
name|long
name|addr
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|tag
decl_stmt|,
name|npages
decl_stmt|,
name|nppods
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|d
init|=
name|TOM_DATA
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|SOCKBUF_LOCK_ASSERT(&so->so_rcv);
endif|#
directive|endif
name|npages
operator|=
operator|(
operator|(
name|addr
operator|&
name|PAGE_MASK
operator|)
operator|+
name|len
operator|+
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|nppods
operator|=
name|min
argument_list|(
name|pages2ppods
argument_list|(
name|npages
argument_list|)
argument_list|,
name|MAX_PPODS
argument_list|)
expr_stmt|;
name|nppods
operator|=
name|roundup2
argument_list|(
name|nppods
argument_list|,
name|PPOD_CLUSTER_SIZE
argument_list|)
expr_stmt|;
name|err
operator|=
name|t3_alloc_ppods
argument_list|(
name|d
argument_list|,
name|nppods
argument_list|,
operator|&
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|nppods
operator|>
name|PPOD_CLUSTER_SIZE
condition|)
block|{
name|nppods
operator|=
name|PPOD_CLUSTER_SIZE
expr_stmt|;
name|err
operator|=
name|t3_alloc_ppods
argument_list|(
name|d
argument_list|,
name|nppods
argument_list|,
operator|&
name|tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|p
operator|->
name|ubuf_nppods
operator|=
name|nppods
expr_stmt|;
name|p
operator|->
name|ubuf_tag
operator|=
name|tag
expr_stmt|;
if|#
directive|if
name|NUM_DDP_KBUF
operator|==
literal|1
name|t3_set_ddp_tag
argument_list|(
name|toep
argument_list|,
literal|1
argument_list|,
name|tag
operator|<<
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Starting offset for the user DDP buffer.  A non-0 value ensures a DDP flush  * won't block indefinitely if there's nothing to place (which should be rare).  */
end_comment

begin_define
define|#
directive|define
name|UBUF_OFFSET
value|1
end_define

begin_function
specifier|static
name|__inline
name|unsigned
name|long
name|select_ddp_flags
parameter_list|(
specifier|const
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|buf_idx
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|int
name|rcv_flags
parameter_list|)
block|{
if|if
condition|(
name|buf_idx
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|rcv_flags
operator|&
name|MSG_WAITALL
argument_list|)
condition|)
return|return
name|V_TF_DDP_PSH_NO_INVALIDATE0
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PSH_NO_INVALIDATE1
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PUSH_DISABLE_1
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|nonblock
condition|)
return|return
name|V_TF_DDP_BUF1_FLUSH
argument_list|(
literal|1
argument_list|)
return|;
return|return
name|V_TF_DDP_BUF1_FLUSH
argument_list|(
operator|!
name|TOM_TUNABLE
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|,
name|ddp_push_wait
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|rcv_flags
operator|&
name|MSG_WAITALL
argument_list|)
condition|)
return|return
name|V_TF_DDP_PSH_NO_INVALIDATE0
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PSH_NO_INVALIDATE1
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PUSH_DISABLE_0
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|nonblock
condition|)
return|return
name|V_TF_DDP_BUF0_FLUSH
argument_list|(
literal|1
argument_list|)
return|;
return|return
name|V_TF_DDP_BUF0_FLUSH
argument_list|(
operator|!
name|TOM_TUNABLE
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|,
name|ddp_push_wait
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reposts the kernel DDP buffer after it has been previously become full and  * invalidated.  We just need to reset the offset and adjust the DDP flags.  * Conveniently, we can set the flags and the offset with a single message.  * Note that this function does not set the buffer length.  Again conveniently  * our kernel buffer is of fixed size.  If the length needs to be changed it  * needs to be done separately.  */
end_comment

begin_function
specifier|static
name|void
name|t3_repost_kbuf
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|unsigned
name|int
name|bufidx
parameter_list|,
name|int
name|modulate
parameter_list|,
name|int
name|activate
parameter_list|,
name|int
name|nonblock
parameter_list|)
block|{
name|struct
name|ddp_state
modifier|*
name|p
init|=
operator|&
name|toep
operator|->
name|tp_ddp_state
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
if|#
directive|if
literal|0
block|SOCKBUF_LOCK_ASSERT(&so->so_rcv);
endif|#
directive|endif
name|p
operator|->
name|buf_state
index|[
name|bufidx
index|]
operator|.
name|cur_offset
operator|=
name|p
operator|->
name|kbuf
index|[
name|bufidx
index|]
operator|->
name|dgl_offset
expr_stmt|;
name|p
operator|->
name|buf_state
index|[
name|bufidx
index|]
operator|.
name|flags
operator|=
name|p
operator|->
name|kbuf_noinval
condition|?
name|DDP_BF_NOINVAL
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|buf_state
index|[
name|bufidx
index|]
operator|.
name|gl
operator|=
name|p
operator|->
name|kbuf
index|[
name|bufidx
index|]
expr_stmt|;
name|p
operator|->
name|cur_buf
operator|=
name|bufidx
expr_stmt|;
name|p
operator|->
name|kbuf_idx
operator|=
name|bufidx
expr_stmt|;
name|flags
operator|=
name|select_ddp_flags
argument_list|(
name|toep
argument_list|,
name|bufidx
argument_list|,
name|nonblock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufidx
condition|)
name|t3_setup_ddpbufs
argument_list|(
name|toep
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|flags
operator||
name|V_TF_DDP_PSH_NO_INVALIDATE0
argument_list|(
name|p
operator|->
name|kbuf_noinval
argument_list|)
operator||
name|V_TF_DDP_PSH_NO_INVALIDATE1
argument_list|(
name|p
operator|->
name|kbuf_noinval
argument_list|)
operator||
name|V_TF_DDP_BUF0_VALID
argument_list|(
literal|1
argument_list|)
argument_list|,
name|V_TF_DDP_BUF0_FLUSH
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PSH_NO_INVALIDATE0
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PSH_NO_INVALIDATE1
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_OFF
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF0_VALID
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_ACTIVE_BUF
argument_list|(
name|activate
argument_list|)
argument_list|,
name|modulate
argument_list|)
expr_stmt|;
else|else
name|t3_setup_ddpbufs
argument_list|(
name|toep
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|flags
operator||
name|V_TF_DDP_PSH_NO_INVALIDATE0
argument_list|(
name|p
operator|->
name|kbuf_noinval
argument_list|)
operator||
name|V_TF_DDP_PSH_NO_INVALIDATE1
argument_list|(
name|p
operator|->
name|kbuf_noinval
argument_list|)
operator||
name|V_TF_DDP_BUF1_VALID
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_ACTIVE_BUF
argument_list|(
name|activate
argument_list|)
argument_list|,
name|V_TF_DDP_BUF1_FLUSH
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PSH_NO_INVALIDATE0
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PSH_NO_INVALIDATE1
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_OFF
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF1_VALID
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_ACTIVE_BUF
argument_list|(
literal|1
argument_list|)
argument_list|,
name|modulate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * setup_uio_ppods - setup HW page pods for a user iovec  * @sk: the associated socket  * @uio: the uio  * @oft: additional bytes to map before the start of the buffer  *  * Pins a user iovec and sets up HW page pods for DDP into it.  We allocate  * page pods for user buffers on the first call per socket.  Afterwards we  * limit the buffer length to whatever the existing page pods can accommodate.  * Returns a negative error code or the length of the mapped buffer.  *  * The current implementation handles iovecs with only one entry.  */
end_comment

begin_function
specifier|static
name|int
name|setup_uio_ppods
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
specifier|const
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|oft
parameter_list|,
name|int
modifier|*
name|length
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|struct
name|ddp_gather_list
modifier|*
name|gl
init|=
name|NULL
decl_stmt|;
name|struct
name|ddp_state
modifier|*
name|p
init|=
operator|&
name|toep
operator|->
name|tp_ddp_state
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iov
init|=
name|uio
operator|->
name|uio_iov
decl_stmt|;
name|vm_offset_t
name|addr
init|=
operator|(
name|vm_offset_t
operator|)
name|iov
operator|->
name|iov_base
operator|-
name|oft
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__predict_false
argument_list|(
name|p
operator|->
name|ubuf_nppods
operator|==
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|alloc_buf1_ppods
argument_list|(
name|toep
argument_list|,
name|p
argument_list|,
name|addr
argument_list|,
name|iov
operator|->
name|iov_len
operator|+
name|oft
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
name|len
operator|=
operator|(
name|p
operator|->
name|ubuf_nppods
operator|-
name|NUM_SENTINEL_PPODS
operator|)
operator|*
name|PPOD_PAGES
operator|*
name|PAGE_SIZE
expr_stmt|;
name|len
operator|-=
name|addr
operator|&
name|PAGE_MASK
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|M_TCB_RX_DDP_BUF0_LEN
condition|)
name|len
operator|=
name|M_TCB_RX_DDP_BUF0_LEN
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|toep
operator|->
name|tp_tp
operator|->
name|rcv_wnd
operator|-
literal|32768
argument_list|)
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|iov
operator|->
name|iov_len
operator|+
name|oft
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|p
operator|->
name|kbuf
index|[
literal|0
index|]
operator|->
name|dgl_length
condition|)
block|{
name|printf
argument_list|(
literal|"length too short\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|err
operator|=
name|t3_pin_pages
argument_list|(
name|toep
operator|->
name|tp_rx_dmat
argument_list|,
name|toep
operator|->
name|tp_dmamap
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
operator|&
name|gl
argument_list|,
name|p
operator|->
name|ubuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|gl
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|ubuf
condition|)
name|t3_free_ddp_gl
argument_list|(
name|p
operator|->
name|ubuf
argument_list|)
expr_stmt|;
name|p
operator|->
name|ubuf
operator|=
name|gl
expr_stmt|;
name|t3_setup_ppods
argument_list|(
name|toep
argument_list|,
name|gl
argument_list|,
name|pages2ppods
argument_list|(
name|gl
operator|->
name|dgl_nelem
argument_list|)
argument_list|,
name|p
operator|->
name|ubuf_tag
argument_list|,
name|len
argument_list|,
name|gl
operator|->
name|dgl_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|length
operator|=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|void
name|t3_cancel_ubuf
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|sockbuf
modifier|*
name|rcv
parameter_list|)
block|{
name|struct
name|ddp_state
modifier|*
name|p
init|=
operator|&
name|toep
operator|->
name|tp_ddp_state
decl_stmt|;
name|int
name|ubuf_pending
init|=
name|t3_ddp_ubuf_pending
argument_list|(
name|toep
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|ubuf
operator|==
name|NULL
condition|)
return|return;
name|sockbuf_lock_assert
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|p
operator|->
name|cancel_ubuf
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|ubuf_pending
operator|&&
operator|!
operator|(
name|rcv
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
operator|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_cancel_ubuf: flags0 0x%x flags1 0x%x get_tcb_count %d"
argument_list|,
name|p
operator|->
name|buf_state
index|[
literal|0
index|]
operator|.
name|flags
operator|&
operator|(
name|DDP_BF_NOFLIP
operator||
name|DDP_BF_NOCOPY
operator|)
argument_list|,
name|p
operator|->
name|buf_state
index|[
literal|1
index|]
operator|.
name|flags
operator|&
operator|(
name|DDP_BF_NOFLIP
operator||
name|DDP_BF_NOCOPY
operator|)
argument_list|,
name|p
operator|->
name|get_tcb_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|get_tcb_count
operator|==
literal|0
condition|)
name|t3_cancel_ddpbuf
argument_list|(
name|toep
argument_list|,
name|p
operator|->
name|cur_buf
argument_list|)
expr_stmt|;
else|else
name|CTR5
argument_list|(
name|KTR_TOM
argument_list|,
literal|"waiting err=%d get_tcb_count=%d timeo=%d rcv=%p SBS_CANTRCVMORE=%d"
argument_list|,
name|err
argument_list|,
name|p
operator|->
name|get_tcb_count
argument_list|,
name|rcv
operator|->
name|sb_timeo
argument_list|,
name|rcv
argument_list|,
operator|!
operator|!
operator|(
name|rcv
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|get_tcb_count
operator|&&
operator|!
operator|(
name|rcv
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
operator|)
condition|)
block|{
if|if
condition|(
name|count
operator|&
literal|0xfffffff
condition|)
name|CTR5
argument_list|(
name|KTR_TOM
argument_list|,
literal|"waiting err=%d get_tcb_count=%d timeo=%d rcv=%p count=%d"
argument_list|,
name|err
argument_list|,
name|p
operator|->
name|get_tcb_count
argument_list|,
name|rcv
operator|->
name|sb_timeo
argument_list|,
name|rcv
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|err
operator|=
name|sbwait
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
block|}
name|ubuf_pending
operator|=
name|t3_ddp_ubuf_pending
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|cancel_ubuf
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|user_ddp_pending
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|OVERLAY_MASK
value|(V_TF_DDP_PSH_NO_INVALIDATE0(1) | \ 	              V_TF_DDP_PSH_NO_INVALIDATE1(1) | \ 		      V_TF_DDP_BUF1_FLUSH(1) | \ 		      V_TF_DDP_BUF0_FLUSH(1) | \ 		      V_TF_DDP_PUSH_DISABLE_1(1) | \ 		      V_TF_DDP_PUSH_DISABLE_0(1) | \ 		      V_TF_DDP_INDICATE_OUT(1))
end_define

begin_comment
comment|/*  * Post a user buffer as an overlay on top of the current kernel buffer.  */
end_comment

begin_function
name|int
name|t3_overlay_ubuf
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|sockbuf
modifier|*
name|rcv
parameter_list|,
specifier|const
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|int
name|rcv_flags
parameter_list|,
name|int
name|modulate
parameter_list|,
name|int
name|post_kbuf
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|len
decl_stmt|,
name|ubuf_idx
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|ddp_state
modifier|*
name|p
init|=
operator|&
name|toep
operator|->
name|tp_ddp_state
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|kbuf
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|err
operator|=
name|setup_uio_ppods
argument_list|(
name|toep
argument_list|,
name|uio
argument_list|,
literal|0
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|rcv
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
operator|)
operator|||
operator|(
name|toep
operator|->
name|tp_tp
operator|->
name|t_flags
operator|&
name|TF_TOE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ubuf_idx
operator|=
name|p
operator|->
name|kbuf_idx
expr_stmt|;
name|p
operator|->
name|buf_state
index|[
name|ubuf_idx
index|]
operator|.
name|flags
operator|=
name|DDP_BF_NOFLIP
expr_stmt|;
comment|/* Use existing offset */
comment|/* Don't need to update .gl, user buffer isn't copied. */
name|p
operator|->
name|cur_buf
operator|=
name|ubuf_idx
expr_stmt|;
name|flags
operator|=
name|select_ddp_flags
argument_list|(
name|toep
argument_list|,
name|ubuf_idx
argument_list|,
name|nonblock
argument_list|,
name|rcv_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|post_kbuf
condition|)
block|{
name|struct
name|ddp_buf_state
modifier|*
name|dbs
init|=
operator|&
name|p
operator|->
name|buf_state
index|[
name|ubuf_idx
operator|^
literal|1
index|]
decl_stmt|;
name|dbs
operator|->
name|cur_offset
operator|=
literal|0
expr_stmt|;
name|dbs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|dbs
operator|->
name|gl
operator|=
name|p
operator|->
name|kbuf
index|[
name|ubuf_idx
operator|^
literal|1
index|]
expr_stmt|;
name|p
operator|->
name|kbuf_idx
operator|^=
literal|1
expr_stmt|;
name|flags
operator||=
name|p
operator|->
name|kbuf_idx
condition|?
name|V_TF_DDP_BUF1_VALID
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PUSH_DISABLE_1
argument_list|(
literal|0
argument_list|)
else|:
name|V_TF_DDP_BUF0_VALID
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_PUSH_DISABLE_0
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ubuf_idx
operator|==
literal|0
condition|)
block|{
name|t3_overlay_ddpbuf
argument_list|(
name|toep
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|ubuf_tag
operator|<<
literal|6
argument_list|,
name|p
operator|->
name|kbuf_tag
index|[
literal|1
index|]
operator|<<
literal|6
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|t3_setup_ddpbufs
argument_list|(
name|toep
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|kbuf
index|[
literal|1
index|]
operator|->
name|dgl_length
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|OVERLAY_MASK
operator||
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t3_overlay_ddpbuf
argument_list|(
name|toep
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|kbuf_tag
index|[
literal|0
index|]
operator|<<
literal|6
argument_list|,
name|p
operator|->
name|ubuf_tag
operator|<<
literal|6
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|t3_setup_ddpbufs
argument_list|(
name|toep
argument_list|,
name|p
operator|->
name|kbuf
index|[
literal|0
index|]
operator|->
name|dgl_length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|OVERLAY_MASK
operator||
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE5
argument_list|(
name|TIDTB
argument_list|(
name|so
argument_list|)
argument_list|,
literal|"t3_overlay_ubuf: tag %u flags 0x%x mask 0x%x ubuf_idx %d "
literal|" kbuf_idx %d"
argument_list|,
name|p
operator|->
name|ubuf_tag
argument_list|,
name|flags
argument_list|,
name|OVERLAY_MASK
argument_list|,
name|ubuf_idx
argument_list|,
name|p
operator|->
name|kbuf_idx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CTR3
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_overlay_ubuf: tag %u flags 0x%x mask 0x%x"
argument_list|,
name|p
operator|->
name|ubuf_tag
argument_list|,
name|flags
argument_list|,
name|OVERLAY_MASK
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_overlay_ubuf:  ubuf_idx %d kbuf_idx %d post_kbuf %d"
argument_list|,
name|ubuf_idx
argument_list|,
name|p
operator|->
name|kbuf_idx
argument_list|,
name|post_kbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clean up DDP state that needs to survive until socket close time, such as the  * DDP buffers.  The buffers are already unmapped at this point as unmapping  * needs the PCI device and a socket may close long after the device is removed.  */
end_comment

begin_function
name|void
name|t3_cleanup_ddp
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|ddp_state
modifier|*
name|p
init|=
operator|&
name|toep
operator|->
name|tp_ddp_state
decl_stmt|;
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|NUM_DDP_KBUF
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
condition|)
block|{
name|ddp_gl_free_pages
argument_list|(
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|ubuf
condition|)
block|{
name|ddp_gl_free_pages
argument_list|(
name|p
operator|->
name|ubuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|ubuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|p
operator|->
name|ubuf
operator|=
name|NULL
expr_stmt|;
block|}
name|toep
operator|->
name|tp_ulp_mode
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is a companion to t3_cleanup_ddp() and releases the HW resources  * associated with a connection's DDP state, such as the page pods.  * It's called when HW is done with a connection.   The rest of the state  * remains available until both HW and the app are done with the connection.  */
end_comment

begin_function
name|void
name|t3_release_ddp_resources
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|ddp_state
modifier|*
name|p
init|=
operator|&
name|toep
operator|->
name|tp_ddp_state
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|d
init|=
name|TOM_DATA
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|)
decl_stmt|;
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|NUM_DDP_KBUF
condition|;
name|idx
operator|++
control|)
block|{
name|t3_free_ppods
argument_list|(
name|d
argument_list|,
name|p
operator|->
name|kbuf_tag
index|[
name|idx
index|]
argument_list|,
name|p
operator|->
name|kbuf_nppods
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|unmap_ddp_gl
argument_list|(
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|ubuf_nppods
condition|)
block|{
name|t3_free_ppods
argument_list|(
name|d
argument_list|,
name|p
operator|->
name|ubuf_tag
argument_list|,
name|p
operator|->
name|ubuf_nppods
argument_list|)
expr_stmt|;
name|p
operator|->
name|ubuf_nppods
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|ubuf
condition|)
name|unmap_ddp_gl
argument_list|(
name|p
operator|->
name|ubuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_post_kbuf
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|modulate
parameter_list|,
name|int
name|nonblock
parameter_list|)
block|{
name|struct
name|ddp_state
modifier|*
name|p
init|=
operator|&
name|toep
operator|->
name|tp_ddp_state
decl_stmt|;
name|t3_set_ddp_tag
argument_list|(
name|toep
argument_list|,
name|p
operator|->
name|cur_buf
argument_list|,
name|p
operator|->
name|kbuf_tag
index|[
name|p
operator|->
name|cur_buf
index|]
operator|<<
literal|6
argument_list|)
expr_stmt|;
name|t3_set_ddp_buf
argument_list|(
name|toep
argument_list|,
name|p
operator|->
name|cur_buf
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|kbuf
index|[
name|p
operator|->
name|cur_buf
index|]
operator|->
name|dgl_length
argument_list|)
expr_stmt|;
name|t3_repost_kbuf
argument_list|(
name|toep
argument_list|,
name|p
operator|->
name|cur_buf
argument_list|,
name|modulate
argument_list|,
literal|1
argument_list|,
name|nonblock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE1
argument_list|(
name|TIDTB
argument_list|(
name|so
argument_list|)
argument_list|,
literal|"t3_post_kbuf: cur_buf = kbuf_idx = %u "
argument_list|,
name|p
operator|->
name|cur_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CTR1
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_post_kbuf: cur_buf = kbuf_idx = %u "
argument_list|,
name|p
operator|->
name|cur_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prepare a socket for DDP.  Must be called when the socket is known to be  * open.  */
end_comment

begin_function
name|int
name|t3_enter_ddp
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|unsigned
name|int
name|kbuf_size
parameter_list|,
name|unsigned
name|int
name|waitall
parameter_list|,
name|int
name|nonblock
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|err
init|=
name|ENOMEM
decl_stmt|;
specifier|static
name|vm_pindex_t
name|color
decl_stmt|;
name|unsigned
name|int
name|nppods
decl_stmt|,
name|kbuf_pages
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|;
name|struct
name|ddp_state
modifier|*
name|p
init|=
operator|&
name|toep
operator|->
name|tp_ddp_state
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|d
init|=
name|TOM_DATA
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|)
decl_stmt|;
if|if
condition|(
name|kbuf_size
operator|>
name|M_TCB_RX_DDP_BUF0_LEN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifdef|#
directive|ifdef
name|notyet
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kbuf_pages
operator|=
operator|(
name|kbuf_size
operator|+
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|nppods
operator|=
name|pages2ppods
argument_list|(
name|kbuf_pages
argument_list|)
expr_stmt|;
name|p
operator|->
name|kbuf_noinval
operator|=
operator|!
operator|!
name|waitall
expr_stmt|;
name|p
operator|->
name|kbuf_tag
index|[
name|NUM_DDP_KBUF
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|NUM_DDP_KBUF
condition|;
name|idx
operator|++
control|)
block|{
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ddp_gather_list
argument_list|)
operator|+
name|kbuf_pages
operator|*
sizeof|sizeof
argument_list|(
name|vm_page_t
operator|*
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|err
operator|=
name|t3_alloc_ppods
argument_list|(
name|d
argument_list|,
name|nppods
argument_list|,
operator|&
name|p
operator|->
name|kbuf_tag
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"t3_alloc_ppods failed err=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|->
name|kbuf_nppods
index|[
name|idx
index|]
operator|=
name|nppods
expr_stmt|;
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
operator|->
name|dgl_length
operator|=
name|kbuf_size
expr_stmt|;
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
operator|->
name|dgl_offset
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
operator|->
name|dgl_nelem
operator|=
name|kbuf_pages
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|kbuf_pages
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
operator|->
name|dgl_pages
index|[
name|i
index|]
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|color
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
operator|->
name|dgl_pages
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
operator|->
name|dgl_nelem
operator|=
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"failed to allocate kbuf pages\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|NEED_BUSDMA
comment|/* 		 * XXX we'll need this for VT-d or any platform with an iommu :-/ 		 * 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|kbuf_pages
condition|;
operator|++
name|i
control|)
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
operator|->
name|phys_addr
index|[
name|i
index|]
operator|=
name|pci_map_page
argument_list|(
name|p
operator|->
name|pdev
argument_list|,
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
operator|->
name|pages
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PCI_DMA_FROMDEVICE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t3_setup_ppods
argument_list|(
name|toep
argument_list|,
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
argument_list|,
name|nppods
argument_list|,
name|p
operator|->
name|kbuf_tag
index|[
name|idx
index|]
argument_list|,
name|p
operator|->
name|kbuf
index|[
name|idx
index|]
operator|->
name|dgl_length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cxgb_log_tcb
argument_list|(
name|TOEP_T3C_DEV
argument_list|(
name|toep
argument_list|)
operator|->
name|adapter
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
expr_stmt|;
name|t3_set_ddp_tag
argument_list|(
name|toep
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|kbuf_tag
index|[
literal|0
index|]
operator|<<
literal|6
argument_list|)
expr_stmt|;
name|t3_set_ddp_buf
argument_list|(
name|toep
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|kbuf
index|[
literal|0
index|]
operator|->
name|dgl_length
argument_list|)
expr_stmt|;
name|t3_repost_kbuf
argument_list|(
name|toep
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|nonblock
argument_list|)
expr_stmt|;
name|t3_set_rcv_coalesce_enable
argument_list|(
name|toep
argument_list|,
name|TOM_TUNABLE
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|,
name|ddp_rcvcoalesce
argument_list|)
argument_list|)
expr_stmt|;
name|t3_set_dack_mss
argument_list|(
name|toep
argument_list|,
name|TOM_TUNABLE
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|,
name|delack
argument_list|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE4
argument_list|(
name|TIDTB
argument_list|(
name|so
argument_list|)
argument_list|,
literal|"t3_enter_ddp: kbuf_size %u waitall %u tag0 %d tag1 %d"
argument_list|,
name|kbuf_size
argument_list|,
name|waitall
argument_list|,
name|p
operator|->
name|kbuf_tag
index|[
literal|0
index|]
argument_list|,
name|p
operator|->
name|kbuf_tag
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CTR4
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_enter_ddp: kbuf_size %u waitall %u tag0 %d tag1 %d"
argument_list|,
name|kbuf_size
argument_list|,
name|waitall
argument_list|,
name|p
operator|->
name|kbuf_tag
index|[
literal|0
index|]
argument_list|,
name|p
operator|->
name|kbuf_tag
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cxgb_log_tcb
argument_list|(
name|TOEP_T3C_DEV
argument_list|(
name|toep
argument_list|)
operator|->
name|adapter
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|t3_release_ddp_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|t3_cleanup_ddp
argument_list|(
name|toep
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_ddp_copy
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|resid_init
decl_stmt|,
name|err
decl_stmt|;
name|struct
name|ddp_gather_list
modifier|*
name|gl
init|=
operator|(
expr|struct
name|ddp_gather_list
operator|*
operator|)
name|m
operator|->
name|m_ddp_gl
decl_stmt|;
name|resid_init
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
operator|!
name|gl
operator|->
name|dgl_pages
condition|)
name|panic
argument_list|(
literal|"pages not set\n"
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_ddp_copy: offset=%d dgl_offset=%d cur_offset=%d len=%d"
argument_list|,
name|offset
argument_list|,
name|gl
operator|->
name|dgl_offset
argument_list|,
name|m
operator|->
name|m_cur_offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|gl
operator|->
name|dgl_offset
operator|+
name|m
operator|->
name|m_cur_offset
expr_stmt|;
name|KASSERT
argument_list|(
name|len
operator|<=
name|gl
operator|->
name|dgl_length
argument_list|,
operator|(
literal|"len=%d> dgl_length=%d in ddp_copy\n"
operator|,
name|len
operator|,
name|gl
operator|->
name|dgl_length
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|uiomove_fromphys
argument_list|(
name|gl
operator|->
name|dgl_pages
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate n page pods.  Returns -1 on failure or the page pod tag.  */
end_comment

begin_function
name|int
name|t3_alloc_ppods
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
name|int
modifier|*
name|ptag
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|td
operator|->
name|ppod_map
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ppod_map not set\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|ppod_map_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|td
operator|->
name|nppods
condition|;
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
comment|/* scan ppod_map[i..i+n-1] */
if|if
condition|(
name|td
operator|->
name|ppod_map
index|[
name|i
operator|+
name|j
index|]
condition|)
block|{
name|i
operator|=
name|i
operator|+
name|j
operator|+
literal|1
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|memset
argument_list|(
operator|&
name|td
operator|->
name|ppod_map
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* allocate range */
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|ppod_map_lock
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_alloc_ppods: n=%u tag=%u"
argument_list|,
name|n
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|*
name|ptag
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|next
label|:
empty_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|ppod_map_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_free_ppods
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|unsigned
name|int
name|tag
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
comment|/* No need to take ppod_lock here */
name|memset
argument_list|(
operator|&
name|td
operator|->
name|ppod_map
index|[
name|tag
index|]
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

