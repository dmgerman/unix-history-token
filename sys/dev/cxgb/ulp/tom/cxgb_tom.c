begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_osdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/sys/mbufq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tcp_offload.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_offload.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_DEFINED
end_ifdef

begin_include
include|#
directive|include
file|<cxgb_include.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_include.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/t3cdev.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_firmware_exports.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_tcb.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_include.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_ctl_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_t3_cpl.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_offload.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/toecore/cxgb_toedev.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tom.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_t3_ddp.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_toepcb.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tcp.h>
end_include

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|adapter
argument_list|)
end_macro

begin_expr_stmt
name|adapter_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|rwlock
name|adapter_list_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|tom_data
argument_list|)
name|cxgb_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|cxgb_list_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|MAX_ATIDS
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|ATID_BASE
init|=
literal|0x100000
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|t3_toe_attach
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
specifier|const
name|struct
name|offload_id
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_register_listeners
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|t3c_tom_add
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Handlers for each CPL opcode  */
end_comment

begin_decl_stmt
specifier|static
name|cxgb_cpl_handler_func
name|tom_cpl_handlers
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|listen_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|offload_id
name|t3_toe_id_tab
index|[]
init|=
block|{
block|{
name|TOE_ID_CHELSIO_T3
block|,
literal|0
block|}
block|,
block|{
name|TOE_ID_CHELSIO_T3B
block|,
literal|0
block|}
block|,
block|{
name|TOE_ID_CHELSIO_T3C
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tom_info
name|t3_tom_info
init|=
block|{
operator|.
name|ti_attach
operator|=
name|t3_toe_attach
block|,
operator|.
name|ti_id_table
operator|=
name|t3_toe_id_tab
block|,
operator|.
name|ti_name
operator|=
literal|"Chelsio-T3"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cxgb_client
name|t3c_tom_client
init|=
block|{
operator|.
name|name
operator|=
literal|"tom_cxgb3"
block|,
operator|.
name|add
operator|=
name|t3c_tom_add
block|,
operator|.
name|remove
operator|=
name|NULL
block|,
operator|.
name|handlers
operator|=
name|tom_cpl_handlers
block|,
operator|.
name|redirect
operator|=
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Add an skb to the deferred skb queue for processing from process context.  */
end_comment

begin_function
name|void
name|t3_defer_reply
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|defer_handler_t
name|handler
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|TOM_DATA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|m_set_handler
argument_list|(
name|m
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|deferq
operator|.
name|lock
argument_list|)
expr_stmt|;
name|mbufq_tail
argument_list|(
operator|&
name|td
operator|->
name|deferq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbufq_len
argument_list|(
operator|&
name|td
operator|->
name|deferq
argument_list|)
operator|==
literal|1
condition|)
name|taskqueue_enqueue
argument_list|(
name|td
operator|->
name|tq
argument_list|,
operator|&
name|td
operator|->
name|deferq_task
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|deferq
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|toepcb
modifier|*
name|toepcb_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
name|toep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|toepcb
argument_list|)
argument_list|,
name|M_CXGB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|toepcb_init
argument_list|(
name|toep
argument_list|)
expr_stmt|;
return|return
operator|(
name|toep
operator|)
return|;
block|}
end_function

begin_function
name|void
name|toepcb_init
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|toep
operator|->
name|tp_refcount
operator|=
literal|1
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|toep
operator|->
name|tp_cv
argument_list|,
literal|"toep cv"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|toepcb_hold
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|atomic_add_acq_int
argument_list|(
operator|&
name|toep
operator|->
name|tp_refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|toepcb_release
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
if|if
condition|(
name|toep
operator|->
name|tp_refcount
operator|==
literal|1
condition|)
block|{
name|free
argument_list|(
name|toep
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
return|return;
block|}
name|atomic_add_acq_int
argument_list|(
operator|&
name|toep
operator|->
name|tp_refcount
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a T3 offload device to the list of devices we are managing.  */
end_comment

begin_function
specifier|static
name|void
name|t3cdev_add
parameter_list|(
name|struct
name|tom_data
modifier|*
name|t
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|cxgb_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cxgb_list
argument_list|,
name|t
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|cdev2type
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|)
block|{
name|int
name|type
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cdev
operator|->
name|type
condition|)
block|{
case|case
name|T3A
case|:
name|type
operator|=
name|TOE_ID_CHELSIO_T3
expr_stmt|;
break|break;
case|case
name|T3B
case|:
name|type
operator|=
name|TOE_ID_CHELSIO_T3B
expr_stmt|;
break|break;
case|case
name|T3C
case|:
name|type
operator|=
name|TOE_ID_CHELSIO_T3C
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate and initialize the TID tables.  Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|init_tid_tabs
parameter_list|(
name|struct
name|tid_info
modifier|*
name|t
parameter_list|,
name|unsigned
name|int
name|ntids
parameter_list|,
name|unsigned
name|int
name|natids
parameter_list|,
name|unsigned
name|int
name|nstids
parameter_list|,
name|unsigned
name|int
name|atid_base
parameter_list|,
name|unsigned
name|int
name|stid_base
parameter_list|)
block|{
name|unsigned
name|long
name|size
init|=
name|ntids
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|tid_tab
argument_list|)
operator|+
name|natids
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|atid_tab
argument_list|)
operator|+
name|nstids
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|stid_tab
argument_list|)
decl_stmt|;
name|t
operator|->
name|tid_tab
operator|=
name|cxgb_alloc_mem
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|tid_tab
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|t
operator|->
name|stid_tab
operator|=
operator|(
expr|union
name|listen_entry
operator|*
operator|)
operator|&
name|t
operator|->
name|tid_tab
index|[
name|ntids
index|]
expr_stmt|;
name|t
operator|->
name|atid_tab
operator|=
operator|(
expr|union
name|active_open_entry
operator|*
operator|)
operator|&
name|t
operator|->
name|stid_tab
index|[
name|nstids
index|]
expr_stmt|;
name|t
operator|->
name|ntids
operator|=
name|ntids
expr_stmt|;
name|t
operator|->
name|nstids
operator|=
name|nstids
expr_stmt|;
name|t
operator|->
name|stid_base
operator|=
name|stid_base
expr_stmt|;
name|t
operator|->
name|sfree
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|natids
operator|=
name|natids
expr_stmt|;
name|t
operator|->
name|atid_base
operator|=
name|atid_base
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|stids_in_use
operator|=
name|t
operator|->
name|atids_in_use
operator|=
literal|0
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|,
literal|"stid"
argument_list|,
name|NULL
argument_list|,
name|MTX_DUPOK
operator||
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|,
literal|"atid"
argument_list|,
name|NULL
argument_list|,
name|MTX_DUPOK
operator||
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the free lists for stid_tab and atid_tab. 	 */
if|if
condition|(
name|nstids
condition|)
block|{
while|while
condition|(
operator|--
name|nstids
condition|)
name|t
operator|->
name|stid_tab
index|[
name|nstids
operator|-
literal|1
index|]
operator|.
name|next
operator|=
operator|&
name|t
operator|->
name|stid_tab
index|[
name|nstids
index|]
expr_stmt|;
name|t
operator|->
name|sfree
operator|=
name|t
operator|->
name|stid_tab
expr_stmt|;
block|}
if|if
condition|(
name|natids
condition|)
block|{
while|while
condition|(
operator|--
name|natids
condition|)
name|t
operator|->
name|atid_tab
index|[
name|natids
operator|-
literal|1
index|]
operator|.
name|next
operator|=
operator|&
name|t
operator|->
name|atid_tab
index|[
name|natids
index|]
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|t
operator|->
name|atid_tab
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_tid_maps
parameter_list|(
name|struct
name|tid_info
modifier|*
name|t
parameter_list|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
name|cxgb_free_mem
argument_list|(
name|t
operator|->
name|tid_tab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|add_adapter
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|adapter_list
argument_list|,
name|adap
argument_list|,
name|adapter_entry
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|remove_adapter
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|adapter_list
argument_list|,
name|adap
argument_list|,
name|adapter_entry
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Populate a TID_RELEASE WR.  The mbuf must be already propely sized.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mk_tid_release
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|struct
name|cpl_tid_release
modifier|*
name|req
decl_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|CPL_PRIORITY_SETUP
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_tid_release
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_TID_RELEASE
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|t3_process_tid_release_list
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|t3cdev
modifier|*
name|tdev
init|=
name|data
decl_stmt|;
name|struct
name|t3c_data
modifier|*
name|td
init|=
name|T3C_DATA
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|td
operator|->
name|tid_release_list
condition|)
block|{
name|struct
name|toe_tid_entry
modifier|*
name|p
init|=
name|td
operator|->
name|tid_release_list
decl_stmt|;
name|td
operator|->
name|tid_release_list
operator|=
operator|(
expr|struct
name|toe_tid_entry
operator|*
operator|)
name|p
operator|->
name|ctx
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_get
argument_list|(
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|mk_tid_release
argument_list|(
name|m
argument_list|,
name|p
operator|-
name|td
operator|->
name|tid_maps
operator|.
name|tid_tab
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|tdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|p
operator|->
name|ctx
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cxgb_offload_activate
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|t3cdev
modifier|*
name|dev
init|=
operator|&
name|adapter
operator|->
name|tdev
decl_stmt|;
name|int
name|natids
decl_stmt|,
name|err
decl_stmt|;
name|struct
name|t3c_data
modifier|*
name|t
decl_stmt|;
name|struct
name|tid_range
name|stid_range
decl_stmt|,
name|tid_range
decl_stmt|;
name|struct
name|mtutab
name|mtutab
decl_stmt|;
name|unsigned
name|int
name|l2t_capacity
decl_stmt|;
name|t
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|,
name|M_CXGB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|dev
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|err
operator|=
operator|(
name|EOPNOTSUPP
operator|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|ctl
argument_list|(
name|dev
argument_list|,
name|GET_TX_MAX_CHUNK
argument_list|,
operator|&
name|t
operator|->
name|tx_max_chunk
argument_list|)
operator|<
literal|0
operator|||
name|dev
operator|->
name|ctl
argument_list|(
name|dev
argument_list|,
name|GET_MAX_OUTSTANDING_WR
argument_list|,
operator|&
name|t
operator|->
name|max_wrs
argument_list|)
operator|<
literal|0
operator|||
name|dev
operator|->
name|ctl
argument_list|(
name|dev
argument_list|,
name|GET_L2T_CAPACITY
argument_list|,
operator|&
name|l2t_capacity
argument_list|)
operator|<
literal|0
operator|||
name|dev
operator|->
name|ctl
argument_list|(
name|dev
argument_list|,
name|GET_MTUS
argument_list|,
operator|&
name|mtutab
argument_list|)
operator|<
literal|0
operator|||
name|dev
operator|->
name|ctl
argument_list|(
name|dev
argument_list|,
name|GET_TID_RANGE
argument_list|,
operator|&
name|tid_range
argument_list|)
operator|<
literal|0
operator|||
name|dev
operator|->
name|ctl
argument_list|(
name|dev
argument_list|,
name|GET_STID_RANGE
argument_list|,
operator|&
name|stid_range
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: dev->ctl check failed\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
name|err
operator|=
operator|(
name|ENOMEM
operator|)
expr_stmt|;
name|L2DATA
argument_list|(
name|dev
argument_list|)
operator|=
name|t3_init_l2t
argument_list|(
name|l2t_capacity
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|L2DATA
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: t3_init_l2t failed\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
name|natids
operator|=
name|min
argument_list|(
name|tid_range
operator|.
name|num
operator|/
literal|2
argument_list|,
name|MAX_ATIDS
argument_list|)
expr_stmt|;
name|err
operator|=
name|init_tid_tabs
argument_list|(
operator|&
name|t
operator|->
name|tid_maps
argument_list|,
name|tid_range
operator|.
name|num
argument_list|,
name|natids
argument_list|,
name|stid_range
operator|.
name|num
argument_list|,
name|ATID_BASE
argument_list|,
name|stid_range
operator|.
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: init_tid_tabs failed\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|out_free_l2t
goto|;
block|}
name|t
operator|->
name|mtus
operator|=
name|mtutab
operator|.
name|mtus
expr_stmt|;
name|t
operator|->
name|nmtus
operator|=
name|mtutab
operator|.
name|size
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|t
operator|->
name|tid_release_task
argument_list|,
literal|0
comment|/* XXX? */
argument_list|,
name|t3_process_tid_release_list
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|t
operator|->
name|tid_release_lock
argument_list|,
literal|"tid release"
argument_list|,
name|NULL
argument_list|,
name|MTX_DUPOK
operator||
name|MTX_DEF
argument_list|)
expr_stmt|;
name|t
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|T3C_DATA
argument_list|(
name|dev
argument_list|)
operator|=
name|t
expr_stmt|;
name|dev
operator|->
name|recv
operator|=
name|process_rx
expr_stmt|;
name|dev
operator|->
name|arp_update
operator|=
name|t3_l2t_update
expr_stmt|;
comment|/* Register netevent handler once */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|adapter_list
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CHELSIO_T3_MODULE
argument_list|)
if|if
condition|(
name|prepare_arp_with_t3core
argument_list|()
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to set offload capabilities\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|CTR1
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"adding adapter %p"
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|add_adapter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"offload started\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|flags
operator||=
name|CXGB_OFLD_INIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|out_free_l2t
label|:
name|t3_free_l2t
argument_list|(
name|L2DATA
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|L2DATA
argument_list|(
name|dev
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|out_free
label|:
name|free
argument_list|(
name|t
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cxgb_offload_deactivate
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|t3cdev
modifier|*
name|tdev
init|=
operator|&
name|adapter
operator|->
name|tdev
decl_stmt|;
name|struct
name|t3c_data
modifier|*
name|t
init|=
name|T3C_DATA
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"removing adapter %p\n"
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|remove_adapter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|adapter_list
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CHELSIO_T3_MODULE
argument_list|)
name|restore_arp_sans_t3core
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|free_tid_maps
argument_list|(
operator|&
name|t
operator|->
name|tid_maps
argument_list|)
expr_stmt|;
name|T3C_DATA
argument_list|(
name|tdev
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|t3_free_l2t
argument_list|(
name|L2DATA
argument_list|(
name|tdev
argument_list|)
argument_list|)
expr_stmt|;
name|L2DATA
argument_list|(
name|tdev
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|t
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sends an sk_buff to a T3C driver after dealing with any active network taps.  */
end_comment

begin_function
name|int
name|cxgb_ofld_send
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|dev
operator|->
name|send
argument_list|(
name|dev
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ifnet
modifier|*
name|get_iff_from_mac
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|mac
parameter_list|,
name|unsigned
name|int
name|vlan
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|i
argument_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
specifier|const
name|struct
name|vlan_group
modifier|*
name|grp
decl_stmt|;
endif|#
directive|endif
specifier|const
name|struct
name|port_info
modifier|*
name|p
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|p
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|p
operator|->
name|hw_addr
argument_list|,
name|mac
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|vlan
operator|&&
name|vlan
operator|!=
name|EVL_VLID_MASK
condition|)
block|{
name|grp
operator|=
name|p
operator|->
name|vlan_grp
expr_stmt|;
name|dev
operator|=
name|grp
condition|?
name|grp
operator|->
name|vlan_devices
index|[
name|vlan
index|]
else|:
name|NULL
expr_stmt|;
block|}
else|else
while|while
condition|(
name|dev
operator|->
name|master
condition|)
name|dev
operator|=
name|dev
operator|->
name|master
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ifp
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|failover_fixup
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|port
index|[
name|port
index|]
operator|.
name|ifp
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|port
index|]
operator|.
name|mac
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
comment|/* Failover triggered by the interface ifdown */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_TX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_TXEN
argument_list|)
expr_stmt|;
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_TX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Failover triggered by the interface link down */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_RXEN
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_ulp_iscsi_ctl
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|req
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|ulp_iscsi_info
modifier|*
name|uiip
init|=
name|data
decl_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|ULP_ISCSI_GET_PARAMS
case|:
name|uiip
operator|->
name|llimit
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_ISCSI_LLIMIT
argument_list|)
expr_stmt|;
name|uiip
operator|->
name|ulimit
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_ISCSI_ULIMIT
argument_list|)
expr_stmt|;
name|uiip
operator|->
name|tagmask
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_ISCSI_TAGMASK
argument_list|)
expr_stmt|;
comment|/* 		 * On tx, the iscsi pdu has to be<= tx page size and has to 		 * fit into the Tx PM FIFO. 		 */
name|uiip
operator|->
name|max_txsz
operator|=
name|min
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|tp
operator|.
name|tx_pg_size
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PM1_TX_CFG
argument_list|)
operator|>>
literal|17
argument_list|)
expr_stmt|;
comment|/* on rx, the iscsi pdu has to be< rx page size and the 		   whole pdu + cpl headers has to fit into one sge buffer */
comment|/* also check the max rx data length programmed in TP */
name|uiip
operator|->
name|max_rxsz
operator|=
name|min
argument_list|(
name|uiip
operator|->
name|max_rxsz
argument_list|,
operator|(
operator|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_PARA_REG2
argument_list|)
operator|)
operator|>>
name|S_MAXRXDATA
operator|)
operator|&
name|M_MAXRXDATA
argument_list|)
expr_stmt|;
break|break;
case|case
name|ULP_ISCSI_SET_PARAMS
case|:
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_ISCSI_TAGMASK
argument_list|,
name|uiip
operator|->
name|tagmask
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|(
name|EOPNOTSUPP
operator|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Response queue used for RDMA events. */
end_comment

begin_define
define|#
directive|define
name|ASYNC_NOTIF_RSPQ
value|0
end_define

begin_function
specifier|static
name|int
name|cxgb_rdma_ctl
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|req
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|RDMA_GET_PARAMS
case|:
block|{
name|struct
name|rdma_info
modifier|*
name|req
init|=
name|data
decl_stmt|;
name|req
operator|->
name|udbell_physbase
operator|=
name|rman_get_start
argument_list|(
name|adapter
operator|->
name|udbs_res
argument_list|)
expr_stmt|;
name|req
operator|->
name|udbell_len
operator|=
name|rman_get_size
argument_list|(
name|adapter
operator|->
name|udbs_res
argument_list|)
expr_stmt|;
name|req
operator|->
name|tpt_base
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_TPT_LLIMIT
argument_list|)
expr_stmt|;
name|req
operator|->
name|tpt_top
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_TPT_ULIMIT
argument_list|)
expr_stmt|;
name|req
operator|->
name|pbl_base
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_PBL_LLIMIT
argument_list|)
expr_stmt|;
name|req
operator|->
name|pbl_top
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_PBL_ULIMIT
argument_list|)
expr_stmt|;
name|req
operator|->
name|rqt_base
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_RQ_LLIMIT
argument_list|)
expr_stmt|;
name|req
operator|->
name|rqt_top
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_RQ_ULIMIT
argument_list|)
expr_stmt|;
name|req
operator|->
name|kdb_addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|rman_get_virtual
argument_list|(
name|adapter
operator|->
name|regs_res
argument_list|)
operator|+
name|A_SG_KDOORBELL
operator|)
expr_stmt|;
break|break;
block|}
case|case
name|RDMA_CQ_OP
case|:
block|{
name|struct
name|rdma_cq_op
modifier|*
name|req
init|=
name|data
decl_stmt|;
comment|/* may be called in any context */
name|mtx_lock_spin
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_sge_cqcntxt_op
argument_list|(
name|adapter
argument_list|,
name|req
operator|->
name|id
argument_list|,
name|req
operator|->
name|op
argument_list|,
name|req
operator|->
name|credits
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RDMA_GET_MEM
case|:
block|{
name|struct
name|ch_mem_range
modifier|*
name|t
init|=
name|data
decl_stmt|;
name|struct
name|mc7
modifier|*
name|mem
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|addr
operator|&
literal|7
operator|)
operator|||
operator|(
name|t
operator|->
name|len
operator|&
literal|7
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_CM
condition|)
name|mem
operator|=
operator|&
name|adapter
operator|->
name|cm
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_PMRX
condition|)
name|mem
operator|=
operator|&
name|adapter
operator|->
name|pmrx
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_PMTX
condition|)
name|mem
operator|=
operator|&
name|adapter
operator|->
name|pmtx
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ret
operator|=
name|t3_mc7_bd_read
argument_list|(
name|mem
argument_list|,
name|t
operator|->
name|addr
operator|/
literal|8
argument_list|,
name|t
operator|->
name|len
operator|/
literal|8
argument_list|,
operator|(
name|u64
operator|*
operator|)
name|t
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
break|break;
block|}
case|case
name|RDMA_CQ_SETUP
case|:
block|{
name|struct
name|rdma_cq_setup
modifier|*
name|req
init|=
name|data
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_sge_init_cqcntxt
argument_list|(
name|adapter
argument_list|,
name|req
operator|->
name|id
argument_list|,
name|req
operator|->
name|base_addr
argument_list|,
name|req
operator|->
name|size
argument_list|,
name|ASYNC_NOTIF_RSPQ
argument_list|,
name|req
operator|->
name|ovfl_mode
argument_list|,
name|req
operator|->
name|credits
argument_list|,
name|req
operator|->
name|credit_thres
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RDMA_CQ_DISABLE
case|:
name|mtx_lock_spin
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_sge_disable_cqcntxt
argument_list|(
name|adapter
argument_list|,
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDMA_CTRL_QP_SETUP
case|:
block|{
name|struct
name|rdma_ctrlqp_setup
modifier|*
name|req
init|=
name|data
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_sge_init_ecntxt
argument_list|(
name|adapter
argument_list|,
name|FW_RI_SGEEC_START
argument_list|,
literal|0
argument_list|,
name|SGE_CNTXT_RDMA
argument_list|,
name|ASYNC_NOTIF_RSPQ
argument_list|,
name|req
operator|->
name|base_addr
argument_list|,
name|req
operator|->
name|size
argument_list|,
name|FW_RI_TID_START
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ret
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_offload_ctl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|unsigned
name|int
name|req
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|tdev2adap
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
name|struct
name|tid_range
modifier|*
name|tid
decl_stmt|;
name|struct
name|mtutab
modifier|*
name|mtup
decl_stmt|;
name|struct
name|iff_mac
modifier|*
name|iffmacp
decl_stmt|;
name|struct
name|ddp_params
modifier|*
name|ddpp
decl_stmt|;
name|struct
name|adap_ports
modifier|*
name|ports
decl_stmt|;
name|struct
name|ofld_page_info
modifier|*
name|rx_page_info
decl_stmt|;
name|struct
name|tp_params
modifier|*
name|tp
init|=
operator|&
name|adapter
operator|->
name|params
operator|.
name|tp
decl_stmt|;
name|int
name|port
decl_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|GET_MAX_OUTSTANDING_WR
case|:
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|data
operator|=
name|FW_WR_NUM
expr_stmt|;
break|break;
case|case
name|GET_WR_LEN
case|:
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|data
operator|=
name|WR_FLITS
expr_stmt|;
break|break;
case|case
name|GET_TX_MAX_CHUNK
case|:
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|data
operator|=
literal|1
operator|<<
literal|20
expr_stmt|;
comment|/* 1MB */
break|break;
case|case
name|GET_TID_RANGE
case|:
name|tid
operator|=
name|data
expr_stmt|;
name|tid
operator|->
name|num
operator|=
name|t3_mc5_size
argument_list|(
operator|&
name|adapter
operator|->
name|mc5
argument_list|)
operator|-
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nroutes
operator|-
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
operator|-
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nservers
expr_stmt|;
name|tid
operator|->
name|base
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GET_STID_RANGE
case|:
name|tid
operator|=
name|data
expr_stmt|;
name|tid
operator|->
name|num
operator|=
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nservers
expr_stmt|;
name|tid
operator|->
name|base
operator|=
name|t3_mc5_size
argument_list|(
operator|&
name|adapter
operator|->
name|mc5
argument_list|)
operator|-
name|tid
operator|->
name|num
operator|-
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
operator|-
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nroutes
expr_stmt|;
break|break;
case|case
name|GET_L2T_CAPACITY
case|:
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|data
operator|=
literal|2048
expr_stmt|;
break|break;
case|case
name|GET_MTUS
case|:
name|mtup
operator|=
name|data
expr_stmt|;
name|mtup
operator|->
name|size
operator|=
name|NMTUS
expr_stmt|;
name|mtup
operator|->
name|mtus
operator|=
name|adapter
operator|->
name|params
operator|.
name|mtus
expr_stmt|;
break|break;
case|case
name|GET_IFF_FROM_MAC
case|:
name|iffmacp
operator|=
name|data
expr_stmt|;
name|iffmacp
operator|->
name|dev
operator|=
name|get_iff_from_mac
argument_list|(
name|adapter
argument_list|,
name|iffmacp
operator|->
name|mac_addr
argument_list|,
name|iffmacp
operator|->
name|vlan_tag
operator|&
name|EVL_VLID_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_DDP_PARAMS
case|:
name|ddpp
operator|=
name|data
expr_stmt|;
name|ddpp
operator|->
name|llimit
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_TDDP_LLIMIT
argument_list|)
expr_stmt|;
name|ddpp
operator|->
name|ulimit
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_TDDP_ULIMIT
argument_list|)
expr_stmt|;
name|ddpp
operator|->
name|tag_mask
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_TDDP_TAGMASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_PORTS
case|:
name|ports
operator|=
name|data
expr_stmt|;
name|ports
operator|->
name|nports
operator|=
name|adapter
operator|->
name|params
operator|.
name|nports
expr_stmt|;
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|port
argument_list|)
name|ports
operator|->
name|lldevs
index|[
name|port
index|]
operator|=
name|adapter
operator|->
name|port
index|[
name|port
index|]
operator|.
name|ifp
expr_stmt|;
break|break;
case|case
name|FAILOVER
case|:
name|port
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|t3_port_failover
argument_list|(
name|adapter
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|failover_fixup
argument_list|(
name|adapter
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
case|case
name|FAILOVER_DONE
case|:
name|port
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|t3_failover_done
argument_list|(
name|adapter
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
case|case
name|FAILOVER_CLEAR
case|:
name|t3_failover_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_RX_PAGE_INFO
case|:
name|rx_page_info
operator|=
name|data
expr_stmt|;
name|rx_page_info
operator|->
name|page_size
operator|=
name|tp
operator|->
name|rx_pg_size
expr_stmt|;
name|rx_page_info
operator|->
name|num
operator|=
name|tp
operator|->
name|rx_num_pgs
expr_stmt|;
break|break;
case|case
name|ULP_ISCSI_GET_PARAMS
case|:
case|case
name|ULP_ISCSI_SET_PARAMS
case|:
if|if
condition|(
operator|!
name|offload_running
argument_list|(
name|adapter
argument_list|)
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
return|return
name|cxgb_ulp_iscsi_ctl
argument_list|(
name|adapter
argument_list|,
name|req
argument_list|,
name|data
argument_list|)
return|;
case|case
name|RDMA_GET_PARAMS
case|:
case|case
name|RDMA_CQ_OP
case|:
case|case
name|RDMA_CQ_SETUP
case|:
case|case
name|RDMA_CQ_DISABLE
case|:
case|case
name|RDMA_CTRL_QP_SETUP
case|:
case|case
name|RDMA_GET_MEM
case|:
if|if
condition|(
operator|!
name|offload_running
argument_list|(
name|adapter
argument_list|)
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
return|return
name|cxgb_rdma_ctl
argument_list|(
name|adapter
argument_list|,
name|req
argument_list|,
name|data
argument_list|)
return|;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a TOM data structure,  * initialize its cpl_handlers  * and register it as a T3C client  */
end_comment

begin_function
specifier|static
name|void
name|t3c_tom_add
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|wr_len
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|t
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tdev
decl_stmt|;
name|struct
name|adap_ports
modifier|*
name|port_info
decl_stmt|;
name|t
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|,
name|M_CXGB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return;
name|cdev
operator|->
name|send
operator|=
name|t3_offload_tx
expr_stmt|;
name|cdev
operator|->
name|ctl
operator|=
name|cxgb_offload_ctl
expr_stmt|;
if|if
condition|(
name|cdev
operator|->
name|ctl
argument_list|(
name|cdev
argument_list|,
name|GET_WR_LEN
argument_list|,
operator|&
name|wr_len
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|out_free_tom
goto|;
name|port_info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|port_info
argument_list|)
argument_list|,
name|M_CXGB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port_info
condition|)
goto|goto
name|out_free_tom
goto|;
if|if
condition|(
name|cdev
operator|->
name|ctl
argument_list|(
name|cdev
argument_list|,
name|GET_PORTS
argument_list|,
name|port_info
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|out_free_all
goto|;
name|t3_init_wr_tab
argument_list|(
name|wr_len
argument_list|)
expr_stmt|;
name|t
operator|->
name|cdev
operator|=
name|cdev
expr_stmt|;
name|t
operator|->
name|client
operator|=
operator|&
name|t3c_tom_client
expr_stmt|;
comment|/* Register TCP offload device */
name|tdev
operator|=
operator|&
name|t
operator|->
name|tdev
expr_stmt|;
name|tdev
operator|->
name|tod_ttid
operator|=
name|cdev2type
argument_list|(
name|cdev
argument_list|)
expr_stmt|;
name|tdev
operator|->
name|tod_lldev
operator|=
name|cdev
operator|->
name|lldev
expr_stmt|;
if|if
condition|(
name|register_toedev
argument_list|(
name|tdev
argument_list|,
literal|"toe%d"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"unable to register offload device"
argument_list|)
expr_stmt|;
goto|goto
name|out_free_all
goto|;
block|}
name|TOM_DATA
argument_list|(
name|tdev
argument_list|)
operator|=
name|t
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|port_info
operator|->
name|nports
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|port_info
operator|->
name|lldevs
index|[
name|i
index|]
decl_stmt|;
name|TOEDEV
argument_list|(
name|ifp
argument_list|)
operator|=
name|tdev
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_TOM
argument_list|,
literal|"enabling toe on %p"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TOE4
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TOE4
expr_stmt|;
block|}
name|t
operator|->
name|ports
operator|=
name|port_info
expr_stmt|;
comment|/* Add device to the list of offload devices */
name|t3cdev_add
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Activate TCP offload device */
name|cxgb_offload_activate
argument_list|(
name|TOM_DATA
argument_list|(
name|tdev
argument_list|)
operator|->
name|cdev
operator|->
name|adapter
argument_list|)
expr_stmt|;
name|activate_offload
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
name|cxgb_register_listeners
argument_list|()
expr_stmt|;
return|return;
name|out_free_all
label|:
name|printf
argument_list|(
literal|"out_free_all fail\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|port_info
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
name|out_free_tom
label|:
name|printf
argument_list|(
literal|"out_free_tom fail\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|do_act_open_rpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_act_open_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|atid
init|=
name|G_TID
argument_list|(
name|ntohl
argument_list|(
name|rpl
operator|->
name|atid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|toe_tid
decl_stmt|;
name|toe_tid
operator|=
name|lookup_atid
argument_list|(
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|dev
argument_list|)
operator|)
operator|->
name|tid_maps
argument_list|,
name|atid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toe_tid
operator|->
name|ctx
operator|&&
name|toe_tid
operator|->
name|client
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|CPL_ACT_OPEN_RPL
index|]
condition|)
block|{
return|return
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|CPL_ACT_OPEN_RPL
index|]
operator|(
name|dev
operator|,
name|m
operator|,
name|toe_tid
operator|->
name|ctx
operator|)
return|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received clientless CPL command 0x%x\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|CPL_ACT_OPEN_RPL
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_stid_rpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|union
name|opcode_tid
modifier|*
name|p
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|stid
init|=
name|G_TID
argument_list|(
name|ntohl
argument_list|(
name|p
operator|->
name|opcode_tid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|toe_tid
decl_stmt|;
name|toe_tid
operator|=
name|lookup_stid
argument_list|(
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|dev
argument_list|)
operator|)
operator|->
name|tid_maps
argument_list|,
name|stid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toe_tid
operator|->
name|ctx
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|p
operator|->
name|opcode
index|]
condition|)
block|{
return|return
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|p
operator|->
name|opcode
index|]
operator|(
name|dev
operator|,
name|m
operator|,
name|toe_tid
operator|->
name|ctx
operator|)
return|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received clientless CPL command 0x%x\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|p
operator|->
name|opcode
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_hwtid_rpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|union
name|opcode_tid
modifier|*
name|p
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|hwtid
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|toe_tid
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"do_hwtid_rpl opcode=0x%x\n"
argument_list|,
name|p
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|hwtid
operator|=
name|G_TID
argument_list|(
name|ntohl
argument_list|(
name|p
operator|->
name|opcode_tid
argument_list|)
argument_list|)
expr_stmt|;
name|toe_tid
operator|=
name|lookup_tid
argument_list|(
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|dev
argument_list|)
operator|)
operator|->
name|tid_maps
argument_list|,
name|hwtid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toe_tid
operator|->
name|ctx
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|p
operator|->
name|opcode
index|]
condition|)
block|{
return|return
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|p
operator|->
name|opcode
index|]
operator|(
name|dev
operator|,
name|m
operator|,
name|toe_tid
operator|->
name|ctx
operator|)
return|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received clientless CPL command 0x%x\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|p
operator|->
name|opcode
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_cr
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_pass_accept_req
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|stid
init|=
name|G_PASS_OPEN_TID
argument_list|(
name|ntohl
argument_list|(
name|req
operator|->
name|tos_tid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|toe_tid
decl_stmt|;
name|toe_tid
operator|=
name|lookup_stid
argument_list|(
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|dev
argument_list|)
operator|)
operator|->
name|tid_maps
argument_list|,
name|stid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toe_tid
operator|->
name|ctx
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|CPL_PASS_ACCEPT_REQ
index|]
condition|)
block|{
return|return
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|CPL_PASS_ACCEPT_REQ
index|]
operator|(
name|dev
operator|,
name|m
operator|,
name|toe_tid
operator|->
name|ctx
operator|)
return|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received clientless CPL command 0x%x\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|CPL_PASS_ACCEPT_REQ
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_abort_req_rss
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|union
name|opcode_tid
modifier|*
name|p
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|hwtid
init|=
name|G_TID
argument_list|(
name|ntohl
argument_list|(
name|p
operator|->
name|opcode_tid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|toe_tid
decl_stmt|;
name|toe_tid
operator|=
name|lookup_tid
argument_list|(
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|dev
argument_list|)
operator|)
operator|->
name|tid_maps
argument_list|,
name|hwtid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toe_tid
operator|->
name|ctx
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|p
operator|->
name|opcode
index|]
condition|)
block|{
return|return
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|p
operator|->
name|opcode
index|]
operator|(
name|dev
operator|,
name|m
operator|,
name|toe_tid
operator|->
name|ctx
operator|)
return|;
block|}
else|else
block|{
name|struct
name|cpl_abort_req_rss
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|cpl_abort_rpl
modifier|*
name|rpl
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m_get
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"do_abort_req_rss: couldn't get mbuf!\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|CPL_PRIORITY_DATA
argument_list|)
expr_stmt|;
name|rpl
operator|=
name|cplhdr
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_OFLD_HOST_ABORT_CON_RPL
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|wr
operator|.
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|GET_TID
argument_list|(
name|req
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|rpl
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_ABORT_RPL
argument_list|,
name|GET_TID
argument_list|(
name|req
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|cmd
operator|=
name|req
operator|->
name|status
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|dev
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|CPL_RET_BUF_DONE
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_act_establish
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_act_establish
modifier|*
name|req
decl_stmt|;
name|unsigned
name|int
name|atid
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|toe_tid
decl_stmt|;
name|req
operator|=
name|cplhdr
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|atid
operator|=
name|G_PASS_OPEN_TID
argument_list|(
name|ntohl
argument_list|(
name|req
operator|->
name|tos_tid
argument_list|)
argument_list|)
expr_stmt|;
name|toe_tid
operator|=
name|lookup_atid
argument_list|(
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|dev
argument_list|)
operator|)
operator|->
name|tid_maps
argument_list|,
name|atid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toe_tid
operator|&&
name|toe_tid
operator|->
name|ctx
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|CPL_ACT_ESTABLISH
index|]
condition|)
block|{
return|return
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|CPL_ACT_ESTABLISH
index|]
operator|(
name|dev
operator|,
name|m
operator|,
name|toe_tid
operator|->
name|ctx
operator|)
return|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received clientless CPL command 0x%x\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|CPL_ACT_ESTABLISH
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_term
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|unsigned
name|int
name|hwtid
init|=
name|ntohl
argument_list|(
name|m_get_priority
argument_list|(
name|m
argument_list|)
argument_list|)
operator|>>
literal|8
operator|&
literal|0xfffff
decl_stmt|;
name|unsigned
name|int
name|opcode
init|=
name|G_OPCODE
argument_list|(
name|ntohl
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|toe_tid
decl_stmt|;
name|toe_tid
operator|=
name|lookup_tid
argument_list|(
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|dev
argument_list|)
operator|)
operator|->
name|tid_maps
argument_list|,
name|hwtid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toe_tid
operator|&&
name|toe_tid
operator|->
name|ctx
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|opcode
index|]
condition|)
block|{
return|return
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|opcode
index|]
operator|(
name|dev
operator|,
name|m
operator|,
name|toe_tid
operator|->
name|ctx
operator|)
return|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received clientless CPL command 0x%x\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a received packet with an unknown/unexpected CPL opcode.  */
end_comment

begin_function
specifier|static
name|int
name|do_bad_cpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received bad CPL command %u\n"
argument_list|,
name|cdev
operator|->
name|name
argument_list|,
literal|0xFF
operator|&
operator|*
name|mtod
argument_list|(
argument|m
argument_list|,
argument|unsigned int *
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a new handler to the CPL dispatch table.  A NULL handler may be supplied  * to unregister an existing handler.  */
end_comment

begin_function
name|void
name|t3tom_register_cpl_handler
parameter_list|(
name|unsigned
name|int
name|opcode
parameter_list|,
name|cxgb_cpl_handler_func
name|h
parameter_list|)
block|{
if|if
condition|(
name|opcode
operator|<
name|UCHAR_MAX
condition|)
name|tom_cpl_handlers
index|[
name|opcode
index|]
operator|=
name|h
condition|?
name|h
else|:
name|do_bad_cpl
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Chelsio T3 TOM: handler registration for "
literal|"opcode %u failed\n"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make a preliminary determination if a connection can be offloaded.  It's OK  * to fail the offload later if we say we can offload here.  For now this  * always accepts the offload request unless there are IP options.  */
end_comment

begin_function
specifier|static
name|int
name|can_offload
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|tomd
init|=
name|TOM_DATA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|t3cdev
modifier|*
name|cdev
init|=
name|T3CDEV
argument_list|(
name|dev
operator|->
name|tod_lldev
argument_list|)
decl_stmt|;
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|cdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
return|return
name|so_sotoinpcb
argument_list|(
name|so
argument_list|)
operator|->
name|inp_depend4
operator|.
name|inp4_options
operator|==
name|NULL
operator|&&
name|tomd
operator|->
name|conf
operator|.
name|activated
operator|&&
operator|(
name|tomd
operator|->
name|conf
operator|.
name|max_conn
operator|<
literal|0
operator|||
name|atomic_load_acq_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|)
operator|+
name|t
operator|->
name|atids_in_use
operator|<
name|tomd
operator|->
name|conf
operator|.
name|max_conn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tom_ctl
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|unsigned
name|int
name|req
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|t
init|=
name|TOM_DATA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|t3cdev
modifier|*
name|cdev
init|=
name|t
operator|->
name|cdev
decl_stmt|;
if|if
condition|(
name|cdev
operator|->
name|ctl
condition|)
return|return
name|cdev
operator|->
name|ctl
argument_list|(
name|cdev
argument_list|,
name|req
argument_list|,
name|data
argument_list|)
return|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free an active-open TID.  */
end_comment

begin_function
name|void
modifier|*
name|cxgb_free_atid
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|int
name|atid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
name|union
name|active_open_entry
modifier|*
name|p
init|=
name|atid2entry
argument_list|(
name|t
argument_list|,
name|atid
argument_list|)
decl_stmt|;
name|void
modifier|*
name|ctx
init|=
name|p
operator|->
name|toe_tid
operator|.
name|ctx
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|t
operator|->
name|afree
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|atids_in_use
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
return|return
name|ctx
return|;
block|}
end_function

begin_comment
comment|/*  * Free a server TID and return it to the free pool.  */
end_comment

begin_function
name|void
name|cxgb_free_stid
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|int
name|stid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
name|union
name|listen_entry
modifier|*
name|p
init|=
name|stid2entry
argument_list|(
name|t
argument_list|,
name|stid
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|t
operator|->
name|sfree
expr_stmt|;
name|t
operator|->
name|sfree
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|stids_in_use
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a server TID and return it to the free pool.  */
end_comment

begin_function
name|void
modifier|*
name|cxgb_get_lctx
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|int
name|stid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
name|union
name|listen_entry
modifier|*
name|p
init|=
name|stid2entry
argument_list|(
name|t
argument_list|,
name|stid
argument_list|)
decl_stmt|;
return|return
operator|(
name|p
operator|->
name|toe_tid
operator|.
name|ctx
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cxgb_insert_tid
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|struct
name|cxgb_client
modifier|*
name|client
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|.
name|client
operator|=
name|client
expr_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* use ctx as a next pointer in the tid release list */
end_comment

begin_function
name|void
name|cxgb_queue_tid_release
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|struct
name|t3c_data
modifier|*
name|td
init|=
name|T3C_DATA
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|p
init|=
operator|&
name|td
operator|->
name|tid_maps
operator|.
name|tid_tab
index|[
name|tid
index|]
decl_stmt|;
name|CTR0
argument_list|(
name|KTR_TOM
argument_list|,
literal|"queuing tid release\n"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|ctx
operator|=
name|td
operator|->
name|tid_release_list
expr_stmt|;
name|td
operator|->
name|tid_release_list
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|ctx
condition|)
name|taskqueue_enqueue
argument_list|(
name|tdev
operator|->
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|td
operator|->
name|tid_release_task
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a tid from the TID table.  A client may defer processing its last  * CPL message if it is locked at the time it arrives, and while the message  * sits in the client's backlog the TID may be reused for another connection.  * To handle this we atomically switch the TID association if it still points  * to the original client context.  */
end_comment

begin_function
name|void
name|cxgb_remove_tid
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
if|if
condition|(
name|tid
operator|>=
name|t
operator|->
name|ntids
condition|)
name|panic
argument_list|(
literal|"tid=%d>= t->ntids=%d"
argument_list|,
name|tid
argument_list|,
name|t
operator|->
name|ntids
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdev
operator|->
name|type
operator|==
name|T3A
condition|)
name|atomic_cmpset_ptr
argument_list|(
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|.
name|ctx
argument_list|,
operator|(
name|long
operator|)
name|NULL
argument_list|,
operator|(
name|long
operator|)
name|ctx
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_get
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|m
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|mk_tid_release
argument_list|(
name|m
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"releasing tid=%u"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|tdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|.
name|ctx
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|cxgb_queue_tid_release
argument_list|(
name|tdev
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cxgb_alloc_atid
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|struct
name|cxgb_client
modifier|*
name|client
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|atid
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|afree
condition|)
block|{
name|union
name|active_open_entry
modifier|*
name|p
init|=
name|t
operator|->
name|afree
decl_stmt|;
name|atid
operator|=
operator|(
name|p
operator|-
name|t
operator|->
name|atid_tab
operator|)
operator|+
name|t
operator|->
name|atid_base
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|toe_tid
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|p
operator|->
name|toe_tid
operator|.
name|client
operator|=
name|client
expr_stmt|;
name|t
operator|->
name|atids_in_use
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
return|return
name|atid
return|;
block|}
end_function

begin_function
name|int
name|cxgb_alloc_stid
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|struct
name|cxgb_client
modifier|*
name|client
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|stid
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sfree
condition|)
block|{
name|union
name|listen_entry
modifier|*
name|p
init|=
name|t
operator|->
name|sfree
decl_stmt|;
name|stid
operator|=
operator|(
name|p
operator|-
name|t
operator|->
name|stid_tab
operator|)
operator|+
name|t
operator|->
name|stid_base
expr_stmt|;
name|t
operator|->
name|sfree
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|toe_tid
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|p
operator|->
name|toe_tid
operator|.
name|client
operator|=
name|client
expr_stmt|;
name|t
operator|->
name|stids_in_use
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
return|return
name|stid
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_offloading
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|int
name|port
decl_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|adapter
argument_list|,
argument|&adapter_list
argument_list|,
argument|adapter_entry
argument_list|)
block|{
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|port
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|==
name|adapter
operator|->
name|port
index|[
name|port
index|]
operator|.
name|ifp
condition|)
block|{
name|rw_runlock
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
name|rw_runlock
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_arp_update_event
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt0
parameter_list|,
name|uint8_t
modifier|*
name|enaddr
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_offloading
argument_list|(
name|rt0
operator|->
name|rt_ifp
argument_list|)
condition|)
return|return;
name|RT_ADDREF
argument_list|(
name|rt0
argument_list|)
expr_stmt|;
name|RT_UNLOCK
argument_list|(
name|rt0
argument_list|)
expr_stmt|;
name|cxgb_neigh_update
argument_list|(
name|rt0
argument_list|,
name|enaddr
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|RT_LOCK
argument_list|(
name|rt0
argument_list|)
expr_stmt|;
name|RT_REMREF
argument_list|(
name|rt0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_redirect_event
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|,
name|int
name|event
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt0
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt1
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
comment|/*  	 * ignore events on non-offloaded interfaces 	 */
if|if
condition|(
operator|!
name|is_offloading
argument_list|(
name|rt0
operator|->
name|rt_ifp
argument_list|)
condition|)
return|return;
comment|/* 	 * Cannot redirect to non-offload device. 	 */
if|if
condition|(
operator|!
name|is_offloading
argument_list|(
name|rt1
operator|->
name|rt_ifp
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: Redirect to non-offload"
literal|"device ignored.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * avoid LORs by dropping the route lock but keeping a reference 	 *  	 */
name|RT_ADDREF
argument_list|(
name|rt0
argument_list|)
expr_stmt|;
name|RT_UNLOCK
argument_list|(
name|rt0
argument_list|)
expr_stmt|;
name|RT_ADDREF
argument_list|(
name|rt1
argument_list|)
expr_stmt|;
name|RT_UNLOCK
argument_list|(
name|rt1
argument_list|)
expr_stmt|;
name|cxgb_redirect
argument_list|(
name|rt0
argument_list|,
name|rt1
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|cxgb_neigh_update
argument_list|(
name|rt1
argument_list|,
name|NULL
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|RT_LOCK
argument_list|(
name|rt0
argument_list|)
expr_stmt|;
name|RT_REMREF
argument_list|(
name|rt0
argument_list|)
expr_stmt|;
name|RT_LOCK
argument_list|(
name|rt1
argument_list|)
expr_stmt|;
name|RT_REMREF
argument_list|(
name|rt1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxgb_neigh_update
parameter_list|(
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|,
name|uint8_t
modifier|*
name|enaddr
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|&&
name|is_offloading
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|)
operator|&&
operator|(
name|rt
operator|->
name|rt_ifp
operator|->
name|if_flags
operator|&
name|IFCAP_TOE
operator|)
condition|)
block|{
name|struct
name|t3cdev
modifier|*
name|tdev
init|=
name|T3CDEV
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|)
decl_stmt|;
name|PANIC_IF
argument_list|(
operator|!
name|tdev
argument_list|)
expr_stmt|;
name|t3_l2t_update
argument_list|(
name|tdev
argument_list|,
name|rt
argument_list|,
name|enaddr
argument_list|,
name|sa
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_l2t_ix
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|u32
name|tid
parameter_list|,
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cpl_set_tcb_field
modifier|*
name|req
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: cannot allocate mbuf!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|CPL_PRIORITY_CONTROL
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_set_tcb_field
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_SET_TCB_FIELD
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|reply
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|cpu_idx
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|word
operator|=
name|htons
argument_list|(
name|W_TCB_L2T_IX
argument_list|)
expr_stmt|;
name|req
operator|->
name|mask
operator|=
name|htobe64
argument_list|(
name|V_TCB_L2T_IX
argument_list|(
name|M_TCB_L2T_IX
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|val
operator|=
name|htobe64
argument_list|(
name|V_TCB_L2T_IX
argument_list|(
name|e
operator|->
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|tdev
operator|->
name|send
argument_list|(
name|tdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxgb_redirect
parameter_list|(
name|struct
name|rtentry
modifier|*
name|old
parameter_list|,
name|struct
name|rtentry
modifier|*
name|new
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|olddev
decl_stmt|,
modifier|*
name|newdev
decl_stmt|;
name|struct
name|tid_info
modifier|*
name|ti
decl_stmt|;
name|struct
name|t3cdev
modifier|*
name|tdev
decl_stmt|;
name|u32
name|tid
decl_stmt|;
name|int
name|update_tcb
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|te
decl_stmt|;
name|olddev
operator|=
name|old
operator|->
name|rt_ifp
expr_stmt|;
name|newdev
operator|=
name|new
operator|->
name|rt_ifp
expr_stmt|;
if|if
condition|(
operator|!
name|is_offloading
argument_list|(
name|olddev
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|is_offloading
argument_list|(
name|newdev
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: Redirect to non-offload"
literal|"device ignored.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
name|tdev
operator|=
name|T3CDEV
argument_list|(
name|olddev
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
operator|!
name|tdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdev
operator|!=
name|T3CDEV
argument_list|(
name|newdev
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: Redirect to different "
literal|"offload device ignored.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Add new L2T entry */
name|e
operator|=
name|t3_l2t_get
argument_list|(
name|tdev
argument_list|,
name|new
argument_list|,
name|new
operator|->
name|rt_ifp
argument_list|,
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: couldn't allocate new l2t entry!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Walk tid table and notify clients of dst change. */
name|ti
operator|=
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
expr_stmt|;
for|for
control|(
name|tid
operator|=
literal|0
init|;
name|tid
operator|<
name|ti
operator|->
name|ntids
condition|;
name|tid
operator|++
control|)
block|{
name|te
operator|=
name|lookup_tid
argument_list|(
name|ti
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
operator|!
name|te
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|ctx
operator|&&
name|te
operator|->
name|client
operator|&&
name|te
operator|->
name|client
operator|->
name|redirect
condition|)
block|{
name|update_tcb
operator|=
name|te
operator|->
name|client
operator|->
name|redirect
argument_list|(
name|te
operator|->
name|ctx
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_tcb
condition|)
block|{
name|l2t_hold
argument_list|(
name|L2DATA
argument_list|(
name|tdev
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|set_l2t_ix
argument_list|(
name|tdev
argument_list|,
name|tid
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|l2t_release
argument_list|(
name|L2DATA
argument_list|(
name|tdev
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the CPL dispatch table.  */
end_comment

begin_function
specifier|static
name|void
name|init_cpl_handlers
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|tom_cpl_handlers
index|[
name|i
index|]
operator|=
name|do_bad_cpl
expr_stmt|;
name|t3_init_listen_cpl_handlers
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_toe_attach
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
specifier|const
name|struct
name|offload_id
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|t
init|=
name|TOM_DATA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|t3cdev
modifier|*
name|cdev
init|=
name|t
operator|->
name|cdev
decl_stmt|;
name|struct
name|ddp_params
name|ddp
decl_stmt|;
name|struct
name|ofld_page_info
name|rx_page_info
decl_stmt|;
name|int
name|err
decl_stmt|;
name|t3_init_tunables
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|t
operator|->
name|listen_lock
argument_list|,
literal|"tom data listeners"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_toe_attach dev=%p entry=%p"
argument_list|,
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|dev
operator|->
name|tod_can_offload
operator|=
name|can_offload
expr_stmt|;
name|dev
operator|->
name|tod_connect
operator|=
name|t3_connect
expr_stmt|;
name|dev
operator|->
name|tod_ctl
operator|=
name|tom_ctl
expr_stmt|;
if|#
directive|if
literal|0
block|dev->tod_failover = t3_failover;
endif|#
directive|endif
name|err
operator|=
name|cdev
operator|->
name|ctl
argument_list|(
name|cdev
argument_list|,
name|GET_DDP_PARAMS
argument_list|,
operator|&
name|ddp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|cdev
operator|->
name|ctl
argument_list|(
name|cdev
argument_list|,
name|GET_RX_PAGE_INFO
argument_list|,
operator|&
name|rx_page_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|t
operator|->
name|ddp_llimit
operator|=
name|ddp
operator|.
name|llimit
expr_stmt|;
name|t
operator|->
name|ddp_ulimit
operator|=
name|ddp
operator|.
name|ulimit
expr_stmt|;
name|t
operator|->
name|pdev
operator|=
name|ddp
operator|.
name|pdev
expr_stmt|;
name|t
operator|->
name|rx_page_size
operator|=
name|rx_page_info
operator|.
name|page_size
expr_stmt|;
comment|/* OK if this fails, we just can't do DDP */
name|t
operator|->
name|nppods
operator|=
operator|(
name|ddp
operator|.
name|ulimit
operator|+
literal|1
operator|-
name|ddp
operator|.
name|llimit
operator|)
operator|/
name|PPOD_SIZE
expr_stmt|;
name|t
operator|->
name|ppod_map
operator|=
name|malloc
argument_list|(
name|t
operator|->
name|nppods
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|t
operator|->
name|ppod_map_lock
argument_list|,
literal|"ppod map"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|t3_sysctl_register
argument_list|(
name|cdev
operator|->
name|adapter
argument_list|,
operator|&
name|t
operator|->
name|conf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_toe_listen_start
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|p
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cxgb_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&cxgb_list
argument_list|,
argument|entry
argument_list|)
block|{
name|t3_listen_start
argument_list|(
operator|&
name|p
operator|->
name|tdev
argument_list|,
name|so
argument_list|,
name|p
operator|->
name|cdev
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_toe_listen_stop
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|p
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cxgb_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&cxgb_list
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_LISTEN
condition|)
name|t3_listen_stop
argument_list|(
operator|&
name|p
operator|->
name|tdev
argument_list|,
name|so
argument_list|,
name|p
operator|->
name|cdev
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_toe_listen_start_handler
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_LISTEN
condition|)
name|cxgb_toe_listen_start
argument_list|(
name|NULL
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_register_listeners
parameter_list|(
name|void
parameter_list|)
block|{
name|inp_apply_all
argument_list|(
name|cxgb_toe_listen_start_handler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_tom_init
parameter_list|(
name|void
parameter_list|)
block|{
name|init_cpl_handlers
argument_list|()
expr_stmt|;
if|if
condition|(
name|t3_init_cpl_io
argument_list|()
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to initialize cpl io ops\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|t3_init_socket_ops
argument_list|()
expr_stmt|;
comment|/* Register with the TOE device layer. */
if|if
condition|(
name|register_tom
argument_list|(
operator|&
name|t3_tom_info
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to register Chelsio T3 TCP offload module.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rw_init
argument_list|(
operator|&
name|adapter_list_lock
argument_list|,
literal|"ofld adap list"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|adapter_list
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|route_arp_update_event
argument_list|,
name|cxgb_arp_update_event
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|route_redirect_event
argument_list|,
name|cxgb_redirect_event
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|cxgb_list_lock
argument_list|,
literal|"cxgb tom list"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|listen_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|tcp_offload_listen_start
argument_list|,
name|cxgb_toe_listen_start
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|listen_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|tcp_offload_listen_stop
argument_list|,
name|cxgb_toe_listen_stop
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cxgb_list
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_PASS_OPEN_RPL
argument_list|,
name|do_stid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_CLOSE_LISTSRV_RPL
argument_list|,
name|do_stid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_PASS_ACCEPT_REQ
argument_list|,
name|do_cr
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_PASS_ESTABLISH
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_ABORT_RPL_RSS
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_ABORT_RPL
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_RX_URG_NOTIFY
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_RX_DATA
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_TX_DATA_ACK
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_TX_DMA_ACK
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_ACT_OPEN_RPL
argument_list|,
name|do_act_open_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_PEER_CLOSE
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_CLOSE_CON_RPL
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_ABORT_REQ_RSS
argument_list|,
name|do_abort_req_rss
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_ACT_ESTABLISH
argument_list|,
name|do_act_establish
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_RDMA_TERMINATE
argument_list|,
name|do_term
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_RDMA_EC_STATUS
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_RX_DATA_DDP
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_RX_DDP_COMPLETE
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_ISCSI_HDR
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_GET_TCB_RPL
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_SET_TCB_RPL
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
comment|/* Register to offloading devices */
name|cxgb_register_client
argument_list|(
operator|&
name|t3c_tom_client
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_tom_load
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|t3_tom_init
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_QUIESCE
case|:
break|break;
case|case
name|MOD_UNLOAD
case|:
name|printf
argument_list|(
literal|"uhm, ... unloading isn't really supported for toe\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|err
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|mod_data
init|=
block|{
literal|"t3_tom"
block|,
name|t3_tom_load
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|t3_tom
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|t3_tom
argument_list|,
name|toecore
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|t3_tom
argument_list|,
name|if_cxgb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|t3_tom
argument_list|,
name|mod_data
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

