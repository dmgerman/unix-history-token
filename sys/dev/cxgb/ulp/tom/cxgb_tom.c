begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_osdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/sys/mbufq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_ofld.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/t3cdev.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_firmware_exports.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_tcb.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_include.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_ctl_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_t3_cpl.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_offload.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_l2t.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/toecore/cxgb_toedev.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tom.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_t3_ddp.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_toepcb.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|activated
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.t3toe.activated"
argument_list|,
operator|&
name|activated
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|t3toe
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"T3 toe driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_t3toe
argument_list|,
name|OID_AUTO
argument_list|,
name|activated
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|activated
argument_list|,
literal|0
argument_list|,
literal|"enable TOE at init time"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|tom_data
argument_list|)
name|cxgb_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|cxgb_list_lock
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|t3_toe_attach
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
specifier|const
name|struct
name|offload_id
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Handlers for each CPL opcode  */
end_comment

begin_decl_stmt
specifier|static
name|cxgb_cpl_handler_func
name|tom_cpl_handlers
index|[
name|NUM_CPL_CMDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|listen_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|offload_id
name|t3_toe_id_tab
index|[]
init|=
block|{
block|{
name|TOE_ID_CHELSIO_T3
block|,
literal|0
block|}
block|,
block|{
name|TOE_ID_CHELSIO_T3B
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tom_info
name|t3_tom_info
init|=
block|{
operator|.
name|ti_attach
operator|=
name|t3_toe_attach
block|,
operator|.
name|ti_id_table
operator|=
name|t3_toe_id_tab
block|,
operator|.
name|ti_name
operator|=
literal|"Chelsio-T3"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cxgb_client
name|t3c_tom_client
init|=
block|{
operator|.
name|name
operator|=
literal|"tom_cxgb3"
block|,
operator|.
name|remove
operator|=
name|NULL
block|,
operator|.
name|handlers
operator|=
name|tom_cpl_handlers
block|,
operator|.
name|redirect
operator|=
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Add an skb to the deferred skb queue for processing from process context.  */
end_comment

begin_function
name|void
name|t3_defer_reply
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|defer_handler_t
name|handler
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|TOM_DATA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|m_set_handler
argument_list|(
name|m
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|deferq
operator|.
name|lock
argument_list|)
expr_stmt|;
name|mbufq_tail
argument_list|(
operator|&
name|td
operator|->
name|deferq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbufq_len
argument_list|(
operator|&
name|td
operator|->
name|deferq
argument_list|)
operator|==
literal|1
condition|)
name|taskqueue_enqueue
argument_list|(
name|td
operator|->
name|tq
argument_list|,
operator|&
name|td
operator|->
name|deferq_task
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|deferq
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|toepcb
modifier|*
name|toepcb_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
name|toep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|toepcb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|toepcb_init
argument_list|(
name|toep
argument_list|)
expr_stmt|;
return|return
operator|(
name|toep
operator|)
return|;
block|}
end_function

begin_function
name|void
name|toepcb_init
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|bzero
argument_list|(
name|toep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|toep
argument_list|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_refcount
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|toepcb_hold
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|atomic_add_acq_int
argument_list|(
operator|&
name|toep
operator|->
name|tp_refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|toepcb_release
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
if|if
condition|(
name|toep
operator|->
name|tp_refcount
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"doing final toepcb free\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|toep
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|atomic_add_acq_int
argument_list|(
operator|&
name|toep
operator|->
name|tp_refcount
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a T3 offload device to the list of devices we are managing.  */
end_comment

begin_function
specifier|static
name|void
name|t3cdev_add
parameter_list|(
name|struct
name|tom_data
modifier|*
name|t
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|cxgb_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cxgb_list
argument_list|,
name|t
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a TOM data structure,  * initialize its cpl_handlers  * and register it as a T3C client  */
end_comment

begin_function
specifier|static
name|void
name|t3c_tom_add
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|wr_len
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|t
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tdev
decl_stmt|;
name|struct
name|adap_ports
modifier|*
name|port_info
decl_stmt|;
name|t
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|,
name|M_CXGB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return;
if|if
condition|(
name|cdev
operator|->
name|ctl
argument_list|(
name|cdev
argument_list|,
name|GET_WR_LEN
argument_list|,
operator|&
name|wr_len
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|out_free_tom
goto|;
name|port_info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|port_info
argument_list|)
argument_list|,
name|M_CXGB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port_info
condition|)
goto|goto
name|out_free_tom
goto|;
if|if
condition|(
name|cdev
operator|->
name|ctl
argument_list|(
name|cdev
argument_list|,
name|GET_PORTS
argument_list|,
name|port_info
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|out_free_all
goto|;
name|t3_init_wr_tab
argument_list|(
name|wr_len
argument_list|)
expr_stmt|;
name|t
operator|->
name|cdev
operator|=
name|cdev
expr_stmt|;
name|t
operator|->
name|client
operator|=
operator|&
name|t3c_tom_client
expr_stmt|;
comment|/* Register TCP offload device */
name|tdev
operator|=
operator|&
name|t
operator|->
name|tdev
expr_stmt|;
name|tdev
operator|->
name|tod_ttid
operator|=
operator|(
name|cdev
operator|->
name|type
operator|==
name|T3A
condition|?
name|TOE_ID_CHELSIO_T3
else|:
name|TOE_ID_CHELSIO_T3B
operator|)
expr_stmt|;
name|tdev
operator|->
name|tod_lldev
operator|=
name|cdev
operator|->
name|lldev
expr_stmt|;
if|if
condition|(
name|register_toedev
argument_list|(
name|tdev
argument_list|,
literal|"toe%d"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"unable to register offload device"
argument_list|)
expr_stmt|;
goto|goto
name|out_free_all
goto|;
block|}
name|TOM_DATA
argument_list|(
name|tdev
argument_list|)
operator|=
name|t
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|port_info
operator|->
name|nports
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|port_info
operator|->
name|lldevs
index|[
name|i
index|]
decl_stmt|;
name|TOEDEV
argument_list|(
name|ifp
argument_list|)
operator|=
name|tdev
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TOE
expr_stmt|;
block|}
name|t
operator|->
name|ports
operator|=
name|port_info
expr_stmt|;
comment|/* Add device to the list of offload devices */
name|t3cdev_add
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Activate TCP offload device */
name|activate_offload
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
return|return;
name|out_free_all
label|:
name|free
argument_list|(
name|port_info
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
name|out_free_tom
label|:
name|free
argument_list|(
name|t
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Process a received packet with an unknown/unexpected CPL opcode.  */
end_comment

begin_function
specifier|static
name|int
name|do_bad_cpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received bad CPL command %u\n"
argument_list|,
name|cdev
operator|->
name|name
argument_list|,
operator|*
name|mtod
argument_list|(
argument|m
argument_list|,
argument|unsigned int *
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a new handler to the CPL dispatch table.  A NULL handler may be supplied  * to unregister an existing handler.  */
end_comment

begin_function
name|void
name|t3tom_register_cpl_handler
parameter_list|(
name|unsigned
name|int
name|opcode
parameter_list|,
name|cxgb_cpl_handler_func
name|h
parameter_list|)
block|{
if|if
condition|(
name|opcode
operator|<
name|NUM_CPL_CMDS
condition|)
name|tom_cpl_handlers
index|[
name|opcode
index|]
operator|=
name|h
condition|?
name|h
else|:
name|do_bad_cpl
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Chelsio T3 TOM: handler registration for "
literal|"opcode %u failed\n"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make a preliminary determination if a connection can be offloaded.  It's OK  * to fail the offload later if we say we can offload here.  For now this  * always accepts the offload request unless there are IP options.  */
end_comment

begin_function
specifier|static
name|int
name|can_offload
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|tomd
init|=
name|TOM_DATA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|t3cdev
modifier|*
name|cdev
init|=
name|T3CDEV
argument_list|(
name|dev
operator|->
name|tod_lldev
argument_list|)
decl_stmt|;
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|cdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
return|return
name|sotoinpcb
argument_list|(
name|so
argument_list|)
operator|->
name|inp_depend4
operator|.
name|inp4_options
operator|==
name|NULL
operator|&&
name|tomd
operator|->
name|conf
operator|.
name|activated
operator|&&
operator|(
name|tomd
operator|->
name|conf
operator|.
name|max_conn
operator|<
literal|0
operator|||
name|atomic_load_acq_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|)
operator|+
name|t
operator|->
name|atids_in_use
operator|<
name|tomd
operator|->
name|conf
operator|.
name|max_conn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tom_ctl
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|unsigned
name|int
name|req
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|t
init|=
name|TOM_DATA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|t3cdev
modifier|*
name|cdev
init|=
name|t
operator|->
name|cdev
decl_stmt|;
if|if
condition|(
name|cdev
operator|->
name|ctl
condition|)
return|return
name|cdev
operator|->
name|ctl
argument_list|(
name|cdev
argument_list|,
name|req
argument_list|,
name|data
argument_list|)
return|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the CPL dispatch table.  */
end_comment

begin_function
specifier|static
name|void
name|init_cpl_handlers
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_CPL_CMDS
condition|;
operator|++
name|i
control|)
name|tom_cpl_handlers
index|[
name|i
index|]
operator|=
name|do_bad_cpl
expr_stmt|;
name|t3_init_listen_cpl_handlers
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_toe_attach
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
specifier|const
name|struct
name|offload_id
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|t
init|=
name|TOM_DATA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|t3cdev
modifier|*
name|cdev
init|=
name|t
operator|->
name|cdev
decl_stmt|;
name|struct
name|ddp_params
name|ddp
decl_stmt|;
name|struct
name|ofld_page_info
name|rx_page_info
decl_stmt|;
name|int
name|err
decl_stmt|;
if|#
directive|if
literal|0
block|skb_queue_head_init(&t->deferq); 	T3_INIT_WORK(&t->deferq_task, process_deferq, t); 	spin_lock_init(&t->listen_lock);
endif|#
directive|endif
name|t3_init_tunables
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|t
operator|->
name|listen_lock
argument_list|,
literal|"tom data listeners"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Adjust TOE activation for this module */
name|t
operator|->
name|conf
operator|.
name|activated
operator|=
name|activated
expr_stmt|;
name|dev
operator|->
name|tod_can_offload
operator|=
name|can_offload
expr_stmt|;
name|dev
operator|->
name|tod_connect
operator|=
name|t3_connect
expr_stmt|;
name|dev
operator|->
name|tod_ctl
operator|=
name|tom_ctl
expr_stmt|;
if|#
directive|if
literal|0
ifndef|#
directive|ifndef
name|NETEVENT
block|dev->tod_neigh_update = tom_neigh_update;
endif|#
directive|endif
block|dev->tod_failover = t3_failover;
endif|#
directive|endif
name|err
operator|=
name|cdev
operator|->
name|ctl
argument_list|(
name|cdev
argument_list|,
name|GET_DDP_PARAMS
argument_list|,
operator|&
name|ddp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|cdev
operator|->
name|ctl
argument_list|(
name|cdev
argument_list|,
name|GET_RX_PAGE_INFO
argument_list|,
operator|&
name|rx_page_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|t
operator|->
name|ddp_llimit
operator|=
name|ddp
operator|.
name|llimit
expr_stmt|;
name|t
operator|->
name|ddp_ulimit
operator|=
name|ddp
operator|.
name|ulimit
expr_stmt|;
name|t
operator|->
name|pdev
operator|=
name|ddp
operator|.
name|pdev
expr_stmt|;
name|t
operator|->
name|rx_page_size
operator|=
name|rx_page_info
operator|.
name|page_size
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* OK if this fails, we just can't do DDP */
name|t
operator|->
name|nppods
operator|=
operator|(
name|ddp
operator|.
name|ulimit
operator|+
literal|1
operator|-
name|ddp
operator|.
name|llimit
operator|)
operator|/
name|PPOD_SIZE
expr_stmt|;
name|t
operator|->
name|ppod_map
operator|=
name|t3_alloc_mem
argument_list|(
name|t
operator|->
name|nppods
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|spin_lock_init(&t->ppod_map_lock); 	tom_proc_init(dev);
ifdef|#
directive|ifdef
name|CONFIG_SYSCTL
block|t->sysctl = t3_sysctl_register(dev,&t->conf);
endif|#
directive|endif
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_toe_listen
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|,
name|int
name|event
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|tp
operator|->
name|t_inpcb
operator|->
name|inp_socket
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|OFLD_LISTEN_OPEN
case|:
case|case
name|OFLD_LISTEN_CLOSE
case|:
name|mtx_lock
argument_list|(
operator|&
name|cxgb_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&cxgb_list
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|event
operator|==
name|OFLD_LISTEN_OPEN
condition|)
name|t3_listen_start
argument_list|(
operator|&
name|p
operator|->
name|tdev
argument_list|,
name|so
argument_list|,
name|p
operator|->
name|cdev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_LISTEN
condition|)
block|{
name|printf
argument_list|(
literal|"stopping listen on port=%d\n"
argument_list|,
name|ntohs
argument_list|(
name|tp
operator|->
name|t_inpcb
operator|->
name|inp_lport
argument_list|)
argument_list|)
expr_stmt|;
name|t3_listen_stop
argument_list|(
operator|&
name|p
operator|->
name|tdev
argument_list|,
name|so
argument_list|,
name|p
operator|->
name|cdev
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_list_lock
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unrecognized listen event %d\n"
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_register_listeners
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|INP_INFO_RLOCK
argument_list|(
operator|&
name|tcbinfo
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|inp
argument_list|,
argument|tcbinfo.ipi_listhead
argument_list|,
argument|inp_list
argument_list|)
block|{
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_LISTEN
condition|)
name|cxgb_toe_listen
argument_list|(
name|NULL
argument_list|,
name|OFLD_LISTEN_OPEN
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|tcbinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_tom_init
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct socket *sock; 	err = sock_create_kern(PF_INET, SOCK_STREAM, IPPROTO_TCP,&sock); 	if (err< 0) { 		printk(KERN_ERR "Could not create TCP socket, error %d\n", err); 		return err; 	}  	t3_def_state_change = sock->sk->sk_state_change; 	t3_def_data_ready = sock->sk->sk_data_ready; 	t3_def_error_report = sock->sk->sk_error_report; 	sock_release(sock);
endif|#
directive|endif
name|init_cpl_handlers
argument_list|()
expr_stmt|;
if|if
condition|(
name|t3_init_cpl_io
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|t3_init_socket_ops
argument_list|()
expr_stmt|;
comment|/* Register with the TOE device layer. */
if|if
condition|(
name|register_tom
argument_list|(
operator|&
name|t3_tom_info
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to register Chelsio T3 TCP offload module.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|mtx_init
argument_list|(
operator|&
name|cxgb_list_lock
argument_list|,
literal|"cxgb tom list"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|listen_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ofld_listen
argument_list|,
name|cxgb_toe_listen
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cxgb_list
argument_list|)
expr_stmt|;
comment|/* Register to offloading devices */
name|t3c_tom_client
operator|.
name|add
operator|=
name|t3c_tom_add
expr_stmt|;
name|cxgb_register_client
argument_list|(
operator|&
name|t3c_tom_client
argument_list|)
expr_stmt|;
name|cxgb_register_listeners
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_tom_load
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|printf
argument_list|(
literal|"wheeeeee ...\n"
argument_list|)
expr_stmt|;
name|t3_tom_init
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_QUIESCE
case|:
break|break;
case|case
name|MOD_UNLOAD
case|:
name|printf
argument_list|(
literal|"uhm, ... unloading isn't really supported for toe\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|err
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|mod_data
init|=
block|{
literal|"t3_tom"
block|,
name|t3_tom_load
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|t3_tom
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|t3_tom
argument_list|,
name|toecore
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|t3_tom
argument_list|,
name|if_cxgb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|t3_tom
argument_list|,
name|mod_data
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

