begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007-2008, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_osdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/sys/mbufq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_offload.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_syncache.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_timer.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/t3cdev.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_firmware_exports.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_t3_cpl.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_tcb.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_ctl_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_offload.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/sys/mvec.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/toecore/cxgb_toedev.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tom.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_t3_ddp.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_toepcb.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tcp.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tcp_offload.h>
end_include

begin_comment
comment|/*  * For ULP connections HW may add headers, e.g., for digests, that aren't part  * of the messages sent by the host but that are part of the TCP payload and  * therefore consume TCP sequence space.  Tx connection parameters that  * operate in TCP sequence space are affected by the HW additions and need to  * compensate for them to accurately track TCP sequence numbers. This array  * contains the compensating extra lengths for ULP packets.  It is indexed by  * a packet's ULP submode.  */
end_comment

begin_decl_stmt
specifier|const
name|unsigned
name|int
name|t3_ulp_extra_len
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/*  * This sk_buff holds a fake header-only TCP segment that we use whenever we  * need to exploit SW TCP functionality that expects TCP headers, such as  * tcp_create_openreq_child().  It's a RO buffer that may be used by multiple  * CPUs without locking.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|tcphdr_mbuf
name|__read_mostly
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Size of WRs in bytes.  Note that we assume all devices we are handling have  * the same WR size.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|wrlen
name|__read_mostly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The number of WRs needed for an skb depends on the number of page fragments  * in the skb and whether it has any payload in its main body.  This maps the  * length of the gather list represented by an skb into the # of necessary WRs.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mbuf_wrs
index|[
name|TX_MAX_SEGS
operator|+
literal|1
index|]
name|__read_mostly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Max receive window supported by HW in bytes.  Only a small part of it can  * be set through option0, the rest needs to be set through RX_DATA_ACK.  */
end_comment

begin_define
define|#
directive|define
name|MAX_RCV_WND
value|((1U<< 27) - 1)
end_define

begin_comment
comment|/*  * Min receive window.  We want it to be large enough to accommodate receive  * coalescing, handle jumbo frames, and not trigger sender SWS avoidance.  */
end_comment

begin_define
define|#
directive|define
name|MIN_RCV_WND
value|(24 * 1024U)
end_define

begin_define
define|#
directive|define
name|INP_TOS
parameter_list|(
name|inp
parameter_list|)
value|((inp_ip_tos_get(inp)>> 2)& M_TOS)
end_define

begin_define
define|#
directive|define
name|VALIDATE_SEQ
value|0
end_define

begin_define
define|#
directive|define
name|VALIDATE_SOCK
parameter_list|(
name|so
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DEBUG_WR
value|0
end_define

begin_define
define|#
directive|define
name|TCP_TIMEWAIT
value|1
end_define

begin_define
define|#
directive|define
name|TCP_CLOSE
value|2
end_define

begin_define
define|#
directive|define
name|TCP_DROP
value|3
end_define

begin_decl_stmt
specifier|extern
name|int
name|tcp_do_autorcvbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tcp_do_autosndbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tcp_autorcvbuf_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tcp_autosndbuf_max
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|t3_send_reset
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_abort_rpl
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|int
name|rst_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|free_atid
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_syncache_event
parameter_list|(
name|int
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|void
name|SBAPPEND
parameter_list|(
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|sb
operator|->
name|sb_mb
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|==
name|EXT_EXTREF
operator|)
operator|)
operator|||
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
argument_list|,
operator|(
literal|"unexpected type M_EXT=%d ext_type=%d m_len=%d\n"
operator|,
operator|!
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|,
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_next
operator|!=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0xffffffff
argument_list|,
operator|(
literal|"bad next value m_next=%p m_nextpkt=%p m_flags=0x%x"
operator|,
name|m
operator|->
name|m_next
operator|,
name|m
operator|->
name|m_nextpkt
operator|,
name|m
operator|->
name|m_flags
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|m
operator|=
name|n
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|==
name|EXT_EXTREF
operator|)
operator|)
operator|||
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
argument_list|,
operator|(
literal|"unexpected type M_EXT=%d ext_type=%d m_len=%d\n"
operator|,
operator|!
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|,
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_next
operator|!=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0xffffffff
argument_list|,
operator|(
literal|"bad next value m_next=%p m_nextpkt=%p m_flags=0x%x"
operator|,
name|m
operator|->
name|m_next
operator|,
name|m
operator|->
name|m_nextpkt
operator|,
name|m
operator|->
name|m_flags
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_NOCOALESCE
argument_list|,
operator|(
literal|"NOCOALESCE not set"
operator|)
argument_list|)
expr_stmt|;
name|sbappendstream_locked
argument_list|(
name|sb
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|m
operator|=
name|sb
operator|->
name|sb_mb
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|KASSERT
argument_list|(
name|m
operator|->
name|m_next
operator|!=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0xffffffff
argument_list|,
operator|(
literal|"bad next value m_next=%p m_nextpkt=%p m_flags=0x%x"
operator|,
name|m
operator|->
name|m_next
operator|,
name|m
operator|->
name|m_nextpkt
operator|,
name|m
operator|->
name|m_flags
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|is_t3a
parameter_list|(
specifier|const
name|struct
name|toedev
modifier|*
name|dev
parameter_list|)
block|{
return|return
operator|(
name|dev
operator|->
name|tod_ttid
operator|==
name|TOE_ID_CHELSIO_T3
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_toepcb
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"qset_idx=%d qset=%d ulp_mode=%d mtu_idx=%d tid=%d\n"
argument_list|,
name|toep
operator|->
name|tp_qset_idx
argument_list|,
name|toep
operator|->
name|tp_qset
argument_list|,
name|toep
operator|->
name|tp_ulp_mode
argument_list|,
name|toep
operator|->
name|tp_mtu_idx
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"wr_max=%d wr_avail=%d wr_unacked=%d mss_clamp=%d flags=0x%x\n"
argument_list|,
name|toep
operator|->
name|tp_wr_max
argument_list|,
name|toep
operator|->
name|tp_wr_avail
argument_list|,
name|toep
operator|->
name|tp_wr_unacked
argument_list|,
name|toep
operator|->
name|tp_mss_clamp
argument_list|,
name|toep
operator|->
name|tp_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|RTALLOC2_DEFINED
end_ifndef

begin_function
specifier|static
name|struct
name|rtentry
modifier|*
name|rtalloc2
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|int
name|report
parameter_list|,
name|u_long
name|ignflags
parameter_list|)
block|{
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|rt
operator|=
name|rtalloc1
argument_list|(
name|dst
argument_list|,
name|report
argument_list|,
name|ignflags
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|RT_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|rt
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Determine whether to send a CPL message now or defer it.  A message is  * deferred if the connection is in SYN_SENT since we don't know the TID yet.  * For connections in other states the message is sent immediately.  * If through_l2t is set the message is subject to ARP processing, otherwise  * it is sent directly.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|send_or_defer
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|through_l2t
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_SENT
argument_list|)
condition|)
block|{
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|mbufq_tail
argument_list|(
operator|&
name|toep
operator|->
name|out_of_order_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// defer
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|through_l2t
condition|)
name|l2t_send
argument_list|(
name|TOEP_T3C_DEV
argument_list|(
name|toep
argument_list|)
argument_list|,
name|m
argument_list|,
name|toep
operator|->
name|tp_l2t
argument_list|)
expr_stmt|;
comment|// send through L2T
else|else
name|cxgb_ofld_send
argument_list|(
name|TOEP_T3C_DEV
argument_list|(
name|toep
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// send directly
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|mkprio
parameter_list|(
name|unsigned
name|int
name|cntrl
parameter_list|,
specifier|const
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
return|return
operator|(
name|cntrl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Populate a TID_RELEASE WR.  The skb must be already propely sized.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mk_tid_release
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|struct
name|cpl_tid_release
modifier|*
name|req
decl_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|mkprio
argument_list|(
name|CPL_PRIORITY_SETUP
argument_list|,
name|toep
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_tid_release
operator|*
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_lo
operator|=
literal|0
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_TID_RELEASE
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|make_tx_data_wr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|mbuf
modifier|*
name|tail
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|tx_data_wr
modifier|*
name|req
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|snd
decl_stmt|;
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|snd
operator|=
name|so_sockbuf_snd
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tx_data_wr
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_OFLD_TX_DATA
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|toep
operator|->
name|tp_tid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* len includes the length of any HW ULP additions */
name|req
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|req
operator|->
name|param
operator|=
name|htonl
argument_list|(
name|V_TX_PORT
argument_list|(
name|toep
operator|->
name|tp_l2t
operator|->
name|smt_idx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* V_TX_ULP_SUBMODE sets both the mode and submode */
name|req
operator|->
name|flags
operator|=
name|htonl
argument_list|(
name|V_TX_ULP_SUBMODE
argument_list|(
comment|/*skb_ulp_mode(skb)*/
literal|0
argument_list|)
operator||
name|V_TX_URG
argument_list|(
comment|/* skb_urgent(skb) */
literal|0
argument_list|)
operator||
name|V_TX_SHOVE
argument_list|(
operator|(
operator|!
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_MORETOCOME
operator|)
operator|&&
operator|(
name|tail
condition|?
literal|0
else|:
literal|1
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|sndseq
operator|=
name|htonl
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_DATASENT
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
name|req
operator|->
name|flags
operator||=
name|htonl
argument_list|(
name|V_TX_ACK_PAGES
argument_list|(
literal|2
argument_list|)
operator||
name|F_TX_INIT
operator||
name|V_TX_CPU_IDX
argument_list|(
name|toep
operator|->
name|tp_qset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sendbuffer is in units of 32KB. 		 */
if|if
condition|(
name|tcp_do_autosndbuf
operator|&&
name|snd
operator|->
name|sb_flags
operator|&
name|SB_AUTOSIZE
condition|)
name|req
operator|->
name|param
operator||=
name|htonl
argument_list|(
name|V_TX_SNDBUF
argument_list|(
name|tcp_autosndbuf_max
operator|>>
literal|15
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|req
operator|->
name|param
operator||=
name|htonl
argument_list|(
name|V_TX_SNDBUF
argument_list|(
name|snd
operator|->
name|sb_hiwat
operator|>>
literal|15
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|toep
operator|->
name|tp_flags
operator||=
name|TP_DATASENT
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|IMM_LEN
value|64
end_define

begin_comment
comment|/* XXX - see WR_LEN in the cxgb driver */
end_comment

begin_function
name|int
name|t3_push_frames
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|req_completion
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|tail
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|struct
name|t3cdev
modifier|*
name|cdev
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|d
decl_stmt|;
name|int
name|state
decl_stmt|,
name|bytes
decl_stmt|,
name|count
decl_stmt|,
name|total_bytes
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|TX_MAX_SEGS
index|]
decl_stmt|,
modifier|*
name|segp
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|snd
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_SENT
operator|||
name|tp
operator|->
name|t_state
operator|==
name|TCPS_CLOSED
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"tcp state=%d\n"
argument_list|,
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|state
operator|=
name|so_state_get
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|&
operator|(
name|SS_ISDISCONNECTING
operator||
name|SS_ISDISCONNECTED
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"disconnecting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|snd
operator|=
name|so_sockbuf_snd
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sockbuf_lock
argument_list|(
name|snd
argument_list|)
expr_stmt|;
name|d
operator|=
name|TOM_DATA
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|)
expr_stmt|;
name|cdev
operator|=
name|d
operator|->
name|cdev
expr_stmt|;
name|last
operator|=
name|tail
operator|=
name|snd
operator|->
name|sb_sndptr
condition|?
name|snd
operator|->
name|sb_sndptr
else|:
name|snd
operator|->
name|sb_mb
expr_stmt|;
name|total_bytes
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"wr_avail=%d tail=%p snd.cc=%d tp_last=%p\n"
argument_list|,
name|toep
operator|->
name|tp_wr_avail
argument_list|,
name|tail
argument_list|,
name|snd
operator|->
name|sb_cc
argument_list|,
name|toep
operator|->
name|tp_m_last
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|&&
name|toep
operator|->
name|tp_m_last
operator|==
name|last
operator|&&
name|snd
operator|->
name|sb_sndptroff
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|tail
argument_list|,
operator|(
literal|"sbdrop error"
operator|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|tail
operator|=
name|tail
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|toep
operator|->
name|tp_wr_avail
operator|==
literal|0
operator|)
operator|||
operator|(
name|tail
operator|==
name|NULL
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"wr_avail=%d tail=%p\n"
argument_list|,
name|toep
operator|->
name|tp_wr_avail
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|sockbuf_unlock
argument_list|(
name|snd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|toep
operator|->
name|tp_m_last
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|toep
operator|->
name|tp_wr_avail
operator|&&
operator|(
name|tail
operator|!=
name|NULL
operator|)
condition|)
block|{
name|count
operator|=
name|bytes
operator|=
literal|0
expr_stmt|;
name|segp
operator|=
name|segs
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sockbuf_unlock
argument_list|(
name|snd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * If the data in tail fits as in-line, then 		 * make an immediate data wr. 		 */
if|if
condition|(
name|tail
operator|->
name|m_len
operator|<=
name|IMM_LEN
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|bytes
operator|=
name|tail
operator|->
name|m_len
expr_stmt|;
name|last
operator|=
name|tail
expr_stmt|;
name|tail
operator|=
name|tail
operator|->
name|m_next
expr_stmt|;
name|m_set_sgl
argument_list|(
name|m0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|m_set_sgllen
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|make_tx_data_wr
argument_list|(
name|so
argument_list|,
name|m0
argument_list|,
name|bytes
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|m_append
argument_list|(
name|m0
argument_list|,
name|bytes
argument_list|,
name|mtod
argument_list|(
name|last
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|m0
operator|->
name|m_next
argument_list|,
operator|(
literal|"bad append"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|mbuf_wrs
index|[
name|count
operator|+
literal|1
index|]
operator|<=
name|toep
operator|->
name|tp_wr_avail
operator|)
operator|&&
operator|(
name|tail
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|count
operator|<
name|TX_MAX_SEGS
operator|-
literal|1
operator|)
condition|)
block|{
name|bytes
operator|+=
name|tail
operator|->
name|m_len
expr_stmt|;
name|last
operator|=
name|tail
expr_stmt|;
name|count
operator|++
expr_stmt|;
comment|/* 				 * technically an abuse to be using this for a VA 				 * but less gross than defining my own structure 				 * or calling pmap_kextract from here :-| 				 */
name|segp
operator|->
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|tail
operator|->
name|m_data
expr_stmt|;
name|segp
operator|->
name|ds_len
operator|=
name|tail
operator|->
name|m_len
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"count=%d wr_needed=%d ds_addr=%p ds_len=%d\n"
argument_list|,
name|count
argument_list|,
name|mbuf_wrs
index|[
name|count
index|]
argument_list|,
name|tail
operator|->
name|m_data
argument_list|,
name|tail
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|segp
operator|++
expr_stmt|;
name|tail
operator|=
name|tail
operator|->
name|m_next
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"wr_avail=%d mbuf_wrs[%d]=%d tail=%p\n"
argument_list|,
name|toep
operator|->
name|tp_wr_avail
argument_list|,
name|count
argument_list|,
name|mbuf_wrs
index|[
name|count
index|]
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|m_set_sgl
argument_list|(
name|m0
argument_list|,
name|segs
argument_list|)
expr_stmt|;
name|m_set_sgllen
argument_list|(
name|m0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|make_tx_data_wr
argument_list|(
name|so
argument_list|,
name|m0
argument_list|,
name|bytes
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
name|m_set_priority
argument_list|(
name|m0
argument_list|,
name|mkprio
argument_list|(
name|CPL_PRIORITY_DATA
argument_list|,
name|toep
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
condition|)
block|{
name|snd
operator|->
name|sb_sndptr
operator|=
name|tail
expr_stmt|;
name|toep
operator|->
name|tp_m_last
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|toep
operator|->
name|tp_m_last
operator|=
name|snd
operator|->
name|sb_sndptr
operator|=
name|last
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"toep->tp_m_last=%p\n"
argument_list|,
name|toep
operator|->
name|tp_m_last
argument_list|)
expr_stmt|;
name|snd
operator|->
name|sb_sndptroff
operator|+=
name|bytes
expr_stmt|;
name|total_bytes
operator|+=
name|bytes
expr_stmt|;
name|toep
operator|->
name|tp_write_seq
operator|+=
name|bytes
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_push_frames: wr_avail=%d mbuf_wrs[%d]=%d tail=%p sndptr=%p sndptroff=%d"
argument_list|,
name|toep
operator|->
name|tp_wr_avail
argument_list|,
name|count
argument_list|,
name|mbuf_wrs
index|[
name|count
index|]
argument_list|,
name|tail
argument_list|,
name|snd
operator|->
name|sb_sndptr
argument_list|,
name|snd
operator|->
name|sb_sndptroff
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
condition|)
name|CTR4
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_push_frames: total_bytes=%d tp_m_last=%p tailbuf=%p snd_una=0x%08x"
argument_list|,
name|total_bytes
argument_list|,
name|toep
operator|->
name|tp_m_last
argument_list|,
name|tail
operator|->
name|m_data
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
expr_stmt|;
else|else
name|CTR3
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_push_frames: total_bytes=%d tp_m_last=%p snd_una=0x%08x"
argument_list|,
name|total_bytes
argument_list|,
name|toep
operator|->
name|tp_m_last
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTR
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|count
operator|&&
name|m_get_sgllen
argument_list|(
name|m0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|count
operator|-
name|i
operator|)
operator|>=
literal|3
condition|)
block|{
name|CTR6
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_push_frames: pa=0x%zx len=%d pa=0x%zx len=%d pa=0x%zx len=%d"
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|,
name|segs
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|ds_len
argument_list|,
name|segs
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|count
operator|-
name|i
operator|)
operator|==
literal|2
condition|)
block|{
name|CTR4
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_push_frames: pa=0x%zx len=%d pa=0x%zx len=%d"
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|,
name|segs
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|CTR2
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_push_frames: pa=0x%zx len=%d"
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* 		 * remember credits used 		 */
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|mbuf_wrs
index|[
name|count
index|]
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|bytes
expr_stmt|;
name|toep
operator|->
name|tp_wr_avail
operator|-=
name|mbuf_wrs
index|[
name|count
index|]
expr_stmt|;
name|toep
operator|->
name|tp_wr_unacked
operator|+=
name|mbuf_wrs
index|[
name|count
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|req_completion
operator|&&
name|toep
operator|->
name|tp_wr_unacked
operator|==
name|mbuf_wrs
index|[
name|count
index|]
operator|)
operator|||
name|toep
operator|->
name|tp_wr_unacked
operator|>=
name|toep
operator|->
name|tp_wr_max
operator|/
literal|2
condition|)
block|{
name|struct
name|work_request_hdr
modifier|*
name|wr
init|=
name|cplhdr
argument_list|(
name|m0
argument_list|)
decl_stmt|;
name|wr
operator|->
name|wr_hi
operator||=
name|htonl
argument_list|(
name|F_WR_COMPL
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_wr_unacked
operator|=
literal|0
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|>
literal|0
operator|)
operator|&&
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|<=
literal|4
operator|)
argument_list|,
operator|(
literal|"bad credit count %d"
operator|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|)
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_type
operator|=
name|MT_DONTFREE
expr_stmt|;
name|enqueue_wr
argument_list|(
name|toep
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"sending offload tx with %d bytes in %d segments\n"
argument_list|,
name|bytes
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|l2t_send
argument_list|(
name|cdev
argument_list|,
name|m0
argument_list|,
name|toep
operator|->
name|tp_l2t
argument_list|)
expr_stmt|;
block|}
name|sockbuf_unlock
argument_list|(
name|snd
argument_list|)
expr_stmt|;
return|return
operator|(
name|total_bytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close a connection by sending a CPL_CLOSE_CON_REQ message.  Cannot fail  * under any circumstances.  We take the easy way out and always queue the  * message to the write_queue.  We can optimize the case where the queue is  * already empty though the optimization is probably not worth it.  */
end_comment

begin_function
specifier|static
name|void
name|close_conn
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cpl_close_con_req
modifier|*
name|req
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|d
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|so_sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
name|unsigned
name|int
name|tid
decl_stmt|;
name|inp_wlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|toep
operator|=
name|tp
operator|->
name|t_toe
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|!=
name|TCPS_SYN_SENT
condition|)
name|t3_push_frames
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_FIN_SENT
condition|)
block|{
name|inp_wunlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return;
block|}
name|tid
operator|=
name|toep
operator|->
name|tp_tid
expr_stmt|;
name|d
operator|=
name|TOM_DATA
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_gethdr_nofail
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|CPL_PRIORITY_DATA
argument_list|)
expr_stmt|;
name|m_set_sgl
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|m_set_sgllen
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_flags
operator||=
name|TP_FIN_SENT
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_close_con_req
operator|*
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_OFLD_CLOSE_CON
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_CLOSE_CON_REQ
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|rsvd
operator|=
literal|0
expr_stmt|;
name|inp_wunlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 	 * XXX - need to defer shutdown while there is still data in the queue 	 * 	 */
name|CTR4
argument_list|(
name|KTR_TOM
argument_list|,
literal|"%s CLOSE_CON_REQ so %p tp %p tid=%u"
argument_list|,
name|__FUNCTION__
argument_list|,
name|so
argument_list|,
name|tp
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|d
operator|->
name|cdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle an ARP failure for a CPL_ABORT_REQ.  Change it into a no RST variant  * and send it along.  */
end_comment

begin_function
specifier|static
name|void
name|abort_arp_failure
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_abort_req
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|req
operator|->
name|cmd
operator|=
name|CPL_ABORT_NO_RST
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|cdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send RX credits through an RX_DATA_ACK CPL message.  If nofail is 0 we are  * permitted to return without sending the message in case we cannot allocate  * an sk_buff.  Returns the number of credits sent.  */
end_comment

begin_function
name|uint32_t
name|t3_send_rx_credits
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|uint32_t
name|credits
parameter_list|,
name|uint32_t
name|dack
parameter_list|,
name|int
name|nofail
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cpl_rx_data_ack
modifier|*
name|req
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tdev
init|=
name|toep
operator|->
name|tp_toedev
decl_stmt|;
name|m
operator|=
name|m_gethdr_nofail
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"returning %u credits to HW\n"
argument_list|,
name|credits
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_rx_data_ack
operator|*
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_lo
operator|=
literal|0
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_RX_DATA_ACK
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|credit_dack
operator|=
name|htonl
argument_list|(
name|dack
operator||
name|V_RX_CREDITS
argument_list|(
name|credits
argument_list|)
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|mkprio
argument_list|(
name|CPL_PRIORITY_ACK
argument_list|,
name|toep
argument_list|)
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|TOM_DATA
argument_list|(
name|tdev
argument_list|)
operator|->
name|cdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|credits
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send RX_DATA_ACK CPL message to request a modulation timer to be scheduled.  * This is only used in DDP mode, so we take the opportunity to also set the  * DACK mode and flush any Rx credits.  */
end_comment

begin_function
name|void
name|t3_send_rx_modulate
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cpl_rx_data_ack
modifier|*
name|req
decl_stmt|;
name|m
operator|=
name|m_gethdr_nofail
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_rx_data_ack
operator|*
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_lo
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_RX_DATA_ACK
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|credit_dack
operator|=
name|htonl
argument_list|(
name|F_RX_MODULATE
operator||
name|F_RX_DACK_CHANGE
operator||
name|V_RX_DACK_MODE
argument_list|(
literal|1
argument_list|)
operator||
name|V_RX_CREDITS
argument_list|(
name|toep
operator|->
name|tp_copied_seq
operator|-
name|toep
operator|->
name|tp_rcv_wup
argument_list|)
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|mkprio
argument_list|(
name|CPL_PRIORITY_CONTROL
argument_list|,
name|toep
argument_list|)
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|TOEP_T3C_DEV
argument_list|(
name|toep
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_rcv_wup
operator|=
name|toep
operator|->
name|tp_copied_seq
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle receipt of an urgent pointer.  */
end_comment

begin_function
specifier|static
name|void
name|handle_urg_ptr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|uint32_t
name|urg_seq
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|URGENT_DATA_SUPPORTED
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|urg_seq
operator|--
expr_stmt|;
comment|/* initially points past the urgent data, per BSD */
if|if
condition|(
name|tp
operator|->
name|urg_data
operator|&&
operator|!
name|after
argument_list|(
name|urg_seq
argument_list|,
name|tp
operator|->
name|urg_seq
argument_list|)
condition|)
return|return;
comment|/* duplicate pointer */
name|sk_send_sigurg
argument_list|(
name|sk
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|urg_seq
operator|==
name|tp
operator|->
name|copied_seq
operator|&&
name|tp
operator|->
name|urg_data
operator|&&
operator|!
name|sock_flag
argument_list|(
name|sk
argument_list|,
name|SOCK_URGINLINE
argument_list|)
operator|&&
name|tp
operator|->
name|copied_seq
operator|!=
name|tp
operator|->
name|rcv_nxt
condition|)
block|{
name|struct
name|sk_buff
modifier|*
name|skb
init|=
name|skb_peek
argument_list|(
operator|&
name|sk
operator|->
name|sk_receive_queue
argument_list|)
decl_stmt|;
name|tp
operator|->
name|copied_seq
operator|++
expr_stmt|;
if|if
condition|(
name|skb
operator|&&
name|tp
operator|->
name|copied_seq
operator|-
name|TCP_SKB_CB
argument_list|(
name|skb
argument_list|)
operator|->
name|seq
operator|>=
name|skb
operator|->
name|len
condition|)
name|tom_eat_skb
argument_list|(
name|sk
argument_list|,
name|skb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|urg_data
operator|=
name|TCP_URG_NOTYET
expr_stmt|;
name|tp
operator|->
name|urg_seq
operator|=
name|urg_seq
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Returns true if a socket cannot accept new Rx data.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|so_no_receive
parameter_list|(
specifier|const
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
name|so_state_get
argument_list|(
name|so
argument_list|)
operator|&
operator|(
name|SS_ISDISCONNECTED
operator||
name|SS_ISDISCONNECTING
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an urgent data notification.  */
end_comment

begin_function
specifier|static
name|void
name|rx_urg_notify
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_rx_urg_notify
modifier|*
name|hdr
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|inp_inpcbtosocket
argument_list|(
name|toep
operator|->
name|tp_tp
operator|->
name|t_inpcb
argument_list|)
decl_stmt|;
name|VALIDATE_SOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|so_no_receive
argument_list|(
name|so
argument_list|)
condition|)
name|handle_urg_ptr
argument_list|(
name|so
argument_list|,
name|ntohl
argument_list|(
name|hdr
operator|->
name|seq
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handler for RX_URG_NOTIFY CPL messages.  */
end_comment

begin_function
specifier|static
name|int
name|do_rx_urg_notify
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
operator|(
expr|struct
name|toepcb
operator|*
operator|)
name|ctx
decl_stmt|;
name|rx_urg_notify
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|is_delack_mode_valid
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
return|return
operator|(
name|toep
operator|->
name|tp_ulp_mode
operator|||
operator|(
name|toep
operator|->
name|tp_ulp_mode
operator|==
name|ULP_MODE_TCPDDP
operator|&&
name|dev
operator|->
name|tod_ttid
operator|>=
name|TOE_ID_CHELSIO_T3
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set of states for which we should return RX credits.  */
end_comment

begin_define
define|#
directive|define
name|CREDIT_RETURN_STATE
value|(TCPF_ESTABLISHED | TCPF_FIN_WAIT1 | TCPF_FIN_WAIT2)
end_define

begin_comment
comment|/*  * Called after some received data has been read.  It returns RX credits  * to the HW for the amount of data processed.  */
end_comment

begin_function
name|void
name|t3_cleanup_rbuf
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|int
name|copied
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|toedev
modifier|*
name|dev
decl_stmt|;
name|int
name|dack_mode
decl_stmt|,
name|must_send
decl_stmt|,
name|read
decl_stmt|;
name|u32
name|thres
decl_stmt|,
name|credits
decl_stmt|,
name|dack
init|=
literal|0
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|rcv
decl_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_ESTABLISHED
operator|)
operator|||
operator|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_FIN_WAIT_1
operator|)
operator|||
operator|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_FIN_WAIT_2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|copied
condition|)
block|{
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_copied_seq
operator|+=
name|copied
expr_stmt|;
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|copied
condition|)
name|toep
operator|->
name|tp_copied_seq
operator|+=
name|copied
expr_stmt|;
else|else
block|{
name|read
operator|=
name|toep
operator|->
name|tp_enqueued_bytes
operator|-
name|rcv
operator|->
name|sb_cc
expr_stmt|;
name|toep
operator|->
name|tp_copied_seq
operator|+=
name|read
expr_stmt|;
block|}
name|credits
operator|=
name|toep
operator|->
name|tp_copied_seq
operator|-
name|toep
operator|->
name|tp_rcv_wup
expr_stmt|;
name|toep
operator|->
name|tp_enqueued_bytes
operator|=
name|rcv
operator|->
name|sb_cc
expr_stmt|;
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|credits
operator|>
name|rcv
operator|->
name|sb_mbmax
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"copied_seq=%u rcv_wup=%u credits=%u\n"
argument_list|,
name|toep
operator|->
name|tp_copied_seq
argument_list|,
name|toep
operator|->
name|tp_rcv_wup
argument_list|,
name|credits
argument_list|)
expr_stmt|;
name|credits
operator|=
name|rcv
operator|->
name|sb_mbmax
expr_stmt|;
block|}
comment|/* 	 * XXX this won't accurately reflect credit return - we need 	 * to look at the difference between the amount that has been  	 * put in the recv sockbuf and what is there now 	 */
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|credits
argument_list|)
condition|)
return|return;
name|dev
operator|=
name|toep
operator|->
name|tp_toedev
expr_stmt|;
name|thres
operator|=
name|TOM_TUNABLE
argument_list|(
name|dev
argument_list|,
name|rx_credit_thres
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|thres
operator|==
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|is_delack_mode_valid
argument_list|(
name|dev
argument_list|,
name|toep
argument_list|)
condition|)
block|{
name|dack_mode
operator|=
name|TOM_TUNABLE
argument_list|(
name|dev
argument_list|,
name|delack
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|dack_mode
operator|!=
name|toep
operator|->
name|tp_delack_mode
argument_list|)
condition|)
block|{
name|u32
name|r
init|=
name|tp
operator|->
name|rcv_nxt
operator|-
name|toep
operator|->
name|tp_delack_seq
decl_stmt|;
if|if
condition|(
name|r
operator|>=
name|tp
operator|->
name|rcv_wnd
operator|||
name|r
operator|>=
literal|16
operator|*
name|toep
operator|->
name|tp_mss_clamp
condition|)
name|dack
operator|=
name|F_RX_DACK_CHANGE
operator||
name|V_RX_DACK_MODE
argument_list|(
name|dack_mode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|dack
operator|=
name|F_RX_DACK_CHANGE
operator||
name|V_RX_DACK_MODE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * For coalescing to work effectively ensure the receive window has 	 * at least 16KB left. 	 */
name|must_send
operator|=
name|credits
operator|+
literal|16384
operator|>=
name|tp
operator|->
name|rcv_wnd
expr_stmt|;
if|if
condition|(
name|must_send
operator|||
name|credits
operator|>=
name|thres
condition|)
name|toep
operator|->
name|tp_rcv_wup
operator|+=
name|t3_send_rx_credits
argument_list|(
name|tp
argument_list|,
name|credits
argument_list|,
name|dack
argument_list|,
name|must_send
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_toe_disconnect
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"cxgb_toe_disconnect\n"
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|close_conn
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_toe_reset
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|t3_send_reset
argument_list|(
name|toep
argument_list|)
expr_stmt|;
comment|/* 	 * unhook from socket 	 */
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_TOE
expr_stmt|;
name|toep
operator|->
name|tp_tp
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_toe
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_toe_send
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"cxgb_toe_send\n"
argument_list|)
expr_stmt|;
name|dump_toepcb
argument_list|(
name|tp
operator|->
name|t_toe
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|t3_push_frames
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_toe_rcvd
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|t3_cleanup_rbuf
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_toe_detach
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
comment|/* 	 * XXX how do we handle teardown in the SYN_SENT state? 	 * 	 */
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|toep
operator|=
name|tp
operator|->
name|t_toe
expr_stmt|;
name|toep
operator|->
name|tp_tp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * unhook from socket 	 */
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_TOE
expr_stmt|;
name|tp
operator|->
name|t_toe
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|toe_usrreqs
name|cxgb_toe_usrreqs
init|=
block|{
operator|.
name|tu_disconnect
operator|=
name|cxgb_toe_disconnect
block|,
operator|.
name|tu_reset
operator|=
name|cxgb_toe_reset
block|,
operator|.
name|tu_send
operator|=
name|cxgb_toe_send
block|,
operator|.
name|tu_rcvd
operator|=
name|cxgb_toe_rcvd
block|,
operator|.
name|tu_detach
operator|=
name|cxgb_toe_detach
block|,
operator|.
name|tu_detach
operator|=
name|cxgb_toe_detach
block|,
operator|.
name|tu_syncache_event
operator|=
name|handle_syncache_event
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|__set_tcb_field
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint16_t
name|word
parameter_list|,
name|uint64_t
name|mask
parameter_list|,
name|uint64_t
name|val
parameter_list|,
name|int
name|no_reply
parameter_list|)
block|{
name|struct
name|cpl_set_tcb_field
modifier|*
name|req
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_TCB
argument_list|,
literal|"__set_tcb_field_ulp(tid=%u word=0x%x mask=%jx val=%jx"
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|word
argument_list|,
name|mask
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_set_tcb_field
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_lo
operator|=
literal|0
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_SET_TCB_FIELD
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|reply
operator|=
name|V_NO_REPLY
argument_list|(
name|no_reply
argument_list|)
expr_stmt|;
name|req
operator|->
name|cpu_idx
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|word
operator|=
name|htons
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|req
operator|->
name|mask
operator|=
name|htobe64
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|req
operator|->
name|val
operator|=
name|htobe64
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|mkprio
argument_list|(
name|CPL_PRIORITY_CONTROL
argument_list|,
name|toep
argument_list|)
argument_list|)
expr_stmt|;
name|send_or_defer
argument_list|(
name|toep
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|t3_set_tcb_field
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|uint16_t
name|word
parameter_list|,
name|uint64_t
name|mask
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
if|if
condition|(
name|toep
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_CLOSED
operator|||
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_SHUTDOWN
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"not seting field\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|=
name|m_gethdr_nofail
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_set_tcb_field
argument_list|)
argument_list|)
expr_stmt|;
name|__set_tcb_field
argument_list|(
name|toep
argument_list|,
name|m
argument_list|,
name|word
argument_list|,
name|mask
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set one of the t_flags bits in the TCB.  */
end_comment

begin_function
specifier|static
name|void
name|set_tcb_tflag
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|unsigned
name|int
name|bit_pos
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|t3_set_tcb_field
argument_list|(
name|toep
argument_list|,
name|W_TCB_T_FLAGS1
argument_list|,
literal|1ULL
operator|<<
name|bit_pos
argument_list|,
name|val
operator|<<
name|bit_pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a SET_TCB_FIELD CPL message to change a connection's Nagle setting.  */
end_comment

begin_function
specifier|static
name|void
name|t3_set_nagle
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|set_tcb_tflag
argument_list|(
name|toep
argument_list|,
name|S_TF_NAGLE
argument_list|,
operator|!
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NODELAY
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a SET_TCB_FIELD CPL message to change a connection's keepalive setting.  */
end_comment

begin_function
name|void
name|t3_set_keepalive
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|on_off
parameter_list|)
block|{
name|set_tcb_tflag
argument_list|(
name|toep
argument_list|,
name|S_TF_KEEPALIVE
argument_list|,
name|on_off
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_set_rcv_coalesce_enable
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|on_off
parameter_list|)
block|{
name|set_tcb_tflag
argument_list|(
name|toep
argument_list|,
name|S_TF_RCV_COALESCE_ENABLE
argument_list|,
name|on_off
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_set_dack_mss
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|on_off
parameter_list|)
block|{
name|set_tcb_tflag
argument_list|(
name|toep
argument_list|,
name|S_TF_DACK_MSS
argument_list|,
name|on_off
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a SET_TCB_FIELD CPL message to change a connection's TOS setting.  */
end_comment

begin_function
specifier|static
name|void
name|t3_set_tos
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|int
name|tos
init|=
name|inp_ip_tos_get
argument_list|(
name|toep
operator|->
name|tp_tp
operator|->
name|t_inpcb
argument_list|)
decl_stmt|;
name|t3_set_tcb_field
argument_list|(
name|toep
argument_list|,
name|W_TCB_TOS
argument_list|,
name|V_TCB_TOS
argument_list|(
name|M_TCB_TOS
argument_list|)
argument_list|,
name|V_TCB_TOS
argument_list|(
name|tos
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * In DDP mode, TP fails to schedule a timer to push RX data to the host when  * DDP is disabled (data is delivered to freelist). [Note that, the peer should  * set the PSH bit in the last segment, which would trigger delivery.]  * We work around the issue by setting a DDP buffer in a partial placed state,  * which guarantees that TP will schedule a timer.  */
end_comment

begin_define
define|#
directive|define
name|TP_DDP_TIMER_WORKAROUND_MASK
define|\
value|(V_TF_DDP_BUF0_VALID(1) | V_TF_DDP_ACTIVE_BUF(1) |\      ((V_TCB_RX_DDP_BUF0_OFFSET(M_TCB_RX_DDP_BUF0_OFFSET) |\        V_TCB_RX_DDP_BUF0_LEN(3))<< 32))
end_define

begin_define
define|#
directive|define
name|TP_DDP_TIMER_WORKAROUND_VAL
define|\
value|(V_TF_DDP_BUF0_VALID(1) | V_TF_DDP_ACTIVE_BUF(0) |\      ((V_TCB_RX_DDP_BUF0_OFFSET((uint64_t)1) | V_TCB_RX_DDP_BUF0_LEN((uint64_t)2))<<\       32))
end_define

begin_function
specifier|static
name|void
name|t3_enable_ddp
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|on
parameter_list|)
block|{
if|if
condition|(
name|on
condition|)
block|{
name|t3_set_tcb_field
argument_list|(
name|toep
argument_list|,
name|W_TCB_RX_DDP_FLAGS
argument_list|,
name|V_TF_DDP_OFF
argument_list|(
literal|1
argument_list|)
argument_list|,
name|V_TF_DDP_OFF
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|t3_set_tcb_field
argument_list|(
name|toep
argument_list|,
name|W_TCB_RX_DDP_FLAGS
argument_list|,
name|V_TF_DDP_OFF
argument_list|(
literal|1
argument_list|)
operator||
name|TP_DDP_TIMER_WORKAROUND_MASK
argument_list|,
name|V_TF_DDP_OFF
argument_list|(
literal|1
argument_list|)
operator||
name|TP_DDP_TIMER_WORKAROUND_VAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_set_ddp_tag
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|buf_idx
parameter_list|,
name|unsigned
name|int
name|tag_color
parameter_list|)
block|{
name|t3_set_tcb_field
argument_list|(
name|toep
argument_list|,
name|W_TCB_RX_DDP_BUF0_TAG
operator|+
name|buf_idx
argument_list|,
name|V_TCB_RX_DDP_BUF0_TAG
argument_list|(
name|M_TCB_RX_DDP_BUF0_TAG
argument_list|)
argument_list|,
name|tag_color
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_set_ddp_buf
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|buf_idx
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|buf_idx
operator|==
literal|0
condition|)
name|t3_set_tcb_field
argument_list|(
name|toep
argument_list|,
name|W_TCB_RX_DDP_BUF0_OFFSET
argument_list|,
name|V_TCB_RX_DDP_BUF0_OFFSET
argument_list|(
name|M_TCB_RX_DDP_BUF0_OFFSET
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF0_LEN
argument_list|(
name|M_TCB_RX_DDP_BUF0_LEN
argument_list|)
argument_list|,
name|V_TCB_RX_DDP_BUF0_OFFSET
argument_list|(
operator|(
name|uint64_t
operator|)
name|offset
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF0_LEN
argument_list|(
operator|(
name|uint64_t
operator|)
name|len
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t3_set_tcb_field
argument_list|(
name|toep
argument_list|,
name|W_TCB_RX_DDP_BUF1_OFFSET
argument_list|,
name|V_TCB_RX_DDP_BUF1_OFFSET
argument_list|(
name|M_TCB_RX_DDP_BUF1_OFFSET
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF1_LEN
argument_list|(
name|M_TCB_RX_DDP_BUF1_LEN
operator|<<
literal|32
argument_list|)
argument_list|,
name|V_TCB_RX_DDP_BUF1_OFFSET
argument_list|(
operator|(
name|uint64_t
operator|)
name|offset
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF1_LEN
argument_list|(
operator|(
operator|(
name|uint64_t
operator|)
name|len
operator|)
operator|<<
literal|32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_set_cong_control
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CONGESTION_CONTROL_SUPPORTED
name|int
name|cong_algo
decl_stmt|;
for|for
control|(
name|cong_algo
operator|=
literal|0
init|;
name|cong_algo
operator|<
name|ARRAY_SIZE
argument_list|(
name|t3_cong_ops
argument_list|)
condition|;
name|cong_algo
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|t3_cong_ops
index|[
name|cong_algo
index|]
operator|.
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cong_algo
operator|>=
name|ARRAY_SIZE
argument_list|(
name|t3_cong_ops
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|t3_get_tcb
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|cpl_get_tcb
modifier|*
name|req
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|mkprio
argument_list|(
name|CPL_PRIORITY_CONTROL
argument_list|,
name|toep
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_get_tcb
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_lo
operator|=
literal|0
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_GET_TCB
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|cpuno
operator|=
name|htons
argument_list|(
name|toep
operator|->
name|tp_qset
argument_list|)
expr_stmt|;
name|req
operator|->
name|rsvd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_SENT
condition|)
name|mbufq_tail
argument_list|(
operator|&
name|toep
operator|->
name|out_of_order_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// defer
else|else
name|cxgb_ofld_send
argument_list|(
name|TOEP_T3C_DEV
argument_list|(
name|toep
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|so_insert_tid
parameter_list|(
name|struct
name|tom_data
modifier|*
name|d
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|toepcb_hold
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|cxgb_insert_tid
argument_list|(
name|d
operator|->
name|cdev
argument_list|,
name|d
operator|->
name|client
argument_list|,
name|toep
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	find_best_mtu - find the entry in the MTU table closest to an MTU  *	@d: TOM state  *	@mtu: the target MTU  *  *	Returns the index of the value in the MTU table that is closest to but  *	does not exceed the target MTU.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|find_best_mtu
parameter_list|(
specifier|const
name|struct
name|t3c_data
modifier|*
name|d
parameter_list|,
name|unsigned
name|short
name|mtu
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|d
operator|->
name|nmtus
operator|-
literal|1
operator|&&
name|d
operator|->
name|mtus
index|[
name|i
operator|+
literal|1
index|]
operator|<=
name|mtu
condition|)
operator|++
name|i
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|select_mss
parameter_list|(
name|struct
name|t3c_data
modifier|*
name|td
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|unsigned
name|int
name|pmtu
parameter_list|)
block|{
name|unsigned
name|int
name|idx
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|struct
name|rtentry
modifier|*
name|dst
init|=
name|so_sotoinpcb
argument_list|(
name|so
argument_list|)
operator|->
name|inp_route
operator|.
name|ro_rt
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tp
condition|)
block|{
name|tp
operator|->
name|t_maxseg
operator|=
name|pmtu
operator|-
literal|40
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_maxseg
operator|<
name|td
operator|->
name|mtus
index|[
literal|0
index|]
operator|-
literal|40
condition|)
name|tp
operator|->
name|t_maxseg
operator|=
name|td
operator|->
name|mtus
index|[
literal|0
index|]
operator|-
literal|40
expr_stmt|;
name|idx
operator|=
name|find_best_mtu
argument_list|(
name|td
argument_list|,
name|tp
operator|->
name|t_maxseg
operator|+
literal|40
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_maxseg
operator|=
name|td
operator|->
name|mtus
index|[
name|idx
index|]
operator|-
literal|40
expr_stmt|;
block|}
else|else
name|idx
operator|=
name|find_best_mtu
argument_list|(
name|td
argument_list|,
name|pmtu
argument_list|)
expr_stmt|;
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|free_atid
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|cxgb_free_atid
argument_list|(
name|cdev
argument_list|,
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|toep
condition|)
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release resources held by an offload connection (TID, L2T entry, etc.)  */
end_comment

begin_function
specifier|static
name|void
name|t3_release_offload_resources
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tdev
init|=
name|toep
operator|->
name|tp_toedev
decl_stmt|;
name|struct
name|t3cdev
modifier|*
name|cdev
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|toep
operator|->
name|tp_tid
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|rcv
decl_stmt|;
name|CTR0
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_release_offload_resources"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tdev
condition|)
return|return;
name|cdev
operator|=
name|TOEP_T3C_DEV
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cdev
condition|)
return|return;
name|toep
operator|->
name|tp_qset
operator|=
literal|0
expr_stmt|;
name|t3_release_ddp_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTRL_SKB_CACHE
name|kfree_skb
argument_list|(
name|CTRL_SKB_CACHE
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|CTRL_SKB_CACHE
argument_list|(
name|tp
argument_list|)
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|toep
operator|->
name|tp_wr_avail
operator|!=
name|toep
operator|->
name|tp_wr_max
condition|)
block|{
name|purge_wr_queue
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|reset_wr_list
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|toep
operator|->
name|tp_l2t
condition|)
block|{
name|l2t_release
argument_list|(
name|L2DATA
argument_list|(
name|cdev
argument_list|)
argument_list|,
name|toep
operator|->
name|tp_l2t
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_l2t
operator|=
name|NULL
expr_stmt|;
block|}
name|toep
operator|->
name|tp_tp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tp
condition|)
block|{
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* 		 * cancel any offloaded reads 		 * 		 */
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_toe
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_TOE
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_ddp_state
operator|.
name|user_ddp_pending
condition|)
block|{
name|t3_cancel_ubuf
argument_list|(
name|toep
argument_list|,
name|rcv
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_ddp_state
operator|.
name|user_ddp_pending
operator|=
literal|0
expr_stmt|;
block|}
name|so_sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|toep
operator|->
name|tp_state
operator|==
name|TCPS_SYN_SENT
condition|)
block|{
name|free_atid
argument_list|(
name|cdev
argument_list|,
name|tid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|__skb_queue_purge
argument_list|(
operator|&
name|tp
operator|->
name|out_of_order_queue
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|// we have TID
name|cxgb_remove_tid
argument_list|(
name|cdev
argument_list|,
name|toep
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|log(LOG_INFO, "closing TID %u, state %u\n", tid, tp->t_state);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|install_offload_ops
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|t_toe
operator|!=
name|NULL
argument_list|,
operator|(
literal|"toepcb not set"
operator|)
argument_list|)
expr_stmt|;
name|t3_install_socket_ops
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_TOE
expr_stmt|;
name|tp
operator|->
name|t_tu
operator|=
operator|&
name|cxgb_toe_usrreqs
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine the receive window scaling factor given a target max  * receive window.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|select_rcv_wscale
parameter_list|(
name|int
name|space
parameter_list|)
block|{
name|int
name|wscale
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|space
operator|>
name|MAX_RCV_WND
condition|)
name|space
operator|=
name|MAX_RCV_WND
expr_stmt|;
if|if
condition|(
name|tcp_do_rfc1323
condition|)
for|for
control|(
init|;
name|space
operator|>
literal|65535
operator|&&
name|wscale
operator|<
literal|14
condition|;
name|space
operator|>>=
literal|1
operator|,
operator|++
name|wscale
control|)
empty_stmt|;
return|return
operator|(
name|wscale
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine the receive window size for a socket.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|select_rcv_wnd
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|d
init|=
name|TOM_DATA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|wnd
decl_stmt|;
name|unsigned
name|int
name|max_rcv_wnd
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|rcv
decl_stmt|;
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcp_do_autorcvbuf
condition|)
name|wnd
operator|=
name|tcp_autorcvbuf_max
expr_stmt|;
else|else
name|wnd
operator|=
name|rcv
operator|->
name|sb_hiwat
expr_stmt|;
comment|/* XXX 	 * For receive coalescing to work effectively we need a receive window 	 * that can accomodate a coalesced segment. 	 */
if|if
condition|(
name|wnd
operator|<
name|MIN_RCV_WND
condition|)
name|wnd
operator|=
name|MIN_RCV_WND
expr_stmt|;
comment|/* PR 5138 */
name|max_rcv_wnd
operator|=
operator|(
name|dev
operator|->
name|tod_ttid
operator|<
name|TOE_ID_CHELSIO_T3C
condition|?
operator|(
name|uint32_t
operator|)
name|d
operator|->
name|rx_page_size
operator|*
literal|23
else|:
name|MAX_RCV_WND
operator|)
expr_stmt|;
return|return
name|min
argument_list|(
name|wnd
argument_list|,
name|max_rcv_wnd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Assign offload parameters to some socket fields.  This code is used by  * both active and passive opens.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|init_offload_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|,
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|,
name|struct
name|rtentry
modifier|*
name|dst
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|t3c_data
modifier|*
name|td
init|=
name|T3C_DATA
argument_list|(
name|TOM_DATA
argument_list|(
name|dev
argument_list|)
operator|->
name|cdev
argument_list|)
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|snd
decl_stmt|,
modifier|*
name|rcv
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|SOCK_LOCK_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|snd
operator|=
name|so_sockbuf_snd
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"initializing offload socket\n"
argument_list|)
expr_stmt|;
comment|/* 	 * We either need to fix push frames to work with sbcompress 	 * or we need to add this 	 */
name|snd
operator|->
name|sb_flags
operator||=
name|SB_NOCOALESCE
expr_stmt|;
name|rcv
operator|->
name|sb_flags
operator||=
name|SB_NOCOALESCE
expr_stmt|;
name|tp
operator|->
name|t_toe
operator|=
name|toep
expr_stmt|;
name|toep
operator|->
name|tp_tp
operator|=
name|tp
expr_stmt|;
name|toep
operator|->
name|tp_toedev
operator|=
name|dev
expr_stmt|;
name|toep
operator|->
name|tp_tid
operator|=
name|tid
expr_stmt|;
name|toep
operator|->
name|tp_l2t
operator|=
name|e
expr_stmt|;
name|toep
operator|->
name|tp_wr_max
operator|=
name|toep
operator|->
name|tp_wr_avail
operator|=
name|TOM_TUNABLE
argument_list|(
name|dev
argument_list|,
name|max_wrs
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_wr_unacked
operator|=
literal|0
expr_stmt|;
name|toep
operator|->
name|tp_delack_mode
operator|=
literal|0
expr_stmt|;
name|toep
operator|->
name|tp_mtu_idx
operator|=
name|select_mss
argument_list|(
name|td
argument_list|,
name|tp
argument_list|,
name|dst
operator|->
name|rt_ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
comment|/* 	 * XXX broken 	 *  	 */
name|tp
operator|->
name|rcv_wnd
operator|=
name|select_rcv_wnd
argument_list|(
name|dev
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_ulp_mode
operator|=
name|TOM_TUNABLE
argument_list|(
name|dev
argument_list|,
name|ddp
argument_list|)
operator|&&
operator|!
operator|(
name|so_options_get
argument_list|(
name|so
argument_list|)
operator|&
name|SO_NO_DDP
operator|)
operator|&&
name|tp
operator|->
name|rcv_wnd
operator|>=
name|MIN_DDP_RCV_WIN
condition|?
name|ULP_MODE_TCPDDP
else|:
literal|0
expr_stmt|;
name|toep
operator|->
name|tp_qset_idx
operator|=
literal|0
expr_stmt|;
name|reset_wr_list
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"initialization done\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The next two functions calculate the option 0 value for a socket.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|calc_opt0h
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|mtu_idx
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|wscale
init|=
name|select_rcv_wscale
argument_list|(
name|tp
operator|->
name|rcv_wnd
argument_list|)
decl_stmt|;
return|return
name|V_NAGLE
argument_list|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NODELAY
operator|)
operator|==
literal|0
argument_list|)
operator||
name|V_KEEP_ALIVE
argument_list|(
operator|(
name|so_options_get
argument_list|(
name|so
argument_list|)
operator|&
name|SO_KEEPALIVE
operator|)
operator|!=
literal|0
argument_list|)
operator||
name|F_TCAM_BYPASS
operator||
name|V_WND_SCALE
argument_list|(
name|wscale
argument_list|)
operator||
name|V_MSS_IDX
argument_list|(
name|mtu_idx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|calc_opt0l
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|ulp_mode
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
name|val
operator|=
name|V_TOS
argument_list|(
name|INP_TOS
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
argument_list|)
operator||
name|V_ULP_MODE
argument_list|(
name|ulp_mode
argument_list|)
operator||
name|V_RCV_BUFSIZ
argument_list|(
name|min
argument_list|(
name|tp
operator|->
name|rcv_wnd
operator|>>
literal|10
argument_list|,
operator|(
name|u32
operator|)
name|M_RCV_BUFSIZ
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"opt0l tos=%08x rcv_wnd=%ld opt0l=%08x\n"
argument_list|,
name|INP_TOS
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
argument_list|,
name|tp
operator|->
name|rcv_wnd
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|calc_opt2
parameter_list|(
specifier|const
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|toedev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|flv_valid
decl_stmt|;
name|flv_valid
operator|=
operator|(
name|TOM_TUNABLE
argument_list|(
name|dev
argument_list|,
name|cong_alg
argument_list|)
operator|!=
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|V_FLAVORS_VALID
argument_list|(
name|flv_valid
argument_list|)
operator||
name|V_CONG_CONTROL_FLAVOR
argument_list|(
name|flv_valid
condition|?
name|TOM_TUNABLE
argument_list|(
name|dev
argument_list|,
name|cong_alg
argument_list|)
else|:
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|DEBUG_WR
operator|>
literal|1
end_if

begin_function
specifier|static
name|int
name|count_pending_wrs
parameter_list|(
specifier|const
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
specifier|const
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|wr_queue_walk
argument_list|(
argument|toep
argument_list|,
argument|m
argument_list|)
name|n
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|(((*(struct tom_data **)&(dev)->l4opt)->conf.cong_alg) != -1)
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|mk_act_open_req
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|atid
parameter_list|,
specifier|const
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|cpl_act_open_req
modifier|*
name|req
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|so_sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|inp_inpcbtotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tdev
init|=
name|toep
operator|->
name|tp_toedev
decl_stmt|;
name|m_set_priority
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|m
argument_list|,
name|mkprio
argument_list|(
name|CPL_PRIORITY_SETUP
argument_list|,
name|toep
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_act_open_req
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_lo
operator|=
literal|0
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_ACT_OPEN_REQ
argument_list|,
name|atid
argument_list|)
argument_list|)
expr_stmt|;
name|inp_4tuple_get
argument_list|(
name|inp
argument_list|,
operator|&
name|req
operator|->
name|local_ip
argument_list|,
operator|&
name|req
operator|->
name|local_port
argument_list|,
operator|&
name|req
operator|->
name|peer_ip
argument_list|,
operator|&
name|req
operator|->
name|peer_port
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|req->local_port = inp->inp_lport; 	req->peer_port = inp->inp_fport; 	memcpy(&req->local_ip,&inp->inp_laddr, 4); 	memcpy(&req->peer_ip,&inp->inp_faddr, 4);
endif|#
directive|endif
name|req
operator|->
name|opt0h
operator|=
name|htonl
argument_list|(
name|calc_opt0h
argument_list|(
name|so
argument_list|,
name|toep
operator|->
name|tp_mtu_idx
argument_list|)
operator||
name|V_L2T_IDX
argument_list|(
name|e
operator|->
name|idx
argument_list|)
operator||
name|V_TX_CHANNEL
argument_list|(
name|e
operator|->
name|smt_idx
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|opt0l
operator|=
name|htonl
argument_list|(
name|calc_opt0l
argument_list|(
name|so
argument_list|,
name|toep
operator|->
name|tp_ulp_mode
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|params
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|opt2
operator|=
name|htonl
argument_list|(
name|calc_opt2
argument_list|(
name|so
argument_list|,
name|tdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert an ACT_OPEN_RPL status to an errno.  */
end_comment

begin_function
specifier|static
name|int
name|act_open_rpl_status_to_errno
parameter_list|(
name|int
name|status
parameter_list|)
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CPL_ERR_CONN_RESET
case|:
return|return
operator|(
name|ECONNREFUSED
operator|)
return|;
case|case
name|CPL_ERR_ARP_MISS
case|:
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
case|case
name|CPL_ERR_CONN_TIMEDOUT
case|:
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
case|case
name|CPL_ERR_TCAM_FULL
case|:
return|return
operator|(
name|ENOMEM
operator|)
return|;
case|case
name|CPL_ERR_CONN_EXIST
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ACTIVE_OPEN_RPL: 4-tuple in use\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fail_act_open
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|errno
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|t3_release_offload_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
condition|)
block|{
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tcp_offload_drop
argument_list|(
name|tp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
name|TCP_INC_STATS_BH
argument_list|(
name|TCP_MIB_ATTEMPTFAILS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Handle active open failures.  */
end_comment

begin_function
specifier|static
name|void
name|active_open_failed
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_act_open_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_tp
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|inp
operator|=
name|toep
operator|->
name|tp_tp
operator|->
name|t_inpcb
expr_stmt|;
comment|/*  * Don't handle connection retry for now  */
ifdef|#
directive|ifdef
name|notyet
name|struct
name|inet_connection_sock
modifier|*
name|icsk
init|=
name|inet_csk
argument_list|(
name|sk
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpl
operator|->
name|status
operator|==
name|CPL_ERR_CONN_EXIST
operator|&&
name|icsk
operator|->
name|icsk_retransmit_timer
operator|.
name|function
operator|!=
name|act_open_retry_timer
condition|)
block|{
name|icsk
operator|->
name|icsk_retransmit_timer
operator|.
name|function
operator|=
name|act_open_retry_timer
expr_stmt|;
name|sk_reset_timer
argument_list|(
name|so
argument_list|,
operator|&
name|icsk
operator|->
name|icsk_retransmit_timer
argument_list|,
name|jiffies
operator|+
name|HZ
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|inp_wlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 		 * drops the inpcb lock 		 */
name|fail_act_open
argument_list|(
name|toep
argument_list|,
name|act_open_rpl_status_to_errno
argument_list|(
name|rpl
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return whether a failed active open has allocated a TID  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|act_open_has_tid
parameter_list|(
name|int
name|status
parameter_list|)
block|{
return|return
name|status
operator|!=
name|CPL_ERR_TCAM_FULL
operator|&&
name|status
operator|!=
name|CPL_ERR_CONN_EXIST
operator|&&
name|status
operator|!=
name|CPL_ERR_ARP_MISS
return|;
block|}
end_function

begin_comment
comment|/*  * Process an ACT_OPEN_RPL CPL message.  */
end_comment

begin_function
specifier|static
name|int
name|do_act_open_rpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
operator|(
expr|struct
name|toepcb
operator|*
operator|)
name|ctx
decl_stmt|;
name|struct
name|cpl_act_open_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|cdev
operator|->
name|type
operator|!=
name|T3A
operator|&&
name|act_open_has_tid
argument_list|(
name|rpl
operator|->
name|status
argument_list|)
condition|)
name|cxgb_queue_tid_release
argument_list|(
name|cdev
argument_list|,
name|GET_TID
argument_list|(
name|rpl
argument_list|)
argument_list|)
expr_stmt|;
name|active_open_failed
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an ARP failure for an active open.   XXX purge ofo queue  *  * XXX badly broken for crossed SYNs as the ATID is no longer valid.  * XXX crossed SYN errors should be generated by PASS_ACCEPT_RPL which should  * check SOCK_DEAD or sk->sk_sock.  Or maybe generate the error here but don't  * free the atid.  Hmm.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|void
name|act_open_req_arp_failure
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|m_get_toep
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|inp_wlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_SENT
operator|||
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_RECEIVED
condition|)
block|{
comment|/* 		 * drops the inpcb lock 		 */
name|fail_act_open
argument_list|(
name|so
argument_list|,
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"freeing %p\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|inp_wunlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Send an active open request.  */
end_comment

begin_function
name|int
name|t3_connect
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|d
init|=
name|TOM_DATA
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|so_sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
comment|/* allocated by init_offload_socket */
name|int
name|atid
decl_stmt|;
name|toep
operator|=
name|toepcb_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|toep
operator|==
name|NULL
condition|)
goto|goto
name|out_err
goto|;
if|if
condition|(
operator|(
name|atid
operator|=
name|cxgb_alloc_atid
argument_list|(
name|d
operator|->
name|cdev
argument_list|,
name|d
operator|->
name|client
argument_list|,
name|toep
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|out_err
goto|;
name|e
operator|=
name|t3_l2t_get
argument_list|(
name|d
operator|->
name|cdev
argument_list|,
name|rt
argument_list|,
name|rt
operator|->
name|rt_ifp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
goto|goto
name|free_tid
goto|;
name|inp_lock_assert
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|MT_DATA
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|m->m_toe.mt_toepcb = tp->t_toe; 	set_arp_failure_handler((struct mbuf *)m, act_open_req_arp_failure);
endif|#
directive|endif
name|so_lock
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|init_offload_socket
argument_list|(
name|so
argument_list|,
name|tdev
argument_list|,
name|atid
argument_list|,
name|e
argument_list|,
name|rt
argument_list|,
name|toep
argument_list|)
expr_stmt|;
name|install_offload_ops
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|mk_act_open_req
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|atid
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|so_unlock
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|toep
operator|=
name|tp
operator|->
name|t_toe
expr_stmt|;
name|m_set_toep
argument_list|(
name|m
argument_list|,
name|tp
operator|->
name|t_toe
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_state
operator|=
name|TCPS_SYN_SENT
expr_stmt|;
name|l2t_send
argument_list|(
name|d
operator|->
name|cdev
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_ulp_mode
condition|)
name|t3_enable_ddp
argument_list|(
name|toep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|free_tid
label|:
name|printf
argument_list|(
literal|"failing connect - free atid\n"
argument_list|)
expr_stmt|;
name|free_atid
argument_list|(
name|d
operator|->
name|cdev
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|out_err
label|:
name|printf
argument_list|(
literal|"return ENOMEM\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send an ABORT_REQ message.  Cannot fail.  This routine makes sure we do  * not send multiple ABORT_REQs for the same connection and also that we do  * not try to send a message after the connection has closed.  Returns 1 if  * an ABORT_REQ wasn't generated after all, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|void
name|t3_send_reset
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|cpl_abort_req
modifier|*
name|req
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|toep
operator|->
name|tp_tid
decl_stmt|;
name|int
name|mode
init|=
name|CPL_ABORT_SEND_RST
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tdev
init|=
name|toep
operator|->
name|tp_toedev
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|snd
decl_stmt|;
if|if
condition|(
name|tp
condition|)
block|{
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_SHUTDOWN
operator|)
operator|||
name|tdev
operator|==
name|NULL
argument_list|)
condition|)
return|return;
name|toep
operator|->
name|tp_flags
operator||=
operator|(
name|TP_ABORT_RPL_PENDING
operator||
name|TP_ABORT_SHUTDOWN
operator|)
expr_stmt|;
name|snd
operator|=
name|so_sockbuf_snd
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* Purge the send queue so we don't send anything after an abort. */
if|if
condition|(
name|so
condition|)
name|sbflush
argument_list|(
name|snd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_CLOSE_CON_REQUESTED
operator|)
operator|&&
name|is_t3a
argument_list|(
name|tdev
argument_list|)
condition|)
name|mode
operator||=
name|CPL_ABORT_POST_CLOSE_REQ
expr_stmt|;
name|m
operator|=
name|m_gethdr_nofail
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|mkprio
argument_list|(
name|CPL_PRIORITY_DATA
argument_list|,
name|toep
argument_list|)
argument_list|)
expr_stmt|;
name|set_arp_failure_handler
argument_list|(
name|m
argument_list|,
name|abort_arp_failure
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_abort_req
operator|*
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_OFLD_HOST_ABORT_CON_REQ
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_ABORT_REQ
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|rsvd0
operator|=
name|tp
condition|?
name|htonl
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|)
else|:
literal|0
expr_stmt|;
name|req
operator|->
name|rsvd1
operator|=
operator|!
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_DATASENT
operator|)
expr_stmt|;
name|req
operator|->
name|cmd
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|tp
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_SENT
operator|)
condition|)
name|mbufq_tail
argument_list|(
operator|&
name|toep
operator|->
name|out_of_order_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// defer
else|else
name|l2t_send
argument_list|(
name|TOEP_T3C_DEV
argument_list|(
name|toep
argument_list|)
argument_list|,
name|m
argument_list|,
name|toep
operator|->
name|tp_l2t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_ip_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|optval
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_OPTIONS
condition|)
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|!=
name|IP_TOS
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|optval
operator|>
name|IPTOS_PREC_CRITIC_ECP
operator|&&
operator|!
name|suser
argument_list|(
name|curthread
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|inp
operator|=
name|so_sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|inp_wlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp_ip_tos_set
argument_list|(
name|inp
argument_list|,
name|optval
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|inp->inp_ip_tos = optval;
endif|#
directive|endif
name|t3_set_tos
argument_list|(
name|inp_inpcbtotcpcb
argument_list|(
name|inp
argument_list|)
operator|->
name|t_toe
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_tcp_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|size_t
name|copied
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|!=
name|TCP_CONGESTION
operator|&&
name|sopt
operator|->
name|sopt_name
operator|!=
name|TCP_NODELAY
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|TCP_CONGESTION
condition|)
block|{
name|char
name|name
index|[
name|TCP_CA_NAME_MAX
index|]
decl_stmt|;
name|int
name|optlen
init|=
name|sopt
operator|->
name|sopt_valsize
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_dir
operator|==
name|SOPT_GET
condition|)
block|{
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"unimplemented"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
if|if
condition|(
name|optlen
operator|<
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|err
operator|=
name|copyinstr
argument_list|(
name|sopt
operator|->
name|sopt_val
argument_list|,
name|name
argument_list|,
name|min
argument_list|(
name|TCP_CA_NAME_MAX
operator|-
literal|1
argument_list|,
name|optlen
argument_list|)
argument_list|,
operator|&
name|copied
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|copied
operator|<
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tp
operator|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* 		 * XXX I need to revisit this 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|t3_set_cong_control
argument_list|(
name|so
argument_list|,
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|CONGESTION_CONTROL_SUPPORTED
name|tp
operator|->
name|t_cong_control
operator|=
name|strdup
argument_list|(
name|name
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
return|return
operator|(
name|err
operator|)
return|;
block|}
else|else
block|{
name|int
name|optval
decl_stmt|,
name|oldval
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_dir
operator|==
name|SOPT_GET
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|err
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|inp
operator|=
name|so_sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|=
name|inp_inpcbtotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp_wlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|tp
operator|->
name|t_flags
expr_stmt|;
if|if
condition|(
name|optval
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_NODELAY
expr_stmt|;
else|else
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_NODELAY
expr_stmt|;
name|inp_wunlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldval
operator|!=
name|tp
operator|->
name|t_flags
operator|&&
operator|(
name|tp
operator|->
name|t_toe
operator|!=
name|NULL
operator|)
condition|)
name|t3_set_nagle
argument_list|(
name|tp
operator|->
name|t_toe
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
name|IPPROTO_TCP
condition|)
name|err
operator|=
name|t3_ip_ctloutput
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|t3_tcp_ctloutput
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|EOPNOTSUPP
condition|)
return|return
operator|(
name|err
operator|)
return|;
return|return
operator|(
name|tcp_ctloutput
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if we need to explicitly request RST when we receive new data  * on an RX-closed connection.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|need_rst_on_excess_rx
parameter_list|(
specifier|const
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handles Rx data that arrives in a state where the socket isn't accepting  * new data.  */
end_comment

begin_function
specifier|static
name|void
name|handle_excess_rx
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|need_rst_on_excess_rx
argument_list|(
name|toep
argument_list|)
operator|&&
operator|!
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_SHUTDOWN
operator|)
condition|)
name|t3_send_reset
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a get_tcb_rpl as a DDP completion (similar to RX_DDP_COMPLETE)  * by getting the DDP offset from the TCB.  */
end_comment

begin_function
specifier|static
name|void
name|tcb_rpl_as_ddp_complete
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ddp_state
modifier|*
name|q
init|=
operator|&
name|toep
operator|->
name|tp_ddp_state
decl_stmt|;
name|struct
name|ddp_buf_state
modifier|*
name|bsp
decl_stmt|;
name|struct
name|cpl_get_tcb_rpl
modifier|*
name|hdr
decl_stmt|;
name|unsigned
name|int
name|ddp_offset
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|rcv
decl_stmt|;
name|int
name|state
decl_stmt|;
name|uint64_t
name|t
decl_stmt|;
name|__be64
modifier|*
name|tcb
decl_stmt|;
name|tp
operator|=
name|toep
operator|->
name|tp_tp
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
comment|/* Note that we only accout for CPL_GET_TCB issued by the DDP code. 	 * We really need a cookie in order to dispatch the RPLs. 	 */
name|q
operator|->
name|get_tcb_count
operator|--
expr_stmt|;
comment|/* It is a possible that a previous CPL already invalidated UBUF DDP 	 * and moved the cur_buf idx and hence no further processing of this 	 * skb is required. However, the app might be sleeping on 	 * !q->get_tcb_count and we need to wake it up. 	 */
if|if
condition|(
name|q
operator|->
name|cancel_ubuf
operator|&&
operator|!
name|t3_ddp_ubuf_pending
argument_list|(
name|toep
argument_list|)
condition|)
block|{
name|int
name|state
init|=
name|so_state_get
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|state
operator|&
name|SS_NOFDREF
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|so_sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
return|return;
block|}
name|bsp
operator|=
operator|&
name|q
operator|->
name|buf_state
index|[
name|q
operator|->
name|cur_buf
index|]
expr_stmt|;
name|hdr
operator|=
name|cplhdr
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|tcb
operator|=
operator|(
name|__be64
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|cur_buf
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|be64toh
argument_list|(
name|tcb
index|[
operator|(
literal|31
operator|-
name|W_TCB_RX_DDP_BUF0_OFFSET
operator|)
operator|/
literal|2
index|]
argument_list|)
expr_stmt|;
name|ddp_offset
operator|=
name|t
operator|>>
operator|(
literal|32
operator|+
name|S_TCB_RX_DDP_BUF0_OFFSET
operator|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|be64toh
argument_list|(
name|tcb
index|[
operator|(
literal|31
operator|-
name|W_TCB_RX_DDP_BUF1_OFFSET
operator|)
operator|/
literal|2
index|]
argument_list|)
expr_stmt|;
name|ddp_offset
operator|=
name|t
operator|>>
name|S_TCB_RX_DDP_BUF1_OFFSET
expr_stmt|;
block|}
name|ddp_offset
operator|&=
name|M_TCB_RX_DDP_BUF0_OFFSET
expr_stmt|;
name|m
operator|->
name|m_cur_offset
operator|=
name|bsp
operator|->
name|cur_offset
expr_stmt|;
name|bsp
operator|->
name|cur_offset
operator|=
name|ddp_offset
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|ddp_offset
operator|-
name|m
operator|->
name|m_cur_offset
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_TOM
argument_list|,
literal|"tcb_rpl_as_ddp_complete: idx=%d seq=0x%x hwbuf=%u ddp_offset=%u cur_offset=%u"
argument_list|,
name|q
operator|->
name|cur_buf
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|q
operator|->
name|cur_buf
argument_list|,
name|ddp_offset
argument_list|,
name|m
operator|->
name|m_cur_offset
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ddp_offset
operator|>=
name|m
operator|->
name|m_cur_offset
argument_list|,
operator|(
literal|"ddp_offset=%u less than cur_offset=%u"
operator|,
name|ddp_offset
operator|,
name|m
operator|->
name|m_cur_offset
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|{ 	unsigned int ddp_flags, rcv_nxt, rx_hdr_offset, buf_idx;  	t = be64toh(tcb[(31 - W_TCB_RX_DDP_FLAGS) / 2]); 	ddp_flags = (t>> S_TCB_RX_DDP_FLAGS)& M_TCB_RX_DDP_FLAGS;          t = be64toh(tcb[(31 - W_TCB_RCV_NXT) / 2]);         rcv_nxt = t>> S_TCB_RCV_NXT;         rcv_nxt&= M_TCB_RCV_NXT;          t = be64toh(tcb[(31 - W_TCB_RX_HDR_OFFSET) / 2]);         rx_hdr_offset = t>> (32 + S_TCB_RX_HDR_OFFSET);         rx_hdr_offset&= M_TCB_RX_HDR_OFFSET;  	T3_TRACE2(TIDTB(sk), 		  "tcb_rpl_as_ddp_complete: DDP FLAGS 0x%x dma up to 0x%x", 		  ddp_flags, rcv_nxt - rx_hdr_offset); 	T3_TRACE4(TB(q), 		  "tcb_rpl_as_ddp_complete: rcvnxt 0x%x hwbuf %u cur_offset %u cancel %u", 		  tp->rcv_nxt, q->cur_buf, bsp->cur_offset, q->cancel_ubuf); 	T3_TRACE3(TB(q), 		  "tcb_rpl_as_ddp_complete: TCB rcvnxt 0x%x hwbuf 0x%x ddp_offset %u", 		  rcv_nxt - rx_hdr_offset, ddp_flags, ddp_offset); 	T3_TRACE2(TB(q), 		  "tcb_rpl_as_ddp_complete: flags0 0x%x flags1 0x%x", 		 q->buf_state[0].flags, q->buf_state[1].flags);  }
endif|#
directive|endif
if|if
condition|(
name|__predict_false
argument_list|(
name|so_no_receive
argument_list|(
name|so
argument_list|)
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
condition|)
block|{
name|handle_excess_rx
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|T3_TRACE
if|if
condition|(
operator|(
name|int
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|0
condition|)
block|{
name|t3_ddp_error
argument_list|(
name|so
argument_list|,
literal|"tcb_rpl_as_ddp_complete: neg len"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOCOPY
condition|)
block|{
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE0
argument_list|(
name|TB
argument_list|(
name|q
argument_list|)
argument_list|,
literal|"tcb_rpl_as_ddp_complete: CANCEL UBUF"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|cancel_ubuf
operator|&&
operator|!
operator|(
name|sk
operator|->
name|sk_shutdown
operator|&
name|RCV_SHUTDOWN
operator|)
condition|)
block|{
name|printk
argument_list|(
literal|"!cancel_ubuf"
argument_list|)
expr_stmt|;
name|t3_ddp_error
argument_list|(
name|sk
argument_list|,
literal|"tcb_rpl_as_ddp_complete: !cancel_ubuf"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|->
name|m_ddp_flags
operator|=
name|DDP_BF_PSH
operator||
name|DDP_BF_NOCOPY
operator||
literal|1
expr_stmt|;
name|bsp
operator|->
name|flags
operator|&=
operator|~
operator|(
name|DDP_BF_NOCOPY
operator||
name|DDP_BF_NODATA
operator|)
expr_stmt|;
name|q
operator|->
name|cur_buf
operator|^=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOFLIP
condition|)
block|{
name|m
operator|->
name|m_ddp_flags
operator|=
literal|1
expr_stmt|;
comment|/* always a kernel buffer */
comment|/* now HW buffer carries a user buffer */
name|bsp
operator|->
name|flags
operator|&=
operator|~
name|DDP_BF_NOFLIP
expr_stmt|;
name|bsp
operator|->
name|flags
operator||=
name|DDP_BF_NOCOPY
expr_stmt|;
comment|/* It is possible that the CPL_GET_TCB_RPL doesn't indicate 		 * any new data in which case we're done. If in addition the 		 * offset is 0, then there wasn't a completion for the kbuf 		 * and we need to decrement the posted count. 		 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ddp_offset
operator|==
literal|0
condition|)
block|{
name|q
operator|->
name|kbuf_posted
operator|--
expr_stmt|;
name|bsp
operator|->
name|flags
operator||=
name|DDP_BF_NODATA
expr_stmt|;
block|}
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
comment|/* This reply is for a CPL_GET_TCB_RPL to cancel the UBUF DDP, 		 * but it got here way late and nobody cares anymore. 		 */
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_ddp_gl
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bsp
operator|->
name|gl
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_DDP
expr_stmt|;
name|m
operator|->
name|m_seq
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|tp
operator|->
name|t_rcvtime
operator|=
name|ticks
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_TOM
argument_list|,
literal|"tcb_rpl_as_ddp_complete: seq 0x%x hwbuf %u m->m_pktlen %u"
argument_list|,
name|m
operator|->
name|m_seq
argument_list|,
name|q
operator|->
name|cur_buf
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|q
operator|->
name|user_ddp_pending
operator|=
literal|0
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|SBAPPEND
argument_list|(
name|rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|state
operator|=
name|so_state_get
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|state
operator|&
name|SS_NOFDREF
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|so_sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a CPL_GET_TCB_RPL.  These can also be generated by the DDP code,  * in that case they are similar to DDP completions.  */
end_comment

begin_function
specifier|static
name|int
name|do_get_tcb_rpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
operator|(
expr|struct
name|toepcb
operator|*
operator|)
name|ctx
decl_stmt|;
comment|/* OK if socket doesn't exist */
if|if
condition|(
name|toep
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"null toep in do_get_tcb_rpl\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CPL_RET_BUF_DONE
operator|)
return|;
block|}
name|inp_wlock
argument_list|(
name|toep
operator|->
name|tp_tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tcb_rpl_as_ddp_complete
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|toep
operator|->
name|tp_tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_ddp_data
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|ddp_state
modifier|*
name|q
decl_stmt|;
name|struct
name|ddp_buf_state
modifier|*
name|bsp
decl_stmt|;
name|struct
name|cpl_rx_data
modifier|*
name|hdr
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|rcv_nxt
init|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|seq
argument_list|)
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|rcv
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|rcv_nxt
operator|==
name|rcv_nxt
condition|)
return|return;
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|q
operator|=
operator|&
name|toep
operator|->
name|tp_ddp_state
expr_stmt|;
name|bsp
operator|=
operator|&
name|q
operator|->
name|buf_state
index|[
name|q
operator|->
name|cur_buf
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|SEQ_GT
argument_list|(
name|rcv_nxt
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|)
argument_list|,
operator|(
literal|"tp->rcv_nxt=0x%08x decreased rcv_nxt=0x08%x"
operator|,
name|rcv_nxt
operator|,
name|tp
operator|->
name|rcv_nxt
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|rcv_nxt
operator|-
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|>
literal|0
argument_list|,
operator|(
literal|"%s m_len=%d"
operator|,
name|__FUNCTION__
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_TOM
argument_list|,
literal|"rcv_nxt=0x%x tp->rcv_nxt=0x%x len=%d"
argument_list|,
name|rcv_nxt
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|T3_TRACE
if|if
condition|(
operator|(
name|int
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|0
condition|)
block|{
name|t3_ddp_error
argument_list|(
name|so
argument_list|,
literal|"handle_ddp_data: neg len"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|->
name|m_ddp_gl
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bsp
operator|->
name|gl
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_DDP
expr_stmt|;
name|m
operator|->
name|m_cur_offset
operator|=
name|bsp
operator|->
name|cur_offset
expr_stmt|;
name|m
operator|->
name|m_ddp_flags
operator|=
name|DDP_BF_PSH
operator||
operator|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOCOPY
operator|)
operator||
literal|1
expr_stmt|;
if|if
condition|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOCOPY
condition|)
name|bsp
operator|->
name|flags
operator|&=
operator|~
name|DDP_BF_NOCOPY
expr_stmt|;
name|m
operator|->
name|m_seq
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|=
name|rcv_nxt
expr_stmt|;
name|bsp
operator|->
name|cur_offset
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOFLIP
operator|)
condition|)
name|q
operator|->
name|cur_buf
operator|^=
literal|1
expr_stmt|;
comment|/* 	 * For now, don't re-enable DDP after a connection fell out of  DDP 	 * mode. 	 */
name|q
operator|->
name|ubuf_ddp_ready
operator|=
literal|0
expr_stmt|;
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process new data received for a connection.  */
end_comment

begin_function
specifier|static
name|void
name|new_rx_data
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_rx_data
modifier|*
name|hdr
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|rcv
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|len
init|=
name|be16toh
argument_list|(
name|hdr
operator|->
name|len
argument_list|)
decl_stmt|;
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|so_no_receive
argument_list|(
name|so
argument_list|)
argument_list|)
condition|)
block|{
name|handle_excess_rx
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|TRACE_EXIT
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|toep
operator|->
name|tp_ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
name|handle_ddp_data
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_seq
operator|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|seq
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_ulp_mode
operator|=
literal|0
expr_stmt|;
comment|/* for iSCSI */
if|#
directive|if
name|VALIDATE_SEQ
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_seq
operator|!=
name|tp
operator|->
name|rcv_nxt
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: TID %u: Bad sequence number %u, expected %u\n"
argument_list|,
name|toep
operator|->
name|tp_toedev
operator|->
name|name
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|m
operator|->
name|m_seq
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|URGENT_DATA_SUPPORTED
comment|/* 	 * We don't handle urgent data yet 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|hdr
operator|->
name|urg
argument_list|)
condition|)
name|handle_urg_ptr
argument_list|(
name|so
argument_list|,
name|tp
operator|->
name|rcv_nxt
operator|+
name|ntohs
argument_list|(
name|hdr
operator|->
name|urg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|tp
operator|->
name|urg_data
operator|==
name|TCP_URG_NOTYET
operator|&&
name|tp
operator|->
name|urg_seq
operator|-
name|tp
operator|->
name|rcv_nxt
operator|<
name|skb
operator|->
name|len
argument_list|)
condition|)
name|tp
operator|->
name|urg_data
operator|=
name|TCP_URG_VALID
operator||
name|skb
operator|->
name|data
index|[
name|tp
operator|->
name|urg_seq
operator|-
name|tp
operator|->
name|rcv_nxt
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__predict_false
argument_list|(
name|hdr
operator|->
name|dack_mode
operator|!=
name|toep
operator|->
name|tp_delack_mode
argument_list|)
condition|)
block|{
name|toep
operator|->
name|tp_delack_mode
operator|=
name|hdr
operator|->
name|dack_mode
expr_stmt|;
name|toep
operator|->
name|tp_delack_seq
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
block|}
name|CTR6
argument_list|(
name|KTR_TOM
argument_list|,
literal|"appending mbuf=%p pktlen=%d m_len=%d len=%d rcv_nxt=0x%x enqueued_bytes=%d"
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|len
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|toep
operator|->
name|tp_enqueued_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|tp
operator|->
name|t_rcvtime
operator|=
name|ticks
expr_stmt|;
name|toep
operator|->
name|tp_enqueued_bytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_TOM
argument_list|,
literal|"new_rx_data: seq 0x%x len %u"
argument_list|,
name|m
operator|->
name|m_seq
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (sb_notify(rcv)) 		DPRINTF("rx_data so=%p flags=0x%x len=%d\n", so, rcv->sb_flags, m->m_pkthdr.len);
endif|#
directive|endif
name|SBAPPEND
argument_list|(
name|rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * We're giving too many credits to the card - but disable this check so we can keep on moving :-| 	 * 	 */
name|KASSERT
argument_list|(
name|rcv
operator|->
name|sb_cc
operator|<
operator|(
name|rcv
operator|->
name|sb_mbmax
operator|<<
literal|1
operator|)
argument_list|,
operator|(
literal|"so=%p, data contents exceed mbmax, sb_cc=%d sb_mbmax=%d"
operator|,
name|so
operator|,
name|rcv
operator|->
name|sb_cc
operator|,
name|rcv
operator|->
name|sb_mbmax
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CTR2
argument_list|(
name|KTR_TOM
argument_list|,
literal|"sb_cc=%d sb_mbcnt=%d"
argument_list|,
name|rcv
operator|->
name|sb_cc
argument_list|,
name|rcv
operator|->
name|sb_mbcnt
argument_list|)
expr_stmt|;
name|state
operator|=
name|so_state_get
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|state
operator|&
name|SS_NOFDREF
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|so_sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handler for RX_DATA CPL messages.  */
end_comment

begin_function
specifier|static
name|int
name|do_rx_data
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
operator|(
expr|struct
name|toepcb
operator|*
operator|)
name|ctx
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"rx_data len=%d\n"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|new_rx_data
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_rx_data_ddp
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|ddp_state
modifier|*
name|q
decl_stmt|;
name|struct
name|ddp_buf_state
modifier|*
name|bsp
decl_stmt|;
name|struct
name|cpl_rx_data_ddp
modifier|*
name|hdr
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|unsigned
name|int
name|ddp_len
decl_stmt|,
name|rcv_nxt
decl_stmt|,
name|ddp_report
decl_stmt|,
name|end_offset
decl_stmt|,
name|buf_idx
decl_stmt|;
name|int
name|nomoredata
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|delack_mode
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|rcv
decl_stmt|;
name|tp
operator|=
name|toep
operator|->
name|tp_tp
expr_stmt|;
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|so_no_receive
argument_list|(
name|so
argument_list|)
argument_list|)
condition|)
block|{
name|handle_excess_rx
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
return|return;
block|}
name|q
operator|=
operator|&
name|toep
operator|->
name|tp_ddp_state
expr_stmt|;
name|hdr
operator|=
name|cplhdr
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ddp_report
operator|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|u
operator|.
name|ddp_report
argument_list|)
expr_stmt|;
name|buf_idx
operator|=
operator|(
name|ddp_report
operator|>>
name|S_DDP_BUF_IDX
operator|)
operator|&
literal|1
expr_stmt|;
name|bsp
operator|=
operator|&
name|q
operator|->
name|buf_state
index|[
name|buf_idx
index|]
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_TOM
argument_list|,
literal|"new_rx_data_ddp: tp->rcv_nxt 0x%x cur_offset %u "
literal|"hdr seq 0x%x len %u"
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|bsp
operator|->
name|cur_offset
argument_list|,
name|ntohl
argument_list|(
name|hdr
operator|->
name|seq
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|hdr
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_TOM
argument_list|,
literal|"new_rx_data_ddp: offset %u ddp_report 0x%x buf_idx=%d"
argument_list|,
name|G_DDP_OFFSET
argument_list|(
name|ddp_report
argument_list|)
argument_list|,
name|ddp_report
argument_list|,
name|buf_idx
argument_list|)
expr_stmt|;
name|ddp_len
operator|=
name|ntohs
argument_list|(
name|hdr
operator|->
name|len
argument_list|)
expr_stmt|;
name|rcv_nxt
operator|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|seq
argument_list|)
operator|+
name|ddp_len
expr_stmt|;
name|delack_mode
operator|=
name|G_DDP_DACK_MODE
argument_list|(
name|ddp_report
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|G_DDP_DACK_MODE
argument_list|(
name|ddp_report
argument_list|)
operator|!=
name|toep
operator|->
name|tp_delack_mode
argument_list|)
condition|)
block|{
name|toep
operator|->
name|tp_delack_mode
operator|=
name|delack_mode
expr_stmt|;
name|toep
operator|->
name|tp_delack_seq
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
block|}
name|m
operator|->
name|m_seq
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|=
name|rcv_nxt
expr_stmt|;
name|tp
operator|->
name|t_rcvtime
operator|=
name|ticks
expr_stmt|;
comment|/* 	 * Store the length in m->m_len.  We are changing the meaning of 	 * m->m_len here, we need to be very careful that nothing from now on 	 * interprets ->len of this packet the usual way. 	 */
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|rcv_nxt
operator|-
name|m
operator|->
name|m_seq
expr_stmt|;
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_TOM
argument_list|,
literal|"new_rx_data_ddp: m_len=%u rcv_next 0x%08x rcv_nxt_prev=0x%08x "
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|rcv_nxt
argument_list|,
name|m
operator|->
name|m_seq
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out where the new data was placed in the buffer and store it 	 * in when.  Assumes the buffer offset starts at 0, consumer needs to 	 * account for page pod's pg_offset. 	 */
name|end_offset
operator|=
name|G_DDP_OFFSET
argument_list|(
name|ddp_report
argument_list|)
operator|+
name|ddp_len
expr_stmt|;
name|m
operator|->
name|m_cur_offset
operator|=
name|end_offset
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_ddp_gl
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bsp
operator|->
name|gl
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_DDP
expr_stmt|;
name|bsp
operator|->
name|cur_offset
operator|=
name|end_offset
expr_stmt|;
name|toep
operator|->
name|tp_enqueued_bytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 	 * Length is only meaningful for kbuf 	 */
if|if
condition|(
operator|!
operator|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOCOPY
operator|)
condition|)
name|KASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|<=
name|bsp
operator|->
name|gl
operator|->
name|dgl_length
argument_list|,
operator|(
literal|"length received exceeds ddp pages: len=%d dgl_length=%d"
operator|,
name|m
operator|->
name|m_len
operator|,
name|bsp
operator|->
name|gl
operator|->
name|dgl_length
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|>
literal|0
argument_list|,
operator|(
literal|"%s m_len=%d"
operator|,
name|__FUNCTION__
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_next
operator|==
name|NULL
argument_list|,
operator|(
literal|"m_len=%p"
operator|,
name|m
operator|->
name|m_next
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Bit 0 of flags stores whether the DDP buffer is completed. 	 * Note that other parts of the code depend on this being in bit 0. 	 */
if|if
condition|(
operator|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOINVAL
operator|)
operator|&&
name|end_offset
operator|!=
name|bsp
operator|->
name|gl
operator|->
name|dgl_length
condition|)
block|{
name|panic
argument_list|(
literal|"spurious ddp completion"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_ddp_flags
operator|=
operator|!
operator|!
operator|(
name|ddp_report
operator|&
name|F_DDP_BUF_COMPLETE
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_ddp_flags
operator|&&
operator|!
operator|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOFLIP
operator|)
condition|)
name|q
operator|->
name|cur_buf
operator|^=
literal|1
expr_stmt|;
comment|/* flip buffers */
block|}
if|if
condition|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOCOPY
condition|)
block|{
name|m
operator|->
name|m_ddp_flags
operator||=
operator|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOCOPY
operator|)
expr_stmt|;
name|bsp
operator|->
name|flags
operator|&=
operator|~
name|DDP_BF_NOCOPY
expr_stmt|;
block|}
if|if
condition|(
name|ddp_report
operator|&
name|F_DDP_PSH
condition|)
name|m
operator|->
name|m_ddp_flags
operator||=
name|DDP_BF_PSH
expr_stmt|;
if|if
condition|(
name|nomoredata
condition|)
name|m
operator|->
name|m_ddp_flags
operator||=
name|DDP_BF_NODATA
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|skb_reset_transport_header
argument_list|(
name|skb
argument_list|)
expr_stmt|;
name|tcp_hdr
argument_list|(
name|skb
argument_list|)
operator|->
name|fin
operator|=
literal|0
expr_stmt|;
comment|/* changes original hdr->ddp_report */
endif|#
directive|endif
name|SBAPPEND
argument_list|(
name|rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|so_state_get
argument_list|(
name|so
argument_list|)
operator|&
name|SS_NOFDREF
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|ddp_report
operator|&
name|F_DDP_PSH
operator|)
operator|||
operator|(
operator|(
operator|(
name|m
operator|->
name|m_ddp_flags
operator|&
operator|(
name|DDP_BF_NOCOPY
operator||
literal|1
operator|)
operator|)
operator|==
operator|(
name|DDP_BF_NOCOPY
operator||
literal|1
operator|)
operator|)
operator|||
operator|!
operator|(
name|m
operator|->
name|m_ddp_flags
operator|&
name|DDP_BF_NOCOPY
operator|)
operator|)
operator|)
condition|)
name|so_sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DDP_ERR
value|(F_DDP_PPOD_MISMATCH | F_DDP_LLIMIT_ERR | F_DDP_ULIMIT_ERR |\ 		 F_DDP_PPOD_PARITY_ERR | F_DDP_PADDING_ERR | F_DDP_OFFSET_ERR |\ 		 F_DDP_INVALID_TAG | F_DDP_COLOR_ERR | F_DDP_TID_MISMATCH |\ 		 F_DDP_INVALID_PPOD)
end_define

begin_comment
comment|/*  * Handler for RX_DATA_DDP CPL messages.  */
end_comment

begin_function
specifier|static
name|int
name|do_rx_data_ddp
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|ctx
decl_stmt|;
specifier|const
name|struct
name|cpl_rx_data_ddp
modifier|*
name|hdr
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|VALIDATE_SOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|ntohl
argument_list|(
name|hdr
operator|->
name|ddpvld_status
argument_list|)
operator|&
name|DDP_ERR
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"RX_DATA_DDP for TID %u reported error 0x%x\n"
argument_list|,
name|GET_TID
argument_list|(
name|hdr
argument_list|)
argument_list|,
name|G_DDP_VALID
argument_list|(
name|ntohl
argument_list|(
name|hdr
operator|->
name|ddpvld_status
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|CPL_RET_BUF_DONE
operator|)
return|;
block|}
if|#
directive|if
literal|0
block|skb->h.th = tcphdr_skb->h.th;
endif|#
directive|endif
name|new_rx_data_ddp
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_ddp_complete
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|ddp_state
modifier|*
name|q
decl_stmt|;
name|struct
name|ddp_buf_state
modifier|*
name|bsp
decl_stmt|;
name|struct
name|cpl_rx_ddp_complete
modifier|*
name|hdr
decl_stmt|;
name|unsigned
name|int
name|ddp_report
decl_stmt|,
name|buf_idx
decl_stmt|,
name|when
decl_stmt|,
name|delack_mode
decl_stmt|;
name|int
name|nomoredata
init|=
literal|0
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|rcv
decl_stmt|;
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|so_no_receive
argument_list|(
name|so
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|so_sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|handle_excess_rx
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return;
block|}
name|q
operator|=
operator|&
name|toep
operator|->
name|tp_ddp_state
expr_stmt|;
name|hdr
operator|=
name|cplhdr
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ddp_report
operator|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|ddp_report
argument_list|)
expr_stmt|;
name|buf_idx
operator|=
operator|(
name|ddp_report
operator|>>
name|S_DDP_BUF_IDX
operator|)
operator|&
literal|1
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|bsp
operator|=
operator|&
name|q
operator|->
name|buf_state
index|[
name|buf_idx
index|]
expr_stmt|;
name|when
operator|=
name|bsp
operator|->
name|cur_offset
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|G_DDP_OFFSET
argument_list|(
name|ddp_report
argument_list|)
operator|-
name|when
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|tp
operator|->
name|t_rcvtime
operator|=
name|ticks
expr_stmt|;
name|delack_mode
operator|=
name|G_DDP_DACK_MODE
argument_list|(
name|ddp_report
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|G_DDP_DACK_MODE
argument_list|(
name|ddp_report
argument_list|)
operator|!=
name|toep
operator|->
name|tp_delack_mode
argument_list|)
condition|)
block|{
name|toep
operator|->
name|tp_delack_mode
operator|=
name|delack_mode
expr_stmt|;
name|toep
operator|->
name|tp_delack_seq
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
name|skb_reset_transport_header
argument_list|(
name|skb
argument_list|)
expr_stmt|;
name|tcp_hdr
argument_list|(
name|skb
argument_list|)
operator|->
name|fin
operator|=
literal|0
expr_stmt|;
comment|/* changes valid memory past CPL */
endif|#
directive|endif
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s m_len=%d"
operator|,
name|__FUNCTION__
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_TOM
argument_list|,
literal|"process_ddp_complete: tp->rcv_nxt 0x%x cur_offset %u "
literal|"ddp_report 0x%x offset %u, len %u"
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|bsp
operator|->
name|cur_offset
argument_list|,
name|ddp_report
argument_list|,
name|G_DDP_OFFSET
argument_list|(
name|ddp_report
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_cur_offset
operator|=
name|bsp
operator|->
name|cur_offset
expr_stmt|;
name|bsp
operator|->
name|cur_offset
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOFLIP
operator|)
condition|)
block|{
name|q
operator|->
name|cur_buf
operator|^=
literal|1
expr_stmt|;
comment|/* flip buffers */
if|if
condition|(
name|G_DDP_OFFSET
argument_list|(
name|ddp_report
argument_list|)
operator|<
name|q
operator|->
name|kbuf
index|[
literal|0
index|]
operator|->
name|dgl_length
condition|)
name|nomoredata
operator|=
literal|1
expr_stmt|;
block|}
name|CTR4
argument_list|(
name|KTR_TOM
argument_list|,
literal|"process_ddp_complete: tp->rcv_nxt 0x%x cur_offset %u "
literal|"ddp_report %u offset %u"
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|bsp
operator|->
name|cur_offset
argument_list|,
name|ddp_report
argument_list|,
name|G_DDP_OFFSET
argument_list|(
name|ddp_report
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_ddp_gl
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bsp
operator|->
name|gl
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_DDP
expr_stmt|;
name|m
operator|->
name|m_ddp_flags
operator|=
operator|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOCOPY
operator|)
operator||
literal|1
expr_stmt|;
if|if
condition|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOCOPY
condition|)
name|bsp
operator|->
name|flags
operator|&=
operator|~
name|DDP_BF_NOCOPY
expr_stmt|;
if|if
condition|(
name|nomoredata
condition|)
name|m
operator|->
name|m_ddp_flags
operator||=
name|DDP_BF_NODATA
expr_stmt|;
name|SBAPPEND
argument_list|(
name|rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|so_state_get
argument_list|(
name|so
argument_list|)
operator|&
name|SS_NOFDREF
operator|)
operator|==
literal|0
condition|)
name|so_sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handler for RX_DDP_COMPLETE CPL messages.  */
end_comment

begin_function
specifier|static
name|int
name|do_rx_ddp_complete
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|ctx
decl_stmt|;
name|VALIDATE_SOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|skb->h.th = tcphdr_skb->h.th;
endif|#
directive|endif
name|process_ddp_complete
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move a socket to TIME_WAIT state.  We need to make some adjustments to the  * socket state before calling tcp_time_wait to comply with its expectations.  */
end_comment

begin_function
specifier|static
name|void
name|enter_timewait
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
comment|/* 	 * Bump rcv_nxt for the peer FIN.  We don't do this at the time we 	 * process peer_close because we don't want to carry the peer FIN in 	 * the socket's receive queue and if we increment rcv_nxt without 	 * having the FIN in the receive queue we'll confuse facilities such 	 * as SIOCINQ. 	 */
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|++
expr_stmt|;
name|tp
operator|->
name|ts_recent_age
operator|=
literal|0
expr_stmt|;
comment|/* defeat recycling */
name|tp
operator|->
name|t_srtt
operator|=
literal|0
expr_stmt|;
comment|/* defeat tcp_update_metrics */
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tcp_offload_twstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enter_timewait_disconnect
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
comment|/* 	 * Bump rcv_nxt for the peer FIN.  We don't do this at the time we 	 * process peer_close because we don't want to carry the peer FIN in 	 * the socket's receive queue and if we increment rcv_nxt without 	 * having the FIN in the receive queue we'll confuse facilities such 	 * as SIOCINQ. 	 */
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|++
expr_stmt|;
name|tp
operator|->
name|ts_recent_age
operator|=
literal|0
expr_stmt|;
comment|/* defeat recycling */
name|tp
operator|->
name|t_srtt
operator|=
literal|0
expr_stmt|;
comment|/* defeat tcp_update_metrics */
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tcp_offload_twstart_disconnect
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For TCP DDP a PEER_CLOSE may also be an implicit RX_DDP_COMPLETE.  This  * function deals with the data that may be reported along with the FIN.  * Returns -1 if no further processing of the PEER_CLOSE is needed,>= 0 to  * perform normal FIN-related processing.  In the latter case 1 indicates that  * there was an implicit RX_DDP_COMPLETE and the skb should not be freed, 0 the  * skb can be freed.  */
end_comment

begin_function
specifier|static
name|int
name|handle_peer_close_data
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|ddp_state
modifier|*
name|q
decl_stmt|;
name|struct
name|ddp_buf_state
modifier|*
name|bsp
decl_stmt|;
name|struct
name|cpl_peer_close
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|rcv_nxt
init|=
name|ntohl
argument_list|(
name|req
operator|->
name|rcv_nxt
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* exclude FIN */
name|struct
name|sockbuf
modifier|*
name|rcv
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|rcv_nxt
operator|==
name|rcv_nxt
condition|)
comment|/* no data */
return|return
operator|(
literal|0
operator|)
return|;
name|CTR0
argument_list|(
name|KTR_TOM
argument_list|,
literal|"handle_peer_close_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|so_no_receive
argument_list|(
name|so
argument_list|)
argument_list|)
condition|)
block|{
name|handle_excess_rx
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * Although we discard the data we want to process the FIN so 		 * that PEER_CLOSE + data behaves the same as RX_DATA_DDP + 		 * PEER_CLOSE without data.  In particular this PEER_CLOSE 		 * may be what will close the connection.  We return 1 because 		 * handle_excess_rx() already freed the packet. 		 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|q
operator|=
operator|&
name|toep
operator|->
name|tp_ddp_state
expr_stmt|;
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sockbuf_lock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
name|bsp
operator|=
operator|&
name|q
operator|->
name|buf_state
index|[
name|q
operator|->
name|cur_buf
index|]
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|rcv_nxt
operator|-
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|>
literal|0
argument_list|,
operator|(
literal|"%s m_len=%d"
operator|,
name|__FUNCTION__
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_ddp_gl
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bsp
operator|->
name|gl
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_DDP
expr_stmt|;
name|m
operator|->
name|m_cur_offset
operator|=
name|bsp
operator|->
name|cur_offset
expr_stmt|;
name|m
operator|->
name|m_ddp_flags
operator|=
name|DDP_BF_PSH
operator||
operator|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOCOPY
operator|)
operator||
literal|1
expr_stmt|;
name|m
operator|->
name|m_seq
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|=
name|rcv_nxt
expr_stmt|;
name|bsp
operator|->
name|cur_offset
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bsp
operator|->
name|flags
operator|&
name|DDP_BF_NOFLIP
operator|)
condition|)
name|q
operator|->
name|cur_buf
operator|^=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|skb_reset_transport_header
argument_list|(
name|skb
argument_list|)
expr_stmt|;
name|tcp_hdr
argument_list|(
name|skb
argument_list|)
operator|->
name|fin
operator|=
literal|0
expr_stmt|;
comment|/* changes valid memory past CPL */
endif|#
directive|endif
name|tp
operator|->
name|t_rcvtime
operator|=
name|ticks
expr_stmt|;
name|SBAPPEND
argument_list|(
name|rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|so_state_get
argument_list|(
name|so
argument_list|)
operator|&
name|SS_NOFDREF
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|so_sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|sockbuf_unlock
argument_list|(
name|rcv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle a peer FIN.  */
end_comment

begin_function
specifier|static
name|void
name|do_peer_fin
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|int
name|keep
decl_stmt|,
name|action
decl_stmt|;
name|action
operator|=
name|keep
operator|=
literal|0
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_TOM
argument_list|,
literal|"do_peer_fin state=%d"
argument_list|,
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_t3a
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|)
operator|&&
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_RPL_PENDING
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"abort_pending set\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|toep
operator|->
name|tp_tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_ulp_mode
operator|==
name|ULP_MODE_TCPDDP
condition|)
block|{
name|keep
operator|=
name|handle_peer_close_data
argument_list|(
name|so
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep
operator|<
literal|0
condition|)
block|{
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|TCPS_HAVERCVDFIN
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_TOM
argument_list|,
literal|"waking up waiters for cantrcvmore on %p "
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|socantrcvmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* 		 * If connection is half-synchronized 		 * (ie NEEDSYN flag on) then delay ACK, 		 * so it may be piggybacked when SYN is sent. 		 * Otherwise, since we received a FIN then no 		 * more input can be expected, send ACK now. 		 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NEEDSYN
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_DELACK
expr_stmt|;
else|else
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
case|case
name|TCPS_SYN_RECEIVED
case|:
name|tp
operator|->
name|t_starttime
operator|=
name|ticks
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|TCPS_ESTABLISHED
case|:
name|tp
operator|->
name|t_state
operator|=
name|TCPS_CLOSE_WAIT
expr_stmt|;
break|break;
case|case
name|TCPS_FIN_WAIT_1
case|:
name|tp
operator|->
name|t_state
operator|=
name|TCPS_CLOSING
expr_stmt|;
break|break;
case|case
name|TCPS_FIN_WAIT_2
case|:
comment|/* 		 * If we've sent an abort_req we must have sent it too late, 		 * HW will send us a reply telling us so, and this peer_close 		 * is really the last message for this connection and needs to 		 * be treated as an abort_rpl, i.e., transition the connection 		 * to TCP_CLOSE (note that the host stack does this at the 		 * time of generating the RST but we must wait for HW). 		 * Otherwise we enter TIME_WAIT. 		 */
name|t3_release_offload_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_RPL_PENDING
condition|)
block|{
name|action
operator|=
name|TCP_CLOSE
expr_stmt|;
block|}
else|else
block|{
name|action
operator|=
name|TCP_TIMEWAIT
expr_stmt|;
block|}
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: TID %u received PEER_CLOSE in bad state %d\n"
argument_list|,
name|toep
operator|->
name|tp_toedev
operator|->
name|tod_name
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
block|}
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|TCP_TIMEWAIT
condition|)
block|{
name|enter_timewait
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|TCP_DROP
condition|)
block|{
name|tcp_offload_drop
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|TCP_CLOSE
condition|)
block|{
name|tcp_offload_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* Do not send POLL_HUP for half duplex close. */
if|if
condition|(
operator|(
name|sk
operator|->
name|sk_shutdown
operator|&
name|SEND_SHUTDOWN
operator|)
operator|||
name|sk
operator|->
name|sk_state
operator|==
name|TCP_CLOSE
condition|)
name|sk_wake_async
argument_list|(
name|so
argument_list|,
literal|1
argument_list|,
name|POLL_HUP
argument_list|)
expr_stmt|;
else|else
name|sk_wake_async
argument_list|(
name|so
argument_list|,
literal|1
argument_list|,
name|POLL_IN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
label|:
if|if
condition|(
operator|!
name|keep
condition|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handler for PEER_CLOSE CPL messages.  */
end_comment

begin_function
specifier|static
name|int
name|do_peer_close
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
operator|(
expr|struct
name|toepcb
operator|*
operator|)
name|ctx
decl_stmt|;
name|VALIDATE_SOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|do_peer_fin
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_close_con_rpl
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_close_con_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|action
init|=
literal|0
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|rcv
decl_stmt|;
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_una
operator|=
name|ntohl
argument_list|(
name|rpl
operator|->
name|snd_nxt
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* exclude FIN */
if|if
condition|(
operator|!
name|is_t3a
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|)
operator|&&
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_RPL_PENDING
operator|)
condition|)
block|{
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|CTR3
argument_list|(
name|KTR_TOM
argument_list|,
literal|"process_close_con_rpl(%p) state=%d dead=%d"
argument_list|,
name|toep
argument_list|,
name|tp
operator|->
name|t_state
argument_list|,
operator|!
operator|!
operator|(
name|so_state_get
argument_list|(
name|so
argument_list|)
operator|&
name|SS_NOFDREF
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
case|case
name|TCPS_CLOSING
case|:
comment|/* see FIN_WAIT2 case in do_peer_fin */
name|t3_release_offload_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_RPL_PENDING
condition|)
block|{
name|action
operator|=
name|TCP_CLOSE
expr_stmt|;
block|}
else|else
block|{
name|action
operator|=
name|TCP_TIMEWAIT
expr_stmt|;
block|}
break|break;
case|case
name|TCPS_LAST_ACK
case|:
comment|/* 		 * In this state we don't care about pending abort_rpl. 		 * If we've sent abort_req it was post-close and was sent too 		 * late, this close_con_rpl is the actual last message. 		 */
name|t3_release_offload_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|action
operator|=
name|TCP_CLOSE
expr_stmt|;
break|break;
case|case
name|TCPS_FIN_WAIT_1
case|:
comment|/* 		 * If we can't receive any more 		 * data, then closing user can proceed. 		 * Starting the timer is contrary to the 		 * specification, but if we don't get a FIN 		 * we'll hang forever. 		 * 		 * XXXjl: 		 * we should release the tp also, and use a 		 * compressed state. 		 */
if|if
condition|(
name|so
condition|)
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|rcv
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
name|int
name|timeout
decl_stmt|;
if|if
condition|(
name|so
condition|)
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|timeout
operator|=
operator|(
name|tcp_fast_finwait2_recycle
operator|)
condition|?
name|tcp_finwait2_timeout
else|:
name|tcp_maxidle
expr_stmt|;
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_2MSL
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|=
name|TCPS_FIN_WAIT_2
expr_stmt|;
if|if
condition|(
operator|(
name|so_options_get
argument_list|(
name|so
argument_list|)
operator|&
name|SO_LINGER
operator|)
operator|&&
name|so_linger_get
argument_list|(
name|so
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_SHUTDOWN
operator|)
operator|==
literal|0
condition|)
block|{
name|action
operator|=
name|TCP_DROP
expr_stmt|;
block|}
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: TID %u received CLOSE_CON_RPL in bad state %d\n"
argument_list|,
name|toep
operator|->
name|tp_toedev
operator|->
name|tod_name
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
block|}
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|TCP_TIMEWAIT
condition|)
block|{
name|enter_timewait_disconnect
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|TCP_DROP
condition|)
block|{
name|tcp_offload_drop
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|TCP_CLOSE
condition|)
block|{
name|tcp_offload_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handler for CLOSE_CON_RPL CPL messages.  */
end_comment

begin_function
specifier|static
name|int
name|do_close_con_rpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
operator|(
expr|struct
name|toepcb
operator|*
operator|)
name|ctx
decl_stmt|;
name|process_close_con_rpl
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process abort replies.  We only process these messages if we anticipate  * them as the coordination between SW and HW in this area is somewhat lacking  * and sometimes we get ABORT_RPLs after we are done with the connection that  * originated the ABORT_REQ.  */
end_comment

begin_function
specifier|static
name|void
name|process_abort_rpl
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|needclose
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE1
argument_list|(
name|TIDTB
argument_list|(
name|sk
argument_list|)
argument_list|,
literal|"process_abort_rpl: GTS rpl pending %d"
argument_list|,
name|sock_flag
argument_list|(
name|sk
argument_list|,
name|ABORT_RPL_PENDING
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_RPL_PENDING
condition|)
block|{
comment|/* 		 * XXX panic on tcpdrop 		 */
if|if
condition|(
operator|!
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_RPL_RCVD
operator|)
operator|&&
operator|!
name|is_t3a
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|)
condition|)
name|toep
operator|->
name|tp_flags
operator||=
name|TP_ABORT_RPL_RCVD
expr_stmt|;
else|else
block|{
name|toep
operator|->
name|tp_flags
operator|&=
operator|~
operator|(
name|TP_ABORT_RPL_RCVD
operator||
name|TP_ABORT_RPL_PENDING
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_REQ_RCVD
operator|)
operator|||
operator|!
name|is_t3a
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|)
condition|)
block|{
if|if
condition|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_REQ_RCVD
condition|)
name|panic
argument_list|(
literal|"TP_ABORT_REQ_RCVD set"
argument_list|)
expr_stmt|;
name|t3_release_offload_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|needclose
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|needclose
condition|)
name|tcp_offload_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle an ABORT_RPL_RSS CPL message.  */
end_comment

begin_function
specifier|static
name|int
name|do_abort_rpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|cpl_abort_rpl_rss
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
comment|/* 	 * Ignore replies to post-close aborts indicating that the abort was 	 * requested too late.  These connections are terminated when we get 	 * PEER_CLOSE or CLOSE_CON_RPL and by the time the abort_rpl_rss 	 * arrives the TID is either no longer used or it has been recycled. 	 */
if|if
condition|(
name|rpl
operator|->
name|status
operator|==
name|CPL_ERR_ABORT_FAILED
condition|)
block|{
name|discard
label|:
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|toep
operator|=
operator|(
expr|struct
name|toepcb
operator|*
operator|)
name|ctx
expr_stmt|;
comment|/* 	 * Sometimes we've already closed the socket, e.g., a post-close 	 * abort races with ABORT_REQ_RSS, the latter frees the socket 	 * expecting the ABORT_REQ will fail with CPL_ERR_ABORT_FAILED, 	 * but FW turns the ABORT_REQ into a regular one and so we get 	 * ABORT_RPL_RSS with status 0 and no socket.  Only on T3A. 	 */
if|if
condition|(
operator|!
name|toep
condition|)
goto|goto
name|discard
goto|;
if|if
condition|(
name|toep
operator|->
name|tp_tp
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"removing tid for abort\n"
argument_list|)
expr_stmt|;
name|cxgb_remove_tid
argument_list|(
name|cdev
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_l2t
condition|)
name|l2t_release
argument_list|(
name|L2DATA
argument_list|(
name|cdev
argument_list|)
argument_list|,
name|toep
operator|->
name|tp_l2t
argument_list|)
expr_stmt|;
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
goto|goto
name|discard
goto|;
block|}
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"toep=%p\n"
argument_list|,
name|toep
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"tp=%p\n"
argument_list|,
name|toep
operator|->
name|tp_tp
argument_list|)
expr_stmt|;
name|toepcb_hold
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|process_abort_rpl
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert the status code of an ABORT_REQ into a FreeBSD error code.  Also  * indicate whether RST should be sent in response.  */
end_comment

begin_function
specifier|static
name|int
name|abort_status_to_errno
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|abort_reason
parameter_list|,
name|int
modifier|*
name|need_rst
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|abort_reason
condition|)
block|{
case|case
name|CPL_ERR_BAD_SYN
case|:
if|#
directive|if
literal|0
block|NET_INC_STATS_BH(LINUX_MIB_TCPABORTONSYN);
comment|// fall through
endif|#
directive|endif
case|case
name|CPL_ERR_CONN_RESET
case|:
comment|// XXX need to handle SYN_RECV due to crossed SYNs
return|return
operator|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_CLOSE_WAIT
operator|?
name|EPIPE
operator|:
name|ECONNRESET
operator|)
return|;
case|case
name|CPL_ERR_XMIT_TIMEDOUT
case|:
case|case
name|CPL_ERR_PERSIST_TIMEDOUT
case|:
case|case
name|CPL_ERR_FINWAIT2_TIMEDOUT
case|:
case|case
name|CPL_ERR_KEEPALIVE_TIMEDOUT
case|:
if|#
directive|if
literal|0
block|NET_INC_STATS_BH(LINUX_MIB_TCPABORTONTIMEOUT);
endif|#
directive|endif
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|set_abort_rpl_wr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|struct
name|cpl_abort_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|rpl
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_OFLD_HOST_ABORT_CON_RPL
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|wr
operator|.
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rpl
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|rpl
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_ABORT_RPL
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|cmd
operator|=
name|cmd
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_deferred_abort_rpl
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|reply_mbuf
decl_stmt|;
name|struct
name|cpl_abort_req_rss
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|reply_mbuf
operator|=
name|m_gethdr_nofail
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_abort_rpl
argument_list|)
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|CPL_PRIORITY_DATA
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_abort_rpl
argument_list|)
expr_stmt|;
name|set_abort_rpl_wr
argument_list|(
name|reply_mbuf
argument_list|,
name|GET_TID
argument_list|(
name|req
argument_list|)
argument_list|,
name|req
operator|->
name|status
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|TOM_DATA
argument_list|(
name|tdev
argument_list|)
operator|->
name|cdev
argument_list|,
name|reply_mbuf
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns whether an ABORT_REQ_RSS message is a negative advice.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_neg_adv_abort
parameter_list|(
name|unsigned
name|int
name|status
parameter_list|)
block|{
return|return
name|status
operator|==
name|CPL_ERR_RTX_NEG_ADVICE
operator|||
name|status
operator|==
name|CPL_ERR_PERSIST_NEG_ADVICE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_abort_rpl
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|int
name|rst_status
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|reply_mbuf
decl_stmt|;
name|struct
name|cpl_abort_req_rss
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|reply_mbuf
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reply_mbuf
condition|)
block|{
comment|/* Defer the reply.  Stick rst_status into req->cmd. */
name|req
operator|->
name|status
operator|=
name|rst_status
expr_stmt|;
name|t3_defer_reply
argument_list|(
name|m
argument_list|,
name|tdev
argument_list|,
name|send_deferred_abort_rpl
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_set_priority
argument_list|(
name|reply_mbuf
argument_list|,
name|CPL_PRIORITY_DATA
argument_list|)
expr_stmt|;
name|set_abort_rpl_wr
argument_list|(
name|reply_mbuf
argument_list|,
name|GET_TID
argument_list|(
name|req
argument_list|)
argument_list|,
name|rst_status
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * XXX need to sync with ARP as for SYN_RECV connections we can send 	 * these messages while ARP is pending.  For other connection states 	 * it's not a problem. 	 */
name|cxgb_ofld_send
argument_list|(
name|TOM_DATA
argument_list|(
name|tdev
argument_list|)
operator|->
name|cdev
argument_list|,
name|reply_mbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|void
name|cleanup_syn_rcv_conn
parameter_list|(
name|struct
name|socket
modifier|*
name|child
parameter_list|,
name|struct
name|socket
modifier|*
name|parent
parameter_list|)
block|{
name|CXGB_UNIMPLEMENTED
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|struct
name|request_sock
modifier|*
name|req
init|=
name|child
operator|->
name|sk_user_data
decl_stmt|;
name|inet_csk_reqsk_queue_removed
argument_list|(
name|parent
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|synq_remove
argument_list|(
name|tcp_sk
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|__reqsk_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|child
operator|->
name|sk_user_data
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Performs the actual work to abort a SYN_RECV connection.  */
end_comment

begin_function
specifier|static
name|void
name|do_abort_syn_rcv
parameter_list|(
name|struct
name|socket
modifier|*
name|child
parameter_list|,
name|struct
name|socket
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|parenttp
init|=
name|so_sototcpcb
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|childtp
init|=
name|so_sototcpcb
argument_list|(
name|child
argument_list|)
decl_stmt|;
comment|/* 	 * If the server is still open we clean up the child connection, 	 * otherwise the server already did the clean up as it was purging 	 * its SYN queue and the skb was just sitting in its backlog. 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|parenttp
operator|->
name|t_state
operator|==
name|TCPS_LISTEN
argument_list|)
condition|)
block|{
name|cleanup_syn_rcv_conn
argument_list|(
name|child
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|inp_wlock
argument_list|(
name|childtp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|t3_release_offload_resources
argument_list|(
name|childtp
operator|->
name|t_toe
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|childtp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tcp_offload_close
argument_list|(
name|childtp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Handle abort requests for a SYN_RECV connection.  These need extra work  * because the socket is on its parent's SYN queue.  */
end_comment

begin_function
specifier|static
name|int
name|abort_syn_rcv
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|CXGB_UNIMPLEMENTED
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|struct
name|socket
modifier|*
name|parent
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tdev
init|=
name|toep
operator|->
name|tp_toedev
decl_stmt|;
name|struct
name|t3cdev
modifier|*
name|cdev
init|=
name|TOM_DATA
argument_list|(
name|tdev
argument_list|)
operator|->
name|cdev
decl_stmt|;
name|struct
name|socket
modifier|*
name|oreq
init|=
name|so
operator|->
name|so_incomp
decl_stmt|;
name|struct
name|t3c_tid_entry
modifier|*
name|t3c_stid
decl_stmt|;
name|struct
name|tid_info
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|oreq
condition|)
return|return
operator|-
literal|1
return|;
comment|/* somehow we are not on the SYN queue */
name|t
operator|=
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|cdev
argument_list|)
operator|)
operator|->
name|tid_maps
expr_stmt|;
name|t3c_stid
operator|=
name|lookup_stid
argument_list|(
name|t
argument_list|,
name|oreq
operator|->
name|ts_recent
argument_list|)
expr_stmt|;
name|parent
operator|=
operator|(
operator|(
expr|struct
name|listen_ctx
operator|*
operator|)
name|t3c_stid
operator|->
name|ctx
operator|)
operator|->
name|lso
expr_stmt|;
name|so_lock
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|do_abort_syn_rcv
argument_list|(
name|so
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|send_abort_rpl
argument_list|(
name|m
argument_list|,
name|tdev
argument_list|,
name|CPL_ABORT_NO_RST
argument_list|)
expr_stmt|;
name|so_unlock
argument_list|(
name|parent
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process abort requests.  If we are waiting for an ABORT_RPL we ignore this  * request except that we need to reply to it.  */
end_comment

begin_function
specifier|static
name|void
name|process_abort_req
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|)
block|{
name|int
name|rst_status
init|=
name|CPL_ABORT_NO_RST
decl_stmt|;
specifier|const
name|struct
name|cpl_abort_req_rss
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|needclose
init|=
literal|0
decl_stmt|;
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|toep
operator|->
name|tp_tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_REQ_RCVD
operator|)
operator|==
literal|0
condition|)
block|{
name|toep
operator|->
name|tp_flags
operator||=
operator|(
name|TP_ABORT_REQ_RCVD
operator||
name|TP_ABORT_SHUTDOWN
operator|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|toep
operator|->
name|tp_flags
operator|&=
operator|~
name|TP_ABORT_REQ_RCVD
expr_stmt|;
comment|/* 	 * Three cases to consider: 	 * a) We haven't sent an abort_req; close the connection. 	 * b) We have sent a post-close abort_req that will get to TP too late 	 *    and will generate a CPL_ERR_ABORT_FAILED reply.  The reply will 	 *    be ignored and the connection should be closed now. 	 * c) We have sent a regular abort_req that will get to TP too late. 	 *    That will generate an abort_rpl with status 0, wait for it. 	 */
if|if
condition|(
operator|(
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_RPL_PENDING
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|is_t3a
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|)
operator|&&
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_CLOSE_CON_REQUESTED
operator|)
operator|)
condition|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|abort_status_to_errno
argument_list|(
name|so
argument_list|,
name|req
operator|->
name|status
argument_list|,
operator|&
name|rst_status
argument_list|)
expr_stmt|;
name|so_error_set
argument_list|(
name|so
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|so_state_get
argument_list|(
name|so
argument_list|)
operator|&
name|SS_NOFDREF
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|so_sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* 		 * SYN_RECV needs special processing.  If abort_syn_rcv() 		 * returns 0 is has taken care of the abort. 		 */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_RECEIVED
operator|)
operator|&&
operator|!
name|abort_syn_rcv
argument_list|(
name|so
argument_list|,
name|m
argument_list|)
condition|)
goto|goto
name|skip
goto|;
name|t3_release_offload_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|needclose
operator|=
literal|1
expr_stmt|;
block|}
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|needclose
condition|)
name|tcp_offload_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|send_abort_rpl
argument_list|(
name|m
argument_list|,
name|tdev
argument_list|,
name|rst_status
argument_list|)
expr_stmt|;
return|return;
name|skip
label|:
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle an ABORT_REQ_RSS CPL message.  */
end_comment

begin_function
specifier|static
name|int
name|do_abort_req
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|struct
name|cpl_abort_req_rss
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
operator|(
expr|struct
name|toepcb
operator|*
operator|)
name|ctx
decl_stmt|;
if|if
condition|(
name|is_neg_adv_abort
argument_list|(
name|req
operator|->
name|status
argument_list|)
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"aborting tid=%d\n"
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|toep
operator|->
name|tp_flags
operator|&
operator|(
name|TP_SYN_RCVD
operator||
name|TP_ABORT_REQ_RCVD
operator|)
operator|)
operator|==
name|TP_SYN_RCVD
condition|)
block|{
name|cxgb_remove_tid
argument_list|(
name|cdev
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_flags
operator||=
name|TP_ABORT_REQ_RCVD
expr_stmt|;
name|send_abort_rpl
argument_list|(
name|m
argument_list|,
name|toep
operator|->
name|tp_toedev
argument_list|,
name|CPL_ABORT_NO_RST
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_l2t
condition|)
name|l2t_release
argument_list|(
name|L2DATA
argument_list|(
name|cdev
argument_list|)
argument_list|,
name|toep
operator|->
name|tp_l2t
argument_list|)
expr_stmt|;
comment|/* 		 *  Unhook 		 */
name|toep
operator|->
name|tp_tp
operator|->
name|t_toe
operator|=
name|NULL
expr_stmt|;
name|toep
operator|->
name|tp_tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_TOE
expr_stmt|;
name|toep
operator|->
name|tp_tp
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * XXX need to call syncache_chkrst - but we don't 		 * have a way of doing that yet 		 */
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"abort for unestablished connection :-(\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|toep
operator|->
name|tp_tp
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"disconnected toepcb\n"
argument_list|)
expr_stmt|;
comment|/* should be freed momentarily */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|toepcb_hold
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|process_abort_req
argument_list|(
name|toep
argument_list|,
name|m
argument_list|,
name|toep
operator|->
name|tp_toedev
argument_list|)
expr_stmt|;
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|void
name|pass_open_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|child
parameter_list|,
name|struct
name|socket
modifier|*
name|parent
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|toedev
modifier|*
name|tdev
init|=
name|TOE_DEV
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|do_abort_syn_rcv
argument_list|(
name|child
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdev
operator|->
name|tod_ttid
operator|==
name|TOE_ID_CHELSIO_T3
condition|)
block|{
name|struct
name|cpl_pass_accept_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|rpl
operator|->
name|opt0h
operator|=
name|htonl
argument_list|(
name|F_TCAM_BYPASS
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|opt0l_status
operator|=
name|htonl
argument_list|(
name|CPL_PASS_OPEN_REJECT
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|TOM_DATA
argument_list|(
name|tdev
argument_list|)
operator|->
name|cdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|handle_pass_open_arp_failure
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|CXGB_UNIMPLEMENTED
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|struct
name|t3cdev
modifier|*
name|cdev
decl_stmt|;
name|struct
name|socket
modifier|*
name|parent
decl_stmt|;
name|struct
name|socket
modifier|*
name|oreq
decl_stmt|;
name|struct
name|t3c_tid_entry
modifier|*
name|t3c_stid
decl_stmt|;
name|struct
name|tid_info
modifier|*
name|t
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|otp
decl_stmt|,
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
comment|/* 	 * If the connection is being aborted due to the parent listening 	 * socket going away there's nothing to do, the ABORT_REQ will close 	 * the connection. 	 */
if|if
condition|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_RPL_PENDING
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|oreq
operator|=
name|so
operator|->
name|so_incomp
expr_stmt|;
name|otp
operator|=
name|so_sototcpcb
argument_list|(
name|oreq
argument_list|)
expr_stmt|;
name|cdev
operator|=
name|T3C_DEV
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|t
operator|=
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|cdev
argument_list|)
operator|)
operator|->
name|tid_maps
expr_stmt|;
name|t3c_stid
operator|=
name|lookup_stid
argument_list|(
name|t
argument_list|,
name|otp
operator|->
name|ts_recent
argument_list|)
expr_stmt|;
name|parent
operator|=
operator|(
operator|(
expr|struct
name|listen_ctx
operator|*
operator|)
name|t3c_stid
operator|->
name|ctx
operator|)
operator|->
name|lso
expr_stmt|;
name|so_lock
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|pass_open_abort
argument_list|(
name|so
argument_list|,
name|parent
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|so_unlock
argument_list|(
name|parent
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Handle an ARP failure for a CPL_PASS_ACCEPT_RPL.  This is treated similarly  * to an ABORT_REQ_RSS in SYN_RECV as both events need to tear down a SYN_RECV  * connection.  */
end_comment

begin_function
specifier|static
name|void
name|pass_accept_rpl_arp_failure
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
name|TCP_INC_STATS_BH
argument_list|(
name|TCP_MIB_ATTEMPTFAILS
argument_list|)
expr_stmt|;
name|BLOG_SKB_CB
argument_list|(
name|skb
argument_list|)
operator|->
name|dev
operator|=
name|TOE_DEV
argument_list|(
name|skb
operator|->
name|sk
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|handle_pass_open_arp_failure
argument_list|(
name|m_get_socket
argument_list|(
name|m
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Populate a reject CPL_PASS_ACCEPT_RPL WR.  */
end_comment

begin_function
specifier|static
name|void
name|mk_pass_accept_rpl
parameter_list|(
name|struct
name|mbuf
modifier|*
name|reply_mbuf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|req_mbuf
parameter_list|)
block|{
name|struct
name|cpl_pass_accept_req
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|req_mbuf
argument_list|)
decl_stmt|;
name|struct
name|cpl_pass_accept_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|reply_mbuf
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|m_set_priority
argument_list|(
name|reply_mbuf
argument_list|,
name|CPL_PRIORITY_SETUP
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|rpl
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_PASS_ACCEPT_RPL
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|peer_ip
operator|=
name|req
operator|->
name|peer_ip
expr_stmt|;
comment|// req->peer_ip not overwritten yet
name|rpl
operator|->
name|opt0h
operator|=
name|htonl
argument_list|(
name|F_TCAM_BYPASS
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|opt0l_status
operator|=
name|htonl
argument_list|(
name|CPL_PASS_OPEN_REJECT
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|opt2
operator|=
literal|0
expr_stmt|;
name|rpl
operator|->
name|rsvd
operator|=
name|rpl
operator|->
name|opt2
expr_stmt|;
comment|/* workaround for HW bug */
block|}
end_function

begin_comment
comment|/*  * Send a deferred reject to an accept request.  */
end_comment

begin_function
specifier|static
name|void
name|reject_pass_request
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|reply_mbuf
decl_stmt|;
name|reply_mbuf
operator|=
name|m_gethdr_nofail
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_pass_accept_rpl
argument_list|)
argument_list|)
expr_stmt|;
name|mk_pass_accept_rpl
argument_list|(
name|reply_mbuf
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|TOM_DATA
argument_list|(
name|tdev
argument_list|)
operator|->
name|cdev
argument_list|,
name|reply_mbuf
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_syncache_event
parameter_list|(
name|int
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|arg
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|TOE_SC_ENTRY_PRESENT
case|:
comment|/* 		 * entry already exists - free toepcb 		 * and l2t 		 */
name|printf
argument_list|(
literal|"syncache entry present\n"
argument_list|)
expr_stmt|;
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOE_SC_DROP
case|:
comment|/* 		 * The syncache has given up on this entry 		 * either it timed out, or it was evicted 		 * we need to explicitly release the tid 		 */
name|printf
argument_list|(
literal|"syncache entry dropped\n"
argument_list|)
expr_stmt|;
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unknown syncache event %d\n"
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|syncache_add_accept_req
parameter_list|(
name|struct
name|cpl_pass_accept_req
modifier|*
name|req
parameter_list|,
name|struct
name|socket
modifier|*
name|lso
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|in_conninfo
name|inc
decl_stmt|;
name|struct
name|tcpopt
name|to
decl_stmt|;
name|struct
name|tcphdr
name|th
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|mss
decl_stmt|,
name|wsf
decl_stmt|,
name|sack
decl_stmt|,
name|ts
decl_stmt|;
name|uint32_t
name|rcv_isn
init|=
name|ntohl
argument_list|(
name|req
operator|->
name|rcv_isn
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|to
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcpopt
argument_list|)
argument_list|)
expr_stmt|;
name|inp
operator|=
name|so_sotoinpcb
argument_list|(
name|lso
argument_list|)
expr_stmt|;
comment|/* 	 * Fill out information for entering us into the syncache 	 */
name|inc
operator|.
name|inc_fport
operator|=
name|th
operator|.
name|th_sport
operator|=
name|req
operator|->
name|peer_port
expr_stmt|;
name|inc
operator|.
name|inc_lport
operator|=
name|th
operator|.
name|th_dport
operator|=
name|req
operator|->
name|local_port
expr_stmt|;
name|th
operator|.
name|th_seq
operator|=
name|req
operator|->
name|rcv_isn
expr_stmt|;
name|th
operator|.
name|th_flags
operator|=
name|TH_SYN
expr_stmt|;
name|toep
operator|->
name|tp_iss
operator|=
name|toep
operator|->
name|tp_delack_seq
operator|=
name|toep
operator|->
name|tp_rcv_wup
operator|=
name|toep
operator|->
name|tp_copied_seq
operator|=
name|rcv_isn
operator|+
literal|1
expr_stmt|;
name|inc
operator|.
name|inc_isipv6
operator|=
literal|0
expr_stmt|;
name|inc
operator|.
name|inc_len
operator|=
literal|0
expr_stmt|;
name|inc
operator|.
name|inc_faddr
operator|.
name|s_addr
operator|=
name|req
operator|->
name|peer_ip
expr_stmt|;
name|inc
operator|.
name|inc_laddr
operator|.
name|s_addr
operator|=
name|req
operator|->
name|local_ip
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"syncache add of %d:%d %d:%d\n"
argument_list|,
name|ntohl
argument_list|(
name|req
operator|->
name|local_ip
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|req
operator|->
name|local_port
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|req
operator|->
name|peer_ip
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|req
operator|->
name|peer_port
argument_list|)
argument_list|)
expr_stmt|;
name|mss
operator|=
name|req
operator|->
name|tcp_options
operator|.
name|mss
expr_stmt|;
name|wsf
operator|=
name|req
operator|->
name|tcp_options
operator|.
name|wsf
expr_stmt|;
name|ts
operator|=
name|req
operator|->
name|tcp_options
operator|.
name|tstamp
expr_stmt|;
name|sack
operator|=
name|req
operator|->
name|tcp_options
operator|.
name|sack
expr_stmt|;
name|to
operator|.
name|to_mss
operator|=
name|mss
expr_stmt|;
name|to
operator|.
name|to_wscale
operator|=
name|wsf
expr_stmt|;
name|to
operator|.
name|to_flags
operator|=
operator|(
name|mss
condition|?
name|TOF_MSS
else|:
literal|0
operator|)
operator||
operator|(
name|wsf
condition|?
name|TOF_SCALE
else|:
literal|0
operator|)
operator||
operator|(
name|ts
condition|?
name|TOF_TS
else|:
literal|0
operator|)
operator||
operator|(
name|sack
condition|?
name|TOF_SACKPERM
else|:
literal|0
operator|)
expr_stmt|;
name|syncache_offload_add
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|to
argument_list|,
operator|&
name|th
argument_list|,
name|inp
argument_list|,
operator|&
name|lso
argument_list|,
operator|&
name|cxgb_toe_usrreqs
argument_list|,
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a CPL_PASS_ACCEPT_REQ message.  Does the part that needs the socket  * lock held.  Note that the sock here is a listening socket that is not owned  * by the TOE.  */
end_comment

begin_function
specifier|static
name|void
name|process_pass_accept_req
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|int
name|rt_flags
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|iff_mac
name|tim
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|reply_mbuf
decl_stmt|,
modifier|*
name|ddp_mbuf
init|=
name|NULL
decl_stmt|;
name|struct
name|cpl_pass_accept_rpl
modifier|*
name|rpl
decl_stmt|;
name|struct
name|cpl_pass_accept_req
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|d
init|=
name|TOM_DATA
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
name|struct
name|t3cdev
modifier|*
name|cdev
init|=
name|d
operator|->
name|cdev
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|newtoep
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|dst
decl_stmt|;
name|struct
name|sockaddr_in
name|nam
decl_stmt|;
name|struct
name|t3c_data
modifier|*
name|td
init|=
name|T3C_DATA
argument_list|(
name|cdev
argument_list|)
decl_stmt|;
name|reply_mbuf
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|reply_mbuf
operator|==
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|tdev
operator|->
name|tod_ttid
operator|==
name|TOE_ID_CHELSIO_T3
condition|)
name|t3_defer_reply
argument_list|(
name|m
argument_list|,
name|tdev
argument_list|,
name|reject_pass_request
argument_list|)
expr_stmt|;
else|else
block|{
name|cxgb_queue_tid_release
argument_list|(
name|cdev
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"failed to get reply_mbuf\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|!=
name|TCPS_LISTEN
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"socket not in listen state\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
name|tim
operator|.
name|mac_addr
operator|=
name|req
operator|->
name|dst_mac
expr_stmt|;
name|tim
operator|.
name|vlan_tag
operator|=
name|ntohs
argument_list|(
name|req
operator|->
name|vlan_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdev
operator|->
name|ctl
argument_list|(
name|cdev
argument_list|,
name|GET_IFF_FROM_MAC
argument_list|,
operator|&
name|tim
argument_list|)
operator|<
literal|0
operator|||
operator|!
name|tim
operator|.
name|dev
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"rejecting from failed GET_IFF_FROM_MAC\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * XXX do route lookup to confirm that we're still listening on this 	 * address 	 */
if|if
condition|(
name|ip_route_input
argument_list|(
name|skb
argument_list|,
name|req
operator|->
name|local_ip
argument_list|,
name|req
operator|->
name|peer_ip
argument_list|,
name|G_PASS_OPEN_TOS
argument_list|(
name|ntohl
argument_list|(
name|req
operator|->
name|tos_tid
argument_list|)
argument_list|)
argument_list|,
name|tim
operator|.
name|dev
argument_list|)
condition|)
goto|goto
name|reject
goto|;
name|rt_flags
operator|=
operator|(
operator|(
expr|struct
name|rtable
operator|*
operator|)
name|skb
operator|->
name|dst
operator|)
operator|->
name|rt_flags
operator|&
operator|(
name|RTCF_BROADCAST
operator||
name|RTCF_MULTICAST
operator||
name|RTCF_LOCAL
operator|)
expr_stmt|;
name|dst_release
argument_list|(
name|skb
operator|->
name|dst
argument_list|)
expr_stmt|;
comment|// done with the input route, release it
name|skb
operator|->
name|dst
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|rt_flags
operator|&
name|RTF_LOCAL
operator|)
operator|==
literal|0
condition|)
goto|goto
name|reject
goto|;
endif|#
directive|endif
comment|/* 	 * XXX 	 */
name|rt_flags
operator|=
name|RTF_LOCAL
expr_stmt|;
if|if
condition|(
operator|(
name|rt_flags
operator|&
name|RTF_LOCAL
operator|)
operator|==
literal|0
condition|)
goto|goto
name|reject
goto|;
comment|/* 	 * Calculate values and add to syncache 	 */
name|newtoep
operator|=
name|toepcb_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|newtoep
operator|==
name|NULL
condition|)
goto|goto
name|reject
goto|;
name|bzero
argument_list|(
operator|&
name|nam
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|nam
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|nam
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|nam
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|req
operator|->
name|peer_ip
expr_stmt|;
name|dst
operator|=
name|rtalloc2
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nam
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"failed to find route\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
name|e
operator|=
name|newtoep
operator|->
name|tp_l2t
operator|=
name|t3_l2t_get
argument_list|(
name|d
operator|->
name|cdev
argument_list|,
name|dst
argument_list|,
name|tim
operator|.
name|dev
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"failed to get l2t\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Point to our listen socket until accept 	 */
name|newtoep
operator|->
name|tp_tp
operator|=
name|tp
expr_stmt|;
name|newtoep
operator|->
name|tp_flags
operator|=
name|TP_SYN_RCVD
expr_stmt|;
name|newtoep
operator|->
name|tp_tid
operator|=
name|tid
expr_stmt|;
name|newtoep
operator|->
name|tp_toedev
operator|=
name|tdev
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|=
name|select_rcv_wnd
argument_list|(
name|tdev
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|cxgb_insert_tid
argument_list|(
name|cdev
argument_list|,
name|d
operator|->
name|client
argument_list|,
name|newtoep
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|so_lock
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lctx
operator|->
name|synq_head
argument_list|,
name|newtoep
argument_list|,
name|synq_entry
argument_list|)
expr_stmt|;
name|so_unlock
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|newtoep
operator|->
name|tp_ulp_mode
operator|=
name|TOM_TUNABLE
argument_list|(
name|tdev
argument_list|,
name|ddp
argument_list|)
operator|&&
operator|!
operator|(
name|so_options_get
argument_list|(
name|so
argument_list|)
operator|&
name|SO_NO_DDP
operator|)
operator|&&
name|tp
operator|->
name|rcv_wnd
operator|>=
name|MIN_DDP_RCV_WIN
condition|?
name|ULP_MODE_TCPDDP
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|newtoep
operator|->
name|tp_ulp_mode
condition|)
block|{
name|ddp_mbuf
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddp_mbuf
operator|==
name|NULL
condition|)
name|newtoep
operator|->
name|tp_ulp_mode
operator|=
literal|0
expr_stmt|;
block|}
name|CTR4
argument_list|(
name|KTR_TOM
argument_list|,
literal|"ddp=%d rcv_wnd=%ld min_win=%d ulp_mode=%d"
argument_list|,
name|TOM_TUNABLE
argument_list|(
name|tdev
argument_list|,
name|ddp
argument_list|)
argument_list|,
name|tp
operator|->
name|rcv_wnd
argument_list|,
name|MIN_DDP_RCV_WIN
argument_list|,
name|newtoep
operator|->
name|tp_ulp_mode
argument_list|)
expr_stmt|;
name|set_arp_failure_handler
argument_list|(
name|reply_mbuf
argument_list|,
name|pass_accept_rpl_arp_failure
argument_list|)
expr_stmt|;
comment|/* 	 * XXX workaround for lack of syncache drop 	 */
name|toepcb_hold
argument_list|(
name|newtoep
argument_list|)
expr_stmt|;
name|syncache_add_accept_req
argument_list|(
name|req
argument_list|,
name|so
argument_list|,
name|newtoep
argument_list|)
expr_stmt|;
name|rpl
operator|=
name|cplhdr
argument_list|(
name|reply_mbuf
argument_list|)
expr_stmt|;
name|reply_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|reply_mbuf
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rpl
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|wr
operator|.
name|wr_lo
operator|=
literal|0
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|rpl
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_PASS_ACCEPT_RPL
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|opt2
operator|=
name|htonl
argument_list|(
name|calc_opt2
argument_list|(
name|so
argument_list|,
name|tdev
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|rsvd
operator|=
name|rpl
operator|->
name|opt2
expr_stmt|;
comment|/* workaround for HW bug */
name|rpl
operator|->
name|peer_ip
operator|=
name|req
operator|->
name|peer_ip
expr_stmt|;
comment|// req->peer_ip is not overwritten
name|rpl
operator|->
name|opt0h
operator|=
name|htonl
argument_list|(
name|calc_opt0h
argument_list|(
name|so
argument_list|,
name|select_mss
argument_list|(
name|td
argument_list|,
name|NULL
argument_list|,
name|dst
operator|->
name|rt_ifp
operator|->
name|if_mtu
argument_list|)
argument_list|)
operator||
name|V_L2T_IDX
argument_list|(
name|e
operator|->
name|idx
argument_list|)
operator||
name|V_TX_CHANNEL
argument_list|(
name|e
operator|->
name|smt_idx
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|opt0l_status
operator|=
name|htonl
argument_list|(
name|calc_opt0l
argument_list|(
name|so
argument_list|,
name|newtoep
operator|->
name|tp_ulp_mode
argument_list|)
operator||
name|CPL_PASS_OPEN_ACCEPT
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"opt0l_status=%08x\n"
argument_list|,
name|rpl
operator|->
name|opt0l_status
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|reply_mbuf
argument_list|,
name|mkprio
argument_list|(
name|CPL_PRIORITY_SETUP
argument_list|,
name|newtoep
argument_list|)
argument_list|)
expr_stmt|;
name|l2t_send
argument_list|(
name|cdev
argument_list|,
name|reply_mbuf
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtoep
operator|->
name|tp_ulp_mode
condition|)
block|{
name|__set_tcb_field
argument_list|(
name|newtoep
argument_list|,
name|ddp_mbuf
argument_list|,
name|W_TCB_RX_DDP_FLAGS
argument_list|,
name|V_TF_DDP_OFF
argument_list|(
literal|1
argument_list|)
operator||
name|TP_DDP_TIMER_WORKAROUND_MASK
argument_list|,
name|V_TF_DDP_OFF
argument_list|(
literal|1
argument_list|)
operator||
name|TP_DDP_TIMER_WORKAROUND_VAL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"not offloading\n"
argument_list|)
expr_stmt|;
return|return;
name|reject
label|:
if|if
condition|(
name|tdev
operator|->
name|tod_ttid
operator|==
name|TOE_ID_CHELSIO_T3
condition|)
name|mk_pass_accept_rpl
argument_list|(
name|reply_mbuf
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
name|mk_tid_release
argument_list|(
name|reply_mbuf
argument_list|,
name|newtoep
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|cdev
argument_list|,
name|reply_mbuf
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|out
label|:
if|#
directive|if
literal|0
block|TCP_INC_STATS_BH(TCP_MIB_ATTEMPTFAILS);
else|#
directive|else
return|return;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Handle a CPL_PASS_ACCEPT_REQ message.  */
end_comment

begin_function
specifier|static
name|int
name|do_pass_accept_req
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|listen_ctx
modifier|*
name|listen_ctx
init|=
operator|(
expr|struct
name|listen_ctx
operator|*
operator|)
name|ctx
decl_stmt|;
name|struct
name|socket
modifier|*
name|lso
init|=
name|listen_ctx
operator|->
name|lso
decl_stmt|;
comment|/* XXX need an interlock against the listen socket going away */
name|struct
name|tom_data
modifier|*
name|d
init|=
name|listen_ctx
operator|->
name|tom_data
decl_stmt|;
if|#
directive|if
name|VALIDATE_TID
name|struct
name|cpl_pass_accept_req
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|T3C_DATA
argument_list|(
name|cdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|lsk
argument_list|)
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"%s: PASS_ACCEPT_REQ had unknown STID %lu\n"
argument_list|,
name|cdev
operator|->
name|name
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
expr|union
name|listen_entry
operator|*
operator|)
name|ctx
operator|-
name|t
operator|->
name|stid_tab
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|tid
operator|>=
name|t
operator|->
name|ntids
argument_list|)
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"%s: passive open TID %u too large\n"
argument_list|,
name|cdev
operator|->
name|name
argument_list|,
name|tid
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
return|;
block|}
comment|/* 	 * For T3A the current user of the TID may have closed but its last 	 * message(s) may have been backlogged so the TID appears to be still 	 * in use.  Just take the TID away, the connection can close at its 	 * own leisure.  For T3B this situation is a bug. 	 */
if|if
condition|(
operator|!
name|valid_new_tid
argument_list|(
name|t
argument_list|,
name|tid
argument_list|)
operator|&&
name|cdev
operator|->
name|type
operator|!=
name|T3A
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"%s: passive open uses existing TID %u\n"
argument_list|,
name|cdev
operator|->
name|name
argument_list|,
name|tid
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
return|;
block|}
endif|#
directive|endif
name|process_pass_accept_req
argument_list|(
name|lso
argument_list|,
name|m
argument_list|,
operator|&
name|d
operator|->
name|tdev
argument_list|,
name|listen_ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when a connection is established to translate the TCP options  * reported by HW to FreeBSD's native format.  */
end_comment

begin_function
specifier|static
name|void
name|assign_rxopt
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|unsigned
name|int
name|opt
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
specifier|const
name|struct
name|t3c_data
modifier|*
name|td
init|=
name|T3C_DATA
argument_list|(
name|TOEP_T3C_DEV
argument_list|(
name|toep
argument_list|)
argument_list|)
decl_stmt|;
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_mss_clamp
operator|=
name|td
operator|->
name|mtus
index|[
name|G_TCPOPT_MSS
argument_list|(
name|opt
argument_list|)
index|]
operator|-
literal|40
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|G_TCPOPT_TSTAMP
argument_list|(
name|opt
argument_list|)
condition|?
name|TF_RCVD_TSTMP
else|:
literal|0
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|G_TCPOPT_SACK
argument_list|(
name|opt
argument_list|)
condition|?
name|TF_SACK_PERMIT
else|:
literal|0
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|G_TCPOPT_WSCALE_OK
argument_list|(
name|opt
argument_list|)
condition|?
name|TF_RCVD_SCALE
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
operator|)
operator|==
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
condition|)
name|tp
operator|->
name|rcv_scale
operator|=
name|tp
operator|->
name|request_r_scale
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Completes some final bits of initialization for just established connections  * and changes their state to TCP_ESTABLISHED.  *  * snd_isn here is the ISN after the SYN, i.e., the true ISN + 1.  */
end_comment

begin_function
specifier|static
name|void
name|make_established
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|u32
name|snd_isn
parameter_list|,
name|unsigned
name|int
name|opt
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|toep
operator|->
name|tp_write_seq
operator|=
name|tp
operator|->
name|iss
operator|=
name|tp
operator|->
name|snd_max
operator|=
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|snd_una
operator|=
name|snd_isn
expr_stmt|;
name|assign_rxopt
argument_list|(
name|so
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 *XXXXXXXXXXX 	 *  	 */
ifdef|#
directive|ifdef
name|notyet
name|so
operator|->
name|so_proto
operator|->
name|pr_ctloutput
operator|=
name|t3_ctloutput
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|inet_sk(sk)->id = tp->write_seq ^ jiffies;
endif|#
directive|endif
comment|/* 	 * XXX not clear what rcv_wup maps to 	 */
comment|/* 	 * Causes the first RX_DATA_ACK to supply any Rx credits we couldn't 	 * pass through opt0. 	 */
if|if
condition|(
name|tp
operator|->
name|rcv_wnd
operator|>
operator|(
name|M_RCV_BUFSIZ
operator|<<
literal|10
operator|)
condition|)
name|toep
operator|->
name|tp_rcv_wup
operator|-=
name|tp
operator|->
name|rcv_wnd
operator|-
operator|(
name|M_RCV_BUFSIZ
operator|<<
literal|10
operator|)
expr_stmt|;
name|dump_toepcb
argument_list|(
name|toep
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/*  * no clean interface for marking ARP up to date  */
name|dst_confirm
argument_list|(
name|sk
operator|->
name|sk_dst_cache
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp
operator|->
name|t_starttime
operator|=
name|ticks
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|syncache_expand_establish_req
parameter_list|(
name|struct
name|cpl_pass_establish
modifier|*
name|req
parameter_list|,
name|struct
name|socket
modifier|*
modifier|*
name|so
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|in_conninfo
name|inc
decl_stmt|;
name|struct
name|tcpopt
name|to
decl_stmt|;
name|struct
name|tcphdr
name|th
decl_stmt|;
name|int
name|mss
decl_stmt|,
name|wsf
decl_stmt|,
name|sack
decl_stmt|,
name|ts
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|t3c_data
modifier|*
name|td
init|=
name|T3C_DATA
argument_list|(
name|TOM_DATA
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|)
operator|->
name|cdev
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|opt
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
error|#
directive|error
literal|"no MAC support"
endif|#
directive|endif
name|opt
operator|=
name|ntohs
argument_list|(
name|req
operator|->
name|tcp_opt
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|to
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcpopt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Fill out information for entering us into the syncache 	 */
name|inc
operator|.
name|inc_fport
operator|=
name|th
operator|.
name|th_sport
operator|=
name|req
operator|->
name|peer_port
expr_stmt|;
name|inc
operator|.
name|inc_lport
operator|=
name|th
operator|.
name|th_dport
operator|=
name|req
operator|->
name|local_port
expr_stmt|;
name|th
operator|.
name|th_seq
operator|=
name|req
operator|->
name|rcv_isn
expr_stmt|;
name|th
operator|.
name|th_flags
operator|=
name|TH_ACK
expr_stmt|;
name|inc
operator|.
name|inc_isipv6
operator|=
literal|0
expr_stmt|;
name|inc
operator|.
name|inc_len
operator|=
literal|0
expr_stmt|;
name|inc
operator|.
name|inc_faddr
operator|.
name|s_addr
operator|=
name|req
operator|->
name|peer_ip
expr_stmt|;
name|inc
operator|.
name|inc_laddr
operator|.
name|s_addr
operator|=
name|req
operator|->
name|local_ip
expr_stmt|;
name|mss
operator|=
name|td
operator|->
name|mtus
index|[
name|G_TCPOPT_MSS
argument_list|(
name|opt
argument_list|)
index|]
operator|-
literal|40
expr_stmt|;
name|wsf
operator|=
name|G_TCPOPT_WSCALE_OK
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|ts
operator|=
name|G_TCPOPT_TSTAMP
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|sack
operator|=
name|G_TCPOPT_SACK
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|to
operator|.
name|to_mss
operator|=
name|mss
expr_stmt|;
name|to
operator|.
name|to_wscale
operator|=
name|G_TCPOPT_SND_WSCALE
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|to
operator|.
name|to_flags
operator|=
operator|(
name|mss
condition|?
name|TOF_MSS
else|:
literal|0
operator|)
operator||
operator|(
name|wsf
condition|?
name|TOF_SCALE
else|:
literal|0
operator|)
operator||
operator|(
name|ts
condition|?
name|TOF_TS
else|:
literal|0
operator|)
operator||
operator|(
name|sack
condition|?
name|TOF_SACKPERM
else|:
literal|0
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"syncache expand of %d:%d %d:%d mss:%d wsf:%d ts:%d sack:%d\n"
argument_list|,
name|ntohl
argument_list|(
name|req
operator|->
name|local_ip
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|req
operator|->
name|local_port
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|req
operator|->
name|peer_ip
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|req
operator|->
name|peer_port
argument_list|)
argument_list|,
name|mss
argument_list|,
name|wsf
argument_list|,
name|ts
argument_list|,
name|sack
argument_list|)
expr_stmt|;
return|return
name|syncache_offload_expand
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|to
argument_list|,
operator|&
name|th
argument_list|,
name|so
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a CPL_PASS_ESTABLISH message.  XXX a lot of the locking doesn't work  * if we are in TCP_SYN_RECV due to crossed SYNs  */
end_comment

begin_function
specifier|static
name|int
name|do_pass_establish
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|cpl_pass_establish
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
operator|(
expr|struct
name|toepcb
operator|*
operator|)
name|ctx
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|,
modifier|*
name|lso
decl_stmt|;
name|struct
name|t3c_data
modifier|*
name|td
init|=
name|T3C_DATA
argument_list|(
name|cdev
argument_list|)
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|snd
decl_stmt|,
modifier|*
name|rcv
decl_stmt|;
comment|// Complete socket initialization now that we have the SND_ISN
name|struct
name|toedev
modifier|*
name|tdev
decl_stmt|;
name|tdev
operator|=
name|toep
operator|->
name|tp_toedev
expr_stmt|;
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
comment|/* 	 * 	 * XXX need to add reference while we're manipulating 	 */
name|so
operator|=
name|lso
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|so_lock
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|toep
argument_list|,
name|synq_entry
argument_list|)
expr_stmt|;
name|so_unlock
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|syncache_expand_establish_req
argument_list|(
name|req
argument_list|,
operator|&
name|so
argument_list|,
name|toep
argument_list|)
condition|)
block|{
comment|/* 		 * No entry  		 */
name|CXGB_UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Couldn't create the socket 		 */
name|CXGB_UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
name|tp
operator|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|snd
operator|=
name|so_sockbuf_snd
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|rcv
operator|=
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|snd
operator|->
name|sb_flags
operator||=
name|SB_NOCOALESCE
expr_stmt|;
name|rcv
operator|->
name|sb_flags
operator||=
name|SB_NOCOALESCE
expr_stmt|;
name|toep
operator|->
name|tp_tp
operator|=
name|tp
expr_stmt|;
name|toep
operator|->
name|tp_flags
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_toe
operator|=
name|toep
expr_stmt|;
name|reset_wr_list
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|=
name|select_rcv_wnd
argument_list|(
name|tdev
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|=
name|toep
operator|->
name|tp_copied_seq
expr_stmt|;
name|install_offload_ops
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_wr_max
operator|=
name|toep
operator|->
name|tp_wr_avail
operator|=
name|TOM_TUNABLE
argument_list|(
name|tdev
argument_list|,
name|max_wrs
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_wr_unacked
operator|=
literal|0
expr_stmt|;
name|toep
operator|->
name|tp_qset
operator|=
name|G_QNUM
argument_list|(
name|ntohl
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
argument_list|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_qset_idx
operator|=
literal|0
expr_stmt|;
name|toep
operator|->
name|tp_mtu_idx
operator|=
name|select_mss
argument_list|(
name|td
argument_list|,
name|tp
argument_list|,
name|toep
operator|->
name|tp_l2t
operator|->
name|neigh
operator|->
name|rt_ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Cancel any keep alive timer 	 */
name|make_established
argument_list|(
name|so
argument_list|,
name|ntohl
argument_list|(
name|req
operator|->
name|snd_isn
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|req
operator|->
name|tcp_opt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX workaround for lack of syncache drop 	 */
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_TOM
argument_list|,
literal|"do_pass_establish tid=%u"
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
expr_stmt|;
name|cxgb_log_tcb
argument_list|(
name|cdev
operator|->
name|adapter
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * XXX not sure how these checks map to us 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|sk
operator|->
name|sk_socket
argument_list|)
condition|)
block|{
comment|// simultaneous opens only
name|sk
operator|->
name|sk_state_change
argument_list|(
name|sk
argument_list|)
expr_stmt|;
name|sk_wake_async
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|POLL_OUT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The state for the new connection is now up to date. 	 * Next check if we should add the connection to the parent's 	 * accept queue.  When the parent closes it resets connections 	 * on its SYN queue, so check if we are being reset.  If so we 	 * don't need to do anything more, the coming ABORT_RPL will 	 * destroy this socket.  Otherwise move the connection to the 	 * accept queue. 	 * 	 * Note that we reset the synq before closing the server so if 	 * we are not being reset the stid is still open. 	 */
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|tp
operator|->
name|forward_skb_hint
argument_list|)
condition|)
block|{
comment|// removed from synq
name|__kfree_skb
argument_list|(
name|skb
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
endif|#
directive|endif
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in the right TID for CPL messages waiting in the out-of-order queue  * and send them to the TOE.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_and_send_ofo
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tdev
init|=
name|toep
operator|->
name|tp_toedev
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|toep
operator|->
name|tp_tid
decl_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"fixup_and_send_ofo\n"
argument_list|)
expr_stmt|;
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|toep
operator|->
name|out_of_order_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * A variety of messages can be waiting but the fields we'll 		 * be touching are common to all so any message type will do. 		 */
name|struct
name|cpl_close_con_req
modifier|*
name|p
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|p
operator|->
name|wr
operator|.
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|p
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|p
operator|->
name|ot
operator|.
name|opcode
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|TOM_DATA
argument_list|(
name|tdev
argument_list|)
operator|->
name|cdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Updates socket state from an active establish CPL message.  Runs with the  * socket lock held.  */
end_comment

begin_function
specifier|static
name|void
name|socket_act_establish
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_act_establish
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|u32
name|rcv_isn
init|=
name|ntohl
argument_list|(
name|req
operator|->
name|rcv_isn
argument_list|)
decl_stmt|;
comment|/* real RCV_ISN + 1 */
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|tp
operator|->
name|t_state
operator|!=
name|TCPS_SYN_SENT
argument_list|)
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TID %u expected SYN_SENT, found %d\n"
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ts_recent_age
operator|=
name|ticks
expr_stmt|;
name|tp
operator|->
name|irs
operator|=
name|tp
operator|->
name|rcv_wnd
operator|=
name|tp
operator|->
name|rcv_nxt
operator|=
name|rcv_isn
expr_stmt|;
name|toep
operator|->
name|tp_delack_seq
operator|=
name|toep
operator|->
name|tp_rcv_wup
operator|=
name|toep
operator|->
name|tp_copied_seq
operator|=
name|tp
operator|->
name|irs
expr_stmt|;
name|make_established
argument_list|(
name|so
argument_list|,
name|ntohl
argument_list|(
name|req
operator|->
name|snd_isn
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|req
operator|->
name|tcp_opt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we finally have a TID send any CPL messages that we had to 	 * defer for lack of a TID. 	 */
if|if
condition|(
name|mbufq_len
argument_list|(
operator|&
name|toep
operator|->
name|out_of_order_queue
argument_list|)
condition|)
name|fixup_and_send_ofo
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|so_state_get
argument_list|(
name|so
argument_list|)
operator|&
name|SS_NOFDREF
argument_list|)
condition|)
block|{
comment|/* 		 * XXX does this even make sense? 		 */
name|so_sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/*  * XXX assume no write requests permitted while socket connection is  * incomplete  */
comment|/* 	 * Currently the send queue must be empty at this point because the 	 * socket layer does not send anything before a connection is 	 * established.  To be future proof though we handle the possibility 	 * that there are pending buffers to send (either TX_DATA or 	 * CLOSE_CON_REQ).  First we need to adjust the sequence number of the 	 * buffers according to the just learned write_seq, and then we send 	 * them on their way. 	 */
name|fixup_pending_writeq_buffers
argument_list|(
name|sk
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_push_frames
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
condition|)
name|sk
operator|->
name|sk_write_space
argument_list|(
name|sk
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|toep
operator|->
name|tp_state
operator|=
name|tp
operator|->
name|t_state
expr_stmt|;
name|tcpstat
operator|.
name|tcps_connects
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a CPL_ACT_ESTABLISH message.  */
end_comment

begin_function
specifier|static
name|int
name|do_act_establish
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|cpl_act_establish
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|atid
init|=
name|G_PASS_OPEN_TID
argument_list|(
name|ntohl
argument_list|(
name|req
operator|->
name|tos_tid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
operator|(
expr|struct
name|toepcb
operator|*
operator|)
name|ctx
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tdev
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
name|free_atid
argument_list|(
name|cdev
argument_list|,
name|atid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 */
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tdev
operator|=
name|toep
operator|->
name|tp_toedev
expr_stmt|;
comment|/* blow up here if link was down */
name|d
operator|=
name|TOM_DATA
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
comment|/* 	 * It's OK if the TID is currently in use, the owning socket may have 	 * backlogged its last CPL message(s).  Just take it away. 	 */
name|toep
operator|->
name|tp_tid
operator|=
name|tid
expr_stmt|;
name|toep
operator|->
name|tp_tp
operator|=
name|tp
expr_stmt|;
name|so_insert_tid
argument_list|(
name|d
argument_list|,
name|toep
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|free_atid
argument_list|(
name|cdev
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_qset
operator|=
name|G_QNUM
argument_list|(
name|ntohl
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
argument_list|)
argument_list|)
expr_stmt|;
name|socket_act_establish
argument_list|(
name|so
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_TOM
argument_list|,
literal|"do_act_establish tid=%u"
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
expr_stmt|;
name|cxgb_log_tcb
argument_list|(
name|cdev
operator|->
name|adapter
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an acknowledgment of WR completion.  Advance snd_una and send the  * next batch of work requests from the write queue.  */
end_comment

begin_function
specifier|static
name|void
name|wr_ack
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|toep
operator|->
name|tp_tp
decl_stmt|;
name|struct
name|cpl_wr_ack
modifier|*
name|hdr
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|unsigned
name|int
name|credits
init|=
name|ntohs
argument_list|(
name|hdr
operator|->
name|credits
argument_list|)
decl_stmt|;
name|u32
name|snd_una
init|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|snd_una
argument_list|)
decl_stmt|;
name|int
name|bytes
init|=
literal|0
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|snd
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"wr_ack: snd_una=%u credits=%d"
argument_list|,
name|snd_una
argument_list|,
name|credits
argument_list|)
expr_stmt|;
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_wr_avail
operator|+=
name|credits
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_wr_unacked
operator|>
name|toep
operator|->
name|tp_wr_max
operator|-
name|toep
operator|->
name|tp_wr_avail
condition|)
name|toep
operator|->
name|tp_wr_unacked
operator|=
name|toep
operator|->
name|tp_wr_max
operator|-
name|toep
operator|->
name|tp_wr_avail
expr_stmt|;
while|while
condition|(
name|credits
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|p
init|=
name|peek_wr
argument_list|(
name|toep
argument_list|)
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|p
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%u WR_ACK credits for TID %u with "
literal|"nothing pending, state %u wr_avail=%u\n"
argument_list|,
name|credits
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|tp
operator|->
name|t_state
argument_list|,
name|toep
operator|->
name|tp_wr_avail
argument_list|)
expr_stmt|;
break|break;
block|}
name|CTR2
argument_list|(
name|KTR_TOM
argument_list|,
literal|"wr_ack: p->credits=%d p->bytes=%d"
argument_list|,
name|p
operator|->
name|m_pkthdr
operator|.
name|csum_data
argument_list|,
name|p
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|p
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|!=
literal|0
argument_list|,
operator|(
literal|"empty request still on list"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|credits
operator|<
name|p
operator|->
name|m_pkthdr
operator|.
name|csum_data
argument_list|)
condition|)
block|{
if|#
directive|if
name|DEBUG_WR
operator|>
literal|1
name|struct
name|tx_data_wr
modifier|*
name|w
init|=
name|cplhdr
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TID %u got %u WR credits, need %u, len %u, "
literal|"main body %u, frags %u, seq # %u, ACK una %u,"
literal|" ACK nxt %u, WR_AVAIL %u, WRs pending %u\n"
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|credits
argument_list|,
name|p
operator|->
name|csum
argument_list|,
name|p
operator|->
name|len
argument_list|,
name|p
operator|->
name|len
operator|-
name|p
operator|->
name|data_len
argument_list|,
name|skb_shinfo
argument_list|(
name|p
argument_list|)
operator|->
name|nr_frags
argument_list|,
name|ntohl
argument_list|(
name|w
operator|->
name|sndseq
argument_list|)
argument_list|,
name|snd_una
argument_list|,
name|ntohl
argument_list|(
name|hdr
operator|->
name|snd_nxt
argument_list|)
argument_list|,
name|toep
operator|->
name|tp_wr_avail
argument_list|,
name|count_pending_wrs
argument_list|(
name|tp
argument_list|)
operator|-
name|credits
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|-=
name|credits
expr_stmt|;
break|break;
block|}
else|else
block|{
name|dequeue_wr
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|credits
operator|-=
name|p
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
name|bytes
operator|+=
name|p
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_TOM
argument_list|,
literal|"wr_ack: done with wr of %d bytes remain credits=%d wr credits=%d"
argument_list|,
name|p
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|credits
argument_list|,
name|p
operator|->
name|m_pkthdr
operator|.
name|csum_data
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|DEBUG_WR
name|check_wr_invariants
argument_list|(
name|tp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__predict_false
argument_list|(
name|SEQ_LT
argument_list|(
name|snd_una
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|VALIDATE_SEQ
name|struct
name|tom_data
modifier|*
name|d
init|=
name|TOM_DATA
argument_list|(
name|TOE_DEV
argument_list|(
name|so
argument_list|)
argument_list|)
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
literal|"%s: unexpected sequence # %u in WR_ACK "
literal|"for TID %u, snd_una %u\n"
argument_list|,
operator|(
operator|&
name|d
operator|->
name|tdev
operator|)
operator|->
name|name
argument_list|,
name|snd_una
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|out_free
goto|;
block|}
if|if
condition|(
name|tp
operator|->
name|snd_una
operator|!=
name|snd_una
condition|)
block|{
name|tp
operator|->
name|snd_una
operator|=
name|snd_una
expr_stmt|;
name|tp
operator|->
name|ts_recent_age
operator|=
name|ticks
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 		 * Keep ARP entry "minty fresh" 		 */
name|dst_confirm
argument_list|(
name|sk
operator|->
name|sk_dst_cache
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tp
operator|->
name|snd_una
operator|==
name|tp
operator|->
name|snd_nxt
condition|)
name|toep
operator|->
name|tp_flags
operator|&=
operator|~
name|TP_TX_WAIT_IDLE
expr_stmt|;
block|}
name|snd
operator|=
name|so_sockbuf_snd
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"wr_ack: sbdrop(%d)"
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|snd
operator|=
name|so_sockbuf_snd
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sockbuf_lock
argument_list|(
name|snd
argument_list|)
expr_stmt|;
name|sbdrop_locked
argument_list|(
name|snd
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|so_sowwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|snd
operator|->
name|sb_sndptroff
operator|<
name|snd
operator|->
name|sb_cc
condition|)
name|t3_push_frames
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out_free
label|:
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handler for TX_DATA_ACK CPL messages.  */
end_comment

begin_function
specifier|static
name|int
name|do_wr_ack
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
operator|(
expr|struct
name|toepcb
operator|*
operator|)
name|ctx
decl_stmt|;
name|VALIDATE_SOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|wr_ack
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Handler for TRACE_PKT CPL messages.  Just sink these packets.  */
end_comment

begin_function
specifier|static
name|int
name|do_trace_pkt
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reset a connection that is on a listener's SYN queue or accept queue,  * i.e., one that has not had a struct socket associated with it.  * Must be called from process context.  *  * Modeled after code in inet_csk_listen_stop().  */
end_comment

begin_function
specifier|static
name|void
name|t3_reset_listen_child
parameter_list|(
name|struct
name|socket
modifier|*
name|child
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|t3_send_reset
argument_list|(
name|tp
operator|->
name|t_toe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|t3_child_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_TOE
condition|)
block|{
name|inp_wlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|t3_reset_listen_child
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Disconnect offloaded established but not yet accepted connections sitting  * on a server's accept_queue.  We just send an ABORT_REQ at this point and  * finish off the disconnect later as we may need to wait for the ABORT_RPL.  */
end_comment

begin_function
name|void
name|t3_disconnect_acceptq
parameter_list|(
name|struct
name|socket
modifier|*
name|listen_so
parameter_list|)
block|{
name|so_lock
argument_list|(
name|listen_so
argument_list|)
expr_stmt|;
name|so_listeners_apply_all
argument_list|(
name|listen_so
argument_list|,
name|t3_child_disconnect
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|so_unlock
argument_list|(
name|listen_so
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset offloaded connections sitting on a server's syn queue.  As above  * we send ABORT_REQ and finish off when we get ABORT_RPL.  */
end_comment

begin_function
name|void
name|t3_reset_synq
parameter_list|(
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
name|so_lock
argument_list|(
name|lctx
operator|->
name|lso
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|lctx
operator|->
name|synq_head
argument_list|)
condition|)
block|{
name|toep
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lctx
operator|->
name|synq_head
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|toep
argument_list|,
name|synq_entry
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_tp
operator|=
name|NULL
expr_stmt|;
name|t3_send_reset
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|cxgb_remove_tid
argument_list|(
name|TOEP_T3C_DEV
argument_list|(
name|toep
argument_list|)
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
expr_stmt|;
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
name|so_unlock
argument_list|(
name|lctx
operator|->
name|lso
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|t3_setup_ppods
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
specifier|const
name|struct
name|ddp_gather_list
modifier|*
name|gl
parameter_list|,
name|unsigned
name|int
name|nppods
parameter_list|,
name|unsigned
name|int
name|tag
parameter_list|,
name|unsigned
name|int
name|maxoff
parameter_list|,
name|unsigned
name|int
name|pg_off
parameter_list|,
name|unsigned
name|int
name|color
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|pidx
decl_stmt|;
name|struct
name|pagepod
modifier|*
name|p
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ulp_mem_io
modifier|*
name|req
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|toep
operator|->
name|tp_tid
decl_stmt|;
specifier|const
name|struct
name|tom_data
modifier|*
name|td
init|=
name|TOM_DATA
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|ppod_addr
init|=
name|tag
operator|*
name|PPOD_SIZE
operator|+
name|td
operator|->
name|ddp_llimit
decl_stmt|;
name|CTR6
argument_list|(
name|KTR_TOM
argument_list|,
literal|"t3_setup_ppods(gl=%p nppods=%u tag=%u maxoff=%u pg_off=%u color=%u)"
argument_list|,
name|gl
argument_list|,
name|nppods
argument_list|,
name|tag
argument_list|,
name|maxoff
argument_list|,
name|pg_off
argument_list|,
name|color
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nppods
condition|;
operator|++
name|i
control|)
block|{
name|m
operator|=
name|m_gethdr_nofail
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
operator|+
name|PPOD_SIZE
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|mkprio
argument_list|(
name|CPL_PRIORITY_CONTROL
argument_list|,
name|toep
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ulp_mem_io
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
operator|+
name|PPOD_SIZE
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_BYPASS
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_lo
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|cmd_lock_addr
operator|=
name|htonl
argument_list|(
name|V_ULP_MEMIO_ADDR
argument_list|(
name|ppod_addr
operator|>>
literal|5
argument_list|)
operator||
name|V_ULPTX_CMD
argument_list|(
name|ULP_MEM_WRITE
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|V_ULP_MEMIO_DATA_LEN
argument_list|(
name|PPOD_SIZE
operator|/
literal|32
argument_list|)
operator||
name|V_ULPTX_NFLITS
argument_list|(
name|PPOD_SIZE
operator|/
literal|8
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|pagepod
operator|*
operator|)
operator|(
name|req
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|i
operator|<
name|nppods
operator|-
name|NUM_SENTINEL_PPODS
argument_list|)
condition|)
block|{
name|p
operator|->
name|pp_vld_tid
operator|=
name|htonl
argument_list|(
name|F_PPOD_VALID
operator||
name|V_PPOD_TID
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|pp_pgsz_tag_color
operator|=
name|htonl
argument_list|(
name|V_PPOD_TAG
argument_list|(
name|tag
argument_list|)
operator||
name|V_PPOD_COLOR
argument_list|(
name|color
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|pp_max_offset
operator|=
name|htonl
argument_list|(
name|maxoff
argument_list|)
expr_stmt|;
name|p
operator|->
name|pp_page_offset
operator|=
name|htonl
argument_list|(
name|pg_off
argument_list|)
expr_stmt|;
name|p
operator|->
name|pp_rsvd
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pidx
operator|=
literal|4
operator|*
name|i
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|5
condition|;
operator|++
name|j
operator|,
operator|++
name|pidx
control|)
name|p
operator|->
name|pp_addr
index|[
name|j
index|]
operator|=
name|pidx
operator|<
name|gl
operator|->
name|dgl_nelem
condition|?
name|htobe64
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|gl
operator|->
name|dgl_pages
index|[
name|pidx
index|]
argument_list|)
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
else|else
name|p
operator|->
name|pp_vld_tid
operator|=
literal|0
expr_stmt|;
comment|/* mark sentinel page pods invalid */
name|send_or_defer
argument_list|(
name|toep
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ppod_addr
operator|+=
name|PPOD_SIZE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Build a CPL_BARRIER message as payload of a ULP_TX_PKT command.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mk_cpl_barrier_ulp
parameter_list|(
name|struct
name|cpl_barrier
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|ulp_txpkt
modifier|*
name|txpkt
init|=
operator|(
expr|struct
name|ulp_txpkt
operator|*
operator|)
name|b
decl_stmt|;
name|txpkt
operator|->
name|cmd_dest
operator|=
name|htonl
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TXPKT
argument_list|)
argument_list|)
expr_stmt|;
name|txpkt
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|V_ULPTX_NFLITS
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|opcode
operator|=
name|CPL_BARRIER
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Build a CPL_GET_TCB message as payload of a ULP_TX_PKT command.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mk_get_tcb_ulp
parameter_list|(
name|struct
name|cpl_get_tcb
modifier|*
name|req
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|,
name|unsigned
name|int
name|cpuno
parameter_list|)
block|{
name|struct
name|ulp_txpkt
modifier|*
name|txpkt
init|=
operator|(
expr|struct
name|ulp_txpkt
operator|*
operator|)
name|req
decl_stmt|;
name|txpkt
operator|=
operator|(
expr|struct
name|ulp_txpkt
operator|*
operator|)
name|req
expr_stmt|;
name|txpkt
operator|->
name|cmd_dest
operator|=
name|htonl
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TXPKT
argument_list|)
argument_list|)
expr_stmt|;
name|txpkt
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|V_ULPTX_NFLITS
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_GET_TCB
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|cpuno
operator|=
name|htons
argument_list|(
name|cpuno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Build a CPL_SET_TCB_FIELD message as payload of a ULP_TX_PKT command.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mk_set_tcb_field_ulp
parameter_list|(
name|struct
name|cpl_set_tcb_field
modifier|*
name|req
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|,
name|unsigned
name|int
name|word
parameter_list|,
name|uint64_t
name|mask
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|struct
name|ulp_txpkt
modifier|*
name|txpkt
init|=
operator|(
expr|struct
name|ulp_txpkt
operator|*
operator|)
name|req
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_TCB
argument_list|,
literal|"mk_set_tcb_field_ulp(tid=%u word=0x%x mask=%jx val=%jx"
argument_list|,
name|tid
argument_list|,
name|word
argument_list|,
name|mask
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|txpkt
operator|->
name|cmd_dest
operator|=
name|htonl
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TXPKT
argument_list|)
argument_list|)
expr_stmt|;
name|txpkt
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|V_ULPTX_NFLITS
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_SET_TCB_FIELD
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|reply
operator|=
name|V_NO_REPLY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|req
operator|->
name|cpu_idx
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|word
operator|=
name|htons
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|req
operator|->
name|mask
operator|=
name|htobe64
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|req
operator|->
name|val
operator|=
name|htobe64
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Build a CPL_RX_DATA_ACK message as payload of a ULP_TX_PKT command.  */
end_comment

begin_function
specifier|static
name|void
name|mk_rx_data_ack_ulp
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|cpl_rx_data_ack
modifier|*
name|ack
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|,
name|unsigned
name|int
name|credits
parameter_list|)
block|{
name|struct
name|ulp_txpkt
modifier|*
name|txpkt
init|=
operator|(
expr|struct
name|ulp_txpkt
operator|*
operator|)
name|ack
decl_stmt|;
name|txpkt
operator|->
name|cmd_dest
operator|=
name|htonl
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TXPKT
argument_list|)
argument_list|)
expr_stmt|;
name|txpkt
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|V_ULPTX_NFLITS
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ack
argument_list|)
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|ack
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_RX_DATA_ACK
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|ack
operator|->
name|credit_dack
operator|=
name|htonl
argument_list|(
name|F_RX_MODULATE
operator||
name|F_RX_DACK_CHANGE
operator||
name|V_RX_DACK_MODE
argument_list|(
name|TOM_TUNABLE
argument_list|(
name|toep
operator|->
name|tp_toedev
argument_list|,
name|delack
argument_list|)
argument_list|)
operator||
name|V_RX_CREDITS
argument_list|(
name|credits
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_cancel_ddpbuf
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|unsigned
name|int
name|bufidx
parameter_list|)
block|{
name|unsigned
name|int
name|wrlen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_barrier
modifier|*
name|lock
decl_stmt|;
name|struct
name|cpl_set_tcb_field
modifier|*
name|req
decl_stmt|;
name|struct
name|cpl_get_tcb
modifier|*
name|getreq
decl_stmt|;
name|struct
name|ddp_state
modifier|*
name|p
init|=
operator|&
name|toep
operator|->
name|tp_ddp_state
decl_stmt|;
if|#
directive|if
literal|0
block|SOCKBUF_LOCK_ASSERT(&toeptoso(toep)->so_rcv);
endif|#
directive|endif
name|wrlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|wr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lock
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|getreq
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_gethdr_nofail
argument_list|(
name|wrlen
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|mkprio
argument_list|(
name|CPL_PRIORITY_CONTROL
argument_list|,
name|toep
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|work_request_hdr
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|wr
argument_list|,
name|wrlen
argument_list|)
expr_stmt|;
name|wr
operator|->
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_BYPASS
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|wrlen
expr_stmt|;
name|lock
operator|=
operator|(
expr|struct
name|cpl_barrier
operator|*
operator|)
operator|(
name|wr
operator|+
literal|1
operator|)
expr_stmt|;
name|mk_cpl_barrier_ulp
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
expr|struct
name|cpl_set_tcb_field
operator|*
operator|)
operator|(
name|lock
operator|+
literal|1
operator|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_TCB
argument_list|,
literal|"t3_cancel_ddpbuf(bufidx=%u)"
argument_list|,
name|bufidx
argument_list|)
expr_stmt|;
comment|/* Hmmm, not sure if this actually a good thing: reactivating 	 * the other buffer might be an issue if it has been completed 	 * already. However, that is unlikely, since the fact that the UBUF 	 * is not completed indicates that there is no oustanding data. 	 */
if|if
condition|(
name|bufidx
operator|==
literal|0
condition|)
name|mk_set_tcb_field_ulp
argument_list|(
name|req
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|W_TCB_RX_DDP_FLAGS
argument_list|,
name|V_TF_DDP_ACTIVE_BUF
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF0_VALID
argument_list|(
literal|1
argument_list|)
argument_list|,
name|V_TF_DDP_ACTIVE_BUF
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|mk_set_tcb_field_ulp
argument_list|(
name|req
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|W_TCB_RX_DDP_FLAGS
argument_list|,
name|V_TF_DDP_ACTIVE_BUF
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF1_VALID
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|getreq
operator|=
operator|(
expr|struct
name|cpl_get_tcb
operator|*
operator|)
operator|(
name|req
operator|+
literal|1
operator|)
expr_stmt|;
name|mk_get_tcb_ulp
argument_list|(
name|getreq
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|toep
operator|->
name|tp_qset
argument_list|)
expr_stmt|;
name|mk_cpl_barrier_ulp
argument_list|(
operator|(
expr|struct
name|cpl_barrier
operator|*
operator|)
operator|(
name|getreq
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Keep track of the number of oustanding CPL_GET_TCB requests 	 */
name|p
operator|->
name|get_tcb_count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE1
argument_list|(
name|TIDTB
argument_list|(
name|so
argument_list|)
argument_list|,
literal|"t3_cancel_ddpbuf: bufidx %u"
argument_list|,
name|bufidx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cxgb_ofld_send
argument_list|(
name|TOEP_T3C_DEV
argument_list|(
name|toep
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * t3_overlay_ddpbuf - overlay an existing DDP buffer with a new one  * @sk: the socket associated with the buffers  * @bufidx: index of HW DDP buffer (0 or 1)  * @tag0: new tag for HW buffer 0  * @tag1: new tag for HW buffer 1  * @len: new length for HW buf @bufidx  *  * Sends a compound WR to overlay a new DDP buffer on top of an existing  * buffer by changing the buffer tag and length and setting the valid and  * active flag accordingly.  The caller must ensure the new buffer is at  * least as big as the existing one.  Since we typically reprogram both HW  * buffers this function sets both tags for convenience. Read the TCB to  * determine how made data was written into the buffer before the overlay  * took place.  */
end_comment

begin_function
name|void
name|t3_overlay_ddpbuf
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|unsigned
name|int
name|bufidx
parameter_list|,
name|unsigned
name|int
name|tag0
parameter_list|,
name|unsigned
name|int
name|tag1
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|wrlen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_get_tcb
modifier|*
name|getreq
decl_stmt|;
name|struct
name|cpl_set_tcb_field
modifier|*
name|req
decl_stmt|;
name|struct
name|ddp_state
modifier|*
name|p
init|=
operator|&
name|toep
operator|->
name|tp_ddp_state
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_TCB
argument_list|,
literal|"t3_setup_ppods(bufidx=%u tag0=%u tag1=%u len=%u)"
argument_list|,
name|bufidx
argument_list|,
name|tag0
argument_list|,
name|tag1
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|SOCKBUF_LOCK_ASSERT(&toeptoso(toep)->so_rcv);
endif|#
directive|endif
name|wrlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|wr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|getreq
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_gethdr_nofail
argument_list|(
name|wrlen
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|mkprio
argument_list|(
name|CPL_PRIORITY_CONTROL
argument_list|,
name|toep
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|work_request_hdr
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|wrlen
expr_stmt|;
name|bzero
argument_list|(
name|wr
argument_list|,
name|wrlen
argument_list|)
expr_stmt|;
comment|/* Set the ATOMIC flag to make sure that TP processes the following 	 * CPLs in an atomic manner and no wire segments can be interleaved. 	 */
name|wr
operator|->
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_BYPASS
argument_list|)
operator||
name|F_WR_ATOMIC
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
expr|struct
name|cpl_set_tcb_field
operator|*
operator|)
operator|(
name|wr
operator|+
literal|1
operator|)
expr_stmt|;
name|mk_set_tcb_field_ulp
argument_list|(
name|req
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|W_TCB_RX_DDP_BUF0_TAG
argument_list|,
name|V_TCB_RX_DDP_BUF0_TAG
argument_list|(
name|M_TCB_RX_DDP_BUF0_TAG
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF1_TAG
argument_list|(
name|M_TCB_RX_DDP_BUF1_TAG
argument_list|)
operator|<<
literal|32
argument_list|,
name|V_TCB_RX_DDP_BUF0_TAG
argument_list|(
name|tag0
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF1_TAG
argument_list|(
operator|(
name|uint64_t
operator|)
name|tag1
argument_list|)
operator|<<
literal|32
argument_list|)
expr_stmt|;
name|req
operator|++
expr_stmt|;
if|if
condition|(
name|bufidx
operator|==
literal|0
condition|)
block|{
name|mk_set_tcb_field_ulp
argument_list|(
name|req
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|W_TCB_RX_DDP_BUF0_LEN
argument_list|,
name|V_TCB_RX_DDP_BUF0_LEN
argument_list|(
name|M_TCB_RX_DDP_BUF0_LEN
argument_list|)
argument_list|,
name|V_TCB_RX_DDP_BUF0_LEN
argument_list|(
operator|(
name|uint64_t
operator|)
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|++
expr_stmt|;
name|mk_set_tcb_field_ulp
argument_list|(
name|req
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|W_TCB_RX_DDP_FLAGS
argument_list|,
name|V_TF_DDP_PUSH_DISABLE_0
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF0_VALID
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_ACTIVE_BUF
argument_list|(
literal|1
argument_list|)
argument_list|,
name|V_TF_DDP_PUSH_DISABLE_0
argument_list|(
literal|0
argument_list|)
operator||
name|V_TF_DDP_BUF0_VALID
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mk_set_tcb_field_ulp
argument_list|(
name|req
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|W_TCB_RX_DDP_BUF1_LEN
argument_list|,
name|V_TCB_RX_DDP_BUF1_LEN
argument_list|(
name|M_TCB_RX_DDP_BUF1_LEN
argument_list|)
argument_list|,
name|V_TCB_RX_DDP_BUF1_LEN
argument_list|(
operator|(
name|uint64_t
operator|)
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|++
expr_stmt|;
name|mk_set_tcb_field_ulp
argument_list|(
name|req
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|W_TCB_RX_DDP_FLAGS
argument_list|,
name|V_TF_DDP_PUSH_DISABLE_1
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_BUF1_VALID
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_ACTIVE_BUF
argument_list|(
literal|1
argument_list|)
argument_list|,
name|V_TF_DDP_PUSH_DISABLE_1
argument_list|(
literal|0
argument_list|)
operator||
name|V_TF_DDP_BUF1_VALID
argument_list|(
literal|1
argument_list|)
operator||
name|V_TF_DDP_ACTIVE_BUF
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|getreq
operator|=
operator|(
expr|struct
name|cpl_get_tcb
operator|*
operator|)
operator|(
name|req
operator|+
literal|1
operator|)
expr_stmt|;
name|mk_get_tcb_ulp
argument_list|(
name|getreq
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|toep
operator|->
name|tp_qset
argument_list|)
expr_stmt|;
comment|/* Keep track of the number of oustanding CPL_GET_TCB requests 	 */
name|p
operator|->
name|get_tcb_count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE4
argument_list|(
name|TIDTB
argument_list|(
name|sk
argument_list|)
argument_list|,
literal|"t3_overlay_ddpbuf: bufidx %u tag0 %u tag1 %u "
literal|"len %d"
argument_list|,
name|bufidx
argument_list|,
name|tag0
argument_list|,
name|tag1
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cxgb_ofld_send
argument_list|(
name|TOEP_T3C_DEV
argument_list|(
name|toep
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sends a compound WR containing all the CPL messages needed to program the  * two HW DDP buffers, namely optionally setting up the length and offset of  * each buffer, programming the DDP flags, and optionally sending RX_DATA_ACK.  */
end_comment

begin_function
name|void
name|t3_setup_ddpbufs
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|unsigned
name|int
name|len0
parameter_list|,
name|unsigned
name|int
name|offset0
parameter_list|,
name|unsigned
name|int
name|len1
parameter_list|,
name|unsigned
name|int
name|offset1
parameter_list|,
name|uint64_t
name|ddp_flags
parameter_list|,
name|uint64_t
name|flag_mask
parameter_list|,
name|int
name|modulate
parameter_list|)
block|{
name|unsigned
name|int
name|wrlen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_set_tcb_field
modifier|*
name|req
decl_stmt|;
name|CTR6
argument_list|(
name|KTR_TCB
argument_list|,
literal|"t3_setup_ddpbufs(len0=%u offset0=%u len1=%u offset1=%u ddp_flags=0x%08x%08x "
argument_list|,
name|len0
argument_list|,
name|offset0
argument_list|,
name|len1
argument_list|,
name|offset1
argument_list|,
name|ddp_flags
operator|>>
literal|32
argument_list|,
name|ddp_flags
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|SOCKBUF_LOCK_ASSERT(&toeptoso(toep)->so_rcv);
endif|#
directive|endif
name|wrlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|wr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
operator|+
operator|(
name|len0
condition|?
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
else|:
literal|0
operator|)
operator|+
operator|(
name|len1
condition|?
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
else|:
literal|0
operator|)
operator|+
operator|(
name|modulate
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_rx_data_ack
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|m
operator|=
name|m_gethdr_nofail
argument_list|(
name|wrlen
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|mkprio
argument_list|(
name|CPL_PRIORITY_CONTROL
argument_list|,
name|toep
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|work_request_hdr
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|wr
argument_list|,
name|wrlen
argument_list|)
expr_stmt|;
name|wr
operator|->
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_BYPASS
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|wrlen
expr_stmt|;
name|req
operator|=
operator|(
expr|struct
name|cpl_set_tcb_field
operator|*
operator|)
operator|(
name|wr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|len0
condition|)
block|{
comment|/* program buffer 0 offset and length */
name|mk_set_tcb_field_ulp
argument_list|(
name|req
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|W_TCB_RX_DDP_BUF0_OFFSET
argument_list|,
name|V_TCB_RX_DDP_BUF0_OFFSET
argument_list|(
name|M_TCB_RX_DDP_BUF0_OFFSET
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF0_LEN
argument_list|(
name|M_TCB_RX_DDP_BUF0_LEN
argument_list|)
argument_list|,
name|V_TCB_RX_DDP_BUF0_OFFSET
argument_list|(
operator|(
name|uint64_t
operator|)
name|offset0
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF0_LEN
argument_list|(
operator|(
name|uint64_t
operator|)
name|len0
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|len1
condition|)
block|{
comment|/* program buffer 1 offset and length */
name|mk_set_tcb_field_ulp
argument_list|(
name|req
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|W_TCB_RX_DDP_BUF1_OFFSET
argument_list|,
name|V_TCB_RX_DDP_BUF1_OFFSET
argument_list|(
name|M_TCB_RX_DDP_BUF1_OFFSET
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF1_LEN
argument_list|(
name|M_TCB_RX_DDP_BUF1_LEN
argument_list|)
operator|<<
literal|32
argument_list|,
name|V_TCB_RX_DDP_BUF1_OFFSET
argument_list|(
operator|(
name|uint64_t
operator|)
name|offset1
argument_list|)
operator||
name|V_TCB_RX_DDP_BUF1_LEN
argument_list|(
operator|(
name|uint64_t
operator|)
name|len1
argument_list|)
operator|<<
literal|32
argument_list|)
expr_stmt|;
name|req
operator|++
expr_stmt|;
block|}
name|mk_set_tcb_field_ulp
argument_list|(
name|req
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|W_TCB_RX_DDP_FLAGS
argument_list|,
name|flag_mask
argument_list|,
name|ddp_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|modulate
condition|)
block|{
name|mk_rx_data_ack_ulp
argument_list|(
name|toep
argument_list|,
operator|(
expr|struct
name|cpl_rx_data_ack
operator|*
operator|)
operator|(
name|req
operator|+
literal|1
operator|)
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|toep
operator|->
name|tp_copied_seq
operator|-
name|toep
operator|->
name|tp_rcv_wup
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_rcv_wup
operator|=
name|toep
operator|->
name|tp_copied_seq
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE5
argument_list|(
name|TIDTB
argument_list|(
name|sk
argument_list|)
argument_list|,
literal|"t3_setup_ddpbufs: len0 %u len1 %u ddp_flags 0x%08x%08x "
literal|"modulate %d"
argument_list|,
name|len0
argument_list|,
name|len1
argument_list|,
name|ddp_flags
operator|>>
literal|32
argument_list|,
name|ddp_flags
operator|&
literal|0xffffffff
argument_list|,
name|modulate
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cxgb_ofld_send
argument_list|(
name|TOEP_T3C_DEV
argument_list|(
name|toep
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_init_wr_tab
parameter_list|(
name|unsigned
name|int
name|wr_len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mbuf_wrs
index|[
literal|1
index|]
condition|)
comment|/* already initialized */
return|return;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|mbuf_wrs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|sgl_len
init|=
operator|(
literal|3
operator|*
name|i
operator|)
operator|/
literal|2
operator|+
operator|(
name|i
operator|&
literal|1
operator|)
decl_stmt|;
name|sgl_len
operator|+=
literal|3
expr_stmt|;
name|mbuf_wrs
index|[
name|i
index|]
operator|=
name|sgl_len
operator|<=
name|wr_len
condition|?
literal|1
else|:
literal|1
operator|+
operator|(
name|sgl_len
operator|-
literal|2
operator|)
operator|/
operator|(
name|wr_len
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|wrlen
operator|=
name|wr_len
operator|*
literal|8
expr_stmt|;
block|}
end_function

begin_function
name|int
name|t3_init_cpl_io
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
name|tcphdr_skb
operator|=
name|alloc_skb
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tcphdr_skb
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Chelsio TCP offload: can't allocate sk_buff\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|skb_put
argument_list|(
name|tcphdr_skb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
expr_stmt|;
name|tcphdr_skb
operator|->
name|h
operator|.
name|raw
operator|=
name|tcphdr_skb
operator|->
name|data
expr_stmt|;
name|memset
argument_list|(
name|tcphdr_skb
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|tcphdr_skb
operator|->
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_ACT_ESTABLISH
argument_list|,
name|do_act_establish
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_ACT_OPEN_RPL
argument_list|,
name|do_act_open_rpl
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_TX_DMA_ACK
argument_list|,
name|do_wr_ack
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_RX_DATA
argument_list|,
name|do_rx_data
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_CLOSE_CON_RPL
argument_list|,
name|do_close_con_rpl
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_PEER_CLOSE
argument_list|,
name|do_peer_close
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_PASS_ESTABLISH
argument_list|,
name|do_pass_establish
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_PASS_ACCEPT_REQ
argument_list|,
name|do_pass_accept_req
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_ABORT_REQ_RSS
argument_list|,
name|do_abort_req
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_ABORT_RPL_RSS
argument_list|,
name|do_abort_rpl
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_RX_DATA_DDP
argument_list|,
name|do_rx_data_ddp
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_RX_DDP_COMPLETE
argument_list|,
name|do_rx_ddp_complete
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_RX_URG_NOTIFY
argument_list|,
name|do_rx_urg_notify
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_TRACE_PKT
argument_list|,
name|do_trace_pkt
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_GET_TCB_RPL
argument_list|,
name|do_get_tcb_rpl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

