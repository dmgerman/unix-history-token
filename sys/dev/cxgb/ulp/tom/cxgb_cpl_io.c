begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Chelsio Communications, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockstate.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/sglist.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_define
define|#
directive|define
name|TCPSTATES
end_define

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/toecore.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_timer.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|"cxgb_include.h"
end_include

begin_include
include|#
directive|include
file|"ulp/tom/cxgb_l2t.h"
end_include

begin_include
include|#
directive|include
file|"ulp/tom/cxgb_tom.h"
end_include

begin_include
include|#
directive|include
file|"ulp/tom/cxgb_toepcb.h"
end_include

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_do_autosndbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_do_autosndbuf
value|VNET(tcp_do_autosndbuf)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_autosndbuf_inc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_autosndbuf_inc
value|VNET(tcp_autosndbuf_inc)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_autosndbuf_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_autosndbuf_max
value|VNET(tcp_autosndbuf_max)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_do_autorcvbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_do_autorcvbuf
value|VNET(tcp_do_autorcvbuf)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_autorcvbuf_inc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_autorcvbuf_inc
value|VNET(tcp_autorcvbuf_inc)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|tcp_autorcvbuf_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_autorcvbuf_max
value|VNET(tcp_autorcvbuf_max)
end_define

begin_decl_stmt
specifier|extern
name|int
name|always_keepalive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * For ULP connections HW may add headers, e.g., for digests, that aren't part  * of the messages sent by the host but that are part of the TCP payload and  * therefore consume TCP sequence space.  Tx connection parameters that  * operate in TCP sequence space are affected by the HW additions and need to  * compensate for them to accurately track TCP sequence numbers. This array  * contains the compensating extra lengths for ULP packets.  It is indexed by  * a packet's ULP submode.  */
end_comment

begin_decl_stmt
specifier|const
name|unsigned
name|int
name|t3_ulp_extra_len
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Max receive window supported by HW in bytes.  Only a small part of it can  * be set through option0, the rest needs to be set through RX_DATA_ACK.  */
end_comment

begin_define
define|#
directive|define
name|MAX_RCV_WND
value|((1U<< 27) - 1)
end_define

begin_comment
comment|/*  * Min receive window.  We want it to be large enough to accommodate receive  * coalescing, handle jumbo frames, and not trigger sender SWS avoidance.  */
end_comment

begin_define
define|#
directive|define
name|MIN_RCV_WND
value|(24 * 1024U)
end_define

begin_define
define|#
directive|define
name|INP_TOS
parameter_list|(
name|inp
parameter_list|)
value|((inp_ip_tos_get(inp)>> 2)& M_TOS)
end_define

begin_function_decl
specifier|static
name|void
name|t3_release_offload_resources
parameter_list|(
name|struct
name|toepcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_reset
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Called after the last CPL for the toepcb has been received.  *  * The inp must be wlocked on entry and is unlocked (or maybe destroyed) by the  * time this function exits.  */
end_comment

begin_function
specifier|static
name|int
name|toepcb_release
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|tp_inp
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
init|=
name|toep
operator|->
name|tp_tod
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|t3_tomdata
argument_list|(
name|tod
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_CPL_DONE
operator|)
argument_list|,
operator|(
literal|"%s: double release?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: tid %d"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_flags
operator||=
name|TP_CPL_DONE
expr_stmt|;
name|toep
operator|->
name|tp_inp
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|,
name|toep
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ATTACHED
operator|)
condition|)
name|t3_release_offload_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|rc
operator|=
name|in_pcbrele_wlocked
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * One sided detach.  The tcpcb is going away and we need to unhook the toepcb  * hanging off it.  If the TOE driver is also done with the toepcb we'll release  * all offload resources.  */
end_comment

begin_function
specifier|static
name|void
name|toepcb_detach
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|KASSERT
argument_list|(
name|inp
argument_list|,
operator|(
literal|"%s: inp is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|toep
operator|=
name|tp
operator|->
name|t_toe
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: toep is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ATTACHED
argument_list|,
operator|(
literal|"%s: not attached"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: %s %u, toep %p, inp %p, tp %p"
argument_list|,
name|__func__
argument_list|,
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_SENT
condition|?
literal|"atid"
else|:
literal|"tid"
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|toep
argument_list|,
name|inp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_toe
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_TOE
expr_stmt|;
name|toep
operator|->
name|tp_flags
operator|&=
operator|~
name|TP_ATTACHED
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_CPL_DONE
condition|)
name|t3_release_offload_resources
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_pcb_detach
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
name|__unused
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|toepcb_detach
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_atid
parameter_list|(
name|struct
name|tid_info
modifier|*
name|t
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|atid
init|=
operator|-
literal|1
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|afree
condition|)
block|{
name|union
name|active_open_entry
modifier|*
name|p
init|=
name|t
operator|->
name|afree
decl_stmt|;
name|atid
operator|=
operator|(
name|p
operator|-
name|t
operator|->
name|atid_tab
operator|)
operator|+
name|t
operator|->
name|atid_base
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|t
operator|->
name|atids_in_use
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|atid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_atid
parameter_list|(
name|struct
name|tid_info
modifier|*
name|t
parameter_list|,
name|int
name|atid
parameter_list|)
block|{
name|union
name|active_open_entry
modifier|*
name|p
init|=
name|atid2entry
argument_list|(
name|t
argument_list|,
name|atid
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|t
operator|->
name|afree
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|atids_in_use
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert_tid
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|td
operator|->
name|tid_maps
decl_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|=
name|ctx
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|update_tid
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|td
operator|->
name|tid_maps
decl_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|=
name|ctx
expr_stmt|;
block|}
end_function

begin_function
name|void
name|remove_tid
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|td
operator|->
name|tid_maps
decl_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|=
name|NULL
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|t
operator|->
name|tids_in_use
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* use ctx as a next pointer in the tid release list */
end_comment

begin_function
name|void
name|queue_tid_release
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|t3_tomdata
argument_list|(
name|tod
argument_list|)
decl_stmt|;
name|void
modifier|*
modifier|*
name|p
init|=
operator|&
name|td
operator|->
name|tid_maps
operator|.
name|tid_tab
index|[
name|tid
index|]
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|td
operator|->
name|tid_release_list
expr_stmt|;
name|td
operator|->
name|tid_release_list
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|td
operator|->
name|tid_release_task
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Populate a TID_RELEASE WR.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mk_tid_release
parameter_list|(
name|struct
name|cpl_tid_release
modifier|*
name|cpl
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|cpl
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_TID_RELEASE
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|release_tid
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|,
name|int
name|qset
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|t3_tomdata
argument_list|(
name|tod
argument_list|)
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cpl_tid_release
modifier|*
name|cpl
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
name|td
operator|->
name|tid_maps
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|tid
operator|>=
literal|0
operator|&&
name|tid
operator|<
name|t
operator|->
name|ntids
argument_list|,
operator|(
literal|"%s: tid=%d, ntids=%d"
operator|,
name|__func__
operator|,
name|tid
operator|,
name|t
operator|->
name|ntids
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|M_GETHDR_OFLD
argument_list|(
name|qset
argument_list|,
name|CPL_PRIORITY_CONTROL
argument_list|,
name|cpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|mk_tid_release
argument_list|(
name|cpl
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|t3_offload_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|remove_tid
argument_list|(
name|td
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
else|else
name|queue_tid_release
argument_list|(
name|tod
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_process_tid_release_list
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|data
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|td
operator|->
name|tod
operator|.
name|tod_softc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|td
operator|->
name|tid_release_list
condition|)
block|{
name|void
modifier|*
modifier|*
name|p
init|=
name|td
operator|->
name|tid_release_list
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|p
operator|-
name|td
operator|->
name|tid_maps
operator|.
name|tid_tab
decl_stmt|;
name|struct
name|cpl_tid_release
modifier|*
name|cpl
decl_stmt|;
name|td
operator|->
name|tid_release_list
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|*
name|p
expr_stmt|;
name|m
operator|=
name|M_GETHDR_OFLD
argument_list|(
literal|0
argument_list|,
name|CPL_PRIORITY_CONTROL
argument_list|,
name|cpl
argument_list|)
expr_stmt|;
comment|/* qs 0 here */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/* XXX: who reschedules the release task? */
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
name|mk_tid_release
argument_list|(
name|cpl
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|t3_offload_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|remove_tid
argument_list|(
name|td
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_conn
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cpl_close_con_req
modifier|*
name|req
decl_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_FIN_SENT
condition|)
return|return;
name|m
operator|=
name|M_GETHDR_OFLD
argument_list|(
name|toep
operator|->
name|tp_qset
argument_list|,
name|CPL_PRIORITY_DATA
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|CXGB_UNIMPLEMENTED
argument_list|()
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_OFLD_CLOSE_CON
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wrh_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|toep
operator|->
name|tp_tid
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_CLOSE_CON_REQ
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|rsvd
operator|=
literal|0
expr_stmt|;
name|toep
operator|->
name|tp_flags
operator||=
name|TP_FIN_SENT
expr_stmt|;
name|t3_offload_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|make_tx_data_wr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|tx_data_wr
modifier|*
name|req
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|mbuf
modifier|*
name|tail
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|snd
decl_stmt|;
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|snd
operator|=
name|so_sockbuf_snd
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_OFLD_TX_DATA
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wrh_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|toep
operator|->
name|tp_tid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* len includes the length of any HW ULP additions */
name|req
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|req
operator|->
name|param
operator|=
name|htonl
argument_list|(
name|V_TX_PORT
argument_list|(
name|toep
operator|->
name|tp_l2t
operator|->
name|smt_idx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* V_TX_ULP_SUBMODE sets both the mode and submode */
name|req
operator|->
name|flags
operator|=
name|htonl
argument_list|(
name|V_TX_ULP_SUBMODE
argument_list|(
name|toep
operator|->
name|tp_ulp_mode
argument_list|)
operator||
name|V_TX_URG
argument_list|(
literal|0
argument_list|)
operator||
name|V_TX_SHOVE
argument_list|(
operator|!
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_MORETOCOME
operator|)
operator|&&
operator|(
name|tail
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|sndseq
operator|=
name|htonl
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_DATASENT
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|toep
operator|->
name|tp_tod
operator|->
name|tod_softc
decl_stmt|;
name|int
name|cpu_idx
init|=
name|sc
operator|->
name|rrss_map
index|[
name|toep
operator|->
name|tp_qset
index|]
decl_stmt|;
name|req
operator|->
name|flags
operator||=
name|htonl
argument_list|(
name|V_TX_ACK_PAGES
argument_list|(
literal|2
argument_list|)
operator||
name|F_TX_INIT
operator||
name|V_TX_CPU_IDX
argument_list|(
name|cpu_idx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sendbuffer is in units of 32KB. */
if|if
condition|(
name|V_tcp_do_autosndbuf
operator|&&
name|snd
operator|->
name|sb_flags
operator|&
name|SB_AUTOSIZE
condition|)
name|req
operator|->
name|param
operator||=
name|htonl
argument_list|(
name|V_TX_SNDBUF
argument_list|(
name|VNET
argument_list|(
name|tcp_autosndbuf_max
argument_list|)
operator|>>
literal|15
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|req
operator|->
name|param
operator||=
name|htonl
argument_list|(
name|V_TX_SNDBUF
argument_list|(
name|snd
operator|->
name|sb_hiwat
operator|>>
literal|15
argument_list|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_flags
operator||=
name|TP_DATASENT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * TOM_XXX_DUPLICATION sgl_len, calc_tx_descs, calc_tx_descs_ofld, mbuf_wrs, etc.  * TOM_XXX_MOVE to some common header file.  */
end_comment

begin_comment
comment|/*  * IMM_LEN: # of bytes that can be tx'd as immediate data.  There are 16 flits  * in a tx desc; subtract 3 for tx_data_wr (including the WR header), and 1 more  * for the second gen bit flit.  This leaves us with 12 flits.  *  * descs_to_sgllen: # of SGL entries that can fit into the given # of tx descs.  * The first desc has a tx_data_wr (which includes the WR header), the rest have  * the WR header only.  All descs have the second gen bit flit.  *  * sgllen_to_descs: # of tx descs used up by an sgl of given length.  The first  * desc has a tx_data_wr (which includes the WR header), the rest have the WR  * header only.  All descs have the second gen bit flit.  *  * flits_to_sgllen: # of SGL entries that can be fit in the given # of flits.  *  */
end_comment

begin_define
define|#
directive|define
name|IMM_LEN
value|96
end_define

begin_decl_stmt
specifier|static
name|int
name|descs_to_sgllen
index|[
name|TX_MAX_DESC
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|8
block|,
literal|17
block|,
literal|26
block|,
literal|35
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sgllen_to_descs
index|[
name|TX_MAX_SEGS
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
comment|/*  0 -  9 */
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
comment|/* 10 - 19 */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
comment|/* 20 - 29 */
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
comment|/* 30 - 35 */
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int flits_to_sgllen[TX_DESC_FLITS + 1] = { 	0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9, 10, 10 };
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SGE_NUM_GENBITS
operator|!=
literal|2
end_if

begin_error
error|#
directive|error
literal|"SGE_NUM_GENBITS really must be 2"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|t3_push_frames
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|req_completion
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|so_sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|sndptr
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
init|=
name|toep
operator|->
name|tp_tod
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|ndesc
decl_stmt|,
name|total_bytes
init|=
literal|0
decl_stmt|,
name|mlen
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|snd
decl_stmt|;
name|struct
name|sglist
modifier|*
name|sgl
decl_stmt|;
name|struct
name|ofld_hdr
modifier|*
name|oh
decl_stmt|;
name|caddr_t
name|dst
decl_stmt|;
name|struct
name|tx_data_wr
modifier|*
name|wr
decl_stmt|;
name|inp_lock_assert
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|snd
operator|=
name|so_sockbuf_snd
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|snd
argument_list|)
expr_stmt|;
comment|/* 	 * Autosize the send buffer. 	 */
if|if
condition|(
name|snd
operator|->
name|sb_flags
operator|&
name|SB_AUTOSIZE
operator|&&
name|VNET
argument_list|(
name|tcp_do_autosndbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|snd
operator|->
name|sb_cc
operator|>=
operator|(
name|snd
operator|->
name|sb_hiwat
operator|/
literal|8
operator|*
literal|7
operator|)
operator|&&
name|snd
operator|->
name|sb_cc
operator|<
name|VNET
argument_list|(
name|tcp_autosndbuf_max
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|sbreserve_locked
argument_list|(
name|snd
argument_list|,
name|min
argument_list|(
name|snd
operator|->
name|sb_hiwat
operator|+
name|VNET
argument_list|(
name|tcp_autosndbuf_inc
argument_list|)
argument_list|,
name|VNET
argument_list|(
name|tcp_autosndbuf_max
argument_list|)
argument_list|)
argument_list|,
name|so
argument_list|,
name|curthread
argument_list|)
condition|)
name|snd
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_AUTOSIZE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|toep
operator|->
name|tp_m_last
operator|&&
name|toep
operator|->
name|tp_m_last
operator|==
name|snd
operator|->
name|sb_sndptr
condition|)
name|sndptr
operator|=
name|toep
operator|->
name|tp_m_last
operator|->
name|m_next
expr_stmt|;
else|else
name|sndptr
operator|=
name|snd
operator|->
name|sb_sndptr
condition|?
name|snd
operator|->
name|sb_sndptr
else|:
name|snd
operator|->
name|sb_mb
expr_stmt|;
comment|/* Nothing to send or no WRs available for sending data */
if|if
condition|(
name|toep
operator|->
name|tp_wr_avail
operator|==
literal|0
operator|||
name|sndptr
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* Something to send and at least 1 WR available */
while|while
condition|(
name|toep
operator|->
name|tp_wr_avail
operator|&&
name|sndptr
operator|!=
name|NULL
condition|)
block|{
name|m0
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
break|break;
name|oh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ofld_hdr
operator|*
argument_list|)
expr_stmt|;
name|wr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|oh
operator|+
literal|1
operator|)
expr_stmt|;
name|dst
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|wr
operator|+
literal|1
operator|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m0
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|oh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|wr
argument_list|)
expr_stmt|;
name|oh
operator|->
name|flags
operator|=
name|V_HDR_CTRL
argument_list|(
name|CPL_PRIORITY_DATA
argument_list|)
operator||
name|F_HDR_DF
operator||
name|V_HDR_QSET
argument_list|(
name|toep
operator|->
name|tp_qset
argument_list|)
expr_stmt|;
comment|/* 		 * Try to construct an immediate data WR if possible.  Stuff as 		 * much data into it as possible, one whole mbuf at a time. 		 */
name|mlen
operator|=
name|sndptr
operator|->
name|m_len
expr_stmt|;
name|ndesc
operator|=
name|bytes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mlen
operator|<=
name|IMM_LEN
operator|-
name|bytes
condition|)
block|{
name|bcopy
argument_list|(
name|sndptr
operator|->
name|m_data
argument_list|,
name|dst
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
name|bytes
operator|+=
name|mlen
expr_stmt|;
name|dst
operator|+=
name|mlen
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sndptr
operator|=
name|sndptr
operator|->
name|m_next
operator|)
condition|)
break|break;
name|mlen
operator|=
name|sndptr
operator|->
name|m_len
expr_stmt|;
block|}
if|if
condition|(
name|bytes
condition|)
block|{
comment|/* Was able to fit 'bytes' bytes in an immediate WR */
name|ndesc
operator|=
literal|1
expr_stmt|;
name|make_tx_data_wr
argument_list|(
name|so
argument_list|,
name|wr
argument_list|,
name|bytes
argument_list|,
name|sndptr
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_len
operator|+=
name|bytes
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m0
operator|->
name|m_len
expr_stmt|;
block|}
else|else
block|{
name|int
name|wr_avail
init|=
name|min
argument_list|(
name|toep
operator|->
name|tp_wr_avail
argument_list|,
name|TX_MAX_DESC
argument_list|)
decl_stmt|;
comment|/* Need to make an SGL */
name|sgl
operator|=
name|sglist_alloc
argument_list|(
name|descs_to_sgllen
index|[
name|wr_avail
index|]
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgl
operator|==
name|NULL
condition|)
break|break;
for|for
control|(
name|m
operator|=
name|sndptr
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
operator|(
name|mlen
operator|=
name|m
operator|->
name|m_len
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sglist_append
argument_list|(
name|sgl
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|mlen
argument_list|)
condition|)
break|break;
block|}
name|bytes
operator|+=
name|mlen
expr_stmt|;
block|}
name|sndptr
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
block|{
name|sglist_free
argument_list|(
name|sgl
argument_list|)
expr_stmt|;
break|break;
block|}
name|ndesc
operator|=
name|sgllen_to_descs
index|[
name|sgl
operator|->
name|sg_nseg
index|]
expr_stmt|;
name|oh
operator|->
name|flags
operator||=
name|F_HDR_SGL
expr_stmt|;
name|oh
operator|->
name|sgl
operator|=
name|sgl
expr_stmt|;
name|make_tx_data_wr
argument_list|(
name|so
argument_list|,
name|wr
argument_list|,
name|bytes
argument_list|,
name|sndptr
argument_list|)
expr_stmt|;
block|}
name|oh
operator|->
name|flags
operator||=
name|V_HDR_NDESC
argument_list|(
name|ndesc
argument_list|)
expr_stmt|;
name|oh
operator|->
name|plen
operator|=
name|bytes
expr_stmt|;
name|snd
operator|->
name|sb_sndptr
operator|=
name|sndptr
expr_stmt|;
name|snd
operator|->
name|sb_sndptroff
operator|+=
name|bytes
expr_stmt|;
if|if
condition|(
name|sndptr
operator|==
name|NULL
condition|)
block|{
name|snd
operator|->
name|sb_sndptr
operator|=
name|snd
operator|->
name|sb_mbtail
expr_stmt|;
name|snd
operator|->
name|sb_sndptroff
operator|-=
name|snd
operator|->
name|sb_mbtail
operator|->
name|m_len
expr_stmt|;
name|toep
operator|->
name|tp_m_last
operator|=
name|snd
operator|->
name|sb_mbtail
expr_stmt|;
block|}
else|else
name|toep
operator|->
name|tp_m_last
operator|=
name|NULL
expr_stmt|;
name|total_bytes
operator|+=
name|bytes
expr_stmt|;
name|toep
operator|->
name|tp_wr_avail
operator|-=
name|ndesc
expr_stmt|;
name|toep
operator|->
name|tp_wr_unacked
operator|+=
name|ndesc
expr_stmt|;
if|if
condition|(
operator|(
name|req_completion
operator|&&
name|toep
operator|->
name|tp_wr_unacked
operator|==
name|ndesc
operator|)
operator|||
name|toep
operator|->
name|tp_wr_unacked
operator|>=
name|toep
operator|->
name|tp_wr_max
operator|/
literal|2
condition|)
block|{
name|wr
operator|->
name|wr
operator|.
name|wrh_hi
operator||=
name|htonl
argument_list|(
name|F_WR_COMPL
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_wr_unacked
operator|=
literal|0
expr_stmt|;
block|}
name|enqueue_wr
argument_list|(
name|toep
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|l2t_send
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|,
name|toep
operator|->
name|tp_l2t
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|SOCKBUF_UNLOCK
argument_list|(
name|snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndptr
operator|==
name|NULL
operator|&&
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_SEND_FIN
operator|)
condition|)
name|close_conn
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|)
expr_stmt|;
return|return
operator|(
name|total_bytes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_rx_credits
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|int
name|credits
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cpl_rx_data_ack
modifier|*
name|req
decl_stmt|;
name|uint32_t
name|dack
init|=
name|F_RX_DACK_CHANGE
operator||
name|V_RX_DACK_MODE
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|m
operator|=
name|M_GETHDR_OFLD
argument_list|(
name|toep
operator|->
name|tp_qset
argument_list|,
name|CPL_PRIORITY_CONTROL
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|req
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wrh_lo
operator|=
literal|0
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_RX_DATA_ACK
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|credit_dack
operator|=
name|htonl
argument_list|(
name|dack
operator||
name|V_RX_CREDITS
argument_list|(
name|credits
argument_list|)
argument_list|)
expr_stmt|;
name|t3_offload_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|credits
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_rcvd
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|inp
operator|->
name|inp_socket
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|so_rcv
init|=
operator|&
name|so
operator|->
name|so_rcv
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|int
name|must_send
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|so_rcv
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tp_enqueued
operator|>=
name|so_rcv
operator|->
name|sb_cc
argument_list|,
operator|(
literal|"%s: so_rcv->sb_cc> enqueued"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_rx_credits
operator|+=
name|toep
operator|->
name|tp_enqueued
operator|-
name|so_rcv
operator|->
name|sb_cc
expr_stmt|;
name|toep
operator|->
name|tp_enqueued
operator|=
name|so_rcv
operator|->
name|sb_cc
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|so_rcv
argument_list|)
expr_stmt|;
name|must_send
operator|=
name|toep
operator|->
name|tp_rx_credits
operator|+
literal|16384
operator|>=
name|tp
operator|->
name|rcv_wnd
expr_stmt|;
if|if
condition|(
name|must_send
operator|||
name|toep
operator|->
name|tp_rx_credits
operator|>=
literal|15
operator|*
literal|1024
condition|)
block|{
name|int
name|credits
decl_stmt|;
name|credits
operator|=
name|send_rx_credits
argument_list|(
name|sc
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|tp_rx_credits
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_rx_credits
operator|-=
name|credits
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|+=
name|credits
expr_stmt|;
name|tp
operator|->
name|rcv_adv
operator|+=
name|credits
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_rx_urg_notify
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|struct
name|cpl_rx_urg_notify
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|hdr
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: tid %u inp %p"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|toep
operator|->
name|tp_inp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_send_fin
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|inp_inpcbtosocket
argument_list|(
name|inp
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|KTR
argument_list|)
name|unsigned
name|int
name|tid
init|=
name|toep
operator|->
name|tp_tid
decl_stmt|;
endif|#
directive|endif
name|INP_INFO_WLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: tid %d, toep %p, flags %x"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|tp_flags
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_flags
operator||=
name|TP_SEND_FIN
expr_stmt|;
name|t3_push_frames
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_tod_output
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|inp
operator|->
name|inp_socket
decl_stmt|;
name|t3_push_frames
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* What mtu_idx to use, given a 4-tuple and/or an MSS cap */
end_comment

begin_function
name|int
name|find_best_mtu_idx
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|in_conninfo
modifier|*
name|inc
parameter_list|,
name|int
name|pmss
parameter_list|)
block|{
name|unsigned
name|short
modifier|*
name|mtus
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|mtus
index|[
literal|0
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|mss
decl_stmt|;
name|KASSERT
argument_list|(
name|inc
operator|!=
name|NULL
operator|||
name|pmss
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: at least one of inc/pmss must be specified"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|mss
operator|=
name|inc
condition|?
name|tcp_mssopt
argument_list|(
name|inc
argument_list|)
else|:
name|pmss
expr_stmt|;
if|if
condition|(
name|pmss
operator|>
literal|0
operator|&&
name|mss
operator|>
name|pmss
condition|)
name|mss
operator|=
name|pmss
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|NMTUS
operator|-
literal|1
operator|&&
name|mtus
index|[
name|i
operator|+
literal|1
index|]
operator|<=
name|mss
operator|+
literal|40
condition|)
operator|++
name|i
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|purge_wr_queue
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ofld_hdr
modifier|*
name|oh
decl_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|toep
operator|->
name|wr_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|oh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ofld_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|oh
operator|->
name|flags
operator|&
name|F_HDR_SGL
condition|)
name|sglist_free
argument_list|(
name|oh
operator|->
name|sgl
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Release cxgb(4) and T3 resources held by an offload connection (TID, L2T  * entry, etc.)  */
end_comment

begin_function
specifier|static
name|void
name|t3_release_offload_resources
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|toedev
modifier|*
name|tod
init|=
name|toep
operator|->
name|tp_tod
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|t3_tomdata
argument_list|(
name|tod
argument_list|)
decl_stmt|;
comment|/* 	 * The TOM explicitly detaches its toepcb from the system's inp before 	 * it releases the offload resources. 	 */
if|if
condition|(
name|toep
operator|->
name|tp_inp
condition|)
block|{
name|panic
argument_list|(
literal|"%s: inp %p still attached to toepcb %p"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tp_inp
argument_list|,
name|toep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|toep
operator|->
name|tp_wr_avail
operator|!=
name|toep
operator|->
name|tp_wr_max
condition|)
name|purge_wr_queue
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_l2t
condition|)
block|{
name|l2t_release
argument_list|(
name|td
operator|->
name|l2t
argument_list|,
name|toep
operator|->
name|tp_l2t
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_l2t
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|toep
operator|->
name|tp_tid
operator|>=
literal|0
condition|)
name|release_tid
argument_list|(
name|tod
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|toep
operator|->
name|tp_qset
argument_list|)
expr_stmt|;
name|toepcb_free
argument_list|(
name|toep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine the receive window size for a socket.  */
end_comment

begin_function
name|unsigned
name|long
name|select_rcv_wnd
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|unsigned
name|long
name|wnd
decl_stmt|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|wnd
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|wnd
operator|<
name|MIN_RCV_WND
condition|)
name|wnd
operator|=
name|MIN_RCV_WND
expr_stmt|;
return|return
name|min
argument_list|(
name|wnd
argument_list|,
name|MAX_RCV_WND
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|select_rcv_wscale
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|wscale
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|space
init|=
name|sb_max
decl_stmt|;
if|if
condition|(
name|space
operator|>
name|MAX_RCV_WND
condition|)
name|space
operator|=
name|MAX_RCV_WND
expr_stmt|;
while|while
condition|(
name|wscale
operator|<
name|TCP_MAX_WINSHIFT
operator|&&
operator|(
name|TCP_MAXWIN
operator|<<
name|wscale
operator|)
operator|<
name|space
condition|)
name|wscale
operator|++
expr_stmt|;
return|return
operator|(
name|wscale
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up the socket for TCP offload.  */
end_comment

begin_function
name|void
name|offload_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|toedev
modifier|*
name|tod
init|=
name|toep
operator|->
name|tp_tod
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|t3_tomdata
argument_list|(
name|tod
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Update socket */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|so_sockbuf_snd
argument_list|(
name|so
argument_list|)
operator|->
name|sb_flags
operator||=
name|SB_NOCOALESCE
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
operator|->
name|sb_flags
operator||=
name|SB_NOCOALESCE
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* Update TCP PCB */
name|tp
operator|->
name|tod
operator|=
name|toep
operator|->
name|tp_tod
expr_stmt|;
name|tp
operator|->
name|t_toe
operator|=
name|toep
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_TOE
expr_stmt|;
comment|/* Install an extra hold on inp */
name|toep
operator|->
name|tp_inp
operator|=
name|inp
expr_stmt|;
name|toep
operator|->
name|tp_flags
operator||=
name|TP_ATTACHED
expr_stmt|;
name|in_pcbref
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Add the TOE PCB to the active list */
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|,
name|toep
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is _not_ the normal way to "unoffload" a socket. */
end_comment

begin_function
name|void
name|undo_offload_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
init|=
name|toep
operator|->
name|tp_tod
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|t3_tomdata
argument_list|(
name|tod
argument_list|)
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|so_sockbuf_snd
argument_list|(
name|so
argument_list|)
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_NOCOALESCE
expr_stmt|;
name|so_sockbuf_rcv
argument_list|(
name|so
argument_list|)
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_NOCOALESCE
expr_stmt|;
name|tp
operator|->
name|tod
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_toe
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_TOE
expr_stmt|;
name|toep
operator|->
name|tp_inp
operator|=
name|NULL
expr_stmt|;
name|toep
operator|->
name|tp_flags
operator|&=
operator|~
name|TP_ATTACHED
expr_stmt|;
if|if
condition|(
name|in_pcbrele_wlocked
argument_list|(
name|inp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: inp freed."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|td
operator|->
name|toep_list
argument_list|,
name|toep
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|toep_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Socket could be a listening socket, and we may not have a toepcb at all at  * this time.  */
end_comment

begin_function
name|uint32_t
name|calc_opt0h
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|mtu_idx
parameter_list|,
name|int
name|rscale
parameter_list|,
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|)
block|{
name|uint32_t
name|opt0h
init|=
name|F_TCAM_BYPASS
operator||
name|V_WND_SCALE
argument_list|(
name|rscale
argument_list|)
operator||
name|V_MSS_IDX
argument_list|(
name|mtu_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|so
operator|!=
name|NULL
condition|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|int
name|keepalive
init|=
name|always_keepalive
operator|||
name|so_options_get
argument_list|(
name|so
argument_list|)
operator|&
name|SO_KEEPALIVE
decl_stmt|;
name|opt0h
operator||=
name|V_NAGLE
argument_list|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NODELAY
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|opt0h
operator||=
name|V_KEEP_ALIVE
argument_list|(
name|keepalive
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
name|opt0h
operator||=
name|V_L2T_IDX
argument_list|(
name|e
operator|->
name|idx
argument_list|)
operator||
name|V_TX_CHANNEL
argument_list|(
name|e
operator|->
name|smt_idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|htobe32
argument_list|(
name|opt0h
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|calc_opt0l
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|rcv_bufsize
parameter_list|)
block|{
name|uint32_t
name|opt0l
init|=
name|V_ULP_MODE
argument_list|(
name|ULP_MODE_NONE
argument_list|)
operator||
name|V_RCV_BUFSIZ
argument_list|(
name|rcv_bufsize
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|rcv_bufsize
operator|<=
name|M_RCV_BUFSIZ
argument_list|,
operator|(
literal|"%s: rcv_bufsize (%d) is too high"
operator|,
name|__func__
operator|,
name|rcv_bufsize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|!=
name|NULL
condition|)
comment|/* optional because noone cares about IP TOS */
name|opt0l
operator||=
name|V_TOS
argument_list|(
name|INP_TOS
argument_list|(
name|sotoinpcb
argument_list|(
name|so
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|htobe32
argument_list|(
name|opt0l
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an ACT_OPEN_RPL status to an errno.  */
end_comment

begin_function
specifier|static
name|int
name|act_open_rpl_status_to_errno
parameter_list|(
name|int
name|status
parameter_list|)
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CPL_ERR_CONN_RESET
case|:
return|return
operator|(
name|ECONNREFUSED
operator|)
return|;
case|case
name|CPL_ERR_ARP_MISS
case|:
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
case|case
name|CPL_ERR_CONN_TIMEDOUT
case|:
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
case|case
name|CPL_ERR_TCAM_FULL
case|:
return|return
operator|(
name|EAGAIN
operator|)
return|;
case|case
name|CPL_ERR_CONN_EXIST
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ACTIVE_OPEN_RPL: 4-tuple in use\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return whether a failed active open has allocated a TID  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|act_open_has_tid
parameter_list|(
name|int
name|status
parameter_list|)
block|{
return|return
name|status
operator|!=
name|CPL_ERR_TCAM_FULL
operator|&&
name|status
operator|!=
name|CPL_ERR_CONN_EXIST
operator|&&
name|status
operator|!=
name|CPL_ERR_ARP_MISS
return|;
block|}
end_function

begin_comment
comment|/*  * Active open failed.  */
end_comment

begin_function
specifier|static
name|int
name|do_act_open_rpl
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
init|=
operator|&
name|td
operator|->
name|tod
decl_stmt|;
name|struct
name|cpl_act_open_rpl
modifier|*
name|rpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|atid
init|=
name|G_TID
argument_list|(
name|ntohl
argument_list|(
name|rpl
operator|->
name|atid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_atid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|atid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|tp_inp
decl_stmt|;
name|int
name|s
init|=
name|rpl
operator|->
name|status
decl_stmt|,
name|rc
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: atid %u, status %u "
argument_list|,
name|__func__
argument_list|,
name|atid
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free_atid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_tid
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|act_open_has_tid
argument_list|(
name|s
argument_list|)
condition|)
name|queue_tid_release
argument_list|(
name|tod
argument_list|,
name|GET_TID
argument_list|(
name|rpl
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|act_open_rpl_status_to_errno
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|EAGAIN
condition|)
name|INP_INFO_WLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|toe_connect_failed
argument_list|(
name|tod
argument_list|,
name|inp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
comment|/* unlocks inp */
if|if
condition|(
name|rc
operator|!=
name|EAGAIN
condition|)
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send an active open request.  *  * State of affairs on entry:  * soisconnecting (so_state |= SS_ISCONNECTING)  * tcbinfo not locked (this has changed - used to be WLOCKed)  * inp WLOCKed  * tp->t_state = TCPS_SYN_SENT  * rtalloc1, RT_UNLOCK on rt.  */
end_comment

begin_function
name|int
name|t3_connect
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|t3_tomdata
argument_list|(
name|tod
argument_list|)
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|cpl_act_open_req
modifier|*
name|cpl
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
name|int
name|atid
init|=
operator|-
literal|1
decl_stmt|,
name|mtu_idx
decl_stmt|,
name|rscale
decl_stmt|,
name|cpu_idx
decl_stmt|,
name|qset
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|gw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|rt
operator|->
name|rt_ifp
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* XXX wrong for VLAN etc. */
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|toep
operator|=
name|toepcb_alloc
argument_list|(
name|tod
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|atid
operator|=
name|alloc_atid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|atid
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
name|qset
operator|=
name|pi
operator|->
name|first_qset
operator|+
operator|(
name|arc4random
argument_list|()
operator|%
name|pi
operator|->
name|nqsets
operator|)
expr_stmt|;
name|m
operator|=
name|M_GETHDR_OFLD
argument_list|(
name|qset
argument_list|,
name|CPL_PRIORITY_CONTROL
argument_list|,
name|cpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|gw
operator|=
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|?
name|rt
operator|->
name|rt_gateway
else|:
name|nam
expr_stmt|;
name|e
operator|=
name|t3_l2t_get
argument_list|(
name|pi
argument_list|,
name|ifp
argument_list|,
name|gw
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|toep
operator|->
name|tp_l2t
operator|=
name|e
expr_stmt|;
name|toep
operator|->
name|tp_tid
operator|=
name|atid
expr_stmt|;
comment|/* used to double check response */
name|toep
operator|->
name|tp_qset
operator|=
name|qset
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* opt0 rcv_bufsiz initially, assumes its normal meaning later */
name|toep
operator|->
name|tp_rx_credits
operator|=
name|min
argument_list|(
name|select_rcv_wnd
argument_list|(
name|so
argument_list|)
operator|>>
literal|10
argument_list|,
name|M_RCV_BUFSIZ
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|offload_socket
argument_list|(
name|so
argument_list|,
name|toep
argument_list|)
expr_stmt|;
comment|/* 	 * The kernel sets request_r_scale based on sb_max whereas we need to 	 * take hardware's MAX_RCV_WND into account too.  This is normally a 	 * no-op as MAX_RCV_WND is much larger than the default sb_max. 	 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_REQ_SCALE
condition|)
name|rscale
operator|=
name|tp
operator|->
name|request_r_scale
operator|=
name|select_rcv_wscale
argument_list|()
expr_stmt|;
else|else
name|rscale
operator|=
literal|0
expr_stmt|;
name|mtu_idx
operator|=
name|find_best_mtu_idx
argument_list|(
name|sc
argument_list|,
operator|&
name|inp
operator|->
name|inp_inc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpu_idx
operator|=
name|sc
operator|->
name|rrss_map
index|[
name|qset
index|]
expr_stmt|;
name|cpl
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htobe32
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|wr
operator|.
name|wrh_lo
operator|=
literal|0
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|cpl
argument_list|)
operator|=
name|htobe32
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_ACT_OPEN_REQ
argument_list|,
name|atid
argument_list|)
argument_list|)
expr_stmt|;
name|inp_4tuple_get
argument_list|(
name|inp
argument_list|,
operator|&
name|cpl
operator|->
name|local_ip
argument_list|,
operator|&
name|cpl
operator|->
name|local_port
argument_list|,
operator|&
name|cpl
operator|->
name|peer_ip
argument_list|,
operator|&
name|cpl
operator|->
name|peer_port
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|opt0h
operator|=
name|calc_opt0h
argument_list|(
name|so
argument_list|,
name|mtu_idx
argument_list|,
name|rscale
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|opt0l
operator|=
name|calc_opt0l
argument_list|(
name|so
argument_list|,
name|toep
operator|->
name|tp_rx_credits
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|params
operator|=
literal|0
expr_stmt|;
name|cpl
operator|->
name|opt2
operator|=
name|calc_opt2
argument_list|(
name|cpu_idx
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: atid %u (%s), toep %p, inp %p"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
argument_list|,
name|toep
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2t_send
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|e
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|undo_offload_socket
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|failed
label|:
name|CTR5
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: FAILED, atid %d, toep %p, l2te %p, mbuf %p"
argument_list|,
name|__func__
argument_list|,
name|atid
argument_list|,
name|toep
argument_list|,
name|e
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|atid
operator|>=
literal|0
condition|)
name|free_atid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|atid
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|l2t_release
argument_list|(
name|td
operator|->
name|l2t
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
condition|)
name|toepcb_free
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send an ABORT_REQ message.  Cannot fail.  This routine makes sure we do not  * send multiple ABORT_REQs for the same connection and also that we do not try  * to send a message after the connection has closed.  */
end_comment

begin_function
specifier|static
name|void
name|send_reset
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|cpl_abort_req
modifier|*
name|req
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|toep
operator|->
name|tp_tid
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|tp_inp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|inp
operator|->
name|inp_socket
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
init|=
name|toep
operator|->
name|tp_tod
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|INP_INFO_WLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: tid %d, toep %p (%x)"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|tp_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_SHUTDOWN
condition|)
return|return;
name|toep
operator|->
name|tp_flags
operator||=
operator|(
name|TP_ABORT_RPL_PENDING
operator||
name|TP_ABORT_SHUTDOWN
operator|)
expr_stmt|;
comment|/* Purge the send queue */
name|sbflush
argument_list|(
name|so_sockbuf_snd
argument_list|(
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|purge_wr_queue
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|m
operator|=
name|M_GETHDR_OFLD
argument_list|(
name|toep
operator|->
name|tp_qset
argument_list|,
name|CPL_PRIORITY_DATA
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|CXGB_UNIMPLEMENTED
argument_list|()
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_OFLD_HOST_ABORT_CON_REQ
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wrh_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_ABORT_REQ
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|rsvd0
operator|=
name|htonl
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|)
expr_stmt|;
name|req
operator|->
name|rsvd1
operator|=
operator|!
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_DATASENT
operator|)
expr_stmt|;
name|req
operator|->
name|cmd
operator|=
name|CPL_ABORT_SEND_RST
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_SENT
condition|)
name|mbufq_tail
argument_list|(
operator|&
name|toep
operator|->
name|out_of_order_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* defer */
else|else
name|l2t_send
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|toep
operator|->
name|tp_l2t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|t3_send_rst
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
name|__unused
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|send_reset
argument_list|(
name|tp
operator|->
name|t_toe
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handler for RX_DATA CPL messages.  */
end_comment

begin_function
specifier|static
name|int
name|do_rx_data
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|struct
name|cpl_rx_data
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|hdr
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|tp_inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|so_rcv
decl_stmt|;
comment|/* Advance over CPL */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: revisit.  This comes from the T4 TOM */
if|if
condition|(
name|__predict_false
argument_list|(
name|inp
operator|==
name|NULL
argument_list|)
condition|)
block|{
comment|/* 		 * do_pass_establish failed and must be attempting to abort the 		 * connection.  Meanwhile, the T4 has sent us data for such a 		 * connection. 		 */
ifdef|#
directive|ifdef
name|notyet
name|KASSERT
argument_list|(
name|toepcb_flag
argument_list|(
name|toep
argument_list|,
name|TPF_ABORT_SHUTDOWN
argument_list|)
argument_list|,
operator|(
literal|"%s: inp NULL and tid isn't being aborted"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
operator|(
name|INP_DROPPED
operator||
name|INP_TIMEWAIT
operator|)
condition|)
block|{
name|CTR4
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: tid %u, rx (%d bytes), inp_flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|hdr
operator|->
name|dack_mode
operator|!=
name|toep
operator|->
name|tp_delack_mode
argument_list|)
condition|)
name|toep
operator|->
name|tp_delack_mode
operator|=
name|hdr
operator|->
name|dack_mode
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|__predict_false
argument_list|(
name|tp
operator|->
name|rcv_nxt
operator|!=
name|be32toh
argument_list|(
name|hdr
operator|->
name|seq
argument_list|)
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: unexpected seq# %x for TID %u, rcv_nxt %x\n"
argument_list|,
name|__func__
argument_list|,
name|be32toh
argument_list|(
name|hdr
operator|->
name|seq
argument_list|)
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tp
operator|->
name|rcv_nxt
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|rcv_wnd
operator|>=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
operator|(
literal|"%s: negative window size"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|tp
operator|->
name|t_rcvtime
operator|=
name|ticks
expr_stmt|;
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
name|so_rcv
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|so_rcv
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
argument_list|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: tid %u, excess rx (%d bytes)"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|so_rcv
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tcp_drop
argument_list|(
name|tp
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* receive buffer autosize */
if|if
condition|(
name|so_rcv
operator|->
name|sb_flags
operator|&
name|SB_AUTOSIZE
operator|&&
name|V_tcp_do_autorcvbuf
operator|&&
name|so_rcv
operator|->
name|sb_hiwat
operator|<
name|V_tcp_autorcvbuf_max
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
operator|(
name|sbspace
argument_list|(
name|so_rcv
argument_list|)
operator|/
literal|8
operator|*
literal|7
operator|)
operator|||
name|tp
operator|->
name|rcv_wnd
operator|<
literal|32768
operator|)
condition|)
block|{
name|unsigned
name|int
name|hiwat
init|=
name|so_rcv
operator|->
name|sb_hiwat
decl_stmt|;
name|unsigned
name|int
name|newsize
init|=
name|min
argument_list|(
name|hiwat
operator|+
name|V_tcp_autorcvbuf_inc
argument_list|,
name|V_tcp_autorcvbuf_max
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sbreserve_locked
argument_list|(
name|so_rcv
argument_list|,
name|newsize
argument_list|,
name|so
argument_list|,
name|NULL
argument_list|)
condition|)
name|so_rcv
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_AUTOSIZE
expr_stmt|;
else|else
name|toep
operator|->
name|tp_rx_credits
operator|+=
name|newsize
operator|-
name|hiwat
expr_stmt|;
block|}
name|toep
operator|->
name|tp_enqueued
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|sbappendstream_locked
argument_list|(
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK_ASSERT
argument_list|(
name|so_rcv
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handler for PEER_CLOSE CPL messages.  */
end_comment

begin_function
specifier|static
name|int
name|do_peer_close
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
specifier|const
name|struct
name|cpl_peer_close
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|hdr
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|tp_inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|INP_INFO_WLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: tid %u (%s), toep_flags 0x%x, inp %p"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|tp
condition|?
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
else|:
literal|"no tp"
argument_list|,
name|toep
operator|->
name|tp_flags
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_RPL_PENDING
condition|)
goto|goto
name|done
goto|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|socantrcvmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|++
expr_stmt|;
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
case|case
name|TCPS_SYN_RECEIVED
case|:
name|tp
operator|->
name|t_starttime
operator|=
name|ticks
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|TCPS_ESTABLISHED
case|:
name|tp
operator|->
name|t_state
operator|=
name|TCPS_CLOSE_WAIT
expr_stmt|;
break|break;
case|case
name|TCPS_FIN_WAIT_1
case|:
name|tp
operator|->
name|t_state
operator|=
name|TCPS_CLOSING
expr_stmt|;
break|break;
case|case
name|TCPS_FIN_WAIT_2
case|:
name|tcp_twstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|INP_UNLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* safe, we have a ref on the  inp */
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
comment|/* no more CPLs expected */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: TID %u received PEER_CLOSE in bad state %d\n"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handler for CLOSE_CON_RPL CPL messages.  peer ACK to our FIN received.  */
end_comment

begin_function
specifier|static
name|int
name|do_close_con_rpl
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
specifier|const
name|struct
name|cpl_close_con_rpl
modifier|*
name|rpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|rpl
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|tp_inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|INP_INFO_WLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: tid %u (%s), toep_flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|tp
condition|?
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
else|:
literal|"no tp"
argument_list|,
name|toep
operator|->
name|tp_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_RPL_PENDING
operator|)
condition|)
goto|goto
name|done
goto|;
name|so
operator|=
name|inp_inpcbtosocket
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_una
operator|=
name|ntohl
argument_list|(
name|rpl
operator|->
name|snd_nxt
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* exclude FIN */
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
case|case
name|TCPS_CLOSING
case|:
name|tcp_twstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|release
label|:
name|INP_UNLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* safe, we have a ref on the  inp */
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
comment|/* no more CPLs expected */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TCPS_LAST_ACK
case|:
if|if
condition|(
name|tcp_close
argument_list|(
name|tp
argument_list|)
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
case|case
name|TCPS_FIN_WAIT_1
case|:
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TCPS_FIN_WAIT_2
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: TID %u received CLOSE_CON_RPL in bad state %d\n"
argument_list|,
name|__func__
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_smt_write_rpl
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_smt_write_rpl
modifier|*
name|rpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unexpected SMT_WRITE_RPL status %u for entry %u\n"
argument_list|,
name|rpl
operator|->
name|status
argument_list|,
name|GET_TID
argument_list|(
name|rpl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_set_tcb_rpl
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_set_tcb_rpl
modifier|*
name|rpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unexpected SET_TCB_RPL status %u for tid %u\n"
argument_list|,
name|rpl
operator|->
name|status
argument_list|,
name|GET_TID
argument_list|(
name|rpl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an ABORT_RPL_RSS CPL message.  */
end_comment

begin_function
specifier|static
name|int
name|do_abort_rpl
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
specifier|const
name|struct
name|cpl_abort_rpl_rss
modifier|*
name|rpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|rpl
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
comment|/* 	 * Ignore replies to post-close aborts indicating that the abort was 	 * requested too late.  These connections are terminated when we get 	 * PEER_CLOSE or CLOSE_CON_RPL and by the time the abort_rpl_rss 	 * arrives the TID is either no longer used or it has been recycled. 	 */
if|if
condition|(
name|rpl
operator|->
name|status
operator|==
name|CPL_ERR_ABORT_FAILED
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_IS_A_SYNQ_ENTRY
condition|)
return|return
operator|(
name|do_abort_rpl_synqe
argument_list|(
name|qs
argument_list|,
name|r
argument_list|,
name|m
argument_list|)
operator|)
return|;
name|CTR4
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: tid %d, toep %p, status %d"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|toep
argument_list|,
name|rpl
operator|->
name|status
argument_list|)
expr_stmt|;
name|inp
operator|=
name|toep
operator|->
name|tp_inp
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_RPL_PENDING
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_RPL_RCVD
operator|)
condition|)
block|{
name|toep
operator|->
name|tp_flags
operator||=
name|TP_ABORT_RPL_RCVD
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|toep
operator|->
name|tp_flags
operator|&=
operator|~
name|TP_ABORT_RPL_RCVD
expr_stmt|;
name|toep
operator|->
name|tp_flags
operator|&=
name|TP_ABORT_RPL_PENDING
expr_stmt|;
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
comment|/* no more CPLs expected */
block|}
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert the status code of an ABORT_REQ into a FreeBSD error code.  */
end_comment

begin_function
specifier|static
name|int
name|abort_status_to_errno
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|int
name|abort_reason
parameter_list|)
block|{
switch|switch
condition|(
name|abort_reason
condition|)
block|{
case|case
name|CPL_ERR_BAD_SYN
case|:
case|case
name|CPL_ERR_CONN_RESET
case|:
return|return
operator|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_CLOSE_WAIT
condition|?
name|EPIPE
else|:
name|ECONNRESET
operator|)
return|;
case|case
name|CPL_ERR_XMIT_TIMEDOUT
case|:
case|case
name|CPL_ERR_PERSIST_TIMEDOUT
case|:
case|case
name|CPL_ERR_FINWAIT2_TIMEDOUT
case|:
case|case
name|CPL_ERR_KEEPALIVE_TIMEDOUT
case|:
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns whether an ABORT_REQ_RSS message is a negative advice.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_neg_adv_abort
parameter_list|(
name|unsigned
name|int
name|status
parameter_list|)
block|{
return|return
name|status
operator|==
name|CPL_ERR_RTX_NEG_ADVICE
operator|||
name|status
operator|==
name|CPL_ERR_PERSIST_NEG_ADVICE
return|;
block|}
end_function

begin_function
name|void
name|send_abort_rpl
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|int
name|tid
parameter_list|,
name|int
name|qset
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|reply
decl_stmt|;
name|struct
name|cpl_abort_rpl
modifier|*
name|rpl
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|reply
operator|=
name|M_GETHDR_OFLD
argument_list|(
name|qset
argument_list|,
name|CPL_PRIORITY_DATA
argument_list|,
name|rpl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reply
condition|)
name|CXGB_UNIMPLEMENTED
argument_list|()
expr_stmt|;
name|rpl
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_OFLD_HOST_ABORT_CON_RPL
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|wr
operator|.
name|wrh_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|rpl
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_ABORT_RPL
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|cmd
operator|=
name|CPL_ABORT_NO_RST
expr_stmt|;
name|t3_offload_tx
argument_list|(
name|sc
argument_list|,
name|reply
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle an ABORT_REQ_RSS CPL message.  If we're waiting for an ABORT_RPL we  * ignore this request except that we need to reply to it.  */
end_comment

begin_function
specifier|static
name|int
name|do_abort_req
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
init|=
operator|&
name|td
operator|->
name|tod
decl_stmt|;
specifier|const
name|struct
name|cpl_abort_req_rss
modifier|*
name|req
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|qset
init|=
name|toep
operator|->
name|tp_qset
decl_stmt|;
if|if
condition|(
name|is_neg_adv_abort
argument_list|(
name|req
operator|->
name|status
argument_list|)
condition|)
block|{
name|CTR4
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: negative advice %d for tid %u (%x)"
argument_list|,
name|__func__
argument_list|,
name|req
operator|->
name|status
argument_list|,
name|tid
argument_list|,
name|toep
operator|->
name|tp_flags
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_IS_A_SYNQ_ENTRY
condition|)
return|return
operator|(
name|do_abort_req_synqe
argument_list|(
name|qs
argument_list|,
name|r
argument_list|,
name|m
argument_list|)
operator|)
return|;
name|inp
operator|=
name|toep
operator|->
name|tp_inp
expr_stmt|;
name|INP_INFO_WLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
comment|/* for tcp_close */
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: tid %u (%s), toep %p (%x), status %d"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
argument_list|,
name|toep
argument_list|,
name|toep
operator|->
name|tp_flags
argument_list|,
name|req
operator|->
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_REQ_RCVD
operator|)
condition|)
block|{
name|toep
operator|->
name|tp_flags
operator||=
name|TP_ABORT_REQ_RCVD
expr_stmt|;
name|toep
operator|->
name|tp_flags
operator||=
name|TP_ABORT_SHUTDOWN
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|toep
operator|->
name|tp_flags
operator|&=
operator|~
name|TP_ABORT_REQ_RCVD
expr_stmt|;
comment|/* 	 * If we'd sent a reset on this toep, we'll ignore this and clean up in 	 * the T3's reply to our reset instead. 	 */
if|if
condition|(
name|toep
operator|->
name|tp_flags
operator|&
name|TP_ABORT_RPL_PENDING
condition|)
block|{
name|toep
operator|->
name|tp_flags
operator||=
name|TP_ABORT_RPL_SENT
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|so_error_set
argument_list|(
name|so
argument_list|,
name|abort_status_to_errno
argument_list|(
name|tp
argument_list|,
name|req
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* re-acquire */
name|toepcb_release
argument_list|(
name|toep
argument_list|)
expr_stmt|;
comment|/* no more CPLs expected */
block|}
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|send_abort_rpl
argument_list|(
name|tod
argument_list|,
name|tid
argument_list|,
name|qset
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|assign_rxopt
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|uint16_t
name|tcpopt
parameter_list|)
block|{
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|toep
operator|->
name|tp_tod
operator|->
name|tod_softc
decl_stmt|;
name|tp
operator|->
name|t_maxseg
operator|=
name|tp
operator|->
name|t_maxopd
operator|=
name|sc
operator|->
name|params
operator|.
name|mtus
index|[
name|G_TCPOPT_MSS
argument_list|(
name|tcpopt
argument_list|)
index|]
operator|-
literal|40
expr_stmt|;
if|if
condition|(
name|G_TCPOPT_TSTAMP
argument_list|(
name|tcpopt
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_RCVD_TSTMP
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_REQ_TSTMP
expr_stmt|;
comment|/* forcibly set */
name|tp
operator|->
name|ts_recent
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|tp
operator|->
name|ts_recent_age
operator|=
name|tcp_ts_getticks
argument_list|()
expr_stmt|;
name|tp
operator|->
name|t_maxseg
operator|-=
name|TCPOLEN_TSTAMP_APPA
expr_stmt|;
block|}
if|if
condition|(
name|G_TCPOPT_SACK
argument_list|(
name|tcpopt
argument_list|)
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_SACK_PERMIT
expr_stmt|;
else|else
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_SACK_PERMIT
expr_stmt|;
if|if
condition|(
name|G_TCPOPT_WSCALE_OK
argument_list|(
name|tcpopt
argument_list|)
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_RCVD_SCALE
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
operator|)
operator|==
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
condition|)
block|{
name|tp
operator|->
name|rcv_scale
operator|=
name|tp
operator|->
name|request_r_scale
expr_stmt|;
name|tp
operator|->
name|snd_scale
operator|=
name|G_TCPOPT_SND_WSCALE
argument_list|(
name|tcpopt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The ISS and IRS are from after the exchange of SYNs and are off by 1.  */
end_comment

begin_function
name|void
name|make_established
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|uint32_t
name|cpl_iss
parameter_list|,
name|uint32_t
name|cpl_irs
parameter_list|,
name|uint16_t
name|cpl_tcpopt
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|long
name|bufsize
decl_stmt|;
name|uint32_t
name|iss
init|=
name|be32toh
argument_list|(
name|cpl_iss
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* true ISS */
name|uint32_t
name|irs
init|=
name|be32toh
argument_list|(
name|cpl_irs
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* true IRS */
name|uint16_t
name|tcpopt
init|=
name|be16toh
argument_list|(
name|cpl_tcpopt
argument_list|)
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
name|tp
operator|->
name|t_starttime
operator|=
name|ticks
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_connects
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s tid %u, toep %p, inp %p"
argument_list|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|toep
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|irs
operator|=
name|irs
expr_stmt|;
name|tcp_rcvseqinit
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|=
name|toep
operator|->
name|tp_rx_credits
operator|<<
literal|10
expr_stmt|;
name|tp
operator|->
name|rcv_adv
operator|+=
name|tp
operator|->
name|rcv_wnd
expr_stmt|;
name|tp
operator|->
name|last_ack_sent
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
comment|/* 	 * If we were unable to send all rx credits via opt0, save the remainder 	 * in rx_credits so that they can be handed over with the next credit 	 * update. 	 */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|bufsize
operator|=
name|select_rcv_wnd
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_rx_credits
operator|=
name|bufsize
operator|-
name|tp
operator|->
name|rcv_wnd
expr_stmt|;
name|tp
operator|->
name|iss
operator|=
name|iss
expr_stmt|;
name|tcp_sendseqinit
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_una
operator|=
name|iss
operator|+
literal|1
expr_stmt|;
name|tp
operator|->
name|snd_nxt
operator|=
name|iss
operator|+
literal|1
expr_stmt|;
name|tp
operator|->
name|snd_max
operator|=
name|iss
operator|+
literal|1
expr_stmt|;
name|assign_rxopt
argument_list|(
name|tp
argument_list|,
name|tcpopt
argument_list|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fill in the right TID for CPL messages waiting in the out-of-order queue  * and send them to the TOE.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_and_send_ofo
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
init|=
name|toep
operator|->
name|tp_tod
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|tp_inp
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|toep
operator|->
name|tp_tid
decl_stmt|;
name|inp_lock_assert
argument_list|(
name|inp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|toep
operator|->
name|out_of_order_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ofld_hdr
modifier|*
name|oh
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
comment|/* 		 * A variety of messages can be waiting but the fields we'll 		 * be touching are common to all so any message type will do. 		 */
name|struct
name|cpl_close_con_req
modifier|*
name|p
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|oh
operator|+
literal|1
operator|)
decl_stmt|;
name|p
operator|->
name|wr
operator|.
name|wrh_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|p
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|p
operator|->
name|ot
operator|.
name|opcode
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|t3_offload_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process a CPL_ACT_ESTABLISH message.  */
end_comment

begin_function
specifier|static
name|int
name|do_act_establish
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|struct
name|cpl_act_establish
modifier|*
name|req
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|atid
init|=
name|G_PASS_OPEN_TID
argument_list|(
name|ntohl
argument_list|(
name|req
operator|->
name|tos_tid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_atid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|atid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|tp_inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: atid %u, tid %u"
argument_list|,
name|__func__
argument_list|,
name|atid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|free_atid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tp_qset
operator|==
name|qs
operator|->
name|idx
argument_list|,
operator|(
literal|"%s qset mismatch %d %d"
operator|,
name|__func__
operator|,
name|toep
operator|->
name|tp_qset
operator|,
name|qs
operator|->
name|idx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|toep
operator|->
name|tp_tid
operator|==
name|atid
argument_list|,
operator|(
literal|"%s atid mismatch %d %d"
operator|,
name|__func__
operator|,
name|toep
operator|->
name|tp_tid
operator|,
name|atid
operator|)
argument_list|)
expr_stmt|;
name|toep
operator|->
name|tp_tid
operator|=
name|tid
expr_stmt|;
name|insert_tid
argument_list|(
name|td
argument_list|,
name|toep
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
condition|)
block|{
comment|/* socket closed by the kernel before hw told us it connected */
name|send_reset
argument_list|(
name|toep
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|KASSERT
argument_list|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_SENT
argument_list|,
operator|(
literal|"TID %u expected TCPS_SYN_SENT, found %d."
operator|,
name|tid
operator|,
name|tp
operator|->
name|t_state
operator|)
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
name|make_established
argument_list|(
name|so
argument_list|,
name|req
operator|->
name|snd_isn
argument_list|,
name|req
operator|->
name|rcv_isn
argument_list|,
name|req
operator|->
name|tcp_opt
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we finally have a TID send any CPL messages that we had to 	 * defer for lack of a TID. 	 */
if|if
condition|(
name|mbufq_len
argument_list|(
operator|&
name|toep
operator|->
name|out_of_order_queue
argument_list|)
condition|)
name|fixup_and_send_ofo
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|done
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an acknowledgment of WR completion.  Advance snd_una and send the  * next batch of work requests from the write queue.  */
end_comment

begin_function
specifier|static
name|void
name|wr_ack
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|toep
operator|->
name|tp_inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|cpl_wr_ack
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|unsigned
name|int
name|credits
init|=
name|ntohs
argument_list|(
name|hdr
operator|->
name|credits
argument_list|)
decl_stmt|;
name|u32
name|snd_una
init|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|snd_una
argument_list|)
decl_stmt|;
name|int
name|bytes
init|=
literal|0
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|snd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|p
decl_stmt|;
name|struct
name|ofld_hdr
modifier|*
name|oh
decl_stmt|;
name|inp_wlock
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
name|toep
operator|->
name|tp_wr_avail
operator|+=
name|credits
expr_stmt|;
if|if
condition|(
name|toep
operator|->
name|tp_wr_unacked
operator|>
name|toep
operator|->
name|tp_wr_max
operator|-
name|toep
operator|->
name|tp_wr_avail
condition|)
name|toep
operator|->
name|tp_wr_unacked
operator|=
name|toep
operator|->
name|tp_wr_max
operator|-
name|toep
operator|->
name|tp_wr_avail
expr_stmt|;
while|while
condition|(
name|credits
condition|)
block|{
name|p
operator|=
name|peek_wr
argument_list|(
name|toep
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|p
argument_list|)
condition|)
block|{
name|CTR5
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: %u extra WR_ACK credits, "
literal|"tid %u, state %u, wr_avail %u"
argument_list|,
name|__func__
argument_list|,
name|credits
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|tp
operator|->
name|t_state
argument_list|,
name|toep
operator|->
name|tp_wr_avail
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%u WR_ACK credits for TID %u with "
literal|"nothing pending, state %u wr_avail=%u\n"
argument_list|,
name|credits
argument_list|,
name|toep
operator|->
name|tp_tid
argument_list|,
name|tp
operator|->
name|t_state
argument_list|,
name|toep
operator|->
name|tp_wr_avail
argument_list|)
expr_stmt|;
break|break;
block|}
name|oh
operator|=
name|mtod
argument_list|(
name|p
argument_list|,
expr|struct
name|ofld_hdr
operator|*
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|credits
operator|>=
name|G_HDR_NDESC
argument_list|(
name|oh
operator|->
name|flags
argument_list|)
argument_list|,
operator|(
literal|"%s: partial credits?  %d %d"
operator|,
name|__func__
operator|,
name|credits
operator|,
name|G_HDR_NDESC
argument_list|(
name|oh
operator|->
name|flags
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|dequeue_wr
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|credits
operator|-=
name|G_HDR_NDESC
argument_list|(
name|oh
operator|->
name|flags
argument_list|)
expr_stmt|;
name|bytes
operator|+=
name|oh
operator|->
name|plen
expr_stmt|;
if|if
condition|(
name|oh
operator|->
name|flags
operator|&
name|F_HDR_SGL
condition|)
name|sglist_free
argument_list|(
name|oh
operator|->
name|sgl
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|SEQ_LT
argument_list|(
name|snd_una
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
argument_list|)
condition|)
goto|goto
name|out_free
goto|;
if|if
condition|(
name|tp
operator|->
name|snd_una
operator|!=
name|snd_una
condition|)
block|{
name|tp
operator|->
name|snd_una
operator|=
name|snd_una
expr_stmt|;
name|tp
operator|->
name|ts_recent_age
operator|=
name|tcp_ts_getticks
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|snd_una
operator|==
name|tp
operator|->
name|snd_nxt
condition|)
name|toep
operator|->
name|tp_flags
operator|&=
operator|~
name|TP_TX_WAIT_IDLE
expr_stmt|;
block|}
name|snd
operator|=
name|so_sockbuf_snd
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
name|snd
argument_list|)
expr_stmt|;
name|sbdrop_locked
argument_list|(
name|snd
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|so_sowwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|snd
operator|->
name|sb_sndptroff
operator|<
name|snd
operator|->
name|sb_cc
condition|)
name|t3_push_frames
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out_free
label|:
name|inp_wunlock
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handler for TX_DATA_ACK CPL messages.  */
end_comment

begin_function
specifier|static
name|int
name|do_wr_ack
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|struct
name|cpl_wr_ack
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|hdr
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|tid
argument_list|)
decl_stmt|;
comment|/* XXX bad race */
if|if
condition|(
name|toep
condition|)
name|wr_ack
argument_list|(
name|toep
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_init_cpl_io
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_ACT_ESTABLISH
argument_list|,
name|do_act_establish
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_ACT_OPEN_RPL
argument_list|,
name|do_act_open_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_RX_URG_NOTIFY
argument_list|,
name|do_rx_urg_notify
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_RX_DATA
argument_list|,
name|do_rx_data
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_TX_DMA_ACK
argument_list|,
name|do_wr_ack
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_PEER_CLOSE
argument_list|,
name|do_peer_close
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_ABORT_REQ_RSS
argument_list|,
name|do_abort_req
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_ABORT_RPL_RSS
argument_list|,
name|do_abort_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_CLOSE_CON_RPL
argument_list|,
name|do_close_con_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_SMT_WRITE_RPL
argument_list|,
name|do_smt_write_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_SET_TCB_RPL
argument_list|,
name|do_set_tcb_rpl
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

