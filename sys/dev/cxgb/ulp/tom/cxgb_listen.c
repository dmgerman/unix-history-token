begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockstate.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_osdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/sys/mbufq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_offload.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/t3cdev.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_firmware_exports.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_t3_cpl.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_tcb.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_ctl_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_offload.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/toecore/cxgb_toedev.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tom.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_t3_ddp.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_toepcb.h>
end_include

begin_function_decl
specifier|static
name|struct
name|listen_info
modifier|*
name|listen_hash_add
parameter_list|(
name|struct
name|tom_data
modifier|*
name|d
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|unsigned
name|int
name|stid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|listen_hash_del
parameter_list|(
name|struct
name|tom_data
modifier|*
name|d
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Process a CPL_CLOSE_LISTSRV_RPL message.  If the status is good we release  * the STID.  */
end_comment

begin_function
specifier|static
name|int
name|do_close_server_rpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|cpl_close_listserv_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|stid
init|=
name|GET_TID
argument_list|(
name|rpl
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unexpected CLOSE_LISTSRV_RPL status %u for "
literal|"STID %u\n"
argument_list|,
name|rpl
operator|->
name|status
argument_list|,
name|stid
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|listen_ctx
modifier|*
name|listen_ctx
init|=
operator|(
expr|struct
name|listen_ctx
operator|*
operator|)
name|ctx
decl_stmt|;
name|cxgb_free_stid
argument_list|(
name|cdev
argument_list|,
name|stid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|listen_ctx
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|CPL_RET_BUF_DONE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a CPL_PASS_OPEN_RPL message.  Remove the socket from the listen hash  * table and free the STID if there was any error, otherwise nothing to do.  */
end_comment

begin_function
specifier|static
name|int
name|do_pass_open_rpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|cpl_pass_open_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
block|{
name|int
name|stid
init|=
name|GET_TID
argument_list|(
name|rpl
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|listen_ctx
init|=
operator|(
expr|struct
name|listen_ctx
operator|*
operator|)
name|ctx
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|d
init|=
name|listen_ctx
operator|->
name|tom_data
decl_stmt|;
name|struct
name|socket
modifier|*
name|lso
init|=
name|listen_ctx
operator|->
name|lso
decl_stmt|;
if|#
directive|if
name|VALIDATE_TID
if|if
condition|(
operator|!
name|lso
condition|)
return|return
operator|(
name|CPL_RET_UNKNOWN_TID
operator||
name|CPL_RET_BUF_DONE
operator|)
return|;
endif|#
directive|endif
comment|/* 		 * Note: It is safe to unconditionally call listen_hash_del() 		 * at this point without risking unhashing a reincarnation of 		 * an already closed socket (i.e., there is no listen, close, 		 * listen, free the sock for the second listen while processing 		 * a message for the first race) because we are still holding 		 * a reference on the socket.  It is possible that the unhash 		 * will fail because the socket is already closed, but we can't 		 * unhash the wrong socket because it is impossible for the 		 * socket to which this message refers to have reincarnated. 		 */
name|listen_hash_del
argument_list|(
name|d
argument_list|,
name|lso
argument_list|)
expr_stmt|;
name|cxgb_free_stid
argument_list|(
name|cdev
argument_list|,
name|stid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 		 * XXX need to unreference the inpcb 		 * but we have no way of knowing that other TOMs aren't referencing it  		 */
name|sock_put
argument_list|(
name|lso
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|listen_ctx
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
block|}
return|return
name|CPL_RET_BUF_DONE
return|;
block|}
end_function

begin_function
name|void
name|t3_init_listen_cpl_handlers
parameter_list|(
name|void
parameter_list|)
block|{
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_PASS_OPEN_RPL
argument_list|,
name|do_pass_open_rpl
argument_list|)
expr_stmt|;
name|t3tom_register_cpl_handler
argument_list|(
name|CPL_CLOSE_LISTSRV_RPL
argument_list|,
name|do_close_server_rpl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|listen_hashfn
parameter_list|(
specifier|const
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
operator|(
name|unsigned
name|long
operator|)
name|so
operator|>>
literal|10
operator|)
operator|&
operator|(
name|LISTEN_INFO_HASH_SIZE
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create and add a listen_info entry to the listen hash table.  This and the  * listen hash table functions below cannot be called from softirqs.  */
end_comment

begin_function
specifier|static
name|struct
name|listen_info
modifier|*
name|listen_hash_add
parameter_list|(
name|struct
name|tom_data
modifier|*
name|d
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|unsigned
name|int
name|stid
parameter_list|)
block|{
name|struct
name|listen_info
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|M_CXGB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|int
name|bucket
init|=
name|listen_hashfn
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|p
operator|->
name|so
operator|=
name|so
expr_stmt|;
comment|/* just a key, no need to take a reference */
name|p
operator|->
name|stid
operator|=
name|stid
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|listen_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|d
operator|->
name|listen_hash_tab
index|[
name|bucket
index|]
expr_stmt|;
name|d
operator|->
name|listen_hash_tab
index|[
name|bucket
index|]
operator|=
name|p
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|listen_lock
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Given a pointer to a listening socket return its server TID by consulting  * the socket->stid map.  Returns -1 if the socket is not in the map.  */
end_comment

begin_function
specifier|static
name|int
name|listen_hash_find
parameter_list|(
name|struct
name|tom_data
modifier|*
name|d
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|int
name|stid
init|=
operator|-
literal|1
decl_stmt|,
name|bucket
init|=
name|listen_hashfn
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|listen_info
modifier|*
name|p
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|listen_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|d
operator|->
name|listen_hash_tab
index|[
name|bucket
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|so
operator|==
name|so
condition|)
block|{
name|stid
operator|=
name|p
operator|->
name|stid
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|listen_lock
argument_list|)
expr_stmt|;
return|return
name|stid
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the listen_info structure for a listening socket.  Returns the server  * TID for the socket if it is present in the socket->stid map, or -1.  */
end_comment

begin_function
specifier|static
name|int
name|listen_hash_del
parameter_list|(
name|struct
name|tom_data
modifier|*
name|d
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|int
name|bucket
decl_stmt|,
name|stid
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|listen_info
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|bucket
operator|=
name|listen_hashfn
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|&
name|d
operator|->
name|listen_hash_tab
index|[
name|bucket
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|listen_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|prev
init|;
name|p
condition|;
name|prev
operator|=
operator|&
name|p
operator|->
name|next
operator|,
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|so
operator|==
name|so
condition|)
block|{
name|stid
operator|=
name|p
operator|->
name|stid
expr_stmt|;
operator|*
name|prev
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|listen_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|stid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start a listening server by sending a passive open request to HW.  */
end_comment

begin_function
name|void
name|t3_listen_start
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|)
block|{
name|int
name|stid
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cpl_pass_open_req
modifier|*
name|req
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|d
init|=
name|TOM_DATA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|so_sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
operator|!
name|TOM_TUNABLE
argument_list|(
name|dev
argument_list|,
name|activated
argument_list|)
condition|)
return|return;
if|if
condition|(
name|listen_hash_find
argument_list|(
name|d
argument_list|,
name|so
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return;
name|CTR1
argument_list|(
name|KTR_TOM
argument_list|,
literal|"start listen on port %u"
argument_list|,
name|ntohs
argument_list|(
name|inp
operator|->
name|inp_lport
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|,
name|M_CXGB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return;
name|ctx
operator|->
name|tom_data
operator|=
name|d
expr_stmt|;
name|ctx
operator|->
name|lso
operator|=
name|so
expr_stmt|;
name|ctx
operator|->
name|ulp_mode
operator|=
name|TOM_TUNABLE
argument_list|(
name|dev
argument_list|,
name|ddp
argument_list|)
operator|&&
operator|!
operator|(
name|so_options_get
argument_list|(
name|so
argument_list|)
operator|&
name|SO_NO_DDP
operator|)
condition|?
name|ULP_MODE_TCPDDP
else|:
literal|0
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ctx
operator|->
name|synq_head
argument_list|)
expr_stmt|;
name|stid
operator|=
name|cxgb_alloc_stid
argument_list|(
name|d
operator|->
name|cdev
argument_list|,
name|d
operator|->
name|client
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|stid
operator|<
literal|0
condition|)
goto|goto
name|free_ctx
goto|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|free_stid
goto|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|listen_hash_add
argument_list|(
name|d
argument_list|,
name|so
argument_list|,
name|stid
argument_list|)
condition|)
goto|goto
name|free_all
goto|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_pass_open_req
operator|*
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_PASS_OPEN_REQ
argument_list|,
name|stid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|local_port
operator|=
name|inp
operator|->
name|inp_lport
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|req
operator|->
name|local_ip
argument_list|,
operator|&
name|inp
operator|->
name|inp_laddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|req
operator|->
name|peer_port
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|peer_ip
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|peer_netmask
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|opt0h
operator|=
name|htonl
argument_list|(
name|F_DELACK
operator||
name|F_TCAM_BYPASS
argument_list|)
expr_stmt|;
name|req
operator|->
name|opt0l
operator|=
name|htonl
argument_list|(
name|V_RCV_BUFSIZ
argument_list|(
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|opt1
operator|=
name|htonl
argument_list|(
name|V_CONN_POLICY
argument_list|(
name|CPL_CONN_POLICY_ASK
argument_list|)
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|CPL_PRIORITY_LISTEN
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|cdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
name|free_all
label|:
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|free_stid
label|:
name|cxgb_free_stid
argument_list|(
name|cdev
argument_list|,
name|stid
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|sock_put(sk);
endif|#
directive|endif
name|free_ctx
label|:
name|free
argument_list|(
name|ctx
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop a listening server by sending a close_listsvr request to HW.  * The server TID is freed when we get the reply.  */
end_comment

begin_function
name|void
name|t3_listen_stop
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|t3cdev
modifier|*
name|cdev
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cpl_close_listserv_req
modifier|*
name|req
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|;
name|int
name|stid
init|=
name|listen_hash_del
argument_list|(
name|TOM_DATA
argument_list|(
name|dev
argument_list|)
argument_list|,
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|stid
operator|<
literal|0
condition|)
return|return;
name|lctx
operator|=
name|cxgb_get_lctx
argument_list|(
name|cdev
argument_list|,
name|stid
argument_list|)
expr_stmt|;
comment|/* 	 * Do this early so embryonic connections are marked as being aborted 	 * while the stid is still open.  This ensures pass_establish messages 	 * that arrive while we are closing the server will be able to locate 	 * the listening socket. 	 */
name|t3_reset_synq
argument_list|(
name|lctx
argument_list|)
expr_stmt|;
comment|/* Send the close ASAP to stop further passive opens */
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * XXX allocate from lowmem cache 		 */
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_close_listserv_req
operator|*
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_CLOSE_LISTSRV_REQ
argument_list|,
name|stid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|cpu_idx
operator|=
literal|0
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|CPL_PRIORITY_LISTEN
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|cdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|t3_disconnect_acceptq
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

