begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_verbs.h>
end_include

begin_include
include|#
directive|include
file|<linux/idr.h>
end_include

begin_include
include|#
directive|include
file|<ulp/iw_cxgb/iw_cxgb_ib_intfc.h>
end_include

begin_include
include|#
directive|include
file|<cxgb_include.h>
end_include

begin_include
include|#
directive|include
file|<ulp/tom/cxgb_tom.h>
end_include

begin_include
include|#
directive|include
file|<ulp/tom/cxgb_toepcb.h>
end_include

begin_include
include|#
directive|include
file|<ulp/iw_cxgb/iw_cxgb_ib_intfc.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_verbs.h>
end_include

begin_include
include|#
directive|include
file|<linux/idr.h>
end_include

begin_include
include|#
directive|include
file|<ulp/iw_cxgb/iw_cxgb_wr.h>
end_include

begin_include
include|#
directive|include
file|<ulp/iw_cxgb/iw_cxgb_hal.h>
end_include

begin_include
include|#
directive|include
file|<ulp/iw_cxgb/iw_cxgb_provider.h>
end_include

begin_include
include|#
directive|include
file|<ulp/iw_cxgb/iw_cxgb_cm.h>
end_include

begin_include
include|#
directive|include
file|<ulp/iw_cxgb/iw_cxgb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|states
index|[]
init|=
block|{
literal|"idle"
block|,
literal|"listen"
block|,
literal|"connecting"
block|,
literal|"mpa_wait_req"
block|,
literal|"mpa_req_sent"
block|,
literal|"mpa_req_rcvd"
block|,
literal|"mpa_rep_sent"
block|,
literal|"fpdu_mode"
block|,
literal|"aborting"
block|,
literal|"closing"
block|,
literal|"moribund"
block|,
literal|"dead"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|iw_cxgb
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"iw_cxgb driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ep_timeout_secs
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgb.ep_timeout_secs"
argument_list|,
operator|&
name|ep_timeout_secs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|ep_timeout_secs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ep_timeout_secs
argument_list|,
literal|0
argument_list|,
literal|"CM Endpoint operation timeout in seconds (default=60)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mpa_rev
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgb.mpa_rev"
argument_list|,
operator|&
name|mpa_rev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|mpa_rev
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mpa_rev
argument_list|,
literal|0
argument_list|,
literal|"MPA Revision, 0 supports amso1100, 1 is spec compliant. (default=1)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|markers_enabled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgb.markers_enabled"
argument_list|,
operator|&
name|markers_enabled
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|markers_enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|markers_enabled
argument_list|,
literal|0
argument_list|,
literal|"Enable MPA MARKERS (default(0)=disabled)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|crc_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgb.crc_enabled"
argument_list|,
operator|&
name|crc_enabled
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|crc_enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|crc_enabled
argument_list|,
literal|0
argument_list|,
literal|"Enable MPA CRC (default(1)=enabled)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|rcv_win
init|=
literal|256
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgb.rcv_win"
argument_list|,
operator|&
name|rcv_win
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|rcv_win
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|rcv_win
argument_list|,
literal|0
argument_list|,
literal|"TCP receive window in bytes (default=256KB)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|snd_win
init|=
literal|32
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgb.snd_win"
argument_list|,
operator|&
name|snd_win
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_iw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|snd_win
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|snd_win
argument_list|,
literal|0
argument_list|,
literal|"TCP send window in bytes (default=32KB)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|nocong
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgb.nocong"
argument_list|,
operator|&
name|nocong
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_iw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|nocong
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nocong
argument_list|,
literal|0
argument_list|,
literal|"Turn off congestion control (default=0)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|cong_flavor
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iw_cxgb.cong_flavor"
argument_list|,
operator|&
name|cong_flavor
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_iw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|cong_flavor
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cong_flavor
argument_list|,
literal|0
argument_list|,
literal|"TCP Congestion control flavor (default=1)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|ep_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|connect_reply_upcall
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwch_so_upcall
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|waitflag
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Cruft to offload socket upcalls onto thread.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|req_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|iwch_ep_list
argument_list|,
argument|iwch_ep_common
argument_list|)
name|req_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|task
name|iw_cxgb_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|taskqueue
modifier|*
name|iw_cxgb_taskq
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|process_req
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|start_ep_timer
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|ep
operator|->
name|timer
argument_list|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s stopped / restarted timer ep %p"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|callout_deactivate
argument_list|(
operator|&
name|ep
operator|->
name|timer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ep
operator|->
name|timer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * XXX this looks racy 		 */
name|get_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|ep
operator|->
name|timer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|ep
operator|->
name|timer
argument_list|,
name|ep_timeout_secs
operator|*
name|hz
argument_list|,
name|ep_timeout
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stop_ep_timer
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callout_pending
argument_list|(
operator|&
name|ep
operator|->
name|timer
argument_list|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s timer stopped when its not running!  ep %p state %u\n"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
name|callout_drain
argument_list|(
operator|&
name|ep
operator|->
name|timer
argument_list|)
expr_stmt|;
name|put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_tcpinfo
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|ep
operator|->
name|com
operator|.
name|so
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_TOE
operator|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
name|printf
argument_list|(
literal|"%s: connection NOT OFFLOADED!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|toep
operator|=
name|tp
operator|->
name|t_toe
expr_stmt|;
name|ep
operator|->
name|hwtid
operator|=
name|toep
operator|->
name|tp_tid
expr_stmt|;
name|ep
operator|->
name|snd_seq
operator|=
name|tp
operator|->
name|snd_nxt
expr_stmt|;
name|ep
operator|->
name|rcv_seq
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|ep
operator|->
name|emss
operator|=
name|tp
operator|->
name|t_maxseg
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|emss
operator|<
literal|128
condition|)
name|ep
operator|->
name|emss
operator|=
literal|128
expr_stmt|;
name|done
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|iwch_ep_state
name|state_read
parameter_list|(
name|struct
name|iwch_ep_common
modifier|*
name|epc
parameter_list|)
block|{
name|enum
name|iwch_ep_state
name|state
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|epc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|state
operator|=
name|epc
operator|->
name|state
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|epc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|state
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__state_set
parameter_list|(
name|struct
name|iwch_ep_common
modifier|*
name|epc
parameter_list|,
name|enum
name|iwch_ep_state
name|new
parameter_list|)
block|{
name|epc
operator|->
name|state
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|state_set
parameter_list|(
name|struct
name|iwch_ep_common
modifier|*
name|epc
parameter_list|,
name|enum
name|iwch_ep_state
name|new
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|epc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s - %s -> %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|states
index|[
name|epc
operator|->
name|state
index|]
argument_list|,
name|states
index|[
name|new
index|]
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
name|epc
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|epc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|alloc_ep
parameter_list|(
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|iwch_ep_common
modifier|*
name|epc
decl_stmt|;
name|epc
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|epc
condition|)
block|{
name|memset
argument_list|(
name|epc
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|epc
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|epc
operator|->
name|lock
argument_list|,
literal|"iwch_epc lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|epc
operator|->
name|waitq
argument_list|,
literal|"iwch_epc cv"
argument_list|)
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s alloc ep %p"
argument_list|,
name|__FUNCTION__
argument_list|,
name|epc
argument_list|)
expr_stmt|;
return|return
name|epc
return|;
block|}
end_function

begin_function
name|void
name|__free_ep
parameter_list|(
name|struct
name|iwch_ep_common
modifier|*
name|epc
parameter_list|)
block|{
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|epc
argument_list|,
name|states
index|[
name|state_read
argument_list|(
name|epc
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|epc
operator|->
name|entry
operator|.
name|tqe_prev
argument_list|,
operator|(
literal|"%s epc %p still on req list!\n"
operator|,
name|__FUNCTION__
operator|,
name|epc
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|epc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|rtentry
modifier|*
name|find_route
parameter_list|(
name|__be32
name|local_ip
parameter_list|,
name|__be32
name|peer_ip
parameter_list|,
name|__be16
name|local_port
parameter_list|,
name|__be16
name|peer_port
parameter_list|,
name|u8
name|tos
parameter_list|)
block|{
name|struct
name|route
name|iproute
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|dst
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|iproute
operator|.
name|ro_dst
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|iproute
argument_list|,
sizeof|sizeof
name|iproute
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|dst
operator|->
name|sin_len
operator|=
sizeof|sizeof
expr|*
name|dst
expr_stmt|;
name|dst
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|peer_ip
expr_stmt|;
name|rtalloc
argument_list|(
operator|&
name|iproute
argument_list|)
expr_stmt|;
return|return
name|iproute
operator|.
name|ro_rt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_socket
parameter_list|(
name|struct
name|iwch_ep_common
modifier|*
name|epc
parameter_list|,
name|int
name|close
parameter_list|)
block|{
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|epc
argument_list|,
name|epc
operator|->
name|so
argument_list|,
name|states
index|[
name|epc
operator|->
name|state
index|]
argument_list|)
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|epc
operator|->
name|so
argument_list|)
expr_stmt|;
name|soupcall_clear
argument_list|(
name|epc
operator|->
name|so
argument_list|,
name|SO_RCV
argument_list|)
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|epc
operator|->
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
condition|)
name|soclose
argument_list|(
name|epc
operator|->
name|so
argument_list|)
expr_stmt|;
else|else
name|soshutdown
argument_list|(
name|epc
operator|->
name|so
argument_list|,
name|SHUT_WR
operator||
name|SHUT_RD
argument_list|)
expr_stmt|;
name|epc
operator|->
name|so
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|shutdown_socket
parameter_list|(
name|struct
name|iwch_ep_common
modifier|*
name|epc
parameter_list|)
block|{
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|epc
argument_list|,
name|epc
operator|->
name|so
argument_list|,
name|states
index|[
name|epc
operator|->
name|state
index|]
argument_list|)
expr_stmt|;
name|soshutdown
argument_list|(
name|epc
operator|->
name|so
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|abort_socket
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|linger
name|l
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
name|l
operator|.
name|l_onoff
operator|=
literal|1
expr_stmt|;
name|l
operator|.
name|l_linger
operator|=
literal|0
expr_stmt|;
comment|/* linger_time of 0 forces RST to be sent */
name|sopt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|SO_LINGER
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|l
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
name|l
expr_stmt|;
name|sopt
operator|.
name|sopt_td
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|sosetopt
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|printf
argument_list|(
literal|"%s can't set linger to 0, no RST! err %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_mpa_req
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|int
name|mpalen
decl_stmt|;
name|struct
name|mpa_message
modifier|*
name|mpa
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|err
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p pd_len %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|plen
argument_list|)
expr_stmt|;
name|mpalen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|+
name|ep
operator|->
name|plen
expr_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|mpalen
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|connect_reply_upcall
argument_list|(
name|ep
argument_list|,
operator|-
name|ENOMEM
argument_list|)
expr_stmt|;
return|return;
block|}
name|mpa
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|mpa_message
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|mpalen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mpalen
expr_stmt|;
name|memset
argument_list|(
name|mpa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mpa
operator|->
name|key
argument_list|,
name|MPA_KEY_REQ
argument_list|,
sizeof|sizeof
argument_list|(
name|mpa
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|mpa
operator|->
name|flags
operator|=
operator|(
name|crc_enabled
condition|?
name|MPA_CRC
else|:
literal|0
operator|)
operator||
operator|(
name|markers_enabled
condition|?
name|MPA_MARKERS
else|:
literal|0
operator|)
expr_stmt|;
name|mpa
operator|->
name|private_data_size
operator|=
name|htons
argument_list|(
name|ep
operator|->
name|plen
argument_list|)
expr_stmt|;
name|mpa
operator|->
name|revision
operator|=
name|mpa_rev
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|plen
condition|)
name|memcpy
argument_list|(
name|mpa
operator|->
name|private_data
argument_list|,
name|ep
operator|->
name|mpa_pkt
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
argument_list|,
name|ep
operator|->
name|plen
argument_list|)
expr_stmt|;
name|err
operator|=
name|sosend
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|MSG_DONTWAIT
argument_list|,
name|ep
operator|->
name|com
operator|.
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|connect_reply_upcall
argument_list|(
name|ep
argument_list|,
operator|-
name|ENOMEM
argument_list|)
expr_stmt|;
return|return;
block|}
name|start_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|MPA_REQ_SENT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|send_mpa_reject
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|,
specifier|const
name|void
modifier|*
name|pdata
parameter_list|,
name|u8
name|plen
parameter_list|)
block|{
name|int
name|mpalen
decl_stmt|;
name|struct
name|mpa_message
modifier|*
name|mpa
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|err
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p plen %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|mpalen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|+
name|plen
expr_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|mpalen
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s - cannot alloc mbuf!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|mpa
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|mpa_message
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|mpalen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mpalen
expr_stmt|;
name|memset
argument_list|(
name|mpa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mpa
operator|->
name|key
argument_list|,
name|MPA_KEY_REP
argument_list|,
sizeof|sizeof
argument_list|(
name|mpa
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|mpa
operator|->
name|flags
operator|=
name|MPA_REJECT
expr_stmt|;
name|mpa
operator|->
name|revision
operator|=
name|mpa_rev
expr_stmt|;
name|mpa
operator|->
name|private_data_size
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
condition|)
name|memcpy
argument_list|(
name|mpa
operator|->
name|private_data
argument_list|,
name|pdata
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|err
operator|=
name|sosend
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|MSG_DONTWAIT
argument_list|,
name|ep
operator|->
name|com
operator|.
name|thread
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_mpa_reply
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|,
specifier|const
name|void
modifier|*
name|pdata
parameter_list|,
name|u8
name|plen
parameter_list|)
block|{
name|int
name|mpalen
decl_stmt|;
name|struct
name|mpa_message
modifier|*
name|mpa
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p plen %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|mpalen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|+
name|plen
expr_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|mpalen
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s - cannot alloc mbuf!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|mpa
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|mpa_message
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|mpalen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mpalen
expr_stmt|;
name|memset
argument_list|(
name|mpa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mpa
operator|->
name|key
argument_list|,
name|MPA_KEY_REP
argument_list|,
sizeof|sizeof
argument_list|(
name|mpa
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|mpa
operator|->
name|flags
operator|=
operator|(
name|ep
operator|->
name|mpa_attr
operator|.
name|crc_enabled
condition|?
name|MPA_CRC
else|:
literal|0
operator|)
operator||
operator|(
name|markers_enabled
condition|?
name|MPA_MARKERS
else|:
literal|0
operator|)
expr_stmt|;
name|mpa
operator|->
name|revision
operator|=
name|mpa_rev
expr_stmt|;
name|mpa
operator|->
name|private_data_size
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
condition|)
name|memcpy
argument_list|(
name|mpa
operator|->
name|private_data
argument_list|,
name|pdata
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|MPA_REP_SENT
argument_list|)
expr_stmt|;
return|return
name|sosend
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|MSG_DONTWAIT
argument_list|,
name|ep
operator|->
name|com
operator|.
name|thread
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_complete_upcall
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|iw_cm_event
name|event
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|event
operator|=
name|IW_CM_EVENT_CLOSE
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"close complete delivered ep %p cm_id %p tid %d"
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
name|ep
operator|->
name|hwtid
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|event_handler
argument_list|(
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|rem_ref
argument_list|(
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|=
name|NULL
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|qp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|abort_connection
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|ABORTING
argument_list|)
expr_stmt|;
name|abort_socket
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|close_socket
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close_complete_upcall
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|DEAD
argument_list|)
expr_stmt|;
name|put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|peer_close_upcall
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|iw_cm_event
name|event
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|event
operator|=
name|IW_CM_EVENT_DISCONNECT
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"peer close delivered ep %p cm_id %p tid %d"
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
name|ep
operator|->
name|hwtid
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|event_handler
argument_list|(
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|peer_abort_upcall
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|iw_cm_event
name|event
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|event
operator|=
name|IW_CM_EVENT_CLOSE
expr_stmt|;
name|event
operator|.
name|status
operator|=
name|ECONNRESET
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"abort delivered ep %p cm_id %p tid %d"
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
name|ep
operator|->
name|hwtid
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|event_handler
argument_list|(
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|rem_ref
argument_list|(
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|=
name|NULL
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|qp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|connect_reply_upcall
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|iw_cm_event
name|event
decl_stmt|;
name|CTR5
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s status %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|event
operator|=
name|IW_CM_EVENT_CONNECT_REPLY
expr_stmt|;
name|event
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|event
operator|.
name|local_addr
operator|=
name|ep
operator|->
name|com
operator|.
name|local_addr
expr_stmt|;
name|event
operator|.
name|remote_addr
operator|=
name|ep
operator|->
name|com
operator|.
name|remote_addr
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
literal|0
operator|)
operator|||
operator|(
name|status
operator|==
name|ECONNREFUSED
operator|)
condition|)
block|{
name|event
operator|.
name|private_data_len
operator|=
name|ep
operator|->
name|plen
expr_stmt|;
name|event
operator|.
name|private_data
operator|=
name|ep
operator|->
name|mpa_pkt
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
condition|)
block|{
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p tid %d status %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|hwtid
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|event_handler
argument_list|(
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|rem_ref
argument_list|(
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|=
name|NULL
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|qp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|connect_request_upcall
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|iw_cm_event
name|event
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|event
operator|=
name|IW_CM_EVENT_CONNECT_REQUEST
expr_stmt|;
name|event
operator|.
name|local_addr
operator|=
name|ep
operator|->
name|com
operator|.
name|local_addr
expr_stmt|;
name|event
operator|.
name|remote_addr
operator|=
name|ep
operator|->
name|com
operator|.
name|remote_addr
expr_stmt|;
name|event
operator|.
name|private_data_len
operator|=
name|ep
operator|->
name|plen
expr_stmt|;
name|event
operator|.
name|private_data
operator|=
name|ep
operator|->
name|mpa_pkt
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_message
argument_list|)
expr_stmt|;
name|event
operator|.
name|provider_data
operator|=
name|ep
expr_stmt|;
name|event
operator|.
name|so
operator|=
name|ep
operator|->
name|com
operator|.
name|so
expr_stmt|;
if|if
condition|(
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|parent_ep
operator|->
name|com
argument_list|)
operator|!=
name|DEAD
condition|)
block|{
name|get_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|ep
operator|->
name|parent_ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|event_handler
argument_list|(
name|ep
operator|->
name|parent_ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
name|put_ep
argument_list|(
operator|&
name|ep
operator|->
name|parent_ep
operator|->
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|established_upcall
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|iw_cm_event
name|event
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|event
operator|=
name|IW_CM_EVENT_ESTABLISHED
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p tid %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|hwtid
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|->
name|event_handler
argument_list|(
name|ep
operator|->
name|com
operator|.
name|cm_id
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|process_mpa_reply
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|mpa_message
modifier|*
name|mpa
decl_stmt|;
name|u16
name|plen
decl_stmt|;
name|struct
name|iwch_qp_attributes
name|attrs
decl_stmt|;
name|enum
name|iwch_qp_attr_mask
name|mask
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|flags
init|=
name|MSG_DONTWAIT
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|int
name|len
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Stop mpa timer.  If it expired, then the state has 	 * changed and we bail since ep_timeout already aborted 	 * the connection. 	 */
name|stop_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
operator|!=
name|MPA_REQ_SENT
condition|)
return|return;
name|uio
operator|.
name|uio_resid
operator|=
name|len
operator|=
literal|1000000
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|ep
operator|->
name|com
operator|.
name|thread
expr_stmt|;
name|err
operator|=
name|soreceive
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|NULL
argument_list|,
operator|&
name|uio
argument_list|,
operator|&
name|top
argument_list|,
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|start_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
name|err
operator|=
operator|-
name|err
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
condition|)
block|{
name|printf
argument_list|(
literal|"%s data after soreceive called! so %p sb_mb %p top %p\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|top
expr_stmt|;
do|do
block|{
comment|/* 		 * If we get more than the supported amount of private data 		 * then we must fail this connection. 		 */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|+
name|m
operator|->
name|m_len
operator|>
sizeof|sizeof
argument_list|(
name|ep
operator|->
name|mpa_pkt
argument_list|)
condition|)
block|{
name|err
operator|=
operator|(
operator|-
name|EINVAL
operator|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 		 * copy the new data into our accumulation buffer. 		 */
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
operator|&
operator|(
name|ep
operator|->
name|mpa_pkt
index|[
name|ep
operator|->
name|mpa_pkt_len
index|]
operator|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mpa_pkt_len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|m_next
condition|)
name|m
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
else|else
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
do|while
condition|(
name|m
condition|)
do|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
comment|/* 	 * if we don't even have the mpa message, then bail. 	 */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
condition|)
return|return;
name|mpa
operator|=
operator|(
expr|struct
name|mpa_message
operator|*
operator|)
name|ep
operator|->
name|mpa_pkt
expr_stmt|;
comment|/* Validate MPA header. */
if|if
condition|(
name|mpa
operator|->
name|revision
operator|!=
name|mpa_rev
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s bad mpa rev %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|mpa
operator|->
name|revision
argument_list|)
expr_stmt|;
name|err
operator|=
name|EPROTO
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|mpa
operator|->
name|key
argument_list|,
name|MPA_KEY_REP
argument_list|,
sizeof|sizeof
argument_list|(
name|mpa
operator|->
name|key
argument_list|)
argument_list|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s bad mpa key |%16s|"
argument_list|,
name|__FUNCTION__
argument_list|,
name|mpa
operator|->
name|key
argument_list|)
expr_stmt|;
name|err
operator|=
name|EPROTO
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|plen
operator|=
name|ntohs
argument_list|(
name|mpa
operator|->
name|private_data_size
argument_list|)
expr_stmt|;
comment|/* 	 * Fail if there's too much private data. 	 */
if|if
condition|(
name|plen
operator|>
name|MPA_MAX_PRIVATE_DATA
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s plen too big %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|err
operator|=
name|EPROTO
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * If plen does not account for pkt size 	 */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|>
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|+
name|plen
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s pkt too big %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
operator|->
name|mpa_pkt_len
argument_list|)
expr_stmt|;
name|err
operator|=
name|EPROTO
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ep
operator|->
name|plen
operator|=
operator|(
name|u8
operator|)
name|plen
expr_stmt|;
comment|/* 	 * If we don't have all the pdata yet, then bail. 	 * We'll continue process when more data arrives. 	 */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|+
name|plen
operator|)
condition|)
return|return;
if|if
condition|(
name|mpa
operator|->
name|flags
operator|&
name|MPA_REJECT
condition|)
block|{
name|err
operator|=
name|ECONNREFUSED
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * If we get here we have accumulated the entire mpa 	 * start reply message including private data. And 	 * the MPA header is valid. 	 */
name|CTR1
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s mpa rpl looks good!"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|FPDU_MODE
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|initiator
operator|=
literal|1
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|crc_enabled
operator|=
operator|(
name|mpa
operator|->
name|flags
operator|&
name|MPA_CRC
operator|)
operator||
name|crc_enabled
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|recv_marker_enabled
operator|=
name|markers_enabled
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|xmit_marker_enabled
operator|=
name|mpa
operator|->
name|flags
operator|&
name|MPA_MARKERS
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|version
operator|=
name|mpa_rev
expr_stmt|;
if|if
condition|(
name|set_tcpinfo
argument_list|(
name|ep
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s set_tcpinfo error\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|CTR5
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s - crc_enabled=%d, recv_marker_enabled=%d, "
literal|"xmit_marker_enabled=%d, version=%d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|crc_enabled
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|recv_marker_enabled
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|xmit_marker_enabled
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|version
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|mpa_attr
operator|=
name|ep
operator|->
name|mpa_attr
expr_stmt|;
name|attrs
operator|.
name|max_ird
operator|=
name|ep
operator|->
name|ird
expr_stmt|;
name|attrs
operator|.
name|max_ord
operator|=
name|ep
operator|->
name|ord
expr_stmt|;
name|attrs
operator|.
name|llp_stream_handle
operator|=
name|ep
expr_stmt|;
name|attrs
operator|.
name|next_state
operator|=
name|IWCH_QP_STATE_RTS
expr_stmt|;
name|mask
operator|=
name|IWCH_QP_ATTR_NEXT_STATE
operator||
name|IWCH_QP_ATTR_LLP_STREAM_HANDLE
operator||
name|IWCH_QP_ATTR_MPA_ATTR
operator||
name|IWCH_QP_ATTR_MAX_IRD
operator||
name|IWCH_QP_ATTR_MAX_ORD
expr_stmt|;
comment|/* bind QP and TID with INIT_WR */
name|err
operator|=
name|iwch_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|rhp
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|mask
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
goto|goto
name|out
goto|;
name|err
label|:
name|abort_connection
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|out
label|:
name|connect_reply_upcall
argument_list|(
name|ep
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|process_mpa_request
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|mpa_message
modifier|*
name|mpa
decl_stmt|;
name|u16
name|plen
decl_stmt|;
name|int
name|flags
init|=
name|MSG_DONTWAIT
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|int
name|len
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Stop mpa timer.  If it expired, then the state has 	 * changed and we bail since ep_timeout already aborted 	 * the connection. 	 */
name|stop_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
operator|!=
name|MPA_REQ_WAIT
condition|)
return|return;
name|uio
operator|.
name|uio_resid
operator|=
name|len
operator|=
literal|1000000
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|ep
operator|->
name|com
operator|.
name|thread
expr_stmt|;
name|err
operator|=
name|soreceive
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|NULL
argument_list|,
operator|&
name|uio
argument_list|,
operator|&
name|top
argument_list|,
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|start_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
name|err
operator|=
operator|-
name|err
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|m
operator|=
name|top
expr_stmt|;
do|do
block|{
comment|/* 		 * If we get more than the supported amount of private data 		 * then we must fail this connection. 		 */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|+
name|m
operator|->
name|m_len
operator|>
sizeof|sizeof
argument_list|(
name|ep
operator|->
name|mpa_pkt
argument_list|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s mpa message too big %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
operator|->
name|mpa_pkt_len
operator|+
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 		 * Copy the new data into our accumulation buffer. 		 */
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
operator|&
operator|(
name|ep
operator|->
name|mpa_pkt
index|[
name|ep
operator|->
name|mpa_pkt_len
index|]
operator|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mpa_pkt_len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|m_next
condition|)
name|m
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
else|else
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
do|while
condition|(
name|m
condition|)
do|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't even have the mpa message, then bail. 	 * We'll continue process when more data arrives. 	 */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
condition|)
block|{
name|start_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s not enough header %d...waiting..."
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
operator|->
name|mpa_pkt_len
argument_list|)
expr_stmt|;
return|return;
block|}
name|mpa
operator|=
operator|(
expr|struct
name|mpa_message
operator|*
operator|)
name|ep
operator|->
name|mpa_pkt
expr_stmt|;
comment|/* 	 * Validate MPA Header. 	 */
if|if
condition|(
name|mpa
operator|->
name|revision
operator|!=
name|mpa_rev
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s bad mpa rev %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|mpa
operator|->
name|revision
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|mpa
operator|->
name|key
argument_list|,
name|MPA_KEY_REQ
argument_list|,
sizeof|sizeof
argument_list|(
name|mpa
operator|->
name|key
argument_list|)
argument_list|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s bad mpa key |%16s|"
argument_list|,
name|__FUNCTION__
argument_list|,
name|mpa
operator|->
name|key
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|plen
operator|=
name|ntohs
argument_list|(
name|mpa
operator|->
name|private_data_size
argument_list|)
expr_stmt|;
comment|/* 	 * Fail if there's too much private data. 	 */
if|if
condition|(
name|plen
operator|>
name|MPA_MAX_PRIVATE_DATA
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s plen too big %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * If plen does not account for pkt size 	 */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|>
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|+
name|plen
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s more data after private data %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
operator|->
name|mpa_pkt_len
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ep
operator|->
name|plen
operator|=
operator|(
name|u8
operator|)
name|plen
expr_stmt|;
comment|/* 	 * If we don't have all the pdata yet, then bail. 	 */
if|if
condition|(
name|ep
operator|->
name|mpa_pkt_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|mpa
argument_list|)
operator|+
name|plen
operator|)
condition|)
block|{
name|start_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s more mpa msg to come %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
operator|->
name|mpa_pkt_len
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we get here we have accumulated the entire mpa 	 * start reply message including private data. 	 */
name|ep
operator|->
name|mpa_attr
operator|.
name|initiator
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|crc_enabled
operator|=
operator|(
name|mpa
operator|->
name|flags
operator|&
name|MPA_CRC
operator|)
operator||
name|crc_enabled
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|recv_marker_enabled
operator|=
name|markers_enabled
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|xmit_marker_enabled
operator|=
name|mpa
operator|->
name|flags
operator|&
name|MPA_MARKERS
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ep
operator|->
name|mpa_attr
operator|.
name|version
operator|=
name|mpa_rev
expr_stmt|;
if|if
condition|(
name|set_tcpinfo
argument_list|(
name|ep
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s set_tcpinfo error\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|CTR5
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s - crc_enabled=%d, recv_marker_enabled=%d, "
literal|"xmit_marker_enabled=%d, version=%d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|crc_enabled
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|recv_marker_enabled
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|xmit_marker_enabled
argument_list|,
name|ep
operator|->
name|mpa_attr
operator|.
name|version
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|MPA_REQ_RCVD
argument_list|)
expr_stmt|;
comment|/* drive upcall */
name|connect_request_upcall
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
name|err
label|:
name|abort_connection
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|process_peer_close
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|iwch_qp_attributes
name|attrs
decl_stmt|;
name|int
name|disconnect
init|=
literal|1
decl_stmt|;
name|int
name|release
init|=
literal|0
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|com
operator|.
name|state
condition|)
block|{
case|case
name|MPA_REQ_WAIT
case|:
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|CLOSING
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REQ_SENT
case|:
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|CLOSING
argument_list|)
expr_stmt|;
name|connect_reply_upcall
argument_list|(
name|ep
argument_list|,
operator|-
name|ECONNRESET
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REQ_RCVD
case|:
comment|/* 		 * We're gonna mark this puppy DEAD, but keep 		 * the reference on it until the ULP accepts or 		 * rejects the CR. 		 */
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|CLOSING
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REP_SENT
case|:
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|CLOSING
argument_list|)
expr_stmt|;
break|break;
case|case
name|FPDU_MODE
case|:
name|start_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|CLOSING
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|next_state
operator|=
name|IWCH_QP_STATE_CLOSING
expr_stmt|;
name|iwch_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|rhp
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|IWCH_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|peer_close_upcall
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABORTING
case|:
name|disconnect
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLOSING
case|:
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|MORIBUND
argument_list|)
expr_stmt|;
name|disconnect
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MORIBUND
case|:
name|stop_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|&&
name|ep
operator|->
name|com
operator|.
name|qp
condition|)
block|{
name|attrs
operator|.
name|next_state
operator|=
name|IWCH_QP_STATE_IDLE
expr_stmt|;
name|iwch_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|rhp
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|IWCH_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|close_socket
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close_complete_upcall
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|DEAD
argument_list|)
expr_stmt|;
name|release
operator|=
literal|1
expr_stmt|;
name|disconnect
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DEAD
case|:
name|disconnect
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|PANIC_IF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|disconnect
condition|)
name|iwch_ep_disconnect
argument_list|(
name|ep
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|release
condition|)
name|put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|process_conn_error
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|iwch_qp_attributes
name|attrs
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|lock
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p state %u"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|com
operator|.
name|state
condition|)
block|{
case|case
name|MPA_REQ_WAIT
case|:
name|stop_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REQ_SENT
case|:
name|stop_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|connect_reply_upcall
argument_list|(
name|ep
argument_list|,
operator|-
name|ECONNRESET
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REP_SENT
case|:
name|ep
operator|->
name|com
operator|.
name|rpl_err
operator|=
name|ECONNRESET
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"waking up ep %p"
argument_list|,
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REQ_RCVD
case|:
comment|/* 		 * We're gonna mark this puppy DEAD, but keep 		 * the reference on it until the ULP accepts or 		 * rejects the CR. 		 */
break|break;
case|case
name|MORIBUND
case|:
case|case
name|CLOSING
case|:
name|stop_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|FPDU_MODE
case|:
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|&&
name|ep
operator|->
name|com
operator|.
name|qp
condition|)
block|{
name|attrs
operator|.
name|next_state
operator|=
name|IWCH_QP_STATE_ERROR
expr_stmt|;
name|ret
operator|=
name|iwch_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|rhp
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|IWCH_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s - qp<- error failed!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
name|peer_abort_upcall
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABORTING
case|:
break|break;
case|case
name|DEAD
case|:
name|mtx_unlock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|lock
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s so_error %d IN DEAD STATE!!!!"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_error
argument_list|)
expr_stmt|;
return|return;
default|default:
name|PANIC_IF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|state
operator|!=
name|ABORTING
condition|)
block|{
name|close_socket
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|DEAD
argument_list|)
expr_stmt|;
name|put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|process_close_complete
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|iwch_qp_attributes
name|attrs
decl_stmt|;
name|int
name|release
init|=
literal|0
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
operator|!
name|ep
argument_list|)
expr_stmt|;
comment|/* The cm_id may be null if we failed to connect */
name|mtx_lock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|com
operator|.
name|state
condition|)
block|{
case|case
name|CLOSING
case|:
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|MORIBUND
argument_list|)
expr_stmt|;
break|break;
case|case
name|MORIBUND
case|:
name|stop_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|)
operator|&&
operator|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|)
condition|)
block|{
name|attrs
operator|.
name|next_state
operator|=
name|IWCH_QP_STATE_IDLE
expr_stmt|;
name|iwch_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|rhp
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|IWCH_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|parent_ep
condition|)
name|close_socket
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|close_socket
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close_complete_upcall
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|DEAD
argument_list|)
expr_stmt|;
name|release
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ABORTING
case|:
break|break;
case|case
name|DEAD
case|:
default|default:
name|PANIC_IF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|release
condition|)
name|put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * T3A does 3 things when a TERM is received:  * 1) send up a CPL_RDMA_TERMINATE message with the TERM packet  * 2) generate an async event on the QP with the TERMINATE opcode  * 3) post a TERMINATE opcde cqe into the associated CQ.  *  * For (1), we save the message in the qp for later consumer consumption.  * For (2), we move the QP into TERMINATE, post a QP event and disconnect.  * For (3), we toss the CQE in cxio_poll_cq().  *  * terminate() handles case (1)...  */
end_comment

begin_function
specifier|static
name|int
name|terminate
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|uint32_t
name|hash
init|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|r
operator|+
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|ntohl
argument_list|(
name|hash
argument_list|)
operator|>>
literal|8
operator|&
literal|0xfffff
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|toep
operator|->
name|tp_inp
operator|->
name|inp_socket
decl_stmt|;
name|struct
name|iwch_ep
modifier|*
name|ep
init|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_upcallarg
decl_stmt|;
if|if
condition|(
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
operator|!=
name|FPDU_MODE
condition|)
goto|goto
name|done
goto|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_rdma_terminate
argument_list|)
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s: tid %u, ep %p, saved %d bytes"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|ep
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|attr
operator|.
name|terminate_buffer
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|attr
operator|.
name|terminate_msg_len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|attr
operator|.
name|is_terminate_local
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ec_status
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|struct
name|cpl_rdma_ec_status
modifier|*
name|rep
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|rep
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|lookup_tid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|toep
operator|->
name|tp_inp
operator|->
name|inp_socket
decl_stmt|;
name|struct
name|iwch_ep
modifier|*
name|ep
init|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_upcallarg
decl_stmt|;
if|if
condition|(
name|rep
operator|->
name|status
condition|)
block|{
name|struct
name|iwch_qp_attributes
name|attrs
decl_stmt|;
name|CTR1
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s BAD CLOSE - Aborting"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|stop_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|next_state
operator|=
name|IWCH_QP_STATE_ERROR
expr_stmt|;
name|iwch_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|rhp
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|IWCH_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|abort_connection
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ep_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwch_ep
modifier|*
name|ep
init|=
operator|(
expr|struct
name|iwch_ep
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|iwch_qp_attributes
name|attrs
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|abort
init|=
literal|1
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|lock
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|com
operator|.
name|state
condition|)
block|{
case|case
name|MPA_REQ_SENT
case|:
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|ABORTING
argument_list|)
expr_stmt|;
name|connect_reply_upcall
argument_list|(
name|ep
argument_list|,
operator|-
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REQ_WAIT
case|:
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|ABORTING
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOSING
case|:
case|case
name|MORIBUND
case|:
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|&&
name|ep
operator|->
name|com
operator|.
name|qp
condition|)
name|err
operator|=
literal|1
expr_stmt|;
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|ABORTING
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s unexpected state ep %p state %u\n"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|state
argument_list|)
expr_stmt|;
name|abort
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|attrs
operator|.
name|next_state
operator|=
name|IWCH_QP_STATE_ERROR
expr_stmt|;
name|iwch_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|rhp
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|IWCH_QP_ATTR_NEXT_STATE
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abort
condition|)
name|abort_connection
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwch_reject_cr
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
specifier|const
name|void
modifier|*
name|pdata
parameter_list|,
name|u8
name|pdata_len
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|iwch_ep
modifier|*
name|ep
init|=
name|to_ep
argument_list|(
name|cm_id
argument_list|)
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
operator|==
name|DEAD
condition|)
block|{
name|put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ECONNRESET
operator|)
return|;
block|}
name|PANIC_IF
argument_list|(
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
operator|!=
name|MPA_REQ_RCVD
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpa_rev
operator|==
literal|0
condition|)
block|{
name|abort_connection
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|send_mpa_reject
argument_list|(
name|ep
argument_list|,
name|pdata
argument_list|,
name|pdata_len
argument_list|)
expr_stmt|;
name|err
operator|=
name|soshutdown
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwch_accept_cr
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|struct
name|iw_cm_conn_param
modifier|*
name|conn_param
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|iwch_qp_attributes
name|attrs
decl_stmt|;
name|enum
name|iwch_qp_attr_mask
name|mask
decl_stmt|;
name|struct
name|iwch_ep
modifier|*
name|ep
init|=
name|to_ep
argument_list|(
name|cm_id
argument_list|)
decl_stmt|;
name|struct
name|iwch_dev
modifier|*
name|h
init|=
name|to_iwch_dev
argument_list|(
name|cm_id
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|iwch_qp
modifier|*
name|qp
init|=
name|get_qhp
argument_list|(
name|h
argument_list|,
name|conn_param
operator|->
name|qpn
argument_list|)
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
operator|==
name|DEAD
condition|)
block|{
name|err
operator|=
operator|-
name|ECONNRESET
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|PANIC_IF
argument_list|(
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
operator|!=
name|MPA_REQ_RCVD
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
operator|!
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|conn_param
operator|->
name|ord
operator|>
name|qp
operator|->
name|rhp
operator|->
name|attr
operator|.
name|max_rdma_read_qp_depth
operator|)
operator|||
operator|(
name|conn_param
operator|->
name|ird
operator|>
name|qp
operator|->
name|rhp
operator|->
name|attr
operator|.
name|max_rdma_reads_per_qp
operator|)
condition|)
block|{
name|abort_connection
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|cm_id
operator|->
name|add_ref
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|=
name|cm_id
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|qp
operator|=
name|qp
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|rpl_err
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|rpl_done
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|ird
operator|=
name|conn_param
operator|->
name|ird
expr_stmt|;
name|ep
operator|->
name|ord
operator|=
name|conn_param
operator|->
name|ord
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ird %d ord %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
operator|->
name|ird
argument_list|,
name|ep
operator|->
name|ord
argument_list|)
expr_stmt|;
comment|/* bind QP to EP and move to RTS */
name|attrs
operator|.
name|mpa_attr
operator|=
name|ep
operator|->
name|mpa_attr
expr_stmt|;
name|attrs
operator|.
name|max_ird
operator|=
name|ep
operator|->
name|ird
expr_stmt|;
name|attrs
operator|.
name|max_ord
operator|=
name|ep
operator|->
name|ord
expr_stmt|;
name|attrs
operator|.
name|llp_stream_handle
operator|=
name|ep
expr_stmt|;
name|attrs
operator|.
name|next_state
operator|=
name|IWCH_QP_STATE_RTS
expr_stmt|;
comment|/* bind QP and TID with INIT_WR */
name|mask
operator|=
name|IWCH_QP_ATTR_NEXT_STATE
operator||
name|IWCH_QP_ATTR_LLP_STREAM_HANDLE
operator||
name|IWCH_QP_ATTR_MPA_ATTR
operator||
name|IWCH_QP_ATTR_MAX_IRD
operator||
name|IWCH_QP_ATTR_MAX_ORD
expr_stmt|;
name|err
operator|=
name|iwch_modify_qp
argument_list|(
name|ep
operator|->
name|com
operator|.
name|qp
operator|->
name|rhp
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|mask
argument_list|,
operator|&
name|attrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err1
goto|;
name|err
operator|=
name|send_mpa_reply
argument_list|(
name|ep
argument_list|,
name|conn_param
operator|->
name|private_data
argument_list|,
name|conn_param
operator|->
name|private_data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err1
goto|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|FPDU_MODE
argument_list|)
expr_stmt|;
name|established_upcall
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err1
label|:
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|=
name|NULL
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|qp
operator|=
name|NULL
expr_stmt|;
name|cm_id
operator|->
name|rem_ref
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
name|err
label|:
name|put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_sock
parameter_list|(
name|struct
name|iwch_ep_common
modifier|*
name|epc
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
name|SOCK_LOCK
argument_list|(
name|epc
operator|->
name|so
argument_list|)
expr_stmt|;
name|soupcall_set
argument_list|(
name|epc
operator|->
name|so
argument_list|,
name|SO_RCV
argument_list|,
name|iwch_so_upcall
argument_list|,
name|epc
argument_list|)
expr_stmt|;
name|epc
operator|->
name|so
operator|->
name|so_state
operator||=
name|SS_NBIO
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|epc
operator|->
name|so
argument_list|)
expr_stmt|;
name|sopt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|TCP_NODELAY
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|on
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
name|on
expr_stmt|;
name|sopt
operator|.
name|sopt_td
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|sosetopt
argument_list|(
name|epc
operator|->
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|printf
argument_list|(
literal|"%s can't set TCP_NODELAY err %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_loopback_dst
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|)
block|{
name|uint16_t
name|port
init|=
name|cm_id
operator|->
name|remote_addr
operator|.
name|sin_port
decl_stmt|;
name|int
name|ifa_present
decl_stmt|;
name|cm_id
operator|->
name|remote_addr
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
name|ifa_present
operator|=
name|ifa_ifwithaddr_check
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|cm_id
operator|->
name|remote_addr
argument_list|)
expr_stmt|;
name|cm_id
operator|->
name|remote_addr
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
return|return
operator|(
name|ifa_present
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iwch_connect
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|struct
name|iw_cm_conn_param
modifier|*
name|conn_param
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|iwch_dev
modifier|*
name|h
init|=
name|to_iwch_dev
argument_list|(
name|cm_id
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|iwch_ep
modifier|*
name|ep
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tdev
decl_stmt|;
if|if
condition|(
name|is_loopback_dst
argument_list|(
name|cm_id
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|ENOSYS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ep
operator|=
name|alloc_ep
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
block|{
name|printf
argument_list|(
literal|"%s - cannot alloc ep.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|-
name|ENOMEM
operator|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|callout_init
argument_list|(
operator|&
name|ep
operator|->
name|timer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ep
operator|->
name|plen
operator|=
name|conn_param
operator|->
name|private_data_len
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|plen
condition|)
name|memcpy
argument_list|(
name|ep
operator|->
name|mpa_pkt
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mpa_message
argument_list|)
argument_list|,
name|conn_param
operator|->
name|private_data
argument_list|,
name|ep
operator|->
name|plen
argument_list|)
expr_stmt|;
name|ep
operator|->
name|ird
operator|=
name|conn_param
operator|->
name|ird
expr_stmt|;
name|ep
operator|->
name|ord
operator|=
name|conn_param
operator|->
name|ord
expr_stmt|;
name|cm_id
operator|->
name|add_ref
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|=
name|cm_id
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|qp
operator|=
name|get_qhp
argument_list|(
name|h
argument_list|,
name|conn_param
operator|->
name|qpn
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|thread
operator|=
name|curthread
expr_stmt|;
name|PANIC_IF
argument_list|(
operator|!
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s qpn 0x%x qp %p cm_id %p"
argument_list|,
name|__FUNCTION__
argument_list|,
name|conn_param
operator|->
name|qpn
argument_list|,
name|ep
operator|->
name|com
operator|.
name|qp
argument_list|,
name|cm_id
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|so
operator|=
name|cm_id
operator|->
name|so
expr_stmt|;
name|err
operator|=
name|init_sock
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|fail2
goto|;
comment|/* find a route */
name|rt
operator|=
name|find_route
argument_list|(
name|cm_id
operator|->
name|local_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|cm_id
operator|->
name|remote_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|cm_id
operator|->
name|local_addr
operator|.
name|sin_port
argument_list|,
name|cm_id
operator|->
name|remote_addr
operator|.
name|sin_port
argument_list|,
name|IPTOS_LOWDELAY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rt
condition|)
block|{
name|printf
argument_list|(
literal|"%s - cannot find route.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|err
operator|=
name|EHOSTUNREACH
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|rt
operator|->
name|rt_ifp
operator|->
name|if_flags
operator|&
name|IFCAP_TOE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s - interface not TOE capable.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|tdev
operator|=
name|TOEDEV
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdev
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s - No toedev for interface.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|CONNECTING
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|local_addr
operator|=
name|cm_id
operator|->
name|local_addr
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|remote_addr
operator|=
name|cm_id
operator|->
name|remote_addr
expr_stmt|;
name|err
operator|=
name|soconnect
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ep
operator|->
name|com
operator|.
name|remote_addr
argument_list|,
name|ep
operator|->
name|com
operator|.
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
goto|goto
name|out
goto|;
name|fail2
label|:
name|put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|iwch_create_listen_ep
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|int
name|backlog
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|iwch_listen_ep
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|alloc_ep
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
block|{
name|printf
argument_list|(
literal|"%s - cannot alloc ep.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|cm_id
operator|->
name|add_ref
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|cm_id
operator|=
name|cm_id
expr_stmt|;
name|ep
operator|->
name|backlog
operator|=
name|backlog
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|local_addr
operator|=
name|cm_id
operator|->
name|local_addr
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|thread
operator|=
name|curthread
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|LISTEN
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|so
operator|=
name|cm_id
operator|->
name|so
expr_stmt|;
name|cm_id
operator|->
name|provider_data
operator|=
name|ep
expr_stmt|;
name|out
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|iwch_destroy_listen_ep
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|)
block|{
name|struct
name|iwch_listen_ep
modifier|*
name|ep
init|=
name|to_listen_ep
argument_list|(
name|cm_id
argument_list|)
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|DEAD
argument_list|)
expr_stmt|;
name|cm_id
operator|->
name|rem_ref
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
name|put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|iwch_ep_disconnect
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|,
name|int
name|abrupt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|close
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|lock
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
operator|!
name|ep
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
operator|!
name|ep
operator|->
name|com
operator|.
name|so
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s, abrupt %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|,
name|abrupt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|com
operator|.
name|state
condition|)
block|{
case|case
name|MPA_REQ_WAIT
case|:
case|case
name|MPA_REQ_SENT
case|:
case|case
name|MPA_REQ_RCVD
case|:
case|case
name|MPA_REP_SENT
case|:
case|case
name|FPDU_MODE
case|:
name|close
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|abrupt
condition|)
name|ep
operator|->
name|com
operator|.
name|state
operator|=
name|ABORTING
expr_stmt|;
else|else
block|{
name|ep
operator|->
name|com
operator|.
name|state
operator|=
name|CLOSING
expr_stmt|;
name|start_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLOSING
case|:
name|close
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|abrupt
condition|)
block|{
name|stop_ep_timer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|state
operator|=
name|ABORTING
expr_stmt|;
block|}
else|else
name|ep
operator|->
name|com
operator|.
name|state
operator|=
name|MORIBUND
expr_stmt|;
break|break;
case|case
name|MORIBUND
case|:
case|case
name|ABORTING
case|:
case|case
name|DEAD
case|:
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ignoring disconnect ep %p state %u\n"
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|state
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unknown state: %d\n"
argument_list|,
name|ep
operator|->
name|com
operator|.
name|state
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ep
operator|->
name|com
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
condition|)
block|{
if|if
condition|(
name|abrupt
condition|)
name|abort_connection
argument_list|(
name|ep
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|ep
operator|->
name|parent_ep
condition|)
name|__state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|MORIBUND
argument_list|)
expr_stmt|;
name|shutdown_socket
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_data
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|local
decl_stmt|,
modifier|*
name|remote
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
condition|)
block|{
case|case
name|MPA_REQ_SENT
case|:
name|process_mpa_reply
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPA_REQ_WAIT
case|:
comment|/* 		 * XXX 		 * Set local and remote addrs here because when we 		 * dequeue the newly accepted socket, they aren't set 		 * yet in the pcb! 		 */
name|in_getsockaddr
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
operator|&
name|local
argument_list|)
expr_stmt|;
name|in_getpeeraddr
argument_list|(
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
operator|&
name|remote
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s local %s remote %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|inet_ntoa
argument_list|(
name|local
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|inet_ntoa
argument_list|(
name|remote
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|local_addr
operator|=
operator|*
name|local
expr_stmt|;
name|ep
operator|->
name|com
operator|.
name|remote_addr
operator|=
operator|*
name|remote
expr_stmt|;
name|free
argument_list|(
name|local
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remote
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|process_mpa_request
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
condition|)
name|printf
argument_list|(
literal|"%s Unexpected streaming data."
literal|" ep %p state %d so %p so_state %x so_rcv.sb_cc %u so_rcv.sb_mb %p\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_state
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|process_connected
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|CTR4
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s ep %p so %p state %s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|so
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|&&
operator|!
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_error
condition|)
block|{
name|send_mpa_req
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|connect_reply_upcall
argument_list|(
name|ep
argument_list|,
operator|-
name|ep
operator|->
name|com
operator|.
name|so
operator|->
name|so_error
argument_list|)
expr_stmt|;
name|close_socket
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|,
name|DEAD
argument_list|)
expr_stmt|;
name|put_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|process_newconn
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|parent_cm_id
parameter_list|,
name|struct
name|socket
modifier|*
name|child_so
parameter_list|)
block|{
name|struct
name|iwch_ep
modifier|*
name|child_ep
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|local
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|remote
decl_stmt|;
name|struct
name|iwch_ep
modifier|*
name|parent_ep
init|=
name|parent_cm_id
operator|->
name|provider_data
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s parent ep %p so %p"
argument_list|,
name|__FUNCTION__
argument_list|,
name|parent_ep
argument_list|,
name|parent_ep
operator|->
name|com
operator|.
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|child_so
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s - invalid child socket!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|child_ep
operator|=
name|alloc_ep
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|child_ep
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|child_ep
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s - failed to allocate ep entry!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|child_so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|soupcall_set
argument_list|(
name|child_so
argument_list|,
name|SO_RCV
argument_list|,
name|iwch_so_upcall
argument_list|,
name|child_ep
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|child_so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|in_getsockaddr
argument_list|(
name|child_so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
operator|&
name|local
argument_list|)
expr_stmt|;
name|in_getpeeraddr
argument_list|(
name|child_so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
operator|&
name|remote
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s remote addr %s port %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|inet_ntoa
argument_list|(
name|remote
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|remote
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|tdev
operator|=
name|parent_ep
operator|->
name|com
operator|.
name|tdev
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|local_addr
operator|.
name|sin_family
operator|=
name|parent_ep
operator|->
name|com
operator|.
name|local_addr
operator|.
name|sin_family
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|local_addr
operator|.
name|sin_port
operator|=
name|parent_ep
operator|->
name|com
operator|.
name|local_addr
operator|.
name|sin_port
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|local_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|parent_ep
operator|->
name|com
operator|.
name|local_addr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|local_addr
operator|.
name|sin_len
operator|=
name|parent_ep
operator|->
name|com
operator|.
name|local_addr
operator|.
name|sin_len
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|remote_addr
operator|.
name|sin_family
operator|=
name|remote
operator|->
name|sin_family
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|remote_addr
operator|.
name|sin_port
operator|=
name|remote
operator|->
name|sin_port
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|remote_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|remote
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|remote_addr
operator|.
name|sin_len
operator|=
name|remote
operator|->
name|sin_len
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|so
operator|=
name|child_so
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|cm_id
operator|=
name|NULL
expr_stmt|;
name|child_ep
operator|->
name|com
operator|.
name|thread
operator|=
name|parent_ep
operator|->
name|com
operator|.
name|thread
expr_stmt|;
name|child_ep
operator|->
name|parent_ep
operator|=
name|parent_ep
expr_stmt|;
name|free
argument_list|(
name|local
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remote
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|get_ep
argument_list|(
operator|&
name|parent_ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|child_ep
operator|->
name|timer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|state_set
argument_list|(
operator|&
name|child_ep
operator|->
name|com
argument_list|,
name|MPA_REQ_WAIT
argument_list|)
expr_stmt|;
name|start_ep_timer
argument_list|(
name|child_ep
argument_list|)
expr_stmt|;
comment|/* maybe the request has already been queued up on the socket... */
name|process_mpa_request
argument_list|(
name|child_ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwch_so_upcall
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|waitflag
parameter_list|)
block|{
name|struct
name|iwch_ep
modifier|*
name|ep
init|=
name|arg
decl_stmt|;
name|CTR6
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s so %p so state %x ep %p ep state(%d)=%s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|so
argument_list|,
name|so
operator|->
name|so_state
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|state
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|req_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|&&
name|ep
operator|->
name|com
operator|.
name|so
operator|&&
operator|!
name|ep
operator|->
name|com
operator|.
name|entry
operator|.
name|tqe_prev
condition|)
block|{
name|get_ep
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|req_list
argument_list|,
operator|&
name|ep
operator|->
name|com
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|iw_cxgb_taskq
argument_list|,
operator|&
name|iw_cxgb_task
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|req_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SU_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_socket_event
parameter_list|(
name|struct
name|iwch_ep
modifier|*
name|ep
parameter_list|)
block|{
name|int
name|state
init|=
name|state_read
argument_list|(
operator|&
name|ep
operator|->
name|com
argument_list|)
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|ep
operator|->
name|com
operator|.
name|so
decl_stmt|;
name|CTR6
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s so %p so state %x ep %p ep state(%d)=%s"
argument_list|,
name|__FUNCTION__
argument_list|,
name|so
argument_list|,
name|so
operator|->
name|so_state
argument_list|,
name|ep
argument_list|,
name|ep
operator|->
name|com
operator|.
name|state
argument_list|,
name|states
index|[
name|ep
operator|->
name|com
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|CONNECTING
condition|)
block|{
name|process_connected
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|state
operator|==
name|LISTEN
condition|)
block|{
comment|/* socket listening events are handled at IWCM */
name|CTR3
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s Invalid ep state:%u, ep:%p"
argument_list|,
name|__func__
argument_list|,
name|ep
operator|->
name|com
operator|.
name|state
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|BUG
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* connection error */
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|process_conn_error
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* peer close */
if|if
condition|(
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
operator|)
operator|&&
name|state
operator|<
name|CLOSING
condition|)
block|{
name|process_peer_close
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* close complete */
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISDISCONNECTED
operator|)
condition|)
block|{
name|process_close_complete
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* rx data */
name|process_data
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|process_req
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|iwch_ep_common
modifier|*
name|epc
decl_stmt|;
name|CTR1
argument_list|(
name|KTR_IW_CXGB
argument_list|,
literal|"%s enter"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|req_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|req_list
argument_list|)
condition|)
block|{
name|epc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|req_list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|req_list
argument_list|,
name|epc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|epc
operator|->
name|entry
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|req_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|epc
operator|->
name|so
condition|)
name|process_socket_event
argument_list|(
operator|(
expr|struct
name|iwch_ep
operator|*
operator|)
name|epc
argument_list|)
expr_stmt|;
name|put_ep
argument_list|(
name|epc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|req_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|req_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwch_cm_init
parameter_list|(
name|void
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|req_list
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|req_lock
argument_list|,
literal|"iw_cxgb req_list lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|iw_cxgb_taskq
operator|=
name|taskqueue_create
argument_list|(
literal|"iw_cxgb_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|iw_cxgb_taskq
argument_list|)
expr_stmt|;
if|if
condition|(
name|iw_cxgb_taskq
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"failed to allocate iw_cxgb taskqueue\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|taskqueue_start_threads
argument_list|(
operator|&
name|iw_cxgb_taskq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"iw_cxgb taskq"
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|iw_cxgb_task
argument_list|,
literal|0
argument_list|,
name|process_req
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|iwch_cm_term
parameter_list|(
name|void
parameter_list|)
block|{
name|taskqueue_drain
argument_list|(
name|iw_cxgb_taskq
argument_list|,
operator|&
name|iw_cxgb_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|iw_cxgb_taskq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwch_cm_init_cpl
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_RDMA_TERMINATE
argument_list|,
name|terminate
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_RDMA_EC_STATUS
argument_list|,
name|ec_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwch_cm_term_cpl
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_RDMA_TERMINATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_RDMA_EC_STATUS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

