begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_DEFINED
end_ifdef

begin_include
include|#
directive|include
file|<cxgb_include.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_include.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_define
define|#
directive|define
name|VALIDATE_TID
value|0
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CXGB
argument_list|,
literal|"cxgb"
argument_list|,
literal|"Chelsio 10 Gigabit Ethernet and services"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|cxgb_client
argument_list|)
end_macro

begin_expr_stmt
name|client_list
expr_stmt|;
end_expr_stmt

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|t3cdev
argument_list|)
end_macro

begin_expr_stmt
name|ofld_dev_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|cxgb_db_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|int
name|offload_activated
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|tdev2adap
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
return|return
operator|(
name|isset
argument_list|(
operator|&
name|adapter
operator|->
name|open_device_map
argument_list|,
name|OFFLOAD_DEVMAP_BIT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|register_tdev
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|)
block|{
specifier|static
name|int
name|unit
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tdev
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|tdev
operator|->
name|name
argument_list|)
argument_list|,
literal|"ofld_dev%d"
argument_list|,
name|unit
operator|++
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ofld_dev_list
argument_list|,
name|tdev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|unregister_tdev
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ofld_dev_list
argument_list|,
name|tdev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TOE_ENABLED
end_ifdef

begin_comment
comment|/**  *	cxgb_register_client - register an offload client  *	@client: the client  *  *	Add the client to the client list,  *	and call backs the client for each activated offload device  */
end_comment

begin_function
name|void
name|cxgb_register_client
parameter_list|(
name|struct
name|cxgb_client
modifier|*
name|client
parameter_list|)
block|{
name|struct
name|t3cdev
modifier|*
name|tdev
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|client_list
argument_list|,
name|client
argument_list|,
name|client_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|add
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|tdev
argument_list|,
argument|&ofld_dev_list
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|offload_activated
argument_list|(
name|tdev
argument_list|)
condition|)
block|{
name|client
operator|->
name|add
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
block|}
else|else
name|CTR1
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"cxgb_register_client: %p not activated"
argument_list|,
name|tdev
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	cxgb_unregister_client - unregister an offload client  *	@client: the client  *  *	Remove the client to the client list,  *	and call backs the client for each activated offload device.  */
end_comment

begin_function
name|void
name|cxgb_unregister_client
parameter_list|(
name|struct
name|cxgb_client
modifier|*
name|client
parameter_list|)
block|{
name|struct
name|t3cdev
modifier|*
name|tdev
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|client_list
argument_list|,
name|client
argument_list|,
name|client_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|remove
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|tdev
argument_list|,
argument|&ofld_dev_list
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|offload_activated
argument_list|(
name|tdev
argument_list|)
condition|)
name|client
operator|->
name|remove
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	cxgb_add_clients - activate register clients for an offload device  *	@tdev: the offload device  *  *	Call backs all registered clients once a offload device is activated   */
end_comment

begin_function
name|void
name|cxgb_add_clients
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|)
block|{
name|struct
name|cxgb_client
modifier|*
name|client
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|client
argument_list|,
argument|&client_list
argument_list|,
argument|client_entry
argument_list|)
block|{
if|if
condition|(
name|client
operator|->
name|add
condition|)
name|client
operator|->
name|add
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	cxgb_remove_clients - activate register clients for an offload device  *	@tdev: the offload device  *  *	Call backs all registered clients once a offload device is deactivated   */
end_comment

begin_function
name|void
name|cxgb_remove_clients
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|)
block|{
name|struct
name|cxgb_client
modifier|*
name|client
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|client
argument_list|,
argument|&client_list
argument_list|,
argument|client_entry
argument_list|)
block|{
if|if
condition|(
name|client
operator|->
name|remove
condition|)
name|client
operator|->
name|remove
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cxgb_ofld_recv - process n received offload packets  * @dev: the offload device  * @m: an array of offload packets  * @n: the number of offload packets  *  * Process an array of ingress offload packets.  Each packet is forwarded  * to any active network taps and then passed to the offload device's receive  * method.  We optimize passing packets to the receive method by passing  * it the whole array at once except when there are active taps.  */
end_comment

begin_function
name|int
name|cxgb_ofld_recv
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|dev
operator|->
name|recv
argument_list|(
name|dev
argument_list|,
name|m
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dummy handler for Rx offload packets in case we get an offload packet before  * proper processing is setup.  This complains and drops the packet as it isn't  * normal to get offload packets at this stage.  */
end_comment

begin_function
specifier|static
name|int
name|rx_offload_blackhole
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
while|while
condition|(
name|n
operator|--
condition|)
name|m_freem
argument_list|(
name|m
index|[
name|n
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dummy_neigh_update
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|rtentry
modifier|*
name|neigh
parameter_list|,
name|uint8_t
modifier|*
name|enaddr
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|cxgb_set_dummy_ops
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|)
block|{
name|dev
operator|->
name|recv
operator|=
name|rx_offload_blackhole
expr_stmt|;
name|dev
operator|->
name|arp_update
operator|=
name|dummy_neigh_update
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_smt_write_rpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_smt_write_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unexpected SMT_WRITE_RPL status %u for entry %u\n"
argument_list|,
name|rpl
operator|->
name|status
argument_list|,
name|GET_TID
argument_list|(
name|rpl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_l2t_write_rpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_l2t_write_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unexpected L2T_WRITE_RPL status %u for entry %u\n"
argument_list|,
name|rpl
operator|->
name|status
argument_list|,
name|GET_TID
argument_list|(
name|rpl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_rte_write_rpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_rte_write_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unexpected L2T_WRITE_RPL status %u for entry %u\n"
argument_list|,
name|rpl
operator|->
name|status
argument_list|,
name|GET_TID
argument_list|(
name|rpl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_set_tcb_rpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_set_tcb_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unexpected SET_TCB_RPL status %u for tid %u\n"
argument_list|,
name|rpl
operator|->
name|status
argument_list|,
name|GET_TID
argument_list|(
name|rpl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_trace
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct cpl_trace_pkt *p = cplhdr(m);   	skb->protocol = 0xffff; 	skb->dev = dev->lldev; 	skb_pull(skb, sizeof(*p)); 	skb->mac.raw = mtod(m, (char *)); 	netif_receive_skb(skb);
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Process a received packet with an unknown/unexpected CPL opcode.  */
end_comment

begin_function
specifier|static
name|int
name|do_bad_cpl
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received bad CPL command 0x%x\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
literal|0xFF
operator|&
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|uint32_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|kdb_backtrace
argument_list|()
expr_stmt|;
return|return
operator|(
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handlers for each CPL opcode  */
end_comment

begin_decl_stmt
specifier|static
name|cpl_handler_func
name|cpl_handlers
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * T3CDEV's receive method.  */
end_comment

begin_function
name|int
name|process_rx
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
init|=
operator|*
name|m
operator|++
decl_stmt|;
name|unsigned
name|int
name|opcode
init|=
name|G_OPCODE
argument_list|(
name|ntohl
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_data
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"processing op=0x%x m=%p data=%p\n"
argument_list|,
name|opcode
argument_list|,
name|m0
argument_list|,
name|m0
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cpl_handlers
index|[
name|opcode
index|]
operator|(
name|dev
operator|,
name|m0
operator|)
expr_stmt|;
if|#
directive|if
name|VALIDATE_TID
if|if
condition|(
name|ret
operator|&
name|CPL_RET_UNKNOWN_TID
condition|)
block|{
name|union
name|opcode_tid
modifier|*
name|p
init|=
name|cplhdr
argument_list|(
name|m0
argument_list|)
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: CPL message (opcode %u) had "
literal|"unknown TID %u\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|opcode
argument_list|,
name|G_TID
argument_list|(
name|ntohl
argument_list|(
name|p
operator|->
name|opcode_tid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ret
operator|&
name|CPL_RET_BUF_DONE
condition|)
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add a new handler to the CPL dispatch table.  A NULL handler may be supplied  * to unregister an existing handler.  */
end_comment

begin_function
name|void
name|t3_register_cpl_handler
parameter_list|(
name|unsigned
name|int
name|opcode
parameter_list|,
name|cpl_handler_func
name|h
parameter_list|)
block|{
if|if
condition|(
name|opcode
operator|<
name|NUM_CPL_CMDS
condition|)
name|cpl_handlers
index|[
name|opcode
index|]
operator|=
name|h
condition|?
name|h
else|:
name|do_bad_cpl
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"T3C: handler registration for "
literal|"opcode %x failed\n"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a chunk of memory using kmalloc or, if that fails, vmalloc.  * The allocated memory is cleared.  */
end_comment

begin_function
name|void
modifier|*
name|cxgb_alloc_mem
parameter_list|(
name|unsigned
name|long
name|size
parameter_list|)
block|{
return|return
name|malloc
argument_list|(
name|size
argument_list|,
name|M_CXGB
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free memory allocated through t3_alloc_mem().  */
end_comment

begin_function
name|void
name|cxgb_free_mem
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|free
argument_list|(
name|addr
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|adap2type
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|type
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
condition|)
block|{
case|case
name|T3_REV_A
case|:
name|type
operator|=
name|T3A
expr_stmt|;
break|break;
case|case
name|T3_REV_B
case|:
case|case
name|T3_REV_B2
case|:
name|type
operator|=
name|T3B
expr_stmt|;
break|break;
case|case
name|T3_REV_C
case|:
name|type
operator|=
name|T3C
expr_stmt|;
break|break;
block|}
return|return
name|type
return|;
block|}
end_function

begin_function
name|void
name|cxgb_adapter_ofld
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|t3cdev
modifier|*
name|tdev
init|=
operator|&
name|adapter
operator|->
name|tdev
decl_stmt|;
name|cxgb_set_dummy_ops
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
name|tdev
operator|->
name|type
operator|=
name|adap2type
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|tdev
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|register_tdev
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxgb_adapter_unofld
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|t3cdev
modifier|*
name|tdev
init|=
operator|&
name|adapter
operator|->
name|tdev
decl_stmt|;
name|tdev
operator|->
name|recv
operator|=
name|NULL
expr_stmt|;
name|tdev
operator|->
name|arp_update
operator|=
name|NULL
expr_stmt|;
name|unregister_tdev
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxgb_offload_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|inited
operator|++
condition|)
return|return;
name|mtx_init
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|,
literal|"ofld db"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|client_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ofld_dev_list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x100
condition|;
operator|++
name|i
control|)
name|cpl_handlers
index|[
name|i
index|]
operator|=
name|do_bad_cpl
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_SMT_WRITE_RPL
argument_list|,
name|do_smt_write_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_RTE_WRITE_RPL
argument_list|,
name|do_rte_write_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_L2T_WRITE_RPL
argument_list|,
name|do_l2t_write_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_SET_TCB_RPL
argument_list|,
name|do_set_tcb_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_TRACE_PKT
argument_list|,
name|do_trace
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxgb_offload_exit
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|--
name|inited
condition|)
return|return;
name|mtx_destroy
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|if_cxgb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

