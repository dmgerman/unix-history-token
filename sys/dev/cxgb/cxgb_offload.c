begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_DEFINED
end_ifdef

begin_include
include|#
directive|include
file|<cxgb_include.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_include.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_comment
comment|/*  * XXX   */
end_comment

begin_define
define|#
directive|define
name|LOG_NOTICE
value|2
end_define

begin_define
define|#
directive|define
name|BUG_ON
parameter_list|(
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|VALIDATE_TID
value|0
end_define

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|cxgb_client
argument_list|)
end_macro

begin_expr_stmt
name|client_list
expr_stmt|;
end_expr_stmt

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|toedev
argument_list|)
end_macro

begin_expr_stmt
name|ofld_dev_list
expr_stmt|;
end_expr_stmt

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|adapter
argument_list|)
end_macro

begin_expr_stmt
name|adapter_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|cxgb_db_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rwlock
name|adapter_list_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|MAX_ATIDS
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|ATID_BASE
init|=
literal|0x100000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|int
name|offload_activated
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|tdev2adap
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
return|return
operator|(
name|isset
argument_list|(
operator|&
name|adapter
operator|->
name|open_device_map
argument_list|,
name|OFFLOAD_DEVMAP_BIT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	cxgb_register_client - register an offload client  *	@client: the client  *  *	Add the client to the client list,  *	and call backs the client for each activated offload device  */
end_comment

begin_function
name|void
name|cxgb_register_client
parameter_list|(
name|struct
name|cxgb_client
modifier|*
name|client
parameter_list|)
block|{
name|struct
name|toedev
modifier|*
name|tdev
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|client_list
argument_list|,
name|client
argument_list|,
name|client_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|add
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|tdev
argument_list|,
argument|&ofld_dev_list
argument_list|,
argument|ofld_entry
argument_list|)
block|{
if|if
condition|(
name|offload_activated
argument_list|(
name|tdev
argument_list|)
condition|)
name|client
operator|->
name|add
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	cxgb_unregister_client - unregister an offload client  *	@client: the client  *  *	Remove the client to the client list,  *	and call backs the client for each activated offload device.  */
end_comment

begin_function
name|void
name|cxgb_unregister_client
parameter_list|(
name|struct
name|cxgb_client
modifier|*
name|client
parameter_list|)
block|{
name|struct
name|toedev
modifier|*
name|tdev
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|client_list
argument_list|,
name|client
argument_list|,
name|client_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|remove
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|tdev
argument_list|,
argument|&ofld_dev_list
argument_list|,
argument|ofld_entry
argument_list|)
block|{
if|if
condition|(
name|offload_activated
argument_list|(
name|tdev
argument_list|)
condition|)
name|client
operator|->
name|remove
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	cxgb_add_clients - activate register clients for an offload device  *	@tdev: the offload device  *  *	Call backs all registered clients once a offload device is activated   */
end_comment

begin_function
name|void
name|cxgb_add_clients
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|)
block|{
name|struct
name|cxgb_client
modifier|*
name|client
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|client
argument_list|,
argument|&client_list
argument_list|,
argument|client_entry
argument_list|)
block|{
if|if
condition|(
name|client
operator|->
name|add
condition|)
name|client
operator|->
name|add
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	cxgb_remove_clients - activate register clients for an offload device  *	@tdev: the offload device  *  *	Call backs all registered clients once a offload device is deactivated   */
end_comment

begin_function
name|void
name|cxgb_remove_clients
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|)
block|{
name|struct
name|cxgb_client
modifier|*
name|client
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|client
argument_list|,
argument|&client_list
argument_list|,
argument|client_entry
argument_list|)
block|{
if|if
condition|(
name|client
operator|->
name|remove
condition|)
name|client
operator|->
name|remove
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_offloading
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|int
name|port
decl_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|adapter
argument_list|,
argument|&adapter_list
argument_list|,
argument|adapter_entry
argument_list|)
block|{
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|port
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|==
name|adapter
operator|->
name|port
index|[
name|port
index|]
operator|.
name|ifp
condition|)
block|{
name|rw_runlock
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
name|rw_runlock
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ifnet
modifier|*
name|get_iff_from_mac
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|mac
parameter_list|,
name|unsigned
name|int
name|vlan
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
name|int
name|i
decl_stmt|;
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|i
argument_list|)
block|{
specifier|const
name|struct
name|vlan_group
modifier|*
name|grp
decl_stmt|;
specifier|const
name|struct
name|port_info
modifier|*
name|p
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnet
init|=
name|p
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|p
operator|->
name|hw_addr
argument_list|,
name|mac
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
condition|)
block|{
if|if
condition|(
name|vlan
operator|&&
name|vlan
operator|!=
name|EVL_VLID_MASK
condition|)
block|{
name|grp
operator|=
name|p
operator|->
name|vlan_grp
expr_stmt|;
name|dev
operator|=
name|grp
condition|?
name|grp
operator|->
name|vlan_devices
index|[
name|vlan
index|]
else|:
name|NULL
expr_stmt|;
block|}
else|else
while|while
condition|(
name|dev
operator|->
name|master
condition|)
name|dev
operator|=
name|dev
operator|->
name|master
expr_stmt|;
return|return
name|dev
return|;
block|}
block|}
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|failover_fixup
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|port
index|[
name|port
index|]
operator|.
name|ifp
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|port
index|]
operator|.
name|mac
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
comment|/* Failover triggered by the interface ifdown */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_TX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_TXEN
argument_list|)
expr_stmt|;
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_TX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Failover triggered by the interface link down */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_RXEN
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_ulp_iscsi_ctl
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|req
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|ulp_iscsi_info
modifier|*
name|uiip
init|=
name|data
decl_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|ULP_ISCSI_GET_PARAMS
case|:
name|uiip
operator|->
name|llimit
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_ISCSI_LLIMIT
argument_list|)
expr_stmt|;
name|uiip
operator|->
name|ulimit
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_ISCSI_ULIMIT
argument_list|)
expr_stmt|;
name|uiip
operator|->
name|tagmask
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_ISCSI_TAGMASK
argument_list|)
expr_stmt|;
comment|/* 		 * On tx, the iscsi pdu has to be<= tx page size and has to 		 * fit into the Tx PM FIFO. 		 */
name|uiip
operator|->
name|max_txsz
operator|=
name|min
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|tp
operator|.
name|tx_pg_size
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PM1_TX_CFG
argument_list|)
operator|>>
literal|17
argument_list|)
expr_stmt|;
comment|/* on rx, the iscsi pdu has to be< rx page size and the 		   whole pdu + cpl headers has to fit into one sge buffer */
name|uiip
operator|->
name|max_rxsz
operator|=
operator|(
name|unsigned
name|int
operator|)
name|min
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|tp
operator|.
name|rx_pg_size
argument_list|,
operator|(
name|adapter
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|fl
index|[
literal|1
index|]
operator|.
name|buf_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_rx_data
argument_list|)
operator|*
literal|2
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_rx_data_ddp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ULP_ISCSI_SET_PARAMS
case|:
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_ISCSI_TAGMASK
argument_list|,
name|uiip
operator|->
name|tagmask
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
name|EOPNOTSUPP
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Response queue used for RDMA events. */
end_comment

begin_define
define|#
directive|define
name|ASYNC_NOTIF_RSPQ
value|0
end_define

begin_function
specifier|static
name|int
name|cxgb_rdma_ctl
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|req
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|RDMA_GET_PARAMS
case|:
block|{
name|struct
name|rdma_info
modifier|*
name|req
init|=
name|data
decl_stmt|;
name|req
operator|->
name|udbell_physbase
operator|=
name|rman_get_start
argument_list|(
name|adapter
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|req
operator|->
name|udbell_len
operator|=
name|rman_get_size
argument_list|(
name|adapter
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|req
operator|->
name|tpt_base
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_TPT_LLIMIT
argument_list|)
expr_stmt|;
name|req
operator|->
name|tpt_top
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_TPT_ULIMIT
argument_list|)
expr_stmt|;
name|req
operator|->
name|pbl_base
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_PBL_LLIMIT
argument_list|)
expr_stmt|;
name|req
operator|->
name|pbl_top
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_PBL_ULIMIT
argument_list|)
expr_stmt|;
name|req
operator|->
name|rqt_base
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_RQ_LLIMIT
argument_list|)
expr_stmt|;
name|req
operator|->
name|rqt_top
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_RQ_ULIMIT
argument_list|)
expr_stmt|;
name|req
operator|->
name|kdb_addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|rman_get_start
argument_list|(
name|adapter
operator|->
name|regs_res
argument_list|)
operator|+
name|A_SG_KDOORBELL
operator|)
expr_stmt|;
break|break;
block|}
case|case
name|RDMA_CQ_OP
case|:
block|{
name|struct
name|rdma_cq_op
modifier|*
name|req
init|=
name|data
decl_stmt|;
comment|/* may be called in any context */
name|mtx_lock
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_sge_cqcntxt_op
argument_list|(
name|adapter
argument_list|,
name|req
operator|->
name|id
argument_list|,
name|req
operator|->
name|op
argument_list|,
name|req
operator|->
name|credits
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RDMA_GET_MEM
case|:
block|{
name|struct
name|ch_mem_range
modifier|*
name|t
init|=
name|data
decl_stmt|;
name|struct
name|mc7
modifier|*
name|mem
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|addr
operator|&
literal|7
operator|)
operator|||
operator|(
name|t
operator|->
name|len
operator|&
literal|7
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_CM
condition|)
name|mem
operator|=
operator|&
name|adapter
operator|->
name|cm
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_PMRX
condition|)
name|mem
operator|=
operator|&
name|adapter
operator|->
name|pmrx
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_PMTX
condition|)
name|mem
operator|=
operator|&
name|adapter
operator|->
name|pmtx
expr_stmt|;
else|else
return|return
operator|-
name|EINVAL
return|;
name|ret
operator|=
name|t3_mc7_bd_read
argument_list|(
name|mem
argument_list|,
name|t
operator|->
name|addr
operator|/
literal|8
argument_list|,
name|t
operator|->
name|len
operator|/
literal|8
argument_list|,
operator|(
name|u64
operator|*
operator|)
name|t
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
break|break;
block|}
case|case
name|RDMA_CQ_SETUP
case|:
block|{
name|struct
name|rdma_cq_setup
modifier|*
name|req
init|=
name|data
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_sge_init_cqcntxt
argument_list|(
name|adapter
argument_list|,
name|req
operator|->
name|id
argument_list|,
name|req
operator|->
name|base_addr
argument_list|,
name|req
operator|->
name|size
argument_list|,
name|ASYNC_NOTIF_RSPQ
argument_list|,
name|req
operator|->
name|ovfl_mode
argument_list|,
name|req
operator|->
name|credits
argument_list|,
name|req
operator|->
name|credit_thres
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RDMA_CQ_DISABLE
case|:
name|mtx_lock
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_sge_disable_cqcntxt
argument_list|(
name|adapter
argument_list|,
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDMA_CTRL_QP_SETUP
case|:
block|{
name|struct
name|rdma_ctrlqp_setup
modifier|*
name|req
init|=
name|data
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_sge_init_ecntxt
argument_list|(
name|adapter
argument_list|,
name|FW_RI_SGEEC_START
argument_list|,
literal|0
argument_list|,
name|SGE_CNTXT_RDMA
argument_list|,
name|ASYNC_NOTIF_RSPQ
argument_list|,
name|req
operator|->
name|base_addr
argument_list|,
name|req
operator|->
name|size
argument_list|,
name|FW_RI_TID_START
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ret
operator|=
operator|-
name|EOPNOTSUPP
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_offload_ctl
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|unsigned
name|int
name|req
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|tdev2adap
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
name|struct
name|tid_range
modifier|*
name|tid
decl_stmt|;
name|struct
name|mtutab
modifier|*
name|mtup
decl_stmt|;
name|struct
name|iff_mac
modifier|*
name|iffmacp
decl_stmt|;
name|struct
name|ddp_params
modifier|*
name|ddpp
decl_stmt|;
name|struct
name|adap_ports
modifier|*
name|ports
decl_stmt|;
name|int
name|port
decl_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|GET_MAX_OUTSTANDING_WR
case|:
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|data
operator|=
name|FW_WR_NUM
expr_stmt|;
break|break;
case|case
name|GET_WR_LEN
case|:
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|data
operator|=
name|WR_FLITS
expr_stmt|;
break|break;
case|case
name|GET_TX_MAX_CHUNK
case|:
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|data
operator|=
literal|1
operator|<<
literal|20
expr_stmt|;
comment|/* 1MB */
break|break;
case|case
name|GET_TID_RANGE
case|:
name|tid
operator|=
name|data
expr_stmt|;
name|tid
operator|->
name|num
operator|=
name|t3_mc5_size
argument_list|(
operator|&
name|adapter
operator|->
name|mc5
argument_list|)
operator|-
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nroutes
operator|-
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
operator|-
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nservers
expr_stmt|;
name|tid
operator|->
name|base
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GET_STID_RANGE
case|:
name|tid
operator|=
name|data
expr_stmt|;
name|tid
operator|->
name|num
operator|=
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nservers
expr_stmt|;
name|tid
operator|->
name|base
operator|=
name|t3_mc5_size
argument_list|(
operator|&
name|adapter
operator|->
name|mc5
argument_list|)
operator|-
name|tid
operator|->
name|num
operator|-
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
operator|-
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nroutes
expr_stmt|;
break|break;
case|case
name|GET_L2T_CAPACITY
case|:
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|data
operator|=
literal|2048
expr_stmt|;
break|break;
case|case
name|GET_MTUS
case|:
name|mtup
operator|=
name|data
expr_stmt|;
name|mtup
operator|->
name|size
operator|=
name|NMTUS
expr_stmt|;
name|mtup
operator|->
name|mtus
operator|=
name|adapter
operator|->
name|params
operator|.
name|mtus
expr_stmt|;
break|break;
case|case
name|GET_IFF_FROM_MAC
case|:
name|iffmacp
operator|=
name|data
expr_stmt|;
name|iffmacp
operator|->
name|dev
operator|=
name|get_iff_from_mac
argument_list|(
name|adapter
argument_list|,
name|iffmacp
operator|->
name|mac_addr
argument_list|,
name|iffmacp
operator|->
name|vlan_tag
operator|&
name|EVL_VLID_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_DDP_PARAMS
case|:
name|ddpp
operator|=
name|data
expr_stmt|;
name|ddpp
operator|->
name|llimit
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_TDDP_LLIMIT
argument_list|)
expr_stmt|;
name|ddpp
operator|->
name|ulimit
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_TDDP_ULIMIT
argument_list|)
expr_stmt|;
name|ddpp
operator|->
name|tag_mask
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_TDDP_TAGMASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_PORTS
case|:
name|ports
operator|=
name|data
expr_stmt|;
name|ports
operator|->
name|nports
operator|=
name|adapter
operator|->
name|params
operator|.
name|nports
expr_stmt|;
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|port
argument_list|)
name|ports
operator|->
name|lldevs
index|[
name|port
index|]
operator|=
name|adapter
operator|->
name|port
index|[
name|port
index|]
operator|.
name|ifp
expr_stmt|;
break|break;
case|case
name|FAILOVER
case|:
name|port
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|t3_port_failover
argument_list|(
name|adapter
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|failover_fixup
argument_list|(
name|adapter
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
case|case
name|FAILOVER_DONE
case|:
name|port
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|t3_failover_done
argument_list|(
name|adapter
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
case|case
name|FAILOVER_CLEAR
case|:
name|t3_failover_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
case|case
name|ULP_ISCSI_GET_PARAMS
case|:
case|case
name|ULP_ISCSI_SET_PARAMS
case|:
if|if
condition|(
operator|!
name|offload_running
argument_list|(
name|adapter
argument_list|)
condition|)
return|return
operator|-
name|EAGAIN
return|;
return|return
name|cxgb_ulp_iscsi_ctl
argument_list|(
name|adapter
argument_list|,
name|req
argument_list|,
name|data
argument_list|)
return|;
case|case
name|RDMA_GET_PARAMS
case|:
case|case
name|RDMA_CQ_OP
case|:
case|case
name|RDMA_CQ_SETUP
case|:
case|case
name|RDMA_CQ_DISABLE
case|:
case|case
name|RDMA_CTRL_QP_SETUP
case|:
case|case
name|RDMA_GET_MEM
case|:
if|if
condition|(
operator|!
name|offload_running
argument_list|(
name|adapter
argument_list|)
condition|)
return|return
operator|-
name|EAGAIN
return|;
return|return
name|cxgb_rdma_ctl
argument_list|(
name|adapter
argument_list|,
name|req
argument_list|,
name|data
argument_list|)
return|;
default|default:
return|return
operator|-
name|EOPNOTSUPP
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Dummy handler for Rx offload packets in case we get an offload packet before  * proper processing is setup.  This complains and drops the packet as it isn't  * normal to get offload packets at this stage.  */
end_comment

begin_function
specifier|static
name|int
name|rx_offload_blackhole
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|CH_ERR
argument_list|(
name|tdev2adap
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"%d unexpected offload packets, first data %u\n"
argument_list|,
name|n
argument_list|,
name|ntohl
argument_list|(
operator|*
name|mtod
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|,
name|uint32_t
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
name|m_freem
argument_list|(
name|m
index|[
name|n
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dummy_neigh_update
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|rtentry
modifier|*
name|neigh
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|cxgb_set_dummy_ops
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|)
block|{
name|dev
operator|->
name|recv
operator|=
name|rx_offload_blackhole
expr_stmt|;
name|dev
operator|->
name|neigh_update
operator|=
name|dummy_neigh_update
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an active-open TID.  */
end_comment

begin_function
name|void
modifier|*
name|cxgb_free_atid
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|int
name|atid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|TOE_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
name|union
name|active_open_entry
modifier|*
name|p
init|=
name|atid2entry
argument_list|(
name|t
argument_list|,
name|atid
argument_list|)
decl_stmt|;
name|void
modifier|*
name|ctx
init|=
name|p
operator|->
name|toe_tid
operator|.
name|ctx
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|t
operator|->
name|afree
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|atids_in_use
operator|--
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
return|return
name|ctx
return|;
block|}
end_function

begin_comment
comment|/*  * Free a server TID and return it to the free pool.  */
end_comment

begin_function
name|void
name|cxgb_free_stid
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|int
name|stid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|TOE_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
name|union
name|listen_entry
modifier|*
name|p
init|=
name|stid2entry
argument_list|(
name|t
argument_list|,
name|stid
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|t
operator|->
name|sfree
expr_stmt|;
name|t
operator|->
name|sfree
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|stids_in_use
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxgb_insert_tid
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|struct
name|cxgb_client
modifier|*
name|client
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|TOE_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|.
name|client
operator|=
name|client
expr_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|(
specifier|volatile
name|unsigned
name|int
operator|*
operator|)
operator|&
name|t
operator|->
name|tids_in_use
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Populate a TID_RELEASE WR.  The mbuf must be already propely sized.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mk_tid_release
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|struct
name|cpl_tid_release
modifier|*
name|req
decl_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|CPL_PRIORITY_SETUP
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_tid_release
operator|*
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_TID_RELEASE
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|t3_process_tid_release_list
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tdev
init|=
name|data
decl_stmt|;
name|struct
name|toe_data
modifier|*
name|td
init|=
name|TOE_DATA
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|td
operator|->
name|tid_release_list
condition|)
block|{
name|struct
name|toe_tid_entry
modifier|*
name|p
init|=
name|td
operator|->
name|tid_release_list
decl_stmt|;
name|td
operator|->
name|tid_release_list
operator|=
operator|(
expr|struct
name|toe_tid_entry
operator|*
operator|)
name|p
operator|->
name|ctx
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_get
argument_list|(
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|mk_tid_release
argument_list|(
name|m
argument_list|,
name|p
operator|-
name|td
operator|->
name|tid_maps
operator|.
name|tid_tab
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|tdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|p
operator|->
name|ctx
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* use ctx as a next pointer in the tid release list */
end_comment

begin_function
name|void
name|cxgb_queue_tid_release
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|struct
name|toe_data
modifier|*
name|td
init|=
name|TOE_DATA
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|p
init|=
operator|&
name|td
operator|->
name|tid_maps
operator|.
name|tid_tab
index|[
name|tid
index|]
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|ctx
operator|=
name|td
operator|->
name|tid_release_list
expr_stmt|;
name|td
operator|->
name|tid_release_list
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|ctx
condition|)
name|taskqueue_enqueue
argument_list|(
name|tdev
operator|->
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|td
operator|->
name|tid_release_task
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|tid_release_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a tid from the TID table.  A client may defer processing its last  * CPL message if it is locked at the time it arrives, and while the message  * sits in the client's backlog the TID may be reused for another connection.  * To handle this we atomically switch the TID association if it still points  * to the original client context.  */
end_comment

begin_function
name|void
name|cxgb_remove_tid
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|)
block|{
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|TOE_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
name|BUG_ON
argument_list|(
name|tid
operator|>=
name|t
operator|->
name|ntids
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdev
operator|->
name|type
operator|==
name|T3A
condition|)
name|atomic_cmpset_ptr
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|.
name|ctx
argument_list|,
operator|(
name|long
operator|)
name|NULL
argument_list|,
operator|(
name|long
operator|)
name|ctx
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_get
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|m
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|mk_tid_release
argument_list|(
name|m
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|tdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|t
operator|->
name|tid_tab
index|[
name|tid
index|]
operator|.
name|ctx
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|cxgb_queue_tid_release
argument_list|(
name|tdev
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|(
specifier|volatile
name|unsigned
name|int
operator|*
operator|)
operator|&
name|t
operator|->
name|tids_in_use
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cxgb_alloc_atid
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|struct
name|cxgb_client
modifier|*
name|client
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|atid
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|TOE_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|afree
condition|)
block|{
name|union
name|active_open_entry
modifier|*
name|p
init|=
name|t
operator|->
name|afree
decl_stmt|;
name|atid
operator|=
operator|(
name|p
operator|-
name|t
operator|->
name|atid_tab
operator|)
operator|+
name|t
operator|->
name|atid_base
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|toe_tid
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|p
operator|->
name|toe_tid
operator|.
name|client
operator|=
name|client
expr_stmt|;
name|t
operator|->
name|atids_in_use
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|)
expr_stmt|;
return|return
name|atid
return|;
block|}
end_function

begin_function
name|int
name|cxgb_alloc_stid
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|struct
name|cxgb_client
modifier|*
name|client
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|stid
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|tid_info
modifier|*
name|t
init|=
operator|&
operator|(
name|TOE_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sfree
condition|)
block|{
name|union
name|listen_entry
modifier|*
name|p
init|=
name|t
operator|->
name|sfree
decl_stmt|;
name|stid
operator|=
operator|(
name|p
operator|-
name|t
operator|->
name|stid_tab
operator|)
operator|+
name|t
operator|->
name|stid_base
expr_stmt|;
name|t
operator|->
name|sfree
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|toe_tid
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|p
operator|->
name|toe_tid
operator|.
name|client
operator|=
name|client
expr_stmt|;
name|t
operator|->
name|stids_in_use
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
return|return
name|stid
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_smt_write_rpl
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_smt_write_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unexpected SMT_WRITE_RPL status %u for entry %u\n"
argument_list|,
name|rpl
operator|->
name|status
argument_list|,
name|GET_TID
argument_list|(
name|rpl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_l2t_write_rpl
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_l2t_write_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unexpected L2T_WRITE_RPL status %u for entry %u\n"
argument_list|,
name|rpl
operator|->
name|status
argument_list|,
name|GET_TID
argument_list|(
name|rpl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_act_open_rpl
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_act_open_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|atid
init|=
name|G_TID
argument_list|(
name|ntohl
argument_list|(
name|rpl
operator|->
name|atid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|toe_tid
decl_stmt|;
name|toe_tid
operator|=
name|lookup_atid
argument_list|(
operator|&
operator|(
name|TOE_DATA
argument_list|(
name|dev
argument_list|)
operator|)
operator|->
name|tid_maps
argument_list|,
name|atid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toe_tid
operator|->
name|ctx
operator|&&
name|toe_tid
operator|->
name|client
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|CPL_ACT_OPEN_RPL
index|]
condition|)
block|{
return|return
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|CPL_ACT_OPEN_RPL
index|]
operator|(
name|dev
operator|,
name|m
operator|,
name|toe_tid
operator|->
name|ctx
operator|)
return|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received clientless CPL command 0x%x\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|CPL_ACT_OPEN_RPL
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_stid_rpl
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|union
name|opcode_tid
modifier|*
name|p
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|stid
init|=
name|G_TID
argument_list|(
name|ntohl
argument_list|(
name|p
operator|->
name|opcode_tid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|toe_tid
decl_stmt|;
name|toe_tid
operator|=
name|lookup_stid
argument_list|(
operator|&
operator|(
name|TOE_DATA
argument_list|(
name|dev
argument_list|)
operator|)
operator|->
name|tid_maps
argument_list|,
name|stid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toe_tid
operator|->
name|ctx
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|p
operator|->
name|opcode
index|]
condition|)
block|{
return|return
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|p
operator|->
name|opcode
index|]
operator|(
name|dev
operator|,
name|m
operator|,
name|toe_tid
operator|->
name|ctx
operator|)
return|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received clientless CPL command 0x%x\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|p
operator|->
name|opcode
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_hwtid_rpl
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|union
name|opcode_tid
modifier|*
name|p
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|hwtid
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|toe_tid
decl_stmt|;
name|printf
argument_list|(
literal|"do_hwtid_rpl m=%p\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|hwtid
operator|=
name|G_TID
argument_list|(
name|ntohl
argument_list|(
name|p
operator|->
name|opcode_tid
argument_list|)
argument_list|)
expr_stmt|;
name|toe_tid
operator|=
name|lookup_tid
argument_list|(
operator|&
operator|(
name|TOE_DATA
argument_list|(
name|dev
argument_list|)
operator|)
operator|->
name|tid_maps
argument_list|,
name|hwtid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toe_tid
operator|->
name|ctx
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|p
operator|->
name|opcode
index|]
condition|)
block|{
return|return
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|p
operator|->
name|opcode
index|]
operator|(
name|dev
operator|,
name|m
operator|,
name|toe_tid
operator|->
name|ctx
operator|)
return|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received clientless CPL command 0x%x\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|p
operator|->
name|opcode
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_cr
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_pass_accept_req
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|stid
init|=
name|G_PASS_OPEN_TID
argument_list|(
name|ntohl
argument_list|(
name|req
operator|->
name|tos_tid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|toe_tid
decl_stmt|;
name|toe_tid
operator|=
name|lookup_stid
argument_list|(
operator|&
operator|(
name|TOE_DATA
argument_list|(
name|dev
argument_list|)
operator|)
operator|->
name|tid_maps
argument_list|,
name|stid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toe_tid
operator|->
name|ctx
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|CPL_PASS_ACCEPT_REQ
index|]
condition|)
block|{
return|return
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|CPL_PASS_ACCEPT_REQ
index|]
operator|(
name|dev
operator|,
name|m
operator|,
name|toe_tid
operator|->
name|ctx
operator|)
return|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received clientless CPL command 0x%x\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|CPL_PASS_ACCEPT_REQ
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_abort_req_rss
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|union
name|opcode_tid
modifier|*
name|p
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|hwtid
init|=
name|G_TID
argument_list|(
name|ntohl
argument_list|(
name|p
operator|->
name|opcode_tid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|toe_tid
decl_stmt|;
name|toe_tid
operator|=
name|lookup_tid
argument_list|(
operator|&
operator|(
name|TOE_DATA
argument_list|(
name|dev
argument_list|)
operator|)
operator|->
name|tid_maps
argument_list|,
name|hwtid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toe_tid
operator|->
name|ctx
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|p
operator|->
name|opcode
index|]
condition|)
block|{
return|return
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|p
operator|->
name|opcode
index|]
operator|(
name|dev
operator|,
name|m
operator|,
name|toe_tid
operator|->
name|ctx
operator|)
return|;
block|}
else|else
block|{
name|struct
name|cpl_abort_req_rss
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|cpl_abort_rpl
modifier|*
name|rpl
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m_get
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"do_abort_req_rss: couldn't get mbuf!\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|CPL_PRIORITY_DATA
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|__skb_put(skb, sizeof(struct cpl_abort_rpl));
endif|#
directive|endif
name|rpl
operator|=
name|cplhdr
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_OFLD_HOST_ABORT_CON_RPL
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|wr
operator|.
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|GET_TID
argument_list|(
name|req
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|rpl
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_ABORT_RPL
argument_list|,
name|GET_TID
argument_list|(
name|req
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|cmd
operator|=
name|req
operator|->
name|status
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|dev
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|CPL_RET_BUF_DONE
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_act_establish
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_act_establish
modifier|*
name|req
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|atid
init|=
name|G_PASS_OPEN_TID
argument_list|(
name|ntohl
argument_list|(
name|req
operator|->
name|tos_tid
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|toe_tid
decl_stmt|;
name|toe_tid
operator|=
name|lookup_atid
argument_list|(
operator|&
operator|(
name|TOE_DATA
argument_list|(
name|dev
argument_list|)
operator|)
operator|->
name|tid_maps
argument_list|,
name|atid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toe_tid
operator|->
name|ctx
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|CPL_ACT_ESTABLISH
index|]
condition|)
block|{
return|return
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|CPL_ACT_ESTABLISH
index|]
operator|(
name|dev
operator|,
name|m
operator|,
name|toe_tid
operator|->
name|ctx
operator|)
return|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received clientless CPL command 0x%x\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|CPL_PASS_ACCEPT_REQ
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_set_tcb_rpl
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|cpl_set_tcb_rpl
modifier|*
name|rpl
init|=
name|cplhdr
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unexpected SET_TCB_RPL status %u for tid %u\n"
argument_list|,
name|rpl
operator|->
name|status
argument_list|,
name|GET_TID
argument_list|(
name|rpl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_trace
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct cpl_trace_pkt *p = cplhdr(m);   	skb->protocol = 0xffff; 	skb->dev = dev->lldev; 	skb_pull(skb, sizeof(*p)); 	skb->mac.raw = mtod(m, (char *)); 	netif_receive_skb(skb);
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_term
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|unsigned
name|int
name|hwtid
init|=
name|ntohl
argument_list|(
name|m_get_priority
argument_list|(
name|m
argument_list|)
argument_list|)
operator|>>
literal|8
operator|&
literal|0xfffff
decl_stmt|;
name|unsigned
name|int
name|opcode
init|=
name|G_OPCODE
argument_list|(
name|ntohl
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|toe_tid
decl_stmt|;
name|toe_tid
operator|=
name|lookup_tid
argument_list|(
operator|&
operator|(
name|TOE_DATA
argument_list|(
name|dev
argument_list|)
operator|)
operator|->
name|tid_maps
argument_list|,
name|hwtid
argument_list|)
expr_stmt|;
if|if
condition|(
name|toe_tid
operator|->
name|ctx
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
operator|&&
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|opcode
index|]
condition|)
block|{
return|return
name|toe_tid
operator|->
name|client
operator|->
name|handlers
index|[
name|opcode
index|]
operator|(
name|dev
operator|,
name|m
operator|,
name|toe_tid
operator|->
name|ctx
operator|)
return|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received clientless CPL command 0x%x\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
return|return
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FOO
argument_list|)
end_if

begin_include
include|#
directive|include
file|<linux/config.h>
end_include

begin_include
include|#
directive|include
file|<linux/kallsyms.h>
end_include

begin_include
include|#
directive|include
file|<linux/kprobes.h>
end_include

begin_include
include|#
directive|include
file|<net/arp.h>
end_include

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|orig_arp_constructor
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|neigh_suspect
parameter_list|(
name|struct
name|ifnet
modifier|*
name|neigh
parameter_list|)
block|{
name|struct
name|hh_cache
modifier|*
name|hh
decl_stmt|;
name|neigh
operator|->
name|output
operator|=
name|neigh
operator|->
name|ops
operator|->
name|output
expr_stmt|;
for|for
control|(
name|hh
operator|=
name|neigh
operator|->
name|hh
init|;
name|hh
condition|;
name|hh
operator|=
name|hh
operator|->
name|hh_next
control|)
name|hh
operator|->
name|hh_output
operator|=
name|neigh
operator|->
name|ops
operator|->
name|output
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|neigh_connect
parameter_list|(
name|struct
name|ifnet
modifier|*
name|neigh
parameter_list|)
block|{
name|struct
name|hh_cache
modifier|*
name|hh
decl_stmt|;
name|neigh
operator|->
name|output
operator|=
name|neigh
operator|->
name|ops
operator|->
name|connected_output
expr_stmt|;
for|for
control|(
name|hh
operator|=
name|neigh
operator|->
name|hh
init|;
name|hh
condition|;
name|hh
operator|=
name|hh
operator|->
name|hh_next
control|)
name|hh
operator|->
name|hh_output
operator|=
name|neigh
operator|->
name|ops
operator|->
name|hh_output
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|neigh_max_probes
parameter_list|(
specifier|const
name|struct
name|neighbour
modifier|*
name|n
parameter_list|)
block|{
specifier|const
name|struct
name|neigh_parms
modifier|*
name|p
init|=
name|n
operator|->
name|parms
decl_stmt|;
return|return
operator|(
name|n
operator|->
name|nud_state
operator|&
name|NUD_PROBE
condition|?
name|p
operator|->
name|ucast_probes
else|:
name|p
operator|->
name|ucast_probes
operator|+
name|p
operator|->
name|app_probes
operator|+
name|p
operator|->
name|mcast_probes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|neigh_timer_handler_offload
parameter_list|(
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|unsigned
name|long
name|now
decl_stmt|,
name|next
decl_stmt|;
name|struct
name|neighbour
modifier|*
name|neigh
init|=
operator|(
expr|struct
name|neighbour
operator|*
operator|)
name|arg
decl_stmt|;
name|unsigned
name|state
decl_stmt|;
name|int
name|notify
init|=
literal|0
decl_stmt|;
name|write_lock
argument_list|(
operator|&
name|neigh
operator|->
name|lock
argument_list|)
expr_stmt|;
name|state
operator|=
name|neigh
operator|->
name|nud_state
expr_stmt|;
name|now
operator|=
name|jiffies
expr_stmt|;
name|next
operator|=
name|now
operator|+
name|HZ
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|state
operator|&
name|NUD_IN_TIMER
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|CONFIG_SMP
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"neigh: timer& !nud_in_timer\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|state
operator|&
name|NUD_REACHABLE
condition|)
block|{
if|if
condition|(
name|time_before_eq
argument_list|(
name|now
argument_list|,
name|neigh
operator|->
name|confirmed
operator|+
name|neigh
operator|->
name|parms
operator|->
name|reachable_time
argument_list|)
condition|)
block|{
name|next
operator|=
name|neigh
operator|->
name|confirmed
operator|+
name|neigh
operator|->
name|parms
operator|->
name|reachable_time
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|time_before_eq
argument_list|(
name|now
argument_list|,
name|neigh
operator|->
name|used
operator|+
name|neigh
operator|->
name|parms
operator|->
name|delay_probe_time
argument_list|)
condition|)
block|{
name|neigh
operator|->
name|nud_state
operator|=
name|NUD_DELAY
expr_stmt|;
name|neigh
operator|->
name|updated
operator|=
name|jiffies
expr_stmt|;
name|neigh_suspect
argument_list|(
name|neigh
argument_list|)
expr_stmt|;
name|next
operator|=
name|now
operator|+
name|neigh
operator|->
name|parms
operator|->
name|delay_probe_time
expr_stmt|;
block|}
else|else
block|{
name|neigh
operator|->
name|nud_state
operator|=
name|NUD_STALE
expr_stmt|;
name|neigh
operator|->
name|updated
operator|=
name|jiffies
expr_stmt|;
name|neigh_suspect
argument_list|(
name|neigh
argument_list|)
expr_stmt|;
name|cxgb_neigh_update
argument_list|(
name|neigh
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|&
name|NUD_DELAY
condition|)
block|{
if|if
condition|(
name|time_before_eq
argument_list|(
name|now
argument_list|,
name|neigh
operator|->
name|confirmed
operator|+
name|neigh
operator|->
name|parms
operator|->
name|delay_probe_time
argument_list|)
condition|)
block|{
name|neigh
operator|->
name|nud_state
operator|=
name|NUD_REACHABLE
expr_stmt|;
name|neigh
operator|->
name|updated
operator|=
name|jiffies
expr_stmt|;
name|neigh_connect
argument_list|(
name|neigh
argument_list|)
expr_stmt|;
name|cxgb_neigh_update
argument_list|(
name|neigh
argument_list|)
expr_stmt|;
name|next
operator|=
name|neigh
operator|->
name|confirmed
operator|+
name|neigh
operator|->
name|parms
operator|->
name|reachable_time
expr_stmt|;
block|}
else|else
block|{
name|neigh
operator|->
name|nud_state
operator|=
name|NUD_PROBE
expr_stmt|;
name|neigh
operator|->
name|updated
operator|=
name|jiffies
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|neigh
operator|->
name|probes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next
operator|=
name|now
operator|+
name|neigh
operator|->
name|parms
operator|->
name|retrans_time
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* NUD_PROBE|NUD_INCOMPLETE */
name|next
operator|=
name|now
operator|+
name|neigh
operator|->
name|parms
operator|->
name|retrans_time
expr_stmt|;
block|}
comment|/* 	 * Needed for read of probes 	 */
name|mb
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|neigh
operator|->
name|nud_state
operator|&
operator|(
name|NUD_INCOMPLETE
operator||
name|NUD_PROBE
operator|)
operator|)
operator|&&
name|neigh
operator|->
name|probes
operator|>=
name|neigh_max_probes
argument_list|(
name|neigh
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|neigh
operator|->
name|nud_state
operator|=
name|NUD_FAILED
expr_stmt|;
name|neigh
operator|->
name|updated
operator|=
name|jiffies
expr_stmt|;
name|notify
operator|=
literal|1
expr_stmt|;
name|cxgb_neigh_update
argument_list|(
name|neigh
argument_list|)
expr_stmt|;
name|NEIGH_CACHE_STAT_INC
argument_list|(
name|neigh
operator|->
name|tbl
argument_list|,
name|res_failed
argument_list|)
expr_stmt|;
comment|/* It is very thin place. report_unreachable is very  		   complicated routine. Particularly, it can hit the same  		   neighbour entry! 		   So that, we try to be accurate and avoid dead loop. --ANK 		 */
while|while
condition|(
name|neigh
operator|->
name|nud_state
operator|==
name|NUD_FAILED
operator|&&
operator|(
name|skb
operator|=
name|__skb_dequeue
argument_list|(
operator|&
name|neigh
operator|->
name|arp_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|write_unlock
argument_list|(
operator|&
name|neigh
operator|->
name|lock
argument_list|)
expr_stmt|;
name|neigh
operator|->
name|ops
operator|->
name|error_report
argument_list|(
name|neigh
argument_list|,
name|skb
argument_list|)
expr_stmt|;
name|write_lock
argument_list|(
operator|&
name|neigh
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|skb_queue_purge
argument_list|(
operator|&
name|neigh
operator|->
name|arp_queue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|neigh
operator|->
name|nud_state
operator|&
name|NUD_IN_TIMER
condition|)
block|{
if|if
condition|(
name|time_before
argument_list|(
name|next
argument_list|,
name|jiffies
operator|+
name|HZ
operator|/
literal|2
argument_list|)
condition|)
name|next
operator|=
name|jiffies
operator|+
name|HZ
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|mod_timer
argument_list|(
operator|&
name|neigh
operator|->
name|timer
argument_list|,
name|next
argument_list|)
condition|)
name|neigh_hold
argument_list|(
name|neigh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|neigh
operator|->
name|nud_state
operator|&
operator|(
name|NUD_INCOMPLETE
operator||
name|NUD_PROBE
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|skb_peek
argument_list|(
operator|&
name|neigh
operator|->
name|arp_queue
argument_list|)
decl_stmt|;
name|write_unlock
argument_list|(
operator|&
name|neigh
operator|->
name|lock
argument_list|)
expr_stmt|;
name|neigh
operator|->
name|ops
operator|->
name|solicit
argument_list|(
name|neigh
argument_list|,
name|skb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|neigh
operator|->
name|probes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
label|:
name|write_unlock
argument_list|(
operator|&
name|neigh
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_ARPD
if|if
condition|(
name|notify
operator|&&
name|neigh
operator|->
name|parms
operator|->
name|app_probes
condition|)
name|neigh_app_notify
argument_list|(
name|neigh
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|neigh_release
argument_list|(
name|neigh
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|arp_constructor_offload
parameter_list|(
name|struct
name|neighbour
modifier|*
name|neigh
parameter_list|)
block|{
if|if
condition|(
name|neigh
operator|->
name|ifp
operator|&&
name|is_offloading
argument_list|(
name|neigh
operator|->
name|ifp
argument_list|)
condition|)
name|neigh
operator|->
name|timer
operator|.
name|function
operator|=
name|neigh_timer_handler_offload
expr_stmt|;
return|return
name|orig_arp_constructor
argument_list|(
name|neigh
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * This must match exactly the signature of neigh_update for jprobes to work.  * It runs from a trap handler with interrupts off so don't disable BH.  */
end_comment

begin_function
specifier|static
name|int
name|neigh_update_offload
parameter_list|(
name|struct
name|neighbour
modifier|*
name|neigh
parameter_list|,
specifier|const
name|u8
modifier|*
name|lladdr
parameter_list|,
name|u8
name|new
parameter_list|,
name|u32
name|flags
parameter_list|)
block|{
name|write_lock
argument_list|(
operator|&
name|neigh
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cxgb_neigh_update
argument_list|(
name|neigh
argument_list|)
expr_stmt|;
name|write_unlock
argument_list|(
operator|&
name|neigh
operator|->
name|lock
argument_list|)
expr_stmt|;
name|jprobe_return
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|jprobe
name|neigh_update_jprobe
init|=
block|{
operator|.
name|entry
operator|=
operator|(
name|kprobe_opcode_t
operator|*
operator|)
name|neigh_update_offload
block|,
operator|.
name|kp
operator|.
name|addr
operator|=
operator|(
name|kprobe_opcode_t
operator|*
operator|)
name|neigh_update
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MODULE_SUPPORT
end_ifdef

begin_function
specifier|static
name|int
name|prepare_arp_with_t3core
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|register_jprobe
argument_list|(
operator|&
name|neigh_update_jprobe
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not install neigh_update jprobe, "
literal|"error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|orig_arp_constructor
operator|=
name|arp_tbl
operator|.
name|constructor
expr_stmt|;
name|arp_tbl
operator|.
name|constructor
operator|=
name|arp_constructor_offload
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|restore_arp_sans_t3core
parameter_list|(
name|void
parameter_list|)
block|{
name|arp_tbl
operator|.
name|constructor
operator|=
name|orig_arp_constructor
expr_stmt|;
name|unregister_jprobe
argument_list|(
operator|&
name|neigh_update_jprobe
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Module suport */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|prepare_arp_with_t3core
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|restore_arp_sans_t3core
parameter_list|(
name|void
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Process a received packet with an unknown/unexpected CPL opcode.  */
end_comment

begin_function
specifier|static
name|int
name|do_bad_cpl
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: received bad CPL command 0x%x\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|uint32_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|CPL_RET_BUF_DONE
operator||
name|CPL_RET_BAD_MSG
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handlers for each CPL opcode  */
end_comment

begin_decl_stmt
specifier|static
name|cpl_handler_func
name|cpl_handlers
index|[
name|NUM_CPL_CMDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Add a new handler to the CPL dispatch table.  A NULL handler may be supplied  * to unregister an existing handler.  */
end_comment

begin_function
name|void
name|t3_register_cpl_handler
parameter_list|(
name|unsigned
name|int
name|opcode
parameter_list|,
name|cpl_handler_func
name|h
parameter_list|)
block|{
if|if
condition|(
name|opcode
operator|<
name|NUM_CPL_CMDS
condition|)
name|cpl_handlers
index|[
name|opcode
index|]
operator|=
name|h
condition|?
name|h
else|:
name|do_bad_cpl
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"T3C: handler registration for "
literal|"opcode %x failed\n"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TOEDEV's receive method.  */
end_comment

begin_function
name|int
name|process_rx
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
init|=
operator|*
name|m
operator|++
decl_stmt|;
name|unsigned
name|int
name|opcode
init|=
name|G_OPCODE
argument_list|(
name|ntohl
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_data
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
name|cpl_handlers
index|[
name|opcode
index|]
operator|(
name|dev
expr|,
name|m0
operator|)
decl_stmt|;
if|#
directive|if
name|VALIDATE_TID
if|if
condition|(
name|ret
operator|&
name|CPL_RET_UNKNOWN_TID
condition|)
block|{
name|union
name|opcode_tid
modifier|*
name|p
init|=
name|cplhdr
argument_list|(
name|m0
argument_list|)
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: CPL message (opcode %u) had "
literal|"unknown TID %u\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|opcode
argument_list|,
name|G_TID
argument_list|(
name|ntohl
argument_list|(
name|p
operator|->
name|opcode_tid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ret
operator|&
name|CPL_RET_BUF_DONE
condition|)
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Sends an sk_buff to a T3C driver after dealing with any active network taps.  */
end_comment

begin_function
name|int
name|cxgb_ofld_send
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|r
operator|=
name|dev
operator|->
name|send
argument_list|(
name|dev
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/**  * cxgb_ofld_recv - process n received offload packets  * @dev: the offload device  * @m: an array of offload packets  * @n: the number of offload packets  *  * Process an array of ingress offload packets.  Each packet is forwarded  * to any active network taps and then passed to the offload device's receive  * method.  We optimize passing packets to the receive method by passing  * it the whole array at once except when there are active taps.  */
end_comment

begin_function
name|int
name|cxgb_ofld_recv
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CHELSIO_T3
argument_list|)
if|if
condition|(
name|likely
argument_list|(
operator|!
name|netdev_nit
argument_list|)
condition|)
return|return
name|dev
operator|->
name|recv
argument_list|(
name|dev
argument_list|,
name|skb
argument_list|,
name|n
argument_list|)
return|;
for|for
control|(
init|;
name|n
condition|;
name|n
operator|--
operator|,
name|skb
operator|++
control|)
block|{
name|skb
index|[
literal|0
index|]
operator|->
name|dev
operator|=
name|dev
operator|->
name|lldev
expr_stmt|;
name|dev_queue_xmit_nit
argument_list|(
name|skb
index|[
literal|0
index|]
argument_list|,
name|dev
operator|->
name|lldev
argument_list|)
expr_stmt|;
name|skb
index|[
literal|0
index|]
operator|->
name|dev
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|recv
argument_list|(
name|dev
argument_list|,
name|skb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
else|#
directive|else
return|return
name|dev
operator|->
name|recv
argument_list|(
name|dev
argument_list|,
name|m
argument_list|,
name|n
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|cxgb_neigh_update
parameter_list|(
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|)
block|{
if|if
condition|(
name|is_offloading
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|)
condition|)
block|{
name|struct
name|toedev
modifier|*
name|tdev
init|=
name|TOEDEV
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|)
decl_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|tdev
argument_list|)
expr_stmt|;
name|t3_l2t_update
argument_list|(
name|tdev
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_l2t_ix
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|u32
name|tid
parameter_list|,
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cpl_set_tcb_field
modifier|*
name|req
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: cannot allocate mbuf!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|CPL_PRIORITY_CONTROL
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_set_tcb_field
operator|*
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_SET_TCB_FIELD
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|reply
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|cpu_idx
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|word
operator|=
name|htons
argument_list|(
name|W_TCB_L2T_IX
argument_list|)
expr_stmt|;
name|req
operator|->
name|mask
operator|=
name|htobe64
argument_list|(
name|V_TCB_L2T_IX
argument_list|(
name|M_TCB_L2T_IX
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|val
operator|=
name|htobe64
argument_list|(
name|V_TCB_L2T_IX
argument_list|(
name|e
operator|->
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|tdev
operator|->
name|send
argument_list|(
name|tdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxgb_redirect
parameter_list|(
name|struct
name|rtentry
modifier|*
name|old
parameter_list|,
name|struct
name|rtentry
modifier|*
name|new
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|olddev
decl_stmt|,
modifier|*
name|newdev
decl_stmt|;
name|struct
name|tid_info
modifier|*
name|ti
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tdev
decl_stmt|;
name|u32
name|tid
decl_stmt|;
name|int
name|update_tcb
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|toe_tid_entry
modifier|*
name|te
decl_stmt|;
name|olddev
operator|=
name|old
operator|->
name|rt_ifp
expr_stmt|;
name|newdev
operator|=
name|new
operator|->
name|rt_ifp
expr_stmt|;
if|if
condition|(
operator|!
name|is_offloading
argument_list|(
name|olddev
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|is_offloading
argument_list|(
name|newdev
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: Redirect to non-offload"
literal|"device ignored.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
name|tdev
operator|=
name|TOEDEV
argument_list|(
name|olddev
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|tdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdev
operator|!=
name|TOEDEV
argument_list|(
name|newdev
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: Redirect to different "
literal|"offload device ignored.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Add new L2T entry */
name|e
operator|=
name|t3_l2t_get
argument_list|(
name|tdev
argument_list|,
name|new
argument_list|,
operator|(
operator|(
expr|struct
name|port_info
operator|*
operator|)
name|new
operator|->
name|rt_ifp
operator|->
name|if_softc
operator|)
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: couldn't allocate new l2t entry!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Walk tid table and notify clients of dst change. */
name|ti
operator|=
operator|&
operator|(
name|TOE_DATA
argument_list|(
name|tdev
argument_list|)
operator|)
operator|->
name|tid_maps
expr_stmt|;
for|for
control|(
name|tid
operator|=
literal|0
init|;
name|tid
operator|<
name|ti
operator|->
name|ntids
condition|;
name|tid
operator|++
control|)
block|{
name|te
operator|=
name|lookup_tid
argument_list|(
name|ti
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|te
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|ctx
operator|&&
name|te
operator|->
name|client
operator|&&
name|te
operator|->
name|client
operator|->
name|redirect
condition|)
block|{
name|update_tcb
operator|=
name|te
operator|->
name|client
operator|->
name|redirect
argument_list|(
name|te
operator|->
name|ctx
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_tcb
condition|)
block|{
name|l2t_hold
argument_list|(
name|L2DATA
argument_list|(
name|tdev
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|set_l2t_ix
argument_list|(
name|tdev
argument_list|,
name|tid
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|l2t_release
argument_list|(
name|L2DATA
argument_list|(
name|tdev
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a chunk of memory using kmalloc or, if that fails, vmalloc.  * The allocated memory is cleared.  */
end_comment

begin_function
name|void
modifier|*
name|cxgb_alloc_mem
parameter_list|(
name|unsigned
name|long
name|size
parameter_list|)
block|{
return|return
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free memory allocated through t3_alloc_mem().  */
end_comment

begin_function
name|void
name|cxgb_free_mem
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|free
argument_list|(
name|addr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate and initialize the TID tables.  Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|init_tid_tabs
parameter_list|(
name|struct
name|tid_info
modifier|*
name|t
parameter_list|,
name|unsigned
name|int
name|ntids
parameter_list|,
name|unsigned
name|int
name|natids
parameter_list|,
name|unsigned
name|int
name|nstids
parameter_list|,
name|unsigned
name|int
name|atid_base
parameter_list|,
name|unsigned
name|int
name|stid_base
parameter_list|)
block|{
name|unsigned
name|long
name|size
init|=
name|ntids
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|tid_tab
argument_list|)
operator|+
name|natids
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|atid_tab
argument_list|)
operator|+
name|nstids
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|stid_tab
argument_list|)
decl_stmt|;
name|t
operator|->
name|tid_tab
operator|=
name|cxgb_alloc_mem
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|tid_tab
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|t
operator|->
name|stid_tab
operator|=
operator|(
expr|union
name|listen_entry
operator|*
operator|)
operator|&
name|t
operator|->
name|tid_tab
index|[
name|ntids
index|]
expr_stmt|;
name|t
operator|->
name|atid_tab
operator|=
operator|(
expr|union
name|active_open_entry
operator|*
operator|)
operator|&
name|t
operator|->
name|stid_tab
index|[
name|nstids
index|]
expr_stmt|;
name|t
operator|->
name|ntids
operator|=
name|ntids
expr_stmt|;
name|t
operator|->
name|nstids
operator|=
name|nstids
expr_stmt|;
name|t
operator|->
name|stid_base
operator|=
name|stid_base
expr_stmt|;
name|t
operator|->
name|sfree
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|natids
operator|=
name|natids
expr_stmt|;
name|t
operator|->
name|atid_base
operator|=
name|atid_base
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|stids_in_use
operator|=
name|t
operator|->
name|atids_in_use
operator|=
literal|0
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|(
specifier|volatile
name|unsigned
name|int
operator|*
operator|)
operator|&
name|t
operator|->
name|tids_in_use
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|,
literal|"stid"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|t
operator|->
name|atid_lock
argument_list|,
literal|"atid"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the free lists for stid_tab and atid_tab. 	 */
if|if
condition|(
name|nstids
condition|)
block|{
while|while
condition|(
operator|--
name|nstids
condition|)
name|t
operator|->
name|stid_tab
index|[
name|nstids
operator|-
literal|1
index|]
operator|.
name|next
operator|=
operator|&
name|t
operator|->
name|stid_tab
index|[
name|nstids
index|]
expr_stmt|;
name|t
operator|->
name|sfree
operator|=
name|t
operator|->
name|stid_tab
expr_stmt|;
block|}
if|if
condition|(
name|natids
condition|)
block|{
while|while
condition|(
operator|--
name|natids
condition|)
name|t
operator|->
name|atid_tab
index|[
name|natids
operator|-
literal|1
index|]
operator|.
name|next
operator|=
operator|&
name|t
operator|->
name|atid_tab
index|[
name|natids
index|]
expr_stmt|;
name|t
operator|->
name|afree
operator|=
name|t
operator|->
name|atid_tab
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_tid_maps
parameter_list|(
name|struct
name|tid_info
modifier|*
name|t
parameter_list|)
block|{
name|cxgb_free_mem
argument_list|(
name|t
operator|->
name|tid_tab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|add_adapter
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|adapter_list
argument_list|,
name|adap
argument_list|,
name|adapter_entry
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|remove_adapter
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|adapter_list
argument_list|,
name|adap
argument_list|,
name|adapter_entry
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX  */
end_comment

begin_define
define|#
directive|define
name|t3_free_l2t
parameter_list|(
modifier|...
parameter_list|)
end_define

begin_function
name|int
name|cxgb_offload_activate
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|toedev
modifier|*
name|dev
init|=
operator|&
name|adapter
operator|->
name|tdev
decl_stmt|;
name|int
name|natids
decl_stmt|,
name|err
decl_stmt|;
name|struct
name|toe_data
modifier|*
name|t
decl_stmt|;
name|struct
name|tid_range
name|stid_range
decl_stmt|,
name|tid_range
decl_stmt|;
name|struct
name|mtutab
name|mtutab
decl_stmt|;
name|unsigned
name|int
name|l2t_capacity
decl_stmt|;
name|t
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|err
operator|=
operator|(
name|EOPNOTSUPP
operator|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|ctl
argument_list|(
name|dev
argument_list|,
name|GET_TX_MAX_CHUNK
argument_list|,
operator|&
name|t
operator|->
name|tx_max_chunk
argument_list|)
operator|<
literal|0
operator|||
name|dev
operator|->
name|ctl
argument_list|(
name|dev
argument_list|,
name|GET_MAX_OUTSTANDING_WR
argument_list|,
operator|&
name|t
operator|->
name|max_wrs
argument_list|)
operator|<
literal|0
operator|||
name|dev
operator|->
name|ctl
argument_list|(
name|dev
argument_list|,
name|GET_L2T_CAPACITY
argument_list|,
operator|&
name|l2t_capacity
argument_list|)
operator|<
literal|0
operator|||
name|dev
operator|->
name|ctl
argument_list|(
name|dev
argument_list|,
name|GET_MTUS
argument_list|,
operator|&
name|mtutab
argument_list|)
operator|<
literal|0
operator|||
name|dev
operator|->
name|ctl
argument_list|(
name|dev
argument_list|,
name|GET_TID_RANGE
argument_list|,
operator|&
name|tid_range
argument_list|)
operator|<
literal|0
operator|||
name|dev
operator|->
name|ctl
argument_list|(
name|dev
argument_list|,
name|GET_STID_RANGE
argument_list|,
operator|&
name|stid_range
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|out_free
goto|;
name|err
operator|=
operator|(
name|ENOMEM
operator|)
expr_stmt|;
name|L2DATA
argument_list|(
name|dev
argument_list|)
operator|=
name|t3_init_l2t
argument_list|(
name|l2t_capacity
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|L2DATA
argument_list|(
name|dev
argument_list|)
condition|)
goto|goto
name|out_free
goto|;
name|natids
operator|=
name|min
argument_list|(
name|tid_range
operator|.
name|num
operator|/
literal|2
argument_list|,
name|MAX_ATIDS
argument_list|)
expr_stmt|;
name|err
operator|=
name|init_tid_tabs
argument_list|(
operator|&
name|t
operator|->
name|tid_maps
argument_list|,
name|tid_range
operator|.
name|num
argument_list|,
name|natids
argument_list|,
name|stid_range
operator|.
name|num
argument_list|,
name|ATID_BASE
argument_list|,
name|stid_range
operator|.
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_free_l2t
goto|;
name|t
operator|->
name|mtus
operator|=
name|mtutab
operator|.
name|mtus
expr_stmt|;
name|t
operator|->
name|nmtus
operator|=
name|mtutab
operator|.
name|size
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|t
operator|->
name|tid_release_task
argument_list|,
literal|0
comment|/* XXX? */
argument_list|,
name|t3_process_tid_release_list
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|t
operator|->
name|tid_release_lock
argument_list|,
literal|"tid release"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|t
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|TOE_DATA
argument_list|(
name|dev
argument_list|)
operator|=
name|t
expr_stmt|;
name|dev
operator|->
name|recv
operator|=
name|process_rx
expr_stmt|;
name|dev
operator|->
name|neigh_update
operator|=
name|t3_l2t_update
expr_stmt|;
if|#
directive|if
literal|0
block|offload_proc_dev_setup(dev);
endif|#
directive|endif
comment|/* Register netevent handler once */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|adapter_list
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CHELSIO_T3_MODULE
argument_list|)
if|if
condition|(
name|prepare_arp_with_t3core
argument_list|()
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to set offload capabilities\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|add_adapter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out_free_l2t
label|:
name|t3_free_l2t
argument_list|(
name|L2DATA
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|L2DATA
argument_list|(
name|dev
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|out_free
label|:
name|free
argument_list|(
name|t
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|cxgb_offload_deactivate
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|toedev
modifier|*
name|tdev
init|=
operator|&
name|adapter
operator|->
name|tdev
decl_stmt|;
name|struct
name|toe_data
modifier|*
name|t
init|=
name|TOE_DATA
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
name|remove_adapter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|adapter_list
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CHELSIO_T3_MODULE
argument_list|)
name|restore_arp_sans_t3core
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|free_tid_maps
argument_list|(
operator|&
name|t
operator|->
name|tid_maps
argument_list|)
expr_stmt|;
name|TOE_DATA
argument_list|(
name|tdev
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|t3_free_l2t
argument_list|(
name|L2DATA
argument_list|(
name|tdev
argument_list|)
argument_list|)
expr_stmt|;
name|L2DATA
argument_list|(
name|tdev
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|register_tdev
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|)
block|{
specifier|static
name|int
name|unit
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tdev
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|tdev
operator|->
name|name
argument_list|)
argument_list|,
literal|"ofld_dev%d"
argument_list|,
name|unit
operator|++
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ofld_dev_list
argument_list|,
name|tdev
argument_list|,
name|ofld_entry
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|unregister_tdev
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ofld_dev_list
argument_list|,
name|tdev
argument_list|,
name|ofld_entry
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxgb_adapter_ofld
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|toedev
modifier|*
name|tdev
init|=
operator|&
name|adapter
operator|->
name|tdev
decl_stmt|;
name|cxgb_set_dummy_ops
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
name|tdev
operator|->
name|send
operator|=
name|t3_offload_tx
expr_stmt|;
name|tdev
operator|->
name|ctl
operator|=
name|cxgb_offload_ctl
expr_stmt|;
name|tdev
operator|->
name|type
operator|=
name|adapter
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
condition|?
name|T3A
else|:
name|T3B
expr_stmt|;
name|register_tdev
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|offload_proc_dev_init(tdev);
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|cxgb_adapter_unofld
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|toedev
modifier|*
name|tdev
init|=
operator|&
name|adapter
operator|->
name|tdev
decl_stmt|;
if|#
directive|if
literal|0
block|offload_proc_dev_cleanup(tdev); 	offload_proc_dev_exit(tdev);
endif|#
directive|endif
name|tdev
operator|->
name|recv
operator|=
name|NULL
expr_stmt|;
name|tdev
operator|->
name|neigh_update
operator|=
name|NULL
expr_stmt|;
name|unregister_tdev
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxgb_offload_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|inited
condition|)
return|return;
else|else
name|inited
operator|=
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|,
literal|"ofld db"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|adapter_list_lock
argument_list|,
literal|"ofld adap list"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|client_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ofld_dev_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|adapter_list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_CPL_CMDS
condition|;
operator|++
name|i
control|)
name|cpl_handlers
index|[
name|i
index|]
operator|=
name|do_bad_cpl
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_SMT_WRITE_RPL
argument_list|,
name|do_smt_write_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_L2T_WRITE_RPL
argument_list|,
name|do_l2t_write_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_PASS_OPEN_RPL
argument_list|,
name|do_stid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_CLOSE_LISTSRV_RPL
argument_list|,
name|do_stid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_PASS_ACCEPT_REQ
argument_list|,
name|do_cr
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_PASS_ESTABLISH
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_ABORT_RPL_RSS
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_ABORT_RPL
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_RX_URG_NOTIFY
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_RX_DATA
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_TX_DATA_ACK
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_TX_DMA_ACK
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_ACT_OPEN_RPL
argument_list|,
name|do_act_open_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_PEER_CLOSE
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_CLOSE_CON_RPL
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_ABORT_REQ_RSS
argument_list|,
name|do_abort_req_rss
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_ACT_ESTABLISH
argument_list|,
name|do_act_establish
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_SET_TCB_RPL
argument_list|,
name|do_set_tcb_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_RDMA_TERMINATE
argument_list|,
name|do_term
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_RDMA_EC_STATUS
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_TRACE_PKT
argument_list|,
name|do_trace
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_RX_DATA_DDP
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_RX_DDP_COMPLETE
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|CPL_ISCSI_HDR
argument_list|,
name|do_hwtid_rpl
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (offload_proc_init()) 	       log(LOG_WARNING, "Unable to create /proc/net/cxgb3 dir\n");
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|cxgb_offload_exit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|deinited
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|deinited
condition|)
return|return;
name|deinited
operator|=
literal|1
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|cxgb_db_lock
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|adapter_list_lock
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|offload_proc_cleanup();
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int offload_info_read_proc(char *buf, char **start, off_t offset, 				  int length, int *eof, void *data) { 	struct toe_data *d = data; 	struct tid_info *t =&d->tid_maps; 	int len;  	len = sprintf(buf, "TID range: 0..%d, in use: %u\n" 		      "STID range: %d..%d, in use: %u\n" 		      "ATID range: %d..%d, in use: %u\n" 		      "MSS: %u\n", 		      t->ntids - 1, atomic_read(&t->tids_in_use), t->stid_base, 		      t->stid_base + t->nstids - 1, t->stids_in_use, 		      t->atid_base, t->atid_base + t->natids - 1, 		      t->atids_in_use, d->tx_max_chunk); 	if (len> length) 		len = length; 	*eof = 1; 	return len; }  static int offload_info_proc_setup(struct proc_dir_entry *dir, 				   struct toe_data *d) { 	struct proc_dir_entry *p;  	if (!dir) 		return -EINVAL;  	p = create_proc_read_entry("info", 0, dir, offload_info_read_proc, d); 	if (!p) 		return -ENOMEM;  	p->owner = THIS_MODULE; 	return 0; }   static int offload_devices_read_proc(char *buf, char **start, off_t offset, 				     int length, int *eof, void *data) { 	int len; 	struct toedev *dev; 	struct net_device *ndev; 	 	len = sprintf(buf, "Device           Interfaces\n"); 	 	mtx_lock(&cxgb_db_lock); 	TAILQ_FOREACH(dev,&ofld_dev_list, ofld_entry) {	 		len += sprintf(buf + len, "%-16s", dev->name); 		read_lock(&dev_base_lock); 		for (ndev = dev_base; ndev; ndev = ndev->next) { 			if (TOEDEV(ndev) == dev) 				len += sprintf(buf + len, " %s", ndev->name); 		} 		read_unlock(&dev_base_lock); 		len += sprintf(buf + len, "\n"); 		if (len>= length) 			break; 	} 	mtx_unlock(&cxgb_db_lock); 	 	if (len> length) 		len = length; 	*eof = 1; 	return len; }
endif|#
directive|endif
end_endif

end_unit

