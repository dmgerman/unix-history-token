begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright     notice, this list of conditions and the following disclaimer in the     documentation and/or other materials provided with the distribution.   3. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_regs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_sge_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_firmware_exports.h>
end_include

begin_comment
comment|/**  *	t3_wait_op_done_val - wait until an operation is completed  *	@adapter: the adapter performing the operation  *	@reg: the register to check for completion  *	@mask: a single-bit field within @reg that indicates completion  *	@polarity: the value of the field when the operation is completed  *	@attempts: number of check iterations  *	@delay: delay in usecs between iterations  *	@valp: where to store the value of the register at completion time  *  *	Wait until an operation is completed by checking a bit in a register  *	up to @attempts times.  If @valp is not NULL the value of the register  *	at the time it indicated completion is stored there.  Returns 0 if the  *	operation completes and	-EAGAIN	otherwise.  */
end_comment

begin_function
name|int
name|t3_wait_op_done_val
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|reg
parameter_list|,
name|u32
name|mask
parameter_list|,
name|int
name|polarity
parameter_list|,
name|int
name|attempts
parameter_list|,
name|int
name|delay
parameter_list|,
name|u32
modifier|*
name|valp
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|u32
name|val
init|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|!
operator|(
name|val
operator|&
name|mask
operator|)
operator|==
name|polarity
condition|)
block|{
if|if
condition|(
name|valp
condition|)
operator|*
name|valp
operator|=
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|--
name|attempts
operator|==
literal|0
condition|)
return|return
operator|-
name|EAGAIN
return|;
if|if
condition|(
name|delay
condition|)
name|udelay
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_write_regs - write a bunch of registers  *	@adapter: the adapter to program  *	@p: an array of register address/register value pairs  *	@n: the number of address/value pairs  *	@offset: register address offset  *  *	Takes an array of register address/register value pairs and writes each  *	value to the corresponding register.  Register addresses are adjusted  *	by the supplied offset.  */
end_comment

begin_function
name|void
name|t3_write_regs
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
specifier|const
name|struct
name|addr_val_pair
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|)
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|p
operator|->
name|reg_addr
operator|+
name|offset
argument_list|,
name|p
operator|->
name|val
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_set_reg_field - set a register field to a value  *	@adapter: the adapter to program  *	@addr: the register address  *	@mask: specifies the portion of the register to modify  *	@val: the new value for the register field  *  *	Sets a register field specified by the supplied mask to the  *	given value.  */
end_comment

begin_function
name|void
name|t3_set_reg_field
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|u32
name|mask
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|u32
name|v
init|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
operator|&
operator|~
name|mask
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|,
name|v
operator||
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* flush */
block|}
end_function

begin_comment
comment|/**  *	t3_read_indirect - read indirectly addressed registers  *	@adap: the adapter  *	@addr_reg: register holding the indirect address  *	@data_reg: register holding the value of the indirect register  *	@vals: where the read register values are stored  *	@start_idx: index of first indirect register to read  *	@nregs: how many indirect registers to read  *  *	Reads registers that are accessed indirectly through an address/data  *	register pair.  */
end_comment

begin_function
name|void
name|t3_read_indirect
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr_reg
parameter_list|,
name|unsigned
name|int
name|data_reg
parameter_list|,
name|u32
modifier|*
name|vals
parameter_list|,
name|unsigned
name|int
name|nregs
parameter_list|,
name|unsigned
name|int
name|start_idx
parameter_list|)
block|{
while|while
condition|(
name|nregs
operator|--
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|addr_reg
argument_list|,
name|start_idx
argument_list|)
expr_stmt|;
operator|*
name|vals
operator|++
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|data_reg
argument_list|)
expr_stmt|;
name|start_idx
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_mc7_bd_read - read from MC7 through backdoor accesses  *	@mc7: identifies MC7 to read from  *	@start: index of first 64-bit word to read  *	@n: number of 64-bit words to read  *	@buf: where to store the read result  *  *	Read n 64-bit words from MC7 starting at word start, using backdoor  *	accesses.  */
end_comment

begin_function
name|int
name|t3_mc7_bd_read
parameter_list|(
name|struct
name|mc7
modifier|*
name|mc7
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
name|u64
modifier|*
name|buf
parameter_list|)
block|{
specifier|static
name|int
name|shift
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|24
block|}
decl_stmt|;
specifier|static
name|int
name|step
index|[]
init|=
block|{
literal|0
block|,
literal|32
block|,
literal|16
block|,
literal|8
block|}
decl_stmt|;
name|unsigned
name|int
name|size64
init|=
name|mc7
operator|->
name|size
operator|/
literal|8
decl_stmt|;
comment|/* # of 64-bit words */
name|adapter_t
modifier|*
name|adap
init|=
name|mc7
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
name|start
operator|>=
name|size64
operator|||
name|start
operator|+
name|n
operator|>
name|size64
condition|)
return|return
operator|-
name|EINVAL
return|;
name|start
operator|*=
operator|(
literal|8
operator|<<
name|mc7
operator|->
name|width
operator|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|int
name|i
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
literal|1
operator|<<
name|mc7
operator|->
name|width
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|int
name|attempts
init|=
literal|10
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BD_ADDR
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BD_OP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BD_OP
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|val
operator|&
name|F_BUSY
operator|)
operator|&&
name|attempts
operator|--
condition|)
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BD_OP
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|F_BUSY
condition|)
return|return
operator|-
name|EIO
return|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BD_DATA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc7
operator|->
name|width
operator|==
literal|0
condition|)
block|{
name|val64
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BD_DATA0
argument_list|)
expr_stmt|;
name|val64
operator||=
operator|(
name|u64
operator|)
name|val
operator|<<
literal|32
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mc7
operator|->
name|width
operator|>
literal|1
condition|)
name|val
operator|>>=
name|shift
index|[
name|mc7
operator|->
name|width
index|]
expr_stmt|;
name|val64
operator||=
operator|(
name|u64
operator|)
name|val
operator|<<
operator|(
name|step
index|[
name|mc7
operator|->
name|width
index|]
operator|*
name|i
operator|)
expr_stmt|;
block|}
name|start
operator|+=
literal|8
expr_stmt|;
block|}
operator|*
name|buf
operator|++
operator|=
name|val64
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize MI1.  */
end_comment

begin_function
specifier|static
name|void
name|mi1_init
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
parameter_list|)
block|{
name|u32
name|clkdiv
init|=
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|/
operator|(
literal|2
operator|*
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|mdc
operator|)
operator|-
literal|1
decl_stmt|;
name|u32
name|val
init|=
name|F_PREEN
operator||
name|V_MDIINV
argument_list|(
name|ai
operator|->
name|mdiinv
argument_list|)
operator||
name|V_MDIEN
argument_list|(
name|ai
operator|->
name|mdien
argument_list|)
operator||
name|V_CLKDIV
argument_list|(
name|clkdiv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ai
operator|->
name|caps
operator|&
name|SUPPORTED_10000baseT_Full
operator|)
condition|)
name|val
operator||=
name|V_ST
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MI1_CFG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MDIO_ATTEMPTS
value|10
end_define

begin_comment
comment|/*  * MI1 read/write operations for direct-addressed PHYs.  */
end_comment

begin_function
specifier|static
name|int
name|mi1_read
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|phy_addr
parameter_list|,
name|int
name|mmd_addr
parameter_list|,
name|int
name|reg_addr
parameter_list|,
name|unsigned
name|int
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|addr
init|=
name|V_REGADDR
argument_list|(
name|reg_addr
argument_list|)
operator||
name|V_PHYADDR
argument_list|(
name|phy_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|mmd_addr
condition|)
return|return
operator|-
name|EINVAL
return|;
name|MDIO_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|V_MDI_OP
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|MDIO_ATTEMPTS
argument_list|,
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
operator|*
name|valp
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_DATA
argument_list|)
expr_stmt|;
name|MDIO_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mi1_write
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|phy_addr
parameter_list|,
name|int
name|mmd_addr
parameter_list|,
name|int
name|reg_addr
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|addr
init|=
name|V_REGADDR
argument_list|(
name|reg_addr
argument_list|)
operator||
name|V_PHYADDR
argument_list|(
name|phy_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|mmd_addr
condition|)
return|return
operator|-
name|EINVAL
return|;
name|MDIO_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|V_MDI_OP
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|MDIO_ATTEMPTS
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|MDIO_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mdio_ops
name|mi1_mdio_ops
init|=
block|{
name|mi1_read
block|,
name|mi1_write
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * MI1 read/write operations for indirect-addressed PHYs.  */
end_comment

begin_function
specifier|static
name|int
name|mi1_ext_read
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|phy_addr
parameter_list|,
name|int
name|mmd_addr
parameter_list|,
name|int
name|reg_addr
parameter_list|,
name|unsigned
name|int
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|addr
init|=
name|V_REGADDR
argument_list|(
name|mmd_addr
argument_list|)
operator||
name|V_PHYADDR
argument_list|(
name|phy_addr
argument_list|)
decl_stmt|;
name|MDIO_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_DATA
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|V_MDI_OP
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|MDIO_ATTEMPTS
argument_list|,
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|V_MDI_OP
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|MDIO_ATTEMPTS
argument_list|,
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
operator|*
name|valp
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_DATA
argument_list|)
expr_stmt|;
block|}
name|MDIO_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mi1_ext_write
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|phy_addr
parameter_list|,
name|int
name|mmd_addr
parameter_list|,
name|int
name|reg_addr
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|addr
init|=
name|V_REGADDR
argument_list|(
name|mmd_addr
argument_list|)
operator||
name|V_PHYADDR
argument_list|(
name|phy_addr
argument_list|)
decl_stmt|;
name|MDIO_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_DATA
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|V_MDI_OP
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|MDIO_ATTEMPTS
argument_list|,
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|V_MDI_OP
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|MDIO_ATTEMPTS
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
name|MDIO_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mdio_ops
name|mi1_mdio_ext_ops
init|=
block|{
name|mi1_ext_read
block|,
name|mi1_ext_write
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  *	t3_mdio_change_bits - modify the value of a PHY register  *	@phy: the PHY to operate on  *	@mmd: the device address  *	@reg: the register address  *	@clear: what part of the register value to mask off  *	@set: what part of the register value to set  *  *	Changes the value of a PHY register by applying a mask to its current  *	value and ORing the result with a new value.  */
end_comment

begin_function
name|int
name|t3_mdio_change_bits
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|,
name|int
name|mmd
parameter_list|,
name|int
name|reg
parameter_list|,
name|unsigned
name|int
name|clear
parameter_list|,
name|unsigned
name|int
name|set
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
name|ret
operator|=
name|mdio_read
argument_list|(
name|phy
argument_list|,
name|mmd
argument_list|,
name|reg
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|val
operator|&=
operator|~
name|clear
expr_stmt|;
name|ret
operator|=
name|mdio_write
argument_list|(
name|phy
argument_list|,
name|mmd
argument_list|,
name|reg
argument_list|,
name|val
operator||
name|set
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_phy_reset - reset a PHY block  *	@phy: the PHY to operate on  *	@mmd: the device address of the PHY block to reset  *	@wait: how long to wait for the reset to complete in 1ms increments  *  *	Resets a PHY block and optionally waits for the reset to complete.  *	@mmd should be 0 for 10/100/1000 PHYs and the device address to reset  *	for 10G PHYs.  */
end_comment

begin_function
name|int
name|t3_phy_reset
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|,
name|int
name|mmd
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|unsigned
name|int
name|ctl
decl_stmt|;
name|err
operator|=
name|t3_mdio_change_bits
argument_list|(
name|phy
argument_list|,
name|mmd
argument_list|,
name|MII_BMCR
argument_list|,
name|BMCR_PDOWN
argument_list|,
name|BMCR_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
operator|!
name|wait
condition|)
return|return
name|err
return|;
do|do
block|{
name|err
operator|=
name|mdio_read
argument_list|(
name|phy
argument_list|,
name|mmd
argument_list|,
name|MII_BMCR
argument_list|,
operator|&
name|ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|ctl
operator|&=
name|BMCR_RESET
expr_stmt|;
if|if
condition|(
name|ctl
condition|)
name|t3_os_sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ctl
operator|&&
operator|--
name|wait
condition|)
do|;
return|return
name|ctl
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_phy_advertise - set the PHY advertisement registers for autoneg  *	@phy: the PHY to operate on  *	@advert: bitmap of capabilities the PHY should advertise  *  *	Sets a 10/100/1000 PHY's advertisement registers to advertise the  *	requested capabilities.  */
end_comment

begin_function
name|int
name|t3_phy_advertise
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|,
name|unsigned
name|int
name|advert
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|unsigned
name|int
name|val
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|mdio_read
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|,
name|MII_CTRL1000
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|val
operator|&=
operator|~
operator|(
name|ADVERTISE_1000HALF
operator||
name|ADVERTISE_1000FULL
operator|)
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_1000baseT_Half
condition|)
name|val
operator||=
name|ADVERTISE_1000HALF
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_1000baseT_Full
condition|)
name|val
operator||=
name|ADVERTISE_1000FULL
expr_stmt|;
name|err
operator|=
name|mdio_write
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|,
name|MII_CTRL1000
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|val
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_10baseT_Half
condition|)
name|val
operator||=
name|ADVERTISE_10HALF
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_10baseT_Full
condition|)
name|val
operator||=
name|ADVERTISE_10FULL
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_100baseT_Half
condition|)
name|val
operator||=
name|ADVERTISE_100HALF
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_100baseT_Full
condition|)
name|val
operator||=
name|ADVERTISE_100FULL
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_Pause
condition|)
name|val
operator||=
name|ADVERTISE_PAUSE_CAP
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_Asym_Pause
condition|)
name|val
operator||=
name|ADVERTISE_PAUSE_ASYM
expr_stmt|;
return|return
name|mdio_write
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|,
name|MII_ADVERTISE
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_set_phy_speed_duplex - force PHY speed and duplex  *	@phy: the PHY to operate on  *	@speed: requested PHY speed  *	@duplex: requested PHY duplex  *  *	Force a 10/100/1000 PHY's speed and duplex.  This also disables  *	auto-negotiation except for GigE, where auto-negotiation is mandatory.  */
end_comment

begin_function
name|int
name|t3_set_phy_speed_duplex
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|,
name|int
name|speed
parameter_list|,
name|int
name|duplex
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|unsigned
name|int
name|ctl
decl_stmt|;
name|err
operator|=
name|mdio_read
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|,
name|MII_BMCR
argument_list|,
operator|&
name|ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|speed
operator|>=
literal|0
condition|)
block|{
name|ctl
operator|&=
operator|~
operator|(
name|BMCR_SPEED100
operator||
name|BMCR_SPEED1000
operator||
name|BMCR_ANENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|speed
operator|==
name|SPEED_100
condition|)
name|ctl
operator||=
name|BMCR_SPEED100
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
name|SPEED_1000
condition|)
name|ctl
operator||=
name|BMCR_SPEED1000
expr_stmt|;
block|}
if|if
condition|(
name|duplex
operator|>=
literal|0
condition|)
block|{
name|ctl
operator|&=
operator|~
operator|(
name|BMCR_FULLDPLX
operator||
name|BMCR_ANENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|duplex
operator|==
name|DUPLEX_FULL
condition|)
name|ctl
operator||=
name|BMCR_FULLDPLX
expr_stmt|;
block|}
if|if
condition|(
name|ctl
operator|&
name|BMCR_SPEED1000
condition|)
comment|/* auto-negotiation required for GigE */
name|ctl
operator||=
name|BMCR_ANENABLE
expr_stmt|;
return|return
name|mdio_write
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|,
name|MII_BMCR
argument_list|,
name|ctl
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|adapter_info
name|t3_adap_info
index|[]
init|=
block|{
block|{
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|F_GPIO2_OEN
operator||
name|F_GPIO4_OEN
operator||
name|F_GPIO2_OUT_VAL
operator||
name|F_GPIO4_OUT_VAL
block|,
name|F_GPIO3
operator||
name|F_GPIO5
block|,
name|SUPPORTED_OFFLOAD
block|,
operator|&
name|mi1_mdio_ops
block|,
literal|"Chelsio PE9000"
block|}
block|,
block|{
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|F_GPIO2_OEN
operator||
name|F_GPIO4_OEN
operator||
name|F_GPIO2_OUT_VAL
operator||
name|F_GPIO4_OUT_VAL
block|,
name|F_GPIO3
operator||
name|F_GPIO5
block|,
name|SUPPORTED_OFFLOAD
block|,
operator|&
name|mi1_mdio_ops
block|,
literal|"Chelsio T302"
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|F_GPIO1_OEN
operator||
name|F_GPIO6_OEN
operator||
name|F_GPIO7_OEN
operator||
name|F_GPIO10_OEN
operator||
name|F_GPIO1_OUT_VAL
operator||
name|F_GPIO6_OUT_VAL
operator||
name|F_GPIO10_OUT_VAL
block|,
literal|0
block|,
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_AUI
operator||
name|SUPPORTED_OFFLOAD
block|,
operator|&
name|mi1_mdio_ext_ops
block|,
literal|"Chelsio T310"
block|}
block|,
block|{
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|F_GPIO1_OEN
operator||
name|F_GPIO2_OEN
operator||
name|F_GPIO4_OEN
operator||
name|F_GPIO5_OEN
operator||
name|F_GPIO6_OEN
operator||
name|F_GPIO7_OEN
operator||
name|F_GPIO10_OEN
operator||
name|F_GPIO11_OEN
operator||
name|F_GPIO1_OUT_VAL
operator||
name|F_GPIO5_OUT_VAL
operator||
name|F_GPIO6_OUT_VAL
operator||
name|F_GPIO10_OUT_VAL
block|,
literal|0
block|,
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_AUI
operator||
name|SUPPORTED_OFFLOAD
block|,
operator|&
name|mi1_mdio_ext_ops
block|,
literal|"Chelsio T320"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return the adapter_info structure with a given index.  Out-of-range indices  * return NULL.  */
end_comment

begin_function
specifier|const
name|struct
name|adapter_info
modifier|*
name|t3_get_adapter_info
parameter_list|(
name|unsigned
name|int
name|id
parameter_list|)
block|{
return|return
name|id
operator|<
name|ARRAY_SIZE
argument_list|(
name|t3_adap_info
argument_list|)
condition|?
operator|&
name|t3_adap_info
index|[
name|id
index|]
else|:
name|NULL
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CAPS_1G
value|(SUPPORTED_10baseT_Full | SUPPORTED_100baseT_Full | \ 		 SUPPORTED_1000baseT_Full | SUPPORTED_Autoneg | SUPPORTED_MII)
end_define

begin_define
define|#
directive|define
name|CAPS_10G
value|(SUPPORTED_10000baseT_Full | SUPPORTED_AUI)
end_define

begin_decl_stmt
specifier|static
name|struct
name|port_type_info
name|port_types
index|[]
init|=
block|{
block|{
name|NULL
block|}
block|,
block|{
name|t3_ael1002_phy_prep
block|,
name|CAPS_10G
operator||
name|SUPPORTED_FIBRE
block|,
literal|"10GBASE-XR"
block|}
block|,
block|{
name|t3_vsc8211_phy_prep
block|,
name|CAPS_1G
operator||
name|SUPPORTED_TP
operator||
name|SUPPORTED_IRQ
block|,
literal|"10/100/1000BASE-T"
block|}
block|,
block|{
name|t3_mv88e1xxx_phy_prep
block|,
name|CAPS_1G
operator||
name|SUPPORTED_TP
operator||
name|SUPPORTED_IRQ
block|,
literal|"10/100/1000BASE-T"
block|}
block|,
block|{
name|t3_xaui_direct_phy_prep
block|,
name|CAPS_10G
operator||
name|SUPPORTED_TP
block|,
literal|"10GBASE-CX4"
block|}
block|,
block|{
name|NULL
block|,
name|CAPS_10G
block|,
literal|"10GBASE-KX4"
block|}
block|,
block|{
name|t3_qt2045_phy_prep
block|,
name|CAPS_10G
operator||
name|SUPPORTED_TP
block|,
literal|"10GBASE-CX4"
block|}
block|,
block|{
name|t3_ael1006_phy_prep
block|,
name|CAPS_10G
operator||
name|SUPPORTED_FIBRE
block|,
literal|"10GBASE-SR"
block|}
block|,
block|{
name|NULL
block|,
name|CAPS_10G
operator||
name|SUPPORTED_TP
block|,
literal|"10GBASE-CX4"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|CAPS_1G
end_undef

begin_undef
undef|#
directive|undef
name|CAPS_10G
end_undef

begin_define
define|#
directive|define
name|VPD_ENTRY
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
define|\
value|u8 name##_kword[2]; u8 name##_len; u8 name##_data[len]
end_define

begin_comment
comment|/*  * Partial EEPROM Vital Product Data structure.  Includes only the ID and  * VPD-R sections.  */
end_comment

begin_struct
struct|struct
name|t3_vpd
block|{
name|u8
name|id_tag
decl_stmt|;
name|u8
name|id_len
index|[
literal|2
index|]
decl_stmt|;
name|u8
name|id_data
index|[
literal|16
index|]
decl_stmt|;
name|u8
name|vpdr_tag
decl_stmt|;
name|u8
name|vpdr_len
index|[
literal|2
index|]
decl_stmt|;
name|VPD_ENTRY
argument_list|(
name|pn
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* part number */
name|VPD_ENTRY
argument_list|(
name|ec
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* EC level */
name|VPD_ENTRY
argument_list|(
name|sn
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* serial number */
name|VPD_ENTRY
argument_list|(
name|na
argument_list|,
literal|12
argument_list|)
expr_stmt|;
comment|/* MAC address base */
name|VPD_ENTRY
argument_list|(
name|cclk
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* core clock */
name|VPD_ENTRY
argument_list|(
name|mclk
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* mem clock */
name|VPD_ENTRY
argument_list|(
name|uclk
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* uP clk */
name|VPD_ENTRY
argument_list|(
name|mdc
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* MDIO clk */
name|VPD_ENTRY
argument_list|(
name|mt
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* mem timing */
name|VPD_ENTRY
argument_list|(
name|xaui0cfg
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* XAUI0 config */
name|VPD_ENTRY
argument_list|(
name|xaui1cfg
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* XAUI1 config */
name|VPD_ENTRY
argument_list|(
name|port0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* PHY0 complex */
name|VPD_ENTRY
argument_list|(
name|port1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* PHY1 complex */
name|VPD_ENTRY
argument_list|(
name|port2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* PHY2 complex */
name|VPD_ENTRY
argument_list|(
name|port3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* PHY3 complex */
name|VPD_ENTRY
argument_list|(
name|rv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* csum */
name|u32
name|pad
decl_stmt|;
comment|/* for multiple-of-4 sizing and alignment */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|EEPROM_MAX_POLL
value|4
end_define

begin_define
define|#
directive|define
name|EEPROM_STAT_ADDR
value|0x4000
end_define

begin_define
define|#
directive|define
name|VPD_BASE
value|0xc00
end_define

begin_comment
comment|/**  *	t3_seeprom_read - read a VPD EEPROM location  *	@adapter: adapter to read  *	@addr: EEPROM address  *	@data: where to store the read data  *  *	Read a 32-bit word from a location in VPD EEPROM using the card's PCI  *	VPD ROM capability.  A zero is written to the flag bit when the  *	addres is written to the control register.  The hardware device will  *	set the flag to 1 when 4 bytes have been read into the data register.  */
end_comment

begin_function
name|int
name|t3_seeprom_read
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
name|u16
name|val
decl_stmt|;
name|int
name|attempts
init|=
name|EEPROM_MAX_POLL
decl_stmt|;
name|unsigned
name|int
name|base
init|=
name|adapter
operator|->
name|params
operator|.
name|pci
operator|.
name|vpd_cap_addr
decl_stmt|;
if|if
condition|(
operator|(
name|addr
operator|>=
name|EEPROMSIZE
operator|&&
name|addr
operator|!=
name|EEPROM_STAT_ADDR
operator|)
operator|||
operator|(
name|addr
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t3_os_pci_write_config_2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|(
name|u16
operator|)
name|addr
argument_list|)
expr_stmt|;
do|do
block|{
name|udelay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|t3_os_pci_read_config_2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|val
operator|&
name|PCI_VPD_ADDR_F
operator|)
operator|&&
operator|--
name|attempts
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PCI_VPD_ADDR_F
operator|)
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"reading EEPROM address 0x%x failed\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
name|t3_os_pci_read_config_4
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|le32_to_cpu
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_seeprom_write - write a VPD EEPROM location  *	@adapter: adapter to write  *	@addr: EEPROM address  *	@data: value to write  *  *	Write a 32-bit word to a location in VPD EEPROM using the card's PCI  *	VPD ROM capability.  */
end_comment

begin_function
name|int
name|t3_seeprom_write
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|data
parameter_list|)
block|{
name|u16
name|val
decl_stmt|;
name|int
name|attempts
init|=
name|EEPROM_MAX_POLL
decl_stmt|;
name|unsigned
name|int
name|base
init|=
name|adapter
operator|->
name|params
operator|.
name|pci
operator|.
name|vpd_cap_addr
decl_stmt|;
if|if
condition|(
operator|(
name|addr
operator|>=
name|EEPROMSIZE
operator|&&
name|addr
operator|!=
name|EEPROM_STAT_ADDR
operator|)
operator|||
operator|(
name|addr
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t3_os_pci_write_config_4
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_DATA
argument_list|,
name|cpu_to_le32
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|t3_os_pci_write_config_2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|(
name|u16
operator|)
name|addr
operator||
name|PCI_VPD_ADDR_F
argument_list|)
expr_stmt|;
do|do
block|{
name|t3_os_sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|t3_os_pci_read_config_2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|val
operator|&
name|PCI_VPD_ADDR_F
operator|)
operator|&&
operator|--
name|attempts
condition|)
do|;
if|if
condition|(
name|val
operator|&
name|PCI_VPD_ADDR_F
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"write to EEPROM address 0x%x failed\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_seeprom_wp - enable/disable EEPROM write protection  *	@adapter: the adapter  *	@enable: 1 to enable write protection, 0 to disable it  *  *	Enables or disables write protection on the serial EEPROM.  */
end_comment

begin_function
name|int
name|t3_seeprom_wp
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
return|return
name|t3_seeprom_write
argument_list|(
name|adapter
argument_list|,
name|EEPROM_STAT_ADDR
argument_list|,
name|enable
condition|?
literal|0xc
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a character holding a hex digit to a number.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hex2int
parameter_list|(
name|unsigned
name|char
name|c
parameter_list|)
block|{
return|return
name|isdigit
argument_list|(
name|c
argument_list|)
condition|?
name|c
operator|-
literal|'0'
else|:
name|toupper
argument_list|(
name|c
argument_list|)
operator|-
literal|'A'
operator|+
literal|10
return|;
block|}
end_function

begin_comment
comment|/**  *	get_vpd_params - read VPD parameters from VPD EEPROM  *	@adapter: adapter to read  *	@p: where to store the parameters  *  *	Reads card parameters stored in VPD EEPROM.  */
end_comment

begin_function
specifier|static
name|int
name|get_vpd_params
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|struct
name|vpd_params
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|addr
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|t3_vpd
name|vpd
decl_stmt|;
comment|/* 	 * Card information is normally at VPD_BASE but some early cards had 	 * it at 0. 	 */
name|ret
operator|=
name|t3_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|VPD_BASE
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|vpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|addr
operator|=
name|vpd
operator|.
name|id_tag
operator|==
literal|0x82
condition|?
name|VPD_BASE
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|vpd
argument_list|)
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|ret
operator|=
name|t3_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|addr
operator|+
name|i
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
operator|&
name|vpd
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|p
operator|->
name|cclk
operator|=
name|simple_strtoul
argument_list|(
name|vpd
operator|.
name|cclk_data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|mclk
operator|=
name|simple_strtoul
argument_list|(
name|vpd
operator|.
name|mclk_data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|uclk
operator|=
name|simple_strtoul
argument_list|(
name|vpd
operator|.
name|uclk_data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|mdc
operator|=
name|simple_strtoul
argument_list|(
name|vpd
operator|.
name|mdc_data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|mem_timing
operator|=
name|simple_strtoul
argument_list|(
name|vpd
operator|.
name|mt_data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Old eeproms didn't have port information */
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
operator|&&
operator|!
name|vpd
operator|.
name|port0_data
index|[
literal|0
index|]
condition|)
block|{
name|p
operator|->
name|port_type
index|[
literal|0
index|]
operator|=
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
name|p
operator|->
name|port_type
index|[
literal|1
index|]
operator|=
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|?
literal|6
else|:
literal|2
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|port_type
index|[
literal|0
index|]
operator|=
operator|(
name|u8
operator|)
name|hex2int
argument_list|(
name|vpd
operator|.
name|port0_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|port_type
index|[
literal|1
index|]
operator|=
operator|(
name|u8
operator|)
name|hex2int
argument_list|(
name|vpd
operator|.
name|port1_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|xauicfg
index|[
literal|0
index|]
operator|=
name|simple_strtoul
argument_list|(
name|vpd
operator|.
name|xaui0cfg_data
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|p
operator|->
name|xauicfg
index|[
literal|1
index|]
operator|=
name|simple_strtoul
argument_list|(
name|vpd
operator|.
name|xaui1cfg_data
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|eth_base
index|[
name|i
index|]
operator|=
name|hex2int
argument_list|(
name|vpd
operator|.
name|na_data
index|[
literal|2
operator|*
name|i
index|]
argument_list|)
operator|*
literal|16
operator|+
name|hex2int
argument_list|(
name|vpd
operator|.
name|na_data
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* serial flash and firmware constants */
end_comment

begin_enum
enum|enum
block|{
name|SF_ATTEMPTS
init|=
literal|5
block|,
comment|/* max retries for SF1 operations */
name|SF_SEC_SIZE
init|=
literal|64
operator|*
literal|1024
block|,
comment|/* serial flash sector size */
name|SF_SIZE
init|=
name|SF_SEC_SIZE
operator|*
literal|8
block|,
comment|/* serial flash size */
comment|/* flash command opcodes */
name|SF_PROG_PAGE
init|=
literal|2
block|,
comment|/* program page */
name|SF_WR_DISABLE
init|=
literal|4
block|,
comment|/* disable writes */
name|SF_RD_STATUS
init|=
literal|5
block|,
comment|/* read status register */
name|SF_WR_ENABLE
init|=
literal|6
block|,
comment|/* enable writes */
name|SF_RD_DATA_FAST
init|=
literal|0xb
block|,
comment|/* read flash */
name|SF_ERASE_SECTOR
init|=
literal|0xd8
block|,
comment|/* erase sector */
name|FW_FLASH_BOOT_ADDR
init|=
literal|0x70000
block|,
comment|/* start address of FW in flash */
name|FW_VERS_ADDR
init|=
literal|0x77ffc
block|,
comment|/* flash address holding FW version */
name|FW_MIN_SIZE
init|=
literal|8
comment|/* at least version and csum */
block|}
enum|;
end_enum

begin_comment
comment|/**  *	sf1_read - read data from the serial flash  *	@adapter: the adapter  *	@byte_cnt: number of bytes to read  *	@cont: whether another operation will be chained  *	@valp: where to store the read data  *  *	Reads up to 4 bytes of data from the serial flash.  The location of  *	the read needs to be specified prior to calling this by issuing the  *	appropriate commands to the serial flash.  */
end_comment

begin_function
specifier|static
name|int
name|sf1_read
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|byte_cnt
parameter_list|,
name|int
name|cont
parameter_list|,
name|u32
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|byte_cnt
operator|||
name|byte_cnt
operator|>
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|)
operator|&
name|F_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|V_CONT
argument_list|(
name|cont
argument_list|)
operator||
name|V_BYTECNT
argument_list|(
name|byte_cnt
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|SF_ATTEMPTS
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
operator|*
name|valp
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_DATA
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	sf1_write - write data to the serial flash  *	@adapter: the adapter  *	@byte_cnt: number of bytes to write  *	@cont: whether another operation will be chained  *	@val: value to write  *  *	Writes up to 4 bytes of data to the serial flash.  The location of  *	the write needs to be specified prior to calling this by issuing the  *	appropriate commands to the serial flash.  */
end_comment

begin_function
specifier|static
name|int
name|sf1_write
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|byte_cnt
parameter_list|,
name|int
name|cont
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|!
name|byte_cnt
operator|||
name|byte_cnt
operator|>
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|)
operator|&
name|F_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|V_CONT
argument_list|(
name|cont
argument_list|)
operator||
name|V_BYTECNT
argument_list|(
name|byte_cnt
operator|-
literal|1
argument_list|)
operator||
name|V_OP
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|SF_ATTEMPTS
argument_list|,
literal|10
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	flash_wait_op - wait for a flash operation to complete  *	@adapter: the adapter  *	@attempts: max number of polls of the status register  *	@delay: delay between polls in ms  *  *	Wait for a flash operation to complete by polling the status register.  */
end_comment

begin_function
specifier|static
name|int
name|flash_wait_op
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|attempts
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|status
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|SF_RD_STATUS
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_read
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|--
name|attempts
operator|==
literal|0
condition|)
return|return
operator|-
name|EAGAIN
return|;
if|if
condition|(
name|delay
condition|)
name|t3_os_sleep
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_read_flash - read words from serial flash  *	@adapter: the adapter  *	@addr: the start address for the read  *	@nwords: how many 32-bit words to read  *	@data: where to store the read data  *	@byte_oriented: whether to store data as bytes or as words  *  *	Read the specified number of 32-bit words from the serial flash.  *	If @byte_oriented is set the read data is stored as a byte array  *	(i.e., big-endian), otherwise as 32-bit words in the platform's  *	natural endianess.  */
end_comment

begin_function
name|int
name|t3_read_flash
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|nwords
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|,
name|int
name|byte_oriented
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|addr
operator|+
name|nwords
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|>
name|SF_SIZE
operator|||
operator|(
name|addr
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|addr
operator|=
name|swab32
argument_list|(
name|addr
argument_list|)
operator||
name|SF_RD_DATA_FAST
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|addr
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_read
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
for|for
control|(
init|;
name|nwords
condition|;
name|nwords
operator|--
operator|,
name|data
operator|++
control|)
block|{
name|ret
operator|=
name|sf1_read
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
name|nwords
operator|>
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|byte_oriented
condition|)
operator|*
name|data
operator|=
name|htonl
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_write_flash - write up to a page of data to the serial flash  *	@adapter: the adapter  *	@addr: the start address to write  *	@n: length of data to write  *	@data: the data to write  *  *	Writes up to a page of data (256 bytes) to the serial flash starting  *	at the given address.  */
end_comment

begin_function
specifier|static
name|int
name|t3_write_flash
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|left
decl_stmt|,
name|val
decl_stmt|,
name|offset
init|=
name|addr
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|addr
operator|+
name|n
operator|>
name|SF_SIZE
operator|||
name|offset
operator|+
name|n
operator|>
literal|256
condition|)
return|return
operator|-
name|EINVAL
return|;
name|val
operator|=
name|swab32
argument_list|(
name|addr
argument_list|)
operator||
name|SF_PROG_PAGE
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|SF_WR_ENABLE
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|val
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
for|for
control|(
name|left
operator|=
name|n
init|;
name|left
condition|;
name|left
operator|-=
name|c
control|)
block|{
name|c
operator|=
name|min
argument_list|(
name|left
argument_list|,
literal|4U
argument_list|)
expr_stmt|;
for|for
control|(
name|val
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
operator|++
name|i
control|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
operator|*
name|data
operator|++
expr_stmt|;
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
name|c
argument_list|,
name|c
operator|!=
name|left
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|flash_wait_op
argument_list|(
name|adapter
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
comment|/* Read the page to verify the write succeeded */
name|ret
operator|=
name|t3_read_flash
argument_list|(
name|adapter
argument_list|,
name|addr
operator|&
operator|~
literal|0xff
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|data
operator|-
name|n
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|buf
operator|+
name|offset
argument_list|,
name|n
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
return|return
literal|0
return|;
block|}
end_function

begin_enum
enum|enum
name|fw_version_type
block|{
name|FW_VERSION_N3
block|,
name|FW_VERSION_T3
block|}
enum|;
end_enum

begin_comment
comment|/**  *	t3_get_fw_version - read the firmware version  *	@adapter: the adapter  *	@vers: where to place the version  *  *	Reads the FW version from flash.  */
end_comment

begin_function
name|int
name|t3_get_fw_version
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
modifier|*
name|vers
parameter_list|)
block|{
return|return
name|t3_read_flash
argument_list|(
name|adapter
argument_list|,
name|FW_VERS_ADDR
argument_list|,
literal|1
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_check_fw_version - check if the FW is compatible with this driver  *	@adapter: the adapter  *  *	Checks if an adapter's FW is compatible with the driver.  Returns 0  *	if the versions are compatible, a negative error otherwise.  */
end_comment

begin_function
name|int
name|t3_check_fw_version
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|vers
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|,
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|ret
operator|=
name|t3_get_fw_version
argument_list|(
name|adapter
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|type
operator|=
name|G_FW_VERSION_TYPE
argument_list|(
name|vers
argument_list|)
expr_stmt|;
name|major
operator|=
name|G_FW_VERSION_MAJOR
argument_list|(
name|vers
argument_list|)
expr_stmt|;
name|minor
operator|=
name|G_FW_VERSION_MINOR
argument_list|(
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|FW_VERSION_T3
operator|&&
name|major
operator|==
name|FW_VERSION_MAJOR
operator|&&
name|minor
operator|==
name|FW_VERSION_MINOR
condition|)
return|return
literal|0
return|;
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"found wrong FW version(%u.%u), "
literal|"driver needs version %d.%d\n"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|FW_VERSION_MAJOR
argument_list|,
name|FW_VERSION_MINOR
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_flash_erase_sectors - erase a range of flash sectors  *	@adapter: the adapter  *	@start: the first sector to erase  *	@end: the last sector to erase  *  *	Erases the sectors in the given range.  */
end_comment

begin_function
specifier|static
name|int
name|t3_flash_erase_sectors
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
while|while
condition|(
name|start
operator|<=
name|end
condition|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|SF_WR_ENABLE
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|SF_ERASE_SECTOR
operator||
operator|(
name|start
operator|<<
literal|8
operator|)
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|flash_wait_op
argument_list|(
name|adapter
argument_list|,
literal|5
argument_list|,
literal|500
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
name|start
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *	t3_load_fw - download firmware  *	@adapter: the adapter  *	@fw_data: the firrware image to write  *	@size: image size  *  *	Write the supplied firmware image to the card's serial flash.  *	The FW image has the following sections: @size - 8 bytes of code and  *	data, followed by 4 bytes of FW version, followed by the 32-bit  *	1's complement checksum of the whole image.  */
end_comment

begin_function
name|int
name|t3_load_fw
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
specifier|const
name|u8
modifier|*
name|fw_data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|u32
name|csum
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|u32
modifier|*
name|p
init|=
operator|(
specifier|const
name|u32
operator|*
operator|)
name|fw_data
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|addr
decl_stmt|,
name|fw_sector
init|=
name|FW_FLASH_BOOT_ADDR
operator|>>
literal|16
decl_stmt|;
if|if
condition|(
operator|(
name|size
operator|&
literal|3
operator|)
operator|||
operator|(
name|size
operator|<
name|FW_MIN_SIZE
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|size
operator|>
name|FW_VERS_ADDR
operator|+
literal|8
operator|-
name|FW_FLASH_BOOT_ADDR
condition|)
return|return
operator|-
name|EFBIG
return|;
for|for
control|(
name|csum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|/
sizeof|sizeof
argument_list|(
name|csum
argument_list|)
condition|;
name|i
operator|++
control|)
name|csum
operator|+=
name|ntohl
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
literal|0xffffffff
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"corrupted firmware image, checksum %u\n"
argument_list|,
name|csum
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|ret
operator|=
name|t3_flash_erase_sectors
argument_list|(
name|adapter
argument_list|,
name|fw_sector
argument_list|,
name|fw_sector
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|size
operator|-=
literal|8
expr_stmt|;
comment|/* trim off version and checksum */
for|for
control|(
name|addr
operator|=
name|FW_FLASH_BOOT_ADDR
init|;
name|size
condition|;
control|)
block|{
name|unsigned
name|int
name|chunk_size
init|=
name|min
argument_list|(
name|size
argument_list|,
literal|256U
argument_list|)
decl_stmt|;
name|ret
operator|=
name|t3_write_flash
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|,
name|chunk_size
argument_list|,
name|fw_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|addr
operator|+=
name|chunk_size
expr_stmt|;
name|fw_data
operator|+=
name|chunk_size
expr_stmt|;
name|size
operator|-=
name|chunk_size
expr_stmt|;
block|}
name|ret
operator|=
name|t3_write_flash
argument_list|(
name|adapter
argument_list|,
name|FW_VERS_ADDR
argument_list|,
literal|4
argument_list|,
name|fw_data
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ret
condition|)
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"firmware download failed, error %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CIM_CTL_BASE
value|0x2000
end_define

begin_comment
comment|/**  *	t3_cim_ctl_blk_read - read a block from CIM control region  *  *	@adap: the adapter  *	@addr: the start address within the CIM control region  *	@n: number of words to read  *	@valp: where to store the result  *  *	Reads a block of 4-byte words from the CIM control region.  */
end_comment

begin_function
name|int
name|t3_cim_ctl_blk_read
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
name|unsigned
name|int
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|)
operator|&
name|F_HOSTBUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
for|for
control|(
init|;
operator|!
name|ret
operator|&&
name|n
operator|--
condition|;
name|addr
operator|+=
literal|4
control|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|CIM_CTL_BASE
operator|+
name|addr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|F_HOSTBUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
operator|*
name|valp
operator|++
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_DATA
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_link_changed - handle interface link changes  *	@adapter: the adapter  *	@port_id: the port index that changed link state  *  *	Called when a port's link settings change to propagate the new values  *	to the associated PHY and MAC.  After performing the common tasks it  *	invokes an OS-specific handler.  */
end_comment

begin_function
name|void
name|t3_link_changed
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port_id
parameter_list|)
block|{
name|int
name|link_ok
decl_stmt|,
name|speed
decl_stmt|,
name|duplex
decl_stmt|,
name|fc
decl_stmt|;
name|struct
name|cphy
modifier|*
name|phy
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|port_id
index|]
operator|.
name|phy
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|port_id
index|]
operator|.
name|mac
decl_stmt|;
name|struct
name|link_config
modifier|*
name|lc
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|port_id
index|]
operator|.
name|link_config
decl_stmt|;
name|phy
operator|->
name|ops
operator|->
name|get_link_status
argument_list|(
name|phy
argument_list|,
operator|&
name|link_ok
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|,
operator|&
name|fc
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_ok
operator|!=
name|lc
operator|->
name|link_ok
operator|&&
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
operator|&&
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
if|if
condition|(
name|link_ok
condition|)
name|t3b_pcs_reset
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_XAUI_ACT_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|link_ok
condition|?
name|F_TXACTENABLE
operator||
name|F_RXEN
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
name|lc
operator|->
name|link_ok
operator|=
operator|(
name|unsigned
name|char
operator|)
name|link_ok
expr_stmt|;
name|lc
operator|->
name|speed
operator|=
name|speed
operator|<
literal|0
condition|?
name|SPEED_INVALID
else|:
name|speed
expr_stmt|;
name|lc
operator|->
name|duplex
operator|=
name|duplex
operator|<
literal|0
condition|?
name|DUPLEX_INVALID
else|:
name|duplex
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|requested_fc
operator|&
name|PAUSE_AUTONEG
condition|)
name|fc
operator|&=
name|lc
operator|->
name|requested_fc
expr_stmt|;
else|else
name|fc
operator|=
name|lc
operator|->
name|requested_fc
operator|&
operator|(
name|PAUSE_RX
operator||
name|PAUSE_TX
operator|)
expr_stmt|;
if|if
condition|(
name|link_ok
operator|&&
name|speed
operator|>=
literal|0
operator|&&
name|lc
operator|->
name|autoneg
operator|==
name|AUTONEG_ENABLE
condition|)
block|{
comment|/* Set MAC speed, duplex, and flow control to match PHY. */
name|t3_mac_set_speed_duplex_fc
argument_list|(
name|mac
argument_list|,
name|speed
argument_list|,
name|duplex
argument_list|,
name|fc
argument_list|)
expr_stmt|;
name|lc
operator|->
name|fc
operator|=
operator|(
name|unsigned
name|char
operator|)
name|fc
expr_stmt|;
block|}
name|t3_os_link_changed
argument_list|(
name|adapter
argument_list|,
name|port_id
argument_list|,
name|link_ok
argument_list|,
name|speed
argument_list|,
name|duplex
argument_list|,
name|fc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_link_start - apply link configuration to MAC/PHY  *	@phy: the PHY to setup  *	@mac: the MAC to setup  *	@lc: the requested link configuration  *  *	Set up a port's MAC and PHY according to a desired link configuration.  *	- If the PHY can auto-negotiate first decide what to advertise, then  *	  enable/disable auto-negotiation as desired, and reset.  *	- If the PHY does not auto-negotiate just reset it.  *	- If auto-negotiation is off set the MAC to the proper speed/duplex/FC,  *	  otherwise do it later based on the outcome of auto-negotiation.  */
end_comment

begin_function
name|int
name|t3_link_start
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|,
name|struct
name|cmac
modifier|*
name|mac
parameter_list|,
name|struct
name|link_config
modifier|*
name|lc
parameter_list|)
block|{
name|unsigned
name|int
name|fc
init|=
name|lc
operator|->
name|requested_fc
operator|&
operator|(
name|PAUSE_RX
operator||
name|PAUSE_TX
operator|)
decl_stmt|;
name|lc
operator|->
name|link_ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|supported
operator|&
name|SUPPORTED_Autoneg
condition|)
block|{
name|lc
operator|->
name|advertising
operator|&=
operator|~
operator|(
name|ADVERTISED_Asym_Pause
operator||
name|ADVERTISED_Pause
operator|)
expr_stmt|;
if|if
condition|(
name|fc
condition|)
block|{
name|lc
operator|->
name|advertising
operator||=
name|ADVERTISED_Asym_Pause
expr_stmt|;
if|if
condition|(
name|fc
operator|&
name|PAUSE_RX
condition|)
name|lc
operator|->
name|advertising
operator||=
name|ADVERTISED_Pause
expr_stmt|;
block|}
name|phy
operator|->
name|ops
operator|->
name|advertise
argument_list|(
name|phy
argument_list|,
name|lc
operator|->
name|advertising
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|autoneg
operator|==
name|AUTONEG_DISABLE
condition|)
block|{
name|lc
operator|->
name|speed
operator|=
name|lc
operator|->
name|requested_speed
expr_stmt|;
name|lc
operator|->
name|duplex
operator|=
name|lc
operator|->
name|requested_duplex
expr_stmt|;
name|lc
operator|->
name|fc
operator|=
operator|(
name|unsigned
name|char
operator|)
name|fc
expr_stmt|;
name|t3_mac_set_speed_duplex_fc
argument_list|(
name|mac
argument_list|,
name|lc
operator|->
name|speed
argument_list|,
name|lc
operator|->
name|duplex
argument_list|,
name|fc
argument_list|)
expr_stmt|;
comment|/* Also disables autoneg */
name|phy
operator|->
name|ops
operator|->
name|set_speed_duplex
argument_list|(
name|phy
argument_list|,
name|lc
operator|->
name|speed
argument_list|,
name|lc
operator|->
name|duplex
argument_list|)
expr_stmt|;
name|phy
operator|->
name|ops
operator|->
name|reset
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|phy
operator|->
name|ops
operator|->
name|autoneg_enable
argument_list|(
name|phy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t3_mac_set_speed_duplex_fc
argument_list|(
name|mac
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|fc
argument_list|)
expr_stmt|;
name|lc
operator|->
name|fc
operator|=
operator|(
name|unsigned
name|char
operator|)
name|fc
expr_stmt|;
name|phy
operator|->
name|ops
operator|->
name|reset
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_set_vlan_accel - control HW VLAN extraction  *	@adapter: the adapter  *	@ports: bitmap of adapter ports to operate on  *	@on: enable (1) or disable (0) HW VLAN extraction  *  *	Enables or disables HW extraction of VLAN tags for the given port.  */
end_comment

begin_function
name|void
name|t3_set_vlan_accel
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|ports
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_TP_OUT_CONFIG
argument_list|,
name|ports
operator|<<
name|S_VLANEXTRACTIONENABLE
argument_list|,
name|on
condition|?
operator|(
name|ports
operator|<<
name|S_VLANEXTRACTIONENABLE
operator|)
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|intr_info
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
comment|/* bits to check in interrupt status */
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* message to print or NULL */
name|short
name|stat_idx
decl_stmt|;
comment|/* stat counter to increment or -1 */
name|unsigned
name|short
name|fatal
range|:
literal|1
decl_stmt|;
comment|/* whether the condition reported is fatal */
block|}
struct|;
end_struct

begin_comment
comment|/**  *	t3_handle_intr_status - table driven interrupt handler  *	@adapter: the adapter that generated the interrupt  *	@reg: the interrupt status register to process  *	@mask: a mask to apply to the interrupt status  *	@acts: table of interrupt actions  *	@stats: statistics counters tracking interrupt occurences  *  *	A table driven interrupt handler that applies a set of masks to an  *	interrupt status word and performs the corresponding actions if the  *	interrupts described by the mask have occured.  The actions include  *	optionally printing a warning or alert message, and optionally  *	incrementing a stat counter.  The table is terminated by an entry  *	specifying mask 0.  Returns the number of fatal interrupt conditions.  */
end_comment

begin_function
specifier|static
name|int
name|t3_handle_intr_status
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|,
name|unsigned
name|int
name|mask
parameter_list|,
specifier|const
name|struct
name|intr_info
modifier|*
name|acts
parameter_list|,
name|unsigned
name|long
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|fatal
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|status
init|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|reg
argument_list|)
operator|&
name|mask
decl_stmt|;
for|for
control|(
init|;
name|acts
operator|->
name|mask
condition|;
operator|++
name|acts
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|acts
operator|->
name|mask
operator|)
condition|)
continue|continue;
if|if
condition|(
name|acts
operator|->
name|fatal
condition|)
block|{
name|fatal
operator|++
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"%s (0x%x)\n"
argument_list|,
name|acts
operator|->
name|msg
argument_list|,
name|status
operator|&
name|acts
operator|->
name|mask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|acts
operator|->
name|msg
condition|)
name|CH_WARN
argument_list|(
name|adapter
argument_list|,
literal|"%s (0x%x)\n"
argument_list|,
name|acts
operator|->
name|msg
argument_list|,
name|status
operator|&
name|acts
operator|->
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|acts
operator|->
name|stat_idx
operator|>=
literal|0
condition|)
name|stats
index|[
name|acts
operator|->
name|stat_idx
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
comment|/* clear processed interrupts */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|reg
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|fatal
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SGE_INTR_MASK
value|(F_RSPQDISABLED)
end_define

begin_define
define|#
directive|define
name|MC5_INTR_MASK
value|(F_PARITYERR | F_ACTRGNFULL | F_UNKNOWNCMD | \ 		       F_REQQPARERR | F_DISPQPARERR | F_DELACTEMPTY | \ 		       F_NFASRCHFAIL)
end_define

begin_define
define|#
directive|define
name|MC7_INTR_MASK
value|(F_AE | F_UE | F_CE | V_PE(M_PE))
end_define

begin_define
define|#
directive|define
name|XGM_INTR_MASK
value|(V_TXFIFO_PRTY_ERR(M_TXFIFO_PRTY_ERR) | \ 		       V_RXFIFO_PRTY_ERR(M_RXFIFO_PRTY_ERR) | \ 		       F_TXFIFO_UNDERRUN | F_RXFIFO_OVERFLOW)
end_define

begin_define
define|#
directive|define
name|PCIX_INTR_MASK
value|(F_MSTDETPARERR | F_SIGTARABT | F_RCVTARABT | \ 			F_RCVMSTABT | F_SIGSYSERR | F_DETPARERR | \ 			F_SPLCMPDIS | F_UNXSPLCMP | F_RCVSPLCMPERR | \ 			F_DETCORECCERR | F_DETUNCECCERR | F_PIOPARERR | \ 			V_WFPARERR(M_WFPARERR) | V_RFPARERR(M_RFPARERR) | \ 			V_CFPARERR(M_CFPARERR)
comment|/* | V_MSIXPARERR(M_MSIXPARERR) */
value|)
end_define

begin_define
define|#
directive|define
name|PCIE_INTR_MASK
value|(F_UNXSPLCPLERRR | F_UNXSPLCPLERRC | F_PCIE_PIOPARERR |\ 			F_PCIE_WFPARERR | F_PCIE_RFPARERR | F_PCIE_CFPARERR | \
comment|/* V_PCIE_MSIXPARERR(M_PCIE_MSIXPARERR) | */
value|\ 			V_BISTERR(M_BISTERR) | F_PEXERR)
end_define

begin_define
define|#
directive|define
name|ULPRX_INTR_MASK
value|F_PARERR
end_define

begin_define
define|#
directive|define
name|ULPTX_INTR_MASK
value|0
end_define

begin_define
define|#
directive|define
name|CPLSW_INTR_MASK
value|(F_TP_FRAMING_ERROR | \ 			 F_SGE_FRAMING_ERROR | F_CIM_FRAMING_ERROR | \ 			 F_ZERO_SWITCH_ERROR)
end_define

begin_define
define|#
directive|define
name|CIM_INTR_MASK
value|(F_BLKWRPLINT | F_BLKRDPLINT | F_BLKWRCTLINT | \ 		       F_BLKRDCTLINT | F_BLKWRFLASHINT | F_BLKRDFLASHINT | \ 		       F_SGLWRFLASHINT | F_WRBLKFLASHINT | F_BLKWRBOOTINT | \ 	 	       F_FLASHRANGEINT | F_SDRAMRANGEINT | F_RSVDSPACEINT)
end_define

begin_define
define|#
directive|define
name|PMTX_INTR_MASK
value|(F_ZERO_C_CMD_ERROR | ICSPI_FRM_ERR | OESPI_FRM_ERR | \ 			V_ICSPI_PAR_ERROR(M_ICSPI_PAR_ERROR) | \ 			V_OESPI_PAR_ERROR(M_OESPI_PAR_ERROR))
end_define

begin_define
define|#
directive|define
name|PMRX_INTR_MASK
value|(F_ZERO_E_CMD_ERROR | IESPI_FRM_ERR | OCSPI_FRM_ERR | \ 			V_IESPI_PAR_ERROR(M_IESPI_PAR_ERROR) | \ 			V_OCSPI_PAR_ERROR(M_OCSPI_PAR_ERROR))
end_define

begin_define
define|#
directive|define
name|MPS_INTR_MASK
value|(V_TX0TPPARERRENB(M_TX0TPPARERRENB) | \ 		       V_TX1TPPARERRENB(M_TX1TPPARERRENB) | \ 		       V_RXTPPARERRENB(M_RXTPPARERRENB) | \ 		       V_MCAPARERRENB(M_MCAPARERRENB))
end_define

begin_define
define|#
directive|define
name|PL_INTR_MASK
value|(F_T3DBG | F_XGMAC0_0 | F_XGMAC0_1 | F_MC5A | F_PM1_TX | \ 		      F_PM1_RX | F_ULP2_TX | F_ULP2_RX | F_TP1 | F_CIM | \ 		      F_MC7_CM | F_MC7_PMTX | F_MC7_PMRX | F_SGE3 | F_PCIM0 | \ 		      F_MPS0 | F_CPL_SWITCH)
end_define

begin_comment
comment|/*  * Interrupt handler for the PCIX1 module.  */
end_comment

begin_function
specifier|static
name|void
name|pci_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|pcix1_intr_info
index|[]
init|=
block|{
block|{
name|F_MSTDETPARERR
block|,
literal|"PCI master detected parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SIGTARABT
block|,
literal|"PCI signaled target abort"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RCVTARABT
block|,
literal|"PCI received target abort"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RCVMSTABT
block|,
literal|"PCI received master abort"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SIGSYSERR
block|,
literal|"PCI signaled system error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DETPARERR
block|,
literal|"PCI detected parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SPLCMPDIS
block|,
literal|"PCI split completion discarded"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_UNXSPLCMP
block|,
literal|"PCI unexpected split completion error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RCVSPLCMPERR
block|,
literal|"PCI received split completion error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DETCORECCERR
block|,
literal|"PCI correctable ECC error"
block|,
name|STAT_PCI_CORR_ECC
block|,
literal|0
block|}
block|,
block|{
name|F_DETUNCECCERR
block|,
literal|"PCI uncorrectable ECC error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PIOPARERR
block|,
literal|"PCI PIO FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_WFPARERR
argument_list|(
name|M_WFPARERR
argument_list|)
block|,
literal|"PCI write FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_RFPARERR
argument_list|(
name|M_RFPARERR
argument_list|)
block|,
literal|"PCI read FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_CFPARERR
argument_list|(
name|M_CFPARERR
argument_list|)
block|,
literal|"PCI command FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_MSIXPARERR
argument_list|(
name|M_MSIXPARERR
argument_list|)
block|,
literal|"PCI MSI-X table/PBA parity "
literal|"error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PCIX_INT_CAUSE
argument_list|,
name|PCIX_INTR_MASK
argument_list|,
name|pcix1_intr_info
argument_list|,
name|adapter
operator|->
name|irq_stats
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler for the PCIE module.  */
end_comment

begin_function
specifier|static
name|void
name|pcie_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|pcie_intr_info
index|[]
init|=
block|{
block|{
name|F_PEXERR
block|,
literal|"PCI PEX error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_UNXSPLCPLERRR
block|,
literal|"PCI unexpected split completion DMA read error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_UNXSPLCPLERRC
block|,
literal|"PCI unexpected split completion DMA command error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCIE_PIOPARERR
block|,
literal|"PCI PIO FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCIE_WFPARERR
block|,
literal|"PCI write FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCIE_RFPARERR
block|,
literal|"PCI read FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCIE_CFPARERR
block|,
literal|"PCI command FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_PCIE_MSIXPARERR
argument_list|(
name|M_PCIE_MSIXPARERR
argument_list|)
block|,
literal|"PCI MSI-X table/PBA parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_BISTERR
argument_list|(
name|M_BISTERR
argument_list|)
block|,
literal|"PCI BIST error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_INT_CAUSE
argument_list|,
name|PCIE_INTR_MASK
argument_list|,
name|pcie_intr_info
argument_list|,
name|adapter
operator|->
name|irq_stats
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TP interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|tp_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|tp_intr_info
index|[]
init|=
block|{
block|{
literal|0xffffff
block|,
literal|"TP parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0x1000000
block|,
literal|"TP out of Rx pages"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0x2000000
block|,
literal|"TP out of Tx pages"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_TP_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|tp_intr_info
argument_list|,
name|NULL
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CIM interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|cim_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|cim_intr_info
index|[]
init|=
block|{
block|{
name|F_RSVDSPACEINT
block|,
literal|"CIM reserved space write"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SDRAMRANGEINT
block|,
literal|"CIM SDRAM address out of range"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_FLASHRANGEINT
block|,
literal|"CIM flash address out of range"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRBOOTINT
block|,
literal|"CIM block write to boot space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_WRBLKFLASHINT
block|,
literal|"CIM write to cached flash space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLWRFLASHINT
block|,
literal|"CIM single write to flash space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKRDFLASHINT
block|,
literal|"CIM block read from flash space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRFLASHINT
block|,
literal|"CIM block write to flash space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKRDCTLINT
block|,
literal|"CIM block read from CTL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRCTLINT
block|,
literal|"CIM block write to CTL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKRDPLINT
block|,
literal|"CIM block read from PL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRPLINT
block|,
literal|"CIM block write to PL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|cim_intr_info
argument_list|,
name|NULL
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ULP RX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ulprx_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|ulprx_intr_info
index|[]
init|=
block|{
block|{
name|F_PARERR
block|,
literal|"ULP RX parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|ulprx_intr_info
argument_list|,
name|NULL
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ULP TX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ulptx_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|ulptx_intr_info
index|[]
init|=
block|{
block|{
name|F_PBL_BOUND_ERR_CH0
block|,
literal|"ULP TX channel 0 PBL out of bounds"
block|,
name|STAT_ULP_CH0_PBL_OOB
block|,
literal|0
block|}
block|,
block|{
name|F_PBL_BOUND_ERR_CH1
block|,
literal|"ULP TX channel 1 PBL out of bounds"
block|,
name|STAT_ULP_CH1_PBL_OOB
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|ulptx_intr_info
argument_list|,
name|adapter
operator|->
name|irq_stats
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ICSPI_FRM_ERR
value|(F_ICSPI0_FIFO2X_RX_FRAMING_ERROR | \ 	F_ICSPI1_FIFO2X_RX_FRAMING_ERROR | F_ICSPI0_RX_FRAMING_ERROR | \ 	F_ICSPI1_RX_FRAMING_ERROR | F_ICSPI0_TX_FRAMING_ERROR | \ 	F_ICSPI1_TX_FRAMING_ERROR)
end_define

begin_define
define|#
directive|define
name|OESPI_FRM_ERR
value|(F_OESPI0_RX_FRAMING_ERROR | \ 	F_OESPI1_RX_FRAMING_ERROR | F_OESPI0_TX_FRAMING_ERROR | \ 	F_OESPI1_TX_FRAMING_ERROR | F_OESPI0_OFIFO2X_TX_FRAMING_ERROR | \ 	F_OESPI1_OFIFO2X_TX_FRAMING_ERROR)
end_define

begin_comment
comment|/*  * PM TX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|pmtx_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|pmtx_intr_info
index|[]
init|=
block|{
block|{
name|F_ZERO_C_CMD_ERROR
block|,
literal|"PMTX 0-length pcmd"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|ICSPI_FRM_ERR
block|,
literal|"PMTX ispi framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|OESPI_FRM_ERR
block|,
literal|"PMTX ospi framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_ICSPI_PAR_ERROR
argument_list|(
name|M_ICSPI_PAR_ERROR
argument_list|)
block|,
literal|"PMTX ispi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_OESPI_PAR_ERROR
argument_list|(
name|M_OESPI_PAR_ERROR
argument_list|)
block|,
literal|"PMTX ospi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PM1_TX_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|pmtx_intr_info
argument_list|,
name|NULL
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IESPI_FRM_ERR
value|(F_IESPI0_FIFO2X_RX_FRAMING_ERROR | \ 	F_IESPI1_FIFO2X_RX_FRAMING_ERROR | F_IESPI0_RX_FRAMING_ERROR | \ 	F_IESPI1_RX_FRAMING_ERROR | F_IESPI0_TX_FRAMING_ERROR | \ 	F_IESPI1_TX_FRAMING_ERROR)
end_define

begin_define
define|#
directive|define
name|OCSPI_FRM_ERR
value|(F_OCSPI0_RX_FRAMING_ERROR | \ 	F_OCSPI1_RX_FRAMING_ERROR | F_OCSPI0_TX_FRAMING_ERROR | \ 	F_OCSPI1_TX_FRAMING_ERROR | F_OCSPI0_OFIFO2X_TX_FRAMING_ERROR | \ 	F_OCSPI1_OFIFO2X_TX_FRAMING_ERROR)
end_define

begin_comment
comment|/*  * PM RX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|pmrx_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|pmrx_intr_info
index|[]
init|=
block|{
block|{
name|F_ZERO_E_CMD_ERROR
block|,
literal|"PMRX 0-length pcmd"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|IESPI_FRM_ERR
block|,
literal|"PMRX ispi framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|OCSPI_FRM_ERR
block|,
literal|"PMRX ospi framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_IESPI_PAR_ERROR
argument_list|(
name|M_IESPI_PAR_ERROR
argument_list|)
block|,
literal|"PMRX ispi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_OCSPI_PAR_ERROR
argument_list|(
name|M_OCSPI_PAR_ERROR
argument_list|)
block|,
literal|"PMRX ospi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PM1_RX_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|pmrx_intr_info
argument_list|,
name|NULL
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CPL switch interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|cplsw_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|cplsw_intr_info
index|[]
init|=
block|{
comment|//		{ F_CIM_OVFL_ERROR, "CPL switch CIM overflow", -1, 1 },
block|{
name|F_TP_FRAMING_ERROR
block|,
literal|"CPL switch TP framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGE_FRAMING_ERROR
block|,
literal|"CPL switch SGE framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CIM_FRAMING_ERROR
block|,
literal|"CPL switch CIM framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ZERO_SWITCH_ERROR
block|,
literal|"CPL switch no-switch error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_CPL_INTR_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|cplsw_intr_info
argument_list|,
name|NULL
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MPS interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|mps_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|mps_intr_info
index|[]
init|=
block|{
block|{
literal|0x1ff
block|,
literal|"MPS parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|mps_intr_info
argument_list|,
name|NULL
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MC7_INTR_FATAL
value|(F_UE | V_PE(M_PE) | F_AE)
end_define

begin_comment
comment|/*  * MC7 interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|mc7_intr_handler
parameter_list|(
name|struct
name|mc7
modifier|*
name|mc7
parameter_list|)
block|{
name|adapter_t
modifier|*
name|adapter
init|=
name|mc7
operator|->
name|adapter
decl_stmt|;
name|u32
name|cause
init|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_INT_CAUSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_CE
condition|)
block|{
name|mc7
operator|->
name|stats
operator|.
name|corr_err
operator|++
expr_stmt|;
name|CH_WARN
argument_list|(
name|adapter
argument_list|,
literal|"%s MC7 correctable error at addr 0x%x, "
literal|"data 0x%x 0x%x 0x%x\n"
argument_list|,
name|mc7
operator|->
name|name
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CE_ADDR
argument_list|)
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CE_DATA0
argument_list|)
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CE_DATA1
argument_list|)
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CE_DATA2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|F_UE
condition|)
block|{
name|mc7
operator|->
name|stats
operator|.
name|uncorr_err
operator|++
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"%s MC7 uncorrectable error at addr 0x%x, "
literal|"data 0x%x 0x%x 0x%x\n"
argument_list|,
name|mc7
operator|->
name|name
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_UE_ADDR
argument_list|)
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_UE_DATA0
argument_list|)
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_UE_DATA1
argument_list|)
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_UE_DATA2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|G_PE
argument_list|(
name|cause
argument_list|)
condition|)
block|{
name|mc7
operator|->
name|stats
operator|.
name|parity_err
operator|++
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"%s MC7 parity error 0x%x\n"
argument_list|,
name|mc7
operator|->
name|name
argument_list|,
name|G_PE
argument_list|(
name|cause
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|F_AE
condition|)
block|{
name|u32
name|addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
name|addr
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_ERR_ADDR
argument_list|)
expr_stmt|;
name|mc7
operator|->
name|stats
operator|.
name|addr_err
operator|++
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"%s MC7 address error: 0x%x\n"
argument_list|,
name|mc7
operator|->
name|name
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|MC7_INTR_FATAL
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_INT_CAUSE
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|XGM_INTR_FATAL
value|(V_TXFIFO_PRTY_ERR(M_TXFIFO_PRTY_ERR) | \ 			V_RXFIFO_PRTY_ERR(M_RXFIFO_PRTY_ERR))
end_define

begin_comment
comment|/*  * XGMAC interrupt handler.  */
end_comment

begin_function
specifier|static
name|int
name|mac_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|adap
operator|->
name|port
index|[
name|idx
index|]
operator|.
name|mac
decl_stmt|;
name|u32
name|cause
init|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_XGM_INT_CAUSE
operator|+
name|mac
operator|->
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|cause
operator|&
name|V_TXFIFO_PRTY_ERR
argument_list|(
name|M_TXFIFO_PRTY_ERR
argument_list|)
condition|)
block|{
name|mac
operator|->
name|stats
operator|.
name|tx_fifo_parity_err
operator|++
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adap
argument_list|,
literal|"port%d: MAC TX FIFO parity error\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|V_RXFIFO_PRTY_ERR
argument_list|(
name|M_RXFIFO_PRTY_ERR
argument_list|)
condition|)
block|{
name|mac
operator|->
name|stats
operator|.
name|rx_fifo_parity_err
operator|++
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adap
argument_list|,
literal|"port%d: MAC RX FIFO parity error\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|F_TXFIFO_UNDERRUN
condition|)
name|mac
operator|->
name|stats
operator|.
name|tx_fifo_urun
operator|++
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_RXFIFO_OVERFLOW
condition|)
name|mac
operator|->
name|stats
operator|.
name|rx_fifo_ovfl
operator|++
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|V_SERDES_LOS
argument_list|(
name|M_SERDES_LOS
argument_list|)
condition|)
name|mac
operator|->
name|stats
operator|.
name|serdes_signal_loss
operator|++
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_XAUIPCSCTCERR
condition|)
name|mac
operator|->
name|stats
operator|.
name|xaui_pcs_ctc_err
operator|++
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_XAUIPCSALIGNCHANGE
condition|)
name|mac
operator|->
name|stats
operator|.
name|xaui_pcs_align_change
operator|++
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_XGM_INT_CAUSE
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|cause
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|XGM_INTR_FATAL
condition|)
name|t3_fatal_err
argument_list|(
name|adap
argument_list|)
expr_stmt|;
return|return
name|cause
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler for PHY events.  */
end_comment

begin_function
name|int
name|t3_phy_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|mask
decl_stmt|,
name|gpi
init|=
name|adapter_info
argument_list|(
name|adapter
argument_list|)
operator|->
name|gpio_intr
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|cause
init|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_T3DBG_INT_CAUSE
argument_list|)
decl_stmt|;
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|mask
operator|=
name|gpi
operator|-
operator|(
name|gpi
operator|&
operator|(
name|gpi
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|gpi
operator|-=
name|mask
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|port_type
operator|->
name|caps
operator|&
name|SUPPORTED_IRQ
operator|)
condition|)
continue|continue;
if|if
condition|(
name|cause
operator|&
name|mask
condition|)
block|{
name|int
name|phy_cause
init|=
name|p
operator|->
name|phy
operator|.
name|ops
operator|->
name|intr_handler
argument_list|(
operator|&
name|p
operator|->
name|phy
argument_list|)
decl_stmt|;
if|if
condition|(
name|phy_cause
operator|&
name|cphy_cause_link_change
condition|)
name|t3_link_changed
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_cause
operator|&
name|cphy_cause_fifo_error
condition|)
name|p
operator|->
name|phy
operator|.
name|fifo_errors
operator|++
expr_stmt|;
block|}
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_T3DBG_INT_CAUSE
argument_list|,
name|cause
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * T3 slow path (non-data) interrupt handler.  */
end_comment

begin_function
name|int
name|t3_slow_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|cause
init|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE0
argument_list|)
decl_stmt|;
name|cause
operator|&=
name|adapter
operator|->
name|slow_intr_mask
expr_stmt|;
if|if
condition|(
operator|!
name|cause
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cause
operator|&
name|F_PCIM0
condition|)
block|{
if|if
condition|(
name|is_pcie
argument_list|(
name|adapter
argument_list|)
condition|)
name|pcie_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
name|pci_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|F_SGE3
condition|)
name|t3_sge_err_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MC7_PMRX
condition|)
name|mc7_intr_handler
argument_list|(
operator|&
name|adapter
operator|->
name|pmrx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MC7_PMTX
condition|)
name|mc7_intr_handler
argument_list|(
operator|&
name|adapter
operator|->
name|pmtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MC7_CM
condition|)
name|mc7_intr_handler
argument_list|(
operator|&
name|adapter
operator|->
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_CIM
condition|)
name|cim_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_TP1
condition|)
name|tp_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_ULP2_RX
condition|)
name|ulprx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_ULP2_TX
condition|)
name|ulptx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_PM1_RX
condition|)
name|pmrx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_PM1_TX
condition|)
name|pmtx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_CPL_SWITCH
condition|)
name|cplsw_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MPS0
condition|)
name|mps_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MC5A
condition|)
name|t3_mc5_intr_handler
argument_list|(
operator|&
name|adapter
operator|->
name|mc5
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_XGMAC0_0
condition|)
name|mac_intr_handler
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_XGMAC0_1
condition|)
name|mac_intr_handler
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_T3DBG
condition|)
name|t3_os_ext_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Clear the interrupts just processed. */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE0
argument_list|,
name|cause
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE0
argument_list|)
expr_stmt|;
comment|/* flush */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_intr_enable - enable interrupts  *	@adapter: the adapter whose interrupts should be enabled  *  *	Enable interrupts by setting the interrupt enable registers of the  *	various HW modules and then enabling the top-level interrupt  *	concentrator.  */
end_comment

begin_function
name|void
name|t3_intr_enable
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|addr_val_pair
name|intr_en_avp
index|[]
init|=
block|{
block|{
name|A_SG_INT_ENABLE
block|,
name|SGE_INTR_MASK
block|}
block|,
block|{
name|A_MC7_INT_ENABLE
block|,
name|MC7_INTR_MASK
block|}
block|,
block|{
name|A_MC7_INT_ENABLE
operator|-
name|MC7_PMRX_BASE_ADDR
operator|+
name|MC7_PMTX_BASE_ADDR
block|,
name|MC7_INTR_MASK
block|}
block|,
block|{
name|A_MC7_INT_ENABLE
operator|-
name|MC7_PMRX_BASE_ADDR
operator|+
name|MC7_CM_BASE_ADDR
block|,
name|MC7_INTR_MASK
block|}
block|,
block|{
name|A_MC5_DB_INT_ENABLE
block|,
name|MC5_INTR_MASK
block|}
block|,
block|{
name|A_ULPRX_INT_ENABLE
block|,
name|ULPRX_INTR_MASK
block|}
block|,
block|{
name|A_TP_INT_ENABLE
block|,
literal|0x3bfffff
block|}
block|,
block|{
name|A_PM1_TX_INT_ENABLE
block|,
name|PMTX_INTR_MASK
block|}
block|,
block|{
name|A_PM1_RX_INT_ENABLE
block|,
name|PMRX_INTR_MASK
block|}
block|,
block|{
name|A_CIM_HOST_INT_ENABLE
block|,
name|CIM_INTR_MASK
block|}
block|,
block|{
name|A_MPS_INT_ENABLE
block|,
name|MPS_INTR_MASK
block|}
block|, 	}
decl_stmt|;
name|adapter
operator|->
name|slow_intr_mask
operator|=
name|PL_INTR_MASK
expr_stmt|;
name|t3_write_regs
argument_list|(
name|adapter
argument_list|,
name|intr_en_avp
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|intr_en_avp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_CPL_INTR_ENABLE
argument_list|,
name|CPLSW_INTR_MASK
operator||
name|F_CIM_OVFL_ERROR
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_INT_ENABLE
argument_list|,
name|ULPTX_INTR_MASK
operator||
name|F_PBL_BOUND_ERR_CH0
operator||
name|F_PBL_BOUND_ERR_CH1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_CPL_INTR_ENABLE
argument_list|,
name|CPLSW_INTR_MASK
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_INT_ENABLE
argument_list|,
name|ULPTX_INTR_MASK
argument_list|)
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_T3DBG_GPIO_ACT_LOW
argument_list|,
name|adapter_info
argument_list|(
name|adapter
argument_list|)
operator|->
name|gpio_intr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_T3DBG_INT_ENABLE
argument_list|,
name|adapter_info
argument_list|(
name|adapter
argument_list|)
operator|->
name|gpio_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pcie
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_INT_ENABLE
argument_list|,
name|PCIE_INTR_MASK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIX_INT_ENABLE
argument_list|,
name|PCIX_INTR_MASK
argument_list|)
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_ENABLE0
argument_list|,
name|adapter
operator|->
name|slow_intr_mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_ENABLE0
argument_list|)
expr_stmt|;
comment|/* flush */
block|}
end_function

begin_comment
comment|/**  *	t3_intr_disable - disable a card's interrupts  *	@adapter: the adapter whose interrupts should be disabled  *  *	Disable interrupts.  We only disable the top-level interrupt  *	concentrator and the SGE data interrupts.  */
end_comment

begin_function
name|void
name|t3_intr_disable
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_ENABLE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_ENABLE0
argument_list|)
expr_stmt|;
comment|/* flush */
name|adapter
operator|->
name|slow_intr_mask
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_intr_clear - clear all interrupts  *	@adapter: the adapter whose interrupts should be cleared  *  *	Clears all interrupts.  */
end_comment

begin_function
name|void
name|t3_intr_clear
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|int
name|cause_reg_addr
index|[]
init|=
block|{
name|A_SG_INT_CAUSE
block|,
name|A_SG_RSPQ_FL_STATUS
block|,
name|A_PCIX_INT_CAUSE
block|,
name|A_MC7_INT_CAUSE
block|,
name|A_MC7_INT_CAUSE
operator|-
name|MC7_PMRX_BASE_ADDR
operator|+
name|MC7_PMTX_BASE_ADDR
block|,
name|A_MC7_INT_CAUSE
operator|-
name|MC7_PMRX_BASE_ADDR
operator|+
name|MC7_CM_BASE_ADDR
block|,
name|A_CIM_HOST_INT_CAUSE
block|,
name|A_TP_INT_CAUSE
block|,
name|A_MC5_DB_INT_CAUSE
block|,
name|A_ULPRX_INT_CAUSE
block|,
name|A_ULPTX_INT_CAUSE
block|,
name|A_CPL_INTR_CAUSE
block|,
name|A_PM1_TX_INT_CAUSE
block|,
name|A_PM1_RX_INT_CAUSE
block|,
name|A_MPS_INT_CAUSE
block|,
name|A_T3DBG_INT_CAUSE
block|, 	}
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Clear PHY and MAC interrupts for each port. */
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|i
argument_list|)
name|t3_port_intr_clear
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|cause_reg_addr
argument_list|)
condition|;
operator|++
name|i
control|)
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|cause_reg_addr
index|[
name|i
index|]
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE0
argument_list|)
expr_stmt|;
comment|/* flush */
block|}
end_function

begin_comment
comment|/**  *	t3_port_intr_enable - enable port-specific interrupts  *	@adapter: associated adapter  *	@idx: index of port whose interrupts should be enabled  *  *	Enable port-specific (i.e., MAC and PHY) interrupts for the given  *	adapter port.  */
end_comment

begin_function
name|void
name|t3_port_intr_enable
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_INT_ENABLE
argument_list|,
name|idx
argument_list|)
argument_list|,
name|XGM_INTR_MASK
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|port
index|[
name|idx
index|]
operator|.
name|phy
operator|.
name|ops
operator|->
name|intr_enable
argument_list|(
operator|&
name|adapter
operator|->
name|port
index|[
name|idx
index|]
operator|.
name|phy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_port_intr_disable - disable port-specific interrupts  *	@adapter: associated adapter  *	@idx: index of port whose interrupts should be disabled  *  *	Disable port-specific (i.e., MAC and PHY) interrupts for the given  *	adapter port.  */
end_comment

begin_function
name|void
name|t3_port_intr_disable
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_INT_ENABLE
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|port
index|[
name|idx
index|]
operator|.
name|phy
operator|.
name|ops
operator|->
name|intr_disable
argument_list|(
operator|&
name|adapter
operator|->
name|port
index|[
name|idx
index|]
operator|.
name|phy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_port_intr_clear - clear port-specific interrupts  *	@adapter: associated adapter  *	@idx: index of port whose interrupts to clear  *  *	Clear port-specific (i.e., MAC and PHY) interrupts for the given  *	adapter port.  */
end_comment

begin_function
name|void
name|t3_port_intr_clear
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_INT_CAUSE
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|port
index|[
name|idx
index|]
operator|.
name|phy
operator|.
name|ops
operator|->
name|intr_clear
argument_list|(
operator|&
name|adapter
operator|->
name|port
index|[
name|idx
index|]
operator|.
name|phy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * 	t3_sge_write_context - write an SGE context  * 	@adapter: the adapter  * 	@id: the context id  * 	@type: the context type  *  * 	Program an SGE context with the values already loaded in the  * 	CONTEXT_DATA? registers.  */
end_comment

begin_function
specifier|static
name|int
name|t3_sge_write_context
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK1
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK2
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK3
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|type
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_init_ecntxt - initialize an SGE egress context  *	@adapter: the adapter to configure  *	@id: the context id  *	@gts_enable: whether to enable GTS for the context  *	@type: the egress context type  *	@respq: associated response queue  *	@base_addr: base address of queue  *	@size: number of queue entries  *	@token: uP token  *	@gen: initial generation value for the context  *	@cidx: consumer pointer  *  *	Initialize an SGE egress context and make it ready for use.  If the  *	platform allows concurrent context operations, the caller is  *	responsible for appropriate locking.  */
end_comment

begin_function
name|int
name|t3_sge_init_ecntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|int
name|gts_enable
parameter_list|,
name|enum
name|sge_context_type
name|type
parameter_list|,
name|int
name|respq
parameter_list|,
name|u64
name|base_addr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|unsigned
name|int
name|token
parameter_list|,
name|int
name|gen
parameter_list|,
name|unsigned
name|int
name|cidx
parameter_list|)
block|{
name|unsigned
name|int
name|credits
init|=
name|type
operator|==
name|SGE_CNTXT_OFLD
condition|?
literal|0
else|:
name|FW_WR_NUM
decl_stmt|;
if|if
condition|(
name|base_addr
operator|&
literal|0xfff
condition|)
comment|/* must be 4K aligned */
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|base_addr
operator|>>=
literal|12
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
name|V_EC_INDEX
argument_list|(
name|cidx
argument_list|)
operator||
name|V_EC_CREDITS
argument_list|(
name|credits
argument_list|)
operator||
name|V_EC_GTS
argument_list|(
name|gts_enable
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA1
argument_list|,
name|V_EC_SIZE
argument_list|(
name|size
argument_list|)
operator||
name|V_EC_BASE_LO
argument_list|(
operator|(
name|u32
operator|)
name|base_addr
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
name|base_addr
operator|>>=
literal|16
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA2
argument_list|,
operator|(
name|u32
operator|)
name|base_addr
argument_list|)
expr_stmt|;
name|base_addr
operator|>>=
literal|32
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA3
argument_list|,
name|V_EC_BASE_HI
argument_list|(
operator|(
name|u32
operator|)
name|base_addr
operator|&
literal|0xf
argument_list|)
operator||
name|V_EC_RESPQ
argument_list|(
name|respq
argument_list|)
operator||
name|V_EC_TYPE
argument_list|(
name|type
argument_list|)
operator||
name|V_EC_GEN
argument_list|(
name|gen
argument_list|)
operator||
name|V_EC_UP_TOKEN
argument_list|(
name|token
argument_list|)
operator||
name|F_EC_VALID
argument_list|)
expr_stmt|;
return|return
name|t3_sge_write_context
argument_list|(
name|adapter
argument_list|,
name|id
argument_list|,
name|F_EGRESS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_init_flcntxt - initialize an SGE free-buffer list context  *	@adapter: the adapter to configure  *	@id: the context id  *	@gts_enable: whether to enable GTS for the context  *	@base_addr: base address of queue  *	@size: number of queue entries  *	@bsize: size of each buffer for this queue  *	@cong_thres: threshold to signal congestion to upstream producers  *	@gen: initial generation value for the context  *	@cidx: consumer pointer  *  *	Initialize an SGE free list context and make it ready for use.  The  *	caller is responsible for ensuring only one context operation occurs  *	at a time.  */
end_comment

begin_function
name|int
name|t3_sge_init_flcntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|int
name|gts_enable
parameter_list|,
name|u64
name|base_addr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|unsigned
name|int
name|bsize
parameter_list|,
name|unsigned
name|int
name|cong_thres
parameter_list|,
name|int
name|gen
parameter_list|,
name|unsigned
name|int
name|cidx
parameter_list|)
block|{
if|if
condition|(
name|base_addr
operator|&
literal|0xfff
condition|)
comment|/* must be 4K aligned */
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|base_addr
operator|>>=
literal|12
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
operator|(
name|u32
operator|)
name|base_addr
argument_list|)
expr_stmt|;
name|base_addr
operator|>>=
literal|32
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA1
argument_list|,
name|V_FL_BASE_HI
argument_list|(
operator|(
name|u32
operator|)
name|base_addr
argument_list|)
operator||
name|V_FL_INDEX_LO
argument_list|(
name|cidx
operator|&
name|M_FL_INDEX_LO
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA2
argument_list|,
name|V_FL_SIZE
argument_list|(
name|size
argument_list|)
operator||
name|V_FL_GEN
argument_list|(
name|gen
argument_list|)
operator||
name|V_FL_INDEX_HI
argument_list|(
name|cidx
operator|>>
literal|12
argument_list|)
operator||
name|V_FL_ENTRY_SIZE_LO
argument_list|(
name|bsize
operator|&
name|M_FL_ENTRY_SIZE_LO
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA3
argument_list|,
name|V_FL_ENTRY_SIZE_HI
argument_list|(
name|bsize
operator|>>
operator|(
literal|32
operator|-
name|S_FL_ENTRY_SIZE_LO
operator|)
argument_list|)
operator||
name|V_FL_CONG_THRES
argument_list|(
name|cong_thres
argument_list|)
operator||
name|V_FL_GTS
argument_list|(
name|gts_enable
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_sge_write_context
argument_list|(
name|adapter
argument_list|,
name|id
argument_list|,
name|F_FREELIST
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_init_rspcntxt - initialize an SGE response queue context  *	@adapter: the adapter to configure  *	@id: the context id  *	@irq_vec_idx: MSI-X interrupt vector index, 0 if no MSI-X, -1 if no IRQ  *	@base_addr: base address of queue  *	@size: number of queue entries  *	@fl_thres: threshold for selecting the normal or jumbo free list  *	@gen: initial generation value for the context  *	@cidx: consumer pointer  *  *	Initialize an SGE response queue context and make it ready for use.  *	The caller is responsible for ensuring only one context operation  *	occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_init_rspcntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|int
name|irq_vec_idx
parameter_list|,
name|u64
name|base_addr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|unsigned
name|int
name|fl_thres
parameter_list|,
name|int
name|gen
parameter_list|,
name|unsigned
name|int
name|cidx
parameter_list|)
block|{
name|unsigned
name|int
name|intr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|base_addr
operator|&
literal|0xfff
condition|)
comment|/* must be 4K aligned */
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|base_addr
operator|>>=
literal|12
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
name|V_CQ_SIZE
argument_list|(
name|size
argument_list|)
operator||
name|V_CQ_INDEX
argument_list|(
name|cidx
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA1
argument_list|,
operator|(
name|u32
operator|)
name|base_addr
argument_list|)
expr_stmt|;
name|base_addr
operator|>>=
literal|32
expr_stmt|;
if|if
condition|(
name|irq_vec_idx
operator|>=
literal|0
condition|)
name|intr
operator|=
name|V_RQ_MSI_VEC
argument_list|(
name|irq_vec_idx
argument_list|)
operator||
name|F_RQ_INTR_EN
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA2
argument_list|,
name|V_CQ_BASE_HI
argument_list|(
operator|(
name|u32
operator|)
name|base_addr
argument_list|)
operator||
name|intr
operator||
name|V_RQ_GEN
argument_list|(
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA3
argument_list|,
name|fl_thres
argument_list|)
expr_stmt|;
return|return
name|t3_sge_write_context
argument_list|(
name|adapter
argument_list|,
name|id
argument_list|,
name|F_RESPONSEQ
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_init_cqcntxt - initialize an SGE completion queue context  *	@adapter: the adapter to configure  *	@id: the context id  *	@base_addr: base address of queue  *	@size: number of queue entries  *	@rspq: response queue for async notifications  *	@ovfl_mode: CQ overflow mode  *	@credits: completion queue credits  *	@credit_thres: the credit threshold  *  *	Initialize an SGE completion queue context and make it ready for use.  *	The caller is responsible for ensuring only one context operation  *	occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_init_cqcntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|u64
name|base_addr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|rspq
parameter_list|,
name|int
name|ovfl_mode
parameter_list|,
name|unsigned
name|int
name|credits
parameter_list|,
name|unsigned
name|int
name|credit_thres
parameter_list|)
block|{
if|if
condition|(
name|base_addr
operator|&
literal|0xfff
condition|)
comment|/* must be 4K aligned */
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|base_addr
operator|>>=
literal|12
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
name|V_CQ_SIZE
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA1
argument_list|,
operator|(
name|u32
operator|)
name|base_addr
argument_list|)
expr_stmt|;
name|base_addr
operator|>>=
literal|32
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA2
argument_list|,
name|V_CQ_BASE_HI
argument_list|(
operator|(
name|u32
operator|)
name|base_addr
argument_list|)
operator||
name|V_CQ_RSPQ
argument_list|(
name|rspq
argument_list|)
operator||
name|V_CQ_GEN
argument_list|(
literal|1
argument_list|)
operator||
name|V_CQ_OVERFLOW_MODE
argument_list|(
name|ovfl_mode
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA3
argument_list|,
name|V_CQ_CREDITS
argument_list|(
name|credits
argument_list|)
operator||
name|V_CQ_CREDIT_THRES
argument_list|(
name|credit_thres
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_sge_write_context
argument_list|(
name|adapter
argument_list|,
name|id
argument_list|,
name|F_CQ
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_enable_ecntxt - enable/disable an SGE egress context  *	@adapter: the adapter  *	@id: the egress context id  *	@enable: enable (1) or disable (0) the context  *  *	Enable or disable an SGE egress context.  The caller is responsible for  *	ensuring only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_enable_ecntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK3
argument_list|,
name|F_EC_VALID
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA3
argument_list|,
name|V_EC_VALID
argument_list|(
name|enable
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|F_EGRESS
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_disable_fl - disable an SGE free-buffer list  *	@adapter: the adapter  *	@id: the free list context id  *  *	Disable an SGE free-buffer list.  The caller is responsible for  *	ensuring only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_disable_fl
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK2
argument_list|,
name|V_FL_SIZE
argument_list|(
name|M_FL_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|F_FREELIST
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_disable_rspcntxt - disable an SGE response queue  *	@adapter: the adapter  *	@id: the response queue context id  *  *	Disable an SGE response queue.  The caller is responsible for  *	ensuring only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_disable_rspcntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK0
argument_list|,
name|V_CQ_SIZE
argument_list|(
name|M_CQ_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|F_RESPONSEQ
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_disable_cqcntxt - disable an SGE completion queue  *	@adapter: the adapter  *	@id: the completion queue context id  *  *	Disable an SGE completion queue.  The caller is responsible for  *	ensuring only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_disable_cqcntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK0
argument_list|,
name|V_CQ_SIZE
argument_list|(
name|M_CQ_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|F_CQ
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_cqcntxt_op - perform an operation on a completion queue context  *	@adapter: the adapter  *	@id: the context id  *	@op: the operation to perform  *  *	Perform the selected operation on an SGE completion queue context.  *	The caller is responsible for ensuring only one context operation  *	occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_cqcntxt_op
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|unsigned
name|int
name|op
parameter_list|,
name|unsigned
name|int
name|credits
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
name|credits
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
name|op
argument_list|)
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
operator||
name|F_CQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_wait_op_done_val
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
if|if
condition|(
name|op
operator|>=
literal|2
operator|&&
name|op
operator|<
literal|7
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
return|return
name|G_CQ_INDEX
argument_list|(
name|val
argument_list|)
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|0
argument_list|)
operator||
name|F_CQ
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
return|return
name|G_CQ_INDEX
argument_list|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * 	t3_sge_read_context - read an SGE context  * 	@type: the context type  * 	@adapter: the adapter  * 	@id: the context id  * 	@data: holds the retrieved context  *  * 	Read an SGE egress context.  The caller is responsible for ensuring  * 	only one context operation occurs at a time.  */
end_comment

begin_function
specifier|static
name|int
name|t3_sge_read_context
parameter_list|(
name|unsigned
name|int
name|type
parameter_list|,
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|u32
name|data
index|[
literal|4
index|]
parameter_list|)
block|{
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|0
argument_list|)
operator||
name|type
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
name|data
index|[
literal|0
index|]
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|)
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA1
argument_list|)
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA2
argument_list|)
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA3
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * 	t3_sge_read_ecntxt - read an SGE egress context  * 	@adapter: the adapter  * 	@id: the context id  * 	@data: holds the retrieved context  *  * 	Read an SGE egress context.  The caller is responsible for ensuring  * 	only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_read_ecntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|u32
name|data
index|[
literal|4
index|]
parameter_list|)
block|{
if|if
condition|(
name|id
operator|>=
literal|65536
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
name|t3_sge_read_context
argument_list|(
name|F_EGRESS
argument_list|,
name|adapter
argument_list|,
name|id
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * 	t3_sge_read_cq - read an SGE CQ context  * 	@adapter: the adapter  * 	@id: the context id  * 	@data: holds the retrieved context  *  * 	Read an SGE CQ context.  The caller is responsible for ensuring  * 	only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_read_cq
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|u32
name|data
index|[
literal|4
index|]
parameter_list|)
block|{
if|if
condition|(
name|id
operator|>=
literal|65536
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
name|t3_sge_read_context
argument_list|(
name|F_CQ
argument_list|,
name|adapter
argument_list|,
name|id
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * 	t3_sge_read_fl - read an SGE free-list context  * 	@adapter: the adapter  * 	@id: the context id  * 	@data: holds the retrieved context  *  * 	Read an SGE free-list context.  The caller is responsible for ensuring  * 	only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_read_fl
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|u32
name|data
index|[
literal|4
index|]
parameter_list|)
block|{
if|if
condition|(
name|id
operator|>=
name|SGE_QSETS
operator|*
literal|2
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
name|t3_sge_read_context
argument_list|(
name|F_FREELIST
argument_list|,
name|adapter
argument_list|,
name|id
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * 	t3_sge_read_rspq - read an SGE response queue context  * 	@adapter: the adapter  * 	@id: the context id  * 	@data: holds the retrieved context  *  * 	Read an SGE response queue context.  The caller is responsible for  * 	ensuring only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_read_rspq
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|u32
name|data
index|[
literal|4
index|]
parameter_list|)
block|{
if|if
condition|(
name|id
operator|>=
name|SGE_QSETS
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
name|t3_sge_read_context
argument_list|(
name|F_RESPONSEQ
argument_list|,
name|adapter
argument_list|,
name|id
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_config_rss - configure Rx packet steering  *	@adapter: the adapter  *	@rss_config: RSS settings (written to TP_RSS_CONFIG)  *	@cpus: values for the CPU lookup table (0xff terminated)  *	@rspq: values for the response queue lookup table (0xffff terminated)  *  *	Programs the receive packet steering logic.  @cpus and @rspq provide  *	the values for the CPU and response queue lookup tables.  If they  *	provide fewer values than the size of the tables the supplied values  *	are used repeatedly until the tables are fully populated.  */
end_comment

begin_function
name|void
name|t3_config_rss
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|rss_config
parameter_list|,
specifier|const
name|u8
modifier|*
name|cpus
parameter_list|,
specifier|const
name|u16
modifier|*
name|rspq
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cpu_idx
init|=
literal|0
decl_stmt|,
name|q_idx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cpus
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_TABLE_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|u32
name|val
init|=
name|i
operator|<<
literal|16
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
operator|++
name|j
control|)
block|{
name|val
operator||=
operator|(
name|cpus
index|[
name|cpu_idx
operator|++
index|]
operator|&
literal|0x3f
operator|)
operator|<<
operator|(
literal|8
operator|*
name|j
operator|)
expr_stmt|;
if|if
condition|(
name|cpus
index|[
name|cpu_idx
index|]
operator|==
literal|0xff
condition|)
name|cpu_idx
operator|=
literal|0
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_LKP_TABLE
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rspq
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_TABLE_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_MAP_TABLE
argument_list|,
operator|(
name|i
operator|<<
literal|16
operator|)
operator||
name|rspq
index|[
name|q_idx
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rspq
index|[
name|q_idx
index|]
operator|==
literal|0xffff
condition|)
name|q_idx
operator|=
literal|0
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_CONFIG
argument_list|,
name|rss_config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_read_rss - read the contents of the RSS tables  *	@adapter: the adapter  *	@lkup: holds the contents of the RSS lookup table  *	@map: holds the contents of the RSS map table  *  *	Reads the contents of the receive packet steering tables.  */
end_comment

begin_function
name|int
name|t3_read_rss
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u8
modifier|*
name|lkup
parameter_list|,
name|u16
modifier|*
name|map
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|val
decl_stmt|;
if|if
condition|(
name|lkup
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_TABLE_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_LKP_TABLE
argument_list|,
literal|0xffff0000
operator||
name|i
argument_list|)
expr_stmt|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_LKP_TABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
literal|0x80000000
operator|)
condition|)
return|return
operator|-
name|EAGAIN
return|;
operator|*
name|lkup
operator|++
operator|=
operator|(
name|u8
operator|)
name|val
expr_stmt|;
operator|*
name|lkup
operator|++
operator|=
call|(
name|u8
call|)
argument_list|(
name|val
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|map
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_TABLE_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_MAP_TABLE
argument_list|,
literal|0xffff0000
operator||
name|i
argument_list|)
expr_stmt|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_MAP_TABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
literal|0x80000000
operator|)
condition|)
return|return
operator|-
name|EAGAIN
return|;
operator|*
name|map
operator|++
operator|=
operator|(
name|u16
operator|)
name|val
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_tp_set_offload_mode - put TP in NIC/offload mode  *	@adap: the adapter  *	@enable: 1 to select offload mode, 0 for regular NIC  *  *	Switches TP to NIC/offload mode.  */
end_comment

begin_function
name|void
name|t3_tp_set_offload_mode
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
if|if
condition|(
name|is_offload
argument_list|(
name|adap
argument_list|)
operator|||
operator|!
name|enable
condition|)
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_IN_CONFIG
argument_list|,
name|F_NICMODE
argument_list|,
name|V_NICMODE
argument_list|(
operator|!
name|enable
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	pm_num_pages - calculate the number of pages of the payload memory  *	@mem_size: the size of the payload memory  *	@pg_size: the size of each payload memory page  *  *	Calculate the number of pages, each of the given size, that fit in a  *	memory of the specified size, respecting the HW requirement that the  *	number of pages must be a multiple of 24.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|pm_num_pages
parameter_list|(
name|unsigned
name|int
name|mem_size
parameter_list|,
name|unsigned
name|int
name|pg_size
parameter_list|)
block|{
name|unsigned
name|int
name|n
init|=
name|mem_size
operator|/
name|pg_size
decl_stmt|;
return|return
name|n
operator|-
name|n
operator|%
literal|24
return|;
block|}
end_function

begin_define
define|#
directive|define
name|mem_region
parameter_list|(
name|adap
parameter_list|,
name|start
parameter_list|,
name|size
parameter_list|,
name|reg
parameter_list|)
define|\
value|t3_write_reg((adap), A_ ## reg, (start)); \ 	start += size
end_define

begin_comment
comment|/*  *	partition_mem - partition memory and configure TP memory settings  *	@adap: the adapter  *	@p: the TP parameters  *  *	Partitions context and payload memory and configures TP's memory  *	registers.  */
end_comment

begin_function
specifier|static
name|void
name|partition_mem
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
specifier|const
name|struct
name|tp_params
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|m
decl_stmt|,
name|pstructs
decl_stmt|,
name|tids
init|=
name|t3_mc5_size
argument_list|(
operator|&
name|adap
operator|->
name|mc5
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|timers
init|=
literal|0
decl_stmt|,
name|timers_shift
init|=
literal|22
decl_stmt|;
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tids
operator|<=
literal|16
operator|*
literal|1024
condition|)
block|{
name|timers
operator|=
literal|1
expr_stmt|;
name|timers_shift
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tids
operator|<=
literal|64
operator|*
literal|1024
condition|)
block|{
name|timers
operator|=
literal|2
expr_stmt|;
name|timers_shift
operator|=
literal|18
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tids
operator|<=
literal|256
operator|*
literal|1024
condition|)
block|{
name|timers
operator|=
literal|3
expr_stmt|;
name|timers_shift
operator|=
literal|20
expr_stmt|;
block|}
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PMM_SIZE
argument_list|,
name|p
operator|->
name|chan_rx_size
operator||
operator|(
name|p
operator|->
name|chan_tx_size
operator|>>
literal|16
operator|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PMM_TX_BASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PMM_TX_PAGE_SIZE
argument_list|,
name|p
operator|->
name|tx_pg_size
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PMM_TX_MAX_PAGE
argument_list|,
name|p
operator|->
name|tx_num_pgs
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG3
argument_list|,
name|V_TXDATAACKIDX
argument_list|(
name|M_TXDATAACKIDX
argument_list|)
argument_list|,
name|V_TXDATAACKIDX
argument_list|(
name|fls
argument_list|(
name|p
operator|->
name|tx_pg_size
argument_list|)
operator|-
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PMM_RX_BASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PMM_RX_PAGE_SIZE
argument_list|,
name|p
operator|->
name|rx_pg_size
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PMM_RX_MAX_PAGE
argument_list|,
name|p
operator|->
name|rx_num_pgs
argument_list|)
expr_stmt|;
name|pstructs
operator|=
name|p
operator|->
name|rx_num_pgs
operator|+
name|p
operator|->
name|tx_num_pgs
expr_stmt|;
comment|/* Add a bit of headroom and make multiple of 24 */
name|pstructs
operator|+=
literal|48
expr_stmt|;
name|pstructs
operator|-=
name|pstructs
operator|%
literal|24
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CMM_MM_MAX_PSTRUCT
argument_list|,
name|pstructs
argument_list|)
expr_stmt|;
name|m
operator|=
name|tids
operator|*
name|TCB_SIZE
expr_stmt|;
name|mem_region
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
operator|(
literal|64
operator|<<
literal|10
operator|)
operator|*
literal|64
argument_list|,
name|SG_EGR_CNTX_BADDR
argument_list|)
expr_stmt|;
name|mem_region
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
operator|(
literal|64
operator|<<
literal|10
operator|)
operator|*
literal|64
argument_list|,
name|SG_CQ_CONTEXT_BADDR
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CMM_TIMER_BASE
argument_list|,
name|V_CMTIMERMAXNUM
argument_list|(
name|timers
argument_list|)
operator||
name|m
argument_list|)
expr_stmt|;
name|m
operator|+=
operator|(
operator|(
name|p
operator|->
name|ntimer_qs
operator|-
literal|1
operator|)
operator|<<
name|timers_shift
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
name|mem_region
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
name|pstructs
operator|*
literal|64
argument_list|,
name|TP_CMM_MM_BASE
argument_list|)
expr_stmt|;
name|mem_region
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
literal|64
operator|*
operator|(
name|pstructs
operator|/
literal|24
operator|)
argument_list|,
name|TP_CMM_MM_PS_FLST_BASE
argument_list|)
expr_stmt|;
name|mem_region
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
literal|64
operator|*
operator|(
name|p
operator|->
name|rx_num_pgs
operator|/
literal|24
operator|)
argument_list|,
name|TP_CMM_MM_RX_FLST_BASE
argument_list|)
expr_stmt|;
name|mem_region
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
literal|64
operator|*
operator|(
name|p
operator|->
name|tx_num_pgs
operator|/
literal|24
operator|)
argument_list|,
name|TP_CMM_MM_TX_FLST_BASE
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
name|m
operator|+
literal|4095
operator|)
operator|&
operator|~
literal|0xfff
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_SDRAM_BASE_ADDR
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_SDRAM_ADDR_SIZE
argument_list|,
name|p
operator|->
name|cm_size
operator|-
name|m
argument_list|)
expr_stmt|;
name|tids
operator|=
operator|(
name|p
operator|->
name|cm_size
operator|-
name|m
operator|-
operator|(
literal|3
operator|<<
literal|20
operator|)
operator|)
operator|/
literal|3072
operator|-
literal|32
expr_stmt|;
name|m
operator|=
name|t3_mc5_size
argument_list|(
operator|&
name|adap
operator|->
name|mc5
argument_list|)
operator|-
name|adap
operator|->
name|params
operator|.
name|mc5
operator|.
name|nservers
operator|-
name|adap
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
operator|-
name|adap
operator|->
name|params
operator|.
name|mc5
operator|.
name|nroutes
expr_stmt|;
if|if
condition|(
name|tids
operator|<
name|m
condition|)
name|adap
operator|->
name|params
operator|.
name|mc5
operator|.
name|nservers
operator|+=
name|m
operator|-
name|tids
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|tp_wr_indirect
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tp_config
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
specifier|const
name|struct
name|tp_params
modifier|*
name|p
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_GLOBAL_CONFIG
argument_list|,
name|F_TXPACINGENABLE
operator||
name|F_PATHMTU
operator||
name|F_IPCHECKSUMOFFLOAD
operator||
name|F_UDPCHECKSUMOFFLOAD
operator||
name|F_TCPCHECKSUMOFFLOAD
operator||
name|V_IPTTL
argument_list|(
literal|64
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TCP_OPTIONS
argument_list|,
name|V_MTUDEFAULT
argument_list|(
literal|576
argument_list|)
operator||
name|F_MTUENABLE
operator||
name|V_WINDOWSCALEMODE
argument_list|(
literal|1
argument_list|)
operator||
name|V_TIMESTAMPSMODE
argument_list|(
literal|0
argument_list|)
operator||
name|V_SACKMODE
argument_list|(
literal|1
argument_list|)
operator||
name|V_SACKRX
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_DACK_CONFIG
argument_list|,
name|V_AUTOSTATE3
argument_list|(
literal|1
argument_list|)
operator||
name|V_AUTOSTATE2
argument_list|(
literal|1
argument_list|)
operator||
name|V_AUTOSTATE1
argument_list|(
literal|0
argument_list|)
operator||
name|V_BYTETHRESHOLD
argument_list|(
literal|16384
argument_list|)
operator||
name|V_MSSTHRESHOLD
argument_list|(
literal|2
argument_list|)
operator||
name|F_AUTOCAREFUL
operator||
name|F_AUTOENABLE
operator||
name|V_DACK_MODE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_IN_CONFIG
argument_list|,
name|F_IPV6ENABLE
operator||
name|F_NICMODE
argument_list|,
name|F_IPV6ENABLE
operator||
name|F_NICMODE
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_RESOURCE_LIMIT
argument_list|,
literal|0x18141814
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG4
argument_list|,
literal|0x5050105
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG6
argument_list|,
name|adap
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|?
name|F_ENABLEESND
else|:
name|F_T3A_ENABLEESND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PC_CONFIG
argument_list|,
name|F_ENABLEEPCMDAFULL
operator||
name|F_ENABLEOCSPIFULL
argument_list|,
name|F_TXDEFERENABLE
operator||
name|F_HEARBEATDACK
operator||
name|F_TXCONGESTIONMODE
operator||
name|F_RXCONGESTIONMODE
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PC_CONFIG2
argument_list|,
name|F_CHDRAFULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
block|{
name|tp_wr_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_EGRESS_CONFIG
argument_list|,
name|F_REWRITEFORCETOSIZE
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG3
argument_list|,
name|F_TXPACEAUTO
argument_list|,
name|F_TXPACEAUTO
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PC_CONFIG
argument_list|,
name|F_LOCKTID
argument_list|,
name|F_LOCKTID
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG3
argument_list|,
literal|0
argument_list|,
name|F_TXPACEAUTOSTRICT
argument_list|)
expr_stmt|;
block|}
else|else
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG3
argument_list|,
literal|0
argument_list|,
name|F_TXPACEFIXED
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_MOD_QUEUE_WEIGHT1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_MOD_QUEUE_WEIGHT0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MOD_CHANNEL_WEIGHT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MOD_RATE_LIMIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Desired TP timer resolution in usec */
end_comment

begin_define
define|#
directive|define
name|TP_TMR_RES
value|200
end_define

begin_comment
comment|/* TCP timer values in ms */
end_comment

begin_define
define|#
directive|define
name|TP_DACK_TIMER
value|50
end_define

begin_define
define|#
directive|define
name|TP_RTO_MIN
value|250
end_define

begin_comment
comment|/**  *	tp_set_timers - set TP timing parameters  *	@adap: the adapter to set  *	@core_clk: the core clock frequency in Hz  *  *	Set TP's timing parameters, such as the various timer resolutions and  *	the TCP timer values.  */
end_comment

begin_function
specifier|static
name|void
name|tp_set_timers
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|core_clk
parameter_list|)
block|{
name|unsigned
name|int
name|tre
init|=
name|fls
argument_list|(
name|core_clk
operator|/
operator|(
literal|1000000
operator|/
name|TP_TMR_RES
operator|)
argument_list|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|dack_re
init|=
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|dack_re
decl_stmt|;
name|unsigned
name|int
name|tstamp_re
init|=
name|fls
argument_list|(
name|core_clk
operator|/
literal|1000
argument_list|)
decl_stmt|;
comment|/* 1ms, at least */
name|unsigned
name|int
name|tps
init|=
name|core_clk
operator|>>
name|tre
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TIMER_RESOLUTION
argument_list|,
name|V_TIMERRESOLUTION
argument_list|(
name|tre
argument_list|)
operator||
name|V_DELAYEDACKRESOLUTION
argument_list|(
name|dack_re
argument_list|)
operator||
name|V_TIMESTAMPRESOLUTION
argument_list|(
name|tstamp_re
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_DACK_TIMER
argument_list|,
operator|(
name|core_clk
operator|>>
name|dack_re
operator|)
operator|/
operator|(
literal|1000
operator|/
name|TP_DACK_TIMER
operator|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TCP_BACKOFF_REG0
argument_list|,
literal|0x3020100
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TCP_BACKOFF_REG1
argument_list|,
literal|0x7060504
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TCP_BACKOFF_REG2
argument_list|,
literal|0xb0a0908
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TCP_BACKOFF_REG3
argument_list|,
literal|0xf0e0d0c
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_SHIFT_CNT
argument_list|,
name|V_SYNSHIFTMAX
argument_list|(
literal|6
argument_list|)
operator||
name|V_RXTSHIFTMAXR1
argument_list|(
literal|4
argument_list|)
operator||
name|V_RXTSHIFTMAXR2
argument_list|(
literal|15
argument_list|)
operator||
name|V_PERSHIFTBACKOFFMAX
argument_list|(
literal|8
argument_list|)
operator||
name|V_PERSHIFTMAX
argument_list|(
literal|8
argument_list|)
operator||
name|V_KEEPALIVEMAX
argument_list|(
literal|9
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|SECONDS
value|* tps
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MSL
argument_list|,
name|adap
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|?
literal|0
else|:
literal|2
name|SECONDS
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_RXT_MIN
argument_list|,
name|tps
operator|/
operator|(
literal|1000
operator|/
name|TP_RTO_MIN
operator|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_RXT_MAX
argument_list|,
literal|64
name|SECONDS
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PERS_MIN
argument_list|,
literal|5
name|SECONDS
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PERS_MAX
argument_list|,
literal|64
name|SECONDS
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_KEEP_IDLE
argument_list|,
literal|7200
name|SECONDS
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_KEEP_INTVL
argument_list|,
literal|75
name|SECONDS
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_INIT_SRTT
argument_list|,
literal|3
name|SECONDS
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_FINWAIT2_TIMER
argument_list|,
literal|600
name|SECONDS
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SECONDS
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_CHELSIO_T3_CORE
end_ifdef

begin_comment
comment|/**  *	t3_tp_set_coalescing_size - set receive coalescing size  *	@adap: the adapter  *	@size: the receive coalescing size  *	@psh: whether a set PSH bit should deliver coalesced data  *  *	Set the receive coalescing size and PSH bit handling.  */
end_comment

begin_function
name|int
name|t3_tp_set_coalescing_size
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|psh
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|MAX_RX_COALESCING_LEN
condition|)
return|return
operator|-
name|EINVAL
return|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG3
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|F_RXCOALESCEENABLE
operator||
name|F_RXCOALESCEPSHEN
operator|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
name|val
operator||=
name|F_RXCOALESCEENABLE
expr_stmt|;
if|if
condition|(
name|psh
condition|)
name|val
operator||=
name|F_RXCOALESCEPSHEN
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG2
argument_list|,
name|V_RXCOALESCESIZE
argument_list|(
name|size
argument_list|)
operator||
name|V_MAXRXDATA
argument_list|(
name|MAX_RX_COALESCING_LEN
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG3
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_tp_set_max_rxsize - set the max receive size  *	@adap: the adapter  *	@size: the max receive size  *  *	Set TP's max receive size.  This is the limit that applies when  *	receive coalescing is disabled.  */
end_comment

begin_function
name|void
name|t3_tp_set_max_rxsize
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG7
argument_list|,
name|V_PMMAXXFERLEN0
argument_list|(
name|size
argument_list|)
operator||
name|V_PMMAXXFERLEN1
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__devinit
name|init_mtus
parameter_list|(
name|unsigned
name|short
name|mtus
index|[]
parameter_list|)
block|{
comment|/* 	 * See draft-mathis-plpmtud-00.txt for the values.  The min is 88 so 	 * it can accomodate max size TCP/IP headers when SACK and timestamps 	 * are enabled and still have at least 8 bytes of payload. 	 */
name|mtus
index|[
literal|0
index|]
operator|=
literal|88
expr_stmt|;
name|mtus
index|[
literal|1
index|]
operator|=
literal|88
expr_stmt|;
comment|/* workaround for silicon starting at 1 */
name|mtus
index|[
literal|2
index|]
operator|=
literal|256
expr_stmt|;
name|mtus
index|[
literal|3
index|]
operator|=
literal|512
expr_stmt|;
name|mtus
index|[
literal|4
index|]
operator|=
literal|576
expr_stmt|;
comment|/* mtus[4] = 808; */
name|mtus
index|[
literal|5
index|]
operator|=
literal|1024
expr_stmt|;
name|mtus
index|[
literal|6
index|]
operator|=
literal|1280
expr_stmt|;
name|mtus
index|[
literal|7
index|]
operator|=
literal|1492
expr_stmt|;
name|mtus
index|[
literal|8
index|]
operator|=
literal|1500
expr_stmt|;
name|mtus
index|[
literal|9
index|]
operator|=
literal|2002
expr_stmt|;
name|mtus
index|[
literal|10
index|]
operator|=
literal|2048
expr_stmt|;
name|mtus
index|[
literal|11
index|]
operator|=
literal|4096
expr_stmt|;
name|mtus
index|[
literal|12
index|]
operator|=
literal|4352
expr_stmt|;
name|mtus
index|[
literal|13
index|]
operator|=
literal|8192
expr_stmt|;
name|mtus
index|[
literal|14
index|]
operator|=
literal|9000
expr_stmt|;
name|mtus
index|[
literal|15
index|]
operator|=
literal|9600
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initial congestion control parameters.  */
end_comment

begin_function
specifier|static
name|void
name|__devinit
name|init_cong_ctrl
parameter_list|(
name|unsigned
name|short
modifier|*
name|a
parameter_list|,
name|unsigned
name|short
modifier|*
name|b
parameter_list|)
block|{
name|a
index|[
literal|0
index|]
operator|=
name|a
index|[
literal|1
index|]
operator|=
name|a
index|[
literal|2
index|]
operator|=
name|a
index|[
literal|3
index|]
operator|=
name|a
index|[
literal|4
index|]
operator|=
name|a
index|[
literal|5
index|]
operator|=
name|a
index|[
literal|6
index|]
operator|=
name|a
index|[
literal|7
index|]
operator|=
name|a
index|[
literal|8
index|]
operator|=
literal|1
expr_stmt|;
name|a
index|[
literal|9
index|]
operator|=
literal|2
expr_stmt|;
name|a
index|[
literal|10
index|]
operator|=
literal|3
expr_stmt|;
name|a
index|[
literal|11
index|]
operator|=
literal|4
expr_stmt|;
name|a
index|[
literal|12
index|]
operator|=
literal|5
expr_stmt|;
name|a
index|[
literal|13
index|]
operator|=
literal|6
expr_stmt|;
name|a
index|[
literal|14
index|]
operator|=
literal|7
expr_stmt|;
name|a
index|[
literal|15
index|]
operator|=
literal|8
expr_stmt|;
name|a
index|[
literal|16
index|]
operator|=
literal|9
expr_stmt|;
name|a
index|[
literal|17
index|]
operator|=
literal|10
expr_stmt|;
name|a
index|[
literal|18
index|]
operator|=
literal|14
expr_stmt|;
name|a
index|[
literal|19
index|]
operator|=
literal|17
expr_stmt|;
name|a
index|[
literal|20
index|]
operator|=
literal|21
expr_stmt|;
name|a
index|[
literal|21
index|]
operator|=
literal|25
expr_stmt|;
name|a
index|[
literal|22
index|]
operator|=
literal|30
expr_stmt|;
name|a
index|[
literal|23
index|]
operator|=
literal|35
expr_stmt|;
name|a
index|[
literal|24
index|]
operator|=
literal|45
expr_stmt|;
name|a
index|[
literal|25
index|]
operator|=
literal|60
expr_stmt|;
name|a
index|[
literal|26
index|]
operator|=
literal|80
expr_stmt|;
name|a
index|[
literal|27
index|]
operator|=
literal|100
expr_stmt|;
name|a
index|[
literal|28
index|]
operator|=
literal|200
expr_stmt|;
name|a
index|[
literal|29
index|]
operator|=
literal|300
expr_stmt|;
name|a
index|[
literal|30
index|]
operator|=
literal|400
expr_stmt|;
name|a
index|[
literal|31
index|]
operator|=
literal|500
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|b
index|[
literal|1
index|]
operator|=
name|b
index|[
literal|2
index|]
operator|=
name|b
index|[
literal|3
index|]
operator|=
name|b
index|[
literal|4
index|]
operator|=
name|b
index|[
literal|5
index|]
operator|=
name|b
index|[
literal|6
index|]
operator|=
name|b
index|[
literal|7
index|]
operator|=
name|b
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|b
index|[
literal|9
index|]
operator|=
name|b
index|[
literal|10
index|]
operator|=
literal|1
expr_stmt|;
name|b
index|[
literal|11
index|]
operator|=
name|b
index|[
literal|12
index|]
operator|=
literal|2
expr_stmt|;
name|b
index|[
literal|13
index|]
operator|=
name|b
index|[
literal|14
index|]
operator|=
name|b
index|[
literal|15
index|]
operator|=
name|b
index|[
literal|16
index|]
operator|=
literal|3
expr_stmt|;
name|b
index|[
literal|17
index|]
operator|=
name|b
index|[
literal|18
index|]
operator|=
name|b
index|[
literal|19
index|]
operator|=
name|b
index|[
literal|20
index|]
operator|=
name|b
index|[
literal|21
index|]
operator|=
literal|4
expr_stmt|;
name|b
index|[
literal|22
index|]
operator|=
name|b
index|[
literal|23
index|]
operator|=
name|b
index|[
literal|24
index|]
operator|=
name|b
index|[
literal|25
index|]
operator|=
name|b
index|[
literal|26
index|]
operator|=
name|b
index|[
literal|27
index|]
operator|=
literal|5
expr_stmt|;
name|b
index|[
literal|28
index|]
operator|=
name|b
index|[
literal|29
index|]
operator|=
literal|6
expr_stmt|;
name|b
index|[
literal|30
index|]
operator|=
name|b
index|[
literal|31
index|]
operator|=
literal|7
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The minimum additive increment value for the congestion control table */
end_comment

begin_define
define|#
directive|define
name|CC_MIN_INCR
value|2U
end_define

begin_comment
comment|/**  *	t3_load_mtus - write the MTU and congestion control HW tables  *	@adap: the adapter  *	@mtus: the unrestricted values for the MTU table  *	@alphs: the values for the congestion control alpha parameter  *	@beta: the values for the congestion control beta parameter  *	@mtu_cap: the maximum permitted effective MTU  *  *	Write the MTU table with the supplied MTUs capping each at&mtu_cap.  *	Update the high-speed congestion control table with the supplied alpha,  * 	beta, and MTUs.  */
end_comment

begin_function
name|void
name|t3_load_mtus
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|short
name|mtus
index|[
name|NMTUS
index|]
parameter_list|,
name|unsigned
name|short
name|alpha
index|[
name|NCCTRL_WIN
index|]
parameter_list|,
name|unsigned
name|short
name|beta
index|[
name|NCCTRL_WIN
index|]
parameter_list|,
name|unsigned
name|short
name|mtu_cap
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|int
name|avg_pkts
index|[
name|NCCTRL_WIN
index|]
init|=
block|{
literal|2
block|,
literal|6
block|,
literal|10
block|,
literal|14
block|,
literal|20
block|,
literal|28
block|,
literal|40
block|,
literal|56
block|,
literal|80
block|,
literal|112
block|,
literal|160
block|,
literal|224
block|,
literal|320
block|,
literal|448
block|,
literal|640
block|,
literal|896
block|,
literal|1281
block|,
literal|1792
block|,
literal|2560
block|,
literal|3584
block|,
literal|5120
block|,
literal|7168
block|,
literal|10240
block|,
literal|14336
block|,
literal|20480
block|,
literal|28672
block|,
literal|40960
block|,
literal|57344
block|,
literal|81920
block|,
literal|114688
block|,
literal|163840
block|,
literal|229376
block|}
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|w
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMTUS
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|int
name|mtu
init|=
name|min
argument_list|(
name|mtus
index|[
name|i
index|]
argument_list|,
name|mtu_cap
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|log2
init|=
name|fls
argument_list|(
name|mtu
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mtu
operator|&
operator|(
operator|(
literal|1
operator|<<
name|log2
operator|)
operator|>>
literal|2
operator|)
operator|)
condition|)
comment|/* round */
name|log2
operator|--
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MTU_TABLE
argument_list|,
operator|(
name|i
operator|<<
literal|24
operator|)
operator||
operator|(
name|log2
operator|<<
literal|16
operator|)
operator||
name|mtu
argument_list|)
expr_stmt|;
for|for
control|(
name|w
operator|=
literal|0
init|;
name|w
operator|<
name|NCCTRL_WIN
condition|;
operator|++
name|w
control|)
block|{
name|unsigned
name|int
name|inc
decl_stmt|;
name|inc
operator|=
name|max
argument_list|(
operator|(
operator|(
name|mtu
operator|-
literal|40
operator|)
operator|*
name|alpha
index|[
name|w
index|]
operator|)
operator|/
name|avg_pkts
index|[
name|w
index|]
argument_list|,
name|CC_MIN_INCR
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CCTRL_TABLE
argument_list|,
operator|(
name|i
operator|<<
literal|21
operator|)
operator||
operator|(
name|w
operator|<<
literal|16
operator|)
operator||
operator|(
name|beta
index|[
name|w
index|]
operator|<<
literal|13
operator|)
operator||
name|inc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_read_hw_mtus - returns the values in the HW MTU table  *	@adap: the adapter  *	@mtus: where to store the HW MTU values  *  *	Reads the HW MTU table.  */
end_comment

begin_function
name|void
name|t3_read_hw_mtus
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|short
name|mtus
index|[
name|NMTUS
index|]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMTUS
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MTU_TABLE
argument_list|,
literal|0xff000000
operator||
name|i
argument_list|)
expr_stmt|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MTU_TABLE
argument_list|)
expr_stmt|;
name|mtus
index|[
name|i
index|]
operator|=
name|val
operator|&
literal|0x3fff
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_get_cong_cntl_tab - reads the congestion control table  *	@adap: the adapter  *	@incr: where to store the alpha values  *  *	Reads the additive increments programmed into the HW congestion  *	control table.  */
end_comment

begin_function
name|void
name|t3_get_cong_cntl_tab
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|short
name|incr
index|[
name|NMTUS
index|]
index|[
name|NCCTRL_WIN
index|]
parameter_list|)
block|{
name|unsigned
name|int
name|mtu
decl_stmt|,
name|w
decl_stmt|;
for|for
control|(
name|mtu
operator|=
literal|0
init|;
name|mtu
operator|<
name|NMTUS
condition|;
operator|++
name|mtu
control|)
for|for
control|(
name|w
operator|=
literal|0
init|;
name|w
operator|<
name|NCCTRL_WIN
condition|;
operator|++
name|w
control|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CCTRL_TABLE
argument_list|,
literal|0xffff0000
operator||
operator|(
name|mtu
operator|<<
literal|5
operator|)
operator||
name|w
argument_list|)
expr_stmt|;
name|incr
index|[
name|mtu
index|]
index|[
name|w
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CCTRL_TABLE
argument_list|)
operator|&
literal|0x1fff
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_tp_get_mib_stats - read TP's MIB counters  *	@adap: the adapter  *	@tps: holds the returned counter values  *  *	Returns the values of TP's MIB counters.  */
end_comment

begin_function
name|void
name|t3_tp_get_mib_stats
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|tp_mib_stats
modifier|*
name|tps
parameter_list|)
block|{
name|t3_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_RDATA
argument_list|,
operator|(
name|u32
operator|*
operator|)
name|tps
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tps
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_read_pace_tbl - read the pace table  *	@adap: the adapter  *	@pace_vals: holds the returned values  *  *	Returns the values of TP's pace table in nanoseconds.  */
end_comment

begin_function
name|void
name|t3_read_pace_tbl
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|pace_vals
index|[
name|NTX_SCHED
index|]
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|tick_ns
init|=
name|dack_ticks_to_usec
argument_list|(
name|adap
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTX_SCHED
condition|;
name|i
operator|++
control|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PACE_TABLE
argument_list|,
literal|0xffff0000
operator|+
name|i
argument_list|)
expr_stmt|;
name|pace_vals
index|[
name|i
index|]
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PACE_TABLE
argument_list|)
operator|*
name|tick_ns
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_set_pace_tbl - set the pace table  *	@adap: the adapter  *	@pace_vals: the pace values in nanoseconds  *	@start: index of the first entry in the HW pace table to set  *	@n: how many entries to set  *  *	Sets (a subset of the) HW pace table.  */
end_comment

begin_function
name|void
name|t3_set_pace_tbl
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
modifier|*
name|pace_vals
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|tick_ns
init|=
name|dack_ticks_to_usec
argument_list|(
name|adap
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|n
condition|;
name|n
operator|--
operator|,
name|start
operator|++
operator|,
name|pace_vals
operator|++
control|)
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PACE_TABLE
argument_list|,
operator|(
name|start
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|*
name|pace_vals
operator|+
name|tick_ns
operator|/
literal|2
operator|)
operator|/
name|tick_ns
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ulp_region
parameter_list|(
name|adap
parameter_list|,
name|name
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|)
define|\
value|t3_write_reg((adap), A_ULPRX_ ## name ## _LLIMIT, (start)); \ 	t3_write_reg((adap), A_ULPRX_ ## name ## _ULIMIT, \ 		     (start) + (len) - 1); \ 	start += len
end_define

begin_define
define|#
directive|define
name|ulptx_region
parameter_list|(
name|adap
parameter_list|,
name|name
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|)
define|\
value|t3_write_reg((adap), A_ULPTX_ ## name ## _LLIMIT, (start)); \ 	t3_write_reg((adap), A_ULPTX_ ## name ## _ULIMIT, \ 		     (start) + (len) - 1)
end_define

begin_function
specifier|static
name|void
name|ulp_config
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
specifier|const
name|struct
name|tp_params
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|m
init|=
name|p
operator|->
name|chan_rx_size
decl_stmt|;
name|ulp_region
argument_list|(
name|adap
argument_list|,
name|ISCSI
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|chan_rx_size
operator|/
literal|8
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|adap
argument_list|,
name|TDDP
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|chan_rx_size
operator|/
literal|8
argument_list|)
expr_stmt|;
name|ulptx_region
argument_list|(
name|adap
argument_list|,
name|TPT
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|chan_rx_size
operator|/
literal|4
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|adap
argument_list|,
name|STAG
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|chan_rx_size
operator|/
literal|4
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|adap
argument_list|,
name|RQ
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|chan_rx_size
operator|/
literal|4
argument_list|)
expr_stmt|;
name|ulptx_region
argument_list|(
name|adap
argument_list|,
name|PBL
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|chan_rx_size
operator|/
literal|4
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|adap
argument_list|,
name|PBL
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|chan_rx_size
operator|/
literal|4
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_ULPRX_TDDP_TAGMASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|t3_config_trace_filter
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
specifier|const
name|struct
name|trace_params
modifier|*
name|tp
parameter_list|,
name|int
name|filter_index
parameter_list|,
name|int
name|invert
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|u32
name|addr
decl_stmt|,
name|key
index|[
literal|4
index|]
decl_stmt|,
name|mask
index|[
literal|4
index|]
decl_stmt|;
name|key
index|[
literal|0
index|]
operator|=
name|tp
operator|->
name|sport
operator||
operator|(
name|tp
operator|->
name|sip
operator|<<
literal|16
operator|)
expr_stmt|;
name|key
index|[
literal|1
index|]
operator|=
operator|(
name|tp
operator|->
name|sip
operator|>>
literal|16
operator|)
operator||
operator|(
name|tp
operator|->
name|dport
operator|<<
literal|16
operator|)
expr_stmt|;
name|key
index|[
literal|2
index|]
operator|=
name|tp
operator|->
name|dip
expr_stmt|;
name|key
index|[
literal|3
index|]
operator|=
name|tp
operator|->
name|proto
operator||
operator|(
name|tp
operator|->
name|vlan
operator|<<
literal|8
operator|)
operator||
operator|(
name|tp
operator|->
name|intf
operator|<<
literal|20
operator|)
expr_stmt|;
name|mask
index|[
literal|0
index|]
operator|=
name|tp
operator|->
name|sport_mask
operator||
operator|(
name|tp
operator|->
name|sip_mask
operator|<<
literal|16
operator|)
expr_stmt|;
name|mask
index|[
literal|1
index|]
operator|=
operator|(
name|tp
operator|->
name|sip_mask
operator|>>
literal|16
operator|)
operator||
operator|(
name|tp
operator|->
name|dport_mask
operator|<<
literal|16
operator|)
expr_stmt|;
name|mask
index|[
literal|2
index|]
operator|=
name|tp
operator|->
name|dip_mask
expr_stmt|;
name|mask
index|[
literal|3
index|]
operator|=
name|tp
operator|->
name|proto_mask
operator||
operator|(
name|tp
operator|->
name|vlan_mask
operator|<<
literal|8
operator|)
operator||
operator|(
name|tp
operator|->
name|intf_mask
operator|<<
literal|20
operator|)
expr_stmt|;
if|if
condition|(
name|invert
condition|)
name|key
index|[
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
literal|29
operator|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|key
index|[
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
literal|28
operator|)
expr_stmt|;
name|addr
operator|=
name|filter_index
condition|?
name|A_TP_RX_TRC_KEY0
else|:
name|A_TP_TX_TRC_KEY0
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|,
name|key
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|,
name|mask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|,
name|key
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|,
name|mask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|,
name|key
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|,
name|mask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|,
name|key
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|,
name|mask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_PIO_DATA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_config_sched - configure a HW traffic scheduler  *	@adap: the adapter  *	@kbps: target rate in Kbps  *	@sched: the scheduler index  *  *	Configure a Tx HW scheduler for the target rate.  */
end_comment

begin_function
name|int
name|t3_config_sched
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|kbps
parameter_list|,
name|int
name|sched
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|tps
decl_stmt|,
name|cpt
decl_stmt|,
name|bpt
decl_stmt|,
name|delta
decl_stmt|,
name|mindelta
init|=
operator|~
literal|0
decl_stmt|;
name|unsigned
name|int
name|clk
init|=
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|*
literal|1000
decl_stmt|;
name|unsigned
name|int
name|selected_cpt
init|=
literal|0
decl_stmt|,
name|selected_bpt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|kbps
operator|>
literal|0
condition|)
block|{
name|kbps
operator|*=
literal|125
expr_stmt|;
comment|/* -> bytes */
for|for
control|(
name|cpt
operator|=
literal|1
init|;
name|cpt
operator|<=
literal|255
condition|;
name|cpt
operator|++
control|)
block|{
name|tps
operator|=
name|clk
operator|/
name|cpt
expr_stmt|;
name|bpt
operator|=
operator|(
name|kbps
operator|+
name|tps
operator|/
literal|2
operator|)
operator|/
name|tps
expr_stmt|;
if|if
condition|(
name|bpt
operator|>
literal|0
operator|&&
name|bpt
operator|<=
literal|255
condition|)
block|{
name|v
operator|=
name|bpt
operator|*
name|tps
expr_stmt|;
name|delta
operator|=
name|v
operator|>=
name|kbps
condition|?
name|v
operator|-
name|kbps
else|:
name|kbps
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|delta
operator|<=
name|mindelta
condition|)
block|{
name|mindelta
operator|=
name|delta
expr_stmt|;
name|selected_cpt
operator|=
name|cpt
expr_stmt|;
name|selected_bpt
operator|=
name|bpt
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|selected_cpt
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|selected_cpt
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|A_TP_TX_MOD_Q1_Q0_RATE_LIMIT
operator|-
name|sched
operator|/
literal|2
argument_list|)
expr_stmt|;
name|v
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|=
operator|(
name|v
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|selected_cpt
operator|<<
literal|16
operator|)
operator||
operator|(
name|selected_bpt
operator|<<
literal|24
operator|)
expr_stmt|;
else|else
name|v
operator|=
operator|(
name|v
operator|&
literal|0xffff0000
operator|)
operator||
name|selected_cpt
operator||
operator|(
name|selected_bpt
operator|<<
literal|8
operator|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_set_sched_ipg - set the IPG for a Tx HW packet rate scheduler  *	@adap: the adapter  *	@sched: the scheduler index  *	@ipg: the interpacket delay in tenths of nanoseconds  *  *	Set the interpacket delay for a HW packet rate scheduler.  */
end_comment

begin_function
name|int
name|t3_set_sched_ipg
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|int
name|sched
parameter_list|,
name|unsigned
name|int
name|ipg
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|addr
init|=
name|A_TP_TX_MOD_Q1_Q0_TIMER_SEPARATOR
operator|-
name|sched
operator|/
literal|2
decl_stmt|;
comment|/* convert ipg to nearest number of core clocks */
name|ipg
operator|*=
name|core_ticks_per_usec
argument_list|(
name|adap
argument_list|)
expr_stmt|;
name|ipg
operator|=
operator|(
name|ipg
operator|+
literal|5000
operator|)
operator|/
literal|10000
expr_stmt|;
if|if
condition|(
name|ipg
operator|>
literal|0xffff
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|v
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|=
operator|(
name|v
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|ipg
operator|<<
literal|16
operator|)
expr_stmt|;
else|else
name|v
operator|=
operator|(
name|v
operator|&
literal|0xffff0000
operator|)
operator||
name|ipg
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_get_tx_sched - get the configuration of a Tx HW traffic scheduler  *	@adap: the adapter  *	@sched: the scheduler index  *	@kbps: the byte rate in Kbps  *	@ipg: the interpacket delay in tenths of nanoseconds  *  *	Return the current configuration of a HW Tx scheduler.  */
end_comment

begin_function
name|void
name|t3_get_tx_sched
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|sched
parameter_list|,
name|unsigned
name|int
modifier|*
name|kbps
parameter_list|,
name|unsigned
name|int
modifier|*
name|ipg
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|addr
decl_stmt|,
name|bpt
decl_stmt|,
name|cpt
decl_stmt|;
if|if
condition|(
name|kbps
condition|)
block|{
name|addr
operator|=
name|A_TP_TX_MOD_Q1_Q0_RATE_LIMIT
operator|-
name|sched
operator|/
literal|2
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|v
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|>>=
literal|16
expr_stmt|;
name|bpt
operator|=
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|cpt
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|!
name|cpt
condition|)
operator|*
name|kbps
operator|=
literal|0
expr_stmt|;
comment|/* scheduler disabled */
else|else
block|{
name|v
operator|=
operator|(
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|*
literal|1000
operator|)
operator|/
name|cpt
expr_stmt|;
operator|*
name|kbps
operator|=
operator|(
name|v
operator|*
name|bpt
operator|)
operator|/
literal|125
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ipg
condition|)
block|{
name|addr
operator|=
name|A_TP_TX_MOD_Q1_Q0_TIMER_SEPARATOR
operator|-
name|sched
operator|/
literal|2
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|v
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|>>=
literal|16
expr_stmt|;
name|v
operator|&=
literal|0xffff
expr_stmt|;
operator|*
name|ipg
operator|=
operator|(
literal|10000
operator|*
name|v
operator|)
operator|/
name|core_ticks_per_usec
argument_list|(
name|adap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|tp_init
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
specifier|const
name|struct
name|tp_params
modifier|*
name|p
parameter_list|)
block|{
name|int
name|busy
init|=
literal|0
decl_stmt|;
name|tp_config
argument_list|(
name|adap
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|t3_set_vlan_accel
argument_list|(
name|adap
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_offload
argument_list|(
name|adap
argument_list|)
condition|)
block|{
name|tp_set_timers
argument_list|(
name|adap
argument_list|,
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_RESET
argument_list|,
name|F_FLSTINITENABLE
argument_list|)
expr_stmt|;
name|busy
operator|=
name|t3_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_TP_RESET
argument_list|,
name|F_FLSTINITENABLE
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|busy
condition|)
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"TP initialization timed out\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|busy
condition|)
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_RESET
argument_list|,
name|F_TPRESET
argument_list|)
expr_stmt|;
return|return
name|busy
return|;
block|}
end_function

begin_function
name|int
name|t3_mps_set_active_ports
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|port_mask
parameter_list|)
block|{
if|if
condition|(
name|port_mask
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|adap
operator|->
name|params
operator|.
name|nports
operator|)
operator|-
literal|1
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_MPS_CFG
argument_list|,
name|F_PORT1ACTIVE
operator||
name|F_PORT0ACTIVE
argument_list|,
name|port_mask
operator|<<
name|S_PORT0ACTIVE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Perform the bits of HW initialization that are dependent on the number  * of available ports.  */
end_comment

begin_function
specifier|static
name|void
name|init_hw_for_avail_ports
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|int
name|nports
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nports
operator|==
literal|1
condition|)
block|{
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_ULPRX_CTL
argument_list|,
name|F_ROUND_ROBIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_ULPTX_CONFIG
argument_list|,
name|F_CFG_RR_ARB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_CFG
argument_list|,
name|F_TPRXPORTEN
operator||
name|F_TPTXPORT0EN
operator||
name|F_PORT0ACTIVE
operator||
name|F_ENFORCEPKT
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PM1_TX_CFG
argument_list|,
literal|0xc000c000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_ULPRX_CTL
argument_list|,
literal|0
argument_list|,
name|F_ROUND_ROBIN
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_ULPTX_CONFIG
argument_list|,
literal|0
argument_list|,
name|F_CFG_RR_ARB
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_ULPTX_DMA_WEIGHT
argument_list|,
name|V_D1_WEIGHT
argument_list|(
literal|16
argument_list|)
operator||
name|V_D0_WEIGHT
argument_list|(
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_CFG
argument_list|,
name|F_TPTXPORT0EN
operator||
name|F_TPTXPORT1EN
operator||
name|F_TPRXPORTEN
operator||
name|F_PORT0ACTIVE
operator||
name|F_PORT1ACTIVE
operator||
name|F_ENFORCEPKT
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PM1_TX_CFG
argument_list|,
literal|0x80008000
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PC_CONFIG
argument_list|,
literal|0
argument_list|,
name|F_TXTOSQUEUEMAPMODE
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_MOD_QUEUE_REQ_MAP
argument_list|,
name|V_TX_MOD_QUEUE_REQ_MAP
argument_list|(
literal|0xaa
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_MOD_QUE_TABLE
argument_list|,
operator|(
name|i
operator|<<
literal|16
operator|)
operator||
literal|0x1010
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|calibrate_xgm
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_XAUI_IMP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_XAUI_IMP
argument_list|)
expr_stmt|;
name|t3_os_sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_XAUI_IMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|&
operator|(
name|F_XGM_CALFAULT
operator||
name|F_CALBUSY
operator|)
operator|)
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_XAUI_IMP
argument_list|,
name|V_XAUIIMP
argument_list|(
name|G_CALIMP
argument_list|(
name|v
argument_list|)
operator|>>
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"MAC calibration failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
name|V_RGMIIIMPPD
argument_list|(
literal|2
argument_list|)
operator||
name|V_RGMIIIMPPU
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
name|F_XGM_IMPSETUPDATE
argument_list|,
name|F_XGM_IMPSETUPDATE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|calibrate_xgm_t3b
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
name|F_CALRESET
operator||
name|F_CALUPDATE
operator||
name|V_RGMIIIMPPD
argument_list|(
literal|2
argument_list|)
operator||
name|V_RGMIIIMPPU
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
name|F_CALRESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
literal|0
argument_list|,
name|F_XGM_IMPSETUPDATE
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
name|F_XGM_IMPSETUPDATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
name|F_CALUPDATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
literal|0
argument_list|,
name|F_CALUPDATE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|mc7_timing_params
block|{
name|unsigned
name|char
name|ActToPreDly
decl_stmt|;
name|unsigned
name|char
name|ActToRdWrDly
decl_stmt|;
name|unsigned
name|char
name|PreCyc
decl_stmt|;
name|unsigned
name|char
name|RefCyc
index|[
literal|5
index|]
decl_stmt|;
name|unsigned
name|char
name|BkCyc
decl_stmt|;
name|unsigned
name|char
name|WrToRdDly
decl_stmt|;
name|unsigned
name|char
name|RdToWrDly
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Write a value to a register and check that the write completed.  These  * writes normally complete in a cycle or two, so one read should suffice.  * The very first read exists to flush the posted write to the device.  */
end_comment

begin_function
specifier|static
name|int
name|wrreg_wait
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* flush */
if|if
condition|(
operator|!
operator|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
operator|&
name|F_BUSY
operator|)
condition|)
return|return
literal|0
return|;
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"write to MC7 register 0x%x timed out\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mc7_init
parameter_list|(
name|struct
name|mc7
modifier|*
name|mc7
parameter_list|,
name|unsigned
name|int
name|mc7_clock
parameter_list|,
name|int
name|mem_type
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|int
name|mc7_mode
index|[]
init|=
block|{
literal|0x632
block|,
literal|0x642
block|,
literal|0x652
block|,
literal|0x432
block|,
literal|0x442
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|mc7_timing_params
name|mc7_timings
index|[]
init|=
block|{
block|{
literal|12
block|,
literal|3
block|,
literal|4
block|,
block|{
literal|20
block|,
literal|28
block|,
literal|34
block|,
literal|52
block|,
literal|0
block|}
block|,
literal|15
block|,
literal|6
block|,
literal|4
block|}
block|,
block|{
literal|12
block|,
literal|4
block|,
literal|5
block|,
block|{
literal|20
block|,
literal|28
block|,
literal|34
block|,
literal|52
block|,
literal|0
block|}
block|,
literal|16
block|,
literal|7
block|,
literal|4
block|}
block|,
block|{
literal|12
block|,
literal|5
block|,
literal|6
block|,
block|{
literal|20
block|,
literal|28
block|,
literal|34
block|,
literal|52
block|,
literal|0
block|}
block|,
literal|17
block|,
literal|8
block|,
literal|4
block|}
block|,
block|{
literal|9
block|,
literal|3
block|,
literal|4
block|,
block|{
literal|15
block|,
literal|21
block|,
literal|26
block|,
literal|39
block|,
literal|0
block|}
block|,
literal|12
block|,
literal|6
block|,
literal|4
block|}
block|,
block|{
literal|9
block|,
literal|4
block|,
literal|5
block|,
block|{
literal|15
block|,
literal|21
block|,
literal|26
block|,
literal|39
block|,
literal|0
block|}
block|,
literal|13
block|,
literal|7
block|,
literal|4
block|}
block|}
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|unsigned
name|int
name|width
decl_stmt|,
name|density
decl_stmt|,
name|slow
decl_stmt|,
name|attempts
decl_stmt|;
name|adapter_t
modifier|*
name|adapter
init|=
name|mc7
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|mc7_timing_params
modifier|*
name|p
init|=
operator|&
name|mc7_timings
index|[
name|mem_type
index|]
decl_stmt|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CFG
argument_list|)
expr_stmt|;
name|slow
operator|=
name|val
operator|&
name|F_SLOW
expr_stmt|;
name|width
operator|=
name|G_WIDTH
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|density
operator|=
name|G_DEN
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CFG
argument_list|,
name|val
operator||
name|F_IFEN
argument_list|)
expr_stmt|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CFG
argument_list|)
expr_stmt|;
comment|/* flush */
name|t3_os_sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slow
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CAL
argument_list|,
name|F_SGL_CAL_EN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CAL
argument_list|)
expr_stmt|;
name|t3_os_sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CAL
argument_list|)
operator|&
operator|(
name|F_BUSY
operator||
name|F_SGL_CAL_EN
operator||
name|F_CAL_FAULT
operator|)
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"%s MC7 calibration timed out\n"
argument_list|,
name|mc7
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|out_fail
goto|;
block|}
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_PARM
argument_list|,
name|V_ACTTOPREDLY
argument_list|(
name|p
operator|->
name|ActToPreDly
argument_list|)
operator||
name|V_ACTTORDWRDLY
argument_list|(
name|p
operator|->
name|ActToRdWrDly
argument_list|)
operator||
name|V_PRECYC
argument_list|(
name|p
operator|->
name|PreCyc
argument_list|)
operator||
name|V_REFCYC
argument_list|(
name|p
operator|->
name|RefCyc
index|[
name|density
index|]
argument_list|)
operator||
name|V_BKCYC
argument_list|(
name|p
operator|->
name|BkCyc
argument_list|)
operator||
name|V_WRTORDDLY
argument_list|(
name|p
operator|->
name|WrToRdDly
argument_list|)
operator||
name|V_RDTOWRDLY
argument_list|(
name|p
operator|->
name|RdToWrDly
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CFG
argument_list|,
name|val
operator||
name|F_CLKEN
operator||
name|F_TERM150
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CFG
argument_list|)
expr_stmt|;
comment|/* flush */
if|if
condition|(
operator|!
name|slow
condition|)
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_DLL
argument_list|,
name|F_DLLENB
argument_list|,
name|F_DLLENB
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|slow
condition|?
literal|3
else|:
literal|6
expr_stmt|;
if|if
condition|(
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_PRE
argument_list|,
literal|0
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_EXT_MODE2
argument_list|,
literal|0
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_EXT_MODE3
argument_list|,
literal|0
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_EXT_MODE1
argument_list|,
name|val
argument_list|)
condition|)
goto|goto
name|out_fail
goto|;
if|if
condition|(
operator|!
name|slow
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_MODE
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_DLL
argument_list|,
name|F_DLLRST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_PRE
argument_list|,
literal|0
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_REF
argument_list|,
literal|0
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_REF
argument_list|,
literal|0
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_MODE
argument_list|,
name|mc7_mode
index|[
name|mem_type
index|]
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_EXT_MODE1
argument_list|,
name|val
operator||
literal|0x380
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_EXT_MODE1
argument_list|,
name|val
argument_list|)
condition|)
goto|goto
name|out_fail
goto|;
comment|/* clock value is in KHz */
name|mc7_clock
operator|=
name|mc7_clock
operator|*
literal|7812
operator|+
name|mc7_clock
operator|/
literal|2
expr_stmt|;
comment|/* ns */
name|mc7_clock
operator|/=
literal|1000000
expr_stmt|;
comment|/* KHz->MHz, ns->us */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_REF
argument_list|,
name|F_PERREFEN
operator||
name|V_PREREFDIV
argument_list|(
name|mc7_clock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_REF
argument_list|)
expr_stmt|;
comment|/* flush */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_ECC
argument_list|,
name|F_ECCGENEN
operator||
name|F_ECCCHKEN
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BIST_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BIST_ADDR_BEG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BIST_ADDR_END
argument_list|,
operator|(
name|mc7
operator|->
name|size
operator|<<
name|width
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BIST_OP
argument_list|,
name|V_OP
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BIST_OP
argument_list|)
expr_stmt|;
comment|/* flush */
name|attempts
operator|=
literal|50
expr_stmt|;
do|do
block|{
name|t3_os_sleep
argument_list|(
literal|250
argument_list|)
expr_stmt|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BIST_OP
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|val
operator|&
name|F_BUSY
operator|)
operator|&&
operator|--
name|attempts
condition|)
do|;
if|if
condition|(
name|val
operator|&
name|F_BUSY
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"%s MC7 BIST timed out\n"
argument_list|,
name|mc7
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|out_fail
goto|;
block|}
comment|/* Enable normal memory accesses. */
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CFG
argument_list|,
literal|0
argument_list|,
name|F_RDY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out_fail
label|:
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|config_pcie
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|)
block|{
specifier|static
specifier|const
name|u16
name|ack_lat
index|[
literal|4
index|]
index|[
literal|6
index|]
init|=
block|{
block|{
literal|237
block|,
literal|416
block|,
literal|559
block|,
literal|1071
block|,
literal|2095
block|,
literal|4143
block|}
block|,
block|{
literal|128
block|,
literal|217
block|,
literal|289
block|,
literal|545
block|,
literal|1057
block|,
literal|2081
block|}
block|,
block|{
literal|73
block|,
literal|118
block|,
literal|154
block|,
literal|282
block|,
literal|538
block|,
literal|1050
block|}
block|,
block|{
literal|67
block|,
literal|107
block|,
literal|86
block|,
literal|150
block|,
literal|278
block|,
literal|534
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|u16
name|rpl_tmr
index|[
literal|4
index|]
index|[
literal|6
index|]
init|=
block|{
block|{
literal|711
block|,
literal|1248
block|,
literal|1677
block|,
literal|3213
block|,
literal|6285
block|,
literal|12429
block|}
block|,
block|{
literal|384
block|,
literal|651
block|,
literal|867
block|,
literal|1635
block|,
literal|3171
block|,
literal|6243
block|}
block|,
block|{
literal|219
block|,
literal|354
block|,
literal|462
block|,
literal|846
block|,
literal|1614
block|,
literal|3150
block|}
block|,
block|{
literal|201
block|,
literal|321
block|,
literal|258
block|,
literal|450
block|,
literal|834
block|,
literal|1602
block|}
block|}
decl_stmt|;
name|u16
name|val
decl_stmt|;
name|unsigned
name|int
name|log2_width
decl_stmt|,
name|pldsize
decl_stmt|;
name|unsigned
name|int
name|fst_trn_rx
decl_stmt|,
name|fst_trn_tx
decl_stmt|,
name|acklat
decl_stmt|,
name|rpllmt
decl_stmt|;
name|t3_os_pci_read_config_2
argument_list|(
name|adap
argument_list|,
name|adap
operator|->
name|params
operator|.
name|pci
operator|.
name|pcie_cap_addr
operator|+
name|PCI_EXP_DEVCTL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|pldsize
operator|=
operator|(
name|val
operator|&
name|PCI_EXP_DEVCTL_PAYLOAD
operator|)
operator|>>
literal|5
expr_stmt|;
name|t3_os_pci_read_config_2
argument_list|(
name|adap
argument_list|,
name|adap
operator|->
name|params
operator|.
name|pci
operator|.
name|pcie_cap_addr
operator|+
name|PCI_EXP_LNKCTL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|fst_trn_tx
operator|=
name|G_NUMFSTTRNSEQ
argument_list|(
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_PEX_CTRL0
argument_list|)
argument_list|)
expr_stmt|;
name|fst_trn_rx
operator|=
name|adap
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
condition|?
name|fst_trn_tx
else|:
name|G_NUMFSTTRNSEQRX
argument_list|(
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_MODE
argument_list|)
argument_list|)
expr_stmt|;
name|log2_width
operator|=
name|fls
argument_list|(
name|adap
operator|->
name|params
operator|.
name|pci
operator|.
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
name|acklat
operator|=
name|ack_lat
index|[
name|log2_width
index|]
index|[
name|pldsize
index|]
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|1
condition|)
comment|/* check LOsEnable */
name|acklat
operator|+=
name|fst_trn_tx
operator|*
literal|4
expr_stmt|;
name|rpllmt
operator|=
name|rpl_tmr
index|[
name|log2_width
index|]
index|[
name|pldsize
index|]
operator|+
name|fst_trn_rx
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
condition|)
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_PCIE_PEX_CTRL1
argument_list|,
name|V_T3A_ACKLAT
argument_list|(
name|M_T3A_ACKLAT
argument_list|)
argument_list|,
name|V_T3A_ACKLAT
argument_list|(
name|acklat
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_PCIE_PEX_CTRL1
argument_list|,
name|V_ACKLAT
argument_list|(
name|M_ACKLAT
argument_list|)
argument_list|,
name|V_ACKLAT
argument_list|(
name|acklat
argument_list|)
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_PCIE_PEX_CTRL0
argument_list|,
name|V_REPLAYLMT
argument_list|(
name|M_REPLAYLMT
argument_list|)
argument_list|,
name|V_REPLAYLMT
argument_list|(
name|rpllmt
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_PEX_ERR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_PCIE_CFG
argument_list|,
name|F_PCIE_CLIDECEN
argument_list|,
name|F_PCIE_CLIDECEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize and configure T3 HW modules.  This performs the  * initialization steps that need to be done once after a card is reset.  * MAC and PHY initialization is handled separarely whenever a port is enabled.  *  * fw_params are passed to FW and their value is platform dependent.  Only the  * top 8 bits are available for use, the rest must be 0.  */
end_comment

begin_function
name|int
name|t3_init_hw
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
name|fw_params
parameter_list|)
block|{
name|int
name|err
init|=
operator|-
name|EIO
decl_stmt|,
name|attempts
init|=
literal|100
decl_stmt|;
specifier|const
name|struct
name|vpd_params
modifier|*
name|vpd
init|=
operator|&
name|adapter
operator|->
name|params
operator|.
name|vpd
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
name|calibrate_xgm_t3b
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|calibrate_xgm
argument_list|(
name|adapter
argument_list|)
condition|)
goto|goto
name|out_err
goto|;
if|if
condition|(
name|vpd
operator|->
name|mclk
condition|)
block|{
name|partition_mem
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc7_init
argument_list|(
operator|&
name|adapter
operator|->
name|pmrx
argument_list|,
name|vpd
operator|->
name|mclk
argument_list|,
name|vpd
operator|->
name|mem_timing
argument_list|)
operator|||
name|mc7_init
argument_list|(
operator|&
name|adapter
operator|->
name|pmtx
argument_list|,
name|vpd
operator|->
name|mclk
argument_list|,
name|vpd
operator|->
name|mem_timing
argument_list|)
operator|||
name|mc7_init
argument_list|(
operator|&
name|adapter
operator|->
name|cm
argument_list|,
name|vpd
operator|->
name|mclk
argument_list|,
name|vpd
operator|->
name|mem_timing
argument_list|)
operator|||
name|t3_mc5_init
argument_list|(
operator|&
name|adapter
operator|->
name|mc5
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nservers
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nroutes
argument_list|)
condition|)
goto|goto
name|out_err
goto|;
block|}
if|if
condition|(
name|tp_init
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|tp
argument_list|)
condition|)
goto|goto
name|out_err
goto|;
ifdef|#
directive|ifdef
name|CONFIG_CHELSIO_T3_CORE
name|t3_tp_set_coalescing_size
argument_list|(
name|adapter
argument_list|,
name|min
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|sge
operator|.
name|max_pkt_size
argument_list|,
name|MAX_RX_COALESCING_LEN
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t3_tp_set_max_rxsize
argument_list|(
name|adapter
argument_list|,
name|min
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|sge
operator|.
name|max_pkt_size
argument_list|,
literal|16384U
argument_list|)
argument_list|)
expr_stmt|;
name|ulp_config
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|tp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|is_pcie
argument_list|(
name|adapter
argument_list|)
condition|)
name|config_pcie
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_PCIX_CFG
argument_list|,
literal|0
argument_list|,
name|F_CLIDECEN
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PM1_RX_CFG
argument_list|,
literal|0xf000f000
argument_list|)
expr_stmt|;
name|init_hw_for_avail_ports
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|nports
argument_list|)
expr_stmt|;
name|t3_sge_init
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|sge
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_ACC_DATA
argument_list|,
name|vpd
operator|->
name|uclk
operator||
name|fw_params
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_CIM_BOOT_CFG
argument_list|,
name|V_BOOTADDR
argument_list|(
name|FW_FLASH_BOOT_ADDR
operator|>>
literal|2
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_CIM_BOOT_CFG
argument_list|)
expr_stmt|;
comment|/* flush */
do|do
block|{
comment|/* wait for uP to initialize */
name|t3_os_sleep
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_ACC_DATA
argument_list|)
operator|&&
operator|--
name|attempts
condition|)
do|;
if|if
condition|(
operator|!
name|attempts
condition|)
goto|goto
name|out_err
goto|;
name|err
operator|=
literal|0
expr_stmt|;
name|out_err
label|:
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/**  *	get_pci_mode - determine a card's PCI mode  *	@adapter: the adapter  *	@p: where to store the PCI settings  *  *	Determines a card's PCI mode and associated parameters, such as speed  *	and width.  */
end_comment

begin_function
specifier|static
name|void
name|__devinit
name|get_pci_mode
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|struct
name|pci_params
modifier|*
name|p
parameter_list|)
block|{
specifier|static
name|unsigned
name|short
name|speed_map
index|[]
init|=
block|{
literal|33
block|,
literal|66
block|,
literal|100
block|,
literal|133
block|}
decl_stmt|;
name|u32
name|pci_mode
decl_stmt|,
name|pcie_cap
decl_stmt|;
name|pcie_cap
operator|=
name|t3_os_find_pci_capability
argument_list|(
name|adapter
argument_list|,
name|PCI_CAP_ID_EXP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcie_cap
condition|)
block|{
name|u16
name|val
decl_stmt|;
name|p
operator|->
name|variant
operator|=
name|PCI_VARIANT_PCIE
expr_stmt|;
name|p
operator|->
name|pcie_cap_addr
operator|=
name|pcie_cap
expr_stmt|;
name|t3_os_pci_read_config_2
argument_list|(
name|adapter
argument_list|,
name|pcie_cap
operator|+
name|PCI_EXP_LNKSTA
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|p
operator|->
name|width
operator|=
operator|(
name|val
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
expr_stmt|;
return|return;
block|}
name|pci_mode
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIX_MODE
argument_list|)
expr_stmt|;
name|p
operator|->
name|speed
operator|=
name|speed_map
index|[
name|G_PCLKRANGE
argument_list|(
name|pci_mode
argument_list|)
index|]
expr_stmt|;
name|p
operator|->
name|width
operator|=
operator|(
name|pci_mode
operator|&
name|F_64BIT
operator|)
condition|?
literal|64
else|:
literal|32
expr_stmt|;
name|pci_mode
operator|=
name|G_PCIXINITPAT
argument_list|(
name|pci_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_mode
operator|==
literal|0
condition|)
name|p
operator|->
name|variant
operator|=
name|PCI_VARIANT_PCI
expr_stmt|;
elseif|else
if|if
condition|(
name|pci_mode
operator|<
literal|4
condition|)
name|p
operator|->
name|variant
operator|=
name|PCI_VARIANT_PCIX_MODE1_PARITY
expr_stmt|;
elseif|else
if|if
condition|(
name|pci_mode
operator|<
literal|8
condition|)
name|p
operator|->
name|variant
operator|=
name|PCI_VARIANT_PCIX_MODE1_ECC
expr_stmt|;
else|else
name|p
operator|->
name|variant
operator|=
name|PCI_VARIANT_PCIX_266_MODE2
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	init_link_config - initialize a link's SW state  *	@lc: structure holding the link state  *	@ai: information about the current card  *  *	Initializes the SW state maintained for each link, including the link's  *	capabilities and default speed/duplex/flow-control/autonegotiation  *	settings.  */
end_comment

begin_function
specifier|static
name|void
name|__devinit
name|init_link_config
parameter_list|(
name|struct
name|link_config
modifier|*
name|lc
parameter_list|,
name|unsigned
name|int
name|caps
parameter_list|)
block|{
name|lc
operator|->
name|supported
operator|=
name|caps
expr_stmt|;
name|lc
operator|->
name|requested_speed
operator|=
name|lc
operator|->
name|speed
operator|=
name|SPEED_INVALID
expr_stmt|;
name|lc
operator|->
name|requested_duplex
operator|=
name|lc
operator|->
name|duplex
operator|=
name|DUPLEX_INVALID
expr_stmt|;
name|lc
operator|->
name|requested_fc
operator|=
name|lc
operator|->
name|fc
operator|=
name|PAUSE_RX
operator||
name|PAUSE_TX
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|supported
operator|&
name|SUPPORTED_Autoneg
condition|)
block|{
name|lc
operator|->
name|advertising
operator|=
name|lc
operator|->
name|supported
expr_stmt|;
name|lc
operator|->
name|autoneg
operator|=
name|AUTONEG_ENABLE
expr_stmt|;
name|lc
operator|->
name|requested_fc
operator||=
name|PAUSE_AUTONEG
expr_stmt|;
block|}
else|else
block|{
name|lc
operator|->
name|advertising
operator|=
literal|0
expr_stmt|;
name|lc
operator|->
name|autoneg
operator|=
name|AUTONEG_DISABLE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	mc7_calc_size - calculate MC7 memory size  *	@cfg: the MC7 configuration  *  *	Calculates the size of an MC7 memory in bytes from the value of its  *	configuration register.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|__devinit
name|mc7_calc_size
parameter_list|(
name|u32
name|cfg
parameter_list|)
block|{
name|unsigned
name|int
name|width
init|=
name|G_WIDTH
argument_list|(
name|cfg
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|banks
init|=
operator|!
operator|!
operator|(
name|cfg
operator|&
name|F_BKS
operator|)
operator|+
literal|1
decl_stmt|;
name|unsigned
name|int
name|org
init|=
operator|!
operator|!
operator|(
name|cfg
operator|&
name|F_ORG
operator|)
operator|+
literal|1
decl_stmt|;
name|unsigned
name|int
name|density
init|=
name|G_DEN
argument_list|(
name|cfg
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|MBs
init|=
operator|(
operator|(
literal|256
operator|<<
name|density
operator|)
operator|*
name|banks
operator|)
operator|/
operator|(
name|org
operator|<<
name|width
operator|)
decl_stmt|;
return|return
name|MBs
operator|<<
literal|20
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__devinit
name|mc7_prep
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|struct
name|mc7
modifier|*
name|mc7
parameter_list|,
name|unsigned
name|int
name|base_addr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|u32
name|cfg
decl_stmt|;
name|mc7
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|mc7
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|mc7
operator|->
name|offset
operator|=
name|base_addr
operator|-
name|MC7_PMRX_BASE_ADDR
expr_stmt|;
name|cfg
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CFG
argument_list|)
expr_stmt|;
name|mc7
operator|->
name|size
operator|=
name|mc7_calc_size
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|mc7
operator|->
name|width
operator|=
name|G_WIDTH
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mac_prep
parameter_list|(
name|struct
name|cmac
modifier|*
name|mac
parameter_list|,
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|mac
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|mac
operator|->
name|offset
operator|=
operator|(
name|XGMAC0_1_BASE_ADDR
operator|-
name|XGMAC0_0_BASE_ADDR
operator|)
operator|*
name|index
expr_stmt|;
name|mac
operator|->
name|nucast
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
operator|&&
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_SERDES_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|is_10G
argument_list|(
name|adapter
argument_list|)
condition|?
literal|0x2901c04
else|:
literal|0x2301c04
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_PORT_CFG
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_ENRGMII
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|early_hw_init
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
parameter_list|)
block|{
name|u32
name|val
init|=
name|V_PORTSPEED
argument_list|(
name|is_10G
argument_list|(
name|adapter
argument_list|)
condition|?
literal|3
else|:
literal|2
argument_list|)
decl_stmt|;
name|mi1_init
argument_list|(
name|adapter
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_I2C_CFG
argument_list|,
comment|/* set for 80KHz */
name|V_I2C_CLKDIV
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|/
literal|80
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_T3DBG_GPIO_EN
argument_list|,
name|ai
operator|->
name|gpio_out
operator||
name|F_GPIO0_OEN
operator||
name|F_GPIO0_OUT_VAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
operator|||
operator|!
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|)
name|val
operator||=
name|F_ENRGMII
expr_stmt|;
comment|/* Enable MAC clocks so we can access the registers */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_PORT_CFG
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_PORT_CFG
argument_list|)
expr_stmt|;
name|val
operator||=
name|F_CLKDIVRESET_
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_PORT_CFG
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_PORT_CFG
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_PORT_CFG
argument_list|,
literal|1
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_PORT_CFG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the adapter.  PCIe cards lose their config space during reset, PCI-X  * ones don't.  */
end_comment

begin_function
name|int
name|t3_reset_adapter
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|save_and_restore_pcie
init|=
name|adapter
operator|->
name|params
operator|.
name|rev
operator|<
name|T3_REV_B2
operator|&&
name|is_pcie
argument_list|(
name|adapter
argument_list|)
decl_stmt|;
name|uint16_t
name|devid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|save_and_restore_pcie
condition|)
name|t3_os_pci_save_state
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_RST
argument_list|,
name|F_CRSTWRM
operator||
name|F_CRSTWRMMODE
argument_list|)
expr_stmt|;
comment|/* 	 * Delay. Give Some time to device to reset fully. 	 * XXX The delay time should be modified. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|t3_os_sleep
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|t3_os_pci_read_config_2
argument_list|(
name|adapter
argument_list|,
literal|0x00
argument_list|,
operator|&
name|devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|devid
operator|==
literal|0x1425
condition|)
break|break;
block|}
if|if
condition|(
name|devid
operator|!=
literal|0x1425
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|save_and_restore_pcie
condition|)
name|t3_os_pci_restore_state
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize adapter SW state for the various HW modules, set initial values  * for some adapter tunables, take PHYs out of reset, and initialize the MDIO  * interface.  */
end_comment

begin_function
name|int
name|__devinit
name|t3_prep_adapter
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
parameter_list|,
name|int
name|reset
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|get_pci_mode
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|pci
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|info
operator|=
name|ai
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|nports
operator|=
name|ai
operator|->
name|nports
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|rev
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_REV
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|linkpoll_period
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|stats_update_period
operator|=
name|is_10G
argument_list|(
name|adapter
argument_list|)
condition|?
name|MAC_STATS_ACCUM_SECS
else|:
operator|(
name|MAC_STATS_ACCUM_SECS
operator|*
literal|10
operator|)
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|pci
operator|.
name|vpd_cap_addr
operator|=
name|t3_os_find_pci_capability
argument_list|(
name|adapter
argument_list|,
name|PCI_CAP_ID_VPD
argument_list|)
expr_stmt|;
name|ret
operator|=
name|get_vpd_params
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|vpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|reset
operator|&&
name|t3_reset_adapter
argument_list|(
name|adapter
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|t3_sge_prep
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|sge
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|mclk
condition|)
block|{
name|struct
name|tp_params
modifier|*
name|p
init|=
operator|&
name|adapter
operator|->
name|params
operator|.
name|tp
decl_stmt|;
name|mc7_prep
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|pmrx
argument_list|,
name|MC7_PMRX_BASE_ADDR
argument_list|,
literal|"PMRX"
argument_list|)
expr_stmt|;
name|mc7_prep
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|pmtx
argument_list|,
name|MC7_PMTX_BASE_ADDR
argument_list|,
literal|"PMTX"
argument_list|)
expr_stmt|;
name|mc7_prep
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|cm
argument_list|,
name|MC7_CM_BASE_ADDR
argument_list|,
literal|"CM"
argument_list|)
expr_stmt|;
name|p
operator|->
name|nchan
operator|=
name|ai
operator|->
name|nports
expr_stmt|;
name|p
operator|->
name|pmrx_size
operator|=
name|t3_mc7_size
argument_list|(
operator|&
name|adapter
operator|->
name|pmrx
argument_list|)
expr_stmt|;
name|p
operator|->
name|pmtx_size
operator|=
name|t3_mc7_size
argument_list|(
operator|&
name|adapter
operator|->
name|pmtx
argument_list|)
expr_stmt|;
name|p
operator|->
name|cm_size
operator|=
name|t3_mc7_size
argument_list|(
operator|&
name|adapter
operator|->
name|cm
argument_list|)
expr_stmt|;
name|p
operator|->
name|chan_rx_size
operator|=
name|p
operator|->
name|pmrx_size
operator|/
literal|2
expr_stmt|;
comment|/* only 1 Rx channel */
name|p
operator|->
name|chan_tx_size
operator|=
name|p
operator|->
name|pmtx_size
operator|/
name|p
operator|->
name|nchan
expr_stmt|;
name|p
operator|->
name|rx_pg_size
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
name|p
operator|->
name|tx_pg_size
operator|=
name|is_10G
argument_list|(
name|adapter
argument_list|)
condition|?
literal|64
operator|*
literal|1024
else|:
literal|16
operator|*
literal|1024
expr_stmt|;
name|p
operator|->
name|rx_num_pgs
operator|=
name|pm_num_pages
argument_list|(
name|p
operator|->
name|chan_rx_size
argument_list|,
name|p
operator|->
name|rx_pg_size
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_num_pgs
operator|=
name|pm_num_pages
argument_list|(
name|p
operator|->
name|chan_tx_size
argument_list|,
name|p
operator|->
name|tx_pg_size
argument_list|)
expr_stmt|;
name|p
operator|->
name|ntimer_qs
operator|=
name|p
operator|->
name|cm_size
operator|>=
operator|(
literal|128
operator|<<
literal|20
operator|)
operator|||
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|?
literal|12
else|:
literal|6
expr_stmt|;
name|p
operator|->
name|dack_re
operator|=
name|fls
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|/
literal|10
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 100us */
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nservers
operator|=
name|DEFAULT_NSERVERS
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
operator|=
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|?
name|DEFAULT_NFILTERS
else|:
literal|0
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nroutes
operator|=
literal|0
expr_stmt|;
name|t3_mc5_prep
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|mc5
argument_list|,
name|MC5_MODE_144_BIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_CHELSIO_T3_CORE
name|init_mtus
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|mtus
argument_list|)
expr_stmt|;
name|init_cong_ctrl
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|a_wnd
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|b_wnd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|early_hw_init
argument_list|(
name|adapter
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|i
argument_list|)
block|{
name|u8
name|hw_addr
index|[
literal|6
index|]
decl_stmt|;
name|struct
name|port_info
modifier|*
name|p
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
operator|!
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|port_type
index|[
name|j
index|]
condition|)
operator|++
name|j
expr_stmt|;
name|p
operator|->
name|port_type
operator|=
operator|&
name|port_types
index|[
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|port_type
index|[
name|j
index|]
index|]
expr_stmt|;
name|p
operator|->
name|port_type
operator|->
name|phy_prep
argument_list|(
operator|&
name|p
operator|->
name|phy
argument_list|,
name|adapter
argument_list|,
name|ai
operator|->
name|phy_base_addr
operator|+
name|j
argument_list|,
name|ai
operator|->
name|mdio_ops
argument_list|)
expr_stmt|;
name|mac_prep
argument_list|(
operator|&
name|p
operator|->
name|mac
argument_list|,
name|adapter
argument_list|,
name|j
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
comment|/* 		 * The VPD EEPROM stores the base Ethernet address for the 		 * card.  A port's address is derived from the base by adding 		 * the port's index to the base's low octet. 		 */
name|memcpy
argument_list|(
name|hw_addr
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|eth_base
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|hw_addr
index|[
literal|5
index|]
operator|=
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|eth_base
index|[
literal|5
index|]
operator|+
name|i
expr_stmt|;
name|t3_os_set_hw_addr
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
name|hw_addr
argument_list|)
expr_stmt|;
name|init_link_config
argument_list|(
operator|&
name|p
operator|->
name|link_config
argument_list|,
name|p
operator|->
name|port_type
operator|->
name|caps
argument_list|)
expr_stmt|;
name|p
operator|->
name|phy
operator|.
name|ops
operator|->
name|power_down
argument_list|(
operator|&
name|p
operator|->
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|port_type
operator|->
name|caps
operator|&
name|SUPPORTED_IRQ
operator|)
condition|)
name|adapter
operator|->
name|params
operator|.
name|linkpoll_period
operator|=
literal|10
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|t3_led_ready
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_T3DBG_GPIO_EN
argument_list|,
name|F_GPIO0_OUT_VAL
argument_list|,
name|F_GPIO0_OUT_VAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_port_failover
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|val
operator|=
name|port
condition|?
name|F_PORT1ACTIVE
else|:
name|F_PORT0ACTIVE
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_MPS_CFG
argument_list|,
name|F_PORT0ACTIVE
operator||
name|F_PORT1ACTIVE
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_failover_done
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_MPS_CFG
argument_list|,
name|F_PORT0ACTIVE
operator||
name|F_PORT1ACTIVE
argument_list|,
name|F_PORT0ACTIVE
operator||
name|F_PORT1ACTIVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_failover_clear
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_MPS_CFG
argument_list|,
name|F_PORT0ACTIVE
operator||
name|F_PORT1ACTIVE
argument_list|,
name|F_PORT0ACTIVE
operator||
name|F_PORT1ACTIVE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

