begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007-2009, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_DEFINED
end_ifdef

begin_include
include|#
directive|include
file|<cxgb_include.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_include.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|msleep
end_undef

begin_define
define|#
directive|define
name|msleep
value|t3_os_sleep
end_define

begin_comment
comment|/**  *	t3_wait_op_done_val - wait until an operation is completed  *	@adapter: the adapter performing the operation  *	@reg: the register to check for completion  *	@mask: a single-bit field within @reg that indicates completion  *	@polarity: the value of the field when the operation is completed  *	@attempts: number of check iterations  *	@delay: delay in usecs between iterations  *	@valp: where to store the value of the register at completion time  *  *	Wait until an operation is completed by checking a bit in a register  *	up to @attempts times.  If @valp is not NULL the value of the register  *	at the time it indicated completion is stored there.  Returns 0 if the  *	operation completes and	-EAGAIN	otherwise.  */
end_comment

begin_function
name|int
name|t3_wait_op_done_val
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|reg
parameter_list|,
name|u32
name|mask
parameter_list|,
name|int
name|polarity
parameter_list|,
name|int
name|attempts
parameter_list|,
name|int
name|delay
parameter_list|,
name|u32
modifier|*
name|valp
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|u32
name|val
init|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|!
operator|(
name|val
operator|&
name|mask
operator|)
operator|==
name|polarity
condition|)
block|{
if|if
condition|(
name|valp
condition|)
operator|*
name|valp
operator|=
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|--
name|attempts
operator|==
literal|0
condition|)
return|return
operator|-
name|EAGAIN
return|;
if|if
condition|(
name|delay
condition|)
name|udelay
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_write_regs - write a bunch of registers  *	@adapter: the adapter to program  *	@p: an array of register address/register value pairs  *	@n: the number of address/value pairs  *	@offset: register address offset  *  *	Takes an array of register address/register value pairs and writes each  *	value to the corresponding register.  Register addresses are adjusted  *	by the supplied offset.  */
end_comment

begin_function
name|void
name|t3_write_regs
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
specifier|const
name|struct
name|addr_val_pair
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|)
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|p
operator|->
name|reg_addr
operator|+
name|offset
argument_list|,
name|p
operator|->
name|val
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_set_reg_field - set a register field to a value  *	@adapter: the adapter to program  *	@addr: the register address  *	@mask: specifies the portion of the register to modify  *	@val: the new value for the register field  *  *	Sets a register field specified by the supplied mask to the  *	given value.  */
end_comment

begin_function
name|void
name|t3_set_reg_field
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|u32
name|mask
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|u32
name|v
init|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
operator|&
operator|~
name|mask
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|,
name|v
operator||
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* flush */
block|}
end_function

begin_comment
comment|/**  *	t3_read_indirect - read indirectly addressed registers  *	@adap: the adapter  *	@addr_reg: register holding the indirect address  *	@data_reg: register holding the value of the indirect register  *	@vals: where the read register values are stored  *	@start_idx: index of first indirect register to read  *	@nregs: how many indirect registers to read  *  *	Reads registers that are accessed indirectly through an address/data  *	register pair.  */
end_comment

begin_function
specifier|static
name|void
name|t3_read_indirect
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr_reg
parameter_list|,
name|unsigned
name|int
name|data_reg
parameter_list|,
name|u32
modifier|*
name|vals
parameter_list|,
name|unsigned
name|int
name|nregs
parameter_list|,
name|unsigned
name|int
name|start_idx
parameter_list|)
block|{
while|while
condition|(
name|nregs
operator|--
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|addr_reg
argument_list|,
name|start_idx
argument_list|)
expr_stmt|;
operator|*
name|vals
operator|++
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|data_reg
argument_list|)
expr_stmt|;
name|start_idx
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_mc7_bd_read - read from MC7 through backdoor accesses  *	@mc7: identifies MC7 to read from  *	@start: index of first 64-bit word to read  *	@n: number of 64-bit words to read  *	@buf: where to store the read result  *  *	Read n 64-bit words from MC7 starting at word start, using backdoor  *	accesses.  */
end_comment

begin_function
name|int
name|t3_mc7_bd_read
parameter_list|(
name|struct
name|mc7
modifier|*
name|mc7
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
name|u64
modifier|*
name|buf
parameter_list|)
block|{
specifier|static
name|int
name|shift
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|24
block|}
decl_stmt|;
specifier|static
name|int
name|step
index|[]
init|=
block|{
literal|0
block|,
literal|32
block|,
literal|16
block|,
literal|8
block|}
decl_stmt|;
name|unsigned
name|int
name|size64
init|=
name|mc7
operator|->
name|size
operator|/
literal|8
decl_stmt|;
comment|/* # of 64-bit words */
name|adapter_t
modifier|*
name|adap
init|=
name|mc7
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
name|start
operator|>=
name|size64
operator|||
name|start
operator|+
name|n
operator|>
name|size64
condition|)
return|return
operator|-
name|EINVAL
return|;
name|start
operator|*=
operator|(
literal|8
operator|<<
name|mc7
operator|->
name|width
operator|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|int
name|i
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
literal|1
operator|<<
name|mc7
operator|->
name|width
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|int
name|attempts
init|=
literal|10
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BD_ADDR
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BD_OP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BD_OP
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|val
operator|&
name|F_BUSY
operator|)
operator|&&
name|attempts
operator|--
condition|)
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BD_OP
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|F_BUSY
condition|)
return|return
operator|-
name|EIO
return|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BD_DATA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc7
operator|->
name|width
operator|==
literal|0
condition|)
block|{
name|val64
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BD_DATA0
argument_list|)
expr_stmt|;
name|val64
operator||=
operator|(
name|u64
operator|)
name|val
operator|<<
literal|32
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mc7
operator|->
name|width
operator|>
literal|1
condition|)
name|val
operator|>>=
name|shift
index|[
name|mc7
operator|->
name|width
index|]
expr_stmt|;
name|val64
operator||=
operator|(
name|u64
operator|)
name|val
operator|<<
operator|(
name|step
index|[
name|mc7
operator|->
name|width
index|]
operator|*
name|i
operator|)
expr_stmt|;
block|}
name|start
operator|+=
literal|8
expr_stmt|;
block|}
operator|*
name|buf
operator|++
operator|=
name|val64
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Low-level I2C read and write routines.  These simply read and write a  * single byte with the option of indicating a "continue" if another operation  * is to be chained.  Generally most code will use higher-level routines to  * read and write to I2C Slave Devices.  */
end_comment

begin_define
define|#
directive|define
name|I2C_ATTEMPTS
value|100
end_define

begin_comment
comment|/*  * Read an 8-bit value from the I2C bus.  If the "chained" parameter is  * non-zero then a STOP bit will not be written after the read command.  On  * error (the read timed out, etc.), a negative errno will be returned (e.g.  * -EAGAIN, etc.).  On success, the 8-bit value read from the I2C bus is  * stored into the buffer *valp and the value of the I2C ACK bit is returned  * as a 0/1 value.  */
end_comment

begin_function
name|int
name|t3_i2c_read8
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|chained
parameter_list|,
name|u8
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|opval
decl_stmt|;
name|MDIO_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_I2C_OP
argument_list|,
name|F_I2C_READ
operator||
operator|(
name|chained
condition|?
name|F_I2C_CONT
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done_val
argument_list|(
name|adapter
argument_list|,
name|A_I2C_OP
argument_list|,
name|F_I2C_BUSY
argument_list|,
literal|0
argument_list|,
name|I2C_ATTEMPTS
argument_list|,
literal|10
argument_list|,
operator|&
name|opval
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|ret
operator|=
operator|(
operator|(
name|opval
operator|&
name|F_I2C_ACK
operator|)
operator|==
name|F_I2C_ACK
operator|)
expr_stmt|;
operator|*
name|valp
operator|=
name|G_I2C_DATA
argument_list|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_I2C_DATA
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MDIO_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Write an 8-bit value to the I2C bus.  If the "chained" parameter is  * non-zero, then a STOP bit will not be written after the write command.  On  * error (the write timed out, etc.), a negative errno will be returned (e.g.  * -EAGAIN, etc.).  On success, the value of the I2C ACK bit is returned as a  * 0/1 value.  */
end_comment

begin_function
name|int
name|t3_i2c_write8
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|chained
parameter_list|,
name|u8
name|val
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|opval
decl_stmt|;
name|MDIO_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_I2C_DATA
argument_list|,
name|V_I2C_DATA
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_I2C_OP
argument_list|,
name|F_I2C_WRITE
operator||
operator|(
name|chained
condition|?
name|F_I2C_CONT
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done_val
argument_list|(
name|adapter
argument_list|,
name|A_I2C_OP
argument_list|,
name|F_I2C_BUSY
argument_list|,
literal|0
argument_list|,
name|I2C_ATTEMPTS
argument_list|,
literal|10
argument_list|,
operator|&
name|opval
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
name|ret
operator|=
operator|(
operator|(
name|opval
operator|&
name|F_I2C_ACK
operator|)
operator|==
name|F_I2C_ACK
operator|)
expr_stmt|;
name|MDIO_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize MI1.  */
end_comment

begin_function
specifier|static
name|void
name|mi1_init
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
parameter_list|)
block|{
name|u32
name|clkdiv
init|=
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|/
operator|(
literal|2
operator|*
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|mdc
operator|)
operator|-
literal|1
decl_stmt|;
name|u32
name|val
init|=
name|F_PREEN
operator||
name|V_CLKDIV
argument_list|(
name|clkdiv
argument_list|)
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MI1_CFG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MDIO_ATTEMPTS
value|20
end_define

begin_comment
comment|/*  * MI1 read/write operations for clause 22 PHYs.  */
end_comment

begin_function
name|int
name|t3_mi1_read
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|phy_addr
parameter_list|,
name|int
name|mmd_addr
parameter_list|,
name|int
name|reg_addr
parameter_list|,
name|unsigned
name|int
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|addr
init|=
name|V_REGADDR
argument_list|(
name|reg_addr
argument_list|)
operator||
name|V_PHYADDR
argument_list|(
name|phy_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|mmd_addr
condition|)
return|return
operator|-
name|EINVAL
return|;
name|MDIO_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_MI1_CFG
argument_list|,
name|V_ST
argument_list|(
name|M_ST
argument_list|)
argument_list|,
name|V_ST
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|V_MDI_OP
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|MDIO_ATTEMPTS
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
operator|*
name|valp
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_DATA
argument_list|)
expr_stmt|;
name|MDIO_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|t3_mi1_write
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|phy_addr
parameter_list|,
name|int
name|mmd_addr
parameter_list|,
name|int
name|reg_addr
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|addr
init|=
name|V_REGADDR
argument_list|(
name|reg_addr
argument_list|)
operator||
name|V_PHYADDR
argument_list|(
name|phy_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|mmd_addr
condition|)
return|return
operator|-
name|EINVAL
return|;
name|MDIO_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_MI1_CFG
argument_list|,
name|V_ST
argument_list|(
name|M_ST
argument_list|)
argument_list|,
name|V_ST
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|V_MDI_OP
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|MDIO_ATTEMPTS
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|MDIO_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mdio_ops
name|mi1_mdio_ops
init|=
block|{
name|t3_mi1_read
block|,
name|t3_mi1_write
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * MI1 read/write operations for clause 45 PHYs.  */
end_comment

begin_function
specifier|static
name|int
name|mi1_ext_read
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|phy_addr
parameter_list|,
name|int
name|mmd_addr
parameter_list|,
name|int
name|reg_addr
parameter_list|,
name|unsigned
name|int
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|addr
init|=
name|V_REGADDR
argument_list|(
name|mmd_addr
argument_list|)
operator||
name|V_PHYADDR
argument_list|(
name|phy_addr
argument_list|)
decl_stmt|;
name|MDIO_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_MI1_CFG
argument_list|,
name|V_ST
argument_list|(
name|M_ST
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_DATA
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|V_MDI_OP
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|MDIO_ATTEMPTS
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|V_MDI_OP
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|MDIO_ATTEMPTS
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
operator|*
name|valp
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_DATA
argument_list|)
expr_stmt|;
block|}
name|MDIO_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mi1_ext_write
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|phy_addr
parameter_list|,
name|int
name|mmd_addr
parameter_list|,
name|int
name|reg_addr
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|addr
init|=
name|V_REGADDR
argument_list|(
name|mmd_addr
argument_list|)
operator||
name|V_PHYADDR
argument_list|(
name|phy_addr
argument_list|)
decl_stmt|;
name|MDIO_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_MI1_CFG
argument_list|,
name|V_ST
argument_list|(
name|M_ST
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_DATA
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|V_MDI_OP
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|MDIO_ATTEMPTS
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|V_MDI_OP
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_MI1_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|MDIO_ATTEMPTS
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|MDIO_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mdio_ops
name|mi1_mdio_ext_ops
init|=
block|{
name|mi1_ext_read
block|,
name|mi1_ext_write
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  *	t3_mdio_change_bits - modify the value of a PHY register  *	@phy: the PHY to operate on  *	@mmd: the device address  *	@reg: the register address  *	@clear: what part of the register value to mask off  *	@set: what part of the register value to set  *  *	Changes the value of a PHY register by applying a mask to its current  *	value and ORing the result with a new value.  */
end_comment

begin_function
name|int
name|t3_mdio_change_bits
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|,
name|int
name|mmd
parameter_list|,
name|int
name|reg
parameter_list|,
name|unsigned
name|int
name|clear
parameter_list|,
name|unsigned
name|int
name|set
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
name|ret
operator|=
name|mdio_read
argument_list|(
name|phy
argument_list|,
name|mmd
argument_list|,
name|reg
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|val
operator|&=
operator|~
name|clear
expr_stmt|;
name|ret
operator|=
name|mdio_write
argument_list|(
name|phy
argument_list|,
name|mmd
argument_list|,
name|reg
argument_list|,
name|val
operator||
name|set
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_phy_reset - reset a PHY block  *	@phy: the PHY to operate on  *	@mmd: the device address of the PHY block to reset  *	@wait: how long to wait for the reset to complete in 1ms increments  *  *	Resets a PHY block and optionally waits for the reset to complete.  *	@mmd should be 0 for 10/100/1000 PHYs and the device address to reset  *	for 10G PHYs.  */
end_comment

begin_function
name|int
name|t3_phy_reset
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|,
name|int
name|mmd
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|unsigned
name|int
name|ctl
decl_stmt|;
name|err
operator|=
name|t3_mdio_change_bits
argument_list|(
name|phy
argument_list|,
name|mmd
argument_list|,
name|MII_BMCR
argument_list|,
name|BMCR_PDOWN
argument_list|,
name|BMCR_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
operator|!
name|wait
condition|)
return|return
name|err
return|;
do|do
block|{
name|err
operator|=
name|mdio_read
argument_list|(
name|phy
argument_list|,
name|mmd
argument_list|,
name|MII_BMCR
argument_list|,
operator|&
name|ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|ctl
operator|&=
name|BMCR_RESET
expr_stmt|;
if|if
condition|(
name|ctl
condition|)
name|msleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ctl
operator|&&
operator|--
name|wait
condition|)
do|;
return|return
name|ctl
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_phy_advertise - set the PHY advertisement registers for autoneg  *	@phy: the PHY to operate on  *	@advert: bitmap of capabilities the PHY should advertise  *  *	Sets a 10/100/1000 PHY's advertisement registers to advertise the  *	requested capabilities.  */
end_comment

begin_function
name|int
name|t3_phy_advertise
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|,
name|unsigned
name|int
name|advert
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|unsigned
name|int
name|val
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|mdio_read
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|,
name|MII_CTRL1000
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|val
operator|&=
operator|~
operator|(
name|ADVERTISE_1000HALF
operator||
name|ADVERTISE_1000FULL
operator|)
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_1000baseT_Half
condition|)
name|val
operator||=
name|ADVERTISE_1000HALF
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_1000baseT_Full
condition|)
name|val
operator||=
name|ADVERTISE_1000FULL
expr_stmt|;
name|err
operator|=
name|mdio_write
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|,
name|MII_CTRL1000
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|val
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_10baseT_Half
condition|)
name|val
operator||=
name|ADVERTISE_10HALF
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_10baseT_Full
condition|)
name|val
operator||=
name|ADVERTISE_10FULL
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_100baseT_Half
condition|)
name|val
operator||=
name|ADVERTISE_100HALF
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_100baseT_Full
condition|)
name|val
operator||=
name|ADVERTISE_100FULL
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_Pause
condition|)
name|val
operator||=
name|ADVERTISE_PAUSE_CAP
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_Asym_Pause
condition|)
name|val
operator||=
name|ADVERTISE_PAUSE_ASYM
expr_stmt|;
return|return
name|mdio_write
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|,
name|MII_ADVERTISE
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_phy_advertise_fiber - set fiber PHY advertisement register  *	@phy: the PHY to operate on  *	@advert: bitmap of capabilities the PHY should advertise  *  *	Sets a fiber PHY's advertisement register to advertise the  *	requested capabilities.  */
end_comment

begin_function
name|int
name|t3_phy_advertise_fiber
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|,
name|unsigned
name|int
name|advert
parameter_list|)
block|{
name|unsigned
name|int
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_1000baseT_Half
condition|)
name|val
operator||=
name|ADVERTISE_1000XHALF
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_1000baseT_Full
condition|)
name|val
operator||=
name|ADVERTISE_1000XFULL
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_Pause
condition|)
name|val
operator||=
name|ADVERTISE_1000XPAUSE
expr_stmt|;
if|if
condition|(
name|advert
operator|&
name|ADVERTISED_Asym_Pause
condition|)
name|val
operator||=
name|ADVERTISE_1000XPSE_ASYM
expr_stmt|;
return|return
name|mdio_write
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|,
name|MII_ADVERTISE
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_set_phy_speed_duplex - force PHY speed and duplex  *	@phy: the PHY to operate on  *	@speed: requested PHY speed  *	@duplex: requested PHY duplex  *  *	Force a 10/100/1000 PHY's speed and duplex.  This also disables  *	auto-negotiation except for GigE, where auto-negotiation is mandatory.  */
end_comment

begin_function
name|int
name|t3_set_phy_speed_duplex
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|,
name|int
name|speed
parameter_list|,
name|int
name|duplex
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|unsigned
name|int
name|ctl
decl_stmt|;
name|err
operator|=
name|mdio_read
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|,
name|MII_BMCR
argument_list|,
operator|&
name|ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|speed
operator|>=
literal|0
condition|)
block|{
name|ctl
operator|&=
operator|~
operator|(
name|BMCR_SPEED100
operator||
name|BMCR_SPEED1000
operator||
name|BMCR_ANENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|speed
operator|==
name|SPEED_100
condition|)
name|ctl
operator||=
name|BMCR_SPEED100
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
name|SPEED_1000
condition|)
name|ctl
operator||=
name|BMCR_SPEED1000
expr_stmt|;
block|}
if|if
condition|(
name|duplex
operator|>=
literal|0
condition|)
block|{
name|ctl
operator|&=
operator|~
operator|(
name|BMCR_FULLDPLX
operator||
name|BMCR_ANENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|duplex
operator|==
name|DUPLEX_FULL
condition|)
name|ctl
operator||=
name|BMCR_FULLDPLX
expr_stmt|;
block|}
if|if
condition|(
name|ctl
operator|&
name|BMCR_SPEED1000
condition|)
comment|/* auto-negotiation required for GigE */
name|ctl
operator||=
name|BMCR_ANENABLE
expr_stmt|;
return|return
name|mdio_write
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|,
name|MII_BMCR
argument_list|,
name|ctl
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|t3_phy_lasi_intr_enable
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|)
block|{
return|return
name|mdio_write
argument_list|(
name|phy
argument_list|,
name|MDIO_DEV_PMA_PMD
argument_list|,
name|LASI_CTRL
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|t3_phy_lasi_intr_disable
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|)
block|{
return|return
name|mdio_write
argument_list|(
name|phy
argument_list|,
name|MDIO_DEV_PMA_PMD
argument_list|,
name|LASI_CTRL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|t3_phy_lasi_intr_clear
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
return|return
name|mdio_read
argument_list|(
name|phy
argument_list|,
name|MDIO_DEV_PMA_PMD
argument_list|,
name|LASI_STAT
argument_list|,
operator|&
name|val
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|t3_phy_lasi_intr_handler
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|)
block|{
name|unsigned
name|int
name|status
decl_stmt|;
name|int
name|err
init|=
name|mdio_read
argument_list|(
name|phy
argument_list|,
name|MDIO_DEV_PMA_PMD
argument_list|,
name|LASI_STAT
argument_list|,
operator|&
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
return|return
operator|(
name|status
operator|&
literal|1
operator|)
condition|?
name|cphy_cause_link_change
else|:
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|adapter_info
name|t3_adap_info
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|F_GPIO2_OEN
operator||
name|F_GPIO4_OEN
operator||
name|F_GPIO2_OUT_VAL
operator||
name|F_GPIO4_OUT_VAL
block|,
block|{
name|S_GPIO3
block|,
name|S_GPIO5
block|}
block|,
literal|0
block|,
operator|&
name|mi1_mdio_ops
block|,
literal|"Chelsio PE9000"
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|F_GPIO2_OEN
operator||
name|F_GPIO4_OEN
operator||
name|F_GPIO2_OUT_VAL
operator||
name|F_GPIO4_OUT_VAL
block|,
block|{
name|S_GPIO3
block|,
name|S_GPIO5
block|}
block|,
literal|0
block|,
operator|&
name|mi1_mdio_ops
block|,
literal|"Chelsio T302"
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|F_GPIO1_OEN
operator||
name|F_GPIO6_OEN
operator||
name|F_GPIO7_OEN
operator||
name|F_GPIO10_OEN
operator||
name|F_GPIO11_OEN
operator||
name|F_GPIO1_OUT_VAL
operator||
name|F_GPIO6_OUT_VAL
operator||
name|F_GPIO10_OUT_VAL
block|,
block|{
literal|0
block|}
block|,
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_AUI
block|,
operator|&
name|mi1_mdio_ext_ops
block|,
literal|"Chelsio T310"
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|F_GPIO1_OEN
operator||
name|F_GPIO2_OEN
operator||
name|F_GPIO4_OEN
operator||
name|F_GPIO5_OEN
operator||
name|F_GPIO6_OEN
operator||
name|F_GPIO7_OEN
operator||
name|F_GPIO10_OEN
operator||
name|F_GPIO11_OEN
operator||
name|F_GPIO1_OUT_VAL
operator||
name|F_GPIO5_OUT_VAL
operator||
name|F_GPIO6_OUT_VAL
operator||
name|F_GPIO10_OUT_VAL
block|,
block|{
name|S_GPIO9
block|,
name|S_GPIO3
block|}
block|,
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_AUI
block|,
operator|&
name|mi1_mdio_ext_ops
block|,
literal|"Chelsio T320"
block|}
block|,
block|{
literal|4
block|,
literal|0
block|,
literal|0
block|,
name|F_GPIO5_OEN
operator||
name|F_GPIO6_OEN
operator||
name|F_GPIO7_OEN
operator||
name|F_GPIO5_OUT_VAL
operator||
name|F_GPIO6_OUT_VAL
operator||
name|F_GPIO7_OUT_VAL
block|,
block|{
name|S_GPIO1
block|,
name|S_GPIO2
block|,
name|S_GPIO3
block|,
name|S_GPIO4
block|}
block|,
name|SUPPORTED_AUI
block|,
operator|&
name|mi1_mdio_ops
block|,
literal|"Chelsio T304"
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|F_GPIO1_OEN
operator||
name|F_GPIO2_OEN
operator||
name|F_GPIO4_OEN
operator||
name|F_GPIO6_OEN
operator||
name|F_GPIO7_OEN
operator||
name|F_GPIO10_OEN
operator||
name|F_GPIO1_OUT_VAL
operator||
name|F_GPIO6_OUT_VAL
operator||
name|F_GPIO10_OUT_VAL
block|,
block|{
name|S_GPIO9
block|}
block|,
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_AUI
block|,
operator|&
name|mi1_mdio_ext_ops
block|,
literal|"Chelsio T310"
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|F_GPIO1_OEN
operator||
name|F_GPIO6_OEN
operator||
name|F_GPIO7_OEN
operator||
name|F_GPIO1_OUT_VAL
operator||
name|F_GPIO6_OUT_VAL
block|,
block|{
name|S_GPIO9
block|}
block|,
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_AUI
block|,
operator|&
name|mi1_mdio_ext_ops
block|,
literal|"Chelsio N320E-G2"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return the adapter_info structure with a given index.  Out-of-range indices  * return NULL.  */
end_comment

begin_function
specifier|const
name|struct
name|adapter_info
modifier|*
name|t3_get_adapter_info
parameter_list|(
name|unsigned
name|int
name|id
parameter_list|)
block|{
return|return
name|id
operator|<
name|ARRAY_SIZE
argument_list|(
name|t3_adap_info
argument_list|)
condition|?
operator|&
name|t3_adap_info
index|[
name|id
index|]
else|:
name|NULL
return|;
block|}
end_function

begin_struct
struct|struct
name|port_type_info
block|{
name|int
function_decl|(
modifier|*
name|phy_prep
function_decl|)
parameter_list|(
name|pinfo_t
modifier|*
name|pinfo
parameter_list|,
name|int
name|phy_addr
parameter_list|,
specifier|const
name|struct
name|mdio_ops
modifier|*
name|ops
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|port_type_info
name|port_types
index|[]
init|=
block|{
block|{
name|NULL
block|}
block|,
block|{
name|t3_ael1002_phy_prep
block|}
block|,
block|{
name|t3_vsc8211_phy_prep
block|}
block|,
block|{
name|t3_mv88e1xxx_phy_prep
block|}
block|,
block|{
name|t3_xaui_direct_phy_prep
block|}
block|,
block|{
name|t3_ael2005_phy_prep
block|}
block|,
block|{
name|t3_qt2045_phy_prep
block|}
block|,
block|{
name|t3_ael1006_phy_prep
block|}
block|,
block|{
name|t3_tn1010_phy_prep
block|}
block|,
block|{
name|t3_aq100x_phy_prep
block|}
block|,
block|{
name|t3_ael2020_phy_prep
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VPD_ENTRY
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
define|\
value|u8 name##_kword[2]; u8 name##_len; u8 name##_data[len]
end_define

begin_comment
comment|/*  * Partial EEPROM Vital Product Data structure.  Includes only the ID and  * VPD-R sections.  */
end_comment

begin_struct
struct|struct
name|t3_vpd
block|{
name|u8
name|id_tag
decl_stmt|;
name|u8
name|id_len
index|[
literal|2
index|]
decl_stmt|;
name|u8
name|id_data
index|[
literal|16
index|]
decl_stmt|;
name|u8
name|vpdr_tag
decl_stmt|;
name|u8
name|vpdr_len
index|[
literal|2
index|]
decl_stmt|;
name|VPD_ENTRY
argument_list|(
name|pn
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* part number */
name|VPD_ENTRY
argument_list|(
name|ec
argument_list|,
name|ECNUM_LEN
argument_list|)
expr_stmt|;
comment|/* EC level */
name|VPD_ENTRY
argument_list|(
name|sn
argument_list|,
name|SERNUM_LEN
argument_list|)
expr_stmt|;
comment|/* serial number */
name|VPD_ENTRY
argument_list|(
name|na
argument_list|,
literal|12
argument_list|)
expr_stmt|;
comment|/* MAC address base */
name|VPD_ENTRY
argument_list|(
name|cclk
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* core clock */
name|VPD_ENTRY
argument_list|(
name|mclk
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* mem clock */
name|VPD_ENTRY
argument_list|(
name|uclk
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* uP clk */
name|VPD_ENTRY
argument_list|(
name|mdc
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* MDIO clk */
name|VPD_ENTRY
argument_list|(
name|mt
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* mem timing */
name|VPD_ENTRY
argument_list|(
name|xaui0cfg
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* XAUI0 config */
name|VPD_ENTRY
argument_list|(
name|xaui1cfg
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* XAUI1 config */
name|VPD_ENTRY
argument_list|(
name|port0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* PHY0 complex */
name|VPD_ENTRY
argument_list|(
name|port1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* PHY1 complex */
name|VPD_ENTRY
argument_list|(
name|port2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* PHY2 complex */
name|VPD_ENTRY
argument_list|(
name|port3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* PHY3 complex */
name|VPD_ENTRY
argument_list|(
name|rv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* csum */
name|u32
name|pad
decl_stmt|;
comment|/* for multiple-of-4 sizing and alignment */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|EEPROM_MAX_POLL
value|40
end_define

begin_define
define|#
directive|define
name|EEPROM_STAT_ADDR
value|0x4000
end_define

begin_define
define|#
directive|define
name|VPD_BASE
value|0xc00
end_define

begin_comment
comment|/**  *	t3_seeprom_read - read a VPD EEPROM location  *	@adapter: adapter to read  *	@addr: EEPROM address  *	@data: where to store the read data  *  *	Read a 32-bit word from a location in VPD EEPROM using the card's PCI  *	VPD ROM capability.  A zero is written to the flag bit when the  *	addres is written to the control register.  The hardware device will  *	set the flag to 1 when 4 bytes have been read into the data register.  */
end_comment

begin_function
name|int
name|t3_seeprom_read
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
name|u16
name|val
decl_stmt|;
name|int
name|attempts
init|=
name|EEPROM_MAX_POLL
decl_stmt|;
name|unsigned
name|int
name|base
init|=
name|adapter
operator|->
name|params
operator|.
name|pci
operator|.
name|vpd_cap_addr
decl_stmt|;
if|if
condition|(
operator|(
name|addr
operator|>=
name|EEPROMSIZE
operator|&&
name|addr
operator|!=
name|EEPROM_STAT_ADDR
operator|)
operator|||
operator|(
name|addr
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t3_os_pci_write_config_2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|(
name|u16
operator|)
name|addr
argument_list|)
expr_stmt|;
do|do
block|{
name|udelay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|t3_os_pci_read_config_2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|val
operator|&
name|PCI_VPD_ADDR_F
operator|)
operator|&&
operator|--
name|attempts
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PCI_VPD_ADDR_F
operator|)
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"reading EEPROM address 0x%x failed\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
name|t3_os_pci_read_config_4
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|le32_to_cpu
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_seeprom_write - write a VPD EEPROM location  *	@adapter: adapter to write  *	@addr: EEPROM address  *	@data: value to write  *  *	Write a 32-bit word to a location in VPD EEPROM using the card's PCI  *	VPD ROM capability.  */
end_comment

begin_function
name|int
name|t3_seeprom_write
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|data
parameter_list|)
block|{
name|u16
name|val
decl_stmt|;
name|int
name|attempts
init|=
name|EEPROM_MAX_POLL
decl_stmt|;
name|unsigned
name|int
name|base
init|=
name|adapter
operator|->
name|params
operator|.
name|pci
operator|.
name|vpd_cap_addr
decl_stmt|;
if|if
condition|(
operator|(
name|addr
operator|>=
name|EEPROMSIZE
operator|&&
name|addr
operator|!=
name|EEPROM_STAT_ADDR
operator|)
operator|||
operator|(
name|addr
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t3_os_pci_write_config_4
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_DATA
argument_list|,
name|cpu_to_le32
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|t3_os_pci_write_config_2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|(
name|u16
operator|)
name|addr
operator||
name|PCI_VPD_ADDR_F
argument_list|)
expr_stmt|;
do|do
block|{
name|msleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|t3_os_pci_read_config_2
argument_list|(
name|adapter
argument_list|,
name|base
operator|+
name|PCI_VPD_ADDR
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|val
operator|&
name|PCI_VPD_ADDR_F
operator|)
operator|&&
operator|--
name|attempts
condition|)
do|;
if|if
condition|(
name|val
operator|&
name|PCI_VPD_ADDR_F
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"write to EEPROM address 0x%x failed\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_seeprom_wp - enable/disable EEPROM write protection  *	@adapter: the adapter  *	@enable: 1 to enable write protection, 0 to disable it  *  *	Enables or disables write protection on the serial EEPROM.  */
end_comment

begin_function
name|int
name|t3_seeprom_wp
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
return|return
name|t3_seeprom_write
argument_list|(
name|adapter
argument_list|,
name|EEPROM_STAT_ADDR
argument_list|,
name|enable
condition|?
literal|0xc
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a character holding a hex digit to a number.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hex2int
parameter_list|(
name|unsigned
name|char
name|c
parameter_list|)
block|{
return|return
name|isdigit
argument_list|(
name|c
argument_list|)
condition|?
name|c
operator|-
literal|'0'
else|:
name|toupper
argument_list|(
name|c
argument_list|)
operator|-
literal|'A'
operator|+
literal|10
return|;
block|}
end_function

begin_comment
comment|/**  * 	get_desc_len - get the length of a vpd descriptor.  *	@adapter: the adapter  *	@offset: first byte offset of the vpd descriptor  *  *	Retrieves the length of the small/large resource  *	data type starting at offset.  */
end_comment

begin_function
specifier|static
name|int
name|get_desc_len
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
name|offset
parameter_list|)
block|{
name|u32
name|read_offset
decl_stmt|,
name|tmp
decl_stmt|,
name|shift
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
name|u8
name|tag
decl_stmt|,
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|read_offset
operator|=
name|offset
operator|&
literal|0xfffffffc
expr_stmt|;
name|shift
operator|=
name|offset
operator|&
literal|0x03
expr_stmt|;
name|ret
operator|=
name|t3_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|read_offset
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
operator|*
operator|(
operator|(
name|u32
operator|*
operator|)
name|buf
operator|)
operator|=
name|cpu_to_le32
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tag
operator|=
name|buf
index|[
name|shift
index|]
expr_stmt|;
if|if
condition|(
name|tag
operator|&
literal|0x80
condition|)
block|{
name|ret
operator|=
name|t3_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|read_offset
operator|+
literal|4
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
operator|*
operator|(
operator|(
name|u32
operator|*
operator|)
operator|(
operator|&
name|buf
index|[
literal|4
index|]
operator|)
operator|)
operator|=
name|cpu_to_le32
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|buf
index|[
name|shift
operator|+
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|buf
index|[
name|shift
operator|+
literal|2
index|]
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
operator|+
literal|3
expr_stmt|;
block|}
else|else
name|len
operator|=
operator|(
name|tag
operator|&
literal|0x07
operator|)
operator|+
literal|1
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/**  *	is_end_tag - Check if a vpd tag is the end tag.  *	@adapter: the adapter  *	@offset: first byte offset of the tag  *  *	Checks if the tag located at offset is the end tag.  */
end_comment

begin_function
specifier|static
name|int
name|is_end_tag
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
name|offset
parameter_list|)
block|{
name|u32
name|read_offset
decl_stmt|,
name|shift
decl_stmt|,
name|ret
decl_stmt|,
name|tmp
decl_stmt|;
name|u8
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|read_offset
operator|=
name|offset
operator|&
literal|0xfffffffc
expr_stmt|;
name|shift
operator|=
name|offset
operator|&
literal|0x03
expr_stmt|;
name|ret
operator|=
name|t3_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|read_offset
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
operator|*
operator|(
operator|(
name|u32
operator|*
operator|)
name|buf
operator|)
operator|=
name|cpu_to_le32
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|shift
index|]
operator|==
literal|0x78
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_get_vpd_len - computes the length of a vpd structure  *	@adapter: the adapter  *	@vpd: contains the offset of first byte of vpd  *  *	Computes the lentgh of the vpd structure starting at vpd->offset.  */
end_comment

begin_function
name|int
name|t3_get_vpd_len
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|struct
name|generic_vpd
modifier|*
name|vpd
parameter_list|)
block|{
name|u32
name|len
init|=
literal|0
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|inc
decl_stmt|,
name|ret
decl_stmt|;
name|offset
operator|=
name|vpd
operator|->
name|offset
expr_stmt|;
while|while
condition|(
name|offset
operator|<
operator|(
name|vpd
operator|->
name|offset
operator|+
name|MAX_VPD_BYTES
operator|)
condition|)
block|{
name|ret
operator|=
name|is_end_tag
argument_list|(
name|adapter
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
break|break;
name|inc
operator|=
name|get_desc_len
argument_list|(
name|adapter
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc
operator|<
literal|0
condition|)
return|return
name|inc
return|;
name|len
operator|+=
name|inc
expr_stmt|;
name|offset
operator|+=
name|inc
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_read_vpd - reads the stream of bytes containing a vpd structure  *	@adapter: the adapter  *	@vpd: contains a buffer that would hold the stream of bytes  *  *	Reads the vpd structure starting at vpd->offset into vpd->data,  *	the length of the byte stream to read is vpd->len.  */
end_comment

begin_function
name|int
name|t3_read_vpd
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|struct
name|generic_vpd
modifier|*
name|vpd
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vpd
operator|->
name|len
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|ret
operator|=
name|t3_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|vpd
operator|->
name|offset
operator|+
name|i
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
operator|(
name|vpd
operator|->
name|data
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	get_vpd_params - read VPD parameters from VPD EEPROM  *	@adapter: adapter to read  *	@p: where to store the parameters  *  *	Reads card parameters stored in VPD EEPROM.  */
end_comment

begin_function
specifier|static
name|int
name|get_vpd_params
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|struct
name|vpd_params
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|addr
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|t3_vpd
name|vpd
decl_stmt|;
comment|/* 	 * Card information is normally at VPD_BASE but some early cards had 	 * it at 0. 	 */
name|ret
operator|=
name|t3_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|VPD_BASE
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|vpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|addr
operator|=
name|vpd
operator|.
name|id_tag
operator|==
literal|0x82
condition|?
name|VPD_BASE
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|vpd
argument_list|)
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|ret
operator|=
name|t3_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|addr
operator|+
name|i
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
operator|&
name|vpd
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|p
operator|->
name|cclk
operator|=
name|simple_strtoul
argument_list|(
name|vpd
operator|.
name|cclk_data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|mclk
operator|=
name|simple_strtoul
argument_list|(
name|vpd
operator|.
name|mclk_data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|uclk
operator|=
name|simple_strtoul
argument_list|(
name|vpd
operator|.
name|uclk_data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|mdc
operator|=
name|simple_strtoul
argument_list|(
name|vpd
operator|.
name|mdc_data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|mem_timing
operator|=
name|simple_strtoul
argument_list|(
name|vpd
operator|.
name|mt_data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|sn
argument_list|,
name|vpd
operator|.
name|sn_data
argument_list|,
name|SERNUM_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|ec
argument_list|,
name|vpd
operator|.
name|ec_data
argument_list|,
name|ECNUM_LEN
argument_list|)
expr_stmt|;
comment|/* Old eeproms didn't have port information */
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
operator|&&
operator|!
name|vpd
operator|.
name|port0_data
index|[
literal|0
index|]
condition|)
block|{
name|p
operator|->
name|port_type
index|[
literal|0
index|]
operator|=
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
name|p
operator|->
name|port_type
index|[
literal|1
index|]
operator|=
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|?
literal|6
else|:
literal|2
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|port_type
index|[
literal|0
index|]
operator|=
operator|(
name|u8
operator|)
name|hex2int
argument_list|(
name|vpd
operator|.
name|port0_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|port_type
index|[
literal|1
index|]
operator|=
operator|(
name|u8
operator|)
name|hex2int
argument_list|(
name|vpd
operator|.
name|port1_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|port_type
index|[
literal|2
index|]
operator|=
operator|(
name|u8
operator|)
name|hex2int
argument_list|(
name|vpd
operator|.
name|port2_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|port_type
index|[
literal|3
index|]
operator|=
operator|(
name|u8
operator|)
name|hex2int
argument_list|(
name|vpd
operator|.
name|port3_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|xauicfg
index|[
literal|0
index|]
operator|=
name|simple_strtoul
argument_list|(
name|vpd
operator|.
name|xaui0cfg_data
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|p
operator|->
name|xauicfg
index|[
literal|1
index|]
operator|=
name|simple_strtoul
argument_list|(
name|vpd
operator|.
name|xaui1cfg_data
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|eth_base
index|[
name|i
index|]
operator|=
name|hex2int
argument_list|(
name|vpd
operator|.
name|na_data
index|[
literal|2
operator|*
name|i
index|]
argument_list|)
operator|*
literal|16
operator|+
name|hex2int
argument_list|(
name|vpd
operator|.
name|na_data
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* BIOS boot header */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|boot_header_s
block|{
name|u8
name|signature
index|[
literal|2
index|]
decl_stmt|;
comment|/* signature */
name|u8
name|length
decl_stmt|;
comment|/* image length (include header) */
name|u8
name|offset
index|[
literal|4
index|]
decl_stmt|;
comment|/* initialization vector */
name|u8
name|reserved
index|[
literal|19
index|]
decl_stmt|;
comment|/* reserved */
name|u8
name|exheader
index|[
literal|2
index|]
decl_stmt|;
comment|/* offset to expansion header */
block|}
name|boot_header_t
typedef|;
end_typedef

begin_comment
comment|/* serial flash and firmware constants */
end_comment

begin_enum
enum|enum
block|{
name|SF_ATTEMPTS
init|=
literal|5
block|,
comment|/* max retries for SF1 operations */
name|SF_SEC_SIZE
init|=
literal|64
operator|*
literal|1024
block|,
comment|/* serial flash sector size */
name|SF_SIZE
init|=
name|SF_SEC_SIZE
operator|*
literal|8
block|,
comment|/* serial flash size */
comment|/* flash command opcodes */
name|SF_PROG_PAGE
init|=
literal|2
block|,
comment|/* program page */
name|SF_WR_DISABLE
init|=
literal|4
block|,
comment|/* disable writes */
name|SF_RD_STATUS
init|=
literal|5
block|,
comment|/* read status register */
name|SF_WR_ENABLE
init|=
literal|6
block|,
comment|/* enable writes */
name|SF_RD_DATA_FAST
init|=
literal|0xb
block|,
comment|/* read flash */
name|SF_ERASE_SECTOR
init|=
literal|0xd8
block|,
comment|/* erase sector */
name|FW_FLASH_BOOT_ADDR
init|=
literal|0x70000
block|,
comment|/* start address of FW in flash */
name|FW_VERS_ADDR
init|=
literal|0x7fffc
block|,
comment|/* flash address holding FW version */
name|FW_VERS_ADDR_PRE8
init|=
literal|0x77ffc
block|,
comment|/* flash address holding FW version pre8 */
name|FW_MIN_SIZE
init|=
literal|8
block|,
comment|/* at least version and csum */
name|FW_MAX_SIZE
init|=
name|FW_VERS_ADDR
operator|-
name|FW_FLASH_BOOT_ADDR
block|,
name|FW_MAX_SIZE_PRE8
init|=
name|FW_VERS_ADDR_PRE8
operator|-
name|FW_FLASH_BOOT_ADDR
block|,
name|BOOT_FLASH_BOOT_ADDR
init|=
literal|0x0
block|,
comment|/* start address of boot image in flash */
name|BOOT_SIGNATURE
init|=
literal|0xaa55
block|,
comment|/* signature of BIOS boot ROM */
name|BOOT_SIZE_INC
init|=
literal|512
block|,
comment|/* image size measured in 512B chunks */
name|BOOT_MIN_SIZE
init|=
sizeof|sizeof
argument_list|(
name|boot_header_t
argument_list|)
block|,
comment|/* at least basic header */
name|BOOT_MAX_SIZE
init|=
literal|1024
operator|*
name|BOOT_SIZE_INC
comment|/* 1 byte * length increment  */
block|}
enum|;
end_enum

begin_comment
comment|/**  *	sf1_read - read data from the serial flash  *	@adapter: the adapter  *	@byte_cnt: number of bytes to read  *	@cont: whether another operation will be chained  *	@valp: where to store the read data  *  *	Reads up to 4 bytes of data from the serial flash.  The location of  *	the read needs to be specified prior to calling this by issuing the  *	appropriate commands to the serial flash.  */
end_comment

begin_function
specifier|static
name|int
name|sf1_read
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|byte_cnt
parameter_list|,
name|int
name|cont
parameter_list|,
name|u32
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|byte_cnt
operator|||
name|byte_cnt
operator|>
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|)
operator|&
name|F_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|V_CONT
argument_list|(
name|cont
argument_list|)
operator||
name|V_BYTECNT
argument_list|(
name|byte_cnt
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|SF_ATTEMPTS
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
operator|*
name|valp
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_DATA
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	sf1_write - write data to the serial flash  *	@adapter: the adapter  *	@byte_cnt: number of bytes to write  *	@cont: whether another operation will be chained  *	@val: value to write  *  *	Writes up to 4 bytes of data to the serial flash.  The location of  *	the write needs to be specified prior to calling this by issuing the  *	appropriate commands to the serial flash.  */
end_comment

begin_function
specifier|static
name|int
name|sf1_write
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|byte_cnt
parameter_list|,
name|int
name|cont
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
if|if
condition|(
operator|!
name|byte_cnt
operator|||
name|byte_cnt
operator|>
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|)
operator|&
name|F_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|V_CONT
argument_list|(
name|cont
argument_list|)
operator||
name|V_BYTECNT
argument_list|(
name|byte_cnt
operator|-
literal|1
argument_list|)
operator||
name|V_OP
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SF_OP
argument_list|,
name|F_BUSY
argument_list|,
literal|0
argument_list|,
name|SF_ATTEMPTS
argument_list|,
literal|10
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	flash_wait_op - wait for a flash operation to complete  *	@adapter: the adapter  *	@attempts: max number of polls of the status register  *	@delay: delay between polls in ms  *  *	Wait for a flash operation to complete by polling the status register.  */
end_comment

begin_function
specifier|static
name|int
name|flash_wait_op
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|attempts
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|status
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|SF_RD_STATUS
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_read
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|--
name|attempts
operator|==
literal|0
condition|)
return|return
operator|-
name|EAGAIN
return|;
if|if
condition|(
name|delay
condition|)
name|msleep
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_read_flash - read words from serial flash  *	@adapter: the adapter  *	@addr: the start address for the read  *	@nwords: how many 32-bit words to read  *	@data: where to store the read data  *	@byte_oriented: whether to store data as bytes or as words  *  *	Read the specified number of 32-bit words from the serial flash.  *	If @byte_oriented is set the read data is stored as a byte array  *	(i.e., big-endian), otherwise as 32-bit words in the platform's  *	natural endianess.  */
end_comment

begin_function
name|int
name|t3_read_flash
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|nwords
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|,
name|int
name|byte_oriented
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|addr
operator|+
name|nwords
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|>
name|SF_SIZE
operator|||
operator|(
name|addr
operator|&
literal|3
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|addr
operator|=
name|swab32
argument_list|(
name|addr
argument_list|)
operator||
name|SF_RD_DATA_FAST
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|addr
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_read
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
for|for
control|(
init|;
name|nwords
condition|;
name|nwords
operator|--
operator|,
name|data
operator|++
control|)
block|{
name|ret
operator|=
name|sf1_read
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
name|nwords
operator|>
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|byte_oriented
condition|)
operator|*
name|data
operator|=
name|htonl
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_write_flash - write up to a page of data to the serial flash  *	@adapter: the adapter  *	@addr: the start address to write  *	@n: length of data to write  *	@data: the data to write  *	@byte_oriented: whether to store data as bytes or as words  *  *	Writes up to a page of data (256 bytes) to the serial flash starting  *	at the given address.  *	If @byte_oriented is set the write data is stored as a 32-bit  *	big-endian array, otherwise in the processor's native endianess.  *  */
end_comment

begin_function
specifier|static
name|int
name|t3_write_flash
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|int
name|byte_oriented
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|,
name|left
decl_stmt|,
name|val
decl_stmt|,
name|offset
init|=
name|addr
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|addr
operator|+
name|n
operator|>
name|SF_SIZE
operator|||
name|offset
operator|+
name|n
operator|>
literal|256
condition|)
return|return
operator|-
name|EINVAL
return|;
name|val
operator|=
name|swab32
argument_list|(
name|addr
argument_list|)
operator||
name|SF_PROG_PAGE
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|SF_WR_ENABLE
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|val
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
for|for
control|(
name|left
operator|=
name|n
init|;
name|left
condition|;
name|left
operator|-=
name|c
control|)
block|{
name|c
operator|=
name|min
argument_list|(
name|left
argument_list|,
literal|4U
argument_list|)
expr_stmt|;
name|val
operator|=
operator|*
operator|(
specifier|const
name|u32
operator|*
operator|)
name|data
expr_stmt|;
name|data
operator|+=
name|c
expr_stmt|;
if|if
condition|(
name|byte_oriented
condition|)
name|val
operator|=
name|htonl
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
name|c
argument_list|,
name|c
operator|!=
name|left
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|flash_wait_op
argument_list|(
name|adapter
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
comment|/* Read the page to verify the write succeeded */
name|ret
operator|=
name|t3_read_flash
argument_list|(
name|adapter
argument_list|,
name|addr
operator|&
operator|~
literal|0xff
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|,
name|byte_oriented
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|data
operator|-
name|n
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|buf
operator|+
name|offset
argument_list|,
name|n
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_get_tp_version - read the tp sram version  *	@adapter: the adapter  *	@vers: where to place the version  *  *	Reads the protocol sram version from sram.  */
end_comment

begin_function
name|int
name|t3_get_tp_version
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
modifier|*
name|vers
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* Get version loaded in SRAM */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_EMBED_OP_FIELD0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_TP_EMBED_OP_FIELD0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
operator|*
name|vers
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_EMBED_OP_FIELD1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_check_tpsram_version - read the tp sram version  *	@adapter: the adapter  *  */
end_comment

begin_function
name|int
name|t3_check_tpsram_version
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|vers
decl_stmt|;
name|unsigned
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|==
name|T3_REV_A
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|t3_get_tp_version
argument_list|(
name|adapter
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|vers
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_EMBED_OP_FIELD1
argument_list|)
expr_stmt|;
name|major
operator|=
name|G_TP_VERSION_MAJOR
argument_list|(
name|vers
argument_list|)
expr_stmt|;
name|minor
operator|=
name|G_TP_VERSION_MINOR
argument_list|(
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|major
operator|==
name|TP_VERSION_MAJOR
operator|&&
name|minor
operator|==
name|TP_VERSION_MINOR
condition|)
return|return
literal|0
return|;
else|else
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"found wrong TP version (%u.%u), "
literal|"driver compiled for version %d.%d\n"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|TP_VERSION_MAJOR
argument_list|,
name|TP_VERSION_MINOR
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_check_tpsram - check if provided protocol SRAM  *			  is compatible with this driver  *	@adapter: the adapter  *	@tp_sram: the firmware image to write  *	@size: image size  *  *	Checks if an adapter's tp sram is compatible with the driver.  *	Returns 0 if the versions are compatible, a negative error otherwise.  */
end_comment

begin_function
name|int
name|t3_check_tpsram
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
specifier|const
name|u8
modifier|*
name|tp_sram
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|u32
name|csum
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|u32
modifier|*
name|p
init|=
operator|(
specifier|const
name|u32
operator|*
operator|)
name|tp_sram
decl_stmt|;
comment|/* Verify checksum */
for|for
control|(
name|csum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|/
sizeof|sizeof
argument_list|(
name|csum
argument_list|)
condition|;
name|i
operator|++
control|)
name|csum
operator|+=
name|ntohl
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
literal|0xffffffff
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"corrupted protocol SRAM image, checksum %u\n"
argument_list|,
name|csum
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_enum
enum|enum
name|fw_version_type
block|{
name|FW_VERSION_N3
block|,
name|FW_VERSION_T3
block|}
enum|;
end_enum

begin_comment
comment|/**  *	t3_get_fw_version - read the firmware version  *	@adapter: the adapter  *	@vers: where to place the version  *  *	Reads the FW version from flash. Note that we had to move the version  *	due to FW size. If we don't find a valid FW version in the new location  *	we fall back and read the old location.  */
end_comment

begin_function
name|int
name|t3_get_fw_version
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
modifier|*
name|vers
parameter_list|)
block|{
name|int
name|ret
init|=
name|t3_read_flash
argument_list|(
name|adapter
argument_list|,
name|FW_VERS_ADDR
argument_list|,
literal|1
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
operator|*
name|vers
operator|!=
literal|0xffffffff
condition|)
return|return
literal|0
return|;
else|else
return|return
name|t3_read_flash
argument_list|(
name|adapter
argument_list|,
name|FW_VERS_ADDR_PRE8
argument_list|,
literal|1
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_check_fw_version - check if the FW is compatible with this driver  *	@adapter: the adapter  *  *	Checks if an adapter's FW is compatible with the driver.  Returns 0  *	if the versions are compatible, a negative error otherwise.  */
end_comment

begin_function
name|int
name|t3_check_fw_version
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u32
name|vers
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|,
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|ret
operator|=
name|t3_get_fw_version
argument_list|(
name|adapter
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|type
operator|=
name|G_FW_VERSION_TYPE
argument_list|(
name|vers
argument_list|)
expr_stmt|;
name|major
operator|=
name|G_FW_VERSION_MAJOR
argument_list|(
name|vers
argument_list|)
expr_stmt|;
name|minor
operator|=
name|G_FW_VERSION_MINOR
argument_list|(
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|FW_VERSION_T3
operator|&&
name|major
operator|==
name|FW_VERSION_MAJOR
operator|&&
name|minor
operator|==
name|FW_VERSION_MINOR
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|major
operator|!=
name|FW_VERSION_MAJOR
operator|||
name|minor
operator|<
name|FW_VERSION_MINOR
condition|)
name|CH_WARN
argument_list|(
name|adapter
argument_list|,
literal|"found old FW minor version(%u.%u), "
literal|"driver compiled for version %u.%u\n"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|FW_VERSION_MAJOR
argument_list|,
name|FW_VERSION_MINOR
argument_list|)
expr_stmt|;
else|else
block|{
name|CH_WARN
argument_list|(
name|adapter
argument_list|,
literal|"found newer FW version(%u.%u), "
literal|"driver compiled for version %u.%u\n"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|FW_VERSION_MAJOR
argument_list|,
name|FW_VERSION_MINOR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_flash_erase_sectors - erase a range of flash sectors  *	@adapter: the adapter  *	@start: the first sector to erase  *	@end: the last sector to erase  *  *	Erases the sectors in the given range.  */
end_comment

begin_function
specifier|static
name|int
name|t3_flash_erase_sectors
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
while|while
condition|(
name|start
operator|<=
name|end
condition|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|SF_WR_ENABLE
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sf1_write
argument_list|(
name|adapter
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|SF_ERASE_SECTOR
operator||
operator|(
name|start
operator|<<
literal|8
operator|)
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|flash_wait_op
argument_list|(
name|adapter
argument_list|,
literal|5
argument_list|,
literal|500
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
name|start
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *	t3_load_fw - download firmware  *	@adapter: the adapter  *	@fw_data: the firmware image to write  *	@size: image size  *  *	Write the supplied firmware image to the card's serial flash.  *	The FW image has the following sections: @size - 8 bytes of code and  *	data, followed by 4 bytes of FW version, followed by the 32-bit  *	1's complement checksum of the whole image.  */
end_comment

begin_function
name|int
name|t3_load_fw
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
specifier|const
name|u8
modifier|*
name|fw_data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|u32
name|version
decl_stmt|,
name|csum
decl_stmt|,
name|fw_version_addr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|u32
modifier|*
name|p
init|=
operator|(
specifier|const
name|u32
operator|*
operator|)
name|fw_data
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|addr
decl_stmt|,
name|fw_sector
init|=
name|FW_FLASH_BOOT_ADDR
operator|>>
literal|16
decl_stmt|;
if|if
condition|(
operator|(
name|size
operator|&
literal|3
operator|)
operator|||
name|size
operator|<
name|FW_MIN_SIZE
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|size
operator|-
literal|8
operator|>
name|FW_MAX_SIZE
condition|)
return|return
operator|-
name|EFBIG
return|;
name|version
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
specifier|const
name|u32
operator|*
operator|)
operator|(
name|fw_data
operator|+
name|size
operator|-
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_FW_VERSION_MAJOR
argument_list|(
name|version
argument_list|)
operator|<
literal|8
condition|)
block|{
name|fw_version_addr
operator|=
name|FW_VERS_ADDR_PRE8
expr_stmt|;
if|if
condition|(
name|size
operator|-
literal|8
operator|>
name|FW_MAX_SIZE_PRE8
condition|)
return|return
operator|-
name|EFBIG
return|;
block|}
else|else
name|fw_version_addr
operator|=
name|FW_VERS_ADDR
expr_stmt|;
for|for
control|(
name|csum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|/
sizeof|sizeof
argument_list|(
name|csum
argument_list|)
condition|;
name|i
operator|++
control|)
name|csum
operator|+=
name|ntohl
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
literal|0xffffffff
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"corrupted firmware image, checksum %u\n"
argument_list|,
name|csum
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|ret
operator|=
name|t3_flash_erase_sectors
argument_list|(
name|adapter
argument_list|,
name|fw_sector
argument_list|,
name|fw_sector
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|size
operator|-=
literal|8
expr_stmt|;
comment|/* trim off version and checksum */
for|for
control|(
name|addr
operator|=
name|FW_FLASH_BOOT_ADDR
init|;
name|size
condition|;
control|)
block|{
name|unsigned
name|int
name|chunk_size
init|=
name|min
argument_list|(
name|size
argument_list|,
literal|256U
argument_list|)
decl_stmt|;
name|ret
operator|=
name|t3_write_flash
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|,
name|chunk_size
argument_list|,
name|fw_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|addr
operator|+=
name|chunk_size
expr_stmt|;
name|fw_data
operator|+=
name|chunk_size
expr_stmt|;
name|size
operator|-=
name|chunk_size
expr_stmt|;
block|}
name|ret
operator|=
name|t3_write_flash
argument_list|(
name|adapter
argument_list|,
name|fw_version_addr
argument_list|,
literal|4
argument_list|,
name|fw_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ret
condition|)
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"firmware download failed, error %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  *	t3_load_boot - download boot flash  *	@adapter: the adapter  *	@boot_data: the boot image to write  *	@size: image size  *  *	Write the supplied boot image to the card's serial flash.  *	The boot image has the following sections: a 28-byte header and the  *	boot image.  */
end_comment

begin_function
name|int
name|t3_load_boot
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u8
modifier|*
name|boot_data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|boot_header_t
modifier|*
name|header
init|=
operator|(
name|boot_header_t
operator|*
operator|)
name|boot_data
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
name|unsigned
name|int
name|boot_sector
init|=
name|BOOT_FLASH_BOOT_ADDR
operator|>>
literal|16
decl_stmt|;
name|unsigned
name|int
name|boot_end
init|=
operator|(
name|BOOT_FLASH_BOOT_ADDR
operator|+
name|size
operator|-
literal|1
operator|)
operator|>>
literal|16
decl_stmt|;
comment|/* 	 * Perform some primitive sanity testing to avoid accidentally 	 * writing garbage over the boot sectors.  We ought to check for 	 * more but it's not worth it for now ... 	 */
if|if
condition|(
name|size
operator|<
name|BOOT_MIN_SIZE
operator|||
name|size
operator|>
name|BOOT_MAX_SIZE
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"boot image too small/large\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFBIG
return|;
block|}
if|if
condition|(
name|le16_to_cpu
argument_list|(
operator|*
operator|(
name|u16
operator|*
operator|)
name|header
operator|->
name|signature
argument_list|)
operator|!=
name|BOOT_SIGNATURE
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"boot image missing signature\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|header
operator|->
name|length
operator|*
name|BOOT_SIZE_INC
operator|!=
name|size
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"boot image header length != image length\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|ret
operator|=
name|t3_flash_erase_sectors
argument_list|(
name|adapter
argument_list|,
name|boot_sector
argument_list|,
name|boot_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|addr
operator|=
name|BOOT_FLASH_BOOT_ADDR
init|;
name|size
condition|;
control|)
block|{
name|unsigned
name|int
name|chunk_size
init|=
name|min
argument_list|(
name|size
argument_list|,
literal|256U
argument_list|)
decl_stmt|;
name|ret
operator|=
name|t3_write_flash
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|,
name|chunk_size
argument_list|,
name|boot_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|addr
operator|+=
name|chunk_size
expr_stmt|;
name|boot_data
operator|+=
name|chunk_size
expr_stmt|;
name|size
operator|-=
name|chunk_size
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|ret
condition|)
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"boot image download failed, error %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CIM_CTL_BASE
value|0x2000
end_define

begin_comment
comment|/**  *	t3_cim_ctl_blk_read - read a block from CIM control region  *	@adap: the adapter  *	@addr: the start address within the CIM control region  *	@n: number of words to read  *	@valp: where to store the result  *  *	Reads a block of 4-byte words from the CIM control region.  */
end_comment

begin_function
name|int
name|t3_cim_ctl_blk_read
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
name|unsigned
name|int
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|)
operator|&
name|F_HOSTBUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
for|for
control|(
init|;
operator|!
name|ret
operator|&&
name|n
operator|--
condition|;
name|addr
operator|+=
literal|4
control|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|CIM_CTL_BASE
operator|+
name|addr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|F_HOSTBUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
operator|*
name|valp
operator|++
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_HOST_ACC_DATA
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|t3_gate_rx_traffic
parameter_list|(
name|struct
name|cmac
modifier|*
name|mac
parameter_list|,
name|u32
modifier|*
name|rx_cfg
parameter_list|,
name|u32
modifier|*
name|rx_hash_high
parameter_list|,
name|u32
modifier|*
name|rx_hash_low
parameter_list|)
block|{
comment|/* stop Rx unicast traffic */
name|t3_mac_disable_exact_filters
argument_list|(
name|mac
argument_list|)
expr_stmt|;
comment|/* stop broadcast, multicast, promiscuous mode traffic */
operator|*
name|rx_cfg
operator|=
name|t3_read_reg
argument_list|(
name|mac
operator|->
name|adapter
argument_list|,
name|A_XGM_RX_CFG
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|mac
operator|->
name|adapter
argument_list|,
name|A_XGM_RX_CFG
argument_list|,
name|F_ENHASHMCAST
operator||
name|F_DISBCAST
operator||
name|F_COPYALLFRAMES
argument_list|,
name|F_DISBCAST
argument_list|)
expr_stmt|;
operator|*
name|rx_hash_high
operator|=
name|t3_read_reg
argument_list|(
name|mac
operator|->
name|adapter
argument_list|,
name|A_XGM_RX_HASH_HIGH
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|mac
operator|->
name|adapter
argument_list|,
name|A_XGM_RX_HASH_HIGH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|rx_hash_low
operator|=
name|t3_read_reg
argument_list|(
name|mac
operator|->
name|adapter
argument_list|,
name|A_XGM_RX_HASH_LOW
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|mac
operator|->
name|adapter
argument_list|,
name|A_XGM_RX_HASH_LOW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Leave time to drain max RX fifo */
name|msleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|t3_open_rx_traffic
parameter_list|(
name|struct
name|cmac
modifier|*
name|mac
parameter_list|,
name|u32
name|rx_cfg
parameter_list|,
name|u32
name|rx_hash_high
parameter_list|,
name|u32
name|rx_hash_low
parameter_list|)
block|{
name|t3_mac_enable_exact_filters
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|mac
operator|->
name|adapter
argument_list|,
name|A_XGM_RX_CFG
argument_list|,
name|F_ENHASHMCAST
operator||
name|F_DISBCAST
operator||
name|F_COPYALLFRAMES
argument_list|,
name|rx_cfg
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|mac
operator|->
name|adapter
argument_list|,
name|A_XGM_RX_HASH_HIGH
argument_list|,
name|rx_hash_high
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|mac
operator|->
name|adapter
argument_list|,
name|A_XGM_RX_HASH_LOW
argument_list|,
name|rx_hash_low
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_detect_link_fault
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port_id
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|adapter
argument_list|,
name|port_id
argument_list|)
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|pi
operator|->
name|mac
decl_stmt|;
name|uint32_t
name|rx_cfg
decl_stmt|,
name|rx_hash_high
decl_stmt|,
name|rx_hash_low
decl_stmt|;
name|int
name|link_fault
decl_stmt|;
comment|/* stop rx */
name|t3_gate_rx_traffic
argument_list|(
name|mac
argument_list|,
operator|&
name|rx_cfg
argument_list|,
operator|&
name|rx_hash_high
argument_list|,
operator|&
name|rx_hash_low
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear status and make sure intr is enabled */
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_INT_STATUS
operator|+
name|mac
operator|->
name|offset
argument_list|)
expr_stmt|;
name|t3_xgm_intr_enable
argument_list|(
name|adapter
argument_list|,
name|port_id
argument_list|)
expr_stmt|;
comment|/* restart rx */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_RXEN
argument_list|)
expr_stmt|;
name|t3_open_rx_traffic
argument_list|(
name|mac
argument_list|,
name|rx_cfg
argument_list|,
name|rx_hash_high
argument_list|,
name|rx_hash_low
argument_list|)
expr_stmt|;
name|link_fault
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_INT_STATUS
operator|+
name|mac
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|link_fault
operator|&
name|F_LINKFAULTCHANGE
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|t3_clear_faults
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port_id
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|adapter
argument_list|,
name|port_id
argument_list|)
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|pi
operator|->
name|mac
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|nports
operator|<=
literal|2
condition|)
block|{
name|t3_xgm_intr_disable
argument_list|(
name|adapter
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_INT_STATUS
operator|+
name|mac
operator|->
name|offset
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_INT_CAUSE
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_XGM_INT
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_INT_ENABLE
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_XGM_INT
argument_list|,
name|F_XGM_INT
argument_list|)
expr_stmt|;
name|t3_xgm_intr_enable
argument_list|(
name|adapter
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_link_changed - handle interface link changes  *	@adapter: the adapter  *	@port_id: the port index that changed link state  *  *	Called when a port's link settings change to propagate the new values  *	to the associated PHY and MAC.  After performing the common tasks it  *	invokes an OS-specific handler.  */
end_comment

begin_function
name|void
name|t3_link_changed
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port_id
parameter_list|)
block|{
name|int
name|link_ok
decl_stmt|,
name|speed
decl_stmt|,
name|duplex
decl_stmt|,
name|fc
decl_stmt|,
name|link_fault
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|adapter
argument_list|,
name|port_id
argument_list|)
decl_stmt|;
name|struct
name|cphy
modifier|*
name|phy
init|=
operator|&
name|pi
operator|->
name|phy
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|pi
operator|->
name|mac
decl_stmt|;
name|struct
name|link_config
modifier|*
name|lc
init|=
operator|&
name|pi
operator|->
name|link_config
decl_stmt|;
name|link_ok
operator|=
name|lc
operator|->
name|link_ok
expr_stmt|;
name|speed
operator|=
name|lc
operator|->
name|speed
expr_stmt|;
name|duplex
operator|=
name|lc
operator|->
name|duplex
expr_stmt|;
name|fc
operator|=
name|lc
operator|->
name|fc
expr_stmt|;
name|link_fault
operator|=
literal|0
expr_stmt|;
name|phy
operator|->
name|ops
operator|->
name|get_link_status
argument_list|(
name|phy
argument_list|,
operator|&
name|link_ok
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|,
operator|&
name|fc
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|requested_fc
operator|&
name|PAUSE_AUTONEG
condition|)
name|fc
operator|&=
name|lc
operator|->
name|requested_fc
expr_stmt|;
else|else
name|fc
operator|=
name|lc
operator|->
name|requested_fc
operator|&
operator|(
name|PAUSE_RX
operator||
name|PAUSE_TX
operator|)
expr_stmt|;
comment|/* Update mac speed before checking for link fault. */
if|if
condition|(
name|link_ok
operator|&&
name|speed
operator|>=
literal|0
operator|&&
name|lc
operator|->
name|autoneg
operator|==
name|AUTONEG_ENABLE
operator|&&
operator|(
name|speed
operator|!=
name|lc
operator|->
name|speed
operator|||
name|duplex
operator|!=
name|lc
operator|->
name|duplex
operator|||
name|fc
operator|!=
name|lc
operator|->
name|fc
operator|)
condition|)
name|t3_mac_set_speed_duplex_fc
argument_list|(
name|mac
argument_list|,
name|speed
argument_list|,
name|duplex
argument_list|,
name|fc
argument_list|)
expr_stmt|;
comment|/* 	 * Check for link faults if any of these is true: 	 * a) A link fault is suspected, and PHY says link ok 	 * b) PHY link transitioned from down -> up 	 */
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|nports
operator|<=
literal|2
operator|&&
operator|(
operator|(
name|pi
operator|->
name|link_fault
operator|&&
name|link_ok
operator|)
operator|||
operator|(
operator|!
name|lc
operator|->
name|link_ok
operator|&&
name|link_ok
operator|)
operator|)
condition|)
block|{
name|link_fault
operator|=
name|t3_detect_link_fault
argument_list|(
name|adapter
argument_list|,
name|port_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_fault
condition|)
block|{
if|if
condition|(
name|pi
operator|->
name|link_fault
operator|!=
name|LF_YES
condition|)
block|{
name|mac
operator|->
name|stats
operator|.
name|link_faults
operator|++
expr_stmt|;
name|pi
operator|->
name|link_fault
operator|=
name|LF_YES
expr_stmt|;
block|}
comment|/* Don't report link up */
name|link_ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* clear faults here if this was a false alarm. */
if|if
condition|(
name|pi
operator|->
name|link_fault
operator|==
name|LF_MAYBE
operator|&&
name|link_ok
operator|&&
name|lc
operator|->
name|link_ok
condition|)
name|t3_clear_faults
argument_list|(
name|adapter
argument_list|,
name|port_id
argument_list|)
expr_stmt|;
name|pi
operator|->
name|link_fault
operator|=
name|LF_NO
expr_stmt|;
block|}
block|}
if|if
condition|(
name|link_ok
operator|==
name|lc
operator|->
name|link_ok
operator|&&
name|speed
operator|==
name|lc
operator|->
name|speed
operator|&&
name|duplex
operator|==
name|lc
operator|->
name|duplex
operator|&&
name|fc
operator|==
name|lc
operator|->
name|fc
condition|)
return|return;
comment|/* nothing changed */
name|lc
operator|->
name|link_ok
operator|=
operator|(
name|unsigned
name|char
operator|)
name|link_ok
expr_stmt|;
name|lc
operator|->
name|speed
operator|=
name|speed
operator|<
literal|0
condition|?
name|SPEED_INVALID
else|:
name|speed
expr_stmt|;
name|lc
operator|->
name|duplex
operator|=
name|duplex
operator|<
literal|0
condition|?
name|DUPLEX_INVALID
else|:
name|duplex
expr_stmt|;
name|lc
operator|->
name|fc
operator|=
name|fc
expr_stmt|;
if|if
condition|(
name|link_ok
condition|)
block|{
comment|/* down -> up, or up -> up with changed settings */
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
operator|&&
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_XAUI_ACT_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_TXACTENABLE
operator||
name|F_RXEN
argument_list|)
expr_stmt|;
block|}
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_TXFIFO_CFG
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_ENDROPPKT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_mac_enable
argument_list|(
name|mac
argument_list|,
name|MAC_DIRECTION_TX
operator||
name|MAC_DIRECTION_RX
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_STAT_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_CLRSTATS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t3_clear_faults
argument_list|(
name|adapter
argument_list|,
name|port_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* up -> down */
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
operator|&&
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_XAUI_ACT_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|t3_xgm_intr_disable
argument_list|(
name|adapter
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|nports
operator|<=
literal|2
condition|)
block|{
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_INT_ENABLE
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_XGM_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|link_fault
condition|)
block|{
if|if
condition|(
name|is_10G
argument_list|(
name|adapter
argument_list|)
condition|)
name|pi
operator|->
name|phy
operator|.
name|ops
operator|->
name|power_down
argument_list|(
operator|&
name|pi
operator|->
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t3_mac_disable
argument_list|(
name|mac
argument_list|,
name|MAC_DIRECTION_RX
argument_list|)
expr_stmt|;
name|t3_link_start
argument_list|(
name|phy
argument_list|,
name|mac
argument_list|,
name|lc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Make sure Tx FIFO continues to drain, even as rxen is left 		 * high to help detect and indicate remote faults. 		 */
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_TXFIFO_CFG
operator|+
name|mac
operator|->
name|offset
argument_list|,
literal|0
argument_list|,
name|F_ENDROPPKT
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_TX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_TXEN
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RX_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_RXEN
argument_list|)
expr_stmt|;
block|}
name|t3_os_link_changed
argument_list|(
name|adapter
argument_list|,
name|port_id
argument_list|,
name|link_ok
argument_list|,
name|speed
argument_list|,
name|duplex
argument_list|,
name|fc
argument_list|,
name|mac
operator|->
name|was_reset
argument_list|)
expr_stmt|;
name|mac
operator|->
name|was_reset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_link_start - apply link configuration to MAC/PHY  *	@phy: the PHY to setup  *	@mac: the MAC to setup  *	@lc: the requested link configuration  *  *	Set up a port's MAC and PHY according to a desired link configuration.  *	- If the PHY can auto-negotiate first decide what to advertise, then  *	  enable/disable auto-negotiation as desired, and reset.  *	- If the PHY does not auto-negotiate just reset it.  *	- If auto-negotiation is off set the MAC to the proper speed/duplex/FC,  *	  otherwise do it later based on the outcome of auto-negotiation.  */
end_comment

begin_function
name|int
name|t3_link_start
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|,
name|struct
name|cmac
modifier|*
name|mac
parameter_list|,
name|struct
name|link_config
modifier|*
name|lc
parameter_list|)
block|{
name|unsigned
name|int
name|fc
init|=
name|lc
operator|->
name|requested_fc
operator|&
operator|(
name|PAUSE_RX
operator||
name|PAUSE_TX
operator|)
decl_stmt|;
name|lc
operator|->
name|link_ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|supported
operator|&
name|SUPPORTED_Autoneg
condition|)
block|{
name|lc
operator|->
name|advertising
operator|&=
operator|~
operator|(
name|ADVERTISED_Asym_Pause
operator||
name|ADVERTISED_Pause
operator|)
expr_stmt|;
if|if
condition|(
name|fc
condition|)
block|{
name|lc
operator|->
name|advertising
operator||=
name|ADVERTISED_Asym_Pause
expr_stmt|;
if|if
condition|(
name|fc
operator|&
name|PAUSE_RX
condition|)
name|lc
operator|->
name|advertising
operator||=
name|ADVERTISED_Pause
expr_stmt|;
block|}
name|phy
operator|->
name|ops
operator|->
name|advertise
argument_list|(
name|phy
argument_list|,
name|lc
operator|->
name|advertising
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|autoneg
operator|==
name|AUTONEG_DISABLE
condition|)
block|{
name|lc
operator|->
name|speed
operator|=
name|lc
operator|->
name|requested_speed
expr_stmt|;
name|lc
operator|->
name|duplex
operator|=
name|lc
operator|->
name|requested_duplex
expr_stmt|;
name|lc
operator|->
name|fc
operator|=
operator|(
name|unsigned
name|char
operator|)
name|fc
expr_stmt|;
name|t3_mac_set_speed_duplex_fc
argument_list|(
name|mac
argument_list|,
name|lc
operator|->
name|speed
argument_list|,
name|lc
operator|->
name|duplex
argument_list|,
name|fc
argument_list|)
expr_stmt|;
comment|/* Also disables autoneg */
name|phy
operator|->
name|ops
operator|->
name|set_speed_duplex
argument_list|(
name|phy
argument_list|,
name|lc
operator|->
name|speed
argument_list|,
name|lc
operator|->
name|duplex
argument_list|)
expr_stmt|;
comment|/* PR 5666. Power phy up when doing an ifup */
if|if
condition|(
operator|!
name|is_10G
argument_list|(
name|phy
operator|->
name|adapter
argument_list|)
condition|)
name|phy
operator|->
name|ops
operator|->
name|power_down
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|phy
operator|->
name|ops
operator|->
name|autoneg_enable
argument_list|(
name|phy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t3_mac_set_speed_duplex_fc
argument_list|(
name|mac
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|fc
argument_list|)
expr_stmt|;
name|lc
operator|->
name|fc
operator|=
operator|(
name|unsigned
name|char
operator|)
name|fc
expr_stmt|;
name|phy
operator|->
name|ops
operator|->
name|reset
argument_list|(
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_set_vlan_accel - control HW VLAN extraction  *	@adapter: the adapter  *	@ports: bitmap of adapter ports to operate on  *	@on: enable (1) or disable (0) HW VLAN extraction  *  *	Enables or disables HW extraction of VLAN tags for the given port.  */
end_comment

begin_function
name|void
name|t3_set_vlan_accel
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|ports
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_TP_OUT_CONFIG
argument_list|,
name|ports
operator|<<
name|S_VLANEXTRACTIONENABLE
argument_list|,
name|on
condition|?
operator|(
name|ports
operator|<<
name|S_VLANEXTRACTIONENABLE
operator|)
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|intr_info
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
comment|/* bits to check in interrupt status */
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* message to print or NULL */
name|short
name|stat_idx
decl_stmt|;
comment|/* stat counter to increment or -1 */
name|unsigned
name|short
name|fatal
decl_stmt|;
comment|/* whether the condition reported is fatal */
block|}
struct|;
end_struct

begin_comment
comment|/**  *	t3_handle_intr_status - table driven interrupt handler  *	@adapter: the adapter that generated the interrupt  *	@reg: the interrupt status register to process  *	@mask: a mask to apply to the interrupt status  *	@acts: table of interrupt actions  *	@stats: statistics counters tracking interrupt occurences  *  *	A table driven interrupt handler that applies a set of masks to an  *	interrupt status word and performs the corresponding actions if the  *	interrupts described by the mask have occured.  The actions include  *	optionally printing a warning or alert message, and optionally  *	incrementing a stat counter.  The table is terminated by an entry  *	specifying mask 0.  Returns the number of fatal interrupt conditions.  */
end_comment

begin_function
specifier|static
name|int
name|t3_handle_intr_status
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|,
name|unsigned
name|int
name|mask
parameter_list|,
specifier|const
name|struct
name|intr_info
modifier|*
name|acts
parameter_list|,
name|unsigned
name|long
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|fatal
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|status
init|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|reg
argument_list|)
operator|&
name|mask
decl_stmt|;
for|for
control|(
init|;
name|acts
operator|->
name|mask
condition|;
operator|++
name|acts
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|acts
operator|->
name|mask
operator|)
condition|)
continue|continue;
if|if
condition|(
name|acts
operator|->
name|fatal
condition|)
block|{
name|fatal
operator|++
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"%s (0x%x)\n"
argument_list|,
name|acts
operator|->
name|msg
argument_list|,
name|status
operator|&
name|acts
operator|->
name|mask
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s (0x%x)\n"
argument_list|,
name|acts
operator|->
name|msg
argument_list|,
name|status
operator|&
name|acts
operator|->
name|mask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|acts
operator|->
name|msg
condition|)
name|CH_WARN
argument_list|(
name|adapter
argument_list|,
literal|"%s (0x%x)\n"
argument_list|,
name|acts
operator|->
name|msg
argument_list|,
name|status
operator|&
name|acts
operator|->
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|acts
operator|->
name|stat_idx
operator|>=
literal|0
condition|)
name|stats
index|[
name|acts
operator|->
name|stat_idx
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
comment|/* clear processed interrupts */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|reg
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|fatal
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SGE_INTR_MASK
value|(F_RSPQDISABLED | \ 		       F_UC_REQ_FRAMINGERROR | F_R_REQ_FRAMINGERROR | \ 		       F_CPPARITYERROR | F_OCPARITYERROR | F_RCPARITYERROR | \ 		       F_IRPARITYERROR | V_ITPARITYERROR(M_ITPARITYERROR) | \ 		       V_FLPARITYERROR(M_FLPARITYERROR) | F_LODRBPARITYERROR | \ 		       F_HIDRBPARITYERROR | F_LORCQPARITYERROR | \ 		       F_HIRCQPARITYERROR)
end_define

begin_define
define|#
directive|define
name|MC5_INTR_MASK
value|(F_PARITYERR | F_ACTRGNFULL | F_UNKNOWNCMD | \ 		       F_REQQPARERR | F_DISPQPARERR | F_DELACTEMPTY | \ 		       F_NFASRCHFAIL)
end_define

begin_define
define|#
directive|define
name|MC7_INTR_MASK
value|(F_AE | F_UE | F_CE | V_PE(M_PE))
end_define

begin_define
define|#
directive|define
name|XGM_INTR_MASK
value|(V_TXFIFO_PRTY_ERR(M_TXFIFO_PRTY_ERR) | \ 		       V_RXFIFO_PRTY_ERR(M_RXFIFO_PRTY_ERR) | \ 		       F_TXFIFO_UNDERRUN)
end_define

begin_define
define|#
directive|define
name|PCIX_INTR_MASK
value|(F_MSTDETPARERR | F_SIGTARABT | F_RCVTARABT | \ 			F_RCVMSTABT | F_SIGSYSERR | F_DETPARERR | \ 			F_SPLCMPDIS | F_UNXSPLCMP | F_RCVSPLCMPERR | \ 			F_DETCORECCERR | F_DETUNCECCERR | F_PIOPARERR | \ 			V_WFPARERR(M_WFPARERR) | V_RFPARERR(M_RFPARERR) | \ 			V_CFPARERR(M_CFPARERR)
comment|/* | V_MSIXPARERR(M_MSIXPARERR) */
value|)
end_define

begin_define
define|#
directive|define
name|PCIE_INTR_MASK
value|(F_UNXSPLCPLERRR | F_UNXSPLCPLERRC | F_PCIE_PIOPARERR |\ 			F_PCIE_WFPARERR | F_PCIE_RFPARERR | F_PCIE_CFPARERR | \
comment|/* V_PCIE_MSIXPARERR(M_PCIE_MSIXPARERR) | */
value|\ 			F_RETRYBUFPARERR | F_RETRYLUTPARERR | F_RXPARERR | \ 			F_TXPARERR | V_BISTERR(M_BISTERR))
end_define

begin_define
define|#
directive|define
name|ULPRX_INTR_MASK
value|(F_PARERRDATA | F_PARERRPCMD | F_ARBPF1PERR | \ 			 F_ARBPF0PERR | F_ARBFPERR | F_PCMDMUXPERR | \ 			 F_DATASELFRAMEERR1 | F_DATASELFRAMEERR0)
end_define

begin_define
define|#
directive|define
name|ULPTX_INTR_MASK
value|0xfc
end_define

begin_define
define|#
directive|define
name|CPLSW_INTR_MASK
value|(F_CIM_OP_MAP_PERR | F_TP_FRAMING_ERROR | \ 			 F_SGE_FRAMING_ERROR | F_CIM_FRAMING_ERROR | \ 			 F_ZERO_SWITCH_ERROR)
end_define

begin_define
define|#
directive|define
name|CIM_INTR_MASK
value|(F_BLKWRPLINT | F_BLKRDPLINT | F_BLKWRCTLINT | \ 		       F_BLKRDCTLINT | F_BLKWRFLASHINT | F_BLKRDFLASHINT | \ 		       F_SGLWRFLASHINT | F_WRBLKFLASHINT | F_BLKWRBOOTINT | \ 	 	       F_FLASHRANGEINT | F_SDRAMRANGEINT | F_RSVDSPACEINT | \ 		       F_DRAMPARERR | F_ICACHEPARERR | F_DCACHEPARERR | \ 		       F_OBQSGEPARERR | F_OBQULPHIPARERR | F_OBQULPLOPARERR | \ 		       F_IBQSGELOPARERR | F_IBQSGEHIPARERR | F_IBQULPPARERR | \ 		       F_IBQTPPARERR | F_ITAGPARERR | F_DTAGPARERR)
end_define

begin_define
define|#
directive|define
name|PMTX_INTR_MASK
value|(F_ZERO_C_CMD_ERROR | ICSPI_FRM_ERR | OESPI_FRM_ERR | \ 			V_ICSPI_PAR_ERROR(M_ICSPI_PAR_ERROR) | \ 			V_OESPI_PAR_ERROR(M_OESPI_PAR_ERROR))
end_define

begin_define
define|#
directive|define
name|PMRX_INTR_MASK
value|(F_ZERO_E_CMD_ERROR | IESPI_FRM_ERR | OCSPI_FRM_ERR | \ 			V_IESPI_PAR_ERROR(M_IESPI_PAR_ERROR) | \ 			V_OCSPI_PAR_ERROR(M_OCSPI_PAR_ERROR))
end_define

begin_define
define|#
directive|define
name|MPS_INTR_MASK
value|(V_TX0TPPARERRENB(M_TX0TPPARERRENB) | \ 		       V_TX1TPPARERRENB(M_TX1TPPARERRENB) | \ 		       V_RXTPPARERRENB(M_RXTPPARERRENB) | \ 		       V_MCAPARERRENB(M_MCAPARERRENB))
end_define

begin_define
define|#
directive|define
name|XGM_EXTRA_INTR_MASK
value|(F_LINKFAULTCHANGE)
end_define

begin_define
define|#
directive|define
name|PL_INTR_MASK
value|(F_T3DBG | F_XGMAC0_0 | F_XGMAC0_1 | F_MC5A | F_PM1_TX | \ 		      F_PM1_RX | F_ULP2_TX | F_ULP2_RX | F_TP1 | F_CIM | \ 		      F_MC7_CM | F_MC7_PMTX | F_MC7_PMRX | F_SGE3 | F_PCIM0 | \ 		      F_MPS0 | F_CPL_SWITCH)
end_define

begin_comment
comment|/*  * Interrupt handler for the PCIX1 module.  */
end_comment

begin_function
specifier|static
name|void
name|pci_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|pcix1_intr_info
index|[]
init|=
block|{
block|{
name|F_MSTDETPARERR
block|,
literal|"PCI master detected parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SIGTARABT
block|,
literal|"PCI signaled target abort"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RCVTARABT
block|,
literal|"PCI received target abort"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RCVMSTABT
block|,
literal|"PCI received master abort"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SIGSYSERR
block|,
literal|"PCI signaled system error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DETPARERR
block|,
literal|"PCI detected parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SPLCMPDIS
block|,
literal|"PCI split completion discarded"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_UNXSPLCMP
block|,
literal|"PCI unexpected split completion error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RCVSPLCMPERR
block|,
literal|"PCI received split completion error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DETCORECCERR
block|,
literal|"PCI correctable ECC error"
block|,
name|STAT_PCI_CORR_ECC
block|,
literal|0
block|}
block|,
block|{
name|F_DETUNCECCERR
block|,
literal|"PCI uncorrectable ECC error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PIOPARERR
block|,
literal|"PCI PIO FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_WFPARERR
argument_list|(
name|M_WFPARERR
argument_list|)
block|,
literal|"PCI write FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_RFPARERR
argument_list|(
name|M_RFPARERR
argument_list|)
block|,
literal|"PCI read FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_CFPARERR
argument_list|(
name|M_CFPARERR
argument_list|)
block|,
literal|"PCI command FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_MSIXPARERR
argument_list|(
name|M_MSIXPARERR
argument_list|)
block|,
literal|"PCI MSI-X table/PBA parity "
literal|"error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PCIX_INT_CAUSE
argument_list|,
name|PCIX_INTR_MASK
argument_list|,
name|pcix1_intr_info
argument_list|,
name|adapter
operator|->
name|irq_stats
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler for the PCIE module.  */
end_comment

begin_function
specifier|static
name|void
name|pcie_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|pcie_intr_info
index|[]
init|=
block|{
block|{
name|F_PEXERR
block|,
literal|"PCI PEX error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_UNXSPLCPLERRR
block|,
literal|"PCI unexpected split completion DMA read error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_UNXSPLCPLERRC
block|,
literal|"PCI unexpected split completion DMA command error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCIE_PIOPARERR
block|,
literal|"PCI PIO FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCIE_WFPARERR
block|,
literal|"PCI write FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCIE_RFPARERR
block|,
literal|"PCI read FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCIE_CFPARERR
block|,
literal|"PCI command FIFO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_PCIE_MSIXPARERR
argument_list|(
name|M_PCIE_MSIXPARERR
argument_list|)
block|,
literal|"PCI MSI-X table/PBA parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RETRYBUFPARERR
block|,
literal|"PCI retry buffer parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RETRYLUTPARERR
block|,
literal|"PCI retry LUT parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_RXPARERR
block|,
literal|"PCI Rx parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TXPARERR
block|,
literal|"PCI Tx parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_BISTERR
argument_list|(
name|M_BISTERR
argument_list|)
block|,
literal|"PCI BIST error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_INT_CAUSE
argument_list|)
operator|&
name|F_PEXERR
condition|)
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"PEX error code 0x%x\n"
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_PEX_ERR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_INT_CAUSE
argument_list|,
name|PCIE_INTR_MASK
argument_list|,
name|pcie_intr_info
argument_list|,
name|adapter
operator|->
name|irq_stats
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TP interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|tp_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|tp_intr_info
index|[]
init|=
block|{
block|{
literal|0xffffff
block|,
literal|"TP parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0x1000000
block|,
literal|"TP out of Rx pages"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0x2000000
block|,
literal|"TP out of Tx pages"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|intr_info
name|tp_intr_info_t3c
index|[]
init|=
block|{
block|{
literal|0x1fffffff
block|,
literal|"TP parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_FLMRXFLSTEMPTY
block|,
literal|"TP out of Rx pages"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_FLMTXFLSTEMPTY
block|,
literal|"TP out of Tx pages"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_TP_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|rev
operator|<
name|T3_REV_C
condition|?
name|tp_intr_info
else|:
name|tp_intr_info_t3c
argument_list|,
name|NULL
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CIM interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|cim_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|cim_intr_info
index|[]
init|=
block|{
block|{
name|F_RSVDSPACEINT
block|,
literal|"CIM reserved space write"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SDRAMRANGEINT
block|,
literal|"CIM SDRAM address out of range"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_FLASHRANGEINT
block|,
literal|"CIM flash address out of range"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRBOOTINT
block|,
literal|"CIM block write to boot space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_WRBLKFLASHINT
block|,
literal|"CIM write to cached flash space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGLWRFLASHINT
block|,
literal|"CIM single write to flash space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKRDFLASHINT
block|,
literal|"CIM block read from flash space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRFLASHINT
block|,
literal|"CIM block write to flash space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKRDCTLINT
block|,
literal|"CIM block read from CTL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRCTLINT
block|,
literal|"CIM block write to CTL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKRDPLINT
block|,
literal|"CIM block read from PL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_BLKWRPLINT
block|,
literal|"CIM block write to PL space"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DRAMPARERR
block|,
literal|"CIM DRAM parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ICACHEPARERR
block|,
literal|"CIM icache parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DCACHEPARERR
block|,
literal|"CIM dcache parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_OBQSGEPARERR
block|,
literal|"CIM OBQ SGE parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_OBQULPHIPARERR
block|,
literal|"CIM OBQ ULPHI parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_OBQULPLOPARERR
block|,
literal|"CIM OBQ ULPLO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_IBQSGELOPARERR
block|,
literal|"CIM IBQ SGELO parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_IBQSGEHIPARERR
block|,
literal|"CIM IBQ SGEHI parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_IBQULPPARERR
block|,
literal|"CIM IBQ ULP parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_IBQTPPARERR
block|,
literal|"CIM IBQ TP parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ITAGPARERR
block|,
literal|"CIM itag parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DTAGPARERR
block|,
literal|"CIM dtag parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_INT_CAUSE
argument_list|,
name|CIM_INTR_MASK
argument_list|,
name|cim_intr_info
argument_list|,
name|NULL
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ULP RX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ulprx_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|ulprx_intr_info
index|[]
init|=
block|{
block|{
name|F_PARERRDATA
block|,
literal|"ULP RX data parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PARERRPCMD
block|,
literal|"ULP RX command parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ARBPF1PERR
block|,
literal|"ULP RX ArbPF1 parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ARBPF0PERR
block|,
literal|"ULP RX ArbPF0 parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ARBFPERR
block|,
literal|"ULP RX ArbF parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_PCMDMUXPERR
block|,
literal|"ULP RX PCMDMUX parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DATASELFRAMEERR1
block|,
literal|"ULP RX frame error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_DATASELFRAMEERR0
block|,
literal|"ULP RX frame error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_ULPRX_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|ulprx_intr_info
argument_list|,
name|NULL
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ULP TX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ulptx_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|ulptx_intr_info
index|[]
init|=
block|{
block|{
name|F_PBL_BOUND_ERR_CH0
block|,
literal|"ULP TX channel 0 PBL out of bounds"
block|,
name|STAT_ULP_CH0_PBL_OOB
block|,
literal|0
block|}
block|,
block|{
name|F_PBL_BOUND_ERR_CH1
block|,
literal|"ULP TX channel 1 PBL out of bounds"
block|,
name|STAT_ULP_CH1_PBL_OOB
block|,
literal|0
block|}
block|,
block|{
literal|0xfc
block|,
literal|"ULP TX parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|ulptx_intr_info
argument_list|,
name|adapter
operator|->
name|irq_stats
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ICSPI_FRM_ERR
value|(F_ICSPI0_FIFO2X_RX_FRAMING_ERROR | \ 	F_ICSPI1_FIFO2X_RX_FRAMING_ERROR | F_ICSPI0_RX_FRAMING_ERROR | \ 	F_ICSPI1_RX_FRAMING_ERROR | F_ICSPI0_TX_FRAMING_ERROR | \ 	F_ICSPI1_TX_FRAMING_ERROR)
end_define

begin_define
define|#
directive|define
name|OESPI_FRM_ERR
value|(F_OESPI0_RX_FRAMING_ERROR | \ 	F_OESPI1_RX_FRAMING_ERROR | F_OESPI0_TX_FRAMING_ERROR | \ 	F_OESPI1_TX_FRAMING_ERROR | F_OESPI0_OFIFO2X_TX_FRAMING_ERROR | \ 	F_OESPI1_OFIFO2X_TX_FRAMING_ERROR)
end_define

begin_comment
comment|/*  * PM TX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|pmtx_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|pmtx_intr_info
index|[]
init|=
block|{
block|{
name|F_ZERO_C_CMD_ERROR
block|,
literal|"PMTX 0-length pcmd"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|ICSPI_FRM_ERR
block|,
literal|"PMTX ispi framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|OESPI_FRM_ERR
block|,
literal|"PMTX ospi framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_ICSPI_PAR_ERROR
argument_list|(
name|M_ICSPI_PAR_ERROR
argument_list|)
block|,
literal|"PMTX ispi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_OESPI_PAR_ERROR
argument_list|(
name|M_OESPI_PAR_ERROR
argument_list|)
block|,
literal|"PMTX ospi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PM1_TX_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|pmtx_intr_info
argument_list|,
name|NULL
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IESPI_FRM_ERR
value|(F_IESPI0_FIFO2X_RX_FRAMING_ERROR | \ 	F_IESPI1_FIFO2X_RX_FRAMING_ERROR | F_IESPI0_RX_FRAMING_ERROR | \ 	F_IESPI1_RX_FRAMING_ERROR | F_IESPI0_TX_FRAMING_ERROR | \ 	F_IESPI1_TX_FRAMING_ERROR)
end_define

begin_define
define|#
directive|define
name|OCSPI_FRM_ERR
value|(F_OCSPI0_RX_FRAMING_ERROR | \ 	F_OCSPI1_RX_FRAMING_ERROR | F_OCSPI0_TX_FRAMING_ERROR | \ 	F_OCSPI1_TX_FRAMING_ERROR | F_OCSPI0_OFIFO2X_TX_FRAMING_ERROR | \ 	F_OCSPI1_OFIFO2X_TX_FRAMING_ERROR)
end_define

begin_comment
comment|/*  * PM RX interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|pmrx_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|pmrx_intr_info
index|[]
init|=
block|{
block|{
name|F_ZERO_E_CMD_ERROR
block|,
literal|"PMRX 0-length pcmd"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|IESPI_FRM_ERR
block|,
literal|"PMRX ispi framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|OCSPI_FRM_ERR
block|,
literal|"PMRX ospi framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_IESPI_PAR_ERROR
argument_list|(
name|M_IESPI_PAR_ERROR
argument_list|)
block|,
literal|"PMRX ispi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|V_OCSPI_PAR_ERROR
argument_list|(
name|M_OCSPI_PAR_ERROR
argument_list|)
block|,
literal|"PMRX ospi parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_PM1_RX_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|pmrx_intr_info
argument_list|,
name|NULL
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CPL switch interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|cplsw_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|cplsw_intr_info
index|[]
init|=
block|{
block|{
name|F_CIM_OP_MAP_PERR
block|,
literal|"CPL switch CIM parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CIM_OVFL_ERROR
block|,
literal|"CPL switch CIM overflow"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_TP_FRAMING_ERROR
block|,
literal|"CPL switch TP framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_SGE_FRAMING_ERROR
block|,
literal|"CPL switch SGE framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_CIM_FRAMING_ERROR
block|,
literal|"CPL switch CIM framing error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
name|F_ZERO_SWITCH_ERROR
block|,
literal|"CPL switch no-switch error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_CPL_INTR_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|cplsw_intr_info
argument_list|,
name|NULL
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MPS interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|mps_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|intr_info
name|mps_intr_info
index|[]
init|=
block|{
block|{
literal|0x1ff
block|,
literal|"MPS parity error"
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|t3_handle_intr_status
argument_list|(
name|adapter
argument_list|,
name|A_MPS_INT_CAUSE
argument_list|,
literal|0xffffffff
argument_list|,
name|mps_intr_info
argument_list|,
name|NULL
argument_list|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MC7_INTR_FATAL
value|(F_UE | V_PE(M_PE) | F_AE)
end_define

begin_comment
comment|/*  * MC7 interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|mc7_intr_handler
parameter_list|(
name|struct
name|mc7
modifier|*
name|mc7
parameter_list|)
block|{
name|adapter_t
modifier|*
name|adapter
init|=
name|mc7
operator|->
name|adapter
decl_stmt|;
name|u32
name|cause
init|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_INT_CAUSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_CE
condition|)
block|{
name|mc7
operator|->
name|stats
operator|.
name|corr_err
operator|++
expr_stmt|;
name|CH_WARN
argument_list|(
name|adapter
argument_list|,
literal|"%s MC7 correctable error at addr 0x%x, "
literal|"data 0x%x 0x%x 0x%x\n"
argument_list|,
name|mc7
operator|->
name|name
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CE_ADDR
argument_list|)
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CE_DATA0
argument_list|)
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CE_DATA1
argument_list|)
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CE_DATA2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|F_UE
condition|)
block|{
name|mc7
operator|->
name|stats
operator|.
name|uncorr_err
operator|++
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"%s MC7 uncorrectable error at addr 0x%x, "
literal|"data 0x%x 0x%x 0x%x\n"
argument_list|,
name|mc7
operator|->
name|name
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_UE_ADDR
argument_list|)
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_UE_DATA0
argument_list|)
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_UE_DATA1
argument_list|)
argument_list|,
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_UE_DATA2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|G_PE
argument_list|(
name|cause
argument_list|)
condition|)
block|{
name|mc7
operator|->
name|stats
operator|.
name|parity_err
operator|++
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"%s MC7 parity error 0x%x\n"
argument_list|,
name|mc7
operator|->
name|name
argument_list|,
name|G_PE
argument_list|(
name|cause
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|F_AE
condition|)
block|{
name|u32
name|addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
name|addr
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_ERR_ADDR
argument_list|)
expr_stmt|;
name|mc7
operator|->
name|stats
operator|.
name|addr_err
operator|++
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"%s MC7 address error: 0x%x\n"
argument_list|,
name|mc7
operator|->
name|name
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|MC7_INTR_FATAL
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_INT_CAUSE
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|XGM_INTR_FATAL
value|(V_TXFIFO_PRTY_ERR(M_TXFIFO_PRTY_ERR) | \ 			V_RXFIFO_PRTY_ERR(M_RXFIFO_PRTY_ERR))
end_define

begin_comment
comment|/*  * XGMAC interrupt handler.  */
end_comment

begin_function
specifier|static
name|int
name|mac_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
name|u32
name|cause
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
decl_stmt|;
name|idx
operator|=
name|idx
operator|==
literal|0
condition|?
literal|0
else|:
name|adapter_info
argument_list|(
name|adap
argument_list|)
operator|->
name|nports0
expr_stmt|;
comment|/* MAC idx -> port */
name|pi
operator|=
name|adap2pinfo
argument_list|(
name|adap
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mac
operator|=
operator|&
name|pi
operator|->
name|mac
expr_stmt|;
comment|/* 	 * We mask out interrupt causes for which we're not taking interrupts. 	 * This allows us to use polling logic to monitor some of the other 	 * conditions when taking interrupts would impose too much load on the 	 * system. 	 */
name|cause
operator|=
operator|(
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_XGM_INT_CAUSE
operator|+
name|mac
operator|->
name|offset
argument_list|)
operator|&
operator|~
operator|(
name|F_RXFIFO_OVERFLOW
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|V_TXFIFO_PRTY_ERR
argument_list|(
name|M_TXFIFO_PRTY_ERR
argument_list|)
condition|)
block|{
name|mac
operator|->
name|stats
operator|.
name|tx_fifo_parity_err
operator|++
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adap
argument_list|,
literal|"port%d: MAC TX FIFO parity error\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|V_RXFIFO_PRTY_ERR
argument_list|(
name|M_RXFIFO_PRTY_ERR
argument_list|)
condition|)
block|{
name|mac
operator|->
name|stats
operator|.
name|rx_fifo_parity_err
operator|++
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adap
argument_list|,
literal|"port%d: MAC RX FIFO parity error\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|F_TXFIFO_UNDERRUN
condition|)
name|mac
operator|->
name|stats
operator|.
name|tx_fifo_urun
operator|++
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_RXFIFO_OVERFLOW
condition|)
name|mac
operator|->
name|stats
operator|.
name|rx_fifo_ovfl
operator|++
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|V_SERDES_LOS
argument_list|(
name|M_SERDES_LOS
argument_list|)
condition|)
name|mac
operator|->
name|stats
operator|.
name|serdes_signal_loss
operator|++
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_XAUIPCSCTCERR
condition|)
name|mac
operator|->
name|stats
operator|.
name|xaui_pcs_ctc_err
operator|++
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_XAUIPCSALIGNCHANGE
condition|)
name|mac
operator|->
name|stats
operator|.
name|xaui_pcs_align_change
operator|++
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_XGM_INT
condition|)
block|{
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_XGM_INT_ENABLE
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_XGM_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* link fault suspected */
name|pi
operator|->
name|link_fault
operator|=
name|LF_MAYBE
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_XGM_INT_CAUSE
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|cause
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|XGM_INTR_FATAL
condition|)
name|t3_fatal_err
argument_list|(
name|adap
argument_list|)
expr_stmt|;
return|return
name|cause
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler for PHY events.  */
end_comment

begin_function
name|int
name|t3_phy_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|cause
init|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_T3DBG_INT_CAUSE
argument_list|)
decl_stmt|;
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
name|adap2pinfo
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|phy
operator|.
name|caps
operator|&
name|SUPPORTED_IRQ
operator|)
condition|)
continue|continue;
if|if
condition|(
name|cause
operator|&
operator|(
literal|1
operator|<<
name|adapter_info
argument_list|(
name|adapter
argument_list|)
operator|->
name|gpio_intr
index|[
name|i
index|]
operator|)
condition|)
block|{
name|int
name|phy_cause
init|=
name|p
operator|->
name|phy
operator|.
name|ops
operator|->
name|intr_handler
argument_list|(
operator|&
name|p
operator|->
name|phy
argument_list|)
decl_stmt|;
if|if
condition|(
name|phy_cause
operator|&
name|cphy_cause_link_change
condition|)
name|t3_link_changed
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_cause
operator|&
name|cphy_cause_fifo_error
condition|)
name|p
operator|->
name|phy
operator|.
name|fifo_errors
operator|++
expr_stmt|;
if|if
condition|(
name|phy_cause
operator|&
name|cphy_cause_module_change
condition|)
name|t3_os_phymod_changed
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_cause
operator|&
name|cphy_cause_alarm
condition|)
name|CH_WARN
argument_list|(
name|adapter
argument_list|,
literal|"Operation affected due to "
literal|"adverse environment.  Check the spec "
literal|"sheet for corrective action."
argument_list|)
expr_stmt|;
block|}
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_T3DBG_INT_CAUSE
argument_list|,
name|cause
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_slow_intr_handler - control path interrupt handler  *	@adapter: the adapter  *  *	T3 interrupt handler for non-data interrupt events, e.g., errors.  *	The designation 'slow' is because it involves register reads, while  *	data interrupts typically don't involve any MMIOs.  */
end_comment

begin_function
name|int
name|t3_slow_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|cause
init|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE0
argument_list|)
decl_stmt|;
name|cause
operator|&=
name|adapter
operator|->
name|slow_intr_mask
expr_stmt|;
if|if
condition|(
operator|!
name|cause
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cause
operator|&
name|F_PCIM0
condition|)
block|{
if|if
condition|(
name|is_pcie
argument_list|(
name|adapter
argument_list|)
condition|)
name|pcie_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
name|pci_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|F_SGE3
condition|)
name|t3_sge_err_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MC7_PMRX
condition|)
name|mc7_intr_handler
argument_list|(
operator|&
name|adapter
operator|->
name|pmrx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MC7_PMTX
condition|)
name|mc7_intr_handler
argument_list|(
operator|&
name|adapter
operator|->
name|pmtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MC7_CM
condition|)
name|mc7_intr_handler
argument_list|(
operator|&
name|adapter
operator|->
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_CIM
condition|)
name|cim_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_TP1
condition|)
name|tp_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_ULP2_RX
condition|)
name|ulprx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_ULP2_TX
condition|)
name|ulptx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_PM1_RX
condition|)
name|pmrx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_PM1_TX
condition|)
name|pmtx_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_CPL_SWITCH
condition|)
name|cplsw_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MPS0
condition|)
name|mps_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_MC5A
condition|)
name|t3_mc5_intr_handler
argument_list|(
operator|&
name|adapter
operator|->
name|mc5
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_XGMAC0_0
condition|)
name|mac_intr_handler
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_XGMAC0_1
condition|)
name|mac_intr_handler
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_T3DBG
condition|)
name|t3_os_ext_intr_handler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Clear the interrupts just processed. */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE0
argument_list|,
name|cause
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE0
argument_list|)
expr_stmt|;
comment|/* flush */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|calc_gpio_intr
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|gpi_intr
init|=
literal|0
decl_stmt|;
name|for_each_port
argument_list|(
argument|adap
argument_list|,
argument|i
argument_list|)
if|if
condition|(
operator|(
name|adap2pinfo
argument_list|(
name|adap
argument_list|,
name|i
argument_list|)
operator|->
name|phy
operator|.
name|caps
operator|&
name|SUPPORTED_IRQ
operator|)
operator|&&
name|adapter_info
argument_list|(
name|adap
argument_list|)
operator|->
name|gpio_intr
index|[
name|i
index|]
condition|)
name|gpi_intr
operator||=
literal|1
operator|<<
name|adapter_info
argument_list|(
name|adap
argument_list|)
operator|->
name|gpio_intr
index|[
name|i
index|]
expr_stmt|;
return|return
name|gpi_intr
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_intr_enable - enable interrupts  *	@adapter: the adapter whose interrupts should be enabled  *  *	Enable interrupts by setting the interrupt enable registers of the  *	various HW modules and then enabling the top-level interrupt  *	concentrator.  */
end_comment

begin_function
name|void
name|t3_intr_enable
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
name|struct
name|addr_val_pair
name|intr_en_avp
index|[]
init|=
block|{
block|{
name|A_MC7_INT_ENABLE
block|,
name|MC7_INTR_MASK
block|}
block|,
block|{
name|A_MC7_INT_ENABLE
operator|-
name|MC7_PMRX_BASE_ADDR
operator|+
name|MC7_PMTX_BASE_ADDR
block|,
name|MC7_INTR_MASK
block|}
block|,
block|{
name|A_MC7_INT_ENABLE
operator|-
name|MC7_PMRX_BASE_ADDR
operator|+
name|MC7_CM_BASE_ADDR
block|,
name|MC7_INTR_MASK
block|}
block|,
block|{
name|A_MC5_DB_INT_ENABLE
block|,
name|MC5_INTR_MASK
block|}
block|,
block|{
name|A_ULPRX_INT_ENABLE
block|,
name|ULPRX_INTR_MASK
block|}
block|,
block|{
name|A_PM1_TX_INT_ENABLE
block|,
name|PMTX_INTR_MASK
block|}
block|,
block|{
name|A_PM1_RX_INT_ENABLE
block|,
name|PMRX_INTR_MASK
block|}
block|,
block|{
name|A_CIM_HOST_INT_ENABLE
block|,
name|CIM_INTR_MASK
block|}
block|,
block|{
name|A_MPS_INT_ENABLE
block|,
name|MPS_INTR_MASK
block|}
block|, 	}
decl_stmt|;
name|adapter
operator|->
name|slow_intr_mask
operator|=
name|PL_INTR_MASK
expr_stmt|;
name|t3_write_regs
argument_list|(
name|adapter
argument_list|,
name|intr_en_avp
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|intr_en_avp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_INT_ENABLE
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>=
name|T3_REV_C
condition|?
literal|0x2bfffff
else|:
literal|0x3bfffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_INT_ENABLE
argument_list|,
name|SGE_INTR_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_CPL_INTR_ENABLE
argument_list|,
name|CPLSW_INTR_MASK
operator||
name|F_CIM_OVFL_ERROR
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_INT_ENABLE
argument_list|,
name|ULPTX_INTR_MASK
operator||
name|F_PBL_BOUND_ERR_CH0
operator||
name|F_PBL_BOUND_ERR_CH1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_CPL_INTR_ENABLE
argument_list|,
name|CPLSW_INTR_MASK
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_INT_ENABLE
argument_list|,
name|ULPTX_INTR_MASK
argument_list|)
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_T3DBG_INT_ENABLE
argument_list|,
name|calc_gpio_intr
argument_list|(
name|adapter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pcie
argument_list|(
name|adapter
argument_list|)
condition|)
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_INT_ENABLE
argument_list|,
name|PCIE_INTR_MASK
argument_list|)
expr_stmt|;
else|else
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIX_INT_ENABLE
argument_list|,
name|PCIX_INTR_MASK
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_ENABLE0
argument_list|,
name|adapter
operator|->
name|slow_intr_mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_ENABLE0
argument_list|)
expr_stmt|;
comment|/* flush */
block|}
end_function

begin_comment
comment|/**  *	t3_intr_disable - disable a card's interrupts  *	@adapter: the adapter whose interrupts should be disabled  *  *	Disable interrupts.  We only disable the top-level interrupt  *	concentrator and the SGE data interrupts.  */
end_comment

begin_function
name|void
name|t3_intr_disable
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_ENABLE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_ENABLE0
argument_list|)
expr_stmt|;
comment|/* flush */
name|adapter
operator|->
name|slow_intr_mask
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_intr_clear - clear all interrupts  *	@adapter: the adapter whose interrupts should be cleared  *  *	Clears all interrupts.  */
end_comment

begin_function
name|void
name|t3_intr_clear
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|int
name|cause_reg_addr
index|[]
init|=
block|{
name|A_SG_INT_CAUSE
block|,
name|A_SG_RSPQ_FL_STATUS
block|,
name|A_PCIX_INT_CAUSE
block|,
name|A_MC7_INT_CAUSE
block|,
name|A_MC7_INT_CAUSE
operator|-
name|MC7_PMRX_BASE_ADDR
operator|+
name|MC7_PMTX_BASE_ADDR
block|,
name|A_MC7_INT_CAUSE
operator|-
name|MC7_PMRX_BASE_ADDR
operator|+
name|MC7_CM_BASE_ADDR
block|,
name|A_CIM_HOST_INT_CAUSE
block|,
name|A_TP_INT_CAUSE
block|,
name|A_MC5_DB_INT_CAUSE
block|,
name|A_ULPRX_INT_CAUSE
block|,
name|A_ULPTX_INT_CAUSE
block|,
name|A_CPL_INTR_CAUSE
block|,
name|A_PM1_TX_INT_CAUSE
block|,
name|A_PM1_RX_INT_CAUSE
block|,
name|A_MPS_INT_CAUSE
block|,
name|A_T3DBG_INT_CAUSE
block|, 	}
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Clear PHY and MAC interrupts for each port. */
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|i
argument_list|)
name|t3_port_intr_clear
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|cause_reg_addr
argument_list|)
condition|;
operator|++
name|i
control|)
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|cause_reg_addr
index|[
name|i
index|]
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pcie
argument_list|(
name|adapter
argument_list|)
condition|)
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIE_PEX_ERR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_INT_CAUSE0
argument_list|)
expr_stmt|;
comment|/* flush */
block|}
end_function

begin_function
name|void
name|t3_xgm_intr_enable
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|adapter
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_XGM_INT_ENABLE
operator|+
name|pi
operator|->
name|mac
operator|.
name|offset
argument_list|,
name|XGM_EXTRA_INTR_MASK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_xgm_intr_disable
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|adapter
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_XGM_INT_DISABLE
operator|+
name|pi
operator|->
name|mac
operator|.
name|offset
argument_list|,
literal|0x7ff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_port_intr_enable - enable port-specific interrupts  *	@adapter: associated adapter  *	@idx: index of port whose interrupts should be enabled  *  *	Enable port-specific (i.e., MAC and PHY) interrupts for the given  *	adapter port.  */
end_comment

begin_function
name|void
name|t3_port_intr_enable
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|adapter
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_INT_ENABLE
operator|+
name|pi
operator|->
name|mac
operator|.
name|offset
argument_list|,
name|XGM_INTR_MASK
argument_list|)
expr_stmt|;
name|pi
operator|->
name|phy
operator|.
name|ops
operator|->
name|intr_enable
argument_list|(
operator|&
name|pi
operator|->
name|phy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_port_intr_disable - disable port-specific interrupts  *	@adapter: associated adapter  *	@idx: index of port whose interrupts should be disabled  *  *	Disable port-specific (i.e., MAC and PHY) interrupts for the given  *	adapter port.  */
end_comment

begin_function
name|void
name|t3_port_intr_disable
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|adapter
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_INT_ENABLE
operator|+
name|pi
operator|->
name|mac
operator|.
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pi
operator|->
name|phy
operator|.
name|ops
operator|->
name|intr_disable
argument_list|(
operator|&
name|pi
operator|->
name|phy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_port_intr_clear - clear port-specific interrupts  *	@adapter: associated adapter  *	@idx: index of port whose interrupts to clear  *  *	Clear port-specific (i.e., MAC and PHY) interrupts for the given  *	adapter port.  */
end_comment

begin_function
name|void
name|t3_port_intr_clear
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|adapter
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_INT_CAUSE
operator|+
name|pi
operator|->
name|mac
operator|.
name|offset
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|pi
operator|->
name|phy
operator|.
name|ops
operator|->
name|intr_clear
argument_list|(
operator|&
name|pi
operator|->
name|phy
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SG_CONTEXT_CMD_ATTEMPTS
value|100
end_define

begin_comment
comment|/**  * 	t3_sge_write_context - write an SGE context  * 	@adapter: the adapter  * 	@id: the context id  * 	@type: the context type  *  * 	Program an SGE context with the values already loaded in the  * 	CONTEXT_DATA? registers.  */
end_comment

begin_function
specifier|static
name|int
name|t3_sge_write_context
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|F_RESPONSEQ
condition|)
block|{
comment|/* 		 * Can't write the Response Queue Context bits for 		 * Interrupt Armed or the Reserve bits after the chip 		 * has been initialized out of reset.  Writing to these 		 * bits can confuse the hardware. 		 */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK1
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK2
argument_list|,
literal|0x17ffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK3
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK1
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK2
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK3
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|type
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
name|SG_CONTEXT_CMD_ATTEMPTS
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	clear_sge_ctxt - completely clear an SGE context  *	@adapter: the adapter  *	@id: the context id  *	@type: the context type  *  *	Completely clear an SGE context.  Used predominantly at post-reset  *	initialization.  Note in particular that we don't skip writing to any  *	"sensitive bits" in the contexts the way that t3_sge_write_context()  *	does ...  */
end_comment

begin_function
specifier|static
name|int
name|clear_sge_ctxt
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CONTEXT_DATA1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CONTEXT_DATA2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CONTEXT_DATA3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CONTEXT_MASK0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CONTEXT_MASK1
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CONTEXT_MASK2
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CONTEXT_MASK3
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|type
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
name|SG_CONTEXT_CMD_ATTEMPTS
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_init_ecntxt - initialize an SGE egress context  *	@adapter: the adapter to configure  *	@id: the context id  *	@gts_enable: whether to enable GTS for the context  *	@type: the egress context type  *	@respq: associated response queue  *	@base_addr: base address of queue  *	@size: number of queue entries  *	@token: uP token  *	@gen: initial generation value for the context  *	@cidx: consumer pointer  *  *	Initialize an SGE egress context and make it ready for use.  If the  *	platform allows concurrent context operations, the caller is  *	responsible for appropriate locking.  */
end_comment

begin_function
name|int
name|t3_sge_init_ecntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|int
name|gts_enable
parameter_list|,
name|enum
name|sge_context_type
name|type
parameter_list|,
name|int
name|respq
parameter_list|,
name|u64
name|base_addr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|unsigned
name|int
name|token
parameter_list|,
name|int
name|gen
parameter_list|,
name|unsigned
name|int
name|cidx
parameter_list|)
block|{
name|unsigned
name|int
name|credits
init|=
name|type
operator|==
name|SGE_CNTXT_OFLD
condition|?
literal|0
else|:
name|FW_WR_NUM
decl_stmt|;
if|if
condition|(
name|base_addr
operator|&
literal|0xfff
condition|)
comment|/* must be 4K aligned */
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|base_addr
operator|>>=
literal|12
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
name|V_EC_INDEX
argument_list|(
name|cidx
argument_list|)
operator||
name|V_EC_CREDITS
argument_list|(
name|credits
argument_list|)
operator||
name|V_EC_GTS
argument_list|(
name|gts_enable
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA1
argument_list|,
name|V_EC_SIZE
argument_list|(
name|size
argument_list|)
operator||
name|V_EC_BASE_LO
argument_list|(
operator|(
name|u32
operator|)
name|base_addr
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
name|base_addr
operator|>>=
literal|16
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA2
argument_list|,
operator|(
name|u32
operator|)
name|base_addr
argument_list|)
expr_stmt|;
name|base_addr
operator|>>=
literal|32
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA3
argument_list|,
name|V_EC_BASE_HI
argument_list|(
operator|(
name|u32
operator|)
name|base_addr
operator|&
literal|0xf
argument_list|)
operator||
name|V_EC_RESPQ
argument_list|(
name|respq
argument_list|)
operator||
name|V_EC_TYPE
argument_list|(
name|type
argument_list|)
operator||
name|V_EC_GEN
argument_list|(
name|gen
argument_list|)
operator||
name|V_EC_UP_TOKEN
argument_list|(
name|token
argument_list|)
operator||
name|F_EC_VALID
argument_list|)
expr_stmt|;
return|return
name|t3_sge_write_context
argument_list|(
name|adapter
argument_list|,
name|id
argument_list|,
name|F_EGRESS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_init_flcntxt - initialize an SGE free-buffer list context  *	@adapter: the adapter to configure  *	@id: the context id  *	@gts_enable: whether to enable GTS for the context  *	@base_addr: base address of queue  *	@size: number of queue entries  *	@bsize: size of each buffer for this queue  *	@cong_thres: threshold to signal congestion to upstream producers  *	@gen: initial generation value for the context  *	@cidx: consumer pointer  *  *	Initialize an SGE free list context and make it ready for use.  The  *	caller is responsible for ensuring only one context operation occurs  *	at a time.  */
end_comment

begin_function
name|int
name|t3_sge_init_flcntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|int
name|gts_enable
parameter_list|,
name|u64
name|base_addr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|unsigned
name|int
name|bsize
parameter_list|,
name|unsigned
name|int
name|cong_thres
parameter_list|,
name|int
name|gen
parameter_list|,
name|unsigned
name|int
name|cidx
parameter_list|)
block|{
if|if
condition|(
name|base_addr
operator|&
literal|0xfff
condition|)
comment|/* must be 4K aligned */
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|base_addr
operator|>>=
literal|12
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
operator|(
name|u32
operator|)
name|base_addr
argument_list|)
expr_stmt|;
name|base_addr
operator|>>=
literal|32
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA1
argument_list|,
name|V_FL_BASE_HI
argument_list|(
operator|(
name|u32
operator|)
name|base_addr
argument_list|)
operator||
name|V_FL_INDEX_LO
argument_list|(
name|cidx
operator|&
name|M_FL_INDEX_LO
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA2
argument_list|,
name|V_FL_SIZE
argument_list|(
name|size
argument_list|)
operator||
name|V_FL_GEN
argument_list|(
name|gen
argument_list|)
operator||
name|V_FL_INDEX_HI
argument_list|(
name|cidx
operator|>>
literal|12
argument_list|)
operator||
name|V_FL_ENTRY_SIZE_LO
argument_list|(
name|bsize
operator|&
name|M_FL_ENTRY_SIZE_LO
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA3
argument_list|,
name|V_FL_ENTRY_SIZE_HI
argument_list|(
name|bsize
operator|>>
operator|(
literal|32
operator|-
name|S_FL_ENTRY_SIZE_LO
operator|)
argument_list|)
operator||
name|V_FL_CONG_THRES
argument_list|(
name|cong_thres
argument_list|)
operator||
name|V_FL_GTS
argument_list|(
name|gts_enable
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_sge_write_context
argument_list|(
name|adapter
argument_list|,
name|id
argument_list|,
name|F_FREELIST
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_init_rspcntxt - initialize an SGE response queue context  *	@adapter: the adapter to configure  *	@id: the context id  *	@irq_vec_idx: MSI-X interrupt vector index, 0 if no MSI-X, -1 if no IRQ  *	@base_addr: base address of queue  *	@size: number of queue entries  *	@fl_thres: threshold for selecting the normal or jumbo free list  *	@gen: initial generation value for the context  *	@cidx: consumer pointer  *  *	Initialize an SGE response queue context and make it ready for use.  *	The caller is responsible for ensuring only one context operation  *	occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_init_rspcntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|int
name|irq_vec_idx
parameter_list|,
name|u64
name|base_addr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|unsigned
name|int
name|fl_thres
parameter_list|,
name|int
name|gen
parameter_list|,
name|unsigned
name|int
name|cidx
parameter_list|)
block|{
name|unsigned
name|int
name|ctrl
decl_stmt|,
name|intr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|base_addr
operator|&
literal|0xfff
condition|)
comment|/* must be 4K aligned */
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|base_addr
operator|>>=
literal|12
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
name|V_CQ_SIZE
argument_list|(
name|size
argument_list|)
operator||
name|V_CQ_INDEX
argument_list|(
name|cidx
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA1
argument_list|,
operator|(
name|u32
operator|)
name|base_addr
argument_list|)
expr_stmt|;
name|base_addr
operator|>>=
literal|32
expr_stmt|;
name|ctrl
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|irq_vec_idx
operator|>
literal|0
operator|)
operator|||
operator|(
operator|(
name|irq_vec_idx
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|ctrl
operator|&
name|F_ONEINTMULTQ
operator|)
operator|)
condition|)
name|intr
operator|=
name|F_RQ_INTR_EN
expr_stmt|;
if|if
condition|(
name|irq_vec_idx
operator|>=
literal|0
condition|)
name|intr
operator||=
name|V_RQ_MSI_VEC
argument_list|(
name|irq_vec_idx
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA2
argument_list|,
name|V_CQ_BASE_HI
argument_list|(
operator|(
name|u32
operator|)
name|base_addr
argument_list|)
operator||
name|intr
operator||
name|V_RQ_GEN
argument_list|(
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA3
argument_list|,
name|fl_thres
argument_list|)
expr_stmt|;
return|return
name|t3_sge_write_context
argument_list|(
name|adapter
argument_list|,
name|id
argument_list|,
name|F_RESPONSEQ
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_init_cqcntxt - initialize an SGE completion queue context  *	@adapter: the adapter to configure  *	@id: the context id  *	@base_addr: base address of queue  *	@size: number of queue entries  *	@rspq: response queue for async notifications  *	@ovfl_mode: CQ overflow mode  *	@credits: completion queue credits  *	@credit_thres: the credit threshold  *  *	Initialize an SGE completion queue context and make it ready for use.  *	The caller is responsible for ensuring only one context operation  *	occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_init_cqcntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|u64
name|base_addr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|rspq
parameter_list|,
name|int
name|ovfl_mode
parameter_list|,
name|unsigned
name|int
name|credits
parameter_list|,
name|unsigned
name|int
name|credit_thres
parameter_list|)
block|{
if|if
condition|(
name|base_addr
operator|&
literal|0xfff
condition|)
comment|/* must be 4K aligned */
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|base_addr
operator|>>=
literal|12
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
name|V_CQ_SIZE
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA1
argument_list|,
operator|(
name|u32
operator|)
name|base_addr
argument_list|)
expr_stmt|;
name|base_addr
operator|>>=
literal|32
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA2
argument_list|,
name|V_CQ_BASE_HI
argument_list|(
operator|(
name|u32
operator|)
name|base_addr
argument_list|)
operator||
name|V_CQ_RSPQ
argument_list|(
name|rspq
argument_list|)
operator||
name|V_CQ_GEN
argument_list|(
literal|1
argument_list|)
operator||
name|V_CQ_OVERFLOW_MODE
argument_list|(
name|ovfl_mode
argument_list|)
operator||
name|V_CQ_ERR
argument_list|(
name|ovfl_mode
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA3
argument_list|,
name|V_CQ_CREDITS
argument_list|(
name|credits
argument_list|)
operator||
name|V_CQ_CREDIT_THRES
argument_list|(
name|credit_thres
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_sge_write_context
argument_list|(
name|adapter
argument_list|,
name|id
argument_list|,
name|F_CQ
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_enable_ecntxt - enable/disable an SGE egress context  *	@adapter: the adapter  *	@id: the egress context id  *	@enable: enable (1) or disable (0) the context  *  *	Enable or disable an SGE egress context.  The caller is responsible for  *	ensuring only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_enable_ecntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK3
argument_list|,
name|F_EC_VALID
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA3
argument_list|,
name|V_EC_VALID
argument_list|(
name|enable
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|F_EGRESS
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
name|SG_CONTEXT_CMD_ATTEMPTS
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_disable_fl - disable an SGE free-buffer list  *	@adapter: the adapter  *	@id: the free list context id  *  *	Disable an SGE free-buffer list.  The caller is responsible for  *	ensuring only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_disable_fl
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK2
argument_list|,
name|V_FL_SIZE
argument_list|(
name|M_FL_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|F_FREELIST
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
name|SG_CONTEXT_CMD_ATTEMPTS
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_disable_rspcntxt - disable an SGE response queue  *	@adapter: the adapter  *	@id: the response queue context id  *  *	Disable an SGE response queue.  The caller is responsible for  *	ensuring only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_disable_rspcntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK0
argument_list|,
name|V_CQ_SIZE
argument_list|(
name|M_CQ_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|F_RESPONSEQ
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
name|SG_CONTEXT_CMD_ATTEMPTS
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_disable_cqcntxt - disable an SGE completion queue  *	@adapter: the adapter  *	@id: the completion queue context id  *  *	Disable an SGE completion queue.  The caller is responsible for  *	ensuring only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_disable_cqcntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK0
argument_list|,
name|V_CQ_SIZE
argument_list|(
name|M_CQ_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_MASK3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|1
argument_list|)
operator||
name|F_CQ
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
name|SG_CONTEXT_CMD_ATTEMPTS
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_cqcntxt_op - perform an operation on a completion queue context  *	@adapter: the adapter  *	@id: the context id  *	@op: the operation to perform  *	@credits: credits to return to the CQ  *  *	Perform the selected operation on an SGE completion queue context.  *	The caller is responsible for ensuring only one context operation  *	occurs at a time.  *  *	For most operations the function returns the current HW position in  *	the completion queue.  */
end_comment

begin_function
name|int
name|t3_sge_cqcntxt_op
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|unsigned
name|int
name|op
parameter_list|,
name|unsigned
name|int
name|credits
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|,
name|credits
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
name|op
argument_list|)
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
operator||
name|F_CQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_wait_op_done_val
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
name|SG_CONTEXT_CMD_ATTEMPTS
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
if|if
condition|(
name|op
operator|>=
literal|2
operator|&&
name|op
operator|<
literal|7
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
return|return
name|G_CQ_INDEX
argument_list|(
name|val
argument_list|)
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|0
argument_list|)
operator||
name|F_CQ
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
name|SG_CONTEXT_CMD_ATTEMPTS
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
return|return
name|G_CQ_INDEX
argument_list|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * 	t3_sge_read_context - read an SGE context  * 	@type: the context type  * 	@adapter: the adapter  * 	@id: the context id  * 	@data: holds the retrieved context  *  * 	Read an SGE egress context.  The caller is responsible for ensuring  * 	only one context operation occurs at a time.  */
end_comment

begin_function
specifier|static
name|int
name|t3_sge_read_context
parameter_list|(
name|unsigned
name|int
name|type
parameter_list|,
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|u32
name|data
index|[
literal|4
index|]
parameter_list|)
block|{
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|V_CONTEXT_CMD_OPCODE
argument_list|(
literal|0
argument_list|)
operator||
name|type
operator||
name|V_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|,
name|F_CONTEXT_CMD_BUSY
argument_list|,
literal|0
argument_list|,
name|SG_CONTEXT_CMD_ATTEMPTS
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
name|data
index|[
literal|0
index|]
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA0
argument_list|)
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA1
argument_list|)
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA2
argument_list|)
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_CONTEXT_DATA3
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * 	t3_sge_read_ecntxt - read an SGE egress context  * 	@adapter: the adapter  * 	@id: the context id  * 	@data: holds the retrieved context  *  * 	Read an SGE egress context.  The caller is responsible for ensuring  * 	only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_read_ecntxt
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|u32
name|data
index|[
literal|4
index|]
parameter_list|)
block|{
if|if
condition|(
name|id
operator|>=
literal|65536
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
name|t3_sge_read_context
argument_list|(
name|F_EGRESS
argument_list|,
name|adapter
argument_list|,
name|id
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * 	t3_sge_read_cq - read an SGE CQ context  * 	@adapter: the adapter  * 	@id: the context id  * 	@data: holds the retrieved context  *  * 	Read an SGE CQ context.  The caller is responsible for ensuring  * 	only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_read_cq
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|u32
name|data
index|[
literal|4
index|]
parameter_list|)
block|{
if|if
condition|(
name|id
operator|>=
literal|65536
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
name|t3_sge_read_context
argument_list|(
name|F_CQ
argument_list|,
name|adapter
argument_list|,
name|id
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * 	t3_sge_read_fl - read an SGE free-list context  * 	@adapter: the adapter  * 	@id: the context id  * 	@data: holds the retrieved context  *  * 	Read an SGE free-list context.  The caller is responsible for ensuring  * 	only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_read_fl
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|u32
name|data
index|[
literal|4
index|]
parameter_list|)
block|{
if|if
condition|(
name|id
operator|>=
name|SGE_QSETS
operator|*
literal|2
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
name|t3_sge_read_context
argument_list|(
name|F_FREELIST
argument_list|,
name|adapter
argument_list|,
name|id
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * 	t3_sge_read_rspq - read an SGE response queue context  * 	@adapter: the adapter  * 	@id: the context id  * 	@data: holds the retrieved context  *  * 	Read an SGE response queue context.  The caller is responsible for  * 	ensuring only one context operation occurs at a time.  */
end_comment

begin_function
name|int
name|t3_sge_read_rspq
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|u32
name|data
index|[
literal|4
index|]
parameter_list|)
block|{
if|if
condition|(
name|id
operator|>=
name|SGE_QSETS
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
name|t3_sge_read_context
argument_list|(
name|F_RESPONSEQ
argument_list|,
name|adapter
argument_list|,
name|id
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_config_rss - configure Rx packet steering  *	@adapter: the adapter  *	@rss_config: RSS settings (written to TP_RSS_CONFIG)  *	@cpus: values for the CPU lookup table (0xff terminated)  *	@rspq: values for the response queue lookup table (0xffff terminated)  *  *	Programs the receive packet steering logic.  @cpus and @rspq provide  *	the values for the CPU and response queue lookup tables.  If they  *	provide fewer values than the size of the tables the supplied values  *	are used repeatedly until the tables are fully populated.  */
end_comment

begin_function
name|void
name|t3_config_rss
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|rss_config
parameter_list|,
specifier|const
name|u8
modifier|*
name|cpus
parameter_list|,
specifier|const
name|u16
modifier|*
name|rspq
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cpu_idx
init|=
literal|0
decl_stmt|,
name|q_idx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cpus
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_TABLE_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|u32
name|val
init|=
name|i
operator|<<
literal|16
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
operator|++
name|j
control|)
block|{
name|val
operator||=
operator|(
name|cpus
index|[
name|cpu_idx
operator|++
index|]
operator|&
literal|0x3f
operator|)
operator|<<
operator|(
literal|8
operator|*
name|j
operator|)
expr_stmt|;
if|if
condition|(
name|cpus
index|[
name|cpu_idx
index|]
operator|==
literal|0xff
condition|)
name|cpu_idx
operator|=
literal|0
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_LKP_TABLE
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rspq
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_TABLE_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_MAP_TABLE
argument_list|,
operator|(
name|i
operator|<<
literal|16
operator|)
operator||
name|rspq
index|[
name|q_idx
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rspq
index|[
name|q_idx
index|]
operator|==
literal|0xffff
condition|)
name|q_idx
operator|=
literal|0
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_CONFIG
argument_list|,
name|rss_config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_read_rss - read the contents of the RSS tables  *	@adapter: the adapter  *	@lkup: holds the contents of the RSS lookup table  *	@map: holds the contents of the RSS map table  *  *	Reads the contents of the receive packet steering tables.  */
end_comment

begin_function
name|int
name|t3_read_rss
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u8
modifier|*
name|lkup
parameter_list|,
name|u16
modifier|*
name|map
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|val
decl_stmt|;
if|if
condition|(
name|lkup
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_TABLE_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_LKP_TABLE
argument_list|,
literal|0xffff0000
operator||
name|i
argument_list|)
expr_stmt|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_LKP_TABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
literal|0x80000000
operator|)
condition|)
return|return
operator|-
name|EAGAIN
return|;
operator|*
name|lkup
operator|++
operator|=
operator|(
name|u8
operator|)
name|val
expr_stmt|;
operator|*
name|lkup
operator|++
operator|=
call|(
name|u8
call|)
argument_list|(
name|val
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|map
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_TABLE_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_MAP_TABLE
argument_list|,
literal|0xffff0000
operator||
name|i
argument_list|)
expr_stmt|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_RSS_MAP_TABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
literal|0x80000000
operator|)
condition|)
return|return
operator|-
name|EAGAIN
return|;
operator|*
name|map
operator|++
operator|=
operator|(
name|u16
operator|)
name|val
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_tp_set_offload_mode - put TP in NIC/offload mode  *	@adap: the adapter  *	@enable: 1 to select offload mode, 0 for regular NIC  *  *	Switches TP to NIC/offload mode.  */
end_comment

begin_function
name|void
name|t3_tp_set_offload_mode
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
if|if
condition|(
name|is_offload
argument_list|(
name|adap
argument_list|)
operator|||
operator|!
name|enable
condition|)
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_IN_CONFIG
argument_list|,
name|F_NICMODE
argument_list|,
name|V_NICMODE
argument_list|(
operator|!
name|enable
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	tp_wr_bits_indirect - set/clear bits in an indirect TP register  *	@adap: the adapter  *	@addr: the indirect TP register address  *	@mask: specifies the field within the register to modify  *	@val: new value for the field  *  *	Sets a field of an indirect TP register to the given value.  */
end_comment

begin_function
specifier|static
name|void
name|tp_wr_bits_indirect
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|mask
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|val
operator||=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_DATA
argument_list|)
operator|&
operator|~
name|mask
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_enable_filters - enable the HW filters  *	@adap: the adapter  *  *	Enables the HW filters for NIC traffic.  */
end_comment

begin_function
name|void
name|t3_enable_filters
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|)
block|{
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_IN_CONFIG
argument_list|,
name|F_NICMODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_CONFIG
argument_list|,
literal|0
argument_list|,
name|F_FILTEREN
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_GLOBAL_CONFIG
argument_list|,
literal|0
argument_list|,
name|V_FIVETUPLELOOKUP
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|tp_wr_bits_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_INGRESS_CONFIG
argument_list|,
literal|0
argument_list|,
name|F_LOOKUPEVERYPKT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_disable_filters - disable the HW filters  *	@adap: the adapter  *  *	Disables the HW filters for NIC traffic.  */
end_comment

begin_function
name|void
name|t3_disable_filters
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|)
block|{
comment|/* note that we don't want to revert to NIC-only mode */
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_CONFIG
argument_list|,
name|F_FILTEREN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_GLOBAL_CONFIG
argument_list|,
name|V_FIVETUPLELOOKUP
argument_list|(
name|M_FIVETUPLELOOKUP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tp_wr_bits_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_INGRESS_CONFIG
argument_list|,
name|F_LOOKUPEVERYPKT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	pm_num_pages - calculate the number of pages of the payload memory  *	@mem_size: the size of the payload memory  *	@pg_size: the size of each payload memory page  *  *	Calculate the number of pages, each of the given size, that fit in a  *	memory of the specified size, respecting the HW requirement that the  *	number of pages must be a multiple of 24.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|pm_num_pages
parameter_list|(
name|unsigned
name|int
name|mem_size
parameter_list|,
name|unsigned
name|int
name|pg_size
parameter_list|)
block|{
name|unsigned
name|int
name|n
init|=
name|mem_size
operator|/
name|pg_size
decl_stmt|;
return|return
name|n
operator|-
name|n
operator|%
literal|24
return|;
block|}
end_function

begin_define
define|#
directive|define
name|mem_region
parameter_list|(
name|adap
parameter_list|,
name|start
parameter_list|,
name|size
parameter_list|,
name|reg
parameter_list|)
define|\
value|t3_write_reg((adap), A_ ## reg, (start)); \ 	start += size
end_define

begin_comment
comment|/**  *	partition_mem - partition memory and configure TP memory settings  *	@adap: the adapter  *	@p: the TP parameters  *  *	Partitions context and payload memory and configures TP's memory  *	registers.  */
end_comment

begin_function
specifier|static
name|void
name|partition_mem
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
specifier|const
name|struct
name|tp_params
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|m
decl_stmt|,
name|pstructs
decl_stmt|,
name|tids
init|=
name|t3_mc5_size
argument_list|(
operator|&
name|adap
operator|->
name|mc5
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|timers
init|=
literal|0
decl_stmt|,
name|timers_shift
init|=
literal|22
decl_stmt|;
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tids
operator|<=
literal|16
operator|*
literal|1024
condition|)
block|{
name|timers
operator|=
literal|1
expr_stmt|;
name|timers_shift
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tids
operator|<=
literal|64
operator|*
literal|1024
condition|)
block|{
name|timers
operator|=
literal|2
expr_stmt|;
name|timers_shift
operator|=
literal|18
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tids
operator|<=
literal|256
operator|*
literal|1024
condition|)
block|{
name|timers
operator|=
literal|3
expr_stmt|;
name|timers_shift
operator|=
literal|20
expr_stmt|;
block|}
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PMM_SIZE
argument_list|,
name|p
operator|->
name|chan_rx_size
operator||
operator|(
name|p
operator|->
name|chan_tx_size
operator|>>
literal|16
operator|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PMM_TX_BASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PMM_TX_PAGE_SIZE
argument_list|,
name|p
operator|->
name|tx_pg_size
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PMM_TX_MAX_PAGE
argument_list|,
name|p
operator|->
name|tx_num_pgs
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG3
argument_list|,
name|V_TXDATAACKIDX
argument_list|(
name|M_TXDATAACKIDX
argument_list|)
argument_list|,
name|V_TXDATAACKIDX
argument_list|(
name|fls
argument_list|(
name|p
operator|->
name|tx_pg_size
argument_list|)
operator|-
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PMM_RX_BASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PMM_RX_PAGE_SIZE
argument_list|,
name|p
operator|->
name|rx_pg_size
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PMM_RX_MAX_PAGE
argument_list|,
name|p
operator|->
name|rx_num_pgs
argument_list|)
expr_stmt|;
name|pstructs
operator|=
name|p
operator|->
name|rx_num_pgs
operator|+
name|p
operator|->
name|tx_num_pgs
expr_stmt|;
comment|/* Add a bit of headroom and make multiple of 24 */
name|pstructs
operator|+=
literal|48
expr_stmt|;
name|pstructs
operator|-=
name|pstructs
operator|%
literal|24
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CMM_MM_MAX_PSTRUCT
argument_list|,
name|pstructs
argument_list|)
expr_stmt|;
name|m
operator|=
name|tids
operator|*
name|TCB_SIZE
expr_stmt|;
name|mem_region
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
operator|(
literal|64
operator|<<
literal|10
operator|)
operator|*
literal|64
argument_list|,
name|SG_EGR_CNTX_BADDR
argument_list|)
expr_stmt|;
name|mem_region
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
operator|(
literal|64
operator|<<
literal|10
operator|)
operator|*
literal|64
argument_list|,
name|SG_CQ_CONTEXT_BADDR
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CMM_TIMER_BASE
argument_list|,
name|V_CMTIMERMAXNUM
argument_list|(
name|timers
argument_list|)
operator||
name|m
argument_list|)
expr_stmt|;
name|m
operator|+=
operator|(
operator|(
name|p
operator|->
name|ntimer_qs
operator|-
literal|1
operator|)
operator|<<
name|timers_shift
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
name|mem_region
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
name|pstructs
operator|*
literal|64
argument_list|,
name|TP_CMM_MM_BASE
argument_list|)
expr_stmt|;
name|mem_region
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
literal|64
operator|*
operator|(
name|pstructs
operator|/
literal|24
operator|)
argument_list|,
name|TP_CMM_MM_PS_FLST_BASE
argument_list|)
expr_stmt|;
name|mem_region
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
literal|64
operator|*
operator|(
name|p
operator|->
name|rx_num_pgs
operator|/
literal|24
operator|)
argument_list|,
name|TP_CMM_MM_RX_FLST_BASE
argument_list|)
expr_stmt|;
name|mem_region
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
literal|64
operator|*
operator|(
name|p
operator|->
name|tx_num_pgs
operator|/
literal|24
operator|)
argument_list|,
name|TP_CMM_MM_TX_FLST_BASE
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
name|m
operator|+
literal|4095
operator|)
operator|&
operator|~
literal|0xfff
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_SDRAM_BASE_ADDR
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_SDRAM_ADDR_SIZE
argument_list|,
name|p
operator|->
name|cm_size
operator|-
name|m
argument_list|)
expr_stmt|;
name|tids
operator|=
operator|(
name|p
operator|->
name|cm_size
operator|-
name|m
operator|-
operator|(
literal|3
operator|<<
literal|20
operator|)
operator|)
operator|/
literal|3072
operator|-
literal|32
expr_stmt|;
name|m
operator|=
name|t3_mc5_size
argument_list|(
operator|&
name|adap
operator|->
name|mc5
argument_list|)
operator|-
name|adap
operator|->
name|params
operator|.
name|mc5
operator|.
name|nservers
operator|-
name|adap
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
operator|-
name|adap
operator|->
name|params
operator|.
name|mc5
operator|.
name|nroutes
expr_stmt|;
if|if
condition|(
name|tids
operator|<
name|m
condition|)
name|adap
operator|->
name|params
operator|.
name|mc5
operator|.
name|nservers
operator|+=
name|m
operator|-
name|tids
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|tp_wr_indirect
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u32
name|tp_rd_indirect
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PIO_DATA
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tp_config
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
specifier|const
name|struct
name|tp_params
modifier|*
name|p
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_GLOBAL_CONFIG
argument_list|,
name|F_TXPACINGENABLE
operator||
name|F_PATHMTU
operator||
name|F_IPCHECKSUMOFFLOAD
operator||
name|F_UDPCHECKSUMOFFLOAD
operator||
name|F_TCPCHECKSUMOFFLOAD
operator||
name|V_IPTTL
argument_list|(
literal|64
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TCP_OPTIONS
argument_list|,
name|V_MTUDEFAULT
argument_list|(
literal|576
argument_list|)
operator||
name|F_MTUENABLE
operator||
name|V_WINDOWSCALEMODE
argument_list|(
literal|1
argument_list|)
operator||
name|V_TIMESTAMPSMODE
argument_list|(
literal|1
argument_list|)
operator||
name|V_SACKMODE
argument_list|(
literal|1
argument_list|)
operator||
name|V_SACKRX
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_DACK_CONFIG
argument_list|,
name|V_AUTOSTATE3
argument_list|(
literal|1
argument_list|)
operator||
name|V_AUTOSTATE2
argument_list|(
literal|1
argument_list|)
operator||
name|V_AUTOSTATE1
argument_list|(
literal|0
argument_list|)
operator||
name|V_BYTETHRESHOLD
argument_list|(
literal|26880
argument_list|)
operator||
name|V_MSSTHRESHOLD
argument_list|(
literal|2
argument_list|)
operator||
name|F_AUTOCAREFUL
operator||
name|F_AUTOENABLE
operator||
name|V_DACK_MODE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_IN_CONFIG
argument_list|,
name|F_RXFBARBPRIO
operator||
name|F_TXFBARBPRIO
argument_list|,
name|F_IPV6ENABLE
operator||
name|F_NICMODE
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_RESOURCE_LIMIT
argument_list|,
literal|0x18141814
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG4
argument_list|,
literal|0x5050105
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG6
argument_list|,
literal|0
argument_list|,
name|adap
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|?
name|F_ENABLEESND
else|:
name|F_T3A_ENABLEESND
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PC_CONFIG
argument_list|,
name|F_ENABLEEPCMDAFULL
argument_list|,
name|F_ENABLEOCSPIFULL
operator||
name|F_TXDEFERENABLE
operator||
name|F_HEARBEATDACK
operator||
name|F_TXCONGESTIONMODE
operator||
name|F_RXCONGESTIONMODE
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PC_CONFIG2
argument_list|,
name|F_CHDRAFULL
argument_list|,
name|F_ENABLEIPV6RSS
operator||
name|F_ENABLENONOFDTNLSYN
operator||
name|F_ENABLEARPMISS
operator||
name|F_DISBLEDAPARBIT0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PROXY_FLOW_CNTL
argument_list|,
literal|1080
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PROXY_FLOW_CNTL
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
block|{
name|tp_wr_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_EGRESS_CONFIG
argument_list|,
name|F_REWRITEFORCETOSIZE
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG3
argument_list|,
literal|0
argument_list|,
name|F_TXPACEAUTO
operator||
name|F_TXPACEAUTOSTRICT
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PC_CONFIG
argument_list|,
name|F_LOCKTID
argument_list|,
name|F_LOCKTID
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_VLAN_PRI_MAP
argument_list|,
literal|0xfa50
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MAC_MATCH_MAP0
argument_list|,
literal|0xfac688
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MAC_MATCH_MAP1
argument_list|,
literal|0xfac688
argument_list|)
expr_stmt|;
block|}
else|else
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG3
argument_list|,
literal|0
argument_list|,
name|F_TXPACEFIXED
argument_list|)
expr_stmt|;
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|rev
operator|==
name|T3_REV_C
condition|)
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PC_CONFIG
argument_list|,
name|V_TABLELATENCYDELTA
argument_list|(
name|M_TABLELATENCYDELTA
argument_list|)
argument_list|,
name|V_TABLELATENCYDELTA
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_MOD_QUEUE_WEIGHT1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_MOD_QUEUE_WEIGHT0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MOD_CHANNEL_WEIGHT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MOD_RATE_LIMIT
argument_list|,
literal|0xf2200000
argument_list|)
expr_stmt|;
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|nports
operator|>
literal|2
condition|)
block|{
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PC_CONFIG2
argument_list|,
literal|0
argument_list|,
name|F_ENABLETXPORTFROMDA2
operator||
name|F_ENABLETXPORTFROMDA
operator||
name|F_ENABLERXPORTFROMADDR
argument_list|)
expr_stmt|;
name|tp_wr_bits_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_QOS_RX_MAP_MODE
argument_list|,
name|V_RXMAPMODE
argument_list|(
name|M_RXMAPMODE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_INGRESS_CONFIG
argument_list|,
name|V_BITPOS0
argument_list|(
literal|48
argument_list|)
operator||
name|V_BITPOS1
argument_list|(
literal|49
argument_list|)
operator||
name|V_BITPOS2
argument_list|(
literal|50
argument_list|)
operator||
name|V_BITPOS3
argument_list|(
literal|51
argument_list|)
operator||
name|F_ENABLEEXTRACT
operator||
name|F_ENABLEEXTRACTIONSFD
operator||
name|F_ENABLEINSERTION
operator||
name|F_ENABLEINSERTIONSFD
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_PREAMBLE_MSB
argument_list|,
literal|0xfb000000
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_PREAMBLE_LSB
argument_list|,
literal|0xd5
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_INTF_FROM_TX_PKT
argument_list|,
name|F_INTFFROMTXPKT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* TCP timer values in ms */
end_comment

begin_define
define|#
directive|define
name|TP_DACK_TIMER
value|50
end_define

begin_define
define|#
directive|define
name|TP_RTO_MIN
value|250
end_define

begin_comment
comment|/**  *	tp_set_timers - set TP timing parameters  *	@adap: the adapter to set  *	@core_clk: the core clock frequency in Hz  *  *	Set TP's timing parameters, such as the various timer resolutions and  *	the TCP timer values.  */
end_comment

begin_function
specifier|static
name|void
name|tp_set_timers
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|core_clk
parameter_list|)
block|{
name|unsigned
name|int
name|tre
init|=
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|tre
decl_stmt|;
name|unsigned
name|int
name|dack_re
init|=
name|adap
operator|->
name|params
operator|.
name|tp
operator|.
name|dack_re
decl_stmt|;
name|unsigned
name|int
name|tstamp_re
init|=
name|fls
argument_list|(
name|core_clk
operator|/
literal|1000
argument_list|)
decl_stmt|;
comment|/* 1ms, at least */
name|unsigned
name|int
name|tps
init|=
name|core_clk
operator|>>
name|tre
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TIMER_RESOLUTION
argument_list|,
name|V_TIMERRESOLUTION
argument_list|(
name|tre
argument_list|)
operator||
name|V_DELAYEDACKRESOLUTION
argument_list|(
name|dack_re
argument_list|)
operator||
name|V_TIMESTAMPRESOLUTION
argument_list|(
name|tstamp_re
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_DACK_TIMER
argument_list|,
operator|(
name|core_clk
operator|>>
name|dack_re
operator|)
operator|/
operator|(
literal|1000
operator|/
name|TP_DACK_TIMER
operator|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TCP_BACKOFF_REG0
argument_list|,
literal|0x3020100
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TCP_BACKOFF_REG1
argument_list|,
literal|0x7060504
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TCP_BACKOFF_REG2
argument_list|,
literal|0xb0a0908
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TCP_BACKOFF_REG3
argument_list|,
literal|0xf0e0d0c
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_SHIFT_CNT
argument_list|,
name|V_SYNSHIFTMAX
argument_list|(
literal|6
argument_list|)
operator||
name|V_RXTSHIFTMAXR1
argument_list|(
literal|4
argument_list|)
operator||
name|V_RXTSHIFTMAXR2
argument_list|(
literal|15
argument_list|)
operator||
name|V_PERSHIFTBACKOFFMAX
argument_list|(
literal|8
argument_list|)
operator||
name|V_PERSHIFTMAX
argument_list|(
literal|8
argument_list|)
operator||
name|V_KEEPALIVEMAX
argument_list|(
literal|9
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|SECONDS
value|* tps
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MSL
argument_list|,
name|adap
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|?
literal|0
else|:
literal|2
name|SECONDS
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_RXT_MIN
argument_list|,
name|tps
operator|/
operator|(
literal|1000
operator|/
name|TP_RTO_MIN
operator|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_RXT_MAX
argument_list|,
literal|64
name|SECONDS
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PERS_MIN
argument_list|,
literal|5
name|SECONDS
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PERS_MAX
argument_list|,
literal|64
name|SECONDS
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_KEEP_IDLE
argument_list|,
literal|7200
name|SECONDS
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_KEEP_INTVL
argument_list|,
literal|75
name|SECONDS
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_INIT_SRTT
argument_list|,
literal|3
name|SECONDS
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_FINWAIT2_TIMER
argument_list|,
literal|600
name|SECONDS
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SECONDS
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_CHELSIO_T3_CORE
end_ifdef

begin_comment
comment|/**  *	t3_tp_set_coalescing_size - set receive coalescing size  *	@adap: the adapter  *	@size: the receive coalescing size  *	@psh: whether a set PSH bit should deliver coalesced data  *  *	Set the receive coalescing size and PSH bit handling.  */
end_comment

begin_function
name|int
name|t3_tp_set_coalescing_size
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|psh
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|MAX_RX_COALESCING_LEN
condition|)
return|return
operator|-
name|EINVAL
return|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG3
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|F_RXCOALESCEENABLE
operator||
name|F_RXCOALESCEPSHEN
operator|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
name|val
operator||=
name|F_RXCOALESCEENABLE
expr_stmt|;
if|if
condition|(
name|psh
condition|)
name|val
operator||=
name|F_RXCOALESCEPSHEN
expr_stmt|;
name|size
operator|=
name|min
argument_list|(
name|MAX_RX_COALESCING_LEN
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG2
argument_list|,
name|V_RXCOALESCESIZE
argument_list|(
name|size
argument_list|)
operator||
name|V_MAXRXDATA
argument_list|(
name|MAX_RX_COALESCING_LEN
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG3
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_tp_set_max_rxsize - set the max receive size  *	@adap: the adapter  *	@size: the max receive size  *  *	Set TP's max receive size.  This is the limit that applies when  *	receive coalescing is disabled.  */
end_comment

begin_function
name|void
name|t3_tp_set_max_rxsize
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PARA_REG7
argument_list|,
name|V_PMMAXXFERLEN0
argument_list|(
name|size
argument_list|)
operator||
name|V_PMMAXXFERLEN1
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__devinit
name|init_mtus
parameter_list|(
name|unsigned
name|short
name|mtus
index|[]
parameter_list|)
block|{
comment|/* 	 * See draft-mathis-plpmtud-00.txt for the values.  The min is 88 so 	 * it can accomodate max size TCP/IP headers when SACK and timestamps 	 * are enabled and still have at least 8 bytes of payload. 	 */
name|mtus
index|[
literal|0
index|]
operator|=
literal|88
expr_stmt|;
name|mtus
index|[
literal|1
index|]
operator|=
literal|88
expr_stmt|;
name|mtus
index|[
literal|2
index|]
operator|=
literal|256
expr_stmt|;
name|mtus
index|[
literal|3
index|]
operator|=
literal|512
expr_stmt|;
name|mtus
index|[
literal|4
index|]
operator|=
literal|576
expr_stmt|;
name|mtus
index|[
literal|5
index|]
operator|=
literal|1024
expr_stmt|;
name|mtus
index|[
literal|6
index|]
operator|=
literal|1280
expr_stmt|;
name|mtus
index|[
literal|7
index|]
operator|=
literal|1492
expr_stmt|;
name|mtus
index|[
literal|8
index|]
operator|=
literal|1500
expr_stmt|;
name|mtus
index|[
literal|9
index|]
operator|=
literal|2002
expr_stmt|;
name|mtus
index|[
literal|10
index|]
operator|=
literal|2048
expr_stmt|;
name|mtus
index|[
literal|11
index|]
operator|=
literal|4096
expr_stmt|;
name|mtus
index|[
literal|12
index|]
operator|=
literal|4352
expr_stmt|;
name|mtus
index|[
literal|13
index|]
operator|=
literal|8192
expr_stmt|;
name|mtus
index|[
literal|14
index|]
operator|=
literal|9000
expr_stmt|;
name|mtus
index|[
literal|15
index|]
operator|=
literal|9600
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	init_cong_ctrl - initialize congestion control parameters  *	@a: the alpha values for congestion control  *	@b: the beta values for congestion control  *  *	Initialize the congestion control parameters.  */
end_comment

begin_function
specifier|static
name|void
name|__devinit
name|init_cong_ctrl
parameter_list|(
name|unsigned
name|short
modifier|*
name|a
parameter_list|,
name|unsigned
name|short
modifier|*
name|b
parameter_list|)
block|{
name|a
index|[
literal|0
index|]
operator|=
name|a
index|[
literal|1
index|]
operator|=
name|a
index|[
literal|2
index|]
operator|=
name|a
index|[
literal|3
index|]
operator|=
name|a
index|[
literal|4
index|]
operator|=
name|a
index|[
literal|5
index|]
operator|=
name|a
index|[
literal|6
index|]
operator|=
name|a
index|[
literal|7
index|]
operator|=
name|a
index|[
literal|8
index|]
operator|=
literal|1
expr_stmt|;
name|a
index|[
literal|9
index|]
operator|=
literal|2
expr_stmt|;
name|a
index|[
literal|10
index|]
operator|=
literal|3
expr_stmt|;
name|a
index|[
literal|11
index|]
operator|=
literal|4
expr_stmt|;
name|a
index|[
literal|12
index|]
operator|=
literal|5
expr_stmt|;
name|a
index|[
literal|13
index|]
operator|=
literal|6
expr_stmt|;
name|a
index|[
literal|14
index|]
operator|=
literal|7
expr_stmt|;
name|a
index|[
literal|15
index|]
operator|=
literal|8
expr_stmt|;
name|a
index|[
literal|16
index|]
operator|=
literal|9
expr_stmt|;
name|a
index|[
literal|17
index|]
operator|=
literal|10
expr_stmt|;
name|a
index|[
literal|18
index|]
operator|=
literal|14
expr_stmt|;
name|a
index|[
literal|19
index|]
operator|=
literal|17
expr_stmt|;
name|a
index|[
literal|20
index|]
operator|=
literal|21
expr_stmt|;
name|a
index|[
literal|21
index|]
operator|=
literal|25
expr_stmt|;
name|a
index|[
literal|22
index|]
operator|=
literal|30
expr_stmt|;
name|a
index|[
literal|23
index|]
operator|=
literal|35
expr_stmt|;
name|a
index|[
literal|24
index|]
operator|=
literal|45
expr_stmt|;
name|a
index|[
literal|25
index|]
operator|=
literal|60
expr_stmt|;
name|a
index|[
literal|26
index|]
operator|=
literal|80
expr_stmt|;
name|a
index|[
literal|27
index|]
operator|=
literal|100
expr_stmt|;
name|a
index|[
literal|28
index|]
operator|=
literal|200
expr_stmt|;
name|a
index|[
literal|29
index|]
operator|=
literal|300
expr_stmt|;
name|a
index|[
literal|30
index|]
operator|=
literal|400
expr_stmt|;
name|a
index|[
literal|31
index|]
operator|=
literal|500
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|b
index|[
literal|1
index|]
operator|=
name|b
index|[
literal|2
index|]
operator|=
name|b
index|[
literal|3
index|]
operator|=
name|b
index|[
literal|4
index|]
operator|=
name|b
index|[
literal|5
index|]
operator|=
name|b
index|[
literal|6
index|]
operator|=
name|b
index|[
literal|7
index|]
operator|=
name|b
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|b
index|[
literal|9
index|]
operator|=
name|b
index|[
literal|10
index|]
operator|=
literal|1
expr_stmt|;
name|b
index|[
literal|11
index|]
operator|=
name|b
index|[
literal|12
index|]
operator|=
literal|2
expr_stmt|;
name|b
index|[
literal|13
index|]
operator|=
name|b
index|[
literal|14
index|]
operator|=
name|b
index|[
literal|15
index|]
operator|=
name|b
index|[
literal|16
index|]
operator|=
literal|3
expr_stmt|;
name|b
index|[
literal|17
index|]
operator|=
name|b
index|[
literal|18
index|]
operator|=
name|b
index|[
literal|19
index|]
operator|=
name|b
index|[
literal|20
index|]
operator|=
name|b
index|[
literal|21
index|]
operator|=
literal|4
expr_stmt|;
name|b
index|[
literal|22
index|]
operator|=
name|b
index|[
literal|23
index|]
operator|=
name|b
index|[
literal|24
index|]
operator|=
name|b
index|[
literal|25
index|]
operator|=
name|b
index|[
literal|26
index|]
operator|=
name|b
index|[
literal|27
index|]
operator|=
literal|5
expr_stmt|;
name|b
index|[
literal|28
index|]
operator|=
name|b
index|[
literal|29
index|]
operator|=
literal|6
expr_stmt|;
name|b
index|[
literal|30
index|]
operator|=
name|b
index|[
literal|31
index|]
operator|=
literal|7
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The minimum additive increment value for the congestion control table */
end_comment

begin_define
define|#
directive|define
name|CC_MIN_INCR
value|2U
end_define

begin_comment
comment|/**  *	t3_load_mtus - write the MTU and congestion control HW tables  *	@adap: the adapter  *	@mtus: the unrestricted values for the MTU table  *	@alpha: the values for the congestion control alpha parameter  *	@beta: the values for the congestion control beta parameter  *	@mtu_cap: the maximum permitted effective MTU  *  *	Write the MTU table with the supplied MTUs capping each at&mtu_cap.  *	Update the high-speed congestion control table with the supplied alpha,  * 	beta, and MTUs.  */
end_comment

begin_function
name|void
name|t3_load_mtus
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|short
name|mtus
index|[
name|NMTUS
index|]
parameter_list|,
name|unsigned
name|short
name|alpha
index|[
name|NCCTRL_WIN
index|]
parameter_list|,
name|unsigned
name|short
name|beta
index|[
name|NCCTRL_WIN
index|]
parameter_list|,
name|unsigned
name|short
name|mtu_cap
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|int
name|avg_pkts
index|[
name|NCCTRL_WIN
index|]
init|=
block|{
literal|2
block|,
literal|6
block|,
literal|10
block|,
literal|14
block|,
literal|20
block|,
literal|28
block|,
literal|40
block|,
literal|56
block|,
literal|80
block|,
literal|112
block|,
literal|160
block|,
literal|224
block|,
literal|320
block|,
literal|448
block|,
literal|640
block|,
literal|896
block|,
literal|1281
block|,
literal|1792
block|,
literal|2560
block|,
literal|3584
block|,
literal|5120
block|,
literal|7168
block|,
literal|10240
block|,
literal|14336
block|,
literal|20480
block|,
literal|28672
block|,
literal|40960
block|,
literal|57344
block|,
literal|81920
block|,
literal|114688
block|,
literal|163840
block|,
literal|229376
block|}
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|w
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMTUS
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|int
name|mtu
init|=
name|min
argument_list|(
name|mtus
index|[
name|i
index|]
argument_list|,
name|mtu_cap
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|log2
init|=
name|fls
argument_list|(
name|mtu
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mtu
operator|&
operator|(
operator|(
literal|1
operator|<<
name|log2
operator|)
operator|>>
literal|2
operator|)
operator|)
condition|)
comment|/* round */
name|log2
operator|--
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MTU_TABLE
argument_list|,
operator|(
name|i
operator|<<
literal|24
operator|)
operator||
operator|(
name|log2
operator|<<
literal|16
operator|)
operator||
name|mtu
argument_list|)
expr_stmt|;
for|for
control|(
name|w
operator|=
literal|0
init|;
name|w
operator|<
name|NCCTRL_WIN
condition|;
operator|++
name|w
control|)
block|{
name|unsigned
name|int
name|inc
decl_stmt|;
name|inc
operator|=
name|max
argument_list|(
operator|(
operator|(
name|mtu
operator|-
literal|40
operator|)
operator|*
name|alpha
index|[
name|w
index|]
operator|)
operator|/
name|avg_pkts
index|[
name|w
index|]
argument_list|,
name|CC_MIN_INCR
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CCTRL_TABLE
argument_list|,
operator|(
name|i
operator|<<
literal|21
operator|)
operator||
operator|(
name|w
operator|<<
literal|16
operator|)
operator||
operator|(
name|beta
index|[
name|w
index|]
operator|<<
literal|13
operator|)
operator||
name|inc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_read_hw_mtus - returns the values in the HW MTU table  *	@adap: the adapter  *	@mtus: where to store the HW MTU values  *  *	Reads the HW MTU table.  */
end_comment

begin_function
name|void
name|t3_read_hw_mtus
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|short
name|mtus
index|[
name|NMTUS
index|]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMTUS
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MTU_TABLE
argument_list|,
literal|0xff000000
operator||
name|i
argument_list|)
expr_stmt|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_MTU_TABLE
argument_list|)
expr_stmt|;
name|mtus
index|[
name|i
index|]
operator|=
name|val
operator|&
literal|0x3fff
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_get_cong_cntl_tab - reads the congestion control table  *	@adap: the adapter  *	@incr: where to store the alpha values  *  *	Reads the additive increments programmed into the HW congestion  *	control table.  */
end_comment

begin_function
name|void
name|t3_get_cong_cntl_tab
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|short
name|incr
index|[
name|NMTUS
index|]
index|[
name|NCCTRL_WIN
index|]
parameter_list|)
block|{
name|unsigned
name|int
name|mtu
decl_stmt|,
name|w
decl_stmt|;
for|for
control|(
name|mtu
operator|=
literal|0
init|;
name|mtu
operator|<
name|NMTUS
condition|;
operator|++
name|mtu
control|)
for|for
control|(
name|w
operator|=
literal|0
init|;
name|w
operator|<
name|NCCTRL_WIN
condition|;
operator|++
name|w
control|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CCTRL_TABLE
argument_list|,
literal|0xffff0000
operator||
operator|(
name|mtu
operator|<<
literal|5
operator|)
operator||
name|w
argument_list|)
expr_stmt|;
name|incr
index|[
name|mtu
index|]
index|[
name|w
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_CCTRL_TABLE
argument_list|)
operator|&
literal|0x1fff
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_tp_get_mib_stats - read TP's MIB counters  *	@adap: the adapter  *	@tps: holds the returned counter values  *  *	Returns the values of TP's MIB counters.  */
end_comment

begin_function
name|void
name|t3_tp_get_mib_stats
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|tp_mib_stats
modifier|*
name|tps
parameter_list|)
block|{
name|t3_read_indirect
argument_list|(
name|adap
argument_list|,
name|A_TP_MIB_INDEX
argument_list|,
name|A_TP_MIB_RDATA
argument_list|,
operator|(
name|u32
operator|*
operator|)
name|tps
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tps
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_read_pace_tbl - read the pace table  *	@adap: the adapter  *	@pace_vals: holds the returned values  *  *	Returns the values of TP's pace table in nanoseconds.  */
end_comment

begin_function
name|void
name|t3_read_pace_tbl
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|pace_vals
index|[
name|NTX_SCHED
index|]
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|tick_ns
init|=
name|dack_ticks_to_usec
argument_list|(
name|adap
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTX_SCHED
condition|;
name|i
operator|++
control|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PACE_TABLE
argument_list|,
literal|0xffff0000
operator|+
name|i
argument_list|)
expr_stmt|;
name|pace_vals
index|[
name|i
index|]
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PACE_TABLE
argument_list|)
operator|*
name|tick_ns
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_set_pace_tbl - set the pace table  *	@adap: the adapter  *	@pace_vals: the pace values in nanoseconds  *	@start: index of the first entry in the HW pace table to set  *	@n: how many entries to set  *  *	Sets (a subset of the) HW pace table.  */
end_comment

begin_function
name|void
name|t3_set_pace_tbl
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
modifier|*
name|pace_vals
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|tick_ns
init|=
name|dack_ticks_to_usec
argument_list|(
name|adap
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|n
condition|;
name|n
operator|--
operator|,
name|start
operator|++
operator|,
name|pace_vals
operator|++
control|)
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_PACE_TABLE
argument_list|,
operator|(
name|start
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|*
name|pace_vals
operator|+
name|tick_ns
operator|/
literal|2
operator|)
operator|/
name|tick_ns
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ulp_region
parameter_list|(
name|adap
parameter_list|,
name|name
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|)
define|\
value|t3_write_reg((adap), A_ULPRX_ ## name ## _LLIMIT, (start)); \ 	t3_write_reg((adap), A_ULPRX_ ## name ## _ULIMIT, \ 		     (start) + (len) - 1); \ 	start += len
end_define

begin_define
define|#
directive|define
name|ulptx_region
parameter_list|(
name|adap
parameter_list|,
name|name
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|)
define|\
value|t3_write_reg((adap), A_ULPTX_ ## name ## _LLIMIT, (start)); \ 	t3_write_reg((adap), A_ULPTX_ ## name ## _ULIMIT, \ 		     (start) + (len) - 1)
end_define

begin_function
specifier|static
name|void
name|ulp_config
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
specifier|const
name|struct
name|tp_params
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|m
init|=
name|p
operator|->
name|chan_rx_size
decl_stmt|;
name|ulp_region
argument_list|(
name|adap
argument_list|,
name|ISCSI
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|chan_rx_size
operator|/
literal|8
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|adap
argument_list|,
name|TDDP
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|chan_rx_size
operator|/
literal|8
argument_list|)
expr_stmt|;
name|ulptx_region
argument_list|(
name|adap
argument_list|,
name|TPT
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|chan_rx_size
operator|/
literal|4
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|adap
argument_list|,
name|STAG
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|chan_rx_size
operator|/
literal|4
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|adap
argument_list|,
name|RQ
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|chan_rx_size
operator|/
literal|4
argument_list|)
expr_stmt|;
name|ulptx_region
argument_list|(
name|adap
argument_list|,
name|PBL
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|chan_rx_size
operator|/
literal|4
argument_list|)
expr_stmt|;
name|ulp_region
argument_list|(
name|adap
argument_list|,
name|PBL
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|chan_rx_size
operator|/
literal|4
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_ULPRX_TDDP_TAGMASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_set_proto_sram - set the contents of the protocol sram  *	@adapter: the adapter  *	@data: the protocol image  *  *	Write the contents of the protocol SRAM.  */
end_comment

begin_function
name|int
name|t3_set_proto_sram
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|u32
modifier|*
name|buf
init|=
operator|(
specifier|const
name|u32
operator|*
operator|)
name|data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROTO_SRAM_LINES
condition|;
name|i
operator|++
control|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_EMBED_OP_FIELD5
argument_list|,
name|cpu_to_be32
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_EMBED_OP_FIELD4
argument_list|,
name|cpu_to_be32
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_EMBED_OP_FIELD3
argument_list|,
name|cpu_to_be32
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_EMBED_OP_FIELD2
argument_list|,
name|cpu_to_be32
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_EMBED_OP_FIELD1
argument_list|,
name|cpu_to_be32
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_EMBED_OP_FIELD0
argument_list|,
name|i
operator|<<
literal|1
operator||
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_TP_EMBED_OP_FIELD0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  *	t3_config_trace_filter - configure one of the tracing filters  *	@adapter: the adapter  *	@tp: the desired trace filter parameters  *	@filter_index: which filter to configure  *	@invert: if set non-matching packets are traced instead of matching ones  *	@enable: whether to enable or disable the filter  *  *	Configures one of the tracing filters available in HW.  */
end_comment

begin_function
name|void
name|t3_config_trace_filter
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
specifier|const
name|struct
name|trace_params
modifier|*
name|tp
parameter_list|,
name|int
name|filter_index
parameter_list|,
name|int
name|invert
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|u32
name|addr
decl_stmt|,
name|key
index|[
literal|4
index|]
decl_stmt|,
name|mask
index|[
literal|4
index|]
decl_stmt|;
name|key
index|[
literal|0
index|]
operator|=
name|tp
operator|->
name|sport
operator||
operator|(
name|tp
operator|->
name|sip
operator|<<
literal|16
operator|)
expr_stmt|;
name|key
index|[
literal|1
index|]
operator|=
operator|(
name|tp
operator|->
name|sip
operator|>>
literal|16
operator|)
operator||
operator|(
name|tp
operator|->
name|dport
operator|<<
literal|16
operator|)
expr_stmt|;
name|key
index|[
literal|2
index|]
operator|=
name|tp
operator|->
name|dip
expr_stmt|;
name|key
index|[
literal|3
index|]
operator|=
name|tp
operator|->
name|proto
operator||
operator|(
name|tp
operator|->
name|vlan
operator|<<
literal|8
operator|)
operator||
operator|(
name|tp
operator|->
name|intf
operator|<<
literal|20
operator|)
expr_stmt|;
name|mask
index|[
literal|0
index|]
operator|=
name|tp
operator|->
name|sport_mask
operator||
operator|(
name|tp
operator|->
name|sip_mask
operator|<<
literal|16
operator|)
expr_stmt|;
name|mask
index|[
literal|1
index|]
operator|=
operator|(
name|tp
operator|->
name|sip_mask
operator|>>
literal|16
operator|)
operator||
operator|(
name|tp
operator|->
name|dport_mask
operator|<<
literal|16
operator|)
expr_stmt|;
name|mask
index|[
literal|2
index|]
operator|=
name|tp
operator|->
name|dip_mask
expr_stmt|;
name|mask
index|[
literal|3
index|]
operator|=
name|tp
operator|->
name|proto_mask
operator||
operator|(
name|tp
operator|->
name|vlan_mask
operator|<<
literal|8
operator|)
operator||
operator|(
name|tp
operator|->
name|intf_mask
operator|<<
literal|20
operator|)
expr_stmt|;
if|if
condition|(
name|invert
condition|)
name|key
index|[
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
literal|29
operator|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|key
index|[
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
literal|28
operator|)
expr_stmt|;
name|addr
operator|=
name|filter_index
condition|?
name|A_TP_RX_TRC_KEY0
else|:
name|A_TP_TX_TRC_KEY0
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|,
name|key
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|,
name|mask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|,
name|key
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|,
name|mask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|,
name|key
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|,
name|mask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|,
name|key
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|tp_wr_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|,
name|mask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_PIO_DATA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_query_trace_filter - query a tracing filter  *	@adapter: the adapter  *	@tp: the current trace filter parameters  *	@filter_index: which filter to query  *	@inverted: non-zero if the filter is inverted  *	@enabled: non-zero if the filter is enabled  *  *	Returns the current settings of the specified HW tracing filter.  */
end_comment

begin_function
name|void
name|t3_query_trace_filter
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|struct
name|trace_params
modifier|*
name|tp
parameter_list|,
name|int
name|filter_index
parameter_list|,
name|int
modifier|*
name|inverted
parameter_list|,
name|int
modifier|*
name|enabled
parameter_list|)
block|{
name|u32
name|addr
decl_stmt|,
name|key
index|[
literal|4
index|]
decl_stmt|,
name|mask
index|[
literal|4
index|]
decl_stmt|;
name|addr
operator|=
name|filter_index
condition|?
name|A_TP_RX_TRC_KEY0
else|:
name|A_TP_TX_TRC_KEY0
expr_stmt|;
name|key
index|[
literal|0
index|]
operator|=
name|tp_rd_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|)
expr_stmt|;
name|mask
index|[
literal|0
index|]
operator|=
name|tp_rd_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|)
expr_stmt|;
name|key
index|[
literal|1
index|]
operator|=
name|tp_rd_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|)
expr_stmt|;
name|mask
index|[
literal|1
index|]
operator|=
name|tp_rd_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|)
expr_stmt|;
name|key
index|[
literal|2
index|]
operator|=
name|tp_rd_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|)
expr_stmt|;
name|mask
index|[
literal|2
index|]
operator|=
name|tp_rd_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|)
expr_stmt|;
name|key
index|[
literal|3
index|]
operator|=
name|tp_rd_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
operator|++
argument_list|)
expr_stmt|;
name|mask
index|[
literal|3
index|]
operator|=
name|tp_rd_indirect
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|tp
operator|->
name|sport
operator|=
name|key
index|[
literal|0
index|]
operator|&
literal|0xffff
expr_stmt|;
name|tp
operator|->
name|sip
operator|=
operator|(
name|key
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator||
operator|(
operator|(
name|key
index|[
literal|1
index|]
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|tp
operator|->
name|dport
operator|=
name|key
index|[
literal|1
index|]
operator|>>
literal|16
expr_stmt|;
name|tp
operator|->
name|dip
operator|=
name|key
index|[
literal|2
index|]
expr_stmt|;
name|tp
operator|->
name|proto
operator|=
name|key
index|[
literal|3
index|]
operator|&
literal|0xff
expr_stmt|;
name|tp
operator|->
name|vlan
operator|=
name|key
index|[
literal|3
index|]
operator|>>
literal|8
expr_stmt|;
name|tp
operator|->
name|intf
operator|=
name|key
index|[
literal|3
index|]
operator|>>
literal|20
expr_stmt|;
name|tp
operator|->
name|sport_mask
operator|=
name|mask
index|[
literal|0
index|]
operator|&
literal|0xffff
expr_stmt|;
name|tp
operator|->
name|sip_mask
operator|=
operator|(
name|mask
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator||
operator|(
operator|(
name|mask
index|[
literal|1
index|]
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|tp
operator|->
name|dport_mask
operator|=
name|mask
index|[
literal|1
index|]
operator|>>
literal|16
expr_stmt|;
name|tp
operator|->
name|dip_mask
operator|=
name|mask
index|[
literal|2
index|]
expr_stmt|;
name|tp
operator|->
name|proto_mask
operator|=
name|mask
index|[
literal|3
index|]
operator|&
literal|0xff
expr_stmt|;
name|tp
operator|->
name|vlan_mask
operator|=
name|mask
index|[
literal|3
index|]
operator|>>
literal|8
expr_stmt|;
name|tp
operator|->
name|intf_mask
operator|=
name|mask
index|[
literal|3
index|]
operator|>>
literal|20
expr_stmt|;
operator|*
name|inverted
operator|=
name|key
index|[
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
literal|29
operator|)
expr_stmt|;
operator|*
name|enabled
operator|=
name|key
index|[
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
literal|28
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_config_sched - configure a HW traffic scheduler  *	@adap: the adapter  *	@kbps: target rate in Kbps  *	@sched: the scheduler index  *  *	Configure a Tx HW scheduler for the target rate.  */
end_comment

begin_function
name|int
name|t3_config_sched
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|kbps
parameter_list|,
name|int
name|sched
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|tps
decl_stmt|,
name|cpt
decl_stmt|,
name|bpt
decl_stmt|,
name|delta
decl_stmt|,
name|mindelta
init|=
operator|~
literal|0
decl_stmt|;
name|unsigned
name|int
name|clk
init|=
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|*
literal|1000
decl_stmt|;
name|unsigned
name|int
name|selected_cpt
init|=
literal|0
decl_stmt|,
name|selected_bpt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|kbps
operator|>
literal|0
condition|)
block|{
name|kbps
operator|*=
literal|125
expr_stmt|;
comment|/* -> bytes */
for|for
control|(
name|cpt
operator|=
literal|1
init|;
name|cpt
operator|<=
literal|255
condition|;
name|cpt
operator|++
control|)
block|{
name|tps
operator|=
name|clk
operator|/
name|cpt
expr_stmt|;
name|bpt
operator|=
operator|(
name|kbps
operator|+
name|tps
operator|/
literal|2
operator|)
operator|/
name|tps
expr_stmt|;
if|if
condition|(
name|bpt
operator|>
literal|0
operator|&&
name|bpt
operator|<=
literal|255
condition|)
block|{
name|v
operator|=
name|bpt
operator|*
name|tps
expr_stmt|;
name|delta
operator|=
name|v
operator|>=
name|kbps
condition|?
name|v
operator|-
name|kbps
else|:
name|kbps
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|delta
operator|<
name|mindelta
condition|)
block|{
name|mindelta
operator|=
name|delta
expr_stmt|;
name|selected_cpt
operator|=
name|cpt
expr_stmt|;
name|selected_bpt
operator|=
name|bpt
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|selected_cpt
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|selected_cpt
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|A_TP_TX_MOD_Q1_Q0_RATE_LIMIT
operator|-
name|sched
operator|/
literal|2
argument_list|)
expr_stmt|;
name|v
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|=
operator|(
name|v
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|selected_cpt
operator|<<
literal|16
operator|)
operator||
operator|(
name|selected_bpt
operator|<<
literal|24
operator|)
expr_stmt|;
else|else
name|v
operator|=
operator|(
name|v
operator|&
literal|0xffff0000
operator|)
operator||
name|selected_cpt
operator||
operator|(
name|selected_bpt
operator|<<
literal|8
operator|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_set_sched_ipg - set the IPG for a Tx HW packet rate scheduler  *	@adap: the adapter  *	@sched: the scheduler index  *	@ipg: the interpacket delay in tenths of nanoseconds  *  *	Set the interpacket delay for a HW packet rate scheduler.  */
end_comment

begin_function
name|int
name|t3_set_sched_ipg
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|int
name|sched
parameter_list|,
name|unsigned
name|int
name|ipg
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|addr
init|=
name|A_TP_TX_MOD_Q1_Q0_TIMER_SEPARATOR
operator|-
name|sched
operator|/
literal|2
decl_stmt|;
comment|/* convert ipg to nearest number of core clocks */
name|ipg
operator|*=
name|core_ticks_per_usec
argument_list|(
name|adap
argument_list|)
expr_stmt|;
name|ipg
operator|=
operator|(
name|ipg
operator|+
literal|5000
operator|)
operator|/
literal|10000
expr_stmt|;
if|if
condition|(
name|ipg
operator|>
literal|0xffff
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|v
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|=
operator|(
name|v
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|ipg
operator|<<
literal|16
operator|)
expr_stmt|;
else|else
name|v
operator|=
operator|(
name|v
operator|&
literal|0xffff0000
operator|)
operator||
name|ipg
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_get_tx_sched - get the configuration of a Tx HW traffic scheduler  *	@adap: the adapter  *	@sched: the scheduler index  *	@kbps: the byte rate in Kbps  *	@ipg: the interpacket delay in tenths of nanoseconds  *  *	Return the current configuration of a HW Tx scheduler.  */
end_comment

begin_function
name|void
name|t3_get_tx_sched
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|sched
parameter_list|,
name|unsigned
name|int
modifier|*
name|kbps
parameter_list|,
name|unsigned
name|int
modifier|*
name|ipg
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|addr
decl_stmt|,
name|bpt
decl_stmt|,
name|cpt
decl_stmt|;
if|if
condition|(
name|kbps
condition|)
block|{
name|addr
operator|=
name|A_TP_TX_MOD_Q1_Q0_RATE_LIMIT
operator|-
name|sched
operator|/
literal|2
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|v
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|>>=
literal|16
expr_stmt|;
name|bpt
operator|=
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|cpt
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|!
name|cpt
condition|)
operator|*
name|kbps
operator|=
literal|0
expr_stmt|;
comment|/* scheduler disabled */
else|else
block|{
name|v
operator|=
operator|(
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|*
literal|1000
operator|)
operator|/
name|cpt
expr_stmt|;
operator|*
name|kbps
operator|=
operator|(
name|v
operator|*
name|bpt
operator|)
operator|/
literal|125
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ipg
condition|)
block|{
name|addr
operator|=
name|A_TP_TX_MOD_Q1_Q0_TIMER_SEPARATOR
operator|-
name|sched
operator|/
literal|2
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|v
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TM_PIO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
operator|&
literal|1
condition|)
name|v
operator|>>=
literal|16
expr_stmt|;
name|v
operator|&=
literal|0xffff
expr_stmt|;
operator|*
name|ipg
operator|=
operator|(
literal|10000
operator|*
name|v
operator|)
operator|/
name|core_ticks_per_usec
argument_list|(
name|adap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	tp_init - configure TP  *	@adap: the adapter  *	@p: TP configuration parameters  *  *	Initializes the TP HW module.  */
end_comment

begin_function
specifier|static
name|int
name|tp_init
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
specifier|const
name|struct
name|tp_params
modifier|*
name|p
parameter_list|)
block|{
name|int
name|busy
init|=
literal|0
decl_stmt|;
name|tp_config
argument_list|(
name|adap
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|t3_set_vlan_accel
argument_list|(
name|adap
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_offload
argument_list|(
name|adap
argument_list|)
condition|)
block|{
name|tp_set_timers
argument_list|(
name|adap
argument_list|,
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_RESET
argument_list|,
name|F_FLSTINITENABLE
argument_list|)
expr_stmt|;
name|busy
operator|=
name|t3_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_TP_RESET
argument_list|,
name|F_FLSTINITENABLE
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|busy
condition|)
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"TP initialization timed out\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|busy
condition|)
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_RESET
argument_list|,
name|F_TPRESET
argument_list|)
expr_stmt|;
return|return
name|busy
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_mps_set_active_ports - configure port failover  *	@adap: the adapter  *	@port_mask: bitmap of active ports  *  *	Sets the active ports according to the supplied bitmap.  */
end_comment

begin_function
name|int
name|t3_mps_set_active_ports
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|port_mask
parameter_list|)
block|{
if|if
condition|(
name|port_mask
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|adap
operator|->
name|params
operator|.
name|nports
operator|)
operator|-
literal|1
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_MPS_CFG
argument_list|,
name|F_PORT1ACTIVE
operator||
name|F_PORT0ACTIVE
argument_list|,
name|port_mask
operator|<<
name|S_PORT0ACTIVE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * 	chan_init_hw - channel-dependent HW initialization  *	@adap: the adapter  *	@chan_map: bitmap of Tx channels being used  *  *	Perform the bits of HW initialization that are dependent on the Tx  *	channels being used.  */
end_comment

begin_function
specifier|static
name|void
name|chan_init_hw
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|chan_map
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|chan_map
operator|!=
literal|3
condition|)
block|{
comment|/* one channel */
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_ULPRX_CTL
argument_list|,
name|F_ROUND_ROBIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_ULPTX_CONFIG
argument_list|,
name|F_CFG_RR_ARB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_CFG
argument_list|,
name|F_TPRXPORTEN
operator||
name|F_ENFORCEPKT
operator||
operator|(
name|chan_map
operator|==
literal|1
condition|?
name|F_TPTXPORT0EN
operator||
name|F_PORT0ACTIVE
else|:
name|F_TPTXPORT1EN
operator||
name|F_PORT1ACTIVE
operator|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PM1_TX_CFG
argument_list|,
name|chan_map
operator|==
literal|1
condition|?
literal|0xffffffff
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan_map
operator|==
literal|2
condition|)
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_MOD_QUEUE_REQ_MAP
argument_list|,
name|V_TX_MOD_QUEUE_REQ_MAP
argument_list|(
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_MOD_QUE_TABLE
argument_list|,
operator|(
literal|12
operator|<<
literal|16
operator|)
operator||
literal|0xd9c8
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_MOD_QUE_TABLE
argument_list|,
operator|(
literal|13
operator|<<
literal|16
operator|)
operator||
literal|0xfbea
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* two channels */
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_ULPRX_CTL
argument_list|,
literal|0
argument_list|,
name|F_ROUND_ROBIN
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_ULPTX_CONFIG
argument_list|,
literal|0
argument_list|,
name|F_CFG_RR_ARB
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_ULPTX_DMA_WEIGHT
argument_list|,
name|V_D1_WEIGHT
argument_list|(
literal|16
argument_list|)
operator||
name|V_D0_WEIGHT
argument_list|(
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MPS_CFG
argument_list|,
name|F_TPTXPORT0EN
operator||
name|F_TPTXPORT1EN
operator||
name|F_TPRXPORTEN
operator||
name|F_PORT0ACTIVE
operator||
name|F_PORT1ACTIVE
operator||
name|F_ENFORCEPKT
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PM1_TX_CFG
argument_list|,
literal|0x80008000
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_TP_PC_CONFIG
argument_list|,
literal|0
argument_list|,
name|F_TXTOSQUEUEMAPMODE
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_MOD_QUEUE_REQ_MAP
argument_list|,
name|V_TX_MOD_QUEUE_REQ_MAP
argument_list|(
literal|0xaa
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_MOD_QUE_TABLE
argument_list|,
operator|(
name|i
operator|<<
literal|16
operator|)
operator||
literal|0x1010
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_MOD_QUE_TABLE
argument_list|,
operator|(
literal|12
operator|<<
literal|16
operator|)
operator||
literal|0xba98
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_TP_TX_MOD_QUE_TABLE
argument_list|,
operator|(
literal|13
operator|<<
literal|16
operator|)
operator||
literal|0xfedc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|calibrate_xgm
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_XAUI_IMP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_XAUI_IMP
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_XAUI_IMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|&
operator|(
name|F_XGM_CALFAULT
operator||
name|F_CALBUSY
operator|)
operator|)
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_XAUI_IMP
argument_list|,
name|V_XAUIIMP
argument_list|(
name|G_CALIMP
argument_list|(
name|v
argument_list|)
operator|>>
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"MAC calibration failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
name|V_RGMIIIMPPD
argument_list|(
literal|2
argument_list|)
operator||
name|V_RGMIIIMPPU
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
name|F_XGM_IMPSETUPDATE
argument_list|,
name|F_XGM_IMPSETUPDATE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|calibrate_xgm_t3b
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
name|F_CALRESET
operator||
name|F_CALUPDATE
operator||
name|V_RGMIIIMPPD
argument_list|(
literal|2
argument_list|)
operator||
name|V_RGMIIIMPPU
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
name|F_CALRESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
literal|0
argument_list|,
name|F_XGM_IMPSETUPDATE
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
name|F_XGM_IMPSETUPDATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
name|F_CALUPDATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_RGMII_IMP
argument_list|,
literal|0
argument_list|,
name|F_CALUPDATE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|mc7_timing_params
block|{
name|unsigned
name|char
name|ActToPreDly
decl_stmt|;
name|unsigned
name|char
name|ActToRdWrDly
decl_stmt|;
name|unsigned
name|char
name|PreCyc
decl_stmt|;
name|unsigned
name|char
name|RefCyc
index|[
literal|5
index|]
decl_stmt|;
name|unsigned
name|char
name|BkCyc
decl_stmt|;
name|unsigned
name|char
name|WrToRdDly
decl_stmt|;
name|unsigned
name|char
name|RdToWrDly
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Write a value to a register and check that the write completed.  These  * writes normally complete in a cycle or two, so one read should suffice.  * The very first read exists to flush the posted write to the device.  */
end_comment

begin_function
specifier|static
name|int
name|wrreg_wait
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* flush */
if|if
condition|(
operator|!
operator|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|addr
argument_list|)
operator|&
name|F_BUSY
operator|)
condition|)
return|return
literal|0
return|;
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"write to MC7 register 0x%x timed out\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mc7_init
parameter_list|(
name|struct
name|mc7
modifier|*
name|mc7
parameter_list|,
name|unsigned
name|int
name|mc7_clock
parameter_list|,
name|int
name|mem_type
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|int
name|mc7_mode
index|[]
init|=
block|{
literal|0x632
block|,
literal|0x642
block|,
literal|0x652
block|,
literal|0x432
block|,
literal|0x442
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|mc7_timing_params
name|mc7_timings
index|[]
init|=
block|{
block|{
literal|12
block|,
literal|3
block|,
literal|4
block|,
block|{
literal|20
block|,
literal|28
block|,
literal|34
block|,
literal|52
block|,
literal|0
block|}
block|,
literal|15
block|,
literal|6
block|,
literal|4
block|}
block|,
block|{
literal|12
block|,
literal|4
block|,
literal|5
block|,
block|{
literal|20
block|,
literal|28
block|,
literal|34
block|,
literal|52
block|,
literal|0
block|}
block|,
literal|16
block|,
literal|7
block|,
literal|4
block|}
block|,
block|{
literal|12
block|,
literal|5
block|,
literal|6
block|,
block|{
literal|20
block|,
literal|28
block|,
literal|34
block|,
literal|52
block|,
literal|0
block|}
block|,
literal|17
block|,
literal|8
block|,
literal|4
block|}
block|,
block|{
literal|9
block|,
literal|3
block|,
literal|4
block|,
block|{
literal|15
block|,
literal|21
block|,
literal|26
block|,
literal|39
block|,
literal|0
block|}
block|,
literal|12
block|,
literal|6
block|,
literal|4
block|}
block|,
block|{
literal|9
block|,
literal|4
block|,
literal|5
block|,
block|{
literal|15
block|,
literal|21
block|,
literal|26
block|,
literal|39
block|,
literal|0
block|}
block|,
literal|13
block|,
literal|7
block|,
literal|4
block|}
block|}
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|unsigned
name|int
name|width
decl_stmt|,
name|density
decl_stmt|,
name|slow
decl_stmt|,
name|attempts
decl_stmt|;
name|adapter_t
modifier|*
name|adapter
init|=
name|mc7
operator|->
name|adapter
decl_stmt|;
specifier|const
name|struct
name|mc7_timing_params
modifier|*
name|p
init|=
operator|&
name|mc7_timings
index|[
name|mem_type
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|mc7
operator|->
name|size
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CFG
argument_list|)
expr_stmt|;
name|slow
operator|=
name|val
operator|&
name|F_SLOW
expr_stmt|;
name|width
operator|=
name|G_WIDTH
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|density
operator|=
name|G_DEN
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CFG
argument_list|,
name|val
operator||
name|F_IFEN
argument_list|)
expr_stmt|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CFG
argument_list|)
expr_stmt|;
comment|/* flush */
name|msleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slow
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CAL
argument_list|,
name|F_SGL_CAL_EN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CAL
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CAL
argument_list|)
operator|&
operator|(
name|F_BUSY
operator||
name|F_SGL_CAL_EN
operator||
name|F_CAL_FAULT
operator|)
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"%s MC7 calibration timed out\n"
argument_list|,
name|mc7
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|out_fail
goto|;
block|}
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_PARM
argument_list|,
name|V_ACTTOPREDLY
argument_list|(
name|p
operator|->
name|ActToPreDly
argument_list|)
operator||
name|V_ACTTORDWRDLY
argument_list|(
name|p
operator|->
name|ActToRdWrDly
argument_list|)
operator||
name|V_PRECYC
argument_list|(
name|p
operator|->
name|PreCyc
argument_list|)
operator||
name|V_REFCYC
argument_list|(
name|p
operator|->
name|RefCyc
index|[
name|density
index|]
argument_list|)
operator||
name|V_BKCYC
argument_list|(
name|p
operator|->
name|BkCyc
argument_list|)
operator||
name|V_WRTORDDLY
argument_list|(
name|p
operator|->
name|WrToRdDly
argument_list|)
operator||
name|V_RDTOWRDLY
argument_list|(
name|p
operator|->
name|RdToWrDly
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CFG
argument_list|,
name|val
operator||
name|F_CLKEN
operator||
name|F_TERM150
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CFG
argument_list|)
expr_stmt|;
comment|/* flush */
if|if
condition|(
operator|!
name|slow
condition|)
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_DLL
argument_list|,
name|F_DLLENB
argument_list|,
name|F_DLLENB
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|slow
condition|?
literal|3
else|:
literal|6
expr_stmt|;
if|if
condition|(
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_PRE
argument_list|,
literal|0
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_EXT_MODE2
argument_list|,
literal|0
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_EXT_MODE3
argument_list|,
literal|0
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_EXT_MODE1
argument_list|,
name|val
argument_list|)
condition|)
goto|goto
name|out_fail
goto|;
if|if
condition|(
operator|!
name|slow
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_MODE
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_DLL
argument_list|,
name|F_DLLRST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|udelay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_PRE
argument_list|,
literal|0
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_REF
argument_list|,
literal|0
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_REF
argument_list|,
literal|0
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_MODE
argument_list|,
name|mc7_mode
index|[
name|mem_type
index|]
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_EXT_MODE1
argument_list|,
name|val
operator||
literal|0x380
argument_list|)
operator|||
name|wrreg_wait
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_EXT_MODE1
argument_list|,
name|val
argument_list|)
condition|)
goto|goto
name|out_fail
goto|;
comment|/* clock value is in KHz */
name|mc7_clock
operator|=
name|mc7_clock
operator|*
literal|7812
operator|+
name|mc7_clock
operator|/
literal|2
expr_stmt|;
comment|/* ns */
name|mc7_clock
operator|/=
literal|1000000
expr_stmt|;
comment|/* KHz->MHz, ns->us */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_REF
argument_list|,
name|F_PERREFEN
operator||
name|V_PREREFDIV
argument_list|(
name|mc7_clock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_REF
argument_list|)
expr_stmt|;
comment|/* flush */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_ECC
argument_list|,
name|F_ECCGENEN
operator||
name|F_ECCCHKEN
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BIST_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BIST_ADDR_BEG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BIST_ADDR_END
argument_list|,
operator|(
name|mc7
operator|->
name|size
operator|<<
name|width
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BIST_OP
argument_list|,
name|V_OP
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BIST_OP
argument_list|)
expr_stmt|;
comment|/* flush */
name|attempts
operator|=
literal|50
expr_stmt|;
do|do
block|{
name|msleep
argument_list|(
literal|250
argument_list|)
expr_stmt|;
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_BIST_OP
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|val
operator|&
name|F_BUSY
operator|)
operator|&&
operator|--
name|attempts
condition|)
do|;
if|if
condition|(
name|val
operator|&
name|F_BUSY
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"%s MC7 BIST timed out\n"
argument_list|,
name|mc7
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|out_fail
goto|;
block|}
comment|/* Enable normal memory accesses. */
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CFG
argument_list|,
literal|0
argument_list|,
name|F_RDY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out_fail
label|:
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|config_pcie
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|)
block|{
specifier|static
specifier|const
name|u16
name|ack_lat
index|[
literal|4
index|]
index|[
literal|6
index|]
init|=
block|{
block|{
literal|237
block|,
literal|416
block|,
literal|559
block|,
literal|1071
block|,
literal|2095
block|,
literal|4143
block|}
block|,
block|{
literal|128
block|,
literal|217
block|,
literal|289
block|,
literal|545
block|,
literal|1057
block|,
literal|2081
block|}
block|,
block|{
literal|73
block|,
literal|118
block|,
literal|154
block|,
literal|282
block|,
literal|538
block|,
literal|1050
block|}
block|,
block|{
literal|67
block|,
literal|107
block|,
literal|86
block|,
literal|150
block|,
literal|278
block|,
literal|534
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|u16
name|rpl_tmr
index|[
literal|4
index|]
index|[
literal|6
index|]
init|=
block|{
block|{
literal|711
block|,
literal|1248
block|,
literal|1677
block|,
literal|3213
block|,
literal|6285
block|,
literal|12429
block|}
block|,
block|{
literal|384
block|,
literal|651
block|,
literal|867
block|,
literal|1635
block|,
literal|3171
block|,
literal|6243
block|}
block|,
block|{
literal|219
block|,
literal|354
block|,
literal|462
block|,
literal|846
block|,
literal|1614
block|,
literal|3150
block|}
block|,
block|{
literal|201
block|,
literal|321
block|,
literal|258
block|,
literal|450
block|,
literal|834
block|,
literal|1602
block|}
block|}
decl_stmt|;
name|u16
name|val
decl_stmt|,
name|devid
decl_stmt|;
name|unsigned
name|int
name|log2_width
decl_stmt|,
name|pldsize
decl_stmt|;
name|unsigned
name|int
name|fst_trn_rx
decl_stmt|,
name|fst_trn_tx
decl_stmt|,
name|acklat
decl_stmt|,
name|rpllmt
decl_stmt|;
name|t3_os_pci_read_config_2
argument_list|(
name|adap
argument_list|,
name|adap
operator|->
name|params
operator|.
name|pci
operator|.
name|pcie_cap_addr
operator|+
name|PCI_EXP_DEVCTL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|pldsize
operator|=
operator|(
name|val
operator|&
name|PCI_EXP_DEVCTL_PAYLOAD
operator|)
operator|>>
literal|5
expr_stmt|;
comment|/* 	 * Gen2 adapter pcie bridge compatibility requires minimum 	 * Max_Read_Request_size 	 */
name|t3_os_pci_read_config_2
argument_list|(
name|adap
argument_list|,
literal|0x2
argument_list|,
operator|&
name|devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|devid
operator|==
literal|0x37
condition|)
block|{
name|t3_os_pci_write_config_2
argument_list|(
name|adap
argument_list|,
name|adap
operator|->
name|params
operator|.
name|pci
operator|.
name|pcie_cap_addr
operator|+
name|PCI_EXP_DEVCTL
argument_list|,
name|val
operator|&
operator|~
name|PCI_EXP_DEVCTL_READRQ
operator|&
operator|~
name|PCI_EXP_DEVCTL_PAYLOAD
argument_list|)
expr_stmt|;
name|pldsize
operator|=
literal|0
expr_stmt|;
block|}
name|t3_os_pci_read_config_2
argument_list|(
name|adap
argument_list|,
name|adap
operator|->
name|params
operator|.
name|pci
operator|.
name|pcie_cap_addr
operator|+
name|PCI_EXP_LNKCTL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|fst_trn_tx
operator|=
name|G_NUMFSTTRNSEQ
argument_list|(
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_PEX_CTRL0
argument_list|)
argument_list|)
expr_stmt|;
name|fst_trn_rx
operator|=
name|adap
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
condition|?
name|fst_trn_tx
else|:
name|G_NUMFSTTRNSEQRX
argument_list|(
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_MODE
argument_list|)
argument_list|)
expr_stmt|;
name|log2_width
operator|=
name|fls
argument_list|(
name|adap
operator|->
name|params
operator|.
name|pci
operator|.
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
name|acklat
operator|=
name|ack_lat
index|[
name|log2_width
index|]
index|[
name|pldsize
index|]
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|1
condition|)
comment|/* check LOsEnable */
name|acklat
operator|+=
name|fst_trn_tx
operator|*
literal|4
expr_stmt|;
name|rpllmt
operator|=
name|rpl_tmr
index|[
name|log2_width
index|]
index|[
name|pldsize
index|]
operator|+
name|fst_trn_rx
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
condition|)
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_PCIE_PEX_CTRL1
argument_list|,
name|V_T3A_ACKLAT
argument_list|(
name|M_T3A_ACKLAT
argument_list|)
argument_list|,
name|V_T3A_ACKLAT
argument_list|(
name|acklat
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_PCIE_PEX_CTRL1
argument_list|,
name|V_ACKLAT
argument_list|(
name|M_ACKLAT
argument_list|)
argument_list|,
name|V_ACKLAT
argument_list|(
name|acklat
argument_list|)
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_PCIE_PEX_CTRL0
argument_list|,
name|V_REPLAYLMT
argument_list|(
name|M_REPLAYLMT
argument_list|)
argument_list|,
name|V_REPLAYLMT
argument_list|(
name|rpllmt
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PCIE_PEX_ERR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adap
argument_list|,
name|A_PCIE_CFG
argument_list|,
literal|0
argument_list|,
name|F_ENABLELINKDWNDRST
operator||
name|F_ENABLELINKDOWNRST
operator||
name|F_PCIE_DMASTOPEN
operator||
name|F_PCIE_CLIDECEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * 	t3_init_hw - initialize and configure T3 HW modules  * 	@adapter: the adapter  * 	@fw_params: initial parameters to pass to firmware (optional)  *  *	Initialize and configure T3 HW modules.  This performs the  *	initialization steps that need to be done once after a card is reset.  *	MAC and PHY initialization is handled separarely whenever a port is  *	enabled.  *  *	@fw_params are passed to FW and their value is platform dependent.  *	Only the top 8 bits are available for use, the rest must be 0.  */
end_comment

begin_function
name|int
name|t3_init_hw
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
name|fw_params
parameter_list|)
block|{
name|int
name|err
init|=
operator|-
name|EIO
decl_stmt|,
name|attempts
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|struct
name|vpd_params
modifier|*
name|vpd
init|=
operator|&
name|adapter
operator|->
name|params
operator|.
name|vpd
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
name|calibrate_xgm_t3b
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|calibrate_xgm
argument_list|(
name|adapter
argument_list|)
condition|)
goto|goto
name|out_err
goto|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|nports
operator|>
literal|2
condition|)
name|t3_mac_init
argument_list|(
operator|&
name|adap2pinfo
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|)
operator|->
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|vpd
operator|->
name|mclk
condition|)
block|{
name|partition_mem
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc7_init
argument_list|(
operator|&
name|adapter
operator|->
name|pmrx
argument_list|,
name|vpd
operator|->
name|mclk
argument_list|,
name|vpd
operator|->
name|mem_timing
argument_list|)
operator|||
name|mc7_init
argument_list|(
operator|&
name|adapter
operator|->
name|pmtx
argument_list|,
name|vpd
operator|->
name|mclk
argument_list|,
name|vpd
operator|->
name|mem_timing
argument_list|)
operator|||
name|mc7_init
argument_list|(
operator|&
name|adapter
operator|->
name|cm
argument_list|,
name|vpd
operator|->
name|mclk
argument_list|,
name|vpd
operator|->
name|mem_timing
argument_list|)
operator|||
name|t3_mc5_init
argument_list|(
operator|&
name|adapter
operator|->
name|mc5
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nservers
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nroutes
argument_list|)
condition|)
goto|goto
name|out_err
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|clear_sge_ctxt
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
name|F_CQ
argument_list|)
condition|)
goto|goto
name|out_err
goto|;
block|}
if|if
condition|(
name|tp_init
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|tp
argument_list|)
condition|)
goto|goto
name|out_err
goto|;
ifdef|#
directive|ifdef
name|CONFIG_CHELSIO_T3_CORE
name|t3_tp_set_coalescing_size
argument_list|(
name|adapter
argument_list|,
name|min
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|sge
operator|.
name|max_pkt_size
argument_list|,
name|MAX_RX_COALESCING_LEN
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t3_tp_set_max_rxsize
argument_list|(
name|adapter
argument_list|,
name|min
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|sge
operator|.
name|max_pkt_size
argument_list|,
literal|16384U
argument_list|)
argument_list|)
expr_stmt|;
name|ulp_config
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|tp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|is_pcie
argument_list|(
name|adapter
argument_list|)
condition|)
name|config_pcie
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_PCIX_CFG
argument_list|,
literal|0
argument_list|,
name|F_DMASTOPEN
operator||
name|F_CLIDECEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|==
name|T3_REV_C
condition|)
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_ULPTX_CONFIG
argument_list|,
literal|0
argument_list|,
name|F_CFG_CQE_SOP_MASK
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PM1_RX_CFG
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PM1_RX_MODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PM1_TX_MODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chan_init_hw
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|chan_map
argument_list|)
expr_stmt|;
name|t3_sge_init
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|sge
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_T3DBG_GPIO_ACT_LOW
argument_list|,
name|calc_gpio_intr
argument_list|(
name|adapter
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_ACC_DATA
argument_list|,
name|vpd
operator|->
name|uclk
operator||
name|fw_params
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_CIM_BOOT_CFG
argument_list|,
name|V_BOOTADDR
argument_list|(
name|FW_FLASH_BOOT_ADDR
operator|>>
literal|2
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_CIM_BOOT_CFG
argument_list|)
expr_stmt|;
comment|/* flush */
name|attempts
operator|=
literal|100
expr_stmt|;
do|do
block|{
comment|/* wait for uP to initialize */
name|msleep
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_ACC_DATA
argument_list|)
operator|&&
operator|--
name|attempts
condition|)
do|;
if|if
condition|(
operator|!
name|attempts
condition|)
block|{
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"uP initialization timed out\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_err
goto|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
name|out_err
label|:
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/**  *	get_pci_mode - determine a card's PCI mode  *	@adapter: the adapter  *	@p: where to store the PCI settings  *  *	Determines a card's PCI mode and associated parameters, such as speed  *	and width.  */
end_comment

begin_function
specifier|static
name|void
name|__devinit
name|get_pci_mode
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|struct
name|pci_params
modifier|*
name|p
parameter_list|)
block|{
specifier|static
name|unsigned
name|short
name|speed_map
index|[]
init|=
block|{
literal|33
block|,
literal|66
block|,
literal|100
block|,
literal|133
block|}
decl_stmt|;
name|u32
name|pci_mode
decl_stmt|,
name|pcie_cap
decl_stmt|;
name|pcie_cap
operator|=
name|t3_os_find_pci_capability
argument_list|(
name|adapter
argument_list|,
name|PCI_CAP_ID_EXP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcie_cap
condition|)
block|{
name|u16
name|val
decl_stmt|;
name|p
operator|->
name|variant
operator|=
name|PCI_VARIANT_PCIE
expr_stmt|;
name|p
operator|->
name|pcie_cap_addr
operator|=
name|pcie_cap
expr_stmt|;
name|t3_os_pci_read_config_2
argument_list|(
name|adapter
argument_list|,
name|pcie_cap
operator|+
name|PCI_EXP_LNKSTA
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|p
operator|->
name|width
operator|=
operator|(
name|val
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
expr_stmt|;
return|return;
block|}
name|pci_mode
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PCIX_MODE
argument_list|)
expr_stmt|;
name|p
operator|->
name|speed
operator|=
name|speed_map
index|[
name|G_PCLKRANGE
argument_list|(
name|pci_mode
argument_list|)
index|]
expr_stmt|;
name|p
operator|->
name|width
operator|=
operator|(
name|pci_mode
operator|&
name|F_64BIT
operator|)
condition|?
literal|64
else|:
literal|32
expr_stmt|;
name|pci_mode
operator|=
name|G_PCIXINITPAT
argument_list|(
name|pci_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_mode
operator|==
literal|0
condition|)
name|p
operator|->
name|variant
operator|=
name|PCI_VARIANT_PCI
expr_stmt|;
elseif|else
if|if
condition|(
name|pci_mode
operator|<
literal|4
condition|)
name|p
operator|->
name|variant
operator|=
name|PCI_VARIANT_PCIX_MODE1_PARITY
expr_stmt|;
elseif|else
if|if
condition|(
name|pci_mode
operator|<
literal|8
condition|)
name|p
operator|->
name|variant
operator|=
name|PCI_VARIANT_PCIX_MODE1_ECC
expr_stmt|;
else|else
name|p
operator|->
name|variant
operator|=
name|PCI_VARIANT_PCIX_266_MODE2
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	init_link_config - initialize a link's SW state  *	@lc: structure holding the link state  *	@caps: link capabilities  *  *	Initializes the SW state maintained for each link, including the link's  *	capabilities and default speed/duplex/flow-control/autonegotiation  *	settings.  */
end_comment

begin_function
specifier|static
name|void
name|__devinit
name|init_link_config
parameter_list|(
name|struct
name|link_config
modifier|*
name|lc
parameter_list|,
name|unsigned
name|int
name|caps
parameter_list|)
block|{
name|lc
operator|->
name|supported
operator|=
name|caps
expr_stmt|;
name|lc
operator|->
name|requested_speed
operator|=
name|lc
operator|->
name|speed
operator|=
name|SPEED_INVALID
expr_stmt|;
name|lc
operator|->
name|requested_duplex
operator|=
name|lc
operator|->
name|duplex
operator|=
name|DUPLEX_INVALID
expr_stmt|;
name|lc
operator|->
name|requested_fc
operator|=
name|lc
operator|->
name|fc
operator|=
name|PAUSE_RX
operator||
name|PAUSE_TX
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|supported
operator|&
name|SUPPORTED_Autoneg
condition|)
block|{
name|lc
operator|->
name|advertising
operator|=
name|lc
operator|->
name|supported
expr_stmt|;
name|lc
operator|->
name|autoneg
operator|=
name|AUTONEG_ENABLE
expr_stmt|;
name|lc
operator|->
name|requested_fc
operator||=
name|PAUSE_AUTONEG
expr_stmt|;
block|}
else|else
block|{
name|lc
operator|->
name|advertising
operator|=
literal|0
expr_stmt|;
name|lc
operator|->
name|autoneg
operator|=
name|AUTONEG_DISABLE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	mc7_calc_size - calculate MC7 memory size  *	@cfg: the MC7 configuration  *  *	Calculates the size of an MC7 memory in bytes from the value of its  *	configuration register.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|__devinit
name|mc7_calc_size
parameter_list|(
name|u32
name|cfg
parameter_list|)
block|{
name|unsigned
name|int
name|width
init|=
name|G_WIDTH
argument_list|(
name|cfg
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|banks
init|=
operator|!
operator|!
operator|(
name|cfg
operator|&
name|F_BKS
operator|)
operator|+
literal|1
decl_stmt|;
name|unsigned
name|int
name|org
init|=
operator|!
operator|!
operator|(
name|cfg
operator|&
name|F_ORG
operator|)
operator|+
literal|1
decl_stmt|;
name|unsigned
name|int
name|density
init|=
name|G_DEN
argument_list|(
name|cfg
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|MBs
init|=
operator|(
operator|(
literal|256
operator|<<
name|density
operator|)
operator|*
name|banks
operator|)
operator|/
operator|(
name|org
operator|<<
name|width
operator|)
decl_stmt|;
return|return
name|MBs
operator|<<
literal|20
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__devinit
name|mc7_prep
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|struct
name|mc7
modifier|*
name|mc7
parameter_list|,
name|unsigned
name|int
name|base_addr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|u32
name|cfg
decl_stmt|;
name|mc7
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|mc7
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|mc7
operator|->
name|offset
operator|=
name|base_addr
operator|-
name|MC7_PMRX_BASE_ADDR
expr_stmt|;
name|cfg
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|mc7
operator|->
name|offset
operator|+
name|A_MC7_CFG
argument_list|)
expr_stmt|;
name|mc7
operator|->
name|size
operator|=
name|G_DEN
argument_list|(
name|cfg
argument_list|)
operator|==
name|M_DEN
condition|?
literal|0
else|:
name|mc7_calc_size
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|mc7
operator|->
name|width
operator|=
name|G_WIDTH
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mac_prep
parameter_list|(
name|struct
name|cmac
modifier|*
name|mac
parameter_list|,
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|u16
name|devid
decl_stmt|;
name|mac
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|mac
operator|->
name|multiport
operator|=
name|adapter
operator|->
name|params
operator|.
name|nports
operator|>
literal|2
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|multiport
condition|)
block|{
name|mac
operator|->
name|ext_port
operator|=
operator|(
name|unsigned
name|char
operator|)
name|index
expr_stmt|;
name|mac
operator|->
name|nucast
operator|=
literal|8
expr_stmt|;
block|}
else|else
name|mac
operator|->
name|nucast
operator|=
literal|1
expr_stmt|;
comment|/* Gen2 adapter uses VPD xauicfg[] to notify driver which MAC 	   is connected to each port, its suppose to be using xgmac0 for both ports 	 */
name|t3_os_pci_read_config_2
argument_list|(
name|adapter
argument_list|,
literal|0x2
argument_list|,
operator|&
name|devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|multiport
operator|||
operator|(
operator|!
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|xauicfg
index|[
literal|1
index|]
operator|&&
operator|(
name|devid
operator|==
literal|0x37
operator|)
operator|)
condition|)
name|index
operator|=
literal|0
expr_stmt|;
name|mac
operator|->
name|offset
operator|=
operator|(
name|XGMAC0_1_BASE_ADDR
operator|-
name|XGMAC0_0_BASE_ADDR
operator|)
operator|*
name|index
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
operator|&&
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_SERDES_CTRL
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|is_10G
argument_list|(
name|adapter
argument_list|)
condition|?
literal|0x2901c04
else|:
literal|0x2301c04
argument_list|)
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_XGM_PORT_CFG
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|F_ENRGMII
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	early_hw_init - HW initialization done at card detection time  *	@adapter: the adapter  *	@ai: contains information about the adapter type and properties  *  *	Perfoms the part of HW initialization that is done early on when the  *	driver first detecs the card.  Most of the HW state is initialized  *	lazily later on when a port or an offload function are first used.  */
end_comment

begin_function
name|void
name|early_hw_init
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
parameter_list|)
block|{
name|u32
name|val
init|=
name|V_PORTSPEED
argument_list|(
name|is_10G
argument_list|(
name|adapter
argument_list|)
operator|||
name|adapter
operator|->
name|params
operator|.
name|nports
operator|>
literal|2
condition|?
literal|3
else|:
literal|2
argument_list|)
decl_stmt|;
name|u32
name|gpio_out
init|=
name|ai
operator|->
name|gpio_out
decl_stmt|;
name|mi1_init
argument_list|(
name|adapter
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_I2C_CFG
argument_list|,
comment|/* set for 80KHz */
name|V_I2C_CLKDIV
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|/
literal|80
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_T3DBG_GPIO_EN
argument_list|,
name|gpio_out
operator||
name|F_GPIO0_OEN
operator||
name|F_GPIO0_OUT_VAL
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MC5_DB_SERVER_INDEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_OCO_BASE
argument_list|,
name|V_BASE1
argument_list|(
literal|0xfff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
operator|||
operator|!
name|uses_xaui
argument_list|(
name|adapter
argument_list|)
condition|)
name|val
operator||=
name|F_ENRGMII
expr_stmt|;
comment|/* Enable MAC clocks so we can access the registers */
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_PORT_CFG
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_PORT_CFG
argument_list|)
expr_stmt|;
name|val
operator||=
name|F_CLKDIVRESET_
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_PORT_CFG
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_PORT_CFG
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_PORT_CFG
argument_list|,
literal|1
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_XGM_PORT_CFG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_reset_adapter - reset the adapter  *	@adapter: the adapter  *  * 	Reset the adapter.  */
end_comment

begin_function
name|int
name|t3_reset_adapter
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|save_and_restore_pcie
init|=
name|adapter
operator|->
name|params
operator|.
name|rev
operator|<
name|T3_REV_B2
operator|&&
name|is_pcie
argument_list|(
name|adapter
argument_list|)
decl_stmt|;
name|uint16_t
name|devid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|save_and_restore_pcie
condition|)
name|t3_os_pci_save_state
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_RST
argument_list|,
name|F_CRSTWRM
operator||
name|F_CRSTWRMMODE
argument_list|)
expr_stmt|;
comment|/* 	 * Delay. Give Some time to device to reset fully. 	 * XXX The delay time should be modified. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|msleep
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|t3_os_pci_read_config_2
argument_list|(
name|adapter
argument_list|,
literal|0x00
argument_list|,
operator|&
name|devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|devid
operator|==
literal|0x1425
condition|)
break|break;
block|}
if|if
condition|(
name|devid
operator|!=
literal|0x1425
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|save_and_restore_pcie
condition|)
name|t3_os_pci_restore_state
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_parity
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|addr
decl_stmt|;
if|if
condition|(
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CONTEXT_CMD
argument_list|)
operator|&
name|F_CONTEXT_CMD_BUSY
condition|)
return|return
operator|-
name|EBUSY
return|;
for|for
control|(
name|err
operator|=
name|i
operator|=
literal|0
init|;
operator|!
name|err
operator|&&
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|err
operator|=
name|clear_sge_ctxt
argument_list|(
name|adap
argument_list|,
name|i
argument_list|,
name|F_EGRESS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0xfff0
init|;
operator|!
name|err
operator|&&
name|i
operator|<=
literal|0xffff
condition|;
name|i
operator|++
control|)
name|err
operator|=
name|clear_sge_ctxt
argument_list|(
name|adap
argument_list|,
name|i
argument_list|,
name|F_EGRESS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|err
operator|&&
name|i
operator|<
name|SGE_QSETS
condition|;
name|i
operator|++
control|)
name|err
operator|=
name|clear_sge_ctxt
argument_list|(
name|adap
argument_list|,
name|i
argument_list|,
name|F_RESPONSEQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_IBQ_DBG_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<=
name|M_IBQDBGADDR
condition|;
name|addr
operator|++
control|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_CIM_IBQ_DBG_CFG
argument_list|,
name|F_IBQDBGEN
operator||
name|F_IBQDBGWR
operator||
name|V_IBQDBGQID
argument_list|(
name|i
argument_list|)
operator||
name|V_IBQDBGADDR
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|t3_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_CIM_IBQ_DBG_CFG
argument_list|,
name|F_IBQDBGBUSY
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_prep_adapter - prepare SW and HW for operation  *	@adapter: the adapter  *	@ai: contains information about the adapter type and properties  *  *	Initialize adapter SW state for the various HW modules, set initial  *	values for some adapter tunables, take PHYs out of reset, and  *	initialize the MDIO interface.  */
end_comment

begin_function
name|int
name|__devinit
name|t3_prep_adapter
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
parameter_list|,
name|int
name|reset
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|get_pci_mode
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|pci
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|info
operator|=
name|ai
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|nports
operator|=
name|ai
operator|->
name|nports0
operator|+
name|ai
operator|->
name|nports1
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|chan_map
operator|=
operator|(
operator|!
operator|!
name|ai
operator|->
name|nports0
operator|)
operator||
operator|(
operator|!
operator|!
name|ai
operator|->
name|nports1
operator|<<
literal|1
operator|)
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|rev
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_PL_REV
argument_list|)
expr_stmt|;
comment|/* 	 * We used to only run the "adapter check task" once a second if 	 * we had PHYs which didn't support interrupts (we would check 	 * their link status once a second).  Now we check other conditions 	 * in that routine which would [potentially] impose a very high 	 * interrupt load on the system.  As such, we now always scan the 	 * adapter state once a second ... 	 */
name|adapter
operator|->
name|params
operator|.
name|linkpoll_period
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|nports
operator|>
literal|2
condition|)
name|adapter
operator|->
name|params
operator|.
name|stats_update_period
operator|=
name|VSC_STATS_ACCUM_SECS
expr_stmt|;
else|else
name|adapter
operator|->
name|params
operator|.
name|stats_update_period
operator|=
name|is_10G
argument_list|(
name|adapter
argument_list|)
condition|?
name|MAC_STATS_ACCUM_SECS
else|:
operator|(
name|MAC_STATS_ACCUM_SECS
operator|*
literal|10
operator|)
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|pci
operator|.
name|vpd_cap_addr
operator|=
name|t3_os_find_pci_capability
argument_list|(
name|adapter
argument_list|,
name|PCI_CAP_ID_VPD
argument_list|)
expr_stmt|;
name|ret
operator|=
name|get_vpd_params
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|vpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|reset
operator|&&
name|t3_reset_adapter
argument_list|(
name|adapter
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|t3_sge_prep
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|params
operator|.
name|sge
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|mclk
condition|)
block|{
name|struct
name|tp_params
modifier|*
name|p
init|=
operator|&
name|adapter
operator|->
name|params
operator|.
name|tp
decl_stmt|;
name|mc7_prep
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|pmrx
argument_list|,
name|MC7_PMRX_BASE_ADDR
argument_list|,
literal|"PMRX"
argument_list|)
expr_stmt|;
name|mc7_prep
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|pmtx
argument_list|,
name|MC7_PMTX_BASE_ADDR
argument_list|,
literal|"PMTX"
argument_list|)
expr_stmt|;
name|mc7_prep
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|cm
argument_list|,
name|MC7_CM_BASE_ADDR
argument_list|,
literal|"CM"
argument_list|)
expr_stmt|;
name|p
operator|->
name|nchan
operator|=
name|adapter
operator|->
name|params
operator|.
name|chan_map
operator|==
literal|3
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|p
operator|->
name|pmrx_size
operator|=
name|t3_mc7_size
argument_list|(
operator|&
name|adapter
operator|->
name|pmrx
argument_list|)
expr_stmt|;
name|p
operator|->
name|pmtx_size
operator|=
name|t3_mc7_size
argument_list|(
operator|&
name|adapter
operator|->
name|pmtx
argument_list|)
expr_stmt|;
name|p
operator|->
name|cm_size
operator|=
name|t3_mc7_size
argument_list|(
operator|&
name|adapter
operator|->
name|cm
argument_list|)
expr_stmt|;
name|p
operator|->
name|chan_rx_size
operator|=
name|p
operator|->
name|pmrx_size
operator|/
literal|2
expr_stmt|;
comment|/* only 1 Rx channel */
name|p
operator|->
name|chan_tx_size
operator|=
name|p
operator|->
name|pmtx_size
operator|/
name|p
operator|->
name|nchan
expr_stmt|;
name|p
operator|->
name|rx_pg_size
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
name|p
operator|->
name|tx_pg_size
operator|=
name|is_10G
argument_list|(
name|adapter
argument_list|)
condition|?
literal|64
operator|*
literal|1024
else|:
literal|16
operator|*
literal|1024
expr_stmt|;
name|p
operator|->
name|rx_num_pgs
operator|=
name|pm_num_pages
argument_list|(
name|p
operator|->
name|chan_rx_size
argument_list|,
name|p
operator|->
name|rx_pg_size
argument_list|)
expr_stmt|;
name|p
operator|->
name|tx_num_pgs
operator|=
name|pm_num_pages
argument_list|(
name|p
operator|->
name|chan_tx_size
argument_list|,
name|p
operator|->
name|tx_pg_size
argument_list|)
expr_stmt|;
name|p
operator|->
name|ntimer_qs
operator|=
name|p
operator|->
name|cm_size
operator|>=
operator|(
literal|128
operator|<<
literal|20
operator|)
operator|||
name|adapter
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|?
literal|12
else|:
literal|6
expr_stmt|;
name|p
operator|->
name|tre
operator|=
name|fls
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|/
operator|(
literal|1000
operator|/
name|TP_TMR_RES
operator|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|dack_re
operator|=
name|fls
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|cclk
operator|/
literal|10
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 100us */
block|}
name|adapter
operator|->
name|params
operator|.
name|offload
operator|=
name|t3_mc7_size
argument_list|(
operator|&
name|adapter
operator|->
name|pmrx
argument_list|)
operator|&&
name|t3_mc7_size
argument_list|(
operator|&
name|adapter
operator|->
name|pmtx
argument_list|)
operator|&&
name|t3_mc7_size
argument_list|(
operator|&
name|adapter
operator|->
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_offload
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nservers
operator|=
name|DEFAULT_NSERVERS
expr_stmt|;
comment|/* PR 6487. TOE and filtering are mutually exclusive */
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|params
operator|.
name|mc5
operator|.
name|nroutes
operator|=
literal|0
expr_stmt|;
name|t3_mc5_prep
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|mc5
argument_list|,
name|MC5_MODE_144_BIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_CHELSIO_T3_CORE
name|init_mtus
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|mtus
argument_list|)
expr_stmt|;
name|init_cong_ctrl
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|a_wnd
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|b_wnd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|early_hw_init
argument_list|(
name|adapter
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|ret
operator|=
name|init_parity
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|adapter
operator|->
name|params
operator|.
name|nports
operator|>
literal|2
operator|&&
operator|(
name|ret
operator|=
name|t3_vsc7323_init
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|nports
argument_list|)
operator|)
condition|)
return|return
name|ret
return|;
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|i
argument_list|)
block|{
name|u8
name|hw_addr
index|[
literal|6
index|]
decl_stmt|;
specifier|const
name|struct
name|port_type_info
modifier|*
name|pti
decl_stmt|;
name|struct
name|port_info
modifier|*
name|p
init|=
name|adap2pinfo
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|port_type
init|=
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|port_type
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|port_type
condition|)
block|{
if|if
condition|(
name|port_type
operator|<
name|ARRAY_SIZE
argument_list|(
name|port_types
argument_list|)
condition|)
block|{
name|pti
operator|=
operator|&
name|port_types
index|[
name|port_type
index|]
expr_stmt|;
break|break;
block|}
else|else
return|return
operator|-
name|EINVAL
return|;
block|}
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|ARRAY_SIZE
argument_list|(
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|port_type
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
name|ret
operator|=
name|pti
operator|->
name|phy_prep
argument_list|(
name|p
argument_list|,
name|ai
operator|->
name|phy_base_addr
operator|+
name|j
argument_list|,
name|ai
operator|->
name|mdio_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|mac_prep
argument_list|(
operator|&
name|p
operator|->
name|mac
argument_list|,
name|adapter
argument_list|,
name|j
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
comment|/* 		 * The VPD EEPROM stores the base Ethernet address for the 		 * card.  A port's address is derived from the base by adding 		 * the port's index to the base's low octet. 		 */
name|memcpy
argument_list|(
name|hw_addr
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|eth_base
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|hw_addr
index|[
literal|5
index|]
operator|=
name|adapter
operator|->
name|params
operator|.
name|vpd
operator|.
name|eth_base
index|[
literal|5
index|]
operator|+
name|i
expr_stmt|;
name|t3_os_set_hw_addr
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
name|hw_addr
argument_list|)
expr_stmt|;
name|init_link_config
argument_list|(
operator|&
name|p
operator|->
name|link_config
argument_list|,
name|p
operator|->
name|phy
operator|.
name|caps
argument_list|)
expr_stmt|;
name|p
operator|->
name|phy
operator|.
name|ops
operator|->
name|power_down
argument_list|(
operator|&
name|p
operator|->
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * If the PHY doesn't support interrupts for link status 		 * changes, schedule a scan of the adapter links at least 		 * once a second. 		 */
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|phy
operator|.
name|caps
operator|&
name|SUPPORTED_IRQ
operator|)
operator|&&
name|adapter
operator|->
name|params
operator|.
name|linkpoll_period
operator|>
literal|10
condition|)
name|adapter
operator|->
name|params
operator|.
name|linkpoll_period
operator|=
literal|10
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_reinit_adapter - prepare HW for operation again  *	@adapter: the adapter  *  *	Put HW in the same state as @t3_prep_adapter without any changes to  *	SW state.  This is a cut down version of @t3_prep_adapter intended  *	to be used after events that wipe out HW state but preserve SW state,  *	e.g., EEH.  The device must be reset before calling this.  */
end_comment

begin_function
name|int
name|t3_reinit_adapter
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|early_hw_init
argument_list|(
name|adap
argument_list|,
name|adap
operator|->
name|params
operator|.
name|info
argument_list|)
expr_stmt|;
name|ret
operator|=
name|init_parity
argument_list|(
name|adap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|nports
operator|>
literal|2
operator|&&
operator|(
name|ret
operator|=
name|t3_vsc7323_init
argument_list|(
name|adap
argument_list|,
name|adap
operator|->
name|params
operator|.
name|nports
argument_list|)
operator|)
condition|)
return|return
name|ret
return|;
name|for_each_port
argument_list|(
argument|adap
argument_list|,
argument|i
argument_list|)
block|{
specifier|const
name|struct
name|port_type_info
modifier|*
name|pti
decl_stmt|;
name|struct
name|port_info
modifier|*
name|p
init|=
name|adap2pinfo
argument_list|(
name|adap
argument_list|,
name|i
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|port_type
init|=
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|port_type
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|port_type
condition|)
block|{
if|if
condition|(
name|port_type
operator|<
name|ARRAY_SIZE
argument_list|(
name|port_types
argument_list|)
condition|)
block|{
name|pti
operator|=
operator|&
name|port_types
index|[
name|port_type
index|]
expr_stmt|;
break|break;
block|}
else|else
return|return
operator|-
name|EINVAL
return|;
block|}
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|ARRAY_SIZE
argument_list|(
name|adap
operator|->
name|params
operator|.
name|vpd
operator|.
name|port_type
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
name|ret
operator|=
name|pti
operator|->
name|phy_prep
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|phy
operator|.
name|addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|p
operator|->
name|phy
operator|.
name|ops
operator|->
name|power_down
argument_list|(
operator|&
name|p
operator|->
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|t3_led_ready
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_T3DBG_GPIO_EN
argument_list|,
name|F_GPIO0_OUT_VAL
argument_list|,
name|F_GPIO0_OUT_VAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_port_failover
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|val
operator|=
name|port
condition|?
name|F_PORT1ACTIVE
else|:
name|F_PORT0ACTIVE
expr_stmt|;
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_MPS_CFG
argument_list|,
name|F_PORT0ACTIVE
operator||
name|F_PORT1ACTIVE
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_failover_done
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_MPS_CFG
argument_list|,
name|F_PORT0ACTIVE
operator||
name|F_PORT1ACTIVE
argument_list|,
name|F_PORT0ACTIVE
operator||
name|F_PORT1ACTIVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_failover_clear
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|t3_set_reg_field
argument_list|(
name|adapter
argument_list|,
name|A_MPS_CFG
argument_list|,
name|F_PORT0ACTIVE
operator||
name|F_PORT1ACTIVE
argument_list|,
name|F_PORT0ACTIVE
operator||
name|F_PORT1ACTIVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_cim_hac_read
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
modifier|*
name|val
parameter_list|)
block|{
name|u32
name|v
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_wait_op_done_val
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|F_HOSTBUSY
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|10
argument_list|,
operator|&
name|v
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
operator|*
name|val
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_ACC_DATA
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_cim_hac_write
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|u32
name|v
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_ACC_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|addr
operator||=
name|F_HOSTWRITE
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_wait_op_done_val
argument_list|(
name|adapter
argument_list|,
name|A_CIM_HOST_ACC_CTRL
argument_list|,
name|F_HOSTBUSY
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|5
argument_list|,
operator|&
name|v
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|t3_get_up_la
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
modifier|*
name|stopped
parameter_list|,
name|u32
modifier|*
name|index
parameter_list|,
name|u32
modifier|*
name|size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|v
decl_stmt|,
modifier|*
name|buf
init|=
name|data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|*
name|size
operator|<
name|LA_ENTRIES
operator|*
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
name|ret
operator|=
name|t3_cim_hac_read
argument_list|(
name|adapter
argument_list|,
name|LA_CTRL
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
operator|*
name|stopped
operator|=
operator|!
operator|(
name|v
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* Freeze LA */
if|if
condition|(
operator|!
operator|*
name|stopped
condition|)
block|{
name|ret
operator|=
name|t3_cim_hac_write
argument_list|(
name|adapter
argument_list|,
name|LA_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LA_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
operator|(
name|i
operator|<<
literal|2
operator|)
operator||
operator|(
literal|1
operator|<<
literal|1
operator|)
expr_stmt|;
name|ret
operator|=
name|t3_cim_hac_write
argument_list|(
name|adapter
argument_list|,
name|LA_CTRL
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|t3_cim_hac_read
argument_list|(
name|adapter
argument_list|,
name|LA_CTRL
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|cnt
operator|=
literal|20
expr_stmt|;
while|while
condition|(
operator|(
name|v
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|&&
name|cnt
condition|)
block|{
name|udelay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|--
name|cnt
expr_stmt|;
name|ret
operator|=
name|t3_cim_hac_read
argument_list|(
name|adapter
argument_list|,
name|LA_CTRL
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|v
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
return|return
operator|-
name|EIO
return|;
name|ret
operator|=
name|t3_cim_hac_read
argument_list|(
name|adapter
argument_list|,
name|LA_DATA
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
operator|*
name|buf
operator|++
operator|=
name|v
expr_stmt|;
block|}
name|ret
operator|=
name|t3_cim_hac_read
argument_list|(
name|adapter
argument_list|,
name|LA_CTRL
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
operator|*
name|index
operator|=
operator|(
name|v
operator|>>
literal|16
operator|)
operator|+
literal|4
expr_stmt|;
operator|*
name|size
operator|=
name|LA_ENTRIES
operator|*
literal|4
expr_stmt|;
name|out
label|:
comment|/* Unfreeze LA */
name|t3_cim_hac_write
argument_list|(
name|adapter
argument_list|,
name|LA_CTRL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|t3_get_up_ioqs
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
modifier|*
name|size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|v
decl_stmt|,
modifier|*
name|buf
init|=
name|data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|*
name|size
operator|<
name|IOQ_ENTRIES
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|t3_ioq_entry
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|t3_cim_hac_read
argument_list|(
name|adapter
argument_list|,
operator|(
literal|4
operator|*
name|i
operator|)
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
operator|*
name|buf
operator|++
operator|=
name|v
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IOQ_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|base_addr
init|=
literal|0x10
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|ret
operator|=
name|t3_cim_hac_read
argument_list|(
name|adapter
argument_list|,
name|base_addr
operator|+
literal|4
operator|*
name|j
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
operator|*
name|buf
operator|++
operator|=
name|v
expr_stmt|;
block|}
block|}
operator|*
name|size
operator|=
name|IOQ_ENTRIES
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|t3_ioq_entry
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

end_unit

