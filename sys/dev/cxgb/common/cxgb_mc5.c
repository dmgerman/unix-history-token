begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright     notice, this list of conditions and the following disclaimer in the     documentation and/or other materials provided with the distribution.   3. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_regs.h>
end_include

begin_enum
enum|enum
block|{
name|IDT75P52100
init|=
literal|4
block|,
name|IDT75N43102
init|=
literal|5
block|}
enum|;
end_enum

begin_comment
comment|/* DBGI command mode */
end_comment

begin_enum
enum|enum
block|{
name|DBGI_MODE_MBUS
init|=
literal|0
block|,
name|DBGI_MODE_IDT52100
init|=
literal|5
block|}
enum|;
end_enum

begin_comment
comment|/* IDT 75P52100 commands */
end_comment

begin_define
define|#
directive|define
name|IDT_CMD_READ
value|0
end_define

begin_define
define|#
directive|define
name|IDT_CMD_WRITE
value|1
end_define

begin_define
define|#
directive|define
name|IDT_CMD_SEARCH
value|2
end_define

begin_define
define|#
directive|define
name|IDT_CMD_LEARN
value|3
end_define

begin_comment
comment|/* IDT LAR register address and value for 144-bit mode (low 32 bits) */
end_comment

begin_define
define|#
directive|define
name|IDT_LAR_ADR0
value|0x180006
end_define

begin_define
define|#
directive|define
name|IDT_LAR_MODE144
value|0xffff0000
end_define

begin_comment
comment|/* IDT SCR and SSR addresses (low 32 bits) */
end_comment

begin_define
define|#
directive|define
name|IDT_SCR_ADR0
value|0x180000
end_define

begin_define
define|#
directive|define
name|IDT_SSR0_ADR0
value|0x180002
end_define

begin_define
define|#
directive|define
name|IDT_SSR1_ADR0
value|0x180004
end_define

begin_comment
comment|/* IDT GMR base address (low 32 bits) */
end_comment

begin_define
define|#
directive|define
name|IDT_GMR_BASE_ADR0
value|0x180020
end_define

begin_comment
comment|/* IDT data and mask array base addresses (low 32 bits) */
end_comment

begin_define
define|#
directive|define
name|IDT_DATARY_BASE_ADR0
value|0
end_define

begin_define
define|#
directive|define
name|IDT_MSKARY_BASE_ADR0
value|0x80000
end_define

begin_comment
comment|/* IDT 75N43102 commands */
end_comment

begin_define
define|#
directive|define
name|IDT4_CMD_SEARCH144
value|3
end_define

begin_define
define|#
directive|define
name|IDT4_CMD_WRITE
value|4
end_define

begin_define
define|#
directive|define
name|IDT4_CMD_READ
value|5
end_define

begin_comment
comment|/* IDT 75N43102 SCR address (low 32 bits) */
end_comment

begin_define
define|#
directive|define
name|IDT4_SCR_ADR0
value|0x3
end_define

begin_comment
comment|/* IDT 75N43102 GMR base addresses (low 32 bits) */
end_comment

begin_define
define|#
directive|define
name|IDT4_GMR_BASE0
value|0x10
end_define

begin_define
define|#
directive|define
name|IDT4_GMR_BASE1
value|0x20
end_define

begin_define
define|#
directive|define
name|IDT4_GMR_BASE2
value|0x30
end_define

begin_comment
comment|/* IDT 75N43102 data and mask array base addresses (low 32 bits) */
end_comment

begin_define
define|#
directive|define
name|IDT4_DATARY_BASE_ADR0
value|0x1000000
end_define

begin_define
define|#
directive|define
name|IDT4_MSKARY_BASE_ADR0
value|0x2000000
end_define

begin_define
define|#
directive|define
name|MAX_WRITE_ATTEMPTS
value|5
end_define

begin_define
define|#
directive|define
name|MAX_ROUTES
value|2048
end_define

begin_comment
comment|/*  * Issue a command to the TCAM and wait for its completion.  The address and  * any data required by the command must have been setup by the caller.  */
end_comment

begin_function
specifier|static
name|int
name|mc5_cmd_write
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
name|cmd
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MC5_DB_DBGI_REQ_CMD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|t3_wait_op_done
argument_list|(
name|adapter
argument_list|,
name|A_MC5_DB_DBGI_RSP_STATUS
argument_list|,
name|F_DBGIRSPVALID
argument_list|,
literal|1
argument_list|,
name|MAX_WRITE_ATTEMPTS
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|dbgi_wr_addr3
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
name|v1
parameter_list|,
name|u32
name|v2
parameter_list|,
name|u32
name|v3
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MC5_DB_DBGI_REQ_ADDR0
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MC5_DB_DBGI_REQ_ADDR1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MC5_DB_DBGI_REQ_ADDR2
argument_list|,
name|v3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|dbgi_wr_data3
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
name|v1
parameter_list|,
name|u32
name|v2
parameter_list|,
name|u32
name|v3
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MC5_DB_DBGI_REQ_DATA0
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MC5_DB_DBGI_REQ_DATA1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MC5_DB_DBGI_REQ_DATA2
argument_list|,
name|v3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|dbgi_rd_rsp3
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
modifier|*
name|v1
parameter_list|,
name|u32
modifier|*
name|v2
parameter_list|,
name|u32
modifier|*
name|v3
parameter_list|)
block|{
operator|*
name|v1
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MC5_DB_DBGI_RSP_DATA0
argument_list|)
expr_stmt|;
operator|*
name|v2
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MC5_DB_DBGI_RSP_DATA1
argument_list|)
expr_stmt|;
operator|*
name|v3
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MC5_DB_DBGI_RSP_DATA2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write data to the TCAM register at address (0, 0, addr_lo) using the TCAM  * command cmd.  The data to be written must have been set up by the caller.  * Returns -1 on failure, 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|mc5_write
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|u32
name|addr_lo
parameter_list|,
name|u32
name|cmd
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_MC5_DB_DBGI_REQ_ADDR0
argument_list|,
name|addr_lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc5_cmd_write
argument_list|(
name|adapter
argument_list|,
name|cmd
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|CH_ERR
argument_list|(
name|adapter
argument_list|,
literal|"MC5 timeout writing to TCAM address 0x%x\n"
argument_list|,
name|addr_lo
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_mask_data_array
parameter_list|(
name|struct
name|mc5
modifier|*
name|mc5
parameter_list|,
name|u32
name|mask_array_base
parameter_list|,
name|u32
name|data_array_base
parameter_list|,
name|u32
name|write_cmd
parameter_list|,
name|int
name|addr_shift
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|mc5
operator|->
name|adapter
decl_stmt|;
comment|/* 	 * We need the size of the TCAM data and mask arrays in terms of 	 * 72-bit entries. 	 */
name|unsigned
name|int
name|size72
init|=
name|mc5
operator|->
name|tcam_size
decl_stmt|;
name|unsigned
name|int
name|server_base
init|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_SERVER_INDEX
argument_list|)
decl_stmt|;
if|if
condition|(
name|mc5
operator|->
name|mode
operator|==
name|MC5_MODE_144_BIT
condition|)
block|{
name|size72
operator|*=
literal|2
expr_stmt|;
comment|/* 1 144-bit entry is 2 72-bit entries */
name|server_base
operator|*=
literal|2
expr_stmt|;
block|}
comment|/* Clear the data array */
name|dbgi_wr_data3
argument_list|(
name|adap
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size72
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mc5_write
argument_list|(
name|adap
argument_list|,
name|data_array_base
operator|+
operator|(
name|i
operator|<<
name|addr_shift
operator|)
argument_list|,
name|write_cmd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Initialize the mask array. */
name|dbgi_wr_data3
argument_list|(
name|adap
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size72
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|server_base
condition|)
comment|/* entering server or routing region */
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_DBGI_REQ_DATA0
argument_list|,
name|mc5
operator|->
name|mode
operator|==
name|MC5_MODE_144_BIT
condition|?
literal|0xfffffff9
else|:
literal|0xfffffffd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc5_write
argument_list|(
name|adap
argument_list|,
name|mask_array_base
operator|+
operator|(
name|i
operator|<<
name|addr_shift
operator|)
argument_list|,
name|write_cmd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_idt52100
parameter_list|(
name|struct
name|mc5
modifier|*
name|mc5
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|mc5
operator|->
name|adapter
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_RSP_LATENCY
argument_list|,
name|V_RDLAT
argument_list|(
literal|0x15
argument_list|)
operator||
name|V_LRNLAT
argument_list|(
literal|0x15
argument_list|)
operator||
name|V_SRCHLAT
argument_list|(
literal|0x15
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_PART_ID_INDEX
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Use GMRs 14-15 for ELOOKUP, GMRs 12-13 for SYN lookups, and 	 * GMRs 8-9 for ACK- and AOPEN searches. 	 */
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_POPEN_DATA_WR_CMD
argument_list|,
name|IDT_CMD_WRITE
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_POPEN_MASK_WR_CMD
argument_list|,
name|IDT_CMD_WRITE
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_AOPEN_SRCH_CMD
argument_list|,
name|IDT_CMD_SEARCH
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_AOPEN_LRN_CMD
argument_list|,
name|IDT_CMD_LEARN
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_SYN_SRCH_CMD
argument_list|,
name|IDT_CMD_SEARCH
operator||
literal|0x6000
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_SYN_LRN_CMD
argument_list|,
name|IDT_CMD_LEARN
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_ACK_SRCH_CMD
argument_list|,
name|IDT_CMD_SEARCH
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_ACK_LRN_CMD
argument_list|,
name|IDT_CMD_LEARN
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_ILOOKUP_CMD
argument_list|,
name|IDT_CMD_SEARCH
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_ELOOKUP_CMD
argument_list|,
name|IDT_CMD_SEARCH
operator||
literal|0x7000
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_DATA_WRITE_CMD
argument_list|,
name|IDT_CMD_WRITE
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_DATA_READ_CMD
argument_list|,
name|IDT_CMD_READ
argument_list|)
expr_stmt|;
comment|/* Set DBGI command mode for IDT TCAM. */
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_DBGI_CONFIG
argument_list|,
name|DBGI_MODE_IDT52100
argument_list|)
expr_stmt|;
comment|/* Set up LAR */
name|dbgi_wr_data3
argument_list|(
name|adap
argument_list|,
name|IDT_LAR_MODE144
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc5_write
argument_list|(
name|adap
argument_list|,
name|IDT_LAR_ADR0
argument_list|,
name|IDT_CMD_WRITE
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Set up SSRs */
name|dbgi_wr_data3
argument_list|(
name|adap
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc5_write
argument_list|(
name|adap
argument_list|,
name|IDT_SSR0_ADR0
argument_list|,
name|IDT_CMD_WRITE
argument_list|)
operator|||
name|mc5_write
argument_list|(
name|adap
argument_list|,
name|IDT_SSR1_ADR0
argument_list|,
name|IDT_CMD_WRITE
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Set up GMRs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>=
literal|12
operator|&&
name|i
operator|<
literal|15
condition|)
name|dbgi_wr_data3
argument_list|(
name|adap
argument_list|,
literal|0xfffffff9
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|15
condition|)
name|dbgi_wr_data3
argument_list|(
name|adap
argument_list|,
literal|0xfffffff9
argument_list|,
literal|0xffff8007
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
else|else
name|dbgi_wr_data3
argument_list|(
name|adap
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc5_write
argument_list|(
name|adap
argument_list|,
name|IDT_GMR_BASE_ADR0
operator|+
name|i
argument_list|,
name|IDT_CMD_WRITE
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* Set up SCR */
name|dbgi_wr_data3
argument_list|(
name|adap
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc5_write
argument_list|(
name|adap
argument_list|,
name|IDT_SCR_ADR0
argument_list|,
name|IDT_CMD_WRITE
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
name|init_mask_data_array
argument_list|(
name|mc5
argument_list|,
name|IDT_MSKARY_BASE_ADR0
argument_list|,
name|IDT_DATARY_BASE_ADR0
argument_list|,
name|IDT_CMD_WRITE
argument_list|,
literal|0
argument_list|)
return|;
name|err
label|:
return|return
operator|-
name|EIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_idt43102
parameter_list|(
name|struct
name|mc5
modifier|*
name|mc5
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|mc5
operator|->
name|adapter
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_RSP_LATENCY
argument_list|,
name|adap
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
condition|?
name|V_RDLAT
argument_list|(
literal|0xd
argument_list|)
operator||
name|V_SRCHLAT
argument_list|(
literal|0x11
argument_list|)
else|:
name|V_RDLAT
argument_list|(
literal|0xd
argument_list|)
operator||
name|V_SRCHLAT
argument_list|(
literal|0x12
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Use GMRs 24-25 for ELOOKUP, GMRs 20-21 for SYN lookups, and no mask 	 * for ACK- and AOPEN searches. 	 */
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_POPEN_DATA_WR_CMD
argument_list|,
name|IDT4_CMD_WRITE
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_POPEN_MASK_WR_CMD
argument_list|,
name|IDT4_CMD_WRITE
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_AOPEN_SRCH_CMD
argument_list|,
name|IDT4_CMD_SEARCH144
operator||
literal|0x3800
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_SYN_SRCH_CMD
argument_list|,
name|IDT4_CMD_SEARCH144
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_ACK_SRCH_CMD
argument_list|,
name|IDT4_CMD_SEARCH144
operator||
literal|0x3800
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_ILOOKUP_CMD
argument_list|,
name|IDT4_CMD_SEARCH144
operator||
literal|0x3800
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_ELOOKUP_CMD
argument_list|,
name|IDT4_CMD_SEARCH144
operator||
literal|0x800
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_DATA_WRITE_CMD
argument_list|,
name|IDT4_CMD_WRITE
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_DATA_READ_CMD
argument_list|,
name|IDT4_CMD_READ
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_PART_ID_INDEX
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Set DBGI command mode for IDT TCAM. */
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_DBGI_CONFIG
argument_list|,
name|DBGI_MODE_IDT52100
argument_list|)
expr_stmt|;
comment|/* Set up GMRs */
name|dbgi_wr_data3
argument_list|(
name|adap
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|mc5_write
argument_list|(
name|adap
argument_list|,
name|IDT4_GMR_BASE0
operator|+
name|i
argument_list|,
name|IDT4_CMD_WRITE
argument_list|)
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|mc5_write
argument_list|(
name|adap
argument_list|,
name|IDT4_GMR_BASE2
operator|+
name|i
argument_list|,
name|IDT4_CMD_WRITE
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|dbgi_wr_data3
argument_list|(
name|adap
argument_list|,
literal|0xfffffff9
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc5_write
argument_list|(
name|adap
argument_list|,
name|IDT4_GMR_BASE1
argument_list|,
name|IDT4_CMD_WRITE
argument_list|)
operator|||
name|mc5_write
argument_list|(
name|adap
argument_list|,
name|IDT4_GMR_BASE1
operator|+
literal|1
argument_list|,
name|IDT4_CMD_WRITE
argument_list|)
operator|||
name|mc5_write
argument_list|(
name|adap
argument_list|,
name|IDT4_GMR_BASE1
operator|+
literal|4
argument_list|,
name|IDT4_CMD_WRITE
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|dbgi_wr_data3
argument_list|(
name|adap
argument_list|,
literal|0xfffffff9
argument_list|,
literal|0xffff8007
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc5_write
argument_list|(
name|adap
argument_list|,
name|IDT4_GMR_BASE1
operator|+
literal|5
argument_list|,
name|IDT4_CMD_WRITE
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Set up SCR */
name|dbgi_wr_data3
argument_list|(
name|adap
argument_list|,
literal|0xf0000000
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc5_write
argument_list|(
name|adap
argument_list|,
name|IDT4_SCR_ADR0
argument_list|,
name|IDT4_CMD_WRITE
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
name|init_mask_data_array
argument_list|(
name|mc5
argument_list|,
name|IDT4_MSKARY_BASE_ADR0
argument_list|,
name|IDT4_DATARY_BASE_ADR0
argument_list|,
name|IDT4_CMD_WRITE
argument_list|,
literal|1
argument_list|)
return|;
name|err
label|:
return|return
operator|-
name|EIO
return|;
block|}
end_function

begin_comment
comment|/* Put MC5 in DBGI mode. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mc5_dbgi_mode_enable
parameter_list|(
specifier|const
name|struct
name|mc5
modifier|*
name|mc5
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|mc5
operator|->
name|adapter
argument_list|,
name|A_MC5_DB_CONFIG
argument_list|,
name|V_TMMODE
argument_list|(
name|mc5
operator|->
name|mode
operator|==
name|MC5_MODE_72_BIT
argument_list|)
operator||
name|F_DBGIEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put MC5 in M-Bus mode. */
end_comment

begin_function
specifier|static
name|void
name|mc5_dbgi_mode_disable
parameter_list|(
specifier|const
name|struct
name|mc5
modifier|*
name|mc5
parameter_list|)
block|{
name|t3_write_reg
argument_list|(
name|mc5
operator|->
name|adapter
argument_list|,
name|A_MC5_DB_CONFIG
argument_list|,
name|V_TMMODE
argument_list|(
name|mc5
operator|->
name|mode
operator|==
name|MC5_MODE_72_BIT
argument_list|)
operator||
name|V_COMPEN
argument_list|(
name|mc5
operator|->
name|mode
operator|==
name|MC5_MODE_72_BIT
argument_list|)
operator||
name|V_PRTYEN
argument_list|(
name|mc5
operator|->
name|parity_enabled
argument_list|)
operator||
name|F_MBUSEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialization that requires the OS and protocol layers to already  * be intialized goes here.  */
end_comment

begin_function
name|int
name|t3_mc5_init
parameter_list|(
name|struct
name|mc5
modifier|*
name|mc5
parameter_list|,
name|unsigned
name|int
name|nservers
parameter_list|,
name|unsigned
name|int
name|nfilters
parameter_list|,
name|unsigned
name|int
name|nroutes
parameter_list|)
block|{
name|u32
name|cfg
decl_stmt|;
name|int
name|err
decl_stmt|;
name|unsigned
name|int
name|tcam_size
init|=
name|mc5
operator|->
name|tcam_size
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|mc5
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
name|nroutes
operator|>
name|MAX_ROUTES
operator|||
name|nroutes
operator|+
name|nservers
operator|+
name|nfilters
operator|>
name|tcam_size
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* Reset the TCAM */
name|cfg
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_CONFIG
argument_list|)
operator|&
operator|~
name|F_TMMODE
expr_stmt|;
name|cfg
operator||=
name|V_TMMODE
argument_list|(
name|mc5
operator|->
name|mode
operator|==
name|MC5_MODE_72_BIT
argument_list|)
operator||
name|F_TMRST
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_CONFIG
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_wait_op_done
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_CONFIG
argument_list|,
name|F_TMRDY
argument_list|,
literal|1
argument_list|,
literal|500
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"TCAM reset timed out\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_ROUTING_TABLE_INDEX
argument_list|,
name|tcam_size
operator|-
name|nroutes
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_FILTER_TABLE
argument_list|,
name|tcam_size
operator|-
name|nroutes
operator|-
name|nfilters
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_SERVER_INDEX
argument_list|,
name|tcam_size
operator|-
name|nroutes
operator|-
name|nfilters
operator|-
name|nservers
argument_list|)
expr_stmt|;
name|mc5
operator|->
name|parity_enabled
operator|=
literal|1
expr_stmt|;
comment|/* All the TCAM addresses we access have only the low 32 bits non 0 */
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_DBGI_REQ_ADDR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_DBGI_REQ_ADDR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mc5_dbgi_mode_enable
argument_list|(
name|mc5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mc5
operator|->
name|part_type
condition|)
block|{
case|case
name|IDT75P52100
case|:
name|err
operator|=
name|init_idt52100
argument_list|(
name|mc5
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDT75N43102
case|:
name|err
operator|=
name|init_idt43102
argument_list|(
name|mc5
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CH_ERR
argument_list|(
name|adap
argument_list|,
literal|"Unsupported TCAM type %d\n"
argument_list|,
name|mc5
operator|->
name|part_type
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mc5_dbgi_mode_disable
argument_list|(
name|mc5
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  *	read_mc5_range - dump a part of the memory managed by MC5  *	@mc5: the MC5 handle  *	@start: the start address for the dump  *	@n: number of 72-bit words to read  *	@buf: result buffer  *  *	Read n 72-bit words from MC5 memory from the given start location.  */
end_comment

begin_function
name|int
name|t3_read_mc5_range
parameter_list|(
specifier|const
name|struct
name|mc5
modifier|*
name|mc5
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
name|u32
modifier|*
name|buf
parameter_list|)
block|{
name|u32
name|read_cmd
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|mc5
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
name|mc5
operator|->
name|part_type
operator|==
name|IDT75P52100
condition|)
name|read_cmd
operator|=
name|IDT_CMD_READ
expr_stmt|;
elseif|else
if|if
condition|(
name|mc5
operator|->
name|part_type
operator|==
name|IDT75N43102
condition|)
name|read_cmd
operator|=
name|IDT4_CMD_READ
expr_stmt|;
else|else
return|return
operator|-
name|EINVAL
return|;
name|mc5_dbgi_mode_enable
argument_list|(
name|mc5
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_DBGI_REQ_ADDR0
argument_list|,
name|start
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc5_cmd_write
argument_list|(
name|adap
argument_list|,
name|read_cmd
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|EIO
expr_stmt|;
break|break;
block|}
name|dbgi_rd_rsp3
argument_list|(
name|adap
argument_list|,
name|buf
operator|+
literal|2
argument_list|,
name|buf
operator|+
literal|1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|3
expr_stmt|;
block|}
name|mc5_dbgi_mode_disable
argument_list|(
name|mc5
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MC5_INT_FATAL
value|(F_PARITYERR | F_REQQPARERR | F_DISPQPARERR)
end_define

begin_comment
comment|/*  * MC5 interrupt handler  */
end_comment

begin_function
name|void
name|t3_mc5_intr_handler
parameter_list|(
name|struct
name|mc5
modifier|*
name|mc5
parameter_list|)
block|{
name|adapter_t
modifier|*
name|adap
init|=
name|mc5
operator|->
name|adapter
decl_stmt|;
name|u32
name|cause
init|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_INT_CAUSE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|cause
operator|&
name|F_PARITYERR
operator|)
operator|&&
name|mc5
operator|->
name|parity_enabled
condition|)
block|{
name|CH_ALERT
argument_list|(
name|adap
argument_list|,
literal|"MC5 parity error\n"
argument_list|)
expr_stmt|;
name|mc5
operator|->
name|stats
operator|.
name|parity_err
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|F_REQQPARERR
condition|)
block|{
name|CH_ALERT
argument_list|(
name|adap
argument_list|,
literal|"MC5 request queue parity error\n"
argument_list|)
expr_stmt|;
name|mc5
operator|->
name|stats
operator|.
name|reqq_parity_err
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|F_DISPQPARERR
condition|)
block|{
name|CH_ALERT
argument_list|(
name|adap
argument_list|,
literal|"MC5 dispatch queue parity error\n"
argument_list|)
expr_stmt|;
name|mc5
operator|->
name|stats
operator|.
name|dispq_parity_err
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|&
name|F_ACTRGNFULL
condition|)
name|mc5
operator|->
name|stats
operator|.
name|active_rgn_full
operator|++
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_NFASRCHFAIL
condition|)
name|mc5
operator|->
name|stats
operator|.
name|nfa_srch_err
operator|++
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_UNKNOWNCMD
condition|)
name|mc5
operator|->
name|stats
operator|.
name|unknown_cmd
operator|++
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_DELACTEMPTY
condition|)
name|mc5
operator|->
name|stats
operator|.
name|del_act_empty
operator|++
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|MC5_INT_FATAL
condition|)
name|t3_fatal_err
argument_list|(
name|adap
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_MC5_DB_INT_CAUSE
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__devinit
name|t3_mc5_prep
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|struct
name|mc5
modifier|*
name|mc5
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
define|#
directive|define
name|K
value|* 1024
specifier|static
name|unsigned
name|int
name|tcam_part_size
index|[]
init|=
block|{
comment|/* in K 72-bit entries */
literal|64
name|K
block|,
literal|128
name|K
block|,
literal|256
name|K
block|,
literal|32
name|K
block|}
decl_stmt|;
undef|#
directive|undef
name|K
name|u32
name|cfg
init|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_MC5_DB_CONFIG
argument_list|)
decl_stmt|;
name|mc5
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|mc5
operator|->
name|mode
operator|=
operator|(
name|unsigned
name|char
operator|)
name|mode
expr_stmt|;
name|mc5
operator|->
name|part_type
operator|=
operator|(
name|unsigned
name|char
operator|)
name|G_TMTYPE
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|&
name|F_TMTYPEHI
condition|)
name|mc5
operator|->
name|part_type
operator||=
literal|4
expr_stmt|;
name|mc5
operator|->
name|tcam_size
operator|=
name|tcam_part_size
index|[
name|G_TMPARTSIZE
argument_list|(
name|cfg
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|MC5_MODE_144_BIT
condition|)
name|mc5
operator|->
name|tcam_size
operator|/=
literal|2
expr_stmt|;
block|}
end_function

end_unit

