begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright     notice, this list of conditions and the following disclaimer in the     documentation and/or other materials provided with the distribution.   3. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_common.h>
end_include

begin_comment
comment|/* VSC8211 PHY specific registers. */
end_comment

begin_enum
enum|enum
block|{
name|VSC8211_INTR_ENABLE
init|=
literal|25
block|,
name|VSC8211_INTR_STATUS
init|=
literal|26
block|,
name|VSC8211_AUX_CTRL_STAT
init|=
literal|28
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|VSC_INTR_RX_ERR
init|=
literal|1
operator|<<
literal|0
block|,
name|VSC_INTR_MS_ERR
init|=
literal|1
operator|<<
literal|1
block|,
comment|/* master/slave resolution error */
name|VSC_INTR_CABLE
init|=
literal|1
operator|<<
literal|2
block|,
comment|/* cable impairment */
name|VSC_INTR_FALSE_CARR
init|=
literal|1
operator|<<
literal|3
block|,
comment|/* false carrier */
name|VSC_INTR_MEDIA_CHG
init|=
literal|1
operator|<<
literal|4
block|,
comment|/* AMS media change */
name|VSC_INTR_RX_FIFO
init|=
literal|1
operator|<<
literal|5
block|,
comment|/* Rx FIFO over/underflow */
name|VSC_INTR_TX_FIFO
init|=
literal|1
operator|<<
literal|6
block|,
comment|/* Tx FIFO over/underflow */
name|VSC_INTR_DESCRAMBL
init|=
literal|1
operator|<<
literal|7
block|,
comment|/* descrambler lock-lost */
name|VSC_INTR_SYMBOL_ERR
init|=
literal|1
operator|<<
literal|8
block|,
comment|/* symbol error */
name|VSC_INTR_NEG_DONE
init|=
literal|1
operator|<<
literal|10
block|,
comment|/* autoneg done */
name|VSC_INTR_NEG_ERR
init|=
literal|1
operator|<<
literal|11
block|,
comment|/* autoneg error */
name|VSC_INTR_LINK_CHG
init|=
literal|1
operator|<<
literal|13
block|,
comment|/* link change */
name|VSC_INTR_ENABLE
init|=
literal|1
operator|<<
literal|15
block|,
comment|/* interrupt enable */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|CFG_CHG_INTR_MASK
value|(VSC_INTR_LINK_CHG | VSC_INTR_NEG_ERR | \ 	 		   VSC_INTR_NEG_DONE)
end_define

begin_define
define|#
directive|define
name|INTR_MASK
value|(CFG_CHG_INTR_MASK | VSC_INTR_TX_FIFO | VSC_INTR_RX_FIFO | \ 		   VSC_INTR_ENABLE)
end_define

begin_comment
comment|/* PHY specific auxiliary control& status register fields */
end_comment

begin_define
define|#
directive|define
name|S_ACSR_ACTIPHY_TMR
value|0
end_define

begin_define
define|#
directive|define
name|M_ACSR_ACTIPHY_TMR
value|0x3
end_define

begin_define
define|#
directive|define
name|V_ACSR_ACTIPHY_TMR
parameter_list|(
name|x
parameter_list|)
value|((x)<< S_ACSR_ACTIPHY_TMR)
end_define

begin_define
define|#
directive|define
name|S_ACSR_SPEED
value|3
end_define

begin_define
define|#
directive|define
name|M_ACSR_SPEED
value|0x3
end_define

begin_define
define|#
directive|define
name|G_ACSR_SPEED
parameter_list|(
name|x
parameter_list|)
value|(((x)>> S_ACSR_SPEED)& M_ACSR_SPEED)
end_define

begin_define
define|#
directive|define
name|S_ACSR_DUPLEX
value|5
end_define

begin_define
define|#
directive|define
name|F_ACSR_DUPLEX
value|(1<< S_ACSR_DUPLEX)
end_define

begin_define
define|#
directive|define
name|S_ACSR_ACTIPHY
value|6
end_define

begin_define
define|#
directive|define
name|F_ACSR_ACTIPHY
value|(1<< S_ACSR_ACTIPHY)
end_define

begin_comment
comment|/*  * Reset the PHY.  This PHY completes reset immediately so we never wait.  */
end_comment

begin_function
specifier|static
name|int
name|vsc8211_reset
parameter_list|(
name|struct
name|cphy
modifier|*
name|cphy
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
return|return
name|t3_phy_reset
argument_list|(
name|cphy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vsc8211_intr_enable
parameter_list|(
name|struct
name|cphy
modifier|*
name|cphy
parameter_list|)
block|{
return|return
name|mdio_write
argument_list|(
name|cphy
argument_list|,
literal|0
argument_list|,
name|VSC8211_INTR_ENABLE
argument_list|,
name|INTR_MASK
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vsc8211_intr_disable
parameter_list|(
name|struct
name|cphy
modifier|*
name|cphy
parameter_list|)
block|{
return|return
name|mdio_write
argument_list|(
name|cphy
argument_list|,
literal|0
argument_list|,
name|VSC8211_INTR_ENABLE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vsc8211_intr_clear
parameter_list|(
name|struct
name|cphy
modifier|*
name|cphy
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
comment|/* Clear PHY interrupts by reading the register. */
return|return
name|mdio_read
argument_list|(
name|cphy
argument_list|,
literal|0
argument_list|,
name|VSC8211_INTR_STATUS
argument_list|,
operator|&
name|val
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vsc8211_autoneg_enable
parameter_list|(
name|struct
name|cphy
modifier|*
name|cphy
parameter_list|)
block|{
return|return
name|t3_mdio_change_bits
argument_list|(
name|cphy
argument_list|,
literal|0
argument_list|,
name|MII_BMCR
argument_list|,
name|BMCR_PDOWN
operator||
name|BMCR_ISOLATE
argument_list|,
name|BMCR_ANENABLE
operator||
name|BMCR_ANRESTART
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vsc8211_autoneg_restart
parameter_list|(
name|struct
name|cphy
modifier|*
name|cphy
parameter_list|)
block|{
return|return
name|t3_mdio_change_bits
argument_list|(
name|cphy
argument_list|,
literal|0
argument_list|,
name|MII_BMCR
argument_list|,
name|BMCR_PDOWN
operator||
name|BMCR_ISOLATE
argument_list|,
name|BMCR_ANRESTART
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vsc8211_get_link_status
parameter_list|(
name|struct
name|cphy
modifier|*
name|cphy
parameter_list|,
name|int
modifier|*
name|link_ok
parameter_list|,
name|int
modifier|*
name|speed
parameter_list|,
name|int
modifier|*
name|duplex
parameter_list|,
name|int
modifier|*
name|fc
parameter_list|)
block|{
name|unsigned
name|int
name|bmcr
decl_stmt|,
name|status
decl_stmt|,
name|lpa
decl_stmt|,
name|adv
decl_stmt|;
name|int
name|err
decl_stmt|,
name|sp
init|=
operator|-
literal|1
decl_stmt|,
name|dplx
init|=
operator|-
literal|1
decl_stmt|,
name|pause
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|mdio_read
argument_list|(
name|cphy
argument_list|,
literal|0
argument_list|,
name|MII_BMCR
argument_list|,
operator|&
name|bmcr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|mdio_read
argument_list|(
name|cphy
argument_list|,
literal|0
argument_list|,
name|MII_BMSR
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|link_ok
condition|)
block|{
comment|/* 		 * BMSR_LSTATUS is latch-low, so if it is 0 we need to read it 		 * once more to get the current link state. 		 */
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|BMSR_LSTATUS
operator|)
condition|)
name|err
operator|=
name|mdio_read
argument_list|(
name|cphy
argument_list|,
literal|0
argument_list|,
name|MII_BMSR
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
operator|*
name|link_ok
operator|=
operator|(
name|status
operator|&
name|BMSR_LSTATUS
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|bmcr
operator|&
name|BMCR_ANENABLE
operator|)
condition|)
block|{
name|dplx
operator|=
operator|(
name|bmcr
operator|&
name|BMCR_FULLDPLX
operator|)
condition|?
name|DUPLEX_FULL
else|:
name|DUPLEX_HALF
expr_stmt|;
if|if
condition|(
name|bmcr
operator|&
name|BMCR_SPEED1000
condition|)
name|sp
operator|=
name|SPEED_1000
expr_stmt|;
elseif|else
if|if
condition|(
name|bmcr
operator|&
name|BMCR_SPEED100
condition|)
name|sp
operator|=
name|SPEED_100
expr_stmt|;
else|else
name|sp
operator|=
name|SPEED_10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|BMSR_ANEGCOMPLETE
condition|)
block|{
name|err
operator|=
name|mdio_read
argument_list|(
name|cphy
argument_list|,
literal|0
argument_list|,
name|VSC8211_AUX_CTRL_STAT
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|dplx
operator|=
operator|(
name|status
operator|&
name|F_ACSR_DUPLEX
operator|)
condition|?
name|DUPLEX_FULL
else|:
name|DUPLEX_HALF
expr_stmt|;
name|sp
operator|=
name|G_ACSR_SPEED
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
literal|0
condition|)
name|sp
operator|=
name|SPEED_10
expr_stmt|;
elseif|else
if|if
condition|(
name|sp
operator|==
literal|1
condition|)
name|sp
operator|=
name|SPEED_100
expr_stmt|;
else|else
name|sp
operator|=
name|SPEED_1000
expr_stmt|;
if|if
condition|(
name|fc
operator|&&
name|dplx
operator|==
name|DUPLEX_FULL
condition|)
block|{
name|err
operator|=
name|mdio_read
argument_list|(
name|cphy
argument_list|,
literal|0
argument_list|,
name|MII_LPA
argument_list|,
operator|&
name|lpa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|mdio_read
argument_list|(
name|cphy
argument_list|,
literal|0
argument_list|,
name|MII_ADVERTISE
argument_list|,
operator|&
name|adv
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|lpa
operator|&
name|adv
operator|&
name|ADVERTISE_PAUSE_CAP
condition|)
name|pause
operator|=
name|PAUSE_RX
operator||
name|PAUSE_TX
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|lpa
operator|&
name|ADVERTISE_PAUSE_CAP
operator|)
operator|&&
operator|(
name|lpa
operator|&
name|ADVERTISE_PAUSE_ASYM
operator|)
operator|&&
operator|(
name|adv
operator|&
name|ADVERTISE_PAUSE_ASYM
operator|)
condition|)
name|pause
operator|=
name|PAUSE_TX
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|lpa
operator|&
name|ADVERTISE_PAUSE_ASYM
operator|)
operator|&&
operator|(
name|adv
operator|&
name|ADVERTISE_PAUSE_CAP
operator|)
condition|)
name|pause
operator|=
name|PAUSE_RX
expr_stmt|;
block|}
block|}
if|if
condition|(
name|speed
condition|)
operator|*
name|speed
operator|=
name|sp
expr_stmt|;
if|if
condition|(
name|duplex
condition|)
operator|*
name|duplex
operator|=
name|dplx
expr_stmt|;
if|if
condition|(
name|fc
condition|)
operator|*
name|fc
operator|=
name|pause
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vsc8211_power_down
parameter_list|(
name|struct
name|cphy
modifier|*
name|cphy
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
return|return
name|t3_mdio_change_bits
argument_list|(
name|cphy
argument_list|,
literal|0
argument_list|,
name|MII_BMCR
argument_list|,
name|BMCR_PDOWN
argument_list|,
name|enable
condition|?
name|BMCR_PDOWN
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vsc8211_intr_handler
parameter_list|(
name|struct
name|cphy
modifier|*
name|cphy
parameter_list|)
block|{
name|unsigned
name|int
name|cause
decl_stmt|;
name|int
name|err
decl_stmt|,
name|cphy_cause
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|mdio_read
argument_list|(
name|cphy
argument_list|,
literal|0
argument_list|,
name|VSC8211_INTR_STATUS
argument_list|,
operator|&
name|cause
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|cause
operator|&=
name|INTR_MASK
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|CFG_CHG_INTR_MASK
condition|)
name|cphy_cause
operator||=
name|cphy_cause_link_change
expr_stmt|;
if|if
condition|(
name|cause
operator|&
operator|(
name|VSC_INTR_RX_FIFO
operator||
name|VSC_INTR_TX_FIFO
operator|)
condition|)
name|cphy_cause
operator||=
name|cphy_cause_fifo_error
expr_stmt|;
return|return
name|cphy_cause
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|C99_NOT_SUPPORTED
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|cphy_ops
name|vsc8211_ops
init|=
block|{
name|NULL
block|,
name|vsc8211_reset
block|,
name|vsc8211_intr_enable
block|,
name|vsc8211_intr_disable
block|,
name|vsc8211_intr_clear
block|,
name|vsc8211_intr_handler
block|,
name|vsc8211_autoneg_enable
block|,
name|vsc8211_autoneg_restart
block|,
name|t3_phy_advertise
block|,
name|NULL
block|,
name|t3_set_phy_speed_duplex
block|,
name|vsc8211_get_link_status
block|,
name|vsc8211_power_down
block|, }
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|cphy_ops
name|vsc8211_ops
init|=
block|{
operator|.
name|reset
operator|=
name|vsc8211_reset
block|,
operator|.
name|intr_enable
operator|=
name|vsc8211_intr_enable
block|,
operator|.
name|intr_disable
operator|=
name|vsc8211_intr_disable
block|,
operator|.
name|intr_clear
operator|=
name|vsc8211_intr_clear
block|,
operator|.
name|intr_handler
operator|=
name|vsc8211_intr_handler
block|,
operator|.
name|autoneg_enable
operator|=
name|vsc8211_autoneg_enable
block|,
operator|.
name|autoneg_restart
operator|=
name|vsc8211_autoneg_restart
block|,
operator|.
name|advertise
operator|=
name|t3_phy_advertise
block|,
operator|.
name|set_speed_duplex
operator|=
name|t3_set_phy_speed_duplex
block|,
operator|.
name|get_link_status
operator|=
name|vsc8211_get_link_status
block|,
operator|.
name|power_down
operator|=
name|vsc8211_power_down
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|t3_vsc8211_phy_prep
parameter_list|(
name|struct
name|cphy
modifier|*
name|phy
parameter_list|,
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|phy_addr
parameter_list|,
specifier|const
name|struct
name|mdio_ops
modifier|*
name|mdio_ops
parameter_list|)
block|{
name|cphy_init
argument_list|(
name|phy
argument_list|,
name|adapter
argument_list|,
name|phy_addr
argument_list|,
operator|&
name|vsc8211_ops
argument_list|,
name|mdio_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

