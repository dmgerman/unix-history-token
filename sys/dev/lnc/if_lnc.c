begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994-2000  *	Paul Richards.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    verbatim and that no modifications are made prior to this  *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name Paul Richards may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY PAUL RICHARDS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL PAUL RICHARDS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/* #define DIAGNOSTIC #define DEBUG  *  * TODO ----  *  * Check all the XXX comments -- some of them are just things I've left  * unfinished rather than "difficult" problems that were hacked around.  *  * Check log settings.  *  * Check how all the arpcom flags get set and used.  *  * Re-inline and re-static all routines after debugging.  *  * Remember to assign iobase in SHMEM probe routines.  *  * Replace all occurences of LANCE-controller-card etc in prints by the name  * strings of the appropriate type -- nifty window dressing  *  * Add DEPCA support -- mostly done.  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_comment
comment|/* Some defines that should really be in generic locations */
end_comment

begin_define
define|#
directive|define
name|FCS_LEN
value|4
end_define

begin_define
define|#
directive|define
name|MULTICAST_FILTER_LEN
value|8
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/lnc/if_lncvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/lnc/if_lncreg.h>
end_include

begin_decl_stmt
name|devclass_t
name|lnc_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|nic_ident
index|[]
init|=
block|{
literal|"Unknown"
block|,
literal|"BICC"
block|,
literal|"NE2100"
block|,
literal|"DEPCA"
block|,
literal|"CNET98S"
block|,
comment|/* PC-98 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|ic_ident
index|[]
init|=
block|{
literal|"Unknown"
block|,
literal|"LANCE"
block|,
literal|"C-LANCE"
block|,
literal|"PCnet-ISA"
block|,
literal|"PCnet-ISA+"
block|,
literal|"PCnet-ISA II"
block|,
literal|"PCnet-32 VL-Bus"
block|,
literal|"PCnet-PCI"
block|,
literal|"PCnet-PCI II"
block|,
literal|"PCnet-FAST"
block|,
literal|"PCnet-FAST+"
block|,
literal|"PCnet-Home"
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|lnc_setladrf
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lnc_reset
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lnc_free_mbufs
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|alloc_mbuf_cluster
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|host_ring_entry
modifier|*
name|desc
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|chain_mbufs
argument_list|(
argument|struct lnc_softc *sc
argument_list|,
argument|int start_of_packet
argument_list|,
argument|int pkt_len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|mbuf_packet
argument_list|(
argument|struct lnc_softc *sc
argument_list|,
argument|int start_of_packet
argument_list|,
argument|int pkt_len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|void
name|lnc_rint
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|lnc_tint
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lnc_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|mbuf_to_buffer
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|chain_to_cluster
argument_list|(
expr|struct
name|mbuf
operator|*
name|m
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|lnc_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lnc_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lnc_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
name|void
name|lnc_dump_state
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mbuf_dump_chain
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|u_short
name|read_csr
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
name|lnc_outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|lnc_inw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|write_csr
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|port
parameter_list|,
name|u_short
name|val
parameter_list|)
block|{
name|lnc_outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|lnc_outw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|write_bcr
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|port
parameter_list|,
name|u_short
name|val
parameter_list|)
block|{
name|lnc_outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|lnc_outw
argument_list|(
name|sc
operator|->
name|bdp
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_short
name|read_bcr
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
name|lnc_outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|lnc_inw
argument_list|(
name|sc
operator|->
name|bdp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lance_probe
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|STOP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lnc_inw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|)
operator|&
name|STOP
operator|)
operator|&&
operator|!
operator|(
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR3
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Check to see if it's a C-LANCE. For the LANCE the INEA bit 		 * cannot be set while the STOP bit is. This restriction is 		 * removed for the C-LANCE. 		 */
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|INEA
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
operator|&
name|INEA
condition|)
return|return
operator|(
name|C_LANCE
operator|)
return|;
else|else
return|return
operator|(
name|LANCE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|UNKNOWN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_long
name|ether_crc
parameter_list|(
specifier|const
name|u_char
modifier|*
name|ether_addr
parameter_list|)
block|{
define|#
directive|define
name|POLYNOMIAL
value|0xEDB88320UL
name|u_char
name|i
decl_stmt|,
name|j
decl_stmt|,
name|addr
decl_stmt|;
name|u_int
name|crc
init|=
literal|0xFFFFFFFFUL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
operator|*
name|ether_addr
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MULTICAST_FILTER_LEN
condition|;
name|j
operator|++
control|)
block|{
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|1
operator|)
operator|^
operator|(
operator|(
operator|(
name|crc
operator|^
name|addr
operator|)
operator|&
literal|1
operator|)
condition|?
name|POLYNOMIAL
else|:
literal|0
operator|)
expr_stmt|;
name|addr
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|crc
return|;
undef|#
directive|undef
name|POLYNOMIAL
block|}
end_function

begin_function
name|void
name|lnc_release_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|lnc_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|irqres
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irqres
argument_list|,
name|sc
operator|->
name|intrhand
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqrid
argument_list|,
name|sc
operator|->
name|irqres
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|portres
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|portrid
argument_list|,
name|sc
operator|->
name|portres
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|drqres
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|sc
operator|->
name|drqrid
argument_list|,
name|sc
operator|->
name|drqres
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dmat
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|dmamap
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|dmat
argument_list|,
name|sc
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|dmat
argument_list|,
name|sc
operator|->
name|recv_ring
argument_list|,
name|sc
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|dmat
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set up the logical address filter for multicast packets  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|lnc_setladrf
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|u_long
name|index
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MULTICAST_FILTER_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|init_block
operator|->
name|ladrf
index|[
name|i
index|]
operator|=
literal|0xFF
expr_stmt|;
return|return;
block|}
comment|/* 	 * For each multicast address, calculate a crc for that address and 	 * then use the high order 6 bits of the crc as a hash code where 	 * bits 3-5 select the byte of the address filter and bits 0-2 select 	 * the bit within that byte. 	 */
name|bzero
argument_list|(
name|sc
operator|->
name|init_block
operator|->
name|ladrf
argument_list|,
name|MULTICAST_FILTER_LEN
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|index
operator|=
name|ether_crc
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
operator|>>
literal|26
expr_stmt|;
name|sc
operator|->
name|init_block
operator|->
name|ladrf
index|[
name|index
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|index
operator|&
literal|7
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|lnc_stop
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|STOP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lnc_reset
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|lnc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lnc_free_mbufs
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * We rely on other routines to keep the buff.mbuf field valid. If 	 * it's not NULL then we assume it points to an allocated mbuf. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|mbuf
condition|)
name|m_free
argument_list|(
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|mbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|mbuf
condition|)
name|m_free
argument_list|(
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mbuf_count
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|mbufs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|alloc_mbuf_cluster
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|host_ring_entry
modifier|*
name|desc
parameter_list|)
block|{
specifier|register
name|struct
name|mds
modifier|*
name|md
init|=
name|desc
operator|->
name|md
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
literal|0
decl_stmt|;
name|int
name|addr
decl_stmt|;
comment|/* Try and get cluster off local cache */
if|if
condition|(
name|sc
operator|->
name|mbuf_count
condition|)
block|{
name|sc
operator|->
name|mbuf_count
operator|--
expr_stmt|;
name|m
operator|=
name|sc
operator|->
name|mbufs
expr_stmt|;
name|sc
operator|->
name|mbufs
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
comment|/* XXX m->m_data = m->m_ext.ext_buf;*/
block|}
else|else
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|desc
operator|->
name|buff
operator|.
name|mbuf
operator|=
name|m
expr_stmt|;
name|addr
operator|=
name|kvtop
argument_list|(
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|md
operator|->
name|md0
operator|=
name|addr
expr_stmt|;
name|md
operator|->
name|md1
operator|=
operator|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
name|OWN
expr_stmt|;
name|md
operator|->
name|md2
operator|=
operator|-
call|(
name|short
call|)
argument_list|(
name|MCLBYTES
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|pkthdr
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|md3
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|chain_mbufs
argument_list|(
argument|struct lnc_softc *sc
argument_list|,
argument|int start_of_packet
argument_list|,
argument|int pkt_len
argument_list|)
block|{ 	struct
name|mbuf
operator|*
name|head
block|,
operator|*
name|m
block|; 	struct
name|host_ring_entry
operator|*
name|desc
block|;
comment|/* 	 * Turn head into a pkthdr mbuf -- 	 * assumes a pkthdr type mbuf was 	 * allocated to the descriptor 	 * originally. 	 */
name|desc
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|start_of_packet
block|;
name|head
operator|=
name|desc
operator|->
name|buff
operator|.
name|mbuf
block|;
name|head
operator|->
name|m_flags
operator||=
name|M_PKTHDR
block|;
name|bzero
argument_list|(
operator|&
name|head
operator|->
name|m_pkthdr
argument_list|,
sizeof|sizeof
argument_list|(
name|head
operator|->
name|m_pkthdr
argument_list|)
argument_list|)
block|;
name|m
operator|=
name|head
block|;
do|do
block|{
name|m
operator|=
name|desc
operator|->
name|buff
operator|.
name|mbuf
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
operator|(
name|MCLBYTES
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|pkthdr
argument_list|)
operator|)
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
name|pkt_len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|alloc_mbuf_cluster
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|)
condition|)
return|return
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
operator|)
return|;
name|INC_MD_PTR
argument_list|(
argument|start_of_packet
argument_list|,
argument|sc->nrdre
argument_list|)
name|desc
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|start_of_packet
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|desc
operator|->
name|buff
operator|.
name|mbuf
expr_stmt|;
block|}
end_expr_stmt

begin_while
while|while
condition|(
name|start_of_packet
operator|!=
name|sc
operator|->
name|recv_next
condition|)
empty_stmt|;
end_while

begin_expr_stmt
name|m
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|head
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|struct
name|mbuf
modifier|*
name|mbuf_packet
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|int
name|start_of_packet
parameter_list|,
name|int
name|pkt_len
parameter_list|)
block|{
name|struct
name|host_ring_entry
modifier|*
name|start
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|head
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_prev
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|,
modifier|*
name|mbuf_data
decl_stmt|;
name|short
name|blen
decl_stmt|;
name|int
name|amount
decl_stmt|;
comment|/* Get a pkthdr mbuf for the start of packet */
name|MGETHDR
argument_list|(
name|head
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|drop_packet
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m
operator|=
name|head
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|start_of_packet
expr_stmt|;
comment|/*blen = -(start->md->md2);*/
name|blen
operator|=
name|RECVBUFSIZE
expr_stmt|;
comment|/* XXX More PCnet-32 crap */
name|data
operator|=
name|start
operator|->
name|buff
operator|.
name|data
expr_stmt|;
name|mbuf_data
operator|=
name|m
operator|->
name|m_data
expr_stmt|;
while|while
condition|(
name|start_of_packet
operator|!=
name|sc
operator|->
name|recv_next
condition|)
block|{
comment|/* 		 * If the data left fits in a single buffer then set 		 * blen to the size of the data left. 		 */
if|if
condition|(
name|pkt_len
operator|<
name|blen
condition|)
name|blen
operator|=
name|pkt_len
expr_stmt|;
comment|/* 		 * amount is least of data in current ring buffer and 		 * amount of space left in current mbuf. 		 */
name|amount
operator|=
name|min
argument_list|(
name|blen
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
operator|==
literal|0
condition|)
block|{
comment|/* mbuf must be empty */
name|m_prev
operator|=
name|m
expr_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|m_freem
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pkt_len
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m_prev
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|amount
operator|=
name|min
argument_list|(
name|blen
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|mbuf_data
operator|=
name|m
operator|->
name|m_data
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|data
argument_list|,
name|mbuf_data
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|blen
operator|-=
name|amount
expr_stmt|;
name|pkt_len
operator|-=
name|amount
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|amount
expr_stmt|;
name|data
operator|+=
name|amount
expr_stmt|;
name|mbuf_data
operator|+=
name|amount
expr_stmt|;
if|if
condition|(
name|blen
operator|==
literal|0
condition|)
block|{
name|start
operator|->
name|md
operator|->
name|md1
operator|&=
name|HADR
expr_stmt|;
name|start
operator|->
name|md
operator|->
name|md1
operator||=
name|OWN
expr_stmt|;
name|start
operator|->
name|md
operator|->
name|md2
operator|=
operator|-
name|RECVBUFSIZE
expr_stmt|;
comment|/* XXX - shouldn't be necessary */
name|INC_MD_PTR
argument_list|(
argument|start_of_packet
argument_list|,
argument|sc->nrdre
argument_list|)
name|start
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|start_of_packet
expr_stmt|;
name|data
operator|=
name|start
operator|->
name|buff
operator|.
name|data
expr_stmt|;
comment|/*blen = -(start->md->md2);*/
name|blen
operator|=
name|RECVBUFSIZE
expr_stmt|;
comment|/* XXX More PCnet-32 crap */
block|}
block|}
return|return
operator|(
name|head
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|lnc_rint
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|host_ring_entry
modifier|*
name|next
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|int
name|start_of_packet
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|head
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|lookahead
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|pkt_len
decl_stmt|;
comment|/* 	 * The LANCE will issue a RINT interrupt when the ownership of the 	 * last buffer of a receive packet has been relinquished by the LANCE. 	 * Therefore, it can be assumed that a complete packet can be found 	 * before hitting buffers that are still owned by the LANCE, if not 	 * then there is a bug in the driver that is causing the descriptors 	 * to get out of sync. 	 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|sc
operator|->
name|recv_next
operator|)
operator|->
name|md
operator|->
name|md1
operator|&
name|OWN
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Receive interrupt with buffer still owned by controller -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|sc
operator|->
name|recv_next
operator|)
operator|->
name|md
operator|->
name|md1
operator|&
name|STP
operator|)
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Receive interrupt but not start of packet -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|lookahead
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|sc
operator|->
name|recv_next
expr_stmt|;
while|while
condition|(
operator|(
name|flags
operator|=
name|next
operator|->
name|md
operator|->
name|md1
operator|)
operator|&
name|STP
condition|)
block|{
comment|/* Make a note of the start of the packet */
name|start_of_packet
operator|=
name|sc
operator|->
name|recv_next
expr_stmt|;
comment|/* 		 * Find the end of the packet. Even if not data chaining, 		 * jabber packets can overrun into a second descriptor. 	 	 * If there is no error, then the ENP flag is set in the last 		 * descriptor of the packet. If there is an error then the ERR 		 * flag will be set in the descriptor where the error occured. 		 * Therefore, to find the last buffer of a packet we search for 		 * either ERR or ENP. 		 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|ENP
operator||
name|MDERR
operator|)
operator|)
condition|)
block|{
do|do
block|{
name|INC_MD_PTR
argument_list|(
argument|sc->recv_next
argument_list|,
argument|sc->nrdre
argument_list|)
name|next
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|sc
operator|->
name|recv_next
expr_stmt|;
name|flags
operator|=
name|next
operator|->
name|md
operator|->
name|md1
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|STP
operator||
name|OWN
operator||
name|ENP
operator||
name|MDERR
operator|)
operator|)
condition|)
do|;
if|if
condition|(
name|flags
operator|&
name|STP
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Start of packet found before end of previous in receive ring -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flags
operator|&
name|OWN
condition|)
block|{
if|if
condition|(
name|lookahead
condition|)
block|{
comment|/* 					 * Looked ahead into a packet still 					 * being received 					 */
name|sc
operator|->
name|recv_next
operator|=
name|start_of_packet
expr_stmt|;
break|break;
block|}
else|else
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: End of received packet not found-- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|pkt_len
operator|=
operator|(
name|next
operator|->
name|md
operator|->
name|md3
operator|&
name|MCNT
operator|)
operator|-
name|FCS_LEN
expr_stmt|;
comment|/* Move pointer onto start of next packet */
name|INC_MD_PTR
argument_list|(
argument|sc->recv_next
argument_list|,
argument|sc->nrdre
argument_list|)
name|next
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|sc
operator|->
name|recv_next
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MDERR
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|RBUFF
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|rbuff
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Receive buffer error\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|OFLO
condition|)
block|{
comment|/* OFLO only valid if ENP is not set */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ENP
operator|)
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|oflo
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Receive overflow error \n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|ENP
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * FRAM and CRC are valid only if ENP 				 * is set and OFLO is not. 				 */
if|if
condition|(
name|flags
operator|&
name|FRAM
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|fram
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Framing error\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* 					 * FRAM is only set if there's a CRC 					 * error so avoid multiple messages 					 */
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|CRC
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|crc
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Receive CRC error\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Drop packet */
name|LNCSTATS
argument_list|(
argument|rerr
argument_list|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
while|while
condition|(
name|start_of_packet
operator|!=
name|sc
operator|->
name|recv_next
condition|)
block|{
name|start
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|start_of_packet
expr_stmt|;
name|start
operator|->
name|md
operator|->
name|md2
operator|=
operator|-
name|RECVBUFSIZE
expr_stmt|;
comment|/* XXX - shouldn't be necessary */
name|start
operator|->
name|md
operator|->
name|md1
operator|&=
name|HADR
expr_stmt|;
name|start
operator|->
name|md
operator|->
name|md1
operator||=
name|OWN
expr_stmt|;
name|INC_MD_PTR
argument_list|(
argument|start_of_packet
argument_list|,
argument|sc->nrdre
argument_list|)
block|}
block|}
else|else
block|{
comment|/* Valid packet */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|==
name|DMA_MBUF
condition|)
name|head
operator|=
name|chain_mbufs
argument_list|(
name|sc
argument_list|,
name|start_of_packet
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
else|else
name|head
operator|=
name|mbuf_packet
argument_list|(
name|sc
argument_list|,
name|start_of_packet
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
condition|)
block|{
comment|/* 				 * First mbuf in packet holds the 				 * ethernet and packet headers 				 */
name|head
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|head
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pkt_len
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|head
operator|->
name|m_data
expr_stmt|;
comment|/* 				 * vmware ethernet hardware emulation loops 				 * packets back to itself, violates IFF_SIMPLEX. 				 * drop it if it is from myself. 				*/
if|if
condition|(
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Skip over the ether header */
name|head
operator|->
name|m_data
operator|+=
sizeof|sizeof
expr|*
name|eh
expr_stmt|;
name|head
operator|->
name|m_len
operator|-=
sizeof|sizeof
expr|*
name|eh
expr_stmt|;
name|head
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
sizeof|sizeof
expr|*
name|eh
expr_stmt|;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|eh
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Packet dropped, no mbufs\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|LNCSTATS
argument_list|(
argument|drop_packet
argument_list|)
block|}
block|}
name|lookahead
operator|++
expr_stmt|;
block|}
comment|/* 	 * At this point all completely received packets have been processed 	 * so clear RINT since any packets that have arrived while we were in 	 * here have been dealt with. 	 */
name|lnc_outw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|,
name|RINT
operator||
name|INEA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|lnc_tint
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|host_ring_entry
modifier|*
name|next
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|int
name|start_of_packet
decl_stmt|;
name|int
name|lookahead
decl_stmt|;
comment|/* 	 * If the driver is reset in this routine then we return immediately to 	 * the interrupt driver routine. Any interrupts that have occured 	 * since the reset will be dealt with there. sc->trans_next 	 * should point to the start of the first packet that was awaiting 	 * transmission after the last transmit interrupt was dealt with. The 	 * LANCE should have relinquished ownership of that descriptor before 	 * the interrupt. Therefore, sc->trans_next should point to a 	 * descriptor with STP set and OWN cleared. If not then the driver's 	 * pointers are out of sync with the LANCE, which signifies a bug in 	 * the driver. Therefore, the following two checks are really 	 * diagnostic, since if the driver is working correctly they should 	 * never happen. 	 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|trans_next
operator|)
operator|->
name|md
operator|->
name|md1
operator|&
name|OWN
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Transmit interrupt with buffer still owned by controller -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * The LANCE will write the status information for the packet it just 	 * tried to transmit in one of two places. If the packet was 	 * transmitted successfully then the status will be written into the 	 * last descriptor of the packet. If the transmit failed then the 	 * status will be written into the descriptor that was being accessed 	 * when the error occured and all subsequent descriptors in that 	 * packet will have been relinquished by the LANCE. 	 * 	 * At this point we know that sc->trans_next points to the start 	 * of a packet that the LANCE has just finished trying to transmit. 	 * We now search for a buffer with either ENP or ERR set. 	 */
name|lookahead
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|start_of_packet
operator|=
name|sc
operator|->
name|trans_next
expr_stmt|;
name|next
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|trans_next
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|STP
operator|)
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Transmit interrupt but not start of packet -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 		 * Find end of packet. 		 */
if|if
condition|(
operator|!
operator|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
operator|(
name|ENP
operator||
name|MDERR
operator|)
operator|)
condition|)
block|{
do|do
block|{
name|INC_MD_PTR
argument_list|(
argument|sc->trans_next
argument_list|,
argument|sc->ntdre
argument_list|)
name|next
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|trans_next
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
operator|(
name|STP
operator||
name|OWN
operator||
name|ENP
operator||
name|MDERR
operator|)
operator|)
condition|)
do|;
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|STP
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Start of packet found before end of previous in transmit ring -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|OWN
condition|)
block|{
if|if
condition|(
name|lookahead
condition|)
block|{
comment|/* 					 * Looked ahead into a packet still 					 * being transmitted 					 */
name|sc
operator|->
name|trans_next
operator|=
name|start_of_packet
expr_stmt|;
break|break;
block|}
else|else
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: End of transmitted packet not found -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* 		 * Check for ERR first since other flags are irrelevant if an 		 * error occurred. 		 */
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|MDERR
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|LNCSTATS
argument_list|(
argument|terr
argument_list|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md3
operator|&
name|LCOL
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|lcol
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Transmit late collision  -- Net error?\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
comment|/* 				 * Clear TBUFF since it's not valid when LCOL 				 * set 				 */
name|next
operator|->
name|md
operator|->
name|md3
operator|&=
operator|~
name|TBUFF
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md3
operator|&
name|LCAR
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|lcar
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Loss of carrier during transmit -- Net error?\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md3
operator|&
name|RTRY
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|rtry
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Transmit of packet failed after 16 attempts -- TDR = %d\n"
argument_list|,
name|unit
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|trans_next
operator|)
operator|->
name|md
operator|->
name|md3
operator|&
name|TDR
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|+=
literal|16
expr_stmt|;
comment|/* 				 * Clear TBUFF since it's not valid when RTRY 				 * set 				 */
name|next
operator|->
name|md
operator|->
name|md3
operator|&=
operator|~
name|TBUFF
expr_stmt|;
block|}
comment|/* 			 * TBUFF is only valid if neither LCOL nor RTRY are set. 			 * We need to check UFLO after LCOL and RTRY so that we 			 * know whether or not TBUFF is valid. If either are 			 * set then TBUFF will have been cleared above. A 			 * UFLO error will turn off the transmitter so we 			 * have to reset. 			 * 			 */
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md3
operator|&
name|UFLO
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|uflo
argument_list|)
comment|/* 				 * If an UFLO has occured it's possibly due 				 * to a TBUFF error 				 */
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md3
operator|&
name|TBUFF
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|tbuff
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Transmit buffer error -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Transmit underflow error -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|INC_MD_PTR
argument_list|(
argument|sc->trans_next
argument_list|,
argument|sc->ntdre
argument_list|)
name|next
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|trans_next
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|STP
operator|)
operator|&&
operator|(
name|sc
operator|->
name|trans_next
operator|!=
name|sc
operator|->
name|next_to_send
operator|)
condition|)
do|;
block|}
else|else
block|{
comment|/* 			 * Since we check for ERR first then if we get here 			 * the packet was transmitted correctly. There may 			 * still have been non-fatal errors though. 			 * Don't bother checking for DEF, waste of time. 			 */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|MORE
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|more
argument_list|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* 			 * ONE is invalid if LCOL is set. If LCOL was set then 			 * ERR would have also been set and we would have 			 * returned from lnc_tint above. Therefore we can 			 * assume if we arrive here that ONE is valid. 			 * 			 */
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|ONE
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|one
argument_list|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
block|}
name|INC_MD_PTR
argument_list|(
argument|sc->trans_next
argument_list|,
argument|sc->ntdre
argument_list|)
name|next
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|trans_next
expr_stmt|;
block|}
comment|/* 		 * Clear descriptors and free any mbufs. 		 */
do|do
block|{
name|start
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|start_of_packet
expr_stmt|;
name|start
operator|->
name|md
operator|->
name|md1
operator|&=
name|HADR
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|==
name|DMA_MBUF
condition|)
block|{
comment|/* Cache clusters on a local queue */
if|if
condition|(
operator|(
name|start
operator|->
name|buff
operator|.
name|mbuf
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|&&
operator|(
name|sc
operator|->
name|mbuf_count
operator|<
name|MBUF_CACHE_LIMIT
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|mbuf_count
condition|)
block|{
name|start
operator|->
name|buff
operator|.
name|mbuf
operator|->
name|m_next
operator|=
name|sc
operator|->
name|mbufs
expr_stmt|;
name|sc
operator|->
name|mbufs
operator|=
name|start
operator|->
name|buff
operator|.
name|mbuf
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|mbufs
operator|=
name|start
operator|->
name|buff
operator|.
name|mbuf
expr_stmt|;
name|sc
operator|->
name|mbuf_count
operator|++
expr_stmt|;
name|start
operator|->
name|buff
operator|.
name|mbuf
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * XXX should this be m_freem()? 					 */
name|m_free
argument_list|(
name|start
operator|->
name|buff
operator|.
name|mbuf
argument_list|)
expr_stmt|;
name|start
operator|->
name|buff
operator|.
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|pending_transmits
operator|--
expr_stmt|;
name|INC_MD_PTR
argument_list|(
argument|start_of_packet
argument_list|,
argument|sc->ntdre
argument_list|)
block|}
do|while
condition|(
name|start_of_packet
operator|!=
name|sc
operator|->
name|trans_next
condition|)
do|;
comment|/* 		 * There's now at least one free descriptor 		 * in the ring so indicate that we can accept 		 * more packets again. 		 */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|lookahead
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|sc
operator|->
name|pending_transmits
operator|&&
operator|!
operator|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|OWN
operator|)
condition|)
do|;
comment|/* 	 * Clear TINT since we've dealt with all 	 * the completed transmissions. 	 */
name|lnc_outw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|,
name|TINT
operator||
name|INEA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lnc_attach_common
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|lnc_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|skip
decl_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|nic
operator|.
name|ident
condition|)
block|{
case|case
name|BICC
case|:
case|case
name|CNET98S
case|:
name|skip
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|skip
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Set default mode */
name|sc
operator|->
name|nic
operator|.
name|mode
operator|=
name|NORMAL
expr_stmt|;
comment|/* Fill in arpcom structure entries */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_name
operator|=
literal|"lnc"
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_start
operator|=
name|lnc_start
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ioctl
operator|=
name|lnc_ioctl
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_watchdog
operator|=
name|lnc_watchdog
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_init
operator|=
name|lnc_init
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
comment|/* Extract MAC address from PROM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|lnc_inb
argument_list|(
name|i
operator|*
name|skip
argument_list|)
expr_stmt|;
comment|/* 	 * XXX -- should check return status of if_attach 	 */
name|ether_ifattach
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lnc%d: "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|==
name|LANCE
operator|||
name|sc
operator|->
name|nic
operator|.
name|ic
operator|==
name|C_LANCE
condition|)
name|printf
argument_list|(
literal|"%s (%s)"
argument_list|,
name|nic_ident
index|[
name|sc
operator|->
name|nic
operator|.
name|ident
index|]
argument_list|,
name|ic_ident
index|[
name|sc
operator|->
name|nic
operator|.
name|ic
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ic_ident
index|[
name|sc
operator|->
name|nic
operator|.
name|ic
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" address %6D\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lnc_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|lnc_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|lnc_mem
decl_stmt|;
comment|/* Check that interface has valid address */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_addrhead
argument_list|)
condition|)
block|{
comment|/* XXX unlikely */
name|printf
argument_list|(
literal|"XXX no address?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Shut down interface */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|lnc_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
comment|/* XXX??? */
comment|/* 	 * This sets up the memory area for the controller. Memory is set up for 	 * the initialisation block (12 words of contiguous memory starting 	 * on a word boundary),the transmit and receive ring structures (each 	 * entry is 4 words long and must start on a quadword boundary) and 	 * the data buffers. 	 * 	 * The alignment tests are particularly paranoid. 	 */
name|sc
operator|->
name|recv_next
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|trans_ring
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
expr_stmt|;
name|sc
operator|->
name|trans_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|==
name|SHMEM
condition|)
name|lnc_mem
operator|=
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|nic
operator|.
name|iobase
expr_stmt|;
else|else
name|lnc_mem
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
operator|)
expr_stmt|;
name|lnc_mem
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|lnc_mem
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|sc
operator|->
name|init_block
operator|=
operator|(
expr|struct
name|init_block
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|lnc_mem
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|lnc_mem
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|sc
operator|->
name|init_block
operator|+
literal|1
operator|)
expr_stmt|;
name|lnc_mem
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|lnc_mem
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
expr_stmt|;
comment|/* Initialise pointers to descriptor entries */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|=
operator|(
expr|struct
name|mds
operator|*
operator|)
name|lnc_mem
expr_stmt|;
name|lnc_mem
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mds
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|=
operator|(
expr|struct
name|mds
operator|*
operator|)
name|lnc_mem
expr_stmt|;
name|lnc_mem
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mds
argument_list|)
expr_stmt|;
block|}
comment|/* Initialise the remaining ring entries */
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|==
name|DMA_MBUF
condition|)
block|{
name|sc
operator|->
name|mbufs
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mbuf_count
operator|=
literal|0
expr_stmt|;
comment|/* Free previously allocated mbufs */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|LNC_INITIALISED
condition|)
name|lnc_free_mbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|alloc_mbuf_cluster
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|recv_ring
operator|+
name|i
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Initialisation failed -- no mbufs\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|mbuf
operator|=
literal|0
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md0
operator|=
literal|0
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md1
operator|=
literal|0
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md2
operator|=
literal|0
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md3
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md0
operator|=
name|kvtop
argument_list|(
name|lnc_mem
argument_list|)
expr_stmt|;
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md1
operator|=
operator|(
operator|(
name|kvtop
argument_list|(
name|lnc_mem
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
name|OWN
expr_stmt|;
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md2
operator|=
operator|-
name|RECVBUFSIZE
expr_stmt|;
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md3
operator|=
literal|0
expr_stmt|;
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|data
operator|=
name|lnc_mem
expr_stmt|;
name|lnc_mem
operator|+=
name|RECVBUFSIZE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md0
operator|=
name|kvtop
argument_list|(
name|lnc_mem
argument_list|)
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md1
operator|=
operator|(
operator|(
name|kvtop
argument_list|(
name|lnc_mem
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md2
operator|=
literal|0
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md3
operator|=
literal|0
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|data
operator|=
name|lnc_mem
expr_stmt|;
name|lnc_mem
operator|+=
name|TRANSBUFSIZE
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|next_to_send
operator|=
literal|0
expr_stmt|;
comment|/* Set up initialisation block */
name|sc
operator|->
name|init_block
operator|->
name|mode
operator|=
name|sc
operator|->
name|nic
operator|.
name|mode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|init_block
operator|->
name|padr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
expr_stmt|;
name|lnc_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|init_block
operator|->
name|rdra
operator|=
name|kvtop
argument_list|(
name|sc
operator|->
name|recv_ring
operator|->
name|md
argument_list|)
expr_stmt|;
name|sc
operator|->
name|init_block
operator|->
name|rlen
operator|=
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|recv_ring
operator|->
name|md
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|sc
operator|->
name|nrdre
operator|<<
literal|13
operator|)
expr_stmt|;
name|sc
operator|->
name|init_block
operator|->
name|tdra
operator|=
name|kvtop
argument_list|(
name|sc
operator|->
name|trans_ring
operator|->
name|md
argument_list|)
expr_stmt|;
name|sc
operator|->
name|init_block
operator|->
name|tlen
operator|=
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|trans_ring
operator|->
name|md
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|sc
operator|->
name|ntdre
operator|<<
literal|13
operator|)
expr_stmt|;
comment|/* Set flags to show that the memory area is valid */
name|sc
operator|->
name|flags
operator||=
name|LNC_INITIALISED
expr_stmt|;
name|sc
operator|->
name|pending_transmits
operator|=
literal|0
expr_stmt|;
comment|/* Give the LANCE the physical address of the initialisation block */
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|==
name|PCnet_Home
condition|)
block|{
name|u_short
name|media
decl_stmt|;
comment|/* Set PHY_SEL to HomeRun */
name|media
operator|=
name|read_bcr
argument_list|(
name|sc
argument_list|,
name|BCR49
argument_list|)
expr_stmt|;
name|media
operator|&=
operator|~
literal|3
expr_stmt|;
name|media
operator||=
literal|1
expr_stmt|;
name|write_bcr
argument_list|(
name|sc
argument_list|,
name|BCR49
argument_list|,
name|media
argument_list|)
expr_stmt|;
block|}
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR1
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|init_block
argument_list|)
argument_list|)
expr_stmt|;
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR2
argument_list|,
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|init_block
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 	 * Depending on which controller this is, CSR3 has different meanings. 	 * For the Am7990 it controls DMA operations, for the Am79C960 it 	 * controls interrupt masks and transmitter algorithms. In either 	 * case, none of the flags are set. 	 * 	 */
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Let's see if it starts */
comment|/* printf("Enabling lnc interrupts\n"); 	sc->arpcom.ac_if.if_timer = 10; 	write_csr(sc, CSR0, INIT|INEA); */
comment|/* 	 * Now that the initialisation is complete there's no reason to 	 * access anything except CSR0, so we leave RAP pointing there 	 * so we can just access RDP from now on, saving an outw each 	 * time. 	 */
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|INIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
operator|&
name|IDON
condition|)
break|break;
if|if
condition|(
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
operator|&
name|IDON
condition|)
block|{
comment|/* 		 * Enable interrupts, start the LANCE, mark the interface as 		 * running and transmit any pending packets. 		 */
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|STRT
operator||
name|INEA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|lnc_start
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Initialisation failed\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The interrupt flag (INTR) will be set and provided that the interrupt enable  * flag (INEA) is also set, the interrupt pin will be driven low when any of  * the following occur:  *  * 1) Completion of the initialisation routine (IDON). 2) The reception of a  * packet (RINT). 3) The transmission of a packet (TINT). 4) A transmitter  * timeout error (BABL). 5) A missed packet (MISS). 6) A memory error (MERR).  *  * The interrupt flag is cleared when all of the above conditions are cleared.  *  * If the driver is reset from this routine then it first checks to see if any  * interrupts have ocurred since the reset and handles them before returning.  * This is because the NIC may signify a pending interrupt in CSR0 using the  * INTR flag even if a hardware interrupt is currently inhibited (at least I  * think it does from reading the data sheets). We may as well deal with  * these pending interrupts now rather than get the overhead of another  * hardware interrupt immediately upon returning from the interrupt handler.  *  */
end_comment

begin_function
name|void
name|lncintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|lnc_softc_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|u_short
name|csr0
decl_stmt|;
comment|/* 	 * INEA is the only bit that can be cleared by writing a 0 to it so 	 * we have to include it in any writes that clear other flags. 	 */
while|while
condition|(
operator|(
name|csr0
operator|=
name|lnc_inw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|)
operator|)
operator|&
name|INTR
condition|)
block|{
comment|/* 		 * Clear interrupt flags early to avoid race conditions. The 		 * controller can still set these flags even while we're in 		 * this interrupt routine. If the flag is still set from the 		 * event that caused this interrupt any new events will 		 * be missed. 		 */
name|lnc_outw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|,
name|csr0
argument_list|)
expr_stmt|;
comment|/*lnc_outw(sc->rdp, IDON | CERR | BABL | MISS | MERR | RINT | TINT | INEA);*/
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|csr0
operator|&
name|IDON
condition|)
block|{
name|printf
argument_list|(
literal|"IDON\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|STRT
operator||
name|INEA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|lnc_start
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|csr0
operator|&
name|ERR
condition|)
block|{
if|if
condition|(
name|csr0
operator|&
name|CERR
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Heartbeat error -- SQE test failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|LNCSTATS
argument_list|(
argument|cerr
argument_list|)
block|}
if|if
condition|(
name|csr0
operator|&
name|BABL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Babble error - more than 1519 bytes transmitted\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|LNCSTATS
argument_list|(
argument|babl
argument_list|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|csr0
operator|&
name|MISS
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Missed packet -- no receive buffer\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|LNCSTATS
argument_list|(
argument|miss
argument_list|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|csr0
operator|&
name|MERR
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Memory error  -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|LNCSTATS
argument_list|(
argument|merr
argument_list|)
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|csr0
operator|&
name|RINT
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|rint
argument_list|)
name|lnc_rint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csr0
operator|&
name|TINT
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|tint
argument_list|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|lnc_tint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If there's room in the transmit descriptor ring then queue 		 * some more transmit packets. 		 */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
condition|)
name|lnc_start
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|mbuf_to_buffer
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|chain_to_cluster
argument_list|(
argument|struct mbuf *m
argument_list|)
block|{ 	struct
name|mbuf
operator|*
name|new
block|;
name|MGET
argument_list|(
name|new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
block|;
if|if
condition|(
name|new
condition|)
block|{
name|MCLGET
argument_list|(
name|new
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|m_ext
operator|.
name|ext_buf
condition|)
block|{
name|new
operator|->
name|m_len
operator|=
name|mbuf_to_buffer
argument_list|(
name|m
argument_list|,
name|new
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_expr_stmt

begin_else
else|else
name|m_free
argument_list|(
name|new
argument_list|)
expr_stmt|;
end_else

begin_expr_stmt
unit|} 	return
operator|(
literal|0
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * IFF_OACTIVE and IFF_RUNNING are checked in ether_output so it's redundant  * to check them again since we wouldn't have got here if they were not  * appropriately set. This is also called from lnc_init and lncintr but the  * flags should be ok at those points too.  */
end_comment

begin_function
unit|static
name|void
name|lnc_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lnc_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|host_ring_entry
modifier|*
name|desc
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|int
name|end_of_packet
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|head
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|,
name|chunk
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|no_entries_needed
decl_stmt|;
do|do
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|==
name|DMA_MBUF
condition|)
block|{
name|no_entries_needed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|head
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|no_entries_needed
operator|++
expr_stmt|;
comment|/* 			 * We try and avoid bcopy as much as possible 			 * but there are two cases when we use it. 			 * 			 * 1) If there are not enough free entries in the ring 			 * to hold each mbuf in the chain then compact the 			 * chain into a single cluster. 			 * 			 * 2) The Am7990 and Am79C90 must not have less than 			 * 100 bytes in the first descriptor of a chained 			 * packet so it's necessary to shuffle the mbuf 			 * contents to ensure this. 			 */
if|if
condition|(
name|no_entries_needed
operator|>
operator|(
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
operator|-
name|sc
operator|->
name|pending_transmits
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|head
operator|=
name|chain_to_cluster
argument_list|(
name|head
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Couldn't get mbuf for transmit packet -- Resetting \n "
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|==
name|LANCE
operator|)
operator|||
operator|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|==
name|C_LANCE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|head
operator|->
name|m_len
operator|<
literal|100
operator|)
operator|&&
operator|(
name|head
operator|->
name|m_next
operator|)
condition|)
block|{
name|len
operator|=
literal|100
operator|-
name|head
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|head
argument_list|)
operator|<
name|len
condition|)
block|{
comment|/* 						 * Move data to start of data 						 * area. We assume the first 						 * mbuf has a packet header 						 * and is not a cluster. 						 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|head
operator|->
name|m_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|head
operator|->
name|m_pktdat
argument_list|,
name|head
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|head
operator|->
name|m_data
operator|=
name|head
operator|->
name|m_pktdat
expr_stmt|;
block|}
name|m
operator|=
name|head
operator|->
name|m_next
expr_stmt|;
while|while
condition|(
name|m
operator|&&
operator|(
name|len
operator|>
literal|0
operator|)
condition|)
block|{
name|chunk
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|head
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|head
operator|->
name|m_len
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|len
operator|-=
name|chunk
expr_stmt|;
name|head
operator|->
name|m_len
operator|+=
name|chunk
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|chunk
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|chunk
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
literal|0
condition|)
block|{
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|head
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
block|}
block|}
block|}
block|}
name|tmp
operator|=
name|sc
operator|->
name|next_to_send
expr_stmt|;
comment|/* 			 * On entering this loop we know that tmp points to a 			 * descriptor with a clear OWN bit. 			 */
name|desc
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|tmp
expr_stmt|;
name|len
operator|=
name|ETHER_MIN_LEN
expr_stmt|;
for|for
control|(
name|m
operator|=
name|head
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|desc
operator|->
name|buff
operator|.
name|mbuf
operator|=
name|m
expr_stmt|;
name|addr
operator|=
name|kvtop
argument_list|(
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md0
operator|=
name|addr
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md1
operator|=
operator|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md3
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md2
operator|=
operator|-
name|m
operator|->
name|m_len
expr_stmt|;
name|sc
operator|->
name|pending_transmits
operator|++
expr_stmt|;
name|len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|INC_MD_PTR
argument_list|(
argument|tmp
argument_list|,
argument|sc->ntdre
argument_list|)
name|desc
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|tmp
expr_stmt|;
block|}
name|end_of_packet
operator|=
name|tmp
expr_stmt|;
name|DEC_MD_PTR
argument_list|(
argument|tmp
argument_list|,
argument|sc->ntdre
argument_list|)
name|desc
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|tmp
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md1
operator||=
name|ENP
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|desc
operator|->
name|md
operator|->
name|md2
operator|-=
name|len
expr_stmt|;
comment|/* 			 * Set OWN bits in reverse order, otherwise the Lance 			 * could start sending the packet before all the 			 * buffers have been relinquished by the host. 			 */
while|while
condition|(
name|tmp
operator|!=
name|sc
operator|->
name|next_to_send
condition|)
block|{
name|desc
operator|->
name|md
operator|->
name|md1
operator||=
name|OWN
expr_stmt|;
name|DEC_MD_PTR
argument_list|(
argument|tmp
argument_list|,
argument|sc->ntdre
argument_list|)
name|desc
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|tmp
expr_stmt|;
block|}
name|sc
operator|->
name|next_to_send
operator|=
name|end_of_packet
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md1
operator||=
name|STP
operator||
name|OWN
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|pending_transmits
operator|++
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|next_to_send
expr_stmt|;
name|len
operator|=
name|mbuf_to_buffer
argument_list|(
name|head
argument_list|,
name|desc
operator|->
name|buff
operator|.
name|data
argument_list|)
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md3
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md2
operator|=
operator|-
name|max
argument_list|(
name|len
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md1
operator||=
name|OWN
operator||
name|STP
operator||
name|ENP
expr_stmt|;
name|INC_MD_PTR
argument_list|(
argument|sc->next_to_send
argument_list|,
argument|sc->ntdre
argument_list|)
block|}
comment|/* Force an immediate poll of the transmit ring */
name|lnc_outw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|,
name|TDMD
operator||
name|INEA
argument_list|)
expr_stmt|;
comment|/* 		 * Set a timer so if the buggy Am7990.h shuts 		 * down we can wake it up. 		 */
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|!=
name|DMA_MBUF
condition|)
name|m_freem
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sc
operator|->
name|pending_transmits
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
condition|)
do|;
comment|/* 	 * Transmit ring is full so set IFF_OACTIVE 	 * since we can't buffer any more packets. 	 */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|LNCSTATS
argument_list|(
argument|trans_ring_full
argument_list|)
block|}
end_function

begin_function
specifier|static
name|int
name|lnc_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|lnc_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|sc
operator|->
name|lnc_debug
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|lnc_debug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|nic
operator|.
name|mode
operator|&
name|PROM
operator|)
condition|)
block|{
name|sc
operator|->
name|nic
operator|.
name|mode
operator||=
name|PROM
expr_stmt|;
name|lnc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mode
operator|&
name|PROM
condition|)
block|{
name|sc
operator|->
name|nic
operator|.
name|mode
operator|&=
operator|~
name|PROM
expr_stmt|;
name|lnc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|LNC_ALLMULTI
operator|)
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|LNC_ALLMULTI
expr_stmt|;
name|lnc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|&&
operator|(
name|sc
operator|->
name|flags
operator|&
name|LNC_ALLMULTI
operator|)
condition|)
block|{
name|sc
operator|->
name|flags
operator|&=
operator|~
name|LNC_ALLMULTI
expr_stmt|;
name|lnc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If interface is marked down and it is running, 			 * then stop it. 			 */
name|lnc_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If interface is marked up and it is stopped, then 			 * start it. 			 */
name|lnc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|lnc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lnc_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Device timeout -- Resetting\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|lnc_reset
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|lnc_dump_state
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\nDriver/NIC [%d] state dump\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Memory access mode: %b\n"
argument_list|,
name|sc
operator|->
name|nic
operator|.
name|mem_mode
argument_list|,
name|MEM_MODES
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Host memory\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-----------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Receive ring: base = %p, next = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|recv_ring
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|sc
operator|->
name|recv_next
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t%d:%p md = %p buff = %p\n"
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Transmit ring: base = %p, next = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|trans_ring
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|trans_next
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t%d:%p md = %p buff = %p\n"
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Lance memory (may be on host(DMA) or card(SHMEM))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Init block = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|init_block
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tmode = %b rlen:rdra = %x:%x tlen:tdra = %x:%x\n"
argument_list|,
name|sc
operator|->
name|init_block
operator|->
name|mode
argument_list|,
name|INIT_MODE
argument_list|,
name|sc
operator|->
name|init_block
operator|->
name|rlen
argument_list|,
name|sc
operator|->
name|init_block
operator|->
name|rdra
argument_list|,
name|sc
operator|->
name|init_block
operator|->
name|tlen
argument_list|,
name|sc
operator|->
name|init_block
operator|->
name|tdra
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Receive descriptor ring\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t%d buffer = 0x%x%x, BCNT = %d,\tMCNT = %u,\tflags = %b\n"
argument_list|,
name|i
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md1
operator|&
name|HADR
operator|)
argument_list|,
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md0
argument_list|,
operator|-
call|(
name|short
call|)
argument_list|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
argument_list|)
operator|->
name|md
operator|->
name|md2
argument_list|,
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md3
argument_list|,
operator|(
operator|(
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md1
operator|&
operator|~
name|HADR
operator|)
operator|>>
literal|8
operator|)
argument_list|,
name|RECV_MD1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Transmit descriptor ring\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t%d buffer = 0x%x%x, BCNT = %d,\tflags = %b %b\n"
argument_list|,
name|i
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md1
operator|&
name|HADR
operator|)
argument_list|,
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md0
argument_list|,
operator|-
call|(
name|short
call|)
argument_list|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
argument_list|)
operator|->
name|md
operator|->
name|md2
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md1
operator|>>
literal|8
operator|)
argument_list|,
name|TRANS_MD1
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md3
operator|>>
literal|10
operator|)
argument_list|,
name|TRANS_MD3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nnext_to_send = %x\n"
argument_list|,
name|sc
operator|->
name|next_to_send
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n CSR0 = %b CSR1 = %x CSR2 = %x CSR3 = %x\n\n"
argument_list|,
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
argument_list|,
name|CSR0_FLAGS
argument_list|,
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR1
argument_list|)
argument_list|,
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR2
argument_list|)
argument_list|,
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set RAP back to CSR0 */
name|lnc_outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|CSR0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mbuf_dump_chain
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
define|#
directive|define
name|MBUF_FLAGS
define|\
value|"\20\1M_EXT\2M_PKTHDR\3M_EOR\4UNKNOWN\5M_BCAST\6M_MCAST"
if|if
condition|(
operator|!
name|m
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m == NULL\n"
argument_list|)
expr_stmt|;
do|do
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m_hdr.mh_next = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|m_hdr
operator|.
name|mh_next
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m_hdr.mh_nextpkt = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|m_hdr
operator|.
name|mh_nextpkt
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m_hdr.mh_len = %d\n"
argument_list|,
name|m
operator|->
name|m_hdr
operator|.
name|mh_len
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m_hdr.mh_data = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|m_hdr
operator|.
name|mh_data
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m_hdr.mh_type = %d\n"
argument_list|,
name|m
operator|->
name|m_hdr
operator|.
name|mh_type
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m_hdr.mh_flags = %b\n"
argument_list|,
name|m
operator|->
name|m_hdr
operator|.
name|mh_flags
argument_list|,
name|MBUF_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_hdr
operator|.
name|mh_flags
operator|&
operator|(
name|M_PKTHDR
operator||
name|M_EXT
operator|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"M_dat.M_databuf = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|M_dat
operator|.
name|M_databuf
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|m
operator|->
name|m_hdr
operator|.
name|mh_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"M_dat.MH.MH_pkthdr.len = %d\n"
argument_list|,
name|m
operator|->
name|M_dat
operator|.
name|MH
operator|.
name|MH_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"M_dat.MH.MH_pkthdr.rcvif = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|M_dat
operator|.
name|MH
operator|.
name|MH_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_hdr
operator|.
name|mh_flags
operator|&
name|M_EXT
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"M_dat.MH.MH_dat.MH_databuf = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|M_dat
operator|.
name|MH
operator|.
name|MH_dat
operator|.
name|MH_databuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_hdr
operator|.
name|mh_flags
operator|&
name|M_EXT
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"M_dat.MH.MH_dat.MH_ext.ext_buff %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|M_dat
operator|.
name|MH
operator|.
name|MH_dat
operator|.
name|MH_ext
operator|.
name|ext_buf
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"M_dat.MH.MH_dat.MH_ext.ext_free %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|M_dat
operator|.
name|MH
operator|.
name|MH_dat
operator|.
name|MH_ext
operator|.
name|ext_free
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"M_dat.MH.MH_dat.MH_ext.ext_size %d\n"
argument_list|,
name|m
operator|->
name|M_dat
operator|.
name|MH
operator|.
name|MH_dat
operator|.
name|MH_ext
operator|.
name|ext_size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|m
operator|=
name|m
operator|->
name|m_next
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

