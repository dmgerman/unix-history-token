begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1995, 1996  *	Paul Richards.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    verbatim and that no modifications are made prior to this  *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Paul Richards.  * 4. The name Paul Richards may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY PAUL RICHARDS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL PAUL RICHARDS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: if_lnc.c,v 1.45 1998/08/24 02:28:15 bde Exp $  */
end_comment

begin_comment
comment|/* #define LNC_MULTICAST #define DIAGNOSTIC #define DEBUG  *  * TODO ----  *  * This driver will need bounce buffer support when dma'ing to mbufs above the  * 16Mb mark.  *  * Check all the XXX comments -- some of them are just things I've left  * unfinished rather than "difficult" problems that were hacked around.  *  * Check log settings.  *  * Check how all the arpcom flags get set and used.  *  * Re-inline and re-static all routines after debugging.  *  * Remember to assign iobase in SHMEM probe routines.  *  * Replace all occurences of LANCE-controller-card etc in prints by the name  * strings of the appropriate type -- nifty window dressing  *  * Add DEPCA support -- mostly done.  *  */
end_comment

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_include
include|#
directive|include
file|"lnc.h"
end_include

begin_if
if|#
directive|if
name|NLNC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_comment
comment|/* Some defines that should really be in generic locations */
end_comment

begin_define
define|#
directive|define
name|FCS_LEN
value|4
end_define

begin_define
define|#
directive|define
name|MULTICAST_FILTER_LEN
value|8
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_lnc.h>
end_include

begin_struct
struct|struct
name|lnc_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* see ../../net/if_arp.h */
name|struct
name|nic_info
name|nic
decl_stmt|;
comment|/* NIC specific info */
name|int
name|nrdre
decl_stmt|;
name|struct
name|host_ring_entry
modifier|*
name|recv_ring
decl_stmt|;
comment|/* start of alloc'd mem */
name|int
name|recv_next
decl_stmt|;
name|int
name|ntdre
decl_stmt|;
name|struct
name|host_ring_entry
modifier|*
name|trans_ring
decl_stmt|;
name|int
name|trans_next
decl_stmt|;
name|struct
name|init_block
modifier|*
name|init_block
decl_stmt|;
comment|/* Initialisation block */
name|int
name|pending_transmits
decl_stmt|;
comment|/* No. of transmit descriptors in use */
name|int
name|next_to_send
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbufs
decl_stmt|;
name|int
name|mbuf_count
decl_stmt|;
name|int
name|initialised
decl_stmt|;
name|int
name|rap
decl_stmt|;
name|int
name|rdp
decl_stmt|;
name|int
name|bdp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|lnc_debug
decl_stmt|;
endif|#
directive|endif
name|LNCSTATS_STRUCT
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|lnc_softc
name|lnc_softc
index|[
name|NLNC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|nic_ident
index|[]
init|=
block|{
literal|"Unknown"
block|,
literal|"BICC"
block|,
literal|"NE2100"
block|,
literal|"DEPCA"
block|,
literal|"CNET98S"
block|,
comment|/* PC-98 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|ic_ident
index|[]
init|=
block|{
literal|"Unknown"
block|,
literal|"LANCE"
block|,
literal|"C-LANCE"
block|,
literal|"PCnet-ISA"
block|,
literal|"PCnet-ISA+"
block|,
literal|"PCnet-ISA II"
block|,
literal|"PCnet-32 VL-Bus"
block|,
literal|"PCnet-PCI"
block|,
literal|"PCnet-PCI II"
block|,
literal|"PCnet-FAST"
block|,
literal|"PCnet-FAST+"
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LNC_MULTICAST
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|lnc_setladrf
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|lnc_stop
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lnc_reset
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lnc_free_mbufs
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|int
name|alloc_mbuf_cluster
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|,
expr|struct
name|host_ring_entry
operator|*
name|desc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|chain_mbufs
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|,
name|int
name|start_of_packet
operator|,
name|int
name|pkt_len
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|mbuf_packet
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|,
name|int
name|start_of_packet
operator|,
name|int
name|pkt_len
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|lnc_rint
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|lnc_tint
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lnc_probe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|isa_dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|cnet98s_probe
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|,
name|unsigned
name|iobase
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|ne2100_probe
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|,
name|unsigned
name|iobase
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bicc_probe
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|,
name|unsigned
name|iobase
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dec_macaddr_extract
name|__P
argument_list|(
operator|(
name|u_char
name|ring
index|[]
operator|,
expr|struct
name|lnc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|depca_probe
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|,
name|unsigned
name|iobase
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lance_probe
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcnet_probe
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lnc_attach_sc
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|,
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lnc_attach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|isa_dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lnc_init
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|int
name|mbuf_to_buffer
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
name|m
operator|,
name|char
operator|*
name|buffer
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|chain_to_cluster
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
name|m
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
name|lnc_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lnc_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|u_long
name|command
operator|,
name|caddr_t
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lnc_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|lnc_dump_state
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mbuf_dump_chain
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
name|m
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_decl_stmt
name|void
modifier|*
name|lnc_attach_ne2100_pci
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|,
name|unsigned
name|iobase
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|lncintr_sc
name|__P
argument_list|(
operator|(
expr|struct
name|lnc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|lncdriver
init|=
block|{
name|lnc_probe
block|,
name|lnc_attach
block|,
literal|"lnc"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
name|void
name|write_csr
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|port
parameter_list|,
name|u_short
name|val
parameter_list|)
block|{
name|outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_short
name|read_csr
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
name|outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|inw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|write_bcr
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|port
parameter_list|,
name|u_short
name|val
parameter_list|)
block|{
name|outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|sc
operator|->
name|bdp
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_short
name|read_bcr
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
name|outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|inw
argument_list|(
name|sc
operator|->
name|bdp
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LNC_MULTICAST
end_ifdef

begin_function
specifier|static
name|__inline
name|u_long
name|ether_crc
parameter_list|(
name|u_char
modifier|*
name|ether_addr
parameter_list|)
block|{
define|#
directive|define
name|POLYNOMIAL
value|0x04c11db6
name|u_long
name|crc
init|=
literal|0xffffffffL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|carry
decl_stmt|;
name|u_char
name|b
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ETHER_ADDR_LEN
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|b
operator|=
operator|*
name|ether_addr
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|8
init|;
operator|--
name|j
operator|>=
literal|0
condition|;
control|)
block|{
name|carry
operator|=
operator|(
operator|(
name|crc
operator|&
literal|0x80000000L
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|^
operator|(
name|b
operator|&
literal|0x01
operator|)
expr_stmt|;
name|crc
operator|<<=
literal|1
expr_stmt|;
name|b
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|carry
condition|)
name|crc
operator|=
operator|(
operator|(
name|crc
operator|^
name|POLYNOMIAL
operator|)
operator||
name|carry
operator|)
expr_stmt|;
block|}
block|}
return|return
name|crc
return|;
undef|#
directive|undef
name|POLYNOMIAL
block|}
end_function

begin_comment
comment|/*  * Set up the logical address filter for multicast packets  */
end_comment

begin_function
specifier|static
name|void
name|lnc_setladrf
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|u_long
name|index
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If promiscuous mode is set then all packets are accepted anyway */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MULTICAST_FILTER_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|init_block
operator|->
name|ladrf
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
return|return;
block|}
comment|/*  * For each multicast address, calculate a crc for that address and  * then use the high order 6 bits of the crc as a hash code where  * bits 3-5 select the byte of the address filter and bits 0-2 select  * the bit within that byte.  */
name|bzero
argument_list|(
name|sc
operator|->
name|init_block
operator|->
name|ladrf
argument_list|,
name|MULTICAST_FILTER_LEN
argument_list|)
expr_stmt|;
for|for
control|(
name|ifma
operator|=
name|ifp
operator|->
name|if_multiaddrs
operator|.
name|lh_first
init|;
name|ifma
condition|;
name|ifma
operator|=
name|ifma
operator|->
name|ifma_link
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|index
operator|=
name|ether_crc
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
operator|>>
literal|26
expr_stmt|;
name|sc
operator|->
name|init_block
operator|->
name|ladrf
index|[
name|index
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|index
operator|&
literal|7
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LNC_MULTICAST */
end_comment

begin_function
specifier|static
name|void
name|lnc_stop
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|STOP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lnc_reset
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|lnc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lnc_free_mbufs
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * We rely on other routines to keep the buff.mbuf field valid. If 	 * it's not NULL then we assume it points to an allocated mbuf. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|mbuf
condition|)
name|m_free
argument_list|(
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|mbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|mbuf
condition|)
name|m_free
argument_list|(
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mbuf_count
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|mbufs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|alloc_mbuf_cluster
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|host_ring_entry
modifier|*
name|desc
parameter_list|)
block|{
specifier|register
name|struct
name|mds
modifier|*
name|md
init|=
name|desc
operator|->
name|md
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
literal|0
decl_stmt|;
name|int
name|addr
decl_stmt|;
comment|/* Try and get cluster off local cache */
if|if
condition|(
name|sc
operator|->
name|mbuf_count
condition|)
block|{
name|sc
operator|->
name|mbuf_count
operator|--
expr_stmt|;
name|m
operator|=
name|sc
operator|->
name|mbufs
expr_stmt|;
name|sc
operator|->
name|mbufs
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
comment|/* XXX m->m_data = m->m_ext.ext_buf;*/
block|}
else|else
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|desc
operator|->
name|buff
operator|.
name|mbuf
operator|=
name|m
expr_stmt|;
name|addr
operator|=
name|kvtop
argument_list|(
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|md
operator|->
name|md0
operator|=
name|addr
expr_stmt|;
name|md
operator|->
name|md1
operator|=
operator|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
name|OWN
expr_stmt|;
name|md
operator|->
name|md2
operator|=
operator|-
call|(
name|short
call|)
argument_list|(
name|MCLBYTES
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|pkthdr
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|md3
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|chain_mbufs
argument_list|(
argument|struct lnc_softc *sc
argument_list|,
argument|int start_of_packet
argument_list|,
argument|int pkt_len
argument_list|)
block|{ 	struct
name|mbuf
operator|*
name|head
block|,
operator|*
name|m
block|; 	struct
name|host_ring_entry
operator|*
name|desc
block|;
comment|/* 	 * Turn head into a pkthdr mbuf -- 	 * assumes a pkthdr type mbuf was 	 * allocated to the descriptor 	 * originally. 	 */
name|desc
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|start_of_packet
block|;
name|head
operator|=
name|desc
operator|->
name|buff
operator|.
name|mbuf
block|;
name|head
operator|->
name|m_flags
operator||=
name|M_PKTHDR
block|;
name|m
operator|=
name|head
block|;
do|do
block|{
name|m
operator|=
name|desc
operator|->
name|buff
operator|.
name|mbuf
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
operator|(
name|MCLBYTES
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|pkthdr
argument_list|)
operator|)
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
name|pkt_len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|alloc_mbuf_cluster
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|)
condition|)
return|return
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
operator|)
return|;
name|INC_MD_PTR
argument_list|(
argument|start_of_packet
argument_list|,
argument|sc->nrdre
argument_list|)
name|desc
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|start_of_packet
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|desc
operator|->
name|buff
operator|.
name|mbuf
expr_stmt|;
block|}
end_expr_stmt

begin_while
while|while
condition|(
name|start_of_packet
operator|!=
name|sc
operator|->
name|recv_next
condition|)
empty_stmt|;
end_while

begin_expr_stmt
name|m
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|head
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|struct
name|mbuf
modifier|*
name|mbuf_packet
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|int
name|start_of_packet
parameter_list|,
name|int
name|pkt_len
parameter_list|)
block|{
name|struct
name|host_ring_entry
modifier|*
name|start
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|head
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_prev
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|,
modifier|*
name|mbuf_data
decl_stmt|;
name|short
name|blen
decl_stmt|;
name|int
name|amount
decl_stmt|;
comment|/* Get a pkthdr mbuf for the start of packet */
name|MGETHDR
argument_list|(
name|head
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|drop_packet
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m
operator|=
name|head
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|start_of_packet
expr_stmt|;
comment|/*blen = -(start->md->md2);*/
name|blen
operator|=
name|RECVBUFSIZE
expr_stmt|;
comment|/* XXX More PCnet-32 crap */
name|data
operator|=
name|start
operator|->
name|buff
operator|.
name|data
expr_stmt|;
name|mbuf_data
operator|=
name|m
operator|->
name|m_data
expr_stmt|;
while|while
condition|(
name|start_of_packet
operator|!=
name|sc
operator|->
name|recv_next
condition|)
block|{
comment|/* 		 * If the data left fits in a single buffer then set 		 * blen to the size of the data left. 		 */
if|if
condition|(
name|pkt_len
operator|<
name|blen
condition|)
name|blen
operator|=
name|pkt_len
expr_stmt|;
comment|/* 		 * amount is least of data in current ring buffer and 		 * amount of space left in current mbuf. 		 */
name|amount
operator|=
name|min
argument_list|(
name|blen
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
operator|==
literal|0
condition|)
block|{
comment|/* mbuf must be empty */
name|m_prev
operator|=
name|m
expr_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|m_freem
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pkt_len
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m_prev
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|amount
operator|=
name|min
argument_list|(
name|blen
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|mbuf_data
operator|=
name|m
operator|->
name|m_data
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|data
argument_list|,
name|mbuf_data
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|blen
operator|-=
name|amount
expr_stmt|;
name|pkt_len
operator|-=
name|amount
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|amount
expr_stmt|;
name|data
operator|+=
name|amount
expr_stmt|;
name|mbuf_data
operator|+=
name|amount
expr_stmt|;
if|if
condition|(
name|blen
operator|==
literal|0
condition|)
block|{
name|start
operator|->
name|md
operator|->
name|md1
operator|&=
name|HADR
expr_stmt|;
name|start
operator|->
name|md
operator|->
name|md1
operator||=
name|OWN
expr_stmt|;
name|start
operator|->
name|md
operator|->
name|md2
operator|=
operator|-
name|RECVBUFSIZE
expr_stmt|;
comment|/* XXX - shouldn't be necessary */
name|INC_MD_PTR
argument_list|(
argument|start_of_packet
argument_list|,
argument|sc->nrdre
argument_list|)
name|start
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|start_of_packet
expr_stmt|;
name|data
operator|=
name|start
operator|->
name|buff
operator|.
name|data
expr_stmt|;
comment|/*blen = -(start->md->md2);*/
name|blen
operator|=
name|RECVBUFSIZE
expr_stmt|;
comment|/* XXX More PCnet-32 crap */
block|}
block|}
return|return
operator|(
name|head
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|lnc_rint
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|host_ring_entry
modifier|*
name|next
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|int
name|start_of_packet
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|head
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|lookahead
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|pkt_len
decl_stmt|;
comment|/* 	 * The LANCE will issue a RINT interrupt when the ownership of the 	 * last buffer of a receive packet has been relinquished by the LANCE. 	 * Therefore, it can be assumed that a complete packet can be found 	 * before hitting buffers that are still owned by the LANCE, if not 	 * then there is a bug in the driver that is causing the descriptors 	 * to get out of sync. 	 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|sc
operator|->
name|recv_next
operator|)
operator|->
name|md
operator|->
name|md1
operator|&
name|OWN
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Receive interrupt with buffer still owned by controller -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|sc
operator|->
name|recv_next
operator|)
operator|->
name|md
operator|->
name|md1
operator|&
name|STP
operator|)
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Receive interrupt but not start of packet -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|lookahead
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|sc
operator|->
name|recv_next
expr_stmt|;
while|while
condition|(
operator|(
name|flags
operator|=
name|next
operator|->
name|md
operator|->
name|md1
operator|)
operator|&
name|STP
condition|)
block|{
comment|/* Make a note of the start of the packet */
name|start_of_packet
operator|=
name|sc
operator|->
name|recv_next
expr_stmt|;
comment|/* 		 * Find the end of the packet. Even if not data chaining, 		 * jabber packets can overrun into a second descriptor. 	 	 * If there is no error, then the ENP flag is set in the last 		 * descriptor of the packet. If there is an error then the ERR 		 * flag will be set in the descriptor where the error occured. 		 * Therefore, to find the last buffer of a packet we search for 		 * either ERR or ENP. 		 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|ENP
operator||
name|MDERR
operator|)
operator|)
condition|)
block|{
do|do
block|{
name|INC_MD_PTR
argument_list|(
argument|sc->recv_next
argument_list|,
argument|sc->nrdre
argument_list|)
name|next
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|sc
operator|->
name|recv_next
expr_stmt|;
name|flags
operator|=
name|next
operator|->
name|md
operator|->
name|md1
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|STP
operator||
name|OWN
operator||
name|ENP
operator||
name|MDERR
operator|)
operator|)
condition|)
do|;
if|if
condition|(
name|flags
operator|&
name|STP
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Start of packet found before end of previous in receive ring -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flags
operator|&
name|OWN
condition|)
block|{
if|if
condition|(
name|lookahead
condition|)
block|{
comment|/* 					 * Looked ahead into a packet still 					 * being received 					 */
name|sc
operator|->
name|recv_next
operator|=
name|start_of_packet
expr_stmt|;
break|break;
block|}
else|else
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: End of received packet not found-- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|pkt_len
operator|=
operator|(
name|next
operator|->
name|md
operator|->
name|md3
operator|&
name|MCNT
operator|)
operator|-
name|FCS_LEN
expr_stmt|;
comment|/* Move pointer onto start of next packet */
name|INC_MD_PTR
argument_list|(
argument|sc->recv_next
argument_list|,
argument|sc->nrdre
argument_list|)
name|next
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|sc
operator|->
name|recv_next
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MDERR
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|RBUFF
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|rbuff
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Receive buffer error\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|OFLO
condition|)
block|{
comment|/* OFLO only valid if ENP is not set */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ENP
operator|)
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|oflo
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Receive overflow error \n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|ENP
condition|)
block|{
comment|/* 				 * FRAM and CRC are valid only if ENP 				 * is set and OFLO is not. 				 */
if|if
condition|(
name|flags
operator|&
name|FRAM
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|fram
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Framming error\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* 					 * FRAM is only set if there's a CRC 					 * error so avoid multiple messages 					 */
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|CRC
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|crc
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Receive CRC error\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Drop packet */
name|LNCSTATS
argument_list|(
argument|rerr
argument_list|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
while|while
condition|(
name|start_of_packet
operator|!=
name|sc
operator|->
name|recv_next
condition|)
block|{
name|start
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|start_of_packet
expr_stmt|;
name|start
operator|->
name|md
operator|->
name|md2
operator|=
operator|-
name|RECVBUFSIZE
expr_stmt|;
comment|/* XXX - shouldn't be necessary */
name|start
operator|->
name|md
operator|->
name|md1
operator|&=
name|HADR
expr_stmt|;
name|start
operator|->
name|md
operator|->
name|md1
operator||=
name|OWN
expr_stmt|;
name|INC_MD_PTR
argument_list|(
argument|start_of_packet
argument_list|,
argument|sc->nrdre
argument_list|)
block|}
block|}
else|else
block|{
comment|/* Valid packet */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|==
name|DMA_MBUF
condition|)
name|head
operator|=
name|chain_mbufs
argument_list|(
name|sc
argument_list|,
name|start_of_packet
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
else|else
name|head
operator|=
name|mbuf_packet
argument_list|(
name|sc
argument_list|,
name|start_of_packet
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
condition|)
block|{
comment|/* 				 * First mbuf in packet holds the 				 * ethernet and packet headers 				 */
name|head
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|head
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pkt_len
operator|-
sizeof|sizeof
expr|*
name|eh
expr_stmt|;
comment|/* 				 * BPF expects the ether header to be in the first 				 * mbuf of the chain so point eh at the right place 				 * but don't increment the mbuf pointers before 				 * the bpf tap. 				 */
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|head
operator|->
name|m_data
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|head
argument_list|)
expr_stmt|;
comment|/* Check this packet is really for us */
if|if
condition|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|!
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|&&
comment|/* Broadcast and multicast */
operator|(
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|)
condition|)
name|m_freem
argument_list|(
name|head
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
comment|/* Skip over the ether header */
name|head
operator|->
name|m_data
operator|+=
sizeof|sizeof
expr|*
name|eh
expr_stmt|;
name|head
operator|->
name|m_len
operator|-=
sizeof|sizeof
expr|*
name|eh
expr_stmt|;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|eh
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Packet dropped, no mbufs\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|LNCSTATS
argument_list|(
argument|drop_packet
argument_list|)
block|}
block|}
name|lookahead
operator|++
expr_stmt|;
block|}
comment|/* 	 * At this point all completely received packets have been processed 	 * so clear RINT since any packets that have arrived while we were in 	 * here have been dealt with. 	 */
name|outw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|,
name|RINT
operator||
name|INEA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|lnc_tint
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|host_ring_entry
modifier|*
name|next
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|int
name|start_of_packet
decl_stmt|;
name|int
name|lookahead
decl_stmt|;
comment|/* 	 * If the driver is reset in this routine then we return immediately to 	 * the interrupt driver routine. Any interrupts that have occured 	 * since the reset will be dealt with there. sc->trans_next 	 * should point to the start of the first packet that was awaiting 	 * transmission after the last transmit interrupt was dealt with. The 	 * LANCE should have relinquished ownership of that descriptor before 	 * the interrupt. Therefore, sc->trans_next should point to a 	 * descriptor with STP set and OWN cleared. If not then the driver's 	 * pointers are out of sync with the LANCE, which signifies a bug in 	 * the driver. Therefore, the following two checks are really 	 * diagnostic, since if the driver is working correctly they should 	 * never happen. 	 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|trans_next
operator|)
operator|->
name|md
operator|->
name|md1
operator|&
name|OWN
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Transmit interrupt with buffer still owned by controller -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * The LANCE will write the status information for the packet it just 	 * tried to transmit in one of two places. If the packet was 	 * transmitted successfully then the status will be written into the 	 * last descriptor of the packet. If the transmit failed then the 	 * status will be written into the descriptor that was being accessed 	 * when the error occured and all subsequent descriptors in that 	 * packet will have been relinquished by the LANCE. 	 * 	 * At this point we know that sc->trans_next points to the start 	 * of a packet that the LANCE has just finished trying to transmit. 	 * We now search for a buffer with either ENP or ERR set. 	 */
name|lookahead
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|start_of_packet
operator|=
name|sc
operator|->
name|trans_next
expr_stmt|;
name|next
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|trans_next
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|STP
operator|)
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Transmit interrupt but not start of packet -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 		 * Find end of packet. 		 */
if|if
condition|(
operator|!
operator|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
operator|(
name|ENP
operator||
name|MDERR
operator|)
operator|)
condition|)
block|{
do|do
block|{
name|INC_MD_PTR
argument_list|(
argument|sc->trans_next
argument_list|,
argument|sc->ntdre
argument_list|)
name|next
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|trans_next
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
operator|(
name|STP
operator||
name|OWN
operator||
name|ENP
operator||
name|MDERR
operator|)
operator|)
condition|)
do|;
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|STP
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Start of packet found before end of previous in transmit ring -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|OWN
condition|)
block|{
if|if
condition|(
name|lookahead
condition|)
block|{
comment|/* 					 * Looked ahead into a packet still 					 * being transmitted 					 */
name|sc
operator|->
name|trans_next
operator|=
name|start_of_packet
expr_stmt|;
break|break;
block|}
else|else
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: End of transmitted packet not found -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* 		 * Check for ERR first since other flags are irrelevant if an 		 * error occurred. 		 */
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|MDERR
condition|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|LNCSTATS
argument_list|(
argument|terr
argument_list|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md3
operator|&
name|LCOL
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|lcol
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Transmit late collision  -- Net error?\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
comment|/* 				 * Clear TBUFF since it's not valid when LCOL 				 * set 				 */
name|next
operator|->
name|md
operator|->
name|md3
operator|&=
operator|~
name|TBUFF
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md3
operator|&
name|LCAR
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|lcar
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Loss of carrier during transmit -- Net error?\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md3
operator|&
name|RTRY
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|rtry
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Transmit of packet failed after 16 attempts -- TDR = %d\n"
argument_list|,
name|unit
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|trans_next
operator|)
operator|->
name|md
operator|->
name|md3
operator|&
name|TDR
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|+=
literal|16
expr_stmt|;
comment|/* 				 * Clear TBUFF since it's not valid when RTRY 				 * set 				 */
name|next
operator|->
name|md
operator|->
name|md3
operator|&=
operator|~
name|TBUFF
expr_stmt|;
block|}
comment|/* 			 * TBUFF is only valid if neither LCOL nor RTRY are set. 			 * We need to check UFLO after LCOL and RTRY so that we 			 * know whether or not TBUFF is valid. If either are 			 * set then TBUFF will have been cleared above. A 			 * UFLO error will turn off the transmitter so we 			 * have to reset. 			 * 			 */
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md3
operator|&
name|UFLO
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|uflo
argument_list|)
comment|/* 				 * If an UFLO has occured it's possibly due 				 * to a TBUFF error 				 */
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md3
operator|&
name|TBUFF
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|tbuff
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Transmit buffer error -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Transmit underflow error -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|INC_MD_PTR
argument_list|(
argument|sc->trans_next
argument_list|,
argument|sc->ntdre
argument_list|)
name|next
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|trans_next
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|STP
operator|)
operator|&&
operator|(
name|sc
operator|->
name|trans_next
operator|!=
name|sc
operator|->
name|next_to_send
operator|)
condition|)
do|;
block|}
else|else
block|{
comment|/* 			 * Since we check for ERR first then if we get here 			 * the packet was transmitted correctly. There may 			 * still have been non-fatal errors though. 			 * Don't bother checking for DEF, waste of time. 			 */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|MORE
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|more
argument_list|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* 			 * ONE is invalid if LCOL is set. If LCOL was set then 			 * ERR would have also been set and we would have 			 * returned from lnc_tint above. Therefore we can 			 * assume if we arrive here that ONE is valid. 			 * 			 */
if|if
condition|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|ONE
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|one
argument_list|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
block|}
name|INC_MD_PTR
argument_list|(
argument|sc->trans_next
argument_list|,
argument|sc->ntdre
argument_list|)
name|next
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|trans_next
expr_stmt|;
block|}
comment|/* 		 * Clear descriptors and free any mbufs. 		 */
do|do
block|{
name|start
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|start_of_packet
expr_stmt|;
name|start
operator|->
name|md
operator|->
name|md1
operator|&=
name|HADR
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|==
name|DMA_MBUF
condition|)
block|{
comment|/* Cache clusters on a local queue */
if|if
condition|(
operator|(
name|start
operator|->
name|buff
operator|.
name|mbuf
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|&&
operator|(
name|sc
operator|->
name|mbuf_count
operator|<
name|MBUF_CACHE_LIMIT
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|mbuf_count
condition|)
block|{
name|start
operator|->
name|buff
operator|.
name|mbuf
operator|->
name|m_next
operator|=
name|sc
operator|->
name|mbufs
expr_stmt|;
name|sc
operator|->
name|mbufs
operator|=
name|start
operator|->
name|buff
operator|.
name|mbuf
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|mbufs
operator|=
name|start
operator|->
name|buff
operator|.
name|mbuf
expr_stmt|;
name|sc
operator|->
name|mbuf_count
operator|++
expr_stmt|;
name|start
operator|->
name|buff
operator|.
name|mbuf
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|junk
decl_stmt|;
name|MFREE
argument_list|(
name|start
operator|->
name|buff
operator|.
name|mbuf
argument_list|,
name|junk
argument_list|)
expr_stmt|;
name|start
operator|->
name|buff
operator|.
name|mbuf
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|pending_transmits
operator|--
expr_stmt|;
name|INC_MD_PTR
argument_list|(
argument|start_of_packet
argument_list|,
argument|sc->ntdre
argument_list|)
block|}
do|while
condition|(
name|start_of_packet
operator|!=
name|sc
operator|->
name|trans_next
condition|)
do|;
comment|/* 		 * There's now at least one free descriptor 		 * in the ring so indicate that we can accept 		 * more packets again. 		 */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|lookahead
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|sc
operator|->
name|pending_transmits
operator|&&
operator|!
operator|(
name|next
operator|->
name|md
operator|->
name|md1
operator|&
name|OWN
operator|)
condition|)
do|;
comment|/* 	 * Clear TINT since we've dealt with all 	 * the completed transmissions. 	 */
name|outw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|,
name|TINT
operator||
name|INEA
argument_list|)
expr_stmt|;
comment|/* XXX only while doing if_is comparisons */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
condition|)
name|lnc_start
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lnc_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|isa_dev
parameter_list|)
block|{
name|int
name|nports
decl_stmt|;
name|int
name|unit
init|=
name|isa_dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|lnc_softc
modifier|*
name|sc
init|=
operator|&
name|lnc_softc
index|[
name|unit
index|]
decl_stmt|;
name|unsigned
name|iobase
init|=
name|isa_dev
operator|->
name|id_iobase
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|int
name|vsw
decl_stmt|;
name|vsw
operator|=
name|inw
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|PCNET_VSW
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Vendor Specific Word = %x\n"
argument_list|,
name|vsw
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nports
operator|=
name|bicc_probe
argument_list|(
name|sc
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
name|nports
operator|==
literal|0
condition|)
name|nports
operator|=
name|ne2100_probe
argument_list|(
name|sc
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
name|nports
operator|==
literal|0
condition|)
name|nports
operator|=
name|depca_probe
argument_list|(
name|sc
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|nports
operator|==
literal|0
condition|)
name|nports
operator|=
name|cnet98s_probe
argument_list|(
name|sc
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|nports
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_comment
comment|/* ISA Bus Configuration Registers */
end_comment

begin_comment
comment|/* XXX - Should be in ic/Am7990.h */
end_comment

begin_define
define|#
directive|define
name|MSRDA
value|0x0000
end_define

begin_comment
comment|/* ISACSR0: Master Mode Read Activity */
end_comment

begin_define
define|#
directive|define
name|MSWRA
value|0x0001
end_define

begin_comment
comment|/* ISACSR1: Master Mode Write Activity */
end_comment

begin_define
define|#
directive|define
name|MC
value|0x0002
end_define

begin_comment
comment|/* ISACSR2: Miscellaneous Configuration */
end_comment

begin_define
define|#
directive|define
name|LED1
value|0x0005
end_define

begin_comment
comment|/* ISACSR5: LED1 Status */
end_comment

begin_define
define|#
directive|define
name|LED2
value|0x0006
end_define

begin_comment
comment|/* ISACSR6: LED2 Status */
end_comment

begin_define
define|#
directive|define
name|LED3
value|0x0007
end_define

begin_comment
comment|/* ISACSR7: LED3 Status */
end_comment

begin_define
define|#
directive|define
name|LED_PSE
value|0x0080
end_define

begin_comment
comment|/* Pulse Stretcher */
end_comment

begin_define
define|#
directive|define
name|LED_XMTE
value|0x0010
end_define

begin_comment
comment|/* Transmit Status */
end_comment

begin_define
define|#
directive|define
name|LED_RVPOLE
value|0x0008
end_define

begin_comment
comment|/* Receive Polarity */
end_comment

begin_define
define|#
directive|define
name|LED_RCVE
value|0x0004
end_define

begin_comment
comment|/* Receive Status */
end_comment

begin_define
define|#
directive|define
name|LED_JABE
value|0x0002
end_define

begin_comment
comment|/* Jabber */
end_comment

begin_define
define|#
directive|define
name|LED_COLE
value|0x0001
end_define

begin_comment
comment|/* Collision */
end_comment

begin_function
specifier|static
name|int
name|cnet98s_probe
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|iobase
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ushort
name|tmp
decl_stmt|;
name|sc
operator|->
name|rap
operator|=
name|iobase
operator|+
name|CNET98S_RAP
expr_stmt|;
name|sc
operator|->
name|rdp
operator|=
name|iobase
operator|+
name|CNET98S_RDP
expr_stmt|;
comment|/* Reset */
name|tmp
operator|=
name|inw
argument_list|(
name|iobase
operator|+
name|CNET98S_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|CNET98S_RESET
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nic
operator|.
name|ic
operator|=
name|pcnet_probe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|==
name|UNKNOWN
operator|)
operator|||
operator|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|>
name|PCnet_32
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|nic
operator|.
name|ident
operator|=
name|CNET98S
expr_stmt|;
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|=
name|DMA_FIXED
expr_stmt|;
comment|/* XXX - For now just use the defines */
name|sc
operator|->
name|nrdre
operator|=
name|NRDRE
expr_stmt|;
name|sc
operator|->
name|ntdre
operator|=
name|NTDRE
expr_stmt|;
comment|/* Extract MAC address from PROM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|iobase
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * ISA Configuration 	 * 	 * XXX - Following parameters are Contec C-NET(98)S only. 	 *       So, check the Ethernet address here. 	 * 	 *       Contec uses 00 80 4c ?? ?? ?? 	 */
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|0
index|]
operator|==
operator|(
name|u_char
operator|)
literal|0x00
operator|&&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|1
index|]
operator|==
operator|(
name|u_char
operator|)
literal|0x80
operator|&&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|2
index|]
operator|==
operator|(
name|u_char
operator|)
literal|0x4c
condition|)
block|{
name|outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|MSRDA
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|CNET98S_IDP
argument_list|,
literal|0x0006
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|MSWRA
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|CNET98S_IDP
argument_list|,
literal|0x0006
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|MC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ISACSR2 = %x\n"
argument_list|,
name|inw
argument_list|(
name|iobase
operator|+
name|CNET98S_IDP
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|LED1
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|CNET98S_IDP
argument_list|,
name|LED_PSE
operator||
name|LED_XMTE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|LED2
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|CNET98S_IDP
argument_list|,
name|LED_PSE
operator||
name|LED_RCVE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|LED3
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|CNET98S_IDP
argument_list|,
name|LED_PSE
operator||
name|LED_COLE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|CNET98S_IOSIZE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ne2100_probe
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|iobase
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|rap
operator|=
name|iobase
operator|+
name|PCNET_RAP
expr_stmt|;
name|sc
operator|->
name|rdp
operator|=
name|iobase
operator|+
name|PCNET_RDP
expr_stmt|;
name|sc
operator|->
name|nic
operator|.
name|ic
operator|=
name|pcnet_probe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|<
name|PCnet_PCI
operator|)
condition|)
block|{
name|sc
operator|->
name|nic
operator|.
name|ident
operator|=
name|NE2100
expr_stmt|;
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|=
name|DMA_FIXED
expr_stmt|;
comment|/* XXX - For now just use the defines */
name|sc
operator|->
name|nrdre
operator|=
name|NRDRE
expr_stmt|;
name|sc
operator|->
name|ntdre
operator|=
name|NTDRE
expr_stmt|;
comment|/* Extract MAC address from PROM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|NE2100_IOSIZE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bicc_probe
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|iobase
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * There isn't any way to determine if a NIC is a BICC. Basically, if 	 * the lance probe succeeds using the i/o addresses of the BICC then 	 * we assume it's a BICC. 	 * 	 */
name|sc
operator|->
name|rap
operator|=
name|iobase
operator|+
name|BICC_RAP
expr_stmt|;
name|sc
operator|->
name|rdp
operator|=
name|iobase
operator|+
name|BICC_RDP
expr_stmt|;
comment|/* I think all these cards us the Am7990 */
if|if
condition|(
operator|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|=
name|lance_probe
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|sc
operator|->
name|nic
operator|.
name|ident
operator|=
name|BICC
expr_stmt|;
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|=
name|DMA_FIXED
expr_stmt|;
comment|/* XXX - For now just use the defines */
name|sc
operator|->
name|nrdre
operator|=
name|NRDRE
expr_stmt|;
name|sc
operator|->
name|ntdre
operator|=
name|NTDRE
expr_stmt|;
comment|/* Extract MAC address from PROM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|iobase
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|BICC_IOSIZE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * I don't have data sheets for the dec cards but it looks like the mac  * address is contained in a 32 byte ring. Each time you read from the port  * you get the next byte in the ring. The mac address is stored after a  * signature so keep searching for the signature first.  */
end_comment

begin_function
specifier|static
name|int
name|dec_macaddr_extract
parameter_list|(
name|u_char
name|ring
index|[]
parameter_list|,
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
name|signature
index|[]
init|=
block|{
literal|0xff
block|,
literal|0x00
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0xff
block|,
literal|0x00
block|,
literal|0x55
block|,
literal|0xaa
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rindex
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|ring
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|rindex
operator|=
name|i
init|;
name|j
operator|<
sizeof|sizeof
name|signature
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ring
index|[
name|rindex
index|]
operator|!=
name|signature
index|[
name|j
index|]
condition|)
break|break;
if|if
condition|(
operator|++
name|rindex
operator|>
sizeof|sizeof
name|ring
condition|)
name|rindex
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
sizeof|sizeof
name|signature
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|rindex
operator|=
name|i
init|;
name|j
operator|<
name|ETHER_ADDR_LEN
condition|;
name|j
operator|++
control|)
block|{
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|j
index|]
operator|=
name|ring
index|[
name|rindex
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|rindex
operator|>
sizeof|sizeof
name|ring
condition|)
name|rindex
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|depca_probe
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|iobase
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|maddr_ring
index|[
name|DEPCA_ADDR_ROM_SIZE
index|]
decl_stmt|;
name|sc
operator|->
name|rap
operator|=
name|iobase
operator|+
name|DEPCA_RAP
expr_stmt|;
name|sc
operator|->
name|rdp
operator|=
name|iobase
operator|+
name|DEPCA_RDP
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|=
name|lance_probe
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|sc
operator|->
name|nic
operator|.
name|ident
operator|=
name|DEPCA
expr_stmt|;
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|=
name|SHMEM
expr_stmt|;
comment|/* Extract MAC address from PROM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DEPCA_ADDR_ROM_SIZE
condition|;
name|i
operator|++
control|)
name|maddr_ring
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|DEPCA_ADP
argument_list|)
expr_stmt|;
if|if
condition|(
name|dec_macaddr_extract
argument_list|(
name|maddr_ring
argument_list|,
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
name|DEPCA_IOSIZE
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lance_probe
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|STOP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|)
operator|&
name|STOP
operator|)
operator|&&
operator|!
operator|(
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR3
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Check to see if it's a C-LANCE. For the LANCE the INEA bit 		 * cannot be set while the STOP bit is. This restriction is 		 * removed for the C-LANCE. 		 */
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|INEA
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
operator|&
name|INEA
condition|)
return|return
operator|(
name|C_LANCE
operator|)
return|;
else|else
return|return
operator|(
name|LANCE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|UNKNOWN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcnet_probe
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_long
name|chip_id
decl_stmt|;
name|int
name|type
decl_stmt|;
comment|/* 	 * The PCnet family don't reset the RAP register on reset so we'll 	 * have to write during the probe :-) It does have an ID register 	 * though so the probe is just a matter of reading it. 	 */
if|if
condition|(
operator|(
name|type
operator|=
name|lance_probe
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|chip_id
operator|=
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR89
argument_list|)
expr_stmt|;
name|chip_id
operator|<<=
literal|16
expr_stmt|;
name|chip_id
operator||=
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR88
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip_id
operator|&
name|AMD_MASK
condition|)
block|{
name|chip_id
operator|>>=
literal|12
expr_stmt|;
switch|switch
condition|(
name|chip_id
operator|&
name|PART_MASK
condition|)
block|{
case|case
name|Am79C960
case|:
return|return
operator|(
name|PCnet_ISA
operator|)
return|;
case|case
name|Am79C961
case|:
return|return
operator|(
name|PCnet_ISAplus
operator|)
return|;
case|case
name|Am79C961A
case|:
return|return
operator|(
name|PCnet_ISA_II
operator|)
return|;
case|case
name|Am79C965
case|:
return|return
operator|(
name|PCnet_32
operator|)
return|;
case|case
name|Am79C970
case|:
return|return
operator|(
name|PCnet_PCI
operator|)
return|;
case|case
name|Am79C970A
case|:
return|return
operator|(
name|PCnet_PCI_II
operator|)
return|;
case|case
name|Am79C971
case|:
return|return
operator|(
name|PCnet_FAST
operator|)
return|;
case|case
name|Am79C972
case|:
return|return
operator|(
name|PCnet_FASTplus
operator|)
return|;
default|default:
break|break;
block|}
block|}
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lnc_attach_sc
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|int
name|lnc_mem_size
decl_stmt|;
comment|/* 	 * Allocate memory for use by the controller. 	 * 	 * XXX -- the Am7990 and Am79C960 only have 24 address lines and so can 	 * only access the lower 16Mb of physical memory. For the moment we 	 * assume that malloc will allocate memory within the lower 16Mb 	 * range. This is not a very valid assumption but there's nothing 	 * that can be done about it yet. For shared memory NICs this isn't 	 * relevant. 	 * 	 */
name|lnc_mem_size
operator|=
operator|(
operator|(
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
operator|+
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|host_ring_entry
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|!=
name|SHMEM
condition|)
name|lnc_mem_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|init_block
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|mds
argument_list|)
operator|*
operator|(
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
operator|+
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
operator|)
operator|)
operator|+
name|MEM_SLEW
expr_stmt|;
comment|/* If using DMA to fixed host buffers then allocate memory for them */
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|==
name|DMA_FIXED
condition|)
name|lnc_mem_size
operator|+=
operator|(
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
operator|*
name|RECVBUFSIZE
operator|)
operator|+
operator|(
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
operator|*
name|TRANSBUFSIZE
operator|)
expr_stmt|;
name|sc
operator|->
name|recv_ring
operator|=
name|malloc
argument_list|(
name|lnc_mem_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|recv_ring
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Couldn't allocate memory for NIC\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX -- attach failed -- not tested in 				 * calling routines */
block|}
comment|/* 	 * XXX - Shouldn't this be skipped for the EISA and PCI versions ??? 	 *       Print the message but do not return for the PCnet_PCI ! 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|!=
name|SHMEM
operator|)
operator|&&
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|recv_ring
argument_list|)
operator|>
literal|0x1000000
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Memory allocated above 16Mb limit\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|!=
name|PCnet_PCI
operator|)
operator|&&
operator|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|!=
name|PCnet_PCI_II
operator|)
operator|&&
operator|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|!=
name|PCnet_FAST
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Set default mode */
name|sc
operator|->
name|nic
operator|.
name|mode
operator|=
name|NORMAL
expr_stmt|;
comment|/* Fill in arpcom structure entries */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_name
operator|=
name|lncdriver
operator|.
name|name
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_start
operator|=
name|lnc_start
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ioctl
operator|=
name|lnc_ioctl
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_watchdog
operator|=
name|lnc_watchdog
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_addrlen
operator|=
name|ETHER_ADDR_LEN
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_hdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
comment|/* 	 * XXX -- should check return status of if_attach 	 */
name|if_attach
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lnc%d: "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|==
name|LANCE
operator|||
name|sc
operator|->
name|nic
operator|.
name|ic
operator|==
name|C_LANCE
condition|)
name|printf
argument_list|(
literal|"%s (%s)"
argument_list|,
name|nic_ident
index|[
name|sc
operator|->
name|nic
operator|.
name|ident
index|]
argument_list|,
name|ic_ident
index|[
name|sc
operator|->
name|nic
operator|.
name|ic
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ic_ident
index|[
name|sc
operator|->
name|nic
operator|.
name|ic
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" address %6D\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lnc_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|isa_dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|isa_dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|lnc_softc
modifier|*
name|sc
init|=
operator|&
name|lnc_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|result
init|=
name|lnc_attach_sc
argument_list|(
name|sc
argument_list|,
name|unit
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifndef|#
directive|ifndef
name|PC98
comment|/* 	 * XXX - is it safe to call isa_dmacascade() after if_attach()  	 *       and ether_ifattach() have been called in lnc_attach() ??? 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|!=
name|SHMEM
operator|)
operator|&&
operator|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|<
name|PCnet_32
operator|)
condition|)
name|isa_dmacascade
argument_list|(
name|isa_dev
operator|->
name|id_drq
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_function
name|void
modifier|*
name|lnc_attach_ne2100_pci
parameter_list|(
name|int
name|unit
parameter_list|,
name|unsigned
name|iobase
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|lnc_softc
modifier|*
name|sc
init|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
condition|)
block|{
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
expr|*
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rap
operator|=
name|iobase
operator|+
name|PCNET_RAP
expr_stmt|;
name|sc
operator|->
name|rdp
operator|=
name|iobase
operator|+
name|PCNET_RDP
expr_stmt|;
name|sc
operator|->
name|bdp
operator|=
name|iobase
operator|+
name|PCNET_BDP
expr_stmt|;
name|sc
operator|->
name|nic
operator|.
name|ic
operator|=
name|pcnet_probe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|>=
name|PCnet_PCI
condition|)
block|{
name|sc
operator|->
name|nic
operator|.
name|ident
operator|=
name|NE2100
expr_stmt|;
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|=
name|DMA_FIXED
expr_stmt|;
comment|/* XXX - For now just use the defines */
name|sc
operator|->
name|nrdre
operator|=
name|NRDRE
expr_stmt|;
name|sc
operator|->
name|ntdre
operator|=
name|NTDRE
expr_stmt|;
comment|/* Extract MAC address from PROM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnc_attach_sc
argument_list|(
name|sc
argument_list|,
name|unit
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|sc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|lnc_init
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|lnc_mem
decl_stmt|;
comment|/* Check that interface has valid address */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_addrhead
argument_list|)
condition|)
comment|/* XXX unlikely */
return|return;
comment|/* Shut down interface */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|lnc_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
comment|/* XXX??? */
comment|/* 	 * This sets up the memory area for the controller. Memory is set up for 	 * the initialisation block (12 words of contiguous memory starting 	 * on a word boundary),the transmit and receive ring structures (each 	 * entry is 4 words long and must start on a quadword boundary) and 	 * the data buffers. 	 * 	 * The alignment tests are particularly paranoid. 	 */
name|sc
operator|->
name|recv_next
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|trans_ring
operator|=
name|sc
operator|->
name|recv_ring
operator|+
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
expr_stmt|;
name|sc
operator|->
name|trans_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|==
name|SHMEM
condition|)
name|lnc_mem
operator|=
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|nic
operator|.
name|iobase
expr_stmt|;
else|else
name|lnc_mem
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
operator|)
expr_stmt|;
name|lnc_mem
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|lnc_mem
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|sc
operator|->
name|init_block
operator|=
operator|(
expr|struct
name|init_block
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|lnc_mem
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|lnc_mem
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|sc
operator|->
name|init_block
operator|+
literal|1
operator|)
expr_stmt|;
name|lnc_mem
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|lnc_mem
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
expr_stmt|;
comment|/* Initialise pointers to descriptor entries */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|=
operator|(
expr|struct
name|mds
operator|*
operator|)
name|lnc_mem
expr_stmt|;
name|lnc_mem
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mds
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|=
operator|(
expr|struct
name|mds
operator|*
operator|)
name|lnc_mem
expr_stmt|;
name|lnc_mem
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mds
argument_list|)
expr_stmt|;
block|}
comment|/* Initialise the remaining ring entries */
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|==
name|DMA_MBUF
condition|)
block|{
name|sc
operator|->
name|mbufs
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mbuf_count
operator|=
literal|0
expr_stmt|;
comment|/* Free previously allocated mbufs */
if|if
condition|(
name|sc
operator|->
name|initialised
condition|)
name|lnc_free_mbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|alloc_mbuf_cluster
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|recv_ring
operator|+
name|i
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Initialisation failed -- no mbufs\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|mbuf
operator|=
literal|0
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md0
operator|=
literal|0
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md1
operator|=
literal|0
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md2
operator|=
literal|0
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md3
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md0
operator|=
name|kvtop
argument_list|(
name|lnc_mem
argument_list|)
expr_stmt|;
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md1
operator|=
operator|(
operator|(
name|kvtop
argument_list|(
name|lnc_mem
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
name|OWN
expr_stmt|;
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md2
operator|=
operator|-
name|RECVBUFSIZE
expr_stmt|;
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md3
operator|=
literal|0
expr_stmt|;
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|data
operator|=
name|lnc_mem
expr_stmt|;
name|lnc_mem
operator|+=
name|RECVBUFSIZE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md0
operator|=
name|kvtop
argument_list|(
name|lnc_mem
argument_list|)
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md1
operator|=
operator|(
operator|(
name|kvtop
argument_list|(
name|lnc_mem
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md2
operator|=
literal|0
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md3
operator|=
literal|0
expr_stmt|;
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|data
operator|=
name|lnc_mem
expr_stmt|;
name|lnc_mem
operator|+=
name|TRANSBUFSIZE
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|next_to_send
operator|=
literal|0
expr_stmt|;
comment|/* Set up initialisation block */
name|sc
operator|->
name|init_block
operator|->
name|mode
operator|=
name|sc
operator|->
name|nic
operator|.
name|mode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|init_block
operator|->
name|padr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|LNC_MULTICAST
name|lnc_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MULTICAST_FILTER_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|init_block
operator|->
name|ladrf
index|[
name|i
index|]
operator|=
name|MULTI_INIT_ADDR
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|init_block
operator|->
name|rdra
operator|=
name|kvtop
argument_list|(
name|sc
operator|->
name|recv_ring
operator|->
name|md
argument_list|)
expr_stmt|;
name|sc
operator|->
name|init_block
operator|->
name|rlen
operator|=
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|recv_ring
operator|->
name|md
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|sc
operator|->
name|nrdre
operator|<<
literal|13
operator|)
expr_stmt|;
name|sc
operator|->
name|init_block
operator|->
name|tdra
operator|=
name|kvtop
argument_list|(
name|sc
operator|->
name|trans_ring
operator|->
name|md
argument_list|)
expr_stmt|;
name|sc
operator|->
name|init_block
operator|->
name|tlen
operator|=
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|trans_ring
operator|->
name|md
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|sc
operator|->
name|ntdre
operator|<<
literal|13
operator|)
expr_stmt|;
comment|/* Set initialised to show that the memory area is valid */
name|sc
operator|->
name|initialised
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|pending_transmits
operator|=
literal|0
expr_stmt|;
comment|/* Give the LANCE the physical address of the initialisation block */
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR1
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|init_block
argument_list|)
argument_list|)
expr_stmt|;
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR2
argument_list|,
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|init_block
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 	 * Depending on which controller this is, CSR3 has different meanings. 	 * For the Am7990 it controls DMA operations, for the Am79C960 it 	 * controls interrupt masks and transmitter algorithms. In either 	 * case, none of the flags are set. 	 * 	 */
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Let's see if it starts */
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|INIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
operator|&
name|IDON
condition|)
break|break;
comment|/* 	 * Now that the initialisation is complete there's no reason to 	 * access anything except CSR0, so we leave RAP pointing there 	 * so we can just access RDP from now on, saving an outw each 	 * time. 	 */
if|if
condition|(
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
operator|&
name|IDON
condition|)
block|{
comment|/* 		 * Enable interrupts, start the LANCE, mark the interface as 		 * running and transmit any pending packets. 		 */
name|write_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|STRT
operator||
name|INEA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|lnc_start
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Initialisation failed\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The interrupt flag (INTR) will be set and provided that the interrupt enable  * flag (INEA) is also set, the interrupt pin will be driven low when any of  * the following occur:  *  * 1) Completion of the initialisation routine (IDON). 2) The reception of a  * packet (RINT). 3) The transmission of a packet (TINT). 4) A transmitter  * timeout error (BABL). 5) A missed packet (MISS). 6) A memory error (MERR).  *  * The interrupt flag is cleared when all of the above conditions are cleared.  *  * If the driver is reset from this routine then it first checks to see if any  * interrupts have ocurred since the reset and handles them before returning.  * This is because the NIC may signify a pending interrupt in CSR0 using the  * INTR flag even if a hardware interrupt is currently inhibited (at least I  * think it does from reading the data sheets). We may as well deal with  * these pending interrupts now rather than get the overhead of another  * hardware interrupt immediately upon returning from the interrupt handler.  *  */
end_comment

begin_function
name|void
name|lncintr_sc
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
decl_stmt|;
name|u_short
name|csr0
decl_stmt|;
comment|/* 	 * INEA is the only bit that can be cleared by writing a 0 to it so 	 * we have to include it in any writes that clear other flags. 	 */
while|while
condition|(
operator|(
name|csr0
operator|=
name|inw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|)
operator|)
operator|&
name|INTR
condition|)
block|{
comment|/* 		 * Clear interrupt flags early to avoid race conditions. The 		 * controller can still set these flags even while we're in 		 * this interrupt routine. If the flag is still set from the 		 * event that caused this interrupt any new events will 		 * be missed. 		 */
comment|/*		outw(sc->rdp, IDON | CERR | BABL | MISS | MERR | RINT | TINT | INEA); */
name|outw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|,
name|csr0
argument_list|)
expr_stmt|;
comment|/* We don't do anything with the IDON flag */
if|if
condition|(
name|csr0
operator|&
name|ERR
condition|)
block|{
if|if
condition|(
name|csr0
operator|&
name|CERR
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Heartbeat error -- SQE test failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|LNCSTATS
argument_list|(
argument|cerr
argument_list|)
block|}
if|if
condition|(
name|csr0
operator|&
name|BABL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Babble error - more than 1519 bytes transmitted\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|LNCSTATS
argument_list|(
argument|babl
argument_list|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|csr0
operator|&
name|MISS
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Missed packet -- no receive buffer\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|LNCSTATS
argument_list|(
argument|miss
argument_list|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|csr0
operator|&
name|MERR
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Memory error  -- Resetting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|LNCSTATS
argument_list|(
argument|merr
argument_list|)
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|csr0
operator|&
name|RINT
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|rint
argument_list|)
name|lnc_rint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csr0
operator|&
name|TINT
condition|)
block|{
name|LNCSTATS
argument_list|(
argument|tint
argument_list|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|lnc_tint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If there's room in the transmit descriptor ring then queue 		 * some more transmit packets. 		 */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
condition|)
name|lnc_start
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|lncintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|lnc_softc
modifier|*
name|sc
init|=
operator|&
name|lnc_softc
index|[
name|unit
index|]
decl_stmt|;
name|lncintr_sc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|mbuf_to_buffer
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|chain_to_cluster
argument_list|(
argument|struct mbuf *m
argument_list|)
block|{ 	struct
name|mbuf
operator|*
name|new
block|;
name|MGET
argument_list|(
name|new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
block|;
if|if
condition|(
name|new
condition|)
block|{
name|MCLGET
argument_list|(
name|new
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|m_ext
operator|.
name|ext_buf
condition|)
block|{
name|new
operator|->
name|m_len
operator|=
name|mbuf_to_buffer
argument_list|(
name|m
argument_list|,
name|new
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_expr_stmt

begin_else
else|else
name|m_free
argument_list|(
name|new
argument_list|)
expr_stmt|;
end_else

begin_expr_stmt
unit|} 	return
operator|(
literal|0
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * IFF_OACTIVE and IFF_RUNNING are checked in ether_output so it's redundant  * to check them again since we wouldn't have got here if they were not  * appropriately set. This is also called from lnc_init and lncintr but the  * flags should be ok at those points too.  */
end_comment

begin_function
unit|static
name|void
name|lnc_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lnc_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|host_ring_entry
modifier|*
name|desc
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|int
name|end_of_packet
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|head
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|,
name|chunk
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|no_entries_needed
decl_stmt|;
do|do
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|==
name|DMA_MBUF
condition|)
block|{
name|no_entries_needed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|head
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|no_entries_needed
operator|++
expr_stmt|;
comment|/* 			 * We try and avoid bcopy as much as possible 			 * but there are two cases when we use it. 			 * 			 * 1) If there are not enough free entries in the ring 			 * to hold each mbuf in the chain then compact the 			 * chain into a single cluster. 			 * 			 * 2) The Am7990 and Am79C90 must not have less than 			 * 100 bytes in the first descriptor of a chained 			 * packet so it's necessary to shuffle the mbuf 			 * contents to ensure this. 			 */
if|if
condition|(
name|no_entries_needed
operator|>
operator|(
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
operator|-
name|sc
operator|->
name|pending_transmits
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|head
operator|=
name|chain_to_cluster
argument_list|(
name|head
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Couldn't get mbuf for transmit packet -- Resetting \n "
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|lnc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|==
name|LANCE
operator|)
operator|||
operator|(
name|sc
operator|->
name|nic
operator|.
name|ic
operator|==
name|C_LANCE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|head
operator|->
name|m_len
operator|<
literal|100
operator|)
operator|&&
operator|(
name|head
operator|->
name|m_next
operator|)
condition|)
block|{
name|len
operator|=
literal|100
operator|-
name|head
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|head
argument_list|)
operator|<
name|len
condition|)
block|{
comment|/* 						 * Move data to start of data 						 * area. We assume the first 						 * mbuf has a packet header 						 * and is not a cluster. 						 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|head
operator|->
name|m_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|head
operator|->
name|m_pktdat
argument_list|,
name|head
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|head
operator|->
name|m_data
operator|=
name|head
operator|->
name|m_pktdat
expr_stmt|;
block|}
name|m
operator|=
name|head
operator|->
name|m_next
expr_stmt|;
while|while
condition|(
name|m
operator|&&
operator|(
name|len
operator|>
literal|0
operator|)
condition|)
block|{
name|chunk
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|head
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|head
operator|->
name|m_len
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|len
operator|-=
name|chunk
expr_stmt|;
name|head
operator|->
name|m_len
operator|+=
name|chunk
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|chunk
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|chunk
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
literal|0
condition|)
block|{
name|MFREE
argument_list|(
name|m
argument_list|,
name|head
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|m
operator|=
name|head
operator|->
name|m_next
expr_stmt|;
block|}
block|}
block|}
block|}
name|tmp
operator|=
name|sc
operator|->
name|next_to_send
expr_stmt|;
comment|/* 			 * On entering this loop we know that tmp points to a 			 * descriptor with a clear OWN bit. 			 */
name|desc
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|tmp
expr_stmt|;
name|len
operator|=
name|ETHER_MIN_LEN
expr_stmt|;
for|for
control|(
name|m
operator|=
name|head
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|desc
operator|->
name|buff
operator|.
name|mbuf
operator|=
name|m
expr_stmt|;
name|addr
operator|=
name|kvtop
argument_list|(
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md0
operator|=
name|addr
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md1
operator|=
operator|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md3
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md2
operator|=
operator|-
name|m
operator|->
name|m_len
expr_stmt|;
name|sc
operator|->
name|pending_transmits
operator|++
expr_stmt|;
name|len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|INC_MD_PTR
argument_list|(
argument|tmp
argument_list|,
argument|sc->ntdre
argument_list|)
name|desc
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|tmp
expr_stmt|;
block|}
name|end_of_packet
operator|=
name|tmp
expr_stmt|;
name|DEC_MD_PTR
argument_list|(
argument|tmp
argument_list|,
argument|sc->ntdre
argument_list|)
name|desc
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|tmp
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md1
operator||=
name|ENP
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|desc
operator|->
name|md
operator|->
name|md2
operator|-=
name|len
expr_stmt|;
comment|/* 			 * Set OWN bits in reverse order, otherwise the Lance 			 * could start sending the packet before all the 			 * buffers have been relinquished by the host. 			 */
while|while
condition|(
name|tmp
operator|!=
name|sc
operator|->
name|next_to_send
condition|)
block|{
name|desc
operator|->
name|md
operator|->
name|md1
operator||=
name|OWN
expr_stmt|;
name|DEC_MD_PTR
argument_list|(
argument|tmp
argument_list|,
argument|sc->ntdre
argument_list|)
name|desc
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|tmp
expr_stmt|;
block|}
name|sc
operator|->
name|next_to_send
operator|=
name|end_of_packet
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md1
operator||=
name|STP
operator||
name|OWN
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|pending_transmits
operator|++
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|next_to_send
expr_stmt|;
name|len
operator|=
name|mbuf_to_buffer
argument_list|(
name|head
argument_list|,
name|desc
operator|->
name|buff
operator|.
name|data
argument_list|)
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md3
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md2
operator|=
operator|-
name|max
argument_list|(
name|len
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
name|desc
operator|->
name|md
operator|->
name|md1
operator||=
name|OWN
operator||
name|STP
operator||
name|ENP
expr_stmt|;
name|INC_MD_PTR
argument_list|(
argument|sc->next_to_send
argument_list|,
argument|sc->ntdre
argument_list|)
block|}
comment|/* Force an immediate poll of the transmit ring */
name|outw
argument_list|(
name|sc
operator|->
name|rdp
argument_list|,
name|TDMD
operator||
name|INEA
argument_list|)
expr_stmt|;
comment|/* 		 * Set a timer so if the buggy Am7990.h shuts 		 * down we can wake it up. 		 */
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|head
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mem_mode
operator|!=
name|DMA_MBUF
condition|)
name|m_freem
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sc
operator|->
name|pending_transmits
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
condition|)
do|;
comment|/* 	 * Transmit ring is full so set IFF_OACTIVE 	 * since we can't buffer any more packets. 	 */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|LNCSTATS
argument_list|(
argument|trans_ring_full
argument_list|)
block|}
end_function

begin_function
specifier|static
name|int
name|lnc_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|lnc_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|lnc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|arp_ifinit
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|lnc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|sc
operator|->
name|lnc_debug
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|lnc_debug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|nic
operator|.
name|mode
operator|&
name|PROM
operator|)
condition|)
block|{
name|sc
operator|->
name|nic
operator|.
name|mode
operator||=
name|PROM
expr_stmt|;
name|lnc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|nic
operator|.
name|mode
operator|&
name|PROM
condition|)
block|{
name|sc
operator|->
name|nic
operator|.
name|mode
operator|&=
operator|~
name|PROM
expr_stmt|;
name|lnc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If interface is marked down and it is running, 			 * then stop it. 			 */
name|lnc_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If interface is marked up and it is stopped, then 			 * start it. 			 */
name|lnc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|LNC_MULTICAST
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|lnc_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCSIFMTU
case|:
comment|/* 		 * Set the interface MTU. 		 */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lnc_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lnc%d: Device timeout -- Resetting\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|lnc_reset
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|lnc_dump_state
parameter_list|(
name|struct
name|lnc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\nDriver/NIC [%d] state dump\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Memory access mode: %b\n"
argument_list|,
name|sc
operator|->
name|nic
operator|.
name|mem_mode
argument_list|,
name|MEM_MODES
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Host memory\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-----------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Receive ring: base = %p, next = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|recv_ring
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|sc
operator|->
name|recv_next
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t%d:%p md = %p buff = %p\n"
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Transmit ring: base = %p, next = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|trans_ring
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|sc
operator|->
name|trans_next
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t%d:%p md = %p buff = %p\n"
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|buff
operator|.
name|data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Lance memory (may be on host(DMA) or card(SHMEM))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Init block = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|init_block
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tmode = %b rlen:rdra = %x:%x tlen:tdra = %x:%x\n"
argument_list|,
name|sc
operator|->
name|init_block
operator|->
name|mode
argument_list|,
name|INIT_MODE
argument_list|,
name|sc
operator|->
name|init_block
operator|->
name|rlen
argument_list|,
name|sc
operator|->
name|init_block
operator|->
name|rdra
argument_list|,
name|sc
operator|->
name|init_block
operator|->
name|tlen
argument_list|,
name|sc
operator|->
name|init_block
operator|->
name|tdra
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Receive descriptor ring\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|nrdre
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t%d buffer = 0x%x%x, BCNT = %d,\tMCNT = %u,\tflags = %b\n"
argument_list|,
name|i
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md1
operator|&
name|HADR
operator|)
argument_list|,
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md0
argument_list|,
operator|-
call|(
name|short
call|)
argument_list|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
argument_list|)
operator|->
name|md
operator|->
name|md2
argument_list|,
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md3
argument_list|,
operator|(
operator|(
operator|(
name|sc
operator|->
name|recv_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md1
operator|&
operator|~
name|HADR
operator|)
operator|>>
literal|8
operator|)
argument_list|,
name|RECV_MD1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Transmit descriptor ring\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDESC
argument_list|(
name|sc
operator|->
name|ntdre
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t%d buffer = 0x%x%x, BCNT = %d,\tflags = %b %b\n"
argument_list|,
name|i
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md1
operator|&
name|HADR
operator|)
argument_list|,
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md0
argument_list|,
operator|-
call|(
name|short
call|)
argument_list|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
argument_list|)
operator|->
name|md
operator|->
name|md2
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md1
operator|>>
literal|8
operator|)
argument_list|,
name|TRANS_MD1
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|trans_ring
operator|+
name|i
operator|)
operator|->
name|md
operator|->
name|md3
operator|>>
literal|10
operator|)
argument_list|,
name|TRANS_MD3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nnext_to_send = %x\n"
argument_list|,
name|sc
operator|->
name|next_to_send
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n CSR0 = %b CSR1 = %x CSR2 = %x CSR3 = %x\n\n"
argument_list|,
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
argument_list|,
name|CSR0_FLAGS
argument_list|,
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR1
argument_list|)
argument_list|,
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR2
argument_list|)
argument_list|,
name|read_csr
argument_list|(
name|sc
argument_list|,
name|CSR3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set RAP back to CSR0 */
name|outw
argument_list|(
name|sc
operator|->
name|rap
argument_list|,
name|CSR0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mbuf_dump_chain
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
define|#
directive|define
name|MBUF_FLAGS
define|\
value|"\20\1M_EXT\2M_PKTHDR\3M_EOR\4UNKNOWN\5M_BCAST\6M_MCAST"
if|if
condition|(
operator|!
name|m
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m == NULL\n"
argument_list|)
expr_stmt|;
do|do
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m_hdr.mh_next = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|m_hdr
operator|.
name|mh_next
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m_hdr.mh_nextpkt = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|m_hdr
operator|.
name|mh_nextpkt
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m_hdr.mh_len = %d\n"
argument_list|,
name|m
operator|->
name|m_hdr
operator|.
name|mh_len
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m_hdr.mh_data = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|m_hdr
operator|.
name|mh_data
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m_hdr.mh_type = %d\n"
argument_list|,
name|m
operator|->
name|m_hdr
operator|.
name|mh_type
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"m_hdr.mh_flags = %b\n"
argument_list|,
name|m
operator|->
name|m_hdr
operator|.
name|mh_flags
argument_list|,
name|MBUF_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_hdr
operator|.
name|mh_flags
operator|&
operator|(
name|M_PKTHDR
operator||
name|M_EXT
operator|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"M_dat.M_databuf = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|M_dat
operator|.
name|M_databuf
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|m
operator|->
name|m_hdr
operator|.
name|mh_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"M_dat.MH.MH_pkthdr.len = %d\n"
argument_list|,
name|m
operator|->
name|M_dat
operator|.
name|MH
operator|.
name|MH_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"M_dat.MH.MH_pkthdr.rcvif = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|M_dat
operator|.
name|MH
operator|.
name|MH_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_hdr
operator|.
name|mh_flags
operator|&
name|M_EXT
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"M_dat.MH.MH_dat.MH_databuf = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|M_dat
operator|.
name|MH
operator|.
name|MH_dat
operator|.
name|MH_databuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_hdr
operator|.
name|mh_flags
operator|&
name|M_EXT
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"M_dat.MH.MH_dat.MH_ext.ext_buff %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|M_dat
operator|.
name|MH
operator|.
name|MH_dat
operator|.
name|MH_ext
operator|.
name|ext_buf
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"M_dat.MH.MH_dat.MH_ext.ext_free %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|M_dat
operator|.
name|MH
operator|.
name|MH_dat
operator|.
name|MH_ext
operator|.
name|ext_free
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"M_dat.MH.MH_dat.MH_ext.ext_size %d\n"
argument_list|,
name|m
operator|->
name|M_dat
operator|.
name|MH
operator|.
name|MH_dat
operator|.
name|MH_ext
operator|.
name|ext_size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|m
operator|=
name|m
operator|->
name|m_next
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

