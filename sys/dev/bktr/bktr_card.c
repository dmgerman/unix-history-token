begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * This is part of the Driver for Video Capture Cards (Frame grabbers)  * and TV Tuner cards using the Brooktree Bt848, Bt848A, Bt849A, Bt878, Bt879  * chipset.  * Copyright Roger Hardiman and Amancio Hasty.  *  * bktr_card : This deals with identifying TV cards.  *               trying to find the card make and model of card.  *               trying to find the type of tuner fitted.  *               reading the configuration EEPROM.  *               locating i2c devices.  *  */
end_comment

begin_comment
comment|/*  * 1. Redistributions of source code must retain the  * Copyright (c) 1997 Amancio Hasty, 1999 Roger Hardiman  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Amancio Hasty and  *      Roger Hardiman  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_bktr.h"
end_include

begin_comment
comment|/* Include any kernel config options */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|500000
operator|)
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|300000
operator|)
end_if

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_comment
comment|/* for bus space */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/ic/bt8xx.h>
end_include

begin_comment
comment|/* NetBSD location for .h files */
end_comment

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_tuner.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_card.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_audio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<machine/ioctl_meteor.h>
end_include

begin_comment
comment|/* Traditional location for .h files */
end_comment

begin_include
include|#
directive|include
file|<machine/ioctl_bt848.h>
end_include

begin_comment
comment|/* extensions to ioctl_meteor.h */
end_comment

begin_include
include|#
directive|include
file|<dev/bktr/bktr_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_tuner.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_card.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_audio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Include the PCI Vendor definitions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/pci/pcidevs.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Various defines */
end_comment

begin_define
define|#
directive|define
name|HAUP_REMOTE_INT_WADDR
value|0x30
end_define

begin_define
define|#
directive|define
name|HAUP_REMOTE_INT_RADDR
value|0x31
end_define

begin_define
define|#
directive|define
name|HAUP_REMOTE_EXT_WADDR
value|0x34
end_define

begin_define
define|#
directive|define
name|HAUP_REMOTE_EXT_RADDR
value|0x35
end_define

begin_comment
comment|/* address of BTSC/SAP decoder chip */
end_comment

begin_define
define|#
directive|define
name|TDA9850_WADDR
value|0xb6
end_define

begin_define
define|#
directive|define
name|TDA9850_RADDR
value|0xb7
end_define

begin_comment
comment|/* address of MSP3400C chip */
end_comment

begin_define
define|#
directive|define
name|MSP3400C_WADDR
value|0x80
end_define

begin_define
define|#
directive|define
name|MSP3400C_RADDR
value|0x81
end_define

begin_comment
comment|/* address of DPL3518A chip */
end_comment

begin_define
define|#
directive|define
name|DPL3518A_WADDR
value|0x84
end_define

begin_define
define|#
directive|define
name|DPL3518A_RADDR
value|0x85
end_define

begin_comment
comment|/* EEProm (128 * 8) on an STB card */
end_comment

begin_define
define|#
directive|define
name|X24C01_WADDR
value|0xae
end_define

begin_define
define|#
directive|define
name|X24C01_RADDR
value|0xaf
end_define

begin_comment
comment|/* EEProm (256 * 8) on a Hauppauge card */
end_comment

begin_comment
comment|/* and on most BT878s cards to store the sub-system vendor id */
end_comment

begin_define
define|#
directive|define
name|PFC8582_WADDR
value|0xa0
end_define

begin_define
define|#
directive|define
name|PFC8582_RADDR
value|0xa1
end_define

begin_if
if|#
directive|if
name|BKTR_SYSTEM_DEFAULT
operator|==
name|BROOKTREE_PAL
end_if

begin_define
define|#
directive|define
name|DEFAULT_TUNER
value|PHILIPS_PALI
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEFAULT_TUNER
value|PHILIPS_NTSC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * the data for each type of card  *  * Note:  *   these entried MUST be kept in the order defined by the CARD_XXX defines!  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|CARDTYPE
name|cards
index|[]
init|=
block|{
block|{
name|CARD_UNKNOWN
block|,
comment|/* the card id */
literal|"Unknown"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx unknown */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* EEProm unknown */
literal|0
block|,
comment|/* EEProm unknown */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_MIRO
block|,
comment|/* the card id */
literal|"Pinnacle/Miro TV"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx unknown */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* EEProm unknown */
literal|0
block|,
comment|/* size unknown */
block|{
literal|0x02
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x0a
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_HAUPPAUGE
block|,
comment|/* the card id */
literal|"Hauppauge WinCast/TV"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
literal|0
block|,
name|PFC8582_WADDR
block|,
comment|/* EEProm type */
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
block|,
comment|/* 256 bytes */
block|{
literal|0x00
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0x04
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_STB
block|,
comment|/* the card id */
literal|"STB TV/PCI"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
literal|0
block|,
name|X24C01_WADDR
block|,
comment|/* EEProm type */
call|(
name|u_char
call|)
argument_list|(
literal|128
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
block|,
comment|/* 128 bytes */
block|{
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_INTEL
block|,
comment|/* the card id */
literal|"Intel Smart Video III/VideoLogic Captivator PCI"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* audio MUX values */
literal|0x00
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_IMS_TURBO
block|,
comment|/* the card id */
literal|"IMS TV Turbo"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
literal|0
block|,
name|PFC8582_WADDR
block|,
comment|/* EEProm type */
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
block|,
comment|/* 256 bytes */
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_AVER_MEDIA
block|,
comment|/* the card id */
literal|"AVer Media TV/FM"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* EEProm type */
literal|0
block|,
comment|/* EEProm size */
block|{
literal|0x0c
block|,
literal|0x08
block|,
literal|0x04
block|,
literal|0x00
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x1f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_OSPREY
block|,
comment|/* the card id */
literal|"MMAC Osprey"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
literal|0
block|,
name|PFC8582_WADDR
block|,
comment|/* EEProm type */
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
block|,
comment|/* 256 bytes */
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0
block|}
block|,
comment|/* audio MUX values */
literal|0
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_NEC_PK
block|,
comment|/* the card id */
literal|"NEC PK-UG-X017"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* EEProm type */
literal|0
block|,
comment|/* EEProm size */
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_IO_GV
block|,
comment|/* the card id */
literal|"I/O DATA GV-BCTV2/PCI"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* EEProm type */
literal|0
block|,
comment|/* EEProm size */
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|1
block|}
block|,
comment|/* Has special MUX handler */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_FLYVIDEO
block|,
comment|/* the card id */
literal|"FlyVideo"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
comment|/* msp34xx is optional */
literal|0
block|,
comment|/* dpl3518a is optional */
literal|0xac
block|,
comment|/* EEProm type */
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
block|,
comment|/* 256 bytes */
block|{
literal|0x000
block|,
literal|0x800
block|,
literal|0x400
block|,
literal|0x8dff00
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x8dff00
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_ZOLTRIX
block|,
comment|/* the card id */
literal|"Zoltrix"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
comment|/* msp34xx is optional */
literal|0
block|,
comment|/* dpl3518a is optional */
literal|0
block|,
comment|/* EEProm type */
literal|0
block|,
comment|/* EEProm size */
block|{
literal|0x04
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x0a
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_KISS
block|,
comment|/* the card id */
literal|"KISS TV/FM PCI"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
comment|/* msp34xx is optional */
literal|0
block|,
comment|/* dpl3518a is optional */
literal|0
block|,
comment|/* EEProm type */
literal|0
block|,
comment|/* EEProm size */
block|{
literal|0x0c
block|,
literal|0x00
block|,
literal|0x0b
block|,
literal|0x0b
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_VIDEO_HIGHWAY_XTREME
block|,
comment|/* the card id */
literal|"Video Highway Xtreme"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* EEProm type */
literal|0
block|,
comment|/* EEProm size */
block|{
literal|0x00
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0x04
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_ASKEY_DYNALINK_MAGIC_TVIEW
block|,
comment|/* the card id */
literal|"Askey/Dynalink Magic TView"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* EEProm type */
literal|0
block|,
comment|/* EEProm size */
block|{
literal|0x400
block|,
literal|0xE00
block|,
literal|0x400
block|,
literal|0xC00
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0xE00
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_LEADTEK
block|,
comment|/* the card id */
literal|"Leadtek Winfast TV 2000"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* EEProm type */
literal|0
block|,
comment|/* EEProm size */
comment|/* Tuner, Extern, Intern, Mute, Enabled */
block|{
literal|0x621000
block|,
literal|0x621000
block|,
literal|0x621000
block|,
literal|0xE21000
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0xfff000
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_TERRATVPLUS
block|,
comment|/* the card id */
literal|"TerraTVplus"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* EEProm type */
literal|0
block|,
comment|/* EEProm size */
block|{
literal|0x20000
block|,
literal|0x00000
block|,
literal|0x30000
block|,
literal|0x40000
block|,
literal|1
block|}
block|,
comment|/* audio MUX values*/
literal|0x70000
block|}
block|,
comment|/* GPIO mask */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bt848_card_sig
name|bt848_card_signature
index|[
literal|1
index|]
init|=
block|{
comment|/* IMS TURBO TV : card 5 */
block|{
literal|5
block|,
literal|9
block|,
block|{
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|02
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Write to the configuration EEPROM on the card.  * This is dangerous and will mess up your card. Therefore it is not  * implemented.  */
end_comment

begin_function
name|int
name|writeEEProm
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the contents of the configuration EEPROM on the card.  * (This is not fitted to all makes of card. All Hauppauge cards have them  * and so do newer Bt878 based cards.  */
end_comment

begin_function
name|int
name|readEEProm
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|max
decl_stmt|;
name|int
name|byte
decl_stmt|;
comment|/* get the address of the EEProm */
name|addr
operator|=
call|(
name|int
call|)
argument_list|(
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|max
operator|=
call|(
name|int
call|)
argument_list|(
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|*
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|+
name|count
operator|)
operator|>
name|max
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* set the start address */
if|if
condition|(
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* the read cycle */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|(
name|byte
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
operator|(
name|addr
operator||
literal|1
operator|)
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|data
index|[
name|x
index|]
operator|=
name|byte
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ABSENT
value|(-1)
end_define

begin_comment
comment|/*  * get a signature of the card  * read all 128 possible i2c read addresses from 0x01 thru 0xff  * build a bit array with a 1 bit for each i2c device that responds  *  * XXX FIXME: use offset& count args  */
end_comment

begin_function
name|int
name|signCard
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|sig
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|16
condition|;
operator|++
name|x
control|)
name|sig
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
operator|(
literal|2
operator|*
name|x
operator|)
operator|+
literal|1
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|sig
index|[
name|x
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * check_for_i2c_devices.  * Some BT848 cards have no tuner and no additional i2c devices  * eg stereo decoder. These are used for video conferencing or capture from  * a video camera. (eg VideoLogic Captivator PCI, Intel SmartCapture card).  *  * Determine if there are any i2c devices present. There are none present if  *  a) reading from all 128 devices returns ABSENT (-1) for each one  *     (eg VideoLogic Captivator PCI with BT848)  *  b) reading from all 128 devices returns 0 for each one  *     (eg VideoLogic Captivator PCI rev. 2F with BT848A)  */
end_comment

begin_function
specifier|static
name|int
name|check_for_i2c_devices
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|temp_read
decl_stmt|;
name|int
name|i2c_all_0
init|=
literal|1
decl_stmt|;
name|int
name|i2c_all_absent
init|=
literal|1
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|128
condition|;
operator|++
name|x
control|)
block|{
name|temp_read
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
operator|(
literal|2
operator|*
name|x
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_read
operator|!=
literal|0
condition|)
name|i2c_all_0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|temp_read
operator|!=
name|ABSENT
condition|)
name|i2c_all_absent
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i2c_all_0
operator|)
operator|||
operator|(
name|i2c_all_absent
operator|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Temic/Philips datasheets say tuners can be at i2c addresses 0xc0, 0xc2,  * 0xc4 or 0xc6, settable by links on the tuner.  * Determine the actual address used on the TV card by probing read addresses.  */
end_comment

begin_function
specifier|static
name|int
name|locate_tuner_address
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xc1
argument_list|)
operator|!=
name|ABSENT
condition|)
return|return
literal|0xc0
return|;
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xc3
argument_list|)
operator|!=
name|ABSENT
condition|)
return|return
literal|0xc2
return|;
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xc5
argument_list|)
operator|!=
name|ABSENT
condition|)
return|return
literal|0xc4
return|;
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xc7
argument_list|)
operator|!=
name|ABSENT
condition|)
return|return
literal|0xc6
return|;
return|return
operator|-
literal|1
return|;
comment|/* no tuner found */
block|}
end_function

begin_comment
comment|/*  * Search for a configuration EEPROM on the i2c bus by looking at i2c addresses  * where EEPROMs are usually found.  * On some cards, the EEPROM appears in several locations, but all in the  * range 0xa0 to 0xae.  */
end_comment

begin_function
specifier|static
name|int
name|locate_eeprom_address
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xa0
argument_list|)
operator|!=
name|ABSENT
condition|)
return|return
literal|0xa0
return|;
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xac
argument_list|)
operator|!=
name|ABSENT
condition|)
return|return
literal|0xac
return|;
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xae
argument_list|)
operator|!=
name|ABSENT
condition|)
return|return
literal|0xae
return|;
return|return
operator|-
literal|1
return|;
comment|/* no eeprom found */
block|}
end_function

begin_comment
comment|/*  * determine the card brand/model  * BKTR_OVERRIDE_CARD, BKTR_OVERRIDE_TUNER, BKTR_OVERRIDE_DBX and  * BKTR_OVERRIDE_MSP can be used to select a specific device,  * regardless of the autodetection and i2c device checks.  *  * The scheme used for probing cards faces these problems:  *  It is impossible to work out which type of tuner is actually fitted,  *  (the driver cannot tell if the Tuner is PAL or NTSC, Temic or Philips)  *  It is impossible to determine what audio-mux hardware is connected.  *  It is impossible to determine if there is extra hardware connected to the  *  GPIO pins  (eg radio chips or MSP34xx reset logic)  *  * However some makes of card (eg Hauppauge) come with a configuration eeprom  * which tells us the make of the card. Most eeproms also tell us the  * tuner type and other features of the the cards.  *  * The current probe code works as follows  * A) If the card uses a Bt878/879:  *   1) Read the sub-system vendor id from the configuration EEPROM.  *      Select the required tuner, audio mux arrangement and any other  *      onboard features. If this fails, move to step B.  * B) If it card uses a Bt848, 848A, 849A or an unknown Bt878/879:  *   1) Look for I2C devices. If there are none fitted, it is an Intel or  *      VideoLogic cards.  *   2) Look for a configuration EEPROM.  *   2a) If there is one at I2C address 0xa0 it may be  *       a Hauppauge or an Osprey. Check the EEPROM contents to determine which  *       one it is. For Hauppauge, select the tuner type and audio hardware.  *   2b) If there is an EEPROM at I2C address 0xa8 it will be an STB card.  *       We still have to guess on the tuner type.  *                * C) If we do not know the card type from (A) or (B), guess at the tuner  *    type based on the I2C address of the tuner.  *  * D) After determining the Tuner Type, we probe the i2c bus for other  *    devices at known locations, eg IR-Remote Control, MSP34xx and TDA  *    stereo chips.  */
end_comment

begin_comment
comment|/*  * These are the sub-system vendor ID codes stored in the  * configuration EEPROM used on Bt878/879 cards. They should match the  * number assigned to the company by the PCI Special Interest Group  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__NetBSD__
end_ifndef

begin_define
define|#
directive|define
name|PCI_VENDOR_HAUPPAUGE
value|0x0070
end_define

begin_define
define|#
directive|define
name|PCI_VENDOR_AVERMEDIA
value|0x1461
end_define

begin_define
define|#
directive|define
name|PCI_VENDOR_STB
value|0x10B4
end_define

begin_define
define|#
directive|define
name|PCI_VENDOR_ASKEY
value|0x144F
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Following not confirmed with http://members.hyperlink.net.au/~chart,    so not added to NetBSD's pcidevs */
end_comment

begin_define
define|#
directive|define
name|PCI_VENDOR_LEADTEK_ALT
value|0x6606
end_define

begin_define
define|#
directive|define
name|PCI_VENDOR_FLYVIDEO
value|0x1851
end_define

begin_define
define|#
directive|define
name|PCI_VENDOR_FLYVIDEO_2
value|0x1852
end_define

begin_define
define|#
directive|define
name|PCI_VENDOR_PINNACLE_ALT
value|0xBD11
end_define

begin_function
name|void
name|probeCard
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|verbose
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|int
name|card
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|card_found
decl_stmt|;
name|int
name|status
decl_stmt|;
name|u_char
name|probe_signature
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|probe_temp
decl_stmt|;
name|int
name|any_i2c_devices
decl_stmt|;
name|u_char
name|eeprom
index|[
literal|256
index|]
decl_stmt|;
name|int
name|tuner_i2c_address
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|eeprom_i2c_address
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Select all GPIO bits as inputs */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_OUT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: GPIO is 0x%08x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAUPPAUGE_MSP_RESET
comment|/* Reset the MSP34xx audio chip. This resolves bootup card 	 * detection problems with old Bt848 based Hauppauge cards with 	 * MSP34xx stereo audio chips. This must be user enabled because 	 * at this point the probe function does not know the card type. */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_OUT_EN
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_OUT_EN
argument_list|)
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|)
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
comment|/* write '1' */
name|DELAY
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
comment|/* wait 2.5ms */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|)
operator|&
operator|~
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
comment|/* write '0' */
name|DELAY
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
comment|/* wait 2.5ms */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|)
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
comment|/* write '1' */
name|DELAY
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
comment|/* wait 2.5ms */
endif|#
directive|endif
comment|/* Check for the presence of i2c devices */
name|any_i2c_devices
operator|=
name|check_for_i2c_devices
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
comment|/* Check for a user specified override on the card selection */
if|#
directive|if
name|defined
argument_list|(
name|BKTR_OVERRIDE_CARD
argument_list|)
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|BKTR_OVERRIDE_CARD
operator|)
index|]
expr_stmt|;
goto|goto
name|checkEEPROM
goto|;
endif|#
directive|endif
if|if
condition|(
name|bktr
operator|->
name|bt848_card
operator|!=
operator|-
literal|1
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|bktr
operator|->
name|bt848_card
operator|)
index|]
expr_stmt|;
goto|goto
name|checkEEPROM
goto|;
block|}
comment|/* No override, so try and determine the make of the card */
comment|/* On BT878/879 cards, read the sub-system vendor id */
comment|/* This identifies the manufacturer of the card and the model */
comment|/* In theory this can be read from PCI registers but this does not */
comment|/* appear to work on the FlyVideo 98. Hauppauge also warned that */
comment|/* the PCI registers are sometimes not loaded correctly. */
comment|/* Therefore, I will read the sub-system vendor ID from the EEPROM */
comment|/* (just like the Bt878 does during power up initialisation) */
if|if
condition|(
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_878
operator|)
operator|||
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_879
operator|)
condition|)
block|{
comment|/* Try and locate the EEPROM */
name|eeprom_i2c_address
operator|=
name|locate_eeprom_address
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom_i2c_address
operator|!=
operator|-
literal|1
condition|)
block|{
name|unsigned
name|int
name|subsystem_vendor_id
decl_stmt|;
comment|/* vendors PCI-SIG ID */
name|unsigned
name|int
name|subsystem_id
decl_stmt|;
comment|/* board model number */
name|unsigned
name|int
name|byte_252
decl_stmt|,
name|byte_253
decl_stmt|,
name|byte_254
decl_stmt|,
name|byte_255
decl_stmt|;
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_UNKNOWN
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
name|readEEProm
argument_list|(
name|bktr
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|eeprom
argument_list|)
expr_stmt|;
name|byte_252
operator|=
operator|(
name|unsigned
name|int
operator|)
name|eeprom
index|[
literal|252
index|]
expr_stmt|;
name|byte_253
operator|=
operator|(
name|unsigned
name|int
operator|)
name|eeprom
index|[
literal|253
index|]
expr_stmt|;
name|byte_254
operator|=
operator|(
name|unsigned
name|int
operator|)
name|eeprom
index|[
literal|254
index|]
expr_stmt|;
name|byte_255
operator|=
operator|(
name|unsigned
name|int
operator|)
name|eeprom
index|[
literal|255
index|]
expr_stmt|;
name|subsystem_id
operator|=
operator|(
name|byte_252
operator|<<
literal|8
operator|)
operator||
name|byte_253
expr_stmt|;
name|subsystem_vendor_id
operator|=
operator|(
name|byte_254
operator|<<
literal|8
operator|)
operator||
name|byte_255
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: subsystem 0x%04x 0x%04x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|subsystem_vendor_id
argument_list|,
name|subsystem_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|subsystem_vendor_id
operator|==
name|PCI_VENDOR_AVERMEDIA
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_AVER_MEDIA
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
if|if
condition|(
name|subsystem_vendor_id
operator|==
name|PCI_VENDOR_HAUPPAUGE
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_HAUPPAUGE
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
if|if
condition|(
operator|(
name|subsystem_vendor_id
operator|==
name|PCI_VENDOR_FLYVIDEO
operator|)
operator|||
operator|(
name|subsystem_vendor_id
operator|==
name|PCI_VENDOR_FLYVIDEO_2
operator|)
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_FLYVIDEO
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
if|if
condition|(
name|subsystem_vendor_id
operator|==
name|PCI_VENDOR_STB
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_STB
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
if|if
condition|(
name|subsystem_vendor_id
operator|==
name|PCI_VENDOR_ASKEY
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_ASKEY_DYNALINK_MAGIC_TVIEW
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
if|if
condition|(
name|subsystem_vendor_id
operator|==
name|PCI_VENDOR_LEADTEK_ALT
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_LEADTEK
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
if|if
condition|(
name|subsystem_vendor_id
operator|==
name|PCI_VENDOR_PINNACLE_ALT
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_MIRO
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
comment|/* Vendor is unknown. We will use the standard probe code */
comment|/* which may not give best results */
name|printf
argument_list|(
literal|"%s: Warning - card vendor 0x%04x (model 0x%04x) unknown.\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|subsystem_vendor_id
argument_list|,
name|subsystem_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: Card has no configuration EEPROM. Cannot determine card make.\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end of bt878/bt879 card detection code */
comment|/* If we get to this point, we must have a Bt848/848A/849A card */
comment|/* or a Bt878/879 with an unknown subsystem vendor id */
comment|/* Try and determine the make of card by clever i2c probing */
comment|/* Check for i2c devices. If none, move on */
if|if
condition|(
operator|!
name|any_i2c_devices
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_INTEL
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
literal|0
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
comment|/* Look for Hauppauge, STB and Osprey cards by the presence */
comment|/* of an EEPROM */
comment|/* Note: Bt878 based cards also use EEPROMs so we can only do this */
comment|/* test on BT848/848A and 849A based cards. */
if|if
condition|(
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848
operator|)
operator|||
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848A
operator|)
operator|||
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_849A
operator|)
condition|)
block|{
comment|/* At i2c address 0xa0, look for Hauppauge and Osprey cards */
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|PFC8582_RADDR
argument_list|)
operator|)
operator|!=
name|ABSENT
condition|)
block|{
comment|/* Read the eeprom contents */
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_UNKNOWN
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|PFC8582_WADDR
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
name|readEEProm
argument_list|(
name|bktr
argument_list|,
literal|0
argument_list|,
literal|128
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|eeprom
argument_list|)
expr_stmt|;
comment|/* For Hauppauge, check the EEPROM begins with 0x84 */
if|if
condition|(
name|eeprom
index|[
literal|0
index|]
operator|==
literal|0x84
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_HAUPPAUGE
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|PFC8582_WADDR
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
comment|/* For Osprey, check the EEPROM begins with "MMAC" */
if|if
condition|(
operator|(
name|eeprom
index|[
literal|0
index|]
operator|==
literal|'M'
operator|)
operator|&&
operator|(
name|eeprom
index|[
literal|1
index|]
operator|==
literal|'M'
operator|)
operator|&&
operator|(
name|eeprom
index|[
literal|2
index|]
operator|==
literal|'A'
operator|)
operator|&&
operator|(
name|eeprom
index|[
literal|3
index|]
operator|==
literal|'C'
operator|)
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_OSPREY
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|PFC8582_WADDR
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
name|printf
argument_list|(
literal|"%s: Warning: Unknown card type. EEPROM data not recognised\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %x %x %x %x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|eeprom
index|[
literal|0
index|]
argument_list|,
name|eeprom
index|[
literal|1
index|]
argument_list|,
name|eeprom
index|[
literal|2
index|]
argument_list|,
name|eeprom
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* look for an STB card */
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|X24C01_RADDR
argument_list|)
operator|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_STB
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|X24C01_WADDR
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|128
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
block|}
name|signCard
argument_list|(
name|bktr
argument_list|,
literal|1
argument_list|,
literal|128
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|probe_signature
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: card signature: "
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|Bt848_MAX_SIGN
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %02x "
argument_list|,
name|probe_signature
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
name|bt848_card_signature
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|bt848_card_sig
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|card_found
operator|=
literal|1
expr_stmt|;
name|probe_temp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|bt848_card_signature
index|[
name|i
index|]
operator|.
name|signature
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|Bt848_MAX_SIGN
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|probe_temp
index|[
name|j
index|]
operator|&
literal|0xf
operator|)
operator|!=
operator|(
name|probe_signature
index|[
name|j
index|]
operator|&
literal|0xf
operator|)
condition|)
block|{
name|card_found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|card_found
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
name|card
operator|=
name|bt848_card_signature
index|[
name|i
index|]
operator|.
name|card
index|]
expr_stmt|;
name|eeprom_i2c_address
operator|=
name|locate_eeprom_address
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom_i2c_address
operator|!=
operator|-
literal|1
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
literal|0
expr_stmt|;
block|}
name|tuner_i2c_address
operator|=
name|locate_tuner_address
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|bt848_card_signature
index|[
name|i
index|]
operator|.
name|tuner
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
block|}
comment|/* We do not know the card type. Default to Miro */
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_MIRO
operator|)
index|]
expr_stmt|;
name|checkEEPROM
label|:
comment|/* look for a configuration eeprom */
name|eeprom_i2c_address
operator|=
name|locate_eeprom_address
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom_i2c_address
operator|!=
operator|-
literal|1
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
literal|0
expr_stmt|;
block|}
name|checkTuner
label|:
comment|/* look for a tuner */
name|tuner_i2c_address
operator|=
name|locate_tuner_address
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tuner_i2c_address
operator|==
operator|-
literal|1
condition|)
block|{
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|NO_TUNER
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|BKTR_OVERRIDE_TUNER
argument_list|)
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|BKTR_OVERRIDE_TUNER
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
endif|#
directive|endif
if|if
condition|(
name|bktr
operator|->
name|bt848_tuner
operator|!=
operator|-
literal|1
condition|)
block|{
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|bt848_tuner
operator|&
literal|0xff
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
comment|/* Check for i2c devices */
if|if
condition|(
operator|!
name|any_i2c_devices
condition|)
block|{
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|NO_TUNER
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
comment|/* differentiate type of tuner */
switch|switch
condition|(
name|card
condition|)
block|{
case|case
name|CARD_MIRO
case|:
switch|switch
condition|(
operator|(
operator|(
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|)
operator|>>
literal|10
operator|)
operator|-
literal|1
operator|)
operator|&
literal|7
condition|)
block|{
case|case
literal|0
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|TEMIC_PAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_PAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_NTSC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_SECAM
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|NO_TUNER
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_PALI
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|TEMIC_NTSC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|TEMIC_PALI
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|checkDBX
goto|;
break|break;
case|case
name|CARD_HAUPPAUGE
case|:
comment|/* Hauppauge kindly supplied the following Tuner Table */
comment|/* FIXME: I think the tuners the driver selects for types */
comment|/* 0x08 and 0x15 may be incorrect but no one has complained. */
comment|/* Old Temic tuners had their own API, but newer Temic tuners */
comment|/* have the same API as Philips tuners */
comment|/*   ID  Tuner Model           Format			We select Format  0x00 NONE                 0x01 EXTERNAL               0x02 OTHER                  0x03 Philips FI1216        BG   0x04 Philips FI1216MF      BGLL'			PHILIPS_SECAM  0x05 Philips FI1236        MN 				PHILIPS_NTSC  0x06 Philips FI1246        I 				PHILIPS_PALI  0x07 Philips FI1256        DK   0x08 Philips FI1216 MK2    BG 				PHILIPS_PALI  0x09 Philips FI1216MF MK2  BGLL' 			PHILIPS_SECAM  0x0a Philips FI1236 MK2    MN 				PHILIPS_NTSC  0x0b Philips FI1246 MK2    I 				PHILIPS_PALI  0x0c Philips FI1256 MK2    DK   0x0d Temic 4032FY5         NTSC			TEMIC_NTSC  0x0e Temic 4002FH5         BG				TEMIC_PAL  0x0f Temic 4062FY5         I 				TEMIC_PALI  0x10 Philips FR1216 MK2    BG   0x11 Philips FR1216MF MK2  BGLL' 			PHILIPS_FR1236_SECAM  0x12 Philips FR1236 MK2    MN 				PHILIPS_FR1236_NTSC  0x13 Philips FR1246 MK2    I   0x14 Philips FR1256 MK2    DK   0x15 Philips FM1216        BG 				PHILIPS_FR1216_PAL  0x16 Philips FM1216MF      BGLL' 			PHILIPS_FR1236_SECAM  0x17 Philips FM1236        MN 				PHILIPS_FR1236_NTSC  0x18 Philips FM1246        I   0x19 Philips FM1256        DK   0x1a Temic 4036FY5         MN (FI1236 MK2 clone)	PHILIPS_NTSC  0x1b Samsung TCPN9082D     MN   0x1c Samsung TCPM9092P     Pal BG/I/DK   0x1d Temic 4006FH5         BG				PHILIPS_PALI  0x1e Samsung TCPN9085D     MN/Radio   0x1f Samsung TCPB9085P     Pal BG/I/DK / Radio   0x20 Samsung TCPL9091P     Pal BG& Secam L/L'   0x21 Temic 4039FY5         NTSC Radio  0x22 Philips FQ1216ME      Pal BGIDK& Secam L/L'   0x23 Temic 4066FY5         Pal I (FI1246 MK2 clone)	PHILIPS_PALI  0x24 Philips TD1536        MN/ATSCDigital  0x25 Philips TD1536D       MN/ATSCDigital DUAL INPUT  0x26 Philips FMR1236       M/N FM(no demod)  0x27 Philips FI1256MP      B/G, D/K  0x28 Samsung TCPQ9091P     BG/I/DK, L/L'  0x29 Temic 4006FN5         BG/I/DK  0x2a Temic 4009FR5         BG FM			PHILIPS_FR1216_PAL  0x2b Temic 4046FM5         B/G, I, D/K, L/L'  0x2c Temic 4009FN5         B/G, I, D/K, FM (no demod)  0x2d Philips TD1536D_FH_44 MN/ATSCDigital DUAL INPUT 	    */
comment|/* Determine the model number from the eeprom */
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|!=
literal|0
condition|)
block|{
comment|/* eeprom data block structure */
name|unsigned
name|char
modifier|*
name|block_1
decl_stmt|,
modifier|*
name|block_2
decl_stmt|,
modifier|*
name|block_3
decl_stmt|,
modifier|*
name|block_4
decl_stmt|;
name|int
name|block_1_data_size
decl_stmt|,
name|block_2_data_size
decl_stmt|,
name|block_3_data_size
decl_stmt|;
name|int
name|block_1_total_size
decl_stmt|,
name|block_2_total_size
decl_stmt|,
name|block_3_total_size
decl_stmt|;
name|int
name|block_4_header_size
decl_stmt|;
name|unsigned
name|int
name|model
decl_stmt|,
name|revision
decl_stmt|;
name|unsigned
name|char
name|tuner_code
decl_stmt|;
name|unsigned
name|char
name|no_audio_mux
decl_stmt|;
name|readEEProm
argument_list|(
name|bktr
argument_list|,
literal|0
argument_list|,
literal|128
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|eeprom
argument_list|)
expr_stmt|;
comment|/* LOCATE THE EEPROM DATA BLOCKS */
name|block_1
operator|=
operator|&
name|eeprom
index|[
literal|0
index|]
expr_stmt|;
name|block_1_data_size
operator|=
operator|(
name|block_1
index|[
literal|2
index|]
operator|<<
literal|8
operator||
name|block_1
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|block_1_total_size
operator|=
name|block_1_data_size
operator|+
literal|3
expr_stmt|;
comment|/* Header bytes */
name|block_2
operator|=
operator|&
name|eeprom
index|[
name|block_1_total_size
index|]
expr_stmt|;
name|block_2_data_size
operator|=
operator|(
name|block_2
index|[
literal|2
index|]
operator|<<
literal|8
operator||
name|block_2
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|block_2_total_size
operator|=
name|block_2_data_size
operator|+
literal|3
expr_stmt|;
comment|/* Header bytes */
name|block_3
operator|=
operator|&
name|eeprom
index|[
name|block_1_total_size
operator|+
name|block_2_total_size
index|]
expr_stmt|;
name|block_3_data_size
operator|=
operator|(
name|block_3
index|[
literal|0
index|]
operator|&
literal|0x07
operator|)
expr_stmt|;
name|block_3_total_size
operator|=
name|block_3_data_size
operator|+
literal|1
expr_stmt|;
comment|/* Header size */
name|block_4
operator|=
operator|&
name|eeprom
index|[
name|block_1_total_size
operator|+
name|block_2_total_size
operator|+
name|block_3_total_size
index|]
expr_stmt|;
name|block_4_header_size
operator|=
literal|1
expr_stmt|;
name|model
operator|=
operator|(
name|block_1
index|[
literal|12
index|]
operator|<<
literal|8
operator||
name|block_1
index|[
literal|11
index|]
operator|)
expr_stmt|;
name|revision
operator|=
operator|(
name|block_1
index|[
literal|15
index|]
operator|<<
literal|16
operator||
name|block_1
index|[
literal|14
index|]
operator|<<
literal|8
operator||
name|block_1
index|[
literal|13
index|]
operator|)
expr_stmt|;
name|tuner_code
operator|=
name|block_1
index|[
literal|9
index|]
expr_stmt|;
name|no_audio_mux
operator|=
operator|(
operator|(
name|block_3
index|[
literal|3
index|]
operator|>>
literal|7
operator|)
operator|&
literal|0x01
operator|)
expr_stmt|;
if|if
condition|(
name|no_audio_mux
condition|)
name|bktr
operator|->
name|audio_mux_present
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%s: Hauppauge Model %d %c%c%c%c\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|model
argument_list|,
operator|(
operator|(
name|revision
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
operator|)
operator|+
literal|32
argument_list|,
operator|(
operator|(
name|revision
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
operator|+
literal|32
argument_list|,
operator|(
operator|(
name|revision
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
operator|+
literal|32
argument_list|,
operator|(
operator|(
name|revision
operator|>>
literal|0
operator|)
operator|&
literal|0x3f
operator|)
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/* Determine the tuner type from the eeprom */
switch|switch
condition|(
name|tuner_code
condition|)
block|{
case|case
literal|0x5
case|:
case|case
literal|0x0a
case|:
case|case
literal|0x1a
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_NTSC
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0x4
case|:
case|case
literal|0x9
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_SECAM
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0x11
case|:
case|case
literal|0x16
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_FR1236_SECAM
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0x12
case|:
case|case
literal|0x17
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_FR1236_NTSC
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0x6
case|:
case|case
literal|0x8
case|:
case|case
literal|0xb
case|:
case|case
literal|0x1d
case|:
case|case
literal|0x23
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_PALI
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0xd
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|TEMIC_NTSC
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0xe
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|TEMIC_PAL
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0xf
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|TEMIC_PALI
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0x15
case|:
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_FR1216_PAL
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0x2a
case|:
name|bktr
operator|->
name|msp_use_mono_source
operator|=
literal|1
expr_stmt|;
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_FR1216_PAL
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
default|default :
name|printf
argument_list|(
literal|"%s: Warning - Unknown Hauppauge Tuner 0x%x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|tuner_code
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CARD_AVER_MEDIA
case|:
comment|/* AVerMedia kindly supplied some details of their EEPROM contents 	     * which allow us to auto select the Tuner Type. 	     * Only the newer AVerMedia cards actually have an EEPROM. 	     */
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|!=
literal|0
condition|)
block|{
name|u_char
name|tuner_make
decl_stmt|;
comment|/* Eg Philips, Temic */
name|u_char
name|tuner_tv_fm
decl_stmt|;
comment|/* TV or TV with FM Radio */
name|u_char
name|tuner_format
decl_stmt|;
comment|/* Eg NTSC, PAL, SECAM */
name|int
name|tuner
decl_stmt|;
name|int
name|tuner_0_table
index|[]
init|=
block|{
name|PHILIPS_NTSC
block|,
name|PHILIPS_PAL
block|,
name|PHILIPS_PAL
block|,
name|PHILIPS_PAL
block|,
name|PHILIPS_PAL
block|,
name|PHILIPS_PAL
block|,
name|PHILIPS_SECAM
block|,
name|PHILIPS_SECAM
block|,
name|PHILIPS_SECAM
block|,
name|PHILIPS_PAL
block|}
decl_stmt|;
name|int
name|tuner_0_fm_table
index|[]
init|=
block|{
name|PHILIPS_FR1236_NTSC
block|,
name|PHILIPS_FR1216_PAL
block|,
name|PHILIPS_FR1216_PAL
block|,
name|PHILIPS_FR1216_PAL
block|,
name|PHILIPS_FR1216_PAL
block|,
name|PHILIPS_FR1216_PAL
block|,
name|PHILIPS_FR1236_SECAM
block|,
name|PHILIPS_FR1236_SECAM
block|,
name|PHILIPS_FR1236_SECAM
block|,
name|PHILIPS_FR1216_PAL
block|}
decl_stmt|;
name|int
name|tuner_1_table
index|[]
init|=
block|{
name|TEMIC_NTSC
block|,
name|TEMIC_PAL
block|,
name|TEMIC_PAL
block|,
name|TEMIC_PAL
block|,
name|TEMIC_PAL
block|,
name|TEMIC_PAL
block|,
name|TEMIC_SECAM
block|,
name|TEMIC_SECAM
block|,
name|TEMIC_SECAM
block|,
name|TEMIC_PAL
block|}
decl_stmt|;
comment|/* Extract information from the EEPROM data */
name|readEEProm
argument_list|(
name|bktr
argument_list|,
literal|0
argument_list|,
literal|128
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|eeprom
argument_list|)
expr_stmt|;
name|tuner_make
operator|=
operator|(
name|eeprom
index|[
literal|0x41
index|]
operator|&
literal|0x7
operator|)
expr_stmt|;
name|tuner_tv_fm
operator|=
operator|(
name|eeprom
index|[
literal|0x41
index|]
operator|&
literal|0x18
operator|)
operator|>>
literal|3
expr_stmt|;
name|tuner_format
operator|=
operator|(
name|eeprom
index|[
literal|0x42
index|]
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
expr_stmt|;
comment|/* Treat tuner make 0 (Philips) and make 2 (LG) the same */
if|if
condition|(
operator|(
operator|(
name|tuner_make
operator|==
literal|0
operator|)
operator|||
operator|(
name|tuner_make
operator|==
literal|2
operator|)
operator|)
operator|&&
operator|(
name|tuner_format
operator|<=
literal|9
operator|)
operator|&&
operator|(
name|tuner_tv_fm
operator|==
literal|0
operator|)
condition|)
block|{
name|tuner
operator|=
name|tuner_0_table
index|[
name|tuner_format
index|]
expr_stmt|;
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|tuner
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|tuner_make
operator|==
literal|0
operator|)
operator|||
operator|(
name|tuner_make
operator|==
literal|2
operator|)
operator|)
operator|&&
operator|(
name|tuner_format
operator|<=
literal|9
operator|)
operator|&&
operator|(
name|tuner_tv_fm
operator|==
literal|1
operator|)
condition|)
block|{
name|tuner
operator|=
name|tuner_0_fm_table
index|[
name|tuner_format
index|]
expr_stmt|;
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|tuner
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
if|if
condition|(
operator|(
name|tuner_make
operator|==
literal|1
operator|)
operator|&&
operator|(
name|tuner_format
operator|<=
literal|9
operator|)
condition|)
block|{
name|tuner
operator|=
name|tuner_1_table
index|[
name|tuner_format
index|]
expr_stmt|;
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|tuner
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
name|printf
argument_list|(
literal|"%s: Warning - Unknown AVerMedia Tuner Make %d Format %d\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|tuner_make
argument_list|,
name|tuner_format
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CARD_LEADTEK
case|:
if|#
directive|if
name|BKTR_SYSTEM_DEFAULT
operator|==
name|BROOKTREE_PAL
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_FR1216_PAL
argument_list|)
expr_stmt|;
else|#
directive|else
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_FR1236_NTSC
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|checkDBX
goto|;
break|break;
block|}
comment|/* end switch(card) */
comment|/* At this point, a goto checkDBX has not occured */
comment|/* We have not been able to select a Tuner */
comment|/* Some cards make use of the tuner address to */
comment|/* identify the make/model of tuner */
comment|/* At address 0xc0/0xc1 we often find a TEMIC NTSC */
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xc1
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|TEMIC_NTSC
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
comment|/* At address 0xc6/0xc7 we often find a PHILIPS NTSC Tuner */
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xc7
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_NTSC
argument_list|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
comment|/* Address 0xc2/0xc3 is default (or common address) for several */
comment|/* tuners and we cannot tell which is which. */
comment|/* And for all other tuner i2c addresses, select the default */
name|select_tuner
argument_list|(
name|bktr
argument_list|,
name|DEFAULT_TUNER
argument_list|)
expr_stmt|;
name|checkDBX
label|:
if|#
directive|if
name|defined
argument_list|(
name|BKTR_OVERRIDE_DBX
argument_list|)
name|bktr
operator|->
name|card
operator|.
name|dbx
operator|=
name|BKTR_OVERRIDE_DBX
expr_stmt|;
goto|goto
name|checkMSP
goto|;
endif|#
directive|endif
comment|/* Check for i2c devices */
if|if
condition|(
operator|!
name|any_i2c_devices
condition|)
block|{
goto|goto
name|checkMSP
goto|;
block|}
comment|/* probe for BTSC (dbx) chip */
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|TDA9850_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
name|bktr
operator|->
name|card
operator|.
name|dbx
operator|=
literal|1
expr_stmt|;
name|checkMSP
label|:
comment|/* If this is a Hauppauge Bt878 card, we need to enable the 	 * MSP 34xx audio chip.  	 * If this is a Hauppauge Bt848 card, reset the MSP device. 	 * The MSP reset line is wired to GPIO pin 5. On Bt878 cards a pulldown 	 * resistor holds the device in reset until we set GPIO pin 5.          */
comment|/* Optionally skip the MSP reset. This is handy if you initialise the 	 * MSP audio in another operating system (eg Windows) first and then 	 * do a soft reboot. 	 */
ifndef|#
directive|ifndef
name|BKTR_NO_MSP_RESET
if|if
condition|(
name|card
operator|==
name|CARD_HAUPPAUGE
condition|)
block|{
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_OUT_EN
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_OUT_EN
argument_list|)
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|)
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
comment|/* write '1' */
name|DELAY
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
comment|/* wait 2.5ms */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|)
operator|&
operator|~
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
comment|/* write '0' */
name|DELAY
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
comment|/* wait 2.5ms */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|)
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
comment|/* write '1' */
name|DELAY
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
comment|/* wait 2.5ms */
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|BKTR_OVERRIDE_MSP
argument_list|)
name|bktr
operator|->
name|card
operator|.
name|msp3400c
operator|=
name|BKTR_OVERRIDE_MSP
expr_stmt|;
goto|goto
name|checkMSPEnd
goto|;
endif|#
directive|endif
comment|/* Check for i2c devices */
if|if
condition|(
operator|!
name|any_i2c_devices
condition|)
block|{
goto|goto
name|checkMSPEnd
goto|;
block|}
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|MSP3400C_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|msp3400c
operator|=
literal|1
expr_stmt|;
block|}
name|checkMSPEnd
label|:
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|msp3400c
condition|)
block|{
name|bktr
operator|->
name|msp_addr
operator|=
name|MSP3400C_WADDR
expr_stmt|;
name|msp_read_id
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Detected a MSP%s at 0x%x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|bktr
operator|->
name|msp_version_string
argument_list|,
name|bktr
operator|->
name|msp_addr
argument_list|)
expr_stmt|;
block|}
comment|/* Check for Dolby Surround Sound DPL3518A sound chip */
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|DPL3518A_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|dpl3518a
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|dpl3518a
condition|)
block|{
name|bktr
operator|->
name|dpl_addr
operator|=
name|DPL3518A_WADDR
expr_stmt|;
name|dpl_read_id
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Detected a DPL%s at 0x%x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|bktr
operator|->
name|dpl_version_string
argument_list|,
name|bktr
operator|->
name|dpl_addr
argument_list|)
expr_stmt|;
block|}
comment|/* Start of Check Remote */
comment|/* Check for the Hauppauge IR Remote Control */
comment|/* If there is an external unit, the internal will be ignored */
name|bktr
operator|->
name|remote_control
operator|=
literal|0
expr_stmt|;
comment|/* initial value */
if|if
condition|(
name|any_i2c_devices
condition|)
block|{
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|HAUP_REMOTE_EXT_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|remote_control
operator|=
literal|1
expr_stmt|;
name|bktr
operator|->
name|remote_control_addr
operator|=
name|HAUP_REMOTE_EXT_RADDR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|HAUP_REMOTE_INT_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|remote_control
operator|=
literal|1
expr_stmt|;
name|bktr
operator|->
name|remote_control_addr
operator|=
name|HAUP_REMOTE_INT_RADDR
expr_stmt|;
block|}
block|}
comment|/* If a remote control is found, poll it 5 times to turn off the LED */
if|if
condition|(
name|bktr
operator|->
name|remote_control
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|remote_control_addr
argument_list|)
expr_stmt|;
block|}
comment|/* End of Check Remote */
if|#
directive|if
name|defined
argument_list|(
name|BKTR_USE_PLL
argument_list|)
name|bktr
operator|->
name|xtal_pll_mode
operator|=
name|BT848_USE_PLL
expr_stmt|;
goto|goto
name|checkPLLEnd
goto|;
endif|#
directive|endif
comment|/* Default is to use XTALS and not PLL mode */
name|bktr
operator|->
name|xtal_pll_mode
operator|=
name|BT848_USE_XTALS
expr_stmt|;
comment|/* Enable PLL mode for OSPREY users */
if|if
condition|(
name|card
operator|==
name|CARD_OSPREY
condition|)
name|bktr
operator|->
name|xtal_pll_mode
operator|=
name|BT848_USE_PLL
expr_stmt|;
comment|/* Enable PLL mode for Video Highway Xtreme users */
if|if
condition|(
name|card
operator|==
name|CARD_VIDEO_HIGHWAY_XTREME
condition|)
name|bktr
operator|->
name|xtal_pll_mode
operator|=
name|BT848_USE_PLL
expr_stmt|;
comment|/* Most (perhaps all) Bt878 cards need to be switched to PLL mode */
comment|/* as they only fit the NTSC crystal to their cards */
comment|/* Default to enabling PLL mode for all Bt878/879 cards */
if|if
condition|(
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_878
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_879
operator|)
condition|)
name|bktr
operator|->
name|xtal_pll_mode
operator|=
name|BT848_USE_PLL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BKTR_USE_PLL
argument_list|)
name|checkPLLEnd
label|:
endif|#
directive|endif
name|bktr
operator|->
name|card
operator|.
name|tuner_pllAddr
operator|=
name|tuner_i2c_address
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %s"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|bktr
operator|->
name|card
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|tuner
condition|)
name|printf
argument_list|(
literal|", %s tuner"
argument_list|,
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|dbx
condition|)
name|printf
argument_list|(
literal|", dbx stereo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|msp3400c
condition|)
name|printf
argument_list|(
literal|", msp3400c stereo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|dpl3518a
condition|)
name|printf
argument_list|(
literal|", dpl3518a dolby"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|remote_control
condition|)
name|printf
argument_list|(
literal|", remote control"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|ABSENT
end_undef

end_unit

