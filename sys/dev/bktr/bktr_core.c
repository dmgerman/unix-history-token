begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * This is part of the Driver for Video Capture Cards (Frame grabbers)  * and TV Tuner cards using the Brooktree Bt848, Bt848A, Bt849A, Bt878, Bt879  * chipset.  * Copyright Roger Hardiman and Amancio Hasty.  *  * bktr_core : This deals with the Bt848/849/878/879 PCI Frame Grabber,  *               Handles all the open, close, ioctl and read userland calls.  *               Sets the Bt848 registers and generates RISC pograms.  *               Controls the i2c bus and GPIO interface.  *               Contains the interface to the kernel.  *               (eg probe/attach and open/close/ioctl)  *  */
end_comment

begin_comment
comment|/*    The Brooktree BT848 Driver driver is based upon Mark Tinguely and    Jim Lowe's driver for the Matrox Meteor PCI card . The     Philips SAA 7116 and SAA 7196 are very different chipsets than    the BT848.     The original copyright notice by Mark and Jim is included mostly    to honor their fantastic work in the Matrox Meteor driver!   */
end_comment

begin_comment
comment|/*  * 1. Redistributions of source code must retain the   * Copyright (c) 1997 Amancio Hasty, 1999 Roger Hardiman  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Amancio Hasty and  *      Roger Hardiman  * 4. The name of the author may not be used to endorse or promote products   *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * 1. Redistributions of source code must retain the   * Copyright (c) 1995 Mark Tinguely and Jim Lowe  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Mark Tinguely and Jim Lowe  * 4. The name of the author may not be used to endorse or promote products   *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_bktr.h"
end_include

begin_comment
comment|/* Include any kernel config options */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|"bktr.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_if
if|#
directive|if
operator|(
expr|\
operator|(
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|NBKTR
operator|>
literal|0
operator|)
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|__bsdi__
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|)
expr|\
operator|)
end_if

begin_comment
comment|/*******************/
end_comment

begin_comment
comment|/* *** FreeBSD *** */
end_comment

begin_comment
comment|/*******************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|400000
operator|)
operator|||
operator|(
name|NSMBUS
operator|>
literal|0
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_comment
comment|/* used by smbus and newbus */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|500000
operator|)
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|300000
operator|)
end_if

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_comment
comment|/* for bus space */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/ioctl_meteor.h>
end_include

begin_include
include|#
directive|include
file|<machine/ioctl_bt848.h>
end_include

begin_comment
comment|/* extensions to ioctl_meteor.h */
end_comment

begin_include
include|#
directive|include
file|<dev/bktr/bktr_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_tuner.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_card.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_audio.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_os.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_core.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BKTR_FREEBSD_MODULE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/bktr/bktr_mem.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BKTR_USE_FREEBSD_SMBUS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/bktr/bktr_i2c.h>
end_include

begin_include
include|#
directive|include
file|<dev/smbus/smbconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iiconf.h>
end_include

begin_include
include|#
directive|include
file|"smbus_if.h"
end_include

begin_include
include|#
directive|include
file|"iicbus_if.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|const
name|char
modifier|*
name|bktr_name
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
return|return
name|bktr
operator|->
name|bktr_xname
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|__FreeBSD__
operator|==
literal|2
operator|)
end_if

begin_typedef
typedef|typedef
name|unsigned
name|int
name|uintptr_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/****************/
end_comment

begin_comment
comment|/* *** BSDI *** */
end_comment

begin_comment
comment|/****************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__bsdi__
end_ifdef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __bsdi__ */
end_comment

begin_comment
comment|/**************************/
end_comment

begin_comment
comment|/* *** OpenBSD/NetBSD *** */
end_comment

begin_comment
comment|/**************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<uvm/uvm_extern.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/inttypes.h>
end_include

begin_comment
comment|/* uintptr_t */
end_comment

begin_include
include|#
directive|include
file|<dev/ic/bt8xx.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_tuner.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_card.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_audio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_os.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|bt848_format
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|bktr_name
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
return|return
operator|(
name|bktr
operator|->
name|bktr_dev
operator|.
name|dv_xname
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ || __OpenBSD__ */
end_comment

begin_typedef
typedef|typedef
name|u_char
name|bool_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|BKTRPRI
value|(PZERO+8)|PCATCH
end_define

begin_define
define|#
directive|define
name|VBIPRI
value|(PZERO-4)|PCATCH
end_define

begin_comment
comment|/*  * memory allocated for DMA programs  */
end_comment

begin_define
define|#
directive|define
name|DMA_PROG_ALLOC
value|(8 * PAGE_SIZE)
end_define

begin_comment
comment|/* When to split a dma transfer , the bt848 has timing as well as    dma transfer size limitations so that we have to split dma    transfers into two dma requests     */
end_comment

begin_define
define|#
directive|define
name|DMA_BT848_SPLIT
value|319*2
end_define

begin_comment
comment|/*   * Allocate enough memory for:  *	768x576 RGB 16 or YUV (16 storage bits/pixel) = 884736 = 216 pages  *  * You may override this using the options "BROOKTREE_ALLOC_PAGES=value"  * in your  kernel configuration file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BROOKTREE_ALLOC_PAGES
end_ifndef

begin_define
define|#
directive|define
name|BROOKTREE_ALLOC_PAGES
value|217*4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BROOKTREE_ALLOC
value|(BROOKTREE_ALLOC_PAGES * PAGE_SIZE)
end_define

begin_comment
comment|/* Definitions for VBI capture.  * There are 16 VBI lines in a PAL video field (32 in a frame),  * and we take 2044 samples from each line (placed in a 2048 byte buffer  * for alignment).  * VBI lines are held in a circular buffer before being read by a  * user program from /dev/vbi.  */
end_comment

begin_define
define|#
directive|define
name|MAX_VBI_LINES
value|16
end_define

begin_comment
comment|/* Maximum for all vidoe formats */
end_comment

begin_define
define|#
directive|define
name|VBI_LINE_SIZE
value|2048
end_define

begin_comment
comment|/* Store upto 2048 bytes per line */
end_comment

begin_define
define|#
directive|define
name|VBI_BUFFER_ITEMS
value|20
end_define

begin_comment
comment|/* Number of frames we buffer */
end_comment

begin_define
define|#
directive|define
name|VBI_DATA_SIZE
value|(VBI_LINE_SIZE * MAX_VBI_LINES * 2)
end_define

begin_define
define|#
directive|define
name|VBI_BUFFER_SIZE
value|(VBI_DATA_SIZE * VBI_BUFFER_ITEMS)
end_define

begin_comment
comment|/*  Defines for fields  */
end_comment

begin_define
define|#
directive|define
name|ODD_F
value|0x01
end_define

begin_define
define|#
directive|define
name|EVEN_F
value|0x02
end_define

begin_comment
comment|/*  * Parameters describing size of transmitted image.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|format_params
name|format_params
index|[]
init|=
block|{
comment|/* # define BT848_IFORM_F_AUTO             (0x0) - don't matter. */
block|{
literal|525
block|,
literal|26
block|,
literal|480
block|,
literal|910
block|,
literal|135
block|,
literal|754
block|,
literal|640
block|,
literal|780
block|,
literal|30
block|,
literal|0x68
block|,
literal|0x5d
block|,
name|BT848_IFORM_X_AUTO
block|,
literal|12
block|,
literal|1600
block|}
block|,
comment|/* # define BT848_IFORM_F_NTSCM            (0x1) */
block|{
literal|525
block|,
literal|26
block|,
literal|480
block|,
literal|910
block|,
literal|135
block|,
literal|754
block|,
literal|640
block|,
literal|780
block|,
literal|30
block|,
literal|0x68
block|,
literal|0x5d
block|,
name|BT848_IFORM_X_XT0
block|,
literal|12
block|,
literal|1600
block|}
block|,
comment|/* # define BT848_IFORM_F_NTSCJ            (0x2) */
block|{
literal|525
block|,
literal|22
block|,
literal|480
block|,
literal|910
block|,
literal|135
block|,
literal|754
block|,
literal|640
block|,
literal|780
block|,
literal|30
block|,
literal|0x68
block|,
literal|0x5d
block|,
name|BT848_IFORM_X_XT0
block|,
literal|12
block|,
literal|1600
block|}
block|,
comment|/* # define BT848_IFORM_F_PALBDGHI         (0x3) */
block|{
literal|625
block|,
literal|32
block|,
literal|576
block|,
literal|1135
block|,
literal|186
block|,
literal|924
block|,
literal|768
block|,
literal|944
block|,
literal|25
block|,
literal|0x7f
block|,
literal|0x72
block|,
name|BT848_IFORM_X_XT1
block|,
literal|16
block|,
literal|2044
block|}
block|,
comment|/* # define BT848_IFORM_F_PALM             (0x4) */
block|{
literal|525
block|,
literal|22
block|,
literal|480
block|,
literal|910
block|,
literal|135
block|,
literal|754
block|,
literal|640
block|,
literal|780
block|,
literal|30
block|,
literal|0x68
block|,
literal|0x5d
block|,
name|BT848_IFORM_X_XT0
block|,
literal|12
block|,
literal|1600
block|}
block|,
comment|/* # define BT848_IFORM_F_PALN             (0x5) */
block|{
literal|625
block|,
literal|32
block|,
literal|576
block|,
literal|1135
block|,
literal|186
block|,
literal|924
block|,
literal|768
block|,
literal|944
block|,
literal|25
block|,
literal|0x7f
block|,
literal|0x72
block|,
name|BT848_IFORM_X_XT1
block|,
literal|16
block|,
literal|2044
block|}
block|,
comment|/* # define BT848_IFORM_F_SECAM            (0x6) */
block|{
literal|625
block|,
literal|32
block|,
literal|576
block|,
literal|1135
block|,
literal|186
block|,
literal|924
block|,
literal|768
block|,
literal|944
block|,
literal|25
block|,
literal|0x7f
block|,
literal|0xa0
block|,
name|BT848_IFORM_X_XT1
block|,
literal|16
block|,
literal|2044
block|}
block|,
comment|/* # define BT848_IFORM_F_RSVD             (0x7) - ???? */
block|{
literal|625
block|,
literal|32
block|,
literal|576
block|,
literal|1135
block|,
literal|186
block|,
literal|924
block|,
literal|768
block|,
literal|944
block|,
literal|25
block|,
literal|0x7f
block|,
literal|0x72
block|,
name|BT848_IFORM_X_XT0
block|,
literal|16
block|,
literal|2044
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table of supported Pixel Formats   */
end_comment

begin_struct
specifier|static
struct|struct
name|meteor_pixfmt_internal
block|{
name|struct
name|meteor_pixfmt
name|public
decl_stmt|;
name|u_int
name|color_fmt
decl_stmt|;
block|}
name|pixfmt_table
index|[]
init|=
block|{
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0x7c00
block|,
literal|0x03e0
block|,
literal|0x001f
block|}
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0x33
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0x7c00
block|,
literal|0x03e0
block|,
literal|0x001f
block|}
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|0x33
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0xf800
block|,
literal|0x07e0
block|,
literal|0x001f
block|}
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0x22
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0xf800
block|,
literal|0x07e0
block|,
literal|0x001f
block|}
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|0x22
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|3
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|0x11
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0x00
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|0
block|,
literal|1
block|}
block|,
literal|0x00
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|0x00
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|1
block|}
block|,
literal|0x00
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_YUV
block|,
literal|2
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|1
block|}
block|,
literal|0x88
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_YUV_PACKED
block|,
literal|2
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|0
block|,
literal|1
block|}
block|,
literal|0x44
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_YUV_12
block|,
literal|2
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|1
block|}
block|,
literal|0x88
block|}
block|,  }
struct|;
end_struct

begin_define
define|#
directive|define
name|PIXFMT_TABLE_SIZE
value|( sizeof(pixfmt_table) / sizeof(pixfmt_table[0]) )
end_define

begin_comment
comment|/*  * Table of Meteor-supported Pixel Formats (for SETGEO compatibility)  */
end_comment

begin_comment
comment|/*  FIXME:  Also add YUV_422 and YUV_PACKED as well  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|u_long
name|meteor_format
decl_stmt|;
name|struct
name|meteor_pixfmt
name|public
decl_stmt|;
block|}
name|meteor_pixfmt_table
index|[]
init|=
block|{
block|{
name|METEOR_GEO_YUV_12
block|,
block|{
literal|0
block|,
name|METEOR_PIXTYPE_YUV_12
block|,
literal|2
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|1
block|}
block|}
block|,
comment|/* FIXME: Should byte swap flag be on for this one; negative in drvr? */
block|{
name|METEOR_GEO_YUV_422
block|,
block|{
literal|0
block|,
name|METEOR_PIXTYPE_YUV
block|,
literal|2
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|1
block|}
block|}
block|,
block|{
name|METEOR_GEO_YUV_PACKED
block|,
block|{
literal|0
block|,
name|METEOR_PIXTYPE_YUV_PACKED
block|,
literal|2
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|0
block|,
literal|1
block|}
block|}
block|,
block|{
name|METEOR_GEO_RGB16
block|,
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0x7c00
block|,
literal|0x03e0
block|,
literal|0x001f
block|}
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
name|METEOR_GEO_RGB24
block|,
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,  }
struct|;
end_struct

begin_define
define|#
directive|define
name|METEOR_PIXFMT_TABLE_SIZE
value|( sizeof(meteor_pixfmt_table) / \ 				   sizeof(meteor_pixfmt_table[0]) )
end_define

begin_define
define|#
directive|define
name|BSWAP
value|(BT848_COLOR_CTL_BSWAP_ODD | BT848_COLOR_CTL_BSWAP_EVEN)
end_define

begin_define
define|#
directive|define
name|WSWAP
value|(BT848_COLOR_CTL_WSWAP_ODD | BT848_COLOR_CTL_WSWAP_EVEN)
end_define

begin_comment
comment|/* sync detect threshold */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|SYNC_LEVEL
value|(BT848_ADC_RESERVED |	\ 				 BT848_ADC_CRUSH)
end_define

begin_comment
comment|/* threshold ~125 mV */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SYNC_LEVEL
value|(BT848_ADC_RESERVED |	\ 				 BT848_ADC_SYNC_T)
end_define

begin_comment
comment|/* threshold ~75 mV */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* debug utility for holding previous INT_STAT contents */
end_comment

begin_define
define|#
directive|define
name|STATUS_SUM
end_define

begin_decl_stmt
specifier|static
name|u_long
name|status_sum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * defines to make certain bit-fiddles understandable  */
end_comment

begin_define
define|#
directive|define
name|FIFO_ENABLED
value|BT848_DMA_CTL_FIFO_EN
end_define

begin_define
define|#
directive|define
name|RISC_ENABLED
value|BT848_DMA_CTL_RISC_EN
end_define

begin_define
define|#
directive|define
name|FIFO_RISC_ENABLED
value|(BT848_DMA_CTL_FIFO_EN | BT848_DMA_CTL_RISC_EN)
end_define

begin_define
define|#
directive|define
name|FIFO_RISC_DISABLED
value|0
end_define

begin_define
define|#
directive|define
name|ALL_INTS_DISABLED
value|0
end_define

begin_define
define|#
directive|define
name|ALL_INTS_CLEARED
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|CAPTURE_OFF
value|0
end_define

begin_define
define|#
directive|define
name|BIT_SEVEN_HIGH
value|(1<<7)
end_define

begin_define
define|#
directive|define
name|BIT_EIGHT_HIGH
value|(1<<8)
end_define

begin_define
define|#
directive|define
name|I2C_BITS
value|(BT848_INT_RACK | BT848_INT_I2CDONE)
end_define

begin_define
define|#
directive|define
name|TDEC_BITS
value|(BT848_INT_FDSR | BT848_INT_FBUS)
end_define

begin_function_decl
specifier|static
name|int
name|oformat_meteor_to_bt
parameter_list|(
name|u_long
name|format
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|pixfmt_swap_flags
parameter_list|(
name|int
name|pixfmt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * bt848 RISC programming routines.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BT848_DUMP
end_ifdef

begin_function_decl
specifier|static
name|int
name|dump_bt848
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|yuvpack_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|yuv422_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|yuv12_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rgb_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rgb_vbi_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_dma_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|getline
parameter_list|(
name|bktr_reg_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|notclipped
parameter_list|(
name|bktr_reg_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|split
parameter_list|(
name|bktr_reg_t
modifier|*
parameter_list|,
specifier|volatile
name|u_long
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_long
parameter_list|,
name|int
parameter_list|,
specifier|volatile
name|u_char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_capture
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_fps
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|u_short
name|fps
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Remote Control Functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|remote_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|struct
name|bktr_remote
modifier|*
name|remote
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * ioctls common to both video& tuner.  */
end_comment

begin_function_decl
specifier|static
name|int
name|common_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|ioctl_cmd_t
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BKTR_USE_FREEBSD_SMBUS
argument_list|)
end_if

begin_comment
comment|/*  * i2c primitives for low level control of i2c bus. Added for MSP34xx control  */
end_comment

begin_function_decl
specifier|static
name|void
name|i2c_start
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i2c_stop
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i2c_write_byte
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i2c_read_byte
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * the common attach code, used by all OS versions.  */
end_comment

begin_function
name|void
name|common_bktr_attach
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|u_long
name|pci_id
parameter_list|,
name|u_int
name|rev
parameter_list|)
block|{
name|vm_offset_t
name|buf
init|=
literal|0
decl_stmt|;
name|int
name|need_to_allocate_memory
init|=
literal|1
decl_stmt|;
comment|/***************************************/
comment|/* *** OS Specific memory routines *** */
comment|/***************************************/
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
comment|/* allocate space for dma program */
name|bktr
operator|->
name|dma_prog
operator|=
name|get_bktr_mem
argument_list|(
name|bktr
argument_list|,
operator|&
name|bktr
operator|->
name|dm_prog
argument_list|,
name|DMA_PROG_ALLOC
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|odd_dma_prog
operator|=
name|get_bktr_mem
argument_list|(
name|bktr
argument_list|,
operator|&
name|bktr
operator|->
name|dm_oprog
argument_list|,
name|DMA_PROG_ALLOC
argument_list|)
expr_stmt|;
comment|/* allocate space for the VBI buffer */
name|bktr
operator|->
name|vbidata
operator|=
name|get_bktr_mem
argument_list|(
name|bktr
argument_list|,
operator|&
name|bktr
operator|->
name|dm_vbidata
argument_list|,
name|VBI_DATA_SIZE
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|vbibuffer
operator|=
name|get_bktr_mem
argument_list|(
name|bktr
argument_list|,
operator|&
name|bktr
operator|->
name|dm_vbibuffer
argument_list|,
name|VBI_BUFFER_SIZE
argument_list|)
expr_stmt|;
comment|/* allocate space for pixel buffer */
if|if
condition|(
name|BROOKTREE_ALLOC
condition|)
name|buf
operator|=
name|get_bktr_mem
argument_list|(
name|bktr
argument_list|,
operator|&
name|bktr
operator|->
name|dm_mem
argument_list|,
name|BROOKTREE_ALLOC
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
comment|/* If this is a module, check if there is any currently saved contiguous memory */
if|#
directive|if
name|defined
argument_list|(
name|BKTR_FREEBSD_MODULE
argument_list|)
if|if
condition|(
name|bktr_has_stored_addresses
argument_list|(
name|unit
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* recover the addresses */
name|bktr
operator|->
name|dma_prog
operator|=
name|bktr_retrieve_address
argument_list|(
name|unit
argument_list|,
name|BKTR_MEM_DMA_PROG
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|odd_dma_prog
operator|=
name|bktr_retrieve_address
argument_list|(
name|unit
argument_list|,
name|BKTR_MEM_ODD_DMA_PROG
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|vbidata
operator|=
name|bktr_retrieve_address
argument_list|(
name|unit
argument_list|,
name|BKTR_MEM_VBIDATA
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|vbibuffer
operator|=
name|bktr_retrieve_address
argument_list|(
name|unit
argument_list|,
name|BKTR_MEM_VBIBUFFER
argument_list|)
expr_stmt|;
name|buf
operator|=
name|bktr_retrieve_address
argument_list|(
name|unit
argument_list|,
name|BKTR_MEM_BUF
argument_list|)
expr_stmt|;
name|need_to_allocate_memory
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|need_to_allocate_memory
operator|==
literal|1
condition|)
block|{
comment|/* allocate space for dma program */
name|bktr
operator|->
name|dma_prog
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|DMA_PROG_ALLOC
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|odd_dma_prog
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|DMA_PROG_ALLOC
argument_list|)
expr_stmt|;
comment|/* allocte space for the VBI buffer */
name|bktr
operator|->
name|vbidata
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|VBI_DATA_SIZE
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|vbibuffer
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|VBI_BUFFER_SIZE
argument_list|)
expr_stmt|;
comment|/* allocate space for pixel buffer */
if|if
condition|(
name|BROOKTREE_ALLOC
condition|)
name|buf
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|BROOKTREE_ALLOC
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FreeBSD or BSDi */
comment|/* If this is a module, save the current contiguous memory */
if|#
directive|if
name|defined
argument_list|(
name|BKTR_FREEBSD_MODULE
argument_list|)
name|bktr_store_address
argument_list|(
name|unit
argument_list|,
name|BKTR_MEM_DMA_PROG
argument_list|,
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
name|bktr_store_address
argument_list|(
name|unit
argument_list|,
name|BKTR_MEM_ODD_DMA_PROG
argument_list|,
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
name|bktr_store_address
argument_list|(
name|unit
argument_list|,
name|BKTR_MEM_VBIDATA
argument_list|,
name|bktr
operator|->
name|vbidata
argument_list|)
expr_stmt|;
name|bktr_store_address
argument_list|(
name|unit
argument_list|,
name|BKTR_MEM_VBIBUFFER
argument_list|,
name|bktr
operator|->
name|vbibuffer
argument_list|)
expr_stmt|;
name|bktr_store_address
argument_list|(
name|unit
argument_list|,
name|BKTR_MEM_BUF
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: buffer size %d, addr 0x%x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|BROOKTREE_ALLOC
argument_list|,
name|vtophys
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|!=
literal|0
condition|)
block|{
name|bktr
operator|->
name|bigbuf
operator|=
name|buf
expr_stmt|;
name|bktr
operator|->
name|alloc_pages
operator|=
name|BROOKTREE_ALLOC_PAGES
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|bigbuf
argument_list|,
name|BROOKTREE_ALLOC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bktr
operator|->
name|alloc_pages
operator|=
literal|0
expr_stmt|;
block|}
name|bktr
operator|->
name|flags
operator|=
name|METEOR_INITALIZED
operator||
name|METEOR_AUTOMODE
operator||
name|METEOR_DEV0
operator||
name|METEOR_RGB16
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
name|bktr
operator|->
name|cols
operator|=
literal|640
expr_stmt|;
name|bktr
operator|->
name|rows
operator|=
literal|480
expr_stmt|;
name|bktr
operator|->
name|frames
operator|=
literal|1
expr_stmt|;
comment|/* one frame */
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB16
expr_stmt|;
name|bktr
operator|->
name|pixfmt
operator|=
name|oformat_meteor_to_bt
argument_list|(
name|bktr
operator|->
name|format
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|pixfmt_compat
operator|=
name|TRUE
expr_stmt|;
name|bktr
operator|->
name|vbiinsert
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|vbistart
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|vbisize
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|vbiflags
operator|=
literal|0
expr_stmt|;
comment|/* using the pci device id and revision id */
comment|/* and determine the card type            */
if|if
condition|(
name|PCI_VENDOR
argument_list|(
name|pci_id
argument_list|)
operator|==
name|PCI_VENDOR_BROOKTREE
condition|)
block|{
switch|switch
condition|(
name|PCI_PRODUCT
argument_list|(
name|pci_id
argument_list|)
condition|)
block|{
case|case
name|PCI_PRODUCT_BROOKTREE_BT848
case|:
if|if
condition|(
name|rev
operator|==
literal|0x12
condition|)
name|bktr
operator|->
name|id
operator|=
name|BROOKTREE_848A
expr_stmt|;
else|else
name|bktr
operator|->
name|id
operator|=
name|BROOKTREE_848
expr_stmt|;
break|break;
case|case
name|PCI_PRODUCT_BROOKTREE_BT849
case|:
name|bktr
operator|->
name|id
operator|=
name|BROOKTREE_849A
expr_stmt|;
break|break;
case|case
name|PCI_PRODUCT_BROOKTREE_BT878
case|:
name|bktr
operator|->
name|id
operator|=
name|BROOKTREE_878
expr_stmt|;
break|break;
case|case
name|PCI_PRODUCT_BROOKTREE_BT879
case|:
name|bktr
operator|->
name|id
operator|=
name|BROOKTREE_879
expr_stmt|;
break|break;
block|}
block|}
empty_stmt|;
name|bktr
operator|->
name|clr_on_start
operator|=
name|FALSE
expr_stmt|;
comment|/* defaults for the tuner section of the card */
name|bktr
operator|->
name|tflags
operator|=
name|TUNER_INITALIZED
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|channel
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|chnlset
operator|=
name|DEFAULT_CHNLSET
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|afc
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|radio_mode
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|audio_mute_state
operator|=
name|FALSE
expr_stmt|;
name|bktr
operator|->
name|bt848_card
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|bt848_tuner
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|reverse_mute
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|slow_msp_audio
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|msp_use_mono_source
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|msp_source_selected
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|audio_mux_present
operator|=
literal|1
expr_stmt|;
name|probeCard
argument_list|(
name|bktr
argument_list|,
name|TRUE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* Initialise any MSP34xx or TDA98xx audio chips */
name|init_audio_devices
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the vbi lines from 'vbidata' into the circular buffer, 'vbibuffer'.  * The circular buffer holds 'n' fixed size data blocks.   * vbisize   is the number of bytes in the circular buffer   * vbiread   is the point we reading data out of the circular buffer   * vbiinsert is the point we insert data into the circular buffer   */
end_comment

begin_function
specifier|static
name|void
name|vbidecode
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|dest
decl_stmt|;
name|unsigned
name|int
modifier|*
name|seq_dest
decl_stmt|;
comment|/* Check if there is room in the buffer to insert the data. */
if|if
condition|(
name|bktr
operator|->
name|vbisize
operator|+
name|VBI_DATA_SIZE
operator|>
name|VBI_BUFFER_SIZE
condition|)
return|return;
comment|/* Copy the VBI data into the next free slot in the buffer. */
comment|/* 'dest' is the point in vbibuffer where we want to insert new data */
name|dest
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bktr
operator|->
name|vbibuffer
operator|+
name|bktr
operator|->
name|vbiinsert
expr_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bktr
operator|->
name|vbidata
argument_list|,
name|VBI_DATA_SIZE
argument_list|)
expr_stmt|;
comment|/* Write the VBI sequence number to the end of the vbi data */
comment|/* This is used by the AleVT teletext program */
name|seq_dest
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bktr
operator|->
name|vbibuffer
operator|+
name|bktr
operator|->
name|vbiinsert
operator|+
operator|(
name|VBI_DATA_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|bktr
operator|->
name|vbi_sequence_number
argument_list|)
operator|)
operator|)
expr_stmt|;
operator|*
name|seq_dest
operator|=
name|bktr
operator|->
name|vbi_sequence_number
expr_stmt|;
comment|/* And increase the VBI sequence number */
comment|/* This can wrap around */
name|bktr
operator|->
name|vbi_sequence_number
operator|++
expr_stmt|;
comment|/* Increment the vbiinsert pointer */
comment|/* This can wrap around */
name|bktr
operator|->
name|vbiinsert
operator|+=
name|VBI_DATA_SIZE
expr_stmt|;
name|bktr
operator|->
name|vbiinsert
operator|=
operator|(
name|bktr
operator|->
name|vbiinsert
operator|%
name|VBI_BUFFER_SIZE
operator|)
expr_stmt|;
comment|/* And increase the amount of vbi data in the buffer */
name|bktr
operator|->
name|vbisize
operator|=
name|bktr
operator|->
name|vbisize
operator|+
name|VBI_DATA_SIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * the common interrupt handler.  * Returns a 0 or 1 depending on whether the interrupt has handled.  * In the OS specific section, bktr_intr() is defined which calls this  * common interrupt handler.  */
end_comment

begin_function
name|int
name|common_bktr_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|u_long
name|bktr_status
decl_stmt|;
name|u_char
name|dstatus
decl_stmt|;
name|u_long
name|field
decl_stmt|;
name|u_long
name|w_field
decl_stmt|;
name|u_long
name|req_field
decl_stmt|;
name|bktr
operator|=
operator|(
name|bktr_ptr_t
operator|)
name|arg
expr_stmt|;
comment|/* 	 * check to see if any interrupts are unmasked on this device.  If 	 * none are, then we likely got here by way of being on a PCI shared 	 * interrupt dispatch list. 	 */
if|if
condition|(
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|)
operator|==
name|ALL_INTS_DISABLED
condition|)
return|return
literal|0
return|;
comment|/* bail out now, before we do something we 				   shouldn't */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_OPEN
operator|)
condition|)
block|{
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|FIFO_RISC_DISABLED
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|,
name|ALL_INTS_DISABLED
argument_list|)
expr_stmt|;
comment|/* return; ?? */
block|}
comment|/* record and clear the INTerrupt status bits */
name|bktr_status
operator|=
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|,
name|bktr_status
operator|&
operator|~
name|I2C_BITS
argument_list|)
expr_stmt|;
comment|/* don't touch i2c */
comment|/* record and clear the device status register */
name|dstatus
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_DSTATUS
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_DSTATUS
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|STATUS_SUM
argument_list|)
comment|/* add any new device status or INTerrupt status bits */
name|status_sum
operator||=
operator|(
name|bktr_status
operator|&
operator|~
operator|(
name|BT848_INT_RSV0
operator||
name|BT848_INT_RSV1
operator|)
operator|)
expr_stmt|;
name|status_sum
operator||=
operator|(
operator|(
name|dstatus
operator|&
operator|(
name|BT848_DSTATUS_COF
operator||
name|BT848_DSTATUS_LOF
operator|)
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* STATUS_SUM */
comment|/* printf( "%s: STATUS %x %x %x \n", bktr_name(bktr), 		dstatus, bktr_status, INL(bktr, BKTR_RISC_COUNT) ); 	*/
comment|/* if risc was disabled re-start process again */
comment|/* if there was one of the following errors re-start again */
if|if
condition|(
operator|!
operator|(
name|bktr_status
operator|&
name|BT848_INT_RISC_EN
operator|)
operator|||
operator|(
operator|(
name|bktr_status
operator|&
operator|(
comment|/* BT848_INT_FBUS   | */
comment|/* BT848_INT_FTRGT  | */
comment|/* BT848_INT_FDSR   | */
name|BT848_INT_PPERR
operator||
name|BT848_INT_RIPERR
operator||
name|BT848_INT_PABORT
operator||
name|BT848_INT_OCERR
operator||
name|BT848_INT_SCERR
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_TDEC
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bktr_status
operator|&
name|TDEC_BITS
operator|)
operator|)
condition|)
block|{
name|u_short
name|tdec_save
init|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_TDEC
argument_list|)
decl_stmt|;
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|FIFO_RISC_DISABLED
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_CAP_CTL
argument_list|,
name|CAPTURE_OFF
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|,
name|ALL_INTS_DISABLED
argument_list|)
expr_stmt|;
comment|/*  Reset temporal decimation counter  */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_TDEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_TDEC
argument_list|,
name|tdec_save
argument_list|)
expr_stmt|;
comment|/*  Reset to no-fields captured state  */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
block|}
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_RISC_STRT_ADD
argument_list|,
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
argument_list|)
expr_stmt|;
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|FIFO_ENABLED
argument_list|)
expr_stmt|;
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|bktr
operator|->
name|capcontrol
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|,
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_RISCI
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_CAP_CTL
argument_list|,
name|bktr
operator|->
name|bktr_cap_ctl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If this is not a RISC program interrupt, return */
if|if
condition|(
operator|!
operator|(
name|bktr_status
operator|&
name|BT848_INT_RISCI
operator|)
condition|)
return|return
literal|0
return|;
comment|/** 	printf( "%s: intr status %x %x %x\n", bktr_name(bktr), 		bktr_status, dstatus, INL(bktr, BKTR_RISC_COUNT) );  */
comment|/* 	 * Disable future interrupts if a capture mode is not selected. 	 * This can happen when we are in the process of closing or  	 * changing capture modes, otherwise it shouldn't happen. 	 */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
operator|)
condition|)
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_CAP_CTL
argument_list|,
name|CAPTURE_OFF
argument_list|)
expr_stmt|;
comment|/* Determine which field generated this interrupt */
name|field
operator|=
operator|(
name|bktr_status
operator|&
name|BT848_INT_FIELD
operator|)
condition|?
name|EVEN_F
else|:
name|ODD_F
expr_stmt|;
comment|/* 	 * Process the VBI data if it is being captured. We do this once 	 * both Odd and Even VBI data is captured. Therefore we do this 	 * in the Even field interrupt handler. 	 */
if|if
condition|(
operator|(
name|bktr
operator|->
name|vbiflags
operator|&
name|VBI_CAPTURE
operator|)
operator|&&
operator|(
name|bktr
operator|->
name|vbiflags
operator|&
name|VBI_OPEN
operator|)
operator|&&
operator|(
name|field
operator|==
name|EVEN_F
operator|)
condition|)
block|{
comment|/* Put VBI data into circular buffer */
name|vbidecode
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
comment|/* If someone is blocked on reading from /dev/vbi, wake them */
if|if
condition|(
name|bktr
operator|->
name|vbi_read_blocked
condition|)
block|{
name|bktr
operator|->
name|vbi_read_blocked
operator|=
name|FALSE
expr_stmt|;
name|wakeup
argument_list|(
name|VBI_SLEEP
argument_list|)
expr_stmt|;
block|}
comment|/* If someone has a select() on /dev/vbi, inform them */
if|if
condition|(
name|bktr
operator|->
name|vbi_select
operator|.
name|si_pid
condition|)
block|{
name|selwakeup
argument_list|(
operator|&
name|bktr
operator|->
name|vbi_select
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 *  Register the completed field 	 *    (For dual-field mode, require fields from the same frame) 	 */
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_WANT_MASK
condition|)
block|{
case|case
name|METEOR_WANT_ODD
case|:
name|w_field
operator|=
name|ODD_F
expr_stmt|;
break|break;
case|case
name|METEOR_WANT_EVEN
case|:
name|w_field
operator|=
name|EVEN_F
expr_stmt|;
break|break;
default|default               :
name|w_field
operator|=
operator|(
name|ODD_F
operator||
name|EVEN_F
operator|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|req_field
operator|=
name|ODD_F
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|req_field
operator|=
name|EVEN_F
expr_stmt|;
break|break;
default|default                      :
name|req_field
operator|=
operator|(
name|ODD_F
operator||
name|EVEN_F
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|field
operator|==
name|EVEN_F
operator|)
operator|&&
operator|(
name|w_field
operator|==
name|EVEN_F
operator|)
condition|)
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_EVEN
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|field
operator|==
name|ODD_F
operator|)
operator|&&
operator|(
name|req_field
operator|==
name|ODD_F
operator|)
operator|&&
operator|(
name|w_field
operator|==
name|ODD_F
operator|)
condition|)
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_ODD
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|field
operator|==
name|ODD_F
operator|)
operator|&&
operator|(
name|req_field
operator|==
operator|(
name|ODD_F
operator||
name|EVEN_F
operator|)
operator|)
operator|&&
operator|(
name|w_field
operator|==
operator|(
name|ODD_F
operator||
name|EVEN_F
operator|)
operator|)
condition|)
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_ODD
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|field
operator|==
name|ODD_F
operator|)
operator|&&
operator|(
name|req_field
operator|==
operator|(
name|ODD_F
operator||
name|EVEN_F
operator|)
operator|)
operator|&&
operator|(
name|w_field
operator|==
name|ODD_F
operator|)
condition|)
block|{
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_ODD
expr_stmt|;
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
block|}
else|else
block|{
comment|/*  We're out of sync.  Start over.  */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
comment|/* 	 * If we have a complete frame. 	 */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_WANT_MASK
operator|)
condition|)
block|{
name|bktr
operator|->
name|frames_captured
operator|++
expr_stmt|;
comment|/* 		 * post the completion time.  		 */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_WANT_TS
condition|)
block|{
name|struct
name|timeval
modifier|*
name|ts
decl_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|<=
operator|(
name|bktr
operator|->
name|frame_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
operator|)
condition|)
block|{
name|ts
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|bktr
operator|->
name|bigbuf
operator|+
name|bktr
operator|->
name|frame_size
expr_stmt|;
comment|/* doesn't work in synch mode except 				 *  for first frame */
comment|/* XXX */
name|microtime
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Wake up the user in single capture mode. 		 */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_SINGLE
condition|)
block|{
comment|/* stop dma */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|,
name|ALL_INTS_DISABLED
argument_list|)
expr_stmt|;
comment|/* disable risc, leave fifo running */
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|FIFO_ENABLED
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|BKTR_SLEEP
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the user requested to be notified via signal, 		 * let them know the frame is complete. 		 */
if|if
condition|(
name|bktr
operator|->
name|proc
operator|&&
operator|!
operator|(
name|bktr
operator|->
name|signal
operator|&
name|METEOR_SIG_MODE_MASK
operator|)
condition|)
name|psignal
argument_list|(
name|bktr
operator|->
name|proc
argument_list|,
name|bktr
operator|->
name|signal
operator|&
operator|(
operator|~
name|METEOR_SIG_MODE_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Reset the want flags if in continuous or 		 * synchronous capture mode. 		 */
comment|/* * XXX NOTE (Luigi): * currently we only support 3 capture modes: odd only, even only, * odd+even interlaced (odd field first). A fourth mode (non interlaced, * either even OR odd) could provide 60 (50 for PAL) pictures per * second, but it would require this routine to toggle the desired frame * each time, and one more different DMA program for the Bt848. * As a consequence, this fourth mode is currently unsupported. */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|bt848_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to set the default format, PAL or NTSC */
end_comment

begin_function
name|int
name|video_open
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|int
name|frame_rate
decl_stmt|,
name|video_format
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_OPEN
condition|)
comment|/* device is busy */
return|return
operator|(
name|EBUSY
operator|)
return|;
name|bktr
operator|->
name|flags
operator||=
name|METEOR_OPEN
expr_stmt|;
ifdef|#
directive|ifdef
name|BT848_DUMP
name|dump_bt848
argument_list|(
name|bt848
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bktr
operator|->
name|clr_on_start
operator|=
name|FALSE
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_DSTATUS
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* clear device status reg. */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_ADC
argument_list|,
name|SYNC_LEVEL
argument_list|)
expr_stmt|;
if|#
directive|if
name|BKTR_SYSTEM_DEFAULT
operator|==
name|BROOKTREE_PAL
name|video_format
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|video_format
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bt848_format
operator|==
literal|0
condition|)
name|video_format
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bt848_format
operator|==
literal|1
condition|)
name|video_format
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|video_format
operator|==
literal|1
condition|)
block|{
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|BT848_IFORM_F_NTSCM
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|BT848_IFORM_F_NTSCM
expr_stmt|;
block|}
else|else
block|{
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|BT848_IFORM_F_PALBDGHI
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|BT848_IFORM_F_PALBDGHI
expr_stmt|;
block|}
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator||
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|iform_xtsel
argument_list|)
expr_stmt|;
comment|/* work around for new Hauppauge 878 cards */
if|if
condition|(
operator|(
name|bktr
operator|->
name|card
operator|.
name|card_id
operator|==
name|CARD_HAUPPAUGE
operator|)
operator|&&
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_878
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_879
operator|)
condition|)
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator||
name|BT848_IFORM_M_MUX3
argument_list|)
expr_stmt|;
else|else
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator||
name|BT848_IFORM_M_MUX1
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_ADELAY
argument_list|,
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|adelay
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_BDELAY
argument_list|,
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|bdelay
argument_list|)
expr_stmt|;
name|frame_rate
operator|=
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|frame_rate
expr_stmt|;
comment|/* enable PLL mode using 28Mhz crystal for PAL/SECAM users */
if|if
condition|(
name|bktr
operator|->
name|xtal_pll_mode
operator|==
name|BT848_USE_PLL
condition|)
block|{
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_TGCTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_PLL_F_LO
argument_list|,
literal|0xf9
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_PLL_F_HI
argument_list|,
literal|0xdc
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_PLL_F_XCI
argument_list|,
literal|0x8e
argument_list|)
expr_stmt|;
block|}
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV0
expr_stmt|;
name|bktr
operator|->
name|max_clip_node
operator|=
literal|0
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|,
name|BT848_COLOR_CTL_GAMMA
operator||
name|BT848_COLOR_CTL_RGB_DED
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_HSCALE_LO
argument_list|,
literal|170
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_HSCALE_LO
argument_list|,
literal|170
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_DELAY_LO
argument_list|,
literal|0x72
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_DELAY_LO
argument_list|,
literal|0x72
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_SCLOOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_SCLOOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_VBI_PACK_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_VBI_PACK_DEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|fifo_errors
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|dma_errors
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|frames_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|even_fields_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|odd_fields_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
expr_stmt|;
name|set_fps
argument_list|(
name|bktr
argument_list|,
name|frame_rate
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|width
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|banksize
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|ramsize
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|pixfmt_compat
operator|=
name|TRUE
expr_stmt|;
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB16
expr_stmt|;
name|bktr
operator|->
name|pixfmt
operator|=
name|oformat_meteor_to_bt
argument_list|(
name|bktr
operator|->
name|format
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|capture_area_enabled
operator|=
name|FALSE
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|,
name|BT848_INT_MYSTERYBIT
argument_list|)
expr_stmt|;
comment|/* if you take this out triton                                                    based motherboards will  						   operate unreliably */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vbi_open
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
if|if
condition|(
name|bktr
operator|->
name|vbiflags
operator|&
name|VBI_OPEN
condition|)
comment|/* device is busy */
return|return
operator|(
name|EBUSY
operator|)
return|;
name|bktr
operator|->
name|vbiflags
operator||=
name|VBI_OPEN
expr_stmt|;
comment|/* reset the VBI circular buffer pointers and clear the buffers */
name|bktr
operator|->
name|vbiinsert
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|vbistart
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|vbisize
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|vbi_sequence_number
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|vbi_read_blocked
operator|=
name|FALSE
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|vbibuffer
argument_list|,
name|VBI_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|vbidata
argument_list|,
name|VBI_DATA_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|tuner_open
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|tflags
operator|&
name|TUNER_INITALIZED
operator|)
condition|)
comment|/* device not found */
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|bktr
operator|->
name|tflags
operator|&
name|TUNER_OPEN
condition|)
comment|/* already open */
return|return
operator|(
literal|0
operator|)
return|;
name|bktr
operator|->
name|tflags
operator||=
name|TUNER_OPEN
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|channel
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|chnlset
operator|=
name|DEFAULT_CHNLSET
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|afc
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|radio_mode
operator|=
literal|0
expr_stmt|;
comment|/* enable drivers on the GPIO port that control the MUXes */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_OUT_EN
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_OUT_EN
argument_list|)
operator||
name|bktr
operator|->
name|card
operator|.
name|gpio_mux_bits
argument_list|)
expr_stmt|;
comment|/* unmute the audio stream */
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_UNMUTE
argument_list|)
expr_stmt|;
comment|/* Initialise any audio chips, eg MSP34xx or TDA98xx */
name|init_audio_devices
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|video_close
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_OPEN
operator||
name|METEOR_SINGLE
operator||
name|METEOR_CAP_MASK
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|FIFO_RISC_DISABLED
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_CAP_CTL
argument_list|,
name|CAPTURE_OFF
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_TDEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|,
name|ALL_INTS_DISABLED
argument_list|)
expr_stmt|;
comment|/** FIXME: is 0xf magic, wouldn't 0x00 work ??? */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_SRESET
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|,
name|ALL_INTS_CLEARED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tuner close handle,  *  place holder for tuner specific operations on a close.  */
end_comment

begin_function
name|int
name|tuner_close
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|bktr
operator|->
name|tflags
operator|&=
operator|~
name|TUNER_OPEN
expr_stmt|;
comment|/* mute the audio by switching the mux */
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_MUTE
argument_list|)
expr_stmt|;
comment|/* disable drivers on the GPIO port that control the MUXes */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_OUT_EN
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_OUT_EN
argument_list|)
operator|&
operator|~
name|bktr
operator|->
name|card
operator|.
name|gpio_mux_bits
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vbi_close
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|bktr
operator|->
name|vbiflags
operator|&=
operator|~
name|VBI_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|int
name|video_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated (ioctl failed) */
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* already capturing */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_CAP_CTL
argument_list|,
name|bktr
operator|->
name|bktr_cap_ctl
argument_list|)
expr_stmt|;
name|count
operator|=
name|bktr
operator|->
name|rows
operator|*
name|bktr
operator|->
name|cols
operator|*
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
operator|.
name|public
operator|.
name|Bpp
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<
name|count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_CAP_MASK
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
comment|/* capture one frame */
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_SINGLE
argument_list|)
expr_stmt|;
comment|/* wait for capture to complete */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|,
name|ALL_INTS_CLEARED
argument_list|)
expr_stmt|;
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|FIFO_ENABLED
argument_list|)
expr_stmt|;
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|bktr
operator|->
name|capcontrol
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|,
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_RISCI
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
argument_list|)
expr_stmt|;
name|status
operator|=
name|tsleep
argument_list|(
name|BKTR_SLEEP
argument_list|,
name|BKTRPRI
argument_list|,
literal|"captur"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
comment|/* successful capture */
name|status
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|bigbuf
argument_list|,
name|count
argument_list|,
name|uio
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s: read: tsleep error %d\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read VBI data from the vbi circular buffer  * The buffer holds vbi data blocks which are the same size  * vbiinsert is the position we will insert the next item into the buffer  * vbistart is the actual position in the buffer we want to read from  * vbisize is the exact number of bytes in the buffer left to read   */
end_comment

begin_function
name|int
name|vbi_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|int
name|readsize
decl_stmt|,
name|readsize2
decl_stmt|;
name|int
name|status
decl_stmt|;
while|while
condition|(
name|bktr
operator|->
name|vbisize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
block|{
return|return
name|EWOULDBLOCK
return|;
block|}
name|bktr
operator|->
name|vbi_read_blocked
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|tsleep
argument_list|(
name|VBI_SLEEP
argument_list|,
name|VBIPRI
argument_list|,
literal|"vbi"
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
comment|/* Now we have some data to give to the user */
comment|/* We cannot read more bytes than there are in 	 * the circular buffer 	 */
name|readsize
operator|=
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
expr_stmt|;
if|if
condition|(
name|readsize
operator|>
name|bktr
operator|->
name|vbisize
condition|)
name|readsize
operator|=
name|bktr
operator|->
name|vbisize
expr_stmt|;
comment|/* Check if we can read this number of bytes without having 	 * to wrap around the circular buffer */
if|if
condition|(
operator|(
name|bktr
operator|->
name|vbistart
operator|+
name|readsize
operator|)
operator|>=
name|VBI_BUFFER_SIZE
condition|)
block|{
comment|/* We need to wrap around */
name|readsize2
operator|=
name|VBI_BUFFER_SIZE
operator|-
name|bktr
operator|->
name|vbistart
expr_stmt|;
name|status
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|vbibuffer
operator|+
name|bktr
operator|->
name|vbistart
argument_list|,
name|readsize2
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|status
operator|+=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|vbibuffer
argument_list|,
operator|(
name|readsize
operator|-
name|readsize2
operator|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We do not need to wrap around */
name|status
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|vbibuffer
operator|+
name|bktr
operator|->
name|vbistart
argument_list|,
name|readsize
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
comment|/* Update the number of bytes left to read */
name|bktr
operator|->
name|vbisize
operator|-=
name|readsize
expr_stmt|;
comment|/* Update vbistart */
name|bktr
operator|->
name|vbistart
operator|+=
name|readsize
expr_stmt|;
name|bktr
operator|->
name|vbistart
operator|=
name|bktr
operator|->
name|vbistart
operator|%
name|VBI_BUFFER_SIZE
expr_stmt|;
comment|/* wrap around if needed */
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * video ioctls  */
end_comment

begin_function
name|int
name|video_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|ioctl_cmd_t
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
specifier|volatile
name|u_char
name|c_temp
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|;
name|unsigned
name|int
name|temp_iform
decl_stmt|;
name|unsigned
name|int
name|error
decl_stmt|;
name|struct
name|meteor_geomet
modifier|*
name|geo
decl_stmt|;
name|struct
name|meteor_counts
modifier|*
name|counts
decl_stmt|;
name|struct
name|meteor_video
modifier|*
name|video
decl_stmt|;
name|struct
name|bktr_capture_area
modifier|*
name|cap_area
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|char_temp
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|BT848SCLIP
case|:
comment|/* set clip region */
name|bktr
operator|->
name|max_clip_node
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|bktr
operator|->
name|clip_list
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|bktr
operator|->
name|clip_list
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BT848_MAX_CLIP_NODE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_min
operator|==
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_max
operator|==
literal|0
condition|)
break|break;
block|}
name|bktr
operator|->
name|max_clip_node
operator|=
name|i
expr_stmt|;
comment|/* make sure that the list contains a valid clip secquence */
comment|/* the clip rectangles should be sorted by x then by y as the                second order sort key */
comment|/* clip rectangle list is terminated by y_min and y_max set to 0 */
comment|/* to disable clipping set  y_min and y_max to 0 in the first                clip rectangle . The first clip rectangle is clip_list[0].              */
if|if
condition|(
name|bktr
operator|->
name|max_clip_node
operator|==
literal|0
operator|&&
operator|(
name|bktr
operator|->
name|clip_list
index|[
literal|0
index|]
operator|.
name|y_min
operator|!=
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
literal|0
index|]
operator|.
name|y_max
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BT848_MAX_CLIP_NODE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_min
operator|==
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_max
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|bktr
operator|->
name|clip_list
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y_min
operator|!=
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y_max
operator|!=
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_min
operator|>
name|bktr
operator|->
name|clip_list
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x_min
condition|)
block|{
name|bktr
operator|->
name|max_clip_node
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_min
operator|>=
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_max
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_min
operator|>=
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_max
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_min
operator|<
literal|0
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_max
operator|<
literal|0
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_min
operator|<
literal|0
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_max
operator|<
literal|0
condition|)
block|{
name|bktr
operator|->
name|max_clip_node
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|METEORSTATUS
case|:
comment|/* get Bt848 status */
name|c_temp
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_DSTATUS
argument_list|)
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c_temp
operator|&
literal|0x40
operator|)
condition|)
name|temp
operator||=
name|METEOR_STATUS_HCLK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c_temp
operator|&
literal|0x10
operator|)
condition|)
name|temp
operator||=
name|METEOR_STATUS_FIDT
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|BT848SFMT
case|:
comment|/* set input format */
name|temp
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|BT848_IFORM_FORMAT
expr_stmt|;
name|temp_iform
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
expr_stmt|;
name|temp_iform
operator|&=
operator|~
name|BT848_IFORM_FORMAT
expr_stmt|;
name|temp_iform
operator|&=
operator|~
name|BT848_IFORM_XTSEL
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
operator|(
name|temp_iform
operator||
name|temp
operator||
name|format_params
index|[
name|temp
index|]
operator|.
name|iform_xtsel
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|BT848_IFORM_F_AUTO
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_AUTOMODE
expr_stmt|;
break|break;
case|case
name|BT848_IFORM_F_NTSCM
case|:
case|case
name|BT848_IFORM_F_NTSCJ
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_NTSC
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_ADELAY
argument_list|,
name|format_params
index|[
name|temp
index|]
operator|.
name|adelay
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_BDELAY
argument_list|,
name|format_params
index|[
name|temp
index|]
operator|.
name|bdelay
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|BT848_IFORM_F_PALBDGHI
case|:
case|case
name|BT848_IFORM_F_PALN
case|:
case|case
name|BT848_IFORM_F_SECAM
case|:
case|case
name|BT848_IFORM_F_RSVD
case|:
case|case
name|BT848_IFORM_F_PALM
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_PAL
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_ADELAY
argument_list|,
name|format_params
index|[
name|temp
index|]
operator|.
name|adelay
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_BDELAY
argument_list|,
name|format_params
index|[
name|temp
index|]
operator|.
name|bdelay
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|temp
expr_stmt|;
break|break;
block|}
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|METEORSFMT
case|:
comment|/* set input format */
name|temp_iform
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
expr_stmt|;
name|temp_iform
operator|&=
operator|~
name|BT848_IFORM_FORMAT
expr_stmt|;
name|temp_iform
operator|&=
operator|~
name|BT848_IFORM_XTSEL
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|METEOR_FORM_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_FMT_NTSC
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_NTSC
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|temp_iform
operator||
name|BT848_IFORM_F_NTSCM
operator||
name|format_params
index|[
name|BT848_IFORM_F_NTSCM
index|]
operator|.
name|iform_xtsel
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_ADELAY
argument_list|,
name|format_params
index|[
name|BT848_IFORM_F_NTSCM
index|]
operator|.
name|adelay
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_BDELAY
argument_list|,
name|format_params
index|[
name|BT848_IFORM_F_NTSCM
index|]
operator|.
name|bdelay
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|BT848_IFORM_F_NTSCM
expr_stmt|;
break|break;
case|case
name|METEOR_FMT_PAL
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_PAL
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|temp_iform
operator||
name|BT848_IFORM_F_PALBDGHI
operator||
name|format_params
index|[
name|BT848_IFORM_F_PALBDGHI
index|]
operator|.
name|iform_xtsel
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_ADELAY
argument_list|,
name|format_params
index|[
name|BT848_IFORM_F_PALBDGHI
index|]
operator|.
name|adelay
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_BDELAY
argument_list|,
name|format_params
index|[
name|BT848_IFORM_F_PALBDGHI
index|]
operator|.
name|bdelay
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|BT848_IFORM_F_PALBDGHI
expr_stmt|;
break|break;
case|case
name|METEOR_FMT_AUTOMODE
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_AUTOMODE
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|temp_iform
operator||
name|BT848_IFORM_F_AUTO
operator||
name|format_params
index|[
name|BT848_IFORM_F_AUTO
index|]
operator|.
name|iform_xtsel
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|METEORGFMT
case|:
comment|/* get input format */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|flags
operator|&
name|METEOR_FORM_MASK
expr_stmt|;
break|break;
case|case
name|BT848GFMT
case|:
comment|/* get input format */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator|&
name|BT848_IFORM_FORMAT
expr_stmt|;
break|break;
case|case
name|METEORSCOUNT
case|:
comment|/* (re)set error counts */
name|counts
operator|=
operator|(
expr|struct
name|meteor_counts
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|fifo_errors
operator|=
name|counts
operator|->
name|fifo_errors
expr_stmt|;
name|bktr
operator|->
name|dma_errors
operator|=
name|counts
operator|->
name|dma_errors
expr_stmt|;
name|bktr
operator|->
name|frames_captured
operator|=
name|counts
operator|->
name|frames_captured
expr_stmt|;
name|bktr
operator|->
name|even_fields_captured
operator|=
name|counts
operator|->
name|even_fields_captured
expr_stmt|;
name|bktr
operator|->
name|odd_fields_captured
operator|=
name|counts
operator|->
name|odd_fields_captured
expr_stmt|;
break|break;
case|case
name|METEORGCOUNT
case|:
comment|/* get error counts */
name|counts
operator|=
operator|(
expr|struct
name|meteor_counts
operator|*
operator|)
name|arg
expr_stmt|;
name|counts
operator|->
name|fifo_errors
operator|=
name|bktr
operator|->
name|fifo_errors
expr_stmt|;
name|counts
operator|->
name|dma_errors
operator|=
name|bktr
operator|->
name|dma_errors
expr_stmt|;
name|counts
operator|->
name|frames_captured
operator|=
name|bktr
operator|->
name|frames_captured
expr_stmt|;
name|counts
operator|->
name|even_fields_captured
operator|=
name|bktr
operator|->
name|even_fields_captured
expr_stmt|;
name|counts
operator|->
name|odd_fields_captured
operator|=
name|bktr
operator|->
name|odd_fields_captured
expr_stmt|;
break|break;
case|case
name|METEORGVIDEO
case|:
name|video
operator|=
operator|(
expr|struct
name|meteor_video
operator|*
operator|)
name|arg
expr_stmt|;
name|video
operator|->
name|addr
operator|=
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
name|video
operator|->
name|width
operator|=
name|bktr
operator|->
name|video
operator|.
name|width
expr_stmt|;
name|video
operator|->
name|banksize
operator|=
name|bktr
operator|->
name|video
operator|.
name|banksize
expr_stmt|;
name|video
operator|->
name|ramsize
operator|=
name|bktr
operator|->
name|video
operator|.
name|ramsize
expr_stmt|;
break|break;
case|case
name|METEORSVIDEO
case|:
name|video
operator|=
operator|(
expr|struct
name|meteor_video
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|addr
operator|=
name|video
operator|->
name|addr
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|width
operator|=
name|video
operator|->
name|width
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|banksize
operator|=
name|video
operator|->
name|banksize
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|ramsize
operator|=
name|video
operator|->
name|ramsize
expr_stmt|;
break|break;
case|case
name|METEORSFPS
case|:
name|set_fps
argument_list|(
name|bktr
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGFPS
case|:
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|fps
expr_stmt|;
break|break;
case|case
name|METEORSHUE
case|:
comment|/* set hue */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_HUE
argument_list|,
operator|(
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGHUE
case|:
comment|/* get hue */
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_HUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORSBRIG
case|:
comment|/* set brightness */
name|char_temp
operator|=
operator|(
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|&
literal|0xff
operator|)
operator|-
literal|128
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_BRIGHT
argument_list|,
name|char_temp
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGBRIG
case|:
comment|/* get brightness */
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_BRIGHT
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORSCSAT
case|:
comment|/* set chroma saturation */
name|temp
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_SAT_U_LO
argument_list|,
operator|(
name|temp
operator|<<
literal|1
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_SAT_V_LO
argument_list|,
operator|(
name|temp
operator|<<
literal|1
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator|&
operator|~
operator|(
name|BT848_E_CONTROL_SAT_U_MSB
operator||
name|BT848_E_CONTROL_SAT_V_MSB
operator|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
operator|&
operator|~
operator|(
name|BT848_O_CONTROL_SAT_U_MSB
operator||
name|BT848_O_CONTROL_SAT_V_MSB
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|BIT_SEVEN_HIGH
condition|)
block|{
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator||
operator|(
name|BT848_E_CONTROL_SAT_U_MSB
operator||
name|BT848_E_CONTROL_SAT_V_MSB
operator|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
operator||
operator|(
name|BT848_O_CONTROL_SAT_U_MSB
operator||
name|BT848_O_CONTROL_SAT_V_MSB
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|METEORGCSAT
case|:
comment|/* get chroma saturation */
name|temp
operator|=
operator|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_SAT_V_LO
argument_list|)
operator|>>
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator|&
name|BT848_E_CONTROL_SAT_V_MSB
condition|)
name|temp
operator||=
name|BIT_SEVEN_HIGH
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
operator|(
name|u_char
operator|)
name|temp
expr_stmt|;
break|break;
case|case
name|METEORSCONT
case|:
comment|/* set contrast */
name|temp
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|&
literal|0xff
expr_stmt|;
name|temp
operator|<<=
literal|1
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_CONTRAST_LO
argument_list|,
name|temp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator|&
operator|~
name|BT848_E_CONTROL_CON_MSB
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
operator|&
operator|~
name|BT848_O_CONTROL_CON_MSB
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator||
operator|(
operator|(
operator|(
name|temp
operator|&
literal|0x100
operator|)
operator|>>
literal|6
operator|)
operator|&
name|BT848_E_CONTROL_CON_MSB
operator|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
operator||
operator|(
operator|(
operator|(
name|temp
operator|&
literal|0x100
operator|)
operator|>>
literal|6
operator|)
operator|&
name|BT848_O_CONTROL_CON_MSB
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGCONT
case|:
comment|/* get contrast */
name|temp
operator|=
operator|(
name|int
operator|)
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_CONTRAST_LO
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|temp
operator||=
operator|(
operator|(
name|int
operator|)
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
operator|&
literal|0x04
operator|)
operator|<<
literal|6
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|temp
operator|>>
literal|1
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848SCBUF
case|:
comment|/* set Clear-Buffer-on-start flag */
name|bktr
operator|->
name|clr_on_start
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|BT848GCBUF
case|:
comment|/* get Clear-Buffer-on-start flag */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
operator|(
name|int
operator|)
name|bktr
operator|->
name|clr_on_start
expr_stmt|;
break|break;
case|case
name|METEORSSIGNAL
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
literal|0
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|>=
name|NSIG
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
name|bktr
operator|->
name|signal
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|proc
operator|=
name|pr
expr_stmt|;
break|break;
case|case
name|METEORGSIGNAL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|signal
expr_stmt|;
break|break;
case|case
name|METEORCAPTUR
case|:
name|temp
operator|=
name|bktr
operator|->
name|flags
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
condition|)
block|{
case|case
name|METEOR_CAP_SINGLE
case|:
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated */
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* already capturing */
if|if
condition|(
name|temp
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_SINGLE
argument_list|)
expr_stmt|;
comment|/* wait for capture to complete */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|,
name|ALL_INTS_CLEARED
argument_list|)
expr_stmt|;
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|FIFO_ENABLED
argument_list|)
expr_stmt|;
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|bktr
operator|->
name|capcontrol
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|,
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_RISCI
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_CAP_CTL
argument_list|,
name|bktr
operator|->
name|bktr_cap_ctl
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|BKTR_SLEEP
argument_list|,
name|BKTRPRI
argument_list|,
literal|"captur"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|(
name|error
operator|!=
name|ERESTART
operator|)
condition|)
block|{
comment|/*  Here if we didn't get complete frame  */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"%s: ioctl: tsleep error %d %x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|error
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_RISC_COUNT
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* stop dma */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|,
name|ALL_INTS_DISABLED
argument_list|)
expr_stmt|;
comment|/* disable risc, leave fifo running */
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|FIFO_ENABLED
argument_list|)
expr_stmt|;
block|}
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
comment|/* FIXME: should we set bt848->int_stat ??? */
break|break;
case|case
name|METEOR_CAP_CONTINOUS
case|:
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated */
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* already capturing */
if|if
condition|(
name|temp
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_CONTIN
argument_list|)
expr_stmt|;
comment|/* Clear the interrypt status register */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|)
argument_list|)
expr_stmt|;
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|FIFO_ENABLED
argument_list|)
expr_stmt|;
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|bktr
operator|->
name|capcontrol
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_CAP_CTL
argument_list|,
name|bktr
operator|->
name|bktr_cap_ctl
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|,
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_RISCI
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BT848_DUMP
name|dump_bt848
argument_list|(
name|bt848
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|METEOR_CAP_STOP_CONT
case|:
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CONTIN
condition|)
block|{
comment|/* turn off capture */
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|FIFO_RISC_DISABLED
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_CAP_CTL
argument_list|,
name|CAPTURE_OFF
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|,
name|ALL_INTS_DISABLED
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|METEORSETGEO
case|:
comment|/* can't change parameters while capturing */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|geo
operator|=
operator|(
expr|struct
name|meteor_geomet
operator|*
operator|)
name|arg
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Either even or odd, if even& odd, then these a zero */
if|if
condition|(
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
operator|)
operator|&&
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ioctl: Geometry odd or even only.\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* set/clear even/odd flags */
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
condition|)
name|bktr
operator|->
name|flags
operator||=
name|METEOR_ONLY_ODD_FIELDS
expr_stmt|;
else|else
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_ONLY_ODD_FIELDS
expr_stmt|;
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
condition|)
name|bktr
operator|->
name|flags
operator||=
name|METEOR_ONLY_EVEN_FIELDS
expr_stmt|;
else|else
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_ONLY_EVEN_FIELDS
expr_stmt|;
if|if
condition|(
name|geo
operator|->
name|columns
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ioctl: %d: columns must be greater than zero.\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|geo
operator|->
name|columns
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|geo
operator|->
name|columns
operator|&
literal|0x3fe
operator|)
operator|!=
name|geo
operator|->
name|columns
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ioctl: %d: columns too large or not even.\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|geo
operator|->
name|columns
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|geo
operator|->
name|rows
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ioctl: %d: rows must be greater than zero.\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|geo
operator|->
name|rows
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|geo
operator|->
name|rows
operator|&
literal|0x7fe
operator|)
operator|!=
name|geo
operator|->
name|rows
operator|)
operator|||
operator|(
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_FIELD_MASK
operator|)
operator|&&
operator|(
operator|(
name|geo
operator|->
name|rows
operator|&
literal|0x3fe
operator|)
operator|!=
name|geo
operator|->
name|rows
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ioctl: %d: rows too large or not even.\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|geo
operator|->
name|rows
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|geo
operator|->
name|frames
operator|>
literal|32
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ioctl: too many frames.\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|FIFO_RISC_DISABLED
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|,
name|ALL_INTS_DISABLED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
operator|(
name|geo
operator|->
name|rows
operator|*
name|geo
operator|->
name|columns
operator|*
name|geo
operator|->
name|frames
operator|*
literal|2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_RGB24
condition|)
name|temp
operator|=
name|temp
operator|*
literal|2
expr_stmt|;
comment|/* meteor_mem structure for SYNC Capture */
if|if
condition|(
name|geo
operator|->
name|frames
operator|>
literal|1
condition|)
name|temp
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|temp
operator|=
name|btoc
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|temp
operator|>
name|bktr
operator|->
name|alloc_pages
operator|&&
name|bktr
operator|->
name|video
operator|.
name|addr
operator|==
literal|0
condition|)
block|{
comment|/*****************************/
comment|/* *** OS Dependant code *** */
comment|/*****************************/
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|bus_dmamap_t
name|dmamap
decl_stmt|;
name|buf
operator|=
name|get_bktr_mem
argument_list|(
name|bktr
argument_list|,
operator|&
name|dmamap
argument_list|,
name|temp
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|0
condition|)
block|{
name|free_bktr_mem
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|dm_mem
argument_list|,
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|dm_mem
operator|=
name|dmamap
expr_stmt|;
else|#
directive|else
name|buf
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|temp
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|bktr
operator|->
name|bigbuf
argument_list|,
operator|(
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bktr
operator|->
name|bigbuf
operator|=
name|buf
expr_stmt|;
name|bktr
operator|->
name|alloc_pages
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: ioctl: Allocating %d bytes\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|temp
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|bktr
operator|->
name|rows
operator|=
name|geo
operator|->
name|rows
expr_stmt|;
name|bktr
operator|->
name|cols
operator|=
name|geo
operator|->
name|columns
expr_stmt|;
name|bktr
operator|->
name|frames
operator|=
name|geo
operator|->
name|frames
expr_stmt|;
comment|/*  Pixel format (if in meteor pixfmt compatibility mode)  */
if|if
condition|(
name|bktr
operator|->
name|pixfmt_compat
condition|)
block|{
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_422
expr_stmt|;
switch|switch
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_OUTPUT_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_GEO_RGB16
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB16
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_RGB24
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB24
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_YUV_422
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_422
expr_stmt|;
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_YUV_12
condition|)
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_12
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_YUV_PACKED
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_PACKED
expr_stmt|;
break|break;
block|}
name|bktr
operator|->
name|pixfmt
operator|=
name|oformat_meteor_to_bt
argument_list|(
name|bktr
operator|->
name|format
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_CONTIN
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|)
argument_list|)
expr_stmt|;
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|FIFO_ENABLED
argument_list|)
expr_stmt|;
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|bktr
operator|->
name|capcontrol
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|,
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* end of METEORSETGEO */
comment|/* FIXME. The Capture Area currently has the following restrictions: 	GENERAL 	 y_offset may need to be even in interlaced modes 	RGB24 - Interlaced mode 	 x_size must be greater than or equal to 1.666*METEORSETGEO width (cols) 	 y_size must be greater than or equal to METEORSETGEO height (rows) 	RGB24 - Even Only (or Odd Only) mode 	 x_size must be greater than or equal to 1.666*METEORSETGEO width (cols) 	 y_size must be greater than or equal to 2*METEORSETGEO height (rows) 	YUV12 - Interlaced mode 	 x_size must be greater than or equal to METEORSETGEO width (cols) 	 y_size must be greater than or equal to METEORSETGEO height (rows) 	YUV12 - Even Only (or Odd Only) mode 	 x_size must be greater than or equal to METEORSETGEO width (cols) 	 y_size must be greater than or equal to 2*METEORSETGEO height (rows) 	*/
case|case
name|BT848_SCAPAREA
case|:
comment|/* set capture area of each video frame */
comment|/* can't change parameters while capturing */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|cap_area
operator|=
operator|(
expr|struct
name|bktr_capture_area
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|capture_area_x_offset
operator|=
name|cap_area
operator|->
name|x_offset
expr_stmt|;
name|bktr
operator|->
name|capture_area_y_offset
operator|=
name|cap_area
operator|->
name|y_offset
expr_stmt|;
name|bktr
operator|->
name|capture_area_x_size
operator|=
name|cap_area
operator|->
name|x_size
expr_stmt|;
name|bktr
operator|->
name|capture_area_y_size
operator|=
name|cap_area
operator|->
name|y_size
expr_stmt|;
name|bktr
operator|->
name|capture_area_enabled
operator|=
name|TRUE
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|BT848_GCAPAREA
case|:
comment|/* get capture area of each video frame */
name|cap_area
operator|=
operator|(
expr|struct
name|bktr_capture_area
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|capture_area_enabled
operator|==
name|FALSE
condition|)
block|{
name|cap_area
operator|->
name|x_offset
operator|=
literal|0
expr_stmt|;
name|cap_area
operator|->
name|y_offset
operator|=
literal|0
expr_stmt|;
name|cap_area
operator|->
name|x_size
operator|=
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|scaled_hactive
expr_stmt|;
name|cap_area
operator|->
name|y_size
operator|=
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|vactive
expr_stmt|;
block|}
else|else
block|{
name|cap_area
operator|->
name|x_offset
operator|=
name|bktr
operator|->
name|capture_area_x_offset
expr_stmt|;
name|cap_area
operator|->
name|y_offset
operator|=
name|bktr
operator|->
name|capture_area_y_offset
expr_stmt|;
name|cap_area
operator|->
name|x_size
operator|=
name|bktr
operator|->
name|capture_area_x_size
expr_stmt|;
name|cap_area
operator|->
name|y_size
operator|=
name|bktr
operator|->
name|capture_area_y_size
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|common_ioctl
argument_list|(
name|bktr
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * tuner ioctls  */
name|int
name|tuner_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|ioctl_cmd_t
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
name|int
name|tmp_int
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|,
name|temp1
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|u_long
name|par
decl_stmt|;
name|u_char
name|write
decl_stmt|;
name|int
name|i2c_addr
decl_stmt|;
name|int
name|i2c_port
decl_stmt|;
name|u_long
name|data
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|REMOTE_GETKEY
case|:
comment|/* Read the last key pressed by the Remote Control */
if|if
condition|(
name|bktr
operator|->
name|remote_control
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|remote_read
argument_list|(
name|bktr
argument_list|,
operator|(
expr|struct
name|bktr_remote
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
case|case
name|TVTUNER_SETAFC
case|:
name|bktr
operator|->
name|tuner
operator|.
name|afc
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETAFC
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|afc
expr_stmt|;
comment|/* XXX Perhaps use another bit to indicate AFC success? */
break|break;
endif|#
directive|endif
comment|/* TUNER_AFC */
case|case
name|TVTUNER_SETCHNL
case|:
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|temp
operator|=
name|tv_channel
argument_list|(
name|bktr
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
comment|/* after every channel change, we must restart the MSP34xx */
comment|/* audio chip to reselect NICAM STEREO or MONO audio */
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|msp3400c
condition|)
name|msp_autodetect
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
comment|/* after every channel change, we must restart the DPL35xx */
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|dpl3518a
condition|)
name|dpl_autodetect
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETCHNL
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|channel
expr_stmt|;
break|break;
case|case
name|TVTUNER_SETTYPE
case|:
name|temp
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|<
name|CHNLSET_MIN
operator|)
operator|||
operator|(
name|temp
operator|>
name|CHNLSET_MAX
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bktr
operator|->
name|tuner
operator|.
name|chnlset
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETTYPE
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|chnlset
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETSTATUS
case|:
name|temp
operator|=
name|get_tuner_status
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|TVTUNER_SETFREQ
case|:
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|temp
operator|=
name|tv_freq
argument_list|(
name|bktr
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
argument_list|,
name|TV_FREQUENCY
argument_list|)
expr_stmt|;
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
comment|/* after every channel change, we must restart the MSP34xx */
comment|/* audio chip to reselect NICAM STEREO or MONO audio */
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|msp3400c
condition|)
name|msp_autodetect
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
comment|/* after every channel change, we must restart the DPL35xx */
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|dpl3518a
condition|)
name|dpl_autodetect
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETFREQ
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|frequency
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETCHNLSET
case|:
return|return
name|tuner_getchnlset
argument_list|(
operator|(
expr|struct
name|bktr_chnlset
operator|*
operator|)
name|arg
argument_list|)
return|;
case|case
name|BT848_SAUDIO
case|:
comment|/* set audio channel */
if|if
condition|(
name|set_audio
argument_list|(
name|bktr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
comment|/* hue is a 2's compliment number, -90' to +89.3' in 0.7' steps */
case|case
name|BT848_SHUE
case|:
comment|/* set hue */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_HUE
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GHUE
case|:
comment|/* get hue */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_HUE
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
comment|/* brightness is a 2's compliment #, -50 to +%49.6% in 0.39% steps */
case|case
name|BT848_SBRIG
case|:
comment|/* set brightness */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_BRIGHT
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GBRIG
case|:
comment|/* get brightness */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_BRIGHT
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SCSAT
case|:
comment|/* set chroma saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
name|BIT_EIGHT_HIGH
condition|)
block|{
name|temp
operator||=
operator|(
name|BT848_E_CONTROL_SAT_U_MSB
operator||
name|BT848_E_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
name|temp1
operator||=
operator|(
name|BT848_O_CONTROL_SAT_U_MSB
operator||
name|BT848_O_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
operator|(
name|BT848_E_CONTROL_SAT_U_MSB
operator||
name|BT848_E_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
name|temp1
operator|&=
operator|~
operator|(
name|BT848_O_CONTROL_SAT_U_MSB
operator||
name|BT848_O_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
block|}
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_SAT_U_LO
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_SAT_V_LO
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GCSAT
case|:
comment|/* get chroma saturation */
name|tmp_int
operator|=
call|(
name|int
call|)
argument_list|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_SAT_V_LO
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator|&
name|BT848_E_CONTROL_SAT_V_MSB
condition|)
name|tmp_int
operator||=
name|BIT_EIGHT_HIGH
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SVSAT
case|:
comment|/* set chroma V saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
name|BIT_EIGHT_HIGH
condition|)
block|{
name|temp
operator||=
name|BT848_E_CONTROL_SAT_V_MSB
expr_stmt|;
name|temp1
operator||=
name|BT848_O_CONTROL_SAT_V_MSB
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|BT848_E_CONTROL_SAT_V_MSB
expr_stmt|;
name|temp1
operator|&=
operator|~
name|BT848_O_CONTROL_SAT_V_MSB
expr_stmt|;
block|}
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_SAT_V_LO
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GVSAT
case|:
comment|/* get chroma V saturation */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_SAT_V_LO
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator|&
name|BT848_E_CONTROL_SAT_V_MSB
condition|)
name|tmp_int
operator||=
name|BIT_EIGHT_HIGH
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SUSAT
case|:
comment|/* set chroma U saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
name|BIT_EIGHT_HIGH
condition|)
block|{
name|temp
operator||=
name|BT848_E_CONTROL_SAT_U_MSB
expr_stmt|;
name|temp1
operator||=
name|BT848_O_CONTROL_SAT_U_MSB
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|BT848_E_CONTROL_SAT_U_MSB
expr_stmt|;
name|temp1
operator|&=
operator|~
name|BT848_O_CONTROL_SAT_U_MSB
expr_stmt|;
block|}
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_SAT_U_LO
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GUSAT
case|:
comment|/* get chroma U saturation */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_SAT_U_LO
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator|&
name|BT848_E_CONTROL_SAT_U_MSB
condition|)
name|tmp_int
operator||=
name|BIT_EIGHT_HIGH
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/* lr 970528 luma notch etc - 3 high bits of e_control/o_control */
case|case
name|BT848_SLNOTCH
case|:
comment|/* set luma notch */
name|tmp_int
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0x7
operator|)
operator|<<
literal|5
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator|&
operator|~
literal|0xe0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
operator|&
operator|~
literal|0xe0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator||
name|tmp_int
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
operator||
name|tmp_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GLNOTCH
case|:
comment|/* get luma notch */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
argument_list|)
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SCONT
case|:
comment|/* set contrast */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
name|BIT_EIGHT_HIGH
condition|)
block|{
name|temp
operator||=
name|BT848_E_CONTROL_CON_MSB
expr_stmt|;
name|temp1
operator||=
name|BT848_O_CONTROL_CON_MSB
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|BT848_E_CONTROL_CON_MSB
expr_stmt|;
name|temp1
operator|&=
operator|~
name|BT848_O_CONTROL_CON_MSB
expr_stmt|;
block|}
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_CONTRAST_LO
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GCONT
case|:
comment|/* get contrast */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_CONTRAST_LO
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator|&
name|BT848_E_CONTROL_CON_MSB
condition|)
name|tmp_int
operator||=
name|BIT_EIGHT_HIGH
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  FIXME:  SCBARS and CCBARS require a valid int *        */
comment|/*    argument to succeed, but its not used; consider      */
comment|/*    using the arg to store the on/off state so           */
comment|/*    there's only one ioctl() needed to turn cbars on/off */
case|case
name|BT848_SCBARS
case|:
comment|/* set colorbar output */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|)
operator||
name|BT848_COLOR_CTL_COLOR_BARS
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_CCBARS
case|:
comment|/* clear colorbar output */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|)
operator|&
operator|~
operator|(
name|BT848_COLOR_CTL_COLOR_BARS
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GAUDIO
case|:
comment|/* get audio channel */
name|temp
operator|=
name|bktr
operator|->
name|audio_mux_select
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|audio_mute_state
operator|==
name|TRUE
condition|)
name|temp
operator||=
name|AUDIO_MUTE
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|BT848_SBTSC
case|:
comment|/* set audio channel */
if|if
condition|(
name|set_BTSC
argument_list|(
name|bktr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
case|case
name|BT848_WEEPROM
case|:
comment|/* write eeprom */
name|offset
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|offset
operator|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
operator|)
expr_stmt|;
name|buf
operator|=
operator|&
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|writeEEProm
argument_list|(
name|bktr
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
case|case
name|BT848_REEPROM
case|:
comment|/* read eeprom */
name|offset
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|offset
operator|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
operator|)
expr_stmt|;
name|buf
operator|=
operator|&
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|readEEProm
argument_list|(
name|bktr
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
case|case
name|BT848_SIGNATURE
case|:
name|offset
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|offset
operator|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
operator|)
expr_stmt|;
name|buf
operator|=
operator|&
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|signCard
argument_list|(
name|bktr
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
comment|/* Ioctl's for direct gpio access */
ifdef|#
directive|ifdef
name|BKTR_GPIO_ACCESS
case|case
name|BT848_GPIO_GET_EN
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_OUT_EN
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GPIO_SET_EN
case|:
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_OUT_EN
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GPIO_GET_DATA
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GPIO_SET_DATA
case|:
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DATA
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* BKTR_GPIO_ACCESS */
comment|/* Ioctl's for running the tuner device in radio mode		*/
case|case
name|RADIO_GETMODE
case|:
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|radio_mode
expr_stmt|;
break|break;
case|case
name|RADIO_SETMODE
case|:
name|bktr
operator|->
name|tuner
operator|.
name|radio_mode
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|arg
expr_stmt|;
break|break;
case|case
name|RADIO_GETFREQ
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|frequency
expr_stmt|;
break|break;
case|case
name|RADIO_SETFREQ
case|:
comment|/* The argument to this ioctl is NOT freq*16. It is 	    ** freq*100. 	    */
name|temp
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
expr_stmt|;
ifdef|#
directive|ifdef
name|BKTR_RADIO_DEBUG
name|printf
argument_list|(
literal|"%s: arg=%d temp=%d\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BKTR_RADIO_NOFREQCHECK
comment|/* According to the spec. sheet the band: 87.5MHz-108MHz	*/
comment|/* is supported.						*/
if|if
condition|(
name|temp
operator|<
literal|8750
operator|||
name|temp
operator|>
literal|10800
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Radio frequency out of range\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
endif|#
directive|endif
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|temp
operator|=
name|tv_freq
argument_list|(
name|bktr
argument_list|,
name|temp
argument_list|,
name|FM_RADIO_FREQUENCY
argument_list|)
expr_stmt|;
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BKTR_RADIO_DEBUG
if|if
condition|(
name|temp
condition|)
name|printf
argument_list|(
literal|"%s: tv_freq returned: %d\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
comment|/* Luigi's I2CWR ioctl */
case|case
name|BT848_I2CWR
case|:
name|par
operator|=
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
expr_stmt|;
name|write
operator|=
operator|(
name|par
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|i2c_addr
operator|=
operator|(
name|par
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|i2c_port
operator|=
operator|(
name|par
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|data
operator|=
operator|(
name|par
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|i2c_addr
argument_list|,
name|i2c_port
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|i2c_addr
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
operator|(
name|par
operator|&
literal|0xffffff00
operator|)
operator||
operator|(
name|data
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BT848_MSP_READ
comment|/* I2C ioctls to allow userland access to the MSP chip */
case|case
name|BT848_MSP_READ
case|:
block|{
name|struct
name|bktr_msp_control
modifier|*
name|msp
decl_stmt|;
name|msp
operator|=
operator|(
expr|struct
name|bktr_msp_control
operator|*
operator|)
name|arg
expr_stmt|;
name|msp
operator|->
name|data
operator|=
name|msp_dpl_read
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|msp_addr
argument_list|,
name|msp
operator|->
name|function
argument_list|,
name|msp
operator|->
name|address
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BT848_MSP_WRITE
case|:
block|{
name|struct
name|bktr_msp_control
modifier|*
name|msp
decl_stmt|;
name|msp
operator|=
operator|(
expr|struct
name|bktr_msp_control
operator|*
operator|)
name|arg
expr_stmt|;
name|msp_dpl_write
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|msp_addr
argument_list|,
name|msp
operator|->
name|function
argument_list|,
name|msp
operator|->
name|address
argument_list|,
name|msp
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BT848_MSP_RESET
case|:
name|msp_dpl_reset
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|msp_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
name|common_ioctl
argument_list|(
name|bktr
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * common ioctls  */
name|int
name|common_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|ioctl_cmd_t
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|int
name|pixfmt
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|;
name|struct
name|meteor_pixfmt
modifier|*
name|pf_pub
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|METEORSINPUT
case|:
comment|/* set input device */
comment|/*Bt848 has 3 MUX Inputs. Bt848A/849A/878/879 has 4 MUX Inputs*/
comment|/* On the original bt848 boards, */
comment|/*   Tuner is MUX0, RCA is MUX1, S-Video is MUX2 */
comment|/* On the Hauppauge bt878 boards, */
comment|/*   Tuner is MUX0, RCA is MUX3 */
comment|/* Unfortunatly Meteor driver codes DEV_RCA as DEV_0, so we */
comment|/* stick with this system in our Meteor Emulation */
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|METEOR_DEV_MASK
condition|)
block|{
comment|/* this is the RCA video input */
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_INPUT_DEV0
case|:
comment|/* METEOR_INPUT_DEV_RCA: */
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV0
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator|&
operator|~
name|BT848_IFORM_MUXSEL
argument_list|)
expr_stmt|;
comment|/* work around for new Hauppauge 878 cards */
if|if
condition|(
operator|(
name|bktr
operator|->
name|card
operator|.
name|card_id
operator|==
name|CARD_HAUPPAUGE
operator|)
operator|&&
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_878
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_879
operator|)
condition|)
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator||
name|BT848_IFORM_M_MUX3
argument_list|)
expr_stmt|;
else|else
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator||
name|BT848_IFORM_M_MUX1
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator|&
operator|~
name|BT848_E_CONTROL_COMP
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
operator|&
operator|~
name|BT848_O_CONTROL_COMP
argument_list|)
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_EXTERN
argument_list|)
expr_stmt|;
break|break;
comment|/* this is the tuner input */
case|case
name|METEOR_INPUT_DEV1
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV1
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator|&
operator|~
name|BT848_IFORM_MUXSEL
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator||
name|BT848_IFORM_M_MUX0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator|&
operator|~
name|BT848_E_CONTROL_COMP
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
operator|&
operator|~
name|BT848_O_CONTROL_COMP
argument_list|)
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_TUNER
argument_list|)
expr_stmt|;
break|break;
comment|/* this is the S-VHS input, but with a composite camera */
case|case
name|METEOR_INPUT_DEV2
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV2
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator|&
operator|~
name|BT848_IFORM_MUXSEL
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator||
name|BT848_IFORM_M_MUX2
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator|&
operator|~
name|BT848_E_CONTROL_COMP
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator|&
operator|~
name|BT848_O_CONTROL_COMP
argument_list|)
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_EXTERN
argument_list|)
expr_stmt|;
break|break;
comment|/* this is the S-VHS input */
case|case
name|METEOR_INPUT_DEV_SVIDEO
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV_SVIDEO
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator|&
operator|~
name|BT848_IFORM_MUXSEL
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator||
name|BT848_IFORM_M_MUX2
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator||
name|BT848_E_CONTROL_COMP
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
operator||
name|BT848_O_CONTROL_COMP
argument_list|)
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_EXTERN
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_INPUT_DEV3
case|:
if|if
condition|(
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848A
operator|)
operator|||
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_849A
operator|)
operator|||
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_878
operator|)
operator|||
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_879
operator|)
condition|)
block|{
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV3
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator|&
operator|~
name|BT848_IFORM_MUXSEL
argument_list|)
expr_stmt|;
comment|/* work around for new Hauppauge 878 cards */
if|if
condition|(
operator|(
name|bktr
operator|->
name|card
operator|.
name|card_id
operator|==
name|CARD_HAUPPAUGE
operator|)
operator|&&
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_878
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_879
operator|)
condition|)
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator||
name|BT848_IFORM_M_MUX1
argument_list|)
expr_stmt|;
else|else
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_IFORM
argument_list|)
operator||
name|BT848_IFORM_M_MUX3
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator|&
operator|~
name|BT848_E_CONTROL_COMP
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
operator|&
operator|~
name|BT848_O_CONTROL_COMP
argument_list|)
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_EXTERN
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
name|METEORGINPUT
case|:
comment|/* get input device */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|flags
operator|&
name|METEOR_DEV_MASK
expr_stmt|;
break|break;
case|case
name|METEORSACTPIXFMT
case|:
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|<
literal|0
operator|)
operator|||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|>=
name|PIXFMT_TABLE_SIZE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bktr
operator|->
name|pixfmt
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|,
operator|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|)
operator|&
literal|0xf0
operator|)
operator||
name|pixfmt_swap_flags
argument_list|(
name|bktr
operator|->
name|pixfmt
argument_list|)
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|pixfmt_compat
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|METEORGACTPIXFMT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|pixfmt
expr_stmt|;
break|break;
case|case
name|METEORGSUPPIXFMT
case|:
name|pf_pub
operator|=
operator|(
expr|struct
name|meteor_pixfmt
operator|*
operator|)
name|arg
expr_stmt|;
name|pixfmt
operator|=
name|pf_pub
operator|->
name|index
expr_stmt|;
if|if
condition|(
operator|(
name|pixfmt
operator|<
literal|0
operator|)
operator|||
operator|(
name|pixfmt
operator|>=
name|PIXFMT_TABLE_SIZE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|pf_pub
argument_list|,
operator|&
name|pixfmt_table
index|[
name|pixfmt
index|]
operator|.
name|public
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pf_pub
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Patch in our format index  */
name|pf_pub
operator|->
name|index
operator|=
name|pixfmt
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|STATUS_SUM
argument_list|)
case|case
name|BT848_GSTATUS
case|:
comment|/* reap status */
block|{
name|DECLARE_INTR_MASK
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|temp
operator|=
name|status_sum
expr_stmt|;
name|status_sum
operator|=
literal|0
expr_stmt|;
name|ENABLE_INTR
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* STATUS_SUM */
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/******************************************************************************  * bt848 RISC programming routines:  */
comment|/*  *   */
ifdef|#
directive|ifdef
name|BT848_DEBUG
specifier|static
name|int
name|dump_bt848
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|int
name|r
index|[
literal|60
index|]
init|=
block|{
literal|4
block|,
literal|8
block|,
literal|0xc
block|,
literal|0x8c
block|,
literal|0x10
block|,
literal|0x90
block|,
literal|0x14
block|,
literal|0x94
block|,
literal|0x18
block|,
literal|0x98
block|,
literal|0x1c
block|,
literal|0x9c
block|,
literal|0x20
block|,
literal|0xa0
block|,
literal|0x24
block|,
literal|0xa4
block|,
literal|0x28
block|,
literal|0x2c
block|,
literal|0xac
block|,
literal|0x30
block|,
literal|0x34
block|,
literal|0x38
block|,
literal|0x3c
block|,
literal|0x40
block|,
literal|0xc0
block|,
literal|0x48
block|,
literal|0x4c
block|,
literal|0xcc
block|,
literal|0x50
block|,
literal|0xd0
block|,
literal|0xd4
block|,
literal|0x60
block|,
literal|0x64
block|,
literal|0x68
block|,
literal|0x6c
block|,
literal|0xec
block|,
literal|0xd8
block|,
literal|0xdc
block|,
literal|0xe0
block|,
literal|0xe4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|40
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|printf
argument_list|(
literal|"%s: Reg:value : \t%x:%x \t%x:%x \t %x:%x \t %x:%x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|r
index|[
name|i
index|]
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|r
index|[
name|i
index|]
argument_list|)
argument_list|,
name|r
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|r
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
argument_list|,
name|r
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|r
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
argument_list|,
name|r
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|r
index|[
name|i
operator|+
literal|3
index|]
expr|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: INT STAT %x \n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Reg INT_MASK %x \n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Reg GPIO_DMA_CTL %x \n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|INW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/*  * build write instruction  */
define|#
directive|define
name|BKTR_FM1
value|0x6
comment|/* packed data to follow */
define|#
directive|define
name|BKTR_FM3
value|0xe
comment|/* planar data to follow */
define|#
directive|define
name|BKTR_VRE
value|0x4
comment|/* Marks the end of the even field */
define|#
directive|define
name|BKTR_VRO
value|0xC
comment|/* Marks the end of the odd field */
define|#
directive|define
name|BKTR_PXV
value|0x0
comment|/* valid word (never used) */
define|#
directive|define
name|BKTR_EOL
value|0x1
comment|/* last dword, 4 bytes */
define|#
directive|define
name|BKTR_SOL
value|0x2
comment|/* first dword */
define|#
directive|define
name|OP_WRITE
value|(0x1<< 28)
define|#
directive|define
name|OP_SKIP
value|(0x2<< 28)
define|#
directive|define
name|OP_WRITEC
value|(0x5<< 28)
define|#
directive|define
name|OP_JUMP
value|(0x7<< 28)
define|#
directive|define
name|OP_SYNC
value|(0x8<< 28)
define|#
directive|define
name|OP_WRITE123
value|(0x9<< 28)
define|#
directive|define
name|OP_WRITES123
value|(0xb<< 28)
define|#
directive|define
name|OP_SOL
value|(1<< 27)
comment|/* first instr for scanline */
define|#
directive|define
name|OP_EOL
value|(1<< 26)
define|#
directive|define
name|BKTR_RESYNC
value|(1<< 15)
define|#
directive|define
name|BKTR_GEN_IRQ
value|(1<< 24)
comment|/*  * The RISC status bits can be set/cleared in the RISC programs  * and tested in the Interrupt Handler  */
define|#
directive|define
name|BKTR_SET_RISC_STATUS_BIT0
value|(1<< 16)
define|#
directive|define
name|BKTR_SET_RISC_STATUS_BIT1
value|(1<< 17)
define|#
directive|define
name|BKTR_SET_RISC_STATUS_BIT2
value|(1<< 18)
define|#
directive|define
name|BKTR_SET_RISC_STATUS_BIT3
value|(1<< 19)
define|#
directive|define
name|BKTR_CLEAR_RISC_STATUS_BIT0
value|(1<< 20)
define|#
directive|define
name|BKTR_CLEAR_RISC_STATUS_BIT1
value|(1<< 21)
define|#
directive|define
name|BKTR_CLEAR_RISC_STATUS_BIT2
value|(1<< 22)
define|#
directive|define
name|BKTR_CLEAR_RISC_STATUS_BIT3
value|(1<< 23)
define|#
directive|define
name|BKTR_TEST_RISC_STATUS_BIT0
value|(1<< 28)
define|#
directive|define
name|BKTR_TEST_RISC_STATUS_BIT1
value|(1<< 29)
define|#
directive|define
name|BKTR_TEST_RISC_STATUS_BIT2
value|(1<< 30)
define|#
directive|define
name|BKTR_TEST_RISC_STATUS_BIT3
value|(1<< 31)
name|bool_t
name|notclipped
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bktr_clip_t
modifier|*
name|clip_node
decl_stmt|;
name|bktr
operator|->
name|clip_start
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|last_y
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|y
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|y2
operator|=
name|width
expr_stmt|;
name|bktr
operator|->
name|line_length
operator|=
name|width
expr_stmt|;
name|bktr
operator|->
name|yclip
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|yclip2
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|current_col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|max_clip_node
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|clip_node
operator|=
operator|(
name|bktr_clip_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|clip_list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bktr
operator|->
name|max_clip_node
condition|;
name|i
operator|++
control|)
block|{
name|clip_node
operator|=
operator|(
name|bktr_clip_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|clip_node
operator|->
name|x_min
operator|&&
name|x
operator|<=
name|clip_node
operator|->
name|x_max
condition|)
block|{
name|bktr
operator|->
name|clip_start
operator|=
name|i
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
name|bool_t
name|getline
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bktr_clip_t
modifier|*
name|clip_node
decl_stmt|;
if|if
condition|(
name|bktr
operator|->
name|line_length
operator|==
literal|0
operator|||
name|bktr
operator|->
name|current_col
operator|>=
name|bktr
operator|->
name|line_length
condition|)
return|return
name|FALSE
return|;
name|bktr
operator|->
name|y
operator|=
name|min
argument_list|(
name|bktr
operator|->
name|last_y
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|y2
operator|=
name|bktr
operator|->
name|line_length
expr_stmt|;
name|bktr
operator|->
name|yclip
operator|=
name|bktr
operator|->
name|yclip2
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bktr
operator|->
name|clip_start
init|;
name|i
operator|<
name|bktr
operator|->
name|max_clip_node
condition|;
name|i
operator|++
control|)
block|{
name|clip_node
operator|=
operator|(
name|bktr_clip_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|clip_node
operator|->
name|x_min
operator|&&
name|x
operator|<=
name|clip_node
operator|->
name|x_max
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|last_y
operator|<=
name|clip_node
operator|->
name|y_min
condition|)
block|{
name|bktr
operator|->
name|y
operator|=
name|min
argument_list|(
name|bktr
operator|->
name|last_y
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|y2
operator|=
name|min
argument_list|(
name|clip_node
operator|->
name|y_min
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|yclip
operator|=
name|min
argument_list|(
name|clip_node
operator|->
name|y_min
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|yclip2
operator|=
name|min
argument_list|(
name|clip_node
operator|->
name|y_max
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|last_y
operator|=
name|bktr
operator|->
name|yclip2
expr_stmt|;
name|bktr
operator|->
name|clip_start
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|bktr
operator|->
name|max_clip_node
condition|;
name|j
operator|++
control|)
block|{
name|clip_node
operator|=
operator|(
name|bktr_clip_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|clip_list
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|clip_node
operator|->
name|x_min
operator|&&
name|x
operator|<=
name|clip_node
operator|->
name|x_max
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|last_y
operator|>=
name|clip_node
operator|->
name|y_min
condition|)
block|{
name|bktr
operator|->
name|yclip2
operator|=
name|min
argument_list|(
name|clip_node
operator|->
name|y_max
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|last_y
operator|=
name|bktr
operator|->
name|yclip2
expr_stmt|;
name|bktr
operator|->
name|clip_start
operator|=
name|j
expr_stmt|;
block|}
block|}
else|else
break|break  ;
block|}
return|return
name|TRUE
return|;
block|}
block|}
block|}
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|<=
name|bktr
operator|->
name|line_length
condition|)
block|{
name|bktr
operator|->
name|current_col
operator|=
name|bktr
operator|->
name|line_length
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
specifier|static
name|bool_t
name|split
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
specifier|volatile
name|u_long
modifier|*
modifier|*
name|dma_prog
parameter_list|,
name|int
name|width
parameter_list|,
name|u_long
name|operation
parameter_list|,
name|int
name|pixel_width
parameter_list|,
specifier|volatile
name|u_char
modifier|*
modifier|*
name|target_buffer
parameter_list|,
name|int
name|cols
parameter_list|)
block|{
name|u_long
name|flag
decl_stmt|,
name|flag2
decl_stmt|;
name|struct
name|meteor_pixfmt
modifier|*
name|pf
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
operator|.
name|public
decl_stmt|;
name|u_int
name|skip
decl_stmt|,
name|start_skip
decl_stmt|;
comment|/*  For RGB24, we need to align the component in FIFO Byte Lane 0         */
comment|/*    to the 1st byte in the mem dword containing our start addr.         */
comment|/*    BTW, we know this pixfmt's 1st byte is Blue; thus the start addr    */
comment|/*     must be Blue.                                                      */
name|start_skip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|type
operator|==
name|METEOR_PIXTYPE_RGB
operator|)
operator|&&
operator|(
name|pf
operator|->
name|Bpp
operator|==
literal|3
operator|)
condition|)
switch|switch
condition|(
operator|(
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
operator|*
name|target_buffer
operator|)
operator|%
literal|4
condition|)
block|{
case|case
literal|2
case|:
name|start_skip
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|start_skip
operator|=
literal|8
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|width
operator|*
name|pixel_width
operator|)
operator|<
name|DMA_BT848_SPLIT
condition|)
block|{
if|if
condition|(
name|width
operator|==
name|cols
condition|)
block|{
name|flag
operator|=
name|OP_SOL
operator||
name|OP_EOL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|==
literal|0
condition|)
block|{
name|flag
operator|=
name|OP_SOL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|==
name|cols
condition|)
block|{
name|flag
operator|=
name|OP_EOL
expr_stmt|;
block|}
else|else
name|flag
operator|=
literal|0
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|OP_SOL
operator|)
operator|&&
operator|(
name|start_skip
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
name|OP_SKIP
operator||
name|OP_SOL
operator||
name|start_skip
expr_stmt|;
name|flag
operator|&=
operator|~
name|OP_SOL
expr_stmt|;
name|skip
operator|=
name|start_skip
expr_stmt|;
block|}
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
name|operation
operator||
name|flag
operator||
operator|(
name|width
operator|*
name|pixel_width
operator|-
name|skip
operator|)
expr_stmt|;
if|if
condition|(
name|operation
operator|!=
name|OP_SKIP
condition|)
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
operator|*
name|target_buffer
expr_stmt|;
operator|*
name|target_buffer
operator|+=
name|width
operator|*
name|pixel_width
expr_stmt|;
name|bktr
operator|->
name|current_col
operator|+=
name|width
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|==
literal|0
operator|&&
name|width
operator|==
name|cols
condition|)
block|{
name|flag
operator|=
name|OP_SOL
expr_stmt|;
name|flag2
operator|=
name|OP_EOL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|==
literal|0
condition|)
block|{
name|flag
operator|=
name|OP_SOL
expr_stmt|;
name|flag2
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|>=
name|cols
condition|)
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|flag2
operator|=
name|OP_EOL
expr_stmt|;
block|}
else|else
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|flag2
operator|=
literal|0
expr_stmt|;
block|}
name|skip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|OP_SOL
operator|)
operator|&&
operator|(
name|start_skip
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
name|OP_SKIP
operator||
name|OP_SOL
operator||
name|start_skip
expr_stmt|;
name|flag
operator|&=
operator|~
name|OP_SOL
expr_stmt|;
name|skip
operator|=
name|start_skip
expr_stmt|;
block|}
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
name|operation
operator||
name|flag
operator||
operator|(
name|width
operator|*
name|pixel_width
operator|/
literal|2
operator|-
name|skip
operator|)
expr_stmt|;
if|if
condition|(
name|operation
operator|!=
name|OP_SKIP
condition|)
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
operator|*
name|target_buffer
expr_stmt|;
operator|*
name|target_buffer
operator|+=
operator|(
name|width
operator|*
name|pixel_width
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|OP_WRITE
condition|)
name|operation
operator|=
name|OP_WRITEC
expr_stmt|;
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
name|operation
operator||
name|flag2
operator||
operator|(
name|width
operator|*
name|pixel_width
operator|/
literal|2
operator|)
expr_stmt|;
operator|*
name|target_buffer
operator|+=
operator|(
name|width
operator|*
name|pixel_width
operator|/
literal|2
operator|)
expr_stmt|;
name|bktr
operator|->
name|current_col
operator|+=
name|width
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/*  * Generate the RISC instructions to capture both VBI and video images  */
specifier|static
name|void
name|rgb_vbi_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|buffer
decl_stmt|,
name|target
decl_stmt|,
name|width
decl_stmt|;
specifier|volatile
name|u_long
name|pitch
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
comment|/* DMA prog is an array of  						32 bit RISC instructions */
specifier|volatile
name|u_long
modifier|*
name|loop_point
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
decl_stmt|;
name|u_int
name|Bpp
init|=
name|pf_int
operator|->
name|public
operator|.
name|Bpp
decl_stmt|;
name|unsigned
name|int
name|vbisamples
decl_stmt|;
comment|/* VBI samples per line */
name|unsigned
name|int
name|vbilines
decl_stmt|;
comment|/* VBI lines per field */
name|unsigned
name|int
name|num_dwords
decl_stmt|;
comment|/* DWORDS per line */
name|vbisamples
operator|=
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|vbi_num_samples
expr_stmt|;
name|vbilines
operator|=
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|vbi_num_lines
expr_stmt|;
name|num_dwords
operator|=
name|vbisamples
operator|/
literal|4
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_FMT
argument_list|,
name|pf_int
operator|->
name|color_fmt
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_ADC
argument_list|,
name|SYNC_LEVEL
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_VBI_PACK_SIZE
argument_list|,
operator|(
operator|(
name|num_dwords
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_VBI_PACK_DEL
argument_list|,
operator|(
operator|(
name|num_dwords
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0x01
argument_list|)
expr_stmt|;
comment|/* no hdelay    */
comment|/* no ext frame */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_OFORM
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|)
operator||
literal|0x40
argument_list|)
expr_stmt|;
comment|/* set chroma comb */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|)
operator||
literal|0x40
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|)
operator|&
operator|~
literal|0x80
argument_list|)
expr_stmt|;
comment|/* clear Ycomb */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|)
operator|&
operator|~
literal|0x80
argument_list|)
expr_stmt|;
comment|/* disable gamma correction removal */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|)
operator||
name|BT848_COLOR_CTL_GAMMA
argument_list|)
expr_stmt|;
if|if
condition|(
name|cols
operator|>
literal|385
condition|)
block|{
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VTC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VTC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VTC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VTC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|bktr
operator|->
name|capcontrol
operator|=
literal|3
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
comment|/* Construct Write */
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
name|pitch
operator|=
name|bktr
operator|->
name|video
operator|.
name|width
expr_stmt|;
block|}
else|else
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|pitch
operator|=
name|cols
operator|*
name|Bpp
expr_stmt|;
block|}
name|buffer
operator|=
name|target_buffer
expr_stmt|;
comment|/* Wait for the VRE sync marking the end of the Even and 	 * the start of the Odd field. Resync here. 	 */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_RESYNC
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
name|loop_point
operator|=
name|dma_prog
expr_stmt|;
comment|/* store the VBI data */
comment|/* look for sync with packed data */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vbilines
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|OP_WRITE
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
name|vbisamples
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|vbidata
operator|+
operator|(
name|i
operator|*
name|VBI_LINE_SIZE
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i_flag
operator|==
literal|2
comment|/*Odd*/
operator|)
operator|||
operator|(
name|i_flag
operator|==
literal|3
operator|)
comment|/*interlaced*/
condition|)
block|{
comment|/* store the Odd field video image */
comment|/* look for sync with packed data */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|width
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
name|target_buffer
expr_stmt|;
if|if
condition|(
name|notclipped
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|,
name|width
argument_list|)
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|getline
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|y
operator|!=
name|bktr
operator|->
name|y2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|yclip
operator|!=
name|bktr
operator|->
name|yclip2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|yclip2
operator|-
name|bktr
operator|->
name|yclip
argument_list|,
name|OP_SKIP
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|target_buffer
operator|+=
name|interlace
operator|*
name|pitch
expr_stmt|;
block|}
block|}
comment|/* end if */
comment|/* Grab the Even field */
comment|/* Look for the VRO, end of Odd field, marker */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_GEN_IRQ
operator||
name|BKTR_RESYNC
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
comment|/* store the VBI data */
comment|/* look for sync with packed data */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vbilines
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|OP_WRITE
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
name|vbisamples
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|vbidata
operator|+
operator|(
operator|(
name|i
operator|+
name|MAX_VBI_LINES
operator|)
operator|*
name|VBI_LINE_SIZE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* store the video image */
if|if
condition|(
name|i_flag
operator|==
literal|1
condition|)
comment|/*Even Only*/
name|target_buffer
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|i_flag
operator|==
literal|3
condition|)
comment|/*interlaced*/
name|target_buffer
operator|=
name|buffer
operator|+
name|pitch
expr_stmt|;
if|if
condition|(
operator|(
name|i_flag
operator|==
literal|1
operator|)
comment|/*Even Only*/
operator|||
operator|(
name|i_flag
operator|==
literal|3
operator|)
comment|/*interlaced*/
condition|)
block|{
comment|/* look for sync with packed data */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|width
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
name|target_buffer
expr_stmt|;
if|if
condition|(
name|notclipped
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|,
name|width
argument_list|)
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|getline
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|y
operator|!=
name|bktr
operator|->
name|y2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|yclip
operator|!=
name|bktr
operator|->
name|yclip2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|yclip2
operator|-
name|bktr
operator|->
name|yclip
argument_list|,
name|OP_SKIP
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|target_buffer
operator|+=
name|interlace
operator|*
name|pitch
expr_stmt|;
block|}
block|}
comment|/* Look for end of 'Even Field' */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_GEN_IRQ
operator||
name|BKTR_RESYNC
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|loop_point
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
specifier|static
name|void
name|rgb_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|buffer
decl_stmt|,
name|target
decl_stmt|,
name|width
decl_stmt|;
specifier|volatile
name|u_long
name|pitch
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
decl_stmt|;
name|u_int
name|Bpp
init|=
name|pf_int
operator|->
name|public
operator|.
name|Bpp
decl_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_FMT
argument_list|,
name|pf_int
operator|->
name|color_fmt
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_VBI_PACK_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_VBI_PACK_DEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_ADC
argument_list|,
name|SYNC_LEVEL
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_OFORM
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|)
operator||
literal|0x40
argument_list|)
expr_stmt|;
comment|/* set chroma comb */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|)
operator||
literal|0x40
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|)
operator|&
operator|~
literal|0x80
argument_list|)
expr_stmt|;
comment|/* clear Ycomb */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|)
operator|&
operator|~
literal|0x80
argument_list|)
expr_stmt|;
comment|/* disable gamma correction removal */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|)
operator||
name|BT848_COLOR_CTL_GAMMA
argument_list|)
expr_stmt|;
if|if
condition|(
name|cols
operator|>
literal|385
condition|)
block|{
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VTC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VTC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VTC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VTC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|bktr
operator|->
name|capcontrol
operator|=
literal|3
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
comment|/* Construct Write */
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
name|pitch
operator|=
name|bktr
operator|->
name|video
operator|.
name|width
expr_stmt|;
block|}
else|else
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|pitch
operator|=
name|cols
operator|*
name|Bpp
expr_stmt|;
block|}
name|buffer
operator|=
name|target_buffer
expr_stmt|;
comment|/* contruct sync : for video packet format */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_RESYNC
operator||
name|BKTR_FM1
expr_stmt|;
comment|/* sync, mode indicator packed data */
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|width
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
name|target_buffer
expr_stmt|;
if|if
condition|(
name|notclipped
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|,
name|width
argument_list|)
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|getline
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|y
operator|!=
name|bktr
operator|->
name|y2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|yclip
operator|!=
name|bktr
operator|->
name|yclip2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|yclip2
operator|-
name|bktr
operator|->
name|yclip
argument_list|,
name|OP_SKIP
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|target_buffer
operator|+=
name|interlace
operator|*
name|pitch
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_GEN_IRQ
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* sync vro */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_GEN_IRQ
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* sync vro */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_GEN_IRQ
operator||
name|BKTR_RESYNC
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
empty_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|target_buffer
operator|=
name|buffer
operator|+
name|pitch
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
comment|/* sync vre IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_RESYNC
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|width
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
name|target_buffer
expr_stmt|;
if|if
condition|(
name|notclipped
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|,
name|width
argument_list|)
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|getline
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|y
operator|!=
name|bktr
operator|->
name|y2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|yclip
operator|!=
name|bktr
operator|->
name|yclip2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|yclip2
operator|-
name|bktr
operator|->
name|yclip
argument_list|,
name|OP_SKIP
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|target_buffer
operator|+=
name|interlace
operator|*
name|pitch
expr_stmt|;
block|}
block|}
comment|/* sync vre IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_GEN_IRQ
operator||
name|BKTR_RESYNC
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
comment|/*  *   */
specifier|static
name|void
name|yuvpack_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst3
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|buffer
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
decl_stmt|;
name|int
name|b
decl_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_FMT
argument_list|,
name|pf_int
operator|->
name|color_fmt
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_SCLOOP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_SCLOOP
argument_list|)
operator||
name|BT848_E_SCLOOP_CAGC
argument_list|)
expr_stmt|;
comment|/* enable chroma comb */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_SCLOOP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_SCLOOP
argument_list|)
operator||
name|BT848_O_SCLOOP_CAGC
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|)
operator||
name|BT848_COLOR_CTL_RGB_DED
operator||
name|BT848_COLOR_CTL_GAMMA
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_ADC
argument_list|,
name|SYNC_LEVEL
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|3
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
comment|/* Construct Write */
comment|/* write , sol, eol */
name|inst
operator|=
name|OP_WRITE
operator||
name|OP_SOL
operator||
operator|(
name|cols
operator|)
expr_stmt|;
comment|/* write , sol, eol */
name|inst3
operator|=
name|OP_WRITE
operator||
name|OP_EOL
operator||
operator|(
name|cols
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
else|else
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|target_buffer
expr_stmt|;
comment|/* contruct sync : for video packet format */
comment|/* sync, mode indicator packed data */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|b
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
operator|+
name|b
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
operator|(
name|cols
operator|*
literal|2
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* sync vro */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* sync vro */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|buffer
operator|+
name|cols
operator|*
literal|2
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
operator|+
name|b
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
operator|(
name|cols
operator|*
literal|2
operator|)
expr_stmt|;
block|}
block|}
comment|/* sync vro IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
comment|/*  *   */
specifier|static
name|void
name|yuv422_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|t1
decl_stmt|,
name|buffer
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
decl_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_FMT
argument_list|,
name|pf_int
operator|->
name|color_fmt
argument_list|)
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|3
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_ADC
argument_list|,
name|SYNC_LEVEL
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_OFORM
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CONTROL
argument_list|)
operator||
name|BT848_E_CONTROL_LDEC
argument_list|)
expr_stmt|;
comment|/* disable luma decimation */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CONTROL
argument_list|)
operator||
name|BT848_O_CONTROL_LDEC
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_SCLOOP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_SCLOOP
argument_list|)
operator||
name|BT848_E_SCLOOP_CAGC
argument_list|)
expr_stmt|;
comment|/* chroma agc enable */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_SCLOOP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_SCLOOP
argument_list|)
operator||
name|BT848_O_SCLOOP_CAGC
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|)
operator|&
operator|~
literal|0x80
argument_list|)
expr_stmt|;
comment|/* clear Ycomb */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|)
operator|&
operator|~
literal|0x80
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|)
operator||
operator|~
literal|0x40
argument_list|)
expr_stmt|;
comment|/* set chroma comb */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|)
operator||
operator|~
literal|0x40
argument_list|)
expr_stmt|;
comment|/* disable gamma correction removal */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|)
operator||
name|BT848_COLOR_CTL_GAMMA
argument_list|)
expr_stmt|;
comment|/* Construct Write */
name|inst
operator|=
name|OP_WRITE123
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
operator|(
name|cols
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
else|else
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|target_buffer
expr_stmt|;
name|t1
operator|=
name|buffer
expr_stmt|;
comment|/* contruct sync : for video packet format */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM3
expr_stmt|;
comment|/*sync, mode indicator packed data*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
name|cols
operator|/
literal|2
operator|<<
literal|16
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
operator|(
name|cols
operator|*
name|rows
operator|/
literal|2
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
comment|/*sync vre*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRO
expr_stmt|;
comment|/*sync vre*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|buffer
operator|+
name|cols
expr_stmt|;
name|t1
operator|=
name|buffer
operator|+
name|cols
operator|/
literal|2
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
name|cols
operator|/
literal|2
operator|<<
literal|16
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
operator|(
name|cols
operator|*
name|rows
operator|/
literal|2
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
block|}
block|}
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
comment|/*  *   */
specifier|static
name|void
name|yuv12_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst1
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|t1
decl_stmt|,
name|buffer
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
decl_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_FMT
argument_list|,
name|pf_int
operator|->
name|color_fmt
argument_list|)
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|3
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_ADC
argument_list|,
name|SYNC_LEVEL
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_OFORM
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Construct Write */
name|inst
operator|=
name|OP_WRITE123
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
operator|(
name|cols
operator|)
expr_stmt|;
name|inst1
operator|=
name|OP_WRITES123
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
operator|(
name|cols
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
else|else
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|target_buffer
expr_stmt|;
name|t1
operator|=
name|buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM3
expr_stmt|;
comment|/*sync, mode indicator packed data*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
operator|(
name|cols
operator|/
literal|2
operator|<<
literal|16
operator|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
operator|(
name|cols
operator|*
name|rows
operator|/
literal|4
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
operator|(
name|cols
operator|/
literal|2
operator|<<
literal|16
operator|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
comment|/*sync vre*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRO
expr_stmt|;
comment|/*sync vro*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|buffer
operator|+
name|cols
expr_stmt|;
name|t1
operator|=
name|buffer
operator|+
name|cols
operator|/
literal|2
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
name|rows
operator|/
name|interlace
operator|)
operator|/
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
operator|(
name|cols
operator|/
literal|2
operator|<<
literal|16
operator|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
operator|(
name|cols
operator|*
name|rows
operator|/
literal|4
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
operator|(
name|cols
operator|/
literal|2
operator|<<
literal|16
operator|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
block|}
block|}
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
comment|/*  *   */
specifier|static
name|void
name|build_dma_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|)
block|{
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|,
name|interlace
decl_stmt|;
name|int
name|tmp_int
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|;
name|struct
name|format_params
modifier|*
name|fp
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
decl_stmt|;
name|fp
operator|=
operator|&
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_MASK
argument_list|,
name|ALL_INTS_DISABLED
argument_list|)
expr_stmt|;
comment|/* disable FIFO& RISC, leave other bits alone */
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|INW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|)
operator|&
operator|~
name|FIFO_RISC_ENABLED
argument_list|)
expr_stmt|;
comment|/* set video parameters */
if|if
condition|(
name|bktr
operator|->
name|capture_area_enabled
condition|)
name|temp
operator|=
operator|(
operator|(
name|quad_t
operator|)
name|fp
operator|->
name|htotal
operator|*
operator|(
name|quad_t
operator|)
name|bktr
operator|->
name|capture_area_x_size
operator|*
literal|4096
operator|/
name|fp
operator|->
name|scaled_htotal
operator|/
name|bktr
operator|->
name|cols
operator|)
operator|-
literal|4096
expr_stmt|;
else|else
name|temp
operator|=
operator|(
operator|(
name|quad_t
operator|)
name|fp
operator|->
name|htotal
operator|*
operator|(
name|quad_t
operator|)
name|fp
operator|->
name|scaled_hactive
operator|*
literal|4096
operator|/
name|fp
operator|->
name|scaled_htotal
operator|/
name|bktr
operator|->
name|cols
operator|)
operator|-
literal|4096
expr_stmt|;
comment|/* printf("%s: HSCALE value is %d\n", bktr_name(bktr), temp); */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_HSCALE_LO
argument_list|,
name|temp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_HSCALE_LO
argument_list|,
name|temp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_HSCALE_HI
argument_list|,
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_HSCALE_HI
argument_list|,
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* horizontal active */
name|temp
operator|=
name|bktr
operator|->
name|cols
expr_stmt|;
comment|/* printf("%s: HACTIVE value is %d\n", bktr_name(bktr), temp); */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_HACTIVE_LO
argument_list|,
name|temp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_HACTIVE_LO
argument_list|,
name|temp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|)
operator|&
operator|~
literal|0x3
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|)
operator|&
operator|~
literal|0x3
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|)
operator||
operator|(
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0x3
operator|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|)
operator||
operator|(
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0x3
operator|)
argument_list|)
expr_stmt|;
comment|/* horizontal delay */
if|if
condition|(
name|bktr
operator|->
name|capture_area_enabled
condition|)
name|temp
operator|=
operator|(
operator|(
name|fp
operator|->
name|hdelay
operator|*
name|fp
operator|->
name|scaled_hactive
operator|+
name|bktr
operator|->
name|capture_area_x_offset
operator|*
name|fp
operator|->
name|scaled_htotal
operator|)
operator|*
name|bktr
operator|->
name|cols
operator|)
operator|/
operator|(
name|bktr
operator|->
name|capture_area_x_size
operator|*
name|fp
operator|->
name|hactive
operator|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|fp
operator|->
name|hdelay
operator|*
name|bktr
operator|->
name|cols
operator|)
operator|/
name|fp
operator|->
name|hactive
expr_stmt|;
name|temp
operator|=
name|temp
operator|&
literal|0x3fe
expr_stmt|;
comment|/* printf("%s: HDELAY value is %d\n", bktr_name(bktr), temp); */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_DELAY_LO
argument_list|,
name|temp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_DELAY_LO
argument_list|,
name|temp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|)
operator|&
operator|~
literal|0xc
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|)
operator|&
operator|~
literal|0xc
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|)
operator||
operator|(
operator|(
name|temp
operator|>>
literal|6
operator|)
operator|&
literal|0xc
operator|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|)
operator||
operator|(
operator|(
name|temp
operator|>>
literal|6
operator|)
operator|&
literal|0xc
operator|)
argument_list|)
expr_stmt|;
comment|/* vertical scale */
if|if
condition|(
name|bktr
operator|->
name|capture_area_enabled
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_ODD_FIELDS
operator|||
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_EVEN_FIELDS
condition|)
name|tmp_int
operator|=
literal|65536
operator|-
operator|(
operator|(
operator|(
name|bktr
operator|->
name|capture_area_y_size
operator|*
literal|256
operator|+
operator|(
name|bktr
operator|->
name|rows
operator|/
literal|2
operator|)
operator|)
operator|/
name|bktr
operator|->
name|rows
operator|)
operator|-
literal|512
operator|)
expr_stmt|;
else|else
block|{
name|tmp_int
operator|=
literal|65536
operator|-
operator|(
operator|(
operator|(
name|bktr
operator|->
name|capture_area_y_size
operator|*
literal|512
operator|+
operator|(
name|bktr
operator|->
name|rows
operator|/
literal|2
operator|)
operator|)
operator|/
name|bktr
operator|->
name|rows
operator|)
operator|-
literal|512
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_ODD_FIELDS
operator|||
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_EVEN_FIELDS
condition|)
name|tmp_int
operator|=
literal|65536
operator|-
operator|(
operator|(
operator|(
name|fp
operator|->
name|vactive
operator|*
literal|256
operator|+
operator|(
name|bktr
operator|->
name|rows
operator|/
literal|2
operator|)
operator|)
operator|/
name|bktr
operator|->
name|rows
operator|)
operator|-
literal|512
operator|)
expr_stmt|;
else|else
block|{
name|tmp_int
operator|=
literal|65536
operator|-
operator|(
operator|(
operator|(
name|fp
operator|->
name|vactive
operator|*
literal|512
operator|+
operator|(
name|bktr
operator|->
name|rows
operator|/
literal|2
operator|)
operator|)
operator|/
name|bktr
operator|->
name|rows
operator|)
operator|-
literal|512
operator|)
expr_stmt|;
block|}
block|}
name|tmp_int
operator|&=
literal|0x1fff
expr_stmt|;
comment|/* printf("%s: VSCALE value is %d\n", bktr_name(bktr), tmp_int); */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_LO
argument_list|,
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_LO
argument_list|,
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|)
operator|&
operator|~
literal|0x1f
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|)
operator|&
operator|~
literal|0x1f
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|)
operator||
operator|(
operator|(
name|tmp_int
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
operator|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|)
operator||
operator|(
operator|(
name|tmp_int
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
operator|)
argument_list|)
expr_stmt|;
comment|/* vertical active */
if|if
condition|(
name|bktr
operator|->
name|capture_area_enabled
condition|)
name|temp
operator|=
name|bktr
operator|->
name|capture_area_y_size
expr_stmt|;
else|else
name|temp
operator|=
name|fp
operator|->
name|vactive
expr_stmt|;
comment|/* printf("%s: VACTIVE is %d\n", bktr_name(bktr), temp); */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|)
operator|&
operator|~
literal|0x30
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|)
operator||
operator|(
operator|(
name|temp
operator|>>
literal|4
operator|)
operator|&
literal|0x30
operator|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VACTIVE_LO
argument_list|,
name|temp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|)
operator|&
operator|~
literal|0x30
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|)
operator||
operator|(
operator|(
name|temp
operator|>>
literal|4
operator|)
operator|&
literal|0x30
operator|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VACTIVE_LO
argument_list|,
name|temp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* vertical delay */
if|if
condition|(
name|bktr
operator|->
name|capture_area_enabled
condition|)
name|temp
operator|=
name|fp
operator|->
name|vdelay
operator|+
operator|(
name|bktr
operator|->
name|capture_area_y_offset
operator|)
expr_stmt|;
else|else
name|temp
operator|=
name|fp
operator|->
name|vdelay
expr_stmt|;
comment|/* printf("%s: VDELAY is %d\n", bktr_name(bktr), temp); */
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|)
operator|&
operator|~
literal|0xC0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_CROP
argument_list|)
operator||
operator|(
operator|(
name|temp
operator|>>
literal|2
operator|)
operator|&
literal|0xC0
operator|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VDELAY_LO
argument_list|,
name|temp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|)
operator|&
operator|~
literal|0xC0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_CROP
argument_list|)
operator||
operator|(
operator|(
name|temp
operator|>>
literal|2
operator|)
operator|&
literal|0xC0
operator|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VDELAY_LO
argument_list|,
name|temp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* end of video params */
if|if
condition|(
operator|(
name|bktr
operator|->
name|xtal_pll_mode
operator|==
name|BT848_USE_PLL
operator|)
operator|&&
operator|(
name|fp
operator|->
name|iform_xtsel
operator|==
name|BT848_IFORM_X_XT1
operator|)
condition|)
block|{
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_TGCTRL
argument_list|,
name|BT848_TGCTRL_TGCKI_PLL
argument_list|)
expr_stmt|;
comment|/* Select PLL mode */
block|}
else|else
block|{
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_TGCTRL
argument_list|,
name|BT848_TGCTRL_TGCKI_XTAL
argument_list|)
expr_stmt|;
comment|/* Select Normal xtal 0/xtal 1 mode */
block|}
comment|/* capture control */
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
operator|(
name|BT848_CAP_CTL_DITH_FRAME
operator||
name|BT848_CAP_CTL_EVEN
operator|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|)
operator|&
operator|~
literal|0x20
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|)
operator|&
operator|~
literal|0x20
argument_list|)
expr_stmt|;
name|interlace
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
operator|(
name|BT848_CAP_CTL_DITH_FRAME
operator||
name|BT848_CAP_CTL_ODD
operator|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|)
operator|&
operator|~
literal|0x20
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|)
operator|&
operator|~
literal|0x20
argument_list|)
expr_stmt|;
name|interlace
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
operator|(
name|BT848_CAP_CTL_DITH_FRAME
operator||
name|BT848_CAP_CTL_EVEN
operator||
name|BT848_CAP_CTL_ODD
operator|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_E_VSCALE_HI
argument_list|)
operator||
literal|0x20
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|,
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_O_VSCALE_HI
argument_list|)
operator||
literal|0x20
argument_list|)
expr_stmt|;
name|interlace
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_RISC_STRT_ADD
argument_list|,
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
argument_list|)
expr_stmt|;
name|rows
operator|=
name|bktr
operator|->
name|rows
expr_stmt|;
name|cols
operator|=
name|bktr
operator|->
name|cols
expr_stmt|;
name|bktr
operator|->
name|vbiflags
operator|&=
operator|~
name|VBI_CAPTURE
expr_stmt|;
comment|/* default - no vbi capture */
comment|/* RGB Grabs. If /dev/vbi is already open, or we are a PAL/SECAM */
comment|/* user, then use the rgb_vbi RISC program. */
comment|/* Otherwise, use the normal rgb RISC program */
if|if
condition|(
name|pf_int
operator|->
name|public
operator|.
name|type
operator|==
name|METEOR_PIXTYPE_RGB
condition|)
block|{
if|if
condition|(
operator|(
name|bktr
operator|->
name|vbiflags
operator|&
name|VBI_OPEN
operator|)
operator|||
operator|(
name|bktr
operator|->
name|format_params
operator|==
name|BT848_IFORM_F_PALBDGHI
operator|)
operator|||
operator|(
name|bktr
operator|->
name|format_params
operator|==
name|BT848_IFORM_F_SECAM
operator|)
condition|)
block|{
name|bktr
operator|->
name|bktr_cap_ctl
operator||=
name|BT848_CAP_CTL_VBI_EVEN
operator||
name|BT848_CAP_CTL_VBI_ODD
expr_stmt|;
name|bktr
operator|->
name|vbiflags
operator||=
name|VBI_CAPTURE
expr_stmt|;
name|rgb_vbi_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|rgb_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|pf_int
operator|->
name|public
operator|.
name|type
operator|==
name|METEOR_PIXTYPE_YUV
condition|)
block|{
name|yuv422_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|,
operator|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|)
operator|&
literal|0xf0
operator|)
operator||
name|pixfmt_swap_flags
argument_list|(
name|bktr
operator|->
name|pixfmt
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pf_int
operator|->
name|public
operator|.
name|type
operator|==
name|METEOR_PIXTYPE_YUV_PACKED
condition|)
block|{
name|yuvpack_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|,
operator|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|)
operator|&
literal|0xf0
operator|)
operator||
name|pixfmt_swap_flags
argument_list|(
name|bktr
operator|->
name|pixfmt
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pf_int
operator|->
name|public
operator|.
name|type
operator|==
name|METEOR_PIXTYPE_YUV_12
condition|)
block|{
name|yuv12_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|,
operator|(
name|INB
argument_list|(
name|bktr
argument_list|,
name|BKTR_COLOR_CTL
argument_list|)
operator|&
literal|0xf0
operator|)
operator||
name|pixfmt_swap_flags
argument_list|(
name|bktr
operator|->
name|pixfmt
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
comment|/******************************************************************************  * video& video capture specific routines:  */
comment|/*  *   */
specifier|static
name|void
name|start_capture
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|type
parameter_list|)
block|{
name|u_char
name|i_flag
decl_stmt|;
name|struct
name|format_params
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
operator|&
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
expr_stmt|;
comment|/*  If requested, clear out capture buf first  */
if|if
condition|(
name|bktr
operator|->
name|clr_on_start
operator|&&
operator|(
name|bktr
operator|->
name|video
operator|.
name|addr
operator|==
literal|0
operator|)
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|bigbuf
argument_list|,
operator|(
name|size_t
operator|)
name|bktr
operator|->
name|rows
operator|*
name|bktr
operator|->
name|cols
operator|*
name|bktr
operator|->
name|frames
operator|*
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
operator|.
name|public
operator|.
name|Bpp
argument_list|)
expr_stmt|;
block|}
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_DSTATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|,
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|)
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|flags
operator||=
name|type
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_MASK
expr_stmt|;
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
name|i_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
name|i_flag
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
name|i_flag
operator|=
literal|3
expr_stmt|;
break|break;
block|}
comment|/*  TDEC is only valid for continuous captures  */
if|if
condition|(
name|type
operator|==
name|METEOR_SINGLE
condition|)
block|{
name|u_short
name|fps_save
init|=
name|bktr
operator|->
name|fps
decl_stmt|;
name|set_fps
argument_list|(
name|bktr
argument_list|,
name|fp
operator|->
name|frame_rate
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|fps
operator|=
name|fps_save
expr_stmt|;
block|}
else|else
name|set_fps
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|fps
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|dma_prog_loaded
operator|==
name|FALSE
condition|)
block|{
name|build_dma_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|TRUE
expr_stmt|;
block|}
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_RISC_STRT_ADD
argument_list|,
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*  *   */
specifier|static
name|void
name|set_fps
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|u_short
name|fps
parameter_list|)
block|{
name|struct
name|format_params
modifier|*
name|fp
decl_stmt|;
name|int
name|i_flag
decl_stmt|;
name|fp
operator|=
operator|&
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
expr_stmt|;
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
name|i_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
name|i_flag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
name|i_flag
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|OUTW
argument_list|(
name|bktr
argument_list|,
name|BKTR_GPIO_DMA_CTL
argument_list|,
name|FIFO_RISC_DISABLED
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|,
name|ALL_INTS_CLEARED
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|fps
operator|=
name|fps
expr_stmt|;
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_TDEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fps
operator|<
name|fp
operator|->
name|frame_rate
condition|)
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_TDEC
argument_list|,
name|i_flag
operator|*
operator|(
name|fp
operator|->
name|frame_rate
operator|-
name|fps
operator|)
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
else|else
name|OUTB
argument_list|(
name|bktr
argument_list|,
name|BKTR_TDEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*   * Given a pixfmt index, compute the bt848 swap_flags necessary to   *   achieve the specified swapping.  * Note that without bt swapping, 2Bpp and 3Bpp modes are written   *   byte-swapped, and 4Bpp modes are byte and word swapped (see Table 6   *   and read R->L).    * Note also that for 3Bpp, we may additionally need to do some creative   *   SKIPing to align the FIFO bytelines with the target buffer (see split()).  * This is abstracted here: e.g. no swaps = RGBA; byte& short swap = ABGR  *   as one would expect.  */
specifier|static
name|u_int
name|pixfmt_swap_flags
parameter_list|(
name|int
name|pixfmt
parameter_list|)
block|{
name|struct
name|meteor_pixfmt
modifier|*
name|pf
init|=
operator|&
name|pixfmt_table
index|[
name|pixfmt
index|]
operator|.
name|public
decl_stmt|;
name|u_int
name|swapf
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|pf
operator|->
name|Bpp
condition|)
block|{
case|case
literal|2
case|:
name|swapf
operator|=
operator|(
name|pf
operator|->
name|swap_bytes
condition|?
literal|0
else|:
name|BSWAP
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* no swaps supported for 3bpp - makes no sense w/ bt848 */
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|pf
operator|->
name|swap_bytes
condition|)
name|swapf
operator|=
name|pf
operator|->
name|swap_shorts
condition|?
literal|0
else|:
name|WSWAP
expr_stmt|;
else|else
name|swapf
operator|=
name|pf
operator|->
name|swap_shorts
condition|?
name|BSWAP
else|:
operator|(
name|BSWAP
operator||
name|WSWAP
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|swapf
return|;
block|}
comment|/*   * Converts meteor-defined pixel formats (e.g. METEOR_GEO_RGB16) into  *   our pixfmt_table indices.  */
specifier|static
name|int
name|oformat_meteor_to_bt
parameter_list|(
name|u_long
name|format
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|meteor_pixfmt
modifier|*
name|pf1
decl_stmt|,
modifier|*
name|pf2
decl_stmt|;
comment|/*  Find format in compatibility table  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|METEOR_PIXFMT_TABLE_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|meteor_pixfmt_table
index|[
name|i
index|]
operator|.
name|meteor_format
operator|==
name|format
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|METEOR_PIXFMT_TABLE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
name|pf1
operator|=
operator|&
name|meteor_pixfmt_table
index|[
name|i
index|]
operator|.
name|public
expr_stmt|;
comment|/*  Match it with an entry in master pixel format table  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PIXFMT_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|pf2
operator|=
operator|&
name|pixfmt_table
index|[
name|i
index|]
operator|.
name|public
expr_stmt|;
if|if
condition|(
operator|(
name|pf1
operator|->
name|type
operator|==
name|pf2
operator|->
name|type
operator|)
operator|&&
operator|(
name|pf1
operator|->
name|Bpp
operator|==
name|pf2
operator|->
name|Bpp
operator|)
operator|&&
operator|!
name|bcmp
argument_list|(
name|pf1
operator|->
name|masks
argument_list|,
name|pf2
operator|->
name|masks
argument_list|,
sizeof|sizeof
argument_list|(
name|pf1
operator|->
name|masks
argument_list|)
argument_list|)
operator|&&
operator|(
name|pf1
operator|->
name|swap_bytes
operator|==
name|pf2
operator|->
name|swap_bytes
operator|)
operator|&&
operator|(
name|pf1
operator|->
name|swap_shorts
operator|==
name|pf2
operator|->
name|swap_shorts
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|PIXFMT_TABLE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i
return|;
block|}
comment|/******************************************************************************  * i2c primitives:  */
comment|/* */
define|#
directive|define
name|I2CBITTIME
value|(0x5<<4)
comment|/* 5 * 0.48uS */
define|#
directive|define
name|I2CBITTIME_878
value|(1<< 7)
define|#
directive|define
name|I2C_READ
value|0x01
define|#
directive|define
name|I2C_COMMAND
value|(I2CBITTIME |			\ 				 BT848_DATA_CTL_I2CSCL |	\ 				 BT848_DATA_CTL_I2CSDA)
define|#
directive|define
name|I2C_COMMAND_878
value|(I2CBITTIME_878 |			\ 				 BT848_DATA_CTL_I2CSCL |	\ 				 BT848_DATA_CTL_I2CSDA)
comment|/* Select between old i2c code and new iicbus / smbus code */
if|#
directive|if
name|defined
argument_list|(
name|BKTR_USE_FREEBSD_SMBUS
argument_list|)
comment|/*  * The hardware interface is actually SMB commands  */
name|int
name|i2cWrite
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|byte1
parameter_list|,
name|int
name|byte2
parameter_list|)
block|{
name|char
name|cmd
decl_stmt|;
if|if
condition|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848A
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_849A
condition|)
name|cmd
operator|=
name|I2C_COMMAND
expr_stmt|;
else|else
name|cmd
operator|=
name|I2C_COMMAND_878
expr_stmt|;
if|if
condition|(
name|byte2
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|smbus_writew
argument_list|(
name|bktr
operator|->
name|i2c_sc
operator|.
name|smbus
argument_list|,
name|addr
argument_list|,
name|cmd
argument_list|,
call|(
name|short
call|)
argument_list|(
operator|(
operator|(
name|byte2
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|byte1
operator|&
literal|0xff
operator|)
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|smbus_writeb
argument_list|(
name|bktr
operator|->
name|i2c_sc
operator|.
name|smbus
argument_list|,
name|addr
argument_list|,
name|cmd
argument_list|,
call|(
name|char
call|)
argument_list|(
name|byte1
operator|&
literal|0xff
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* return OK */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|int
name|i2cRead
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|char
name|result
decl_stmt|;
name|char
name|cmd
decl_stmt|;
if|if
condition|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848A
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_849A
condition|)
name|cmd
operator|=
name|I2C_COMMAND
expr_stmt|;
else|else
name|cmd
operator|=
name|I2C_COMMAND_878
expr_stmt|;
if|if
condition|(
name|smbus_readb
argument_list|(
name|bktr
operator|->
name|i2c_sc
operator|.
name|smbus
argument_list|,
name|addr
argument_list|,
name|cmd
argument_list|,
operator|&
name|result
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|result
argument_list|)
operator|)
return|;
block|}
define|#
directive|define
name|IICBUS
parameter_list|(
name|bktr
parameter_list|)
value|((bktr)->i2c_sc.iicbus)
comment|/* The MSP34xx and DPL35xx Audio chip require i2c bus writes of up */
comment|/* to 5 bytes which the bt848 automated i2c bus controller cannot handle */
comment|/* Therefore we need low level control of the i2c bus hardware */
comment|/* Write to the MSP or DPL registers */
name|void
name|msp_dpl_write
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|i2c_addr
parameter_list|,
name|unsigned
name|char
name|dev
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|data
parameter_list|)
block|{
name|unsigned
name|char
name|addr_l
decl_stmt|,
name|addr_h
decl_stmt|,
name|data_h
decl_stmt|,
name|data_l
decl_stmt|;
name|addr_h
operator|=
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr_l
operator|=
name|addr
operator|&
literal|0xff
expr_stmt|;
name|data_h
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|data_l
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
name|iicbus_start
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|i2c_addr
argument_list|,
literal|0
comment|/* no timeout? */
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|addr_h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|addr_l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|data_h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|data_l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_stop
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read from the MSP or DPL registers */
name|unsigned
name|int
name|msp_dpl_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|i2c_addr
parameter_list|,
name|unsigned
name|char
name|dev
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|)
block|{
name|unsigned
name|int
name|data
decl_stmt|;
name|unsigned
name|char
name|addr_l
decl_stmt|,
name|addr_h
decl_stmt|,
name|dev_r
decl_stmt|;
name|int
name|read
decl_stmt|;
name|u_char
name|data_read
index|[
literal|2
index|]
decl_stmt|;
name|addr_h
operator|=
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr_l
operator|=
name|addr
operator|&
literal|0xff
expr_stmt|;
name|dev_r
operator|=
name|dev
operator|+
literal|1
expr_stmt|;
comment|/* XXX errors ignored */
name|iicbus_start
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|i2c_addr
argument_list|,
literal|0
comment|/* no timeout? */
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|dev_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|addr_h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|addr_l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_repeated_start
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|i2c_addr
operator|+
literal|1
argument_list|,
literal|0
comment|/* no timeout? */
argument_list|)
expr_stmt|;
name|iicbus_read
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|data_read
argument_list|,
literal|2
argument_list|,
operator|&
name|read
argument_list|,
name|IIC_LAST_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_stop
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|data_read
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|data_read
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
comment|/* Reset the MSP or DPL chip */
comment|/* The user can block the reset (which is handy if you initialise the  * MSP and/or DPL audio in another operating system first (eg in Windows)  */
name|void
name|msp_dpl_reset
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|i2c_addr
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|BKTR_NO_MSP_RESET
comment|/* put into reset mode */
name|iicbus_start
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|i2c_addr
argument_list|,
literal|0
comment|/* no timeout? */
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
literal|0x00
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
literal|0x80
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
literal|0x00
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_stop
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put back to operational mode */
name|iicbus_start
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|i2c_addr
argument_list|,
literal|0
comment|/* no timeout? */
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
literal|0x00
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
literal|0x00
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
literal|0x00
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_stop
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
specifier|static
name|void
name|remote_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|struct
name|bktr_remote
modifier|*
name|remote
parameter_list|)
block|{
name|int
name|read
decl_stmt|;
comment|/* XXX errors ignored */
name|iicbus_start
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|bktr
operator|->
name|remote_control_addr
argument_list|,
literal|0
comment|/* no timeout? */
argument_list|)
expr_stmt|;
name|iicbus_read
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|remote
operator|->
name|data
argument_list|,
literal|3
argument_list|,
operator|&
name|read
argument_list|,
name|IIC_LAST_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_stop
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
comment|/* defined(BKTR_USE_FREEBSD_SMBUS) */
comment|/*  * Program the i2c bus directly  */
name|int
name|i2cWrite
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|byte1
parameter_list|,
name|int
name|byte2
parameter_list|)
block|{
name|u_long
name|x
decl_stmt|;
name|u_long
name|data
decl_stmt|;
comment|/* clear status bits */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|,
name|BT848_INT_RACK
operator||
name|BT848_INT_I2CDONE
argument_list|)
expr_stmt|;
comment|/* build the command datum */
if|if
condition|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848A
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_849A
condition|)
block|{
name|data
operator|=
operator|(
operator|(
name|addr
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|byte1
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
name|I2C_COMMAND
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
operator|(
operator|(
name|addr
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|byte1
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
name|I2C_COMMAND_878
expr_stmt|;
block|}
if|if
condition|(
name|byte2
operator|!=
operator|-
literal|1
condition|)
block|{
name|data
operator||=
operator|(
operator|(
name|byte2
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|data
operator||=
name|BT848_DATA_CTL_I2CW3B
expr_stmt|;
block|}
comment|/* write the address and data */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* wait for completion */
for|for
control|(
name|x
operator|=
literal|0x7fffffff
init|;
name|x
condition|;
operator|--
name|x
control|)
block|{
comment|/* safety valve */
if|if
condition|(
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|)
operator|&
name|BT848_INT_I2CDONE
condition|)
break|break;
block|}
comment|/* check for ACK */
if|if
condition|(
operator|!
name|x
operator|||
operator|!
operator|(
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|)
operator|&
name|BT848_INT_RACK
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* return OK */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  *   */
name|int
name|i2cRead
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|u_long
name|x
decl_stmt|;
comment|/* clear status bits */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|,
name|BT848_INT_RACK
operator||
name|BT848_INT_I2CDONE
argument_list|)
expr_stmt|;
comment|/* write the READ address */
comment|/* The Bt878 and Bt879  differed on the treatment of i2c commands */
if|if
condition|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848A
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_849A
condition|)
block|{
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
operator|(
operator|(
name|addr
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
name|I2C_COMMAND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
operator|(
operator|(
name|addr
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
name|I2C_COMMAND_878
argument_list|)
expr_stmt|;
block|}
comment|/* wait for completion */
for|for
control|(
name|x
operator|=
literal|0x7fffffff
init|;
name|x
condition|;
operator|--
name|x
control|)
block|{
comment|/* safety valve */
if|if
condition|(
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|)
operator|&
name|BT848_INT_I2CDONE
condition|)
break|break;
block|}
comment|/* check for ACK */
if|if
condition|(
operator|!
name|x
operator|||
operator|!
operator|(
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_INT_STAT
argument_list|)
operator|&
name|BT848_INT_RACK
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* it was a read */
return|return
operator|(
operator|(
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
comment|/* The MSP34xx Audio chip require i2c bus writes of up to 5 bytes which the */
comment|/* bt848 automated i2c bus controller cannot handle */
comment|/* Therefore we need low level control of the i2c bus hardware */
comment|/* Idea for the following functions are from elsewhere in this driver and */
comment|/* from the Linux BTTV i2c driver by Gerd Knorr<kraxel@cs.tu-berlin.de> */
define|#
directive|define
name|BITD
value|40
specifier|static
name|void
name|i2c_start
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release data */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower data */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower clock */
block|}
specifier|static
name|void
name|i2c_stop
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower clock& data */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release data */
block|}
specifier|static
name|int
name|i2c_write_byte
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* write out the byte */
for|for
control|(
name|x
operator|=
literal|7
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
block|{
if|if
condition|(
name|data
operator|&
operator|(
literal|1
operator|<<
name|x
operator|)
condition|)
block|{
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* assert HI data */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
else|else
block|{
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* assert LO data */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
block|}
comment|/* look for an ACK */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* float data */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|status
operator|=
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|)
operator|&
literal|1
expr_stmt|;
comment|/* read the ACK bit */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
return|return
operator|(
name|status
operator|)
return|;
block|}
specifier|static
name|int
name|i2c_read_byte
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|int
name|byte
init|=
literal|0
decl_stmt|;
comment|/* read in the byte */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* float data */
for|for
control|(
name|x
operator|=
literal|7
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
block|{
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|bit
operator|=
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|)
operator|&
literal|1
expr_stmt|;
comment|/* read the data bit */
if|if
condition|(
name|bit
condition|)
name|byte
operator||=
operator|(
literal|1
operator|<<
name|x
operator|)
expr_stmt|;
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
comment|/* After reading the byte, send an ACK */
comment|/* (unless that was the last byte, for which we send a NAK */
if|if
condition|(
name|last
condition|)
block|{
comment|/* send NAK - same a writing a 1 */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* set data bit */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
else|else
block|{
comment|/* send ACK - same as writing a 0 */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* set data bit */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
operator|*
name|data
operator|=
name|byte
expr_stmt|;
return|return
literal|0
return|;
block|}
undef|#
directive|undef
name|BITD
comment|/* Write to the MSP or DPL registers */
name|void
name|msp_dpl_write
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|i2c_addr
parameter_list|,
name|unsigned
name|char
name|dev
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|data
parameter_list|)
block|{
name|unsigned
name|int
name|msp_w_addr
init|=
name|i2c_addr
decl_stmt|;
name|unsigned
name|char
name|addr_l
decl_stmt|,
name|addr_h
decl_stmt|,
name|data_h
decl_stmt|,
name|data_l
decl_stmt|;
name|addr_h
operator|=
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr_l
operator|=
name|addr
operator|&
literal|0xff
expr_stmt|;
name|data_h
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|data_l
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
name|i2c_start
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|msp_w_addr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|addr_h
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|addr_l
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|data_h
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|data_l
argument_list|)
expr_stmt|;
name|i2c_stop
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
block|}
comment|/* Read from the MSP or DPL registers */
name|unsigned
name|int
name|msp_dpl_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|i2c_addr
parameter_list|,
name|unsigned
name|char
name|dev
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|)
block|{
name|unsigned
name|int
name|data
decl_stmt|;
name|unsigned
name|char
name|addr_l
decl_stmt|,
name|addr_h
decl_stmt|,
name|data_1
decl_stmt|,
name|data_2
decl_stmt|,
name|dev_r
decl_stmt|;
name|addr_h
operator|=
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr_l
operator|=
name|addr
operator|&
literal|0xff
expr_stmt|;
name|dev_r
operator|=
name|dev
operator|+
literal|1
expr_stmt|;
name|i2c_start
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|i2c_addr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|dev_r
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|addr_h
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|addr_l
argument_list|)
expr_stmt|;
name|i2c_start
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|i2c_addr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i2c_read_byte
argument_list|(
name|bktr
argument_list|,
operator|&
name|data_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i2c_read_byte
argument_list|(
name|bktr
argument_list|,
operator|&
name|data_2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i2c_stop
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|data_1
operator|<<
literal|8
operator|)
operator||
name|data_2
expr_stmt|;
return|return
name|data
return|;
block|}
comment|/* Reset the MSP or DPL chip */
comment|/* The user can block the reset (which is handy if you initialise the  * MSP audio in another operating system first (eg in Windows)  */
name|void
name|msp_dpl_reset
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|i2c_addr
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|BKTR_NO_MSP_RESET
comment|/* put into reset mode */
name|i2c_start
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|i2c_addr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|i2c_stop
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
comment|/* put back to operational mode */
name|i2c_start
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|i2c_addr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|i2c_stop
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
specifier|static
name|void
name|remote_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|struct
name|bktr_remote
modifier|*
name|remote
parameter_list|)
block|{
comment|/* XXX errors ignored */
name|i2c_start
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|remote_control_addr
argument_list|)
expr_stmt|;
name|i2c_read_byte
argument_list|(
name|bktr
argument_list|,
operator|&
operator|(
name|remote
operator|->
name|data
index|[
literal|0
index|]
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i2c_read_byte
argument_list|(
name|bktr
argument_list|,
operator|&
operator|(
name|remote
operator|->
name|data
index|[
literal|1
index|]
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i2c_read_byte
argument_list|(
name|bktr
argument_list|,
operator|&
operator|(
name|remote
operator|->
name|data
index|[
literal|2
index|]
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i2c_stop
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* defined(BKTR_USE_FREEBSD_SMBUS) */
if|#
directive|if
name|defined
argument_list|(
name|I2C_SOFTWARE_PROBE
argument_list|)
comment|/*  * we are keeping this around for any parts that we need to probe  * but that CANNOT be probed via an i2c read.  * this is necessary because the hardware i2c mechanism  * cannot be programmed for 1 byte writes.  * currently there are no known i2c parts that we need to probe  * and that cannot be safely read.  */
specifier|static
name|int
name|i2cProbe
argument_list|(
name|bktr_ptr_t
name|bktr
argument_list|,
name|int
name|addr
argument_list|)
decl_stmt|;
define|#
directive|define
name|BITD
value|40
define|#
directive|define
name|EXTRA_START
comment|/*  * probe for an I2C device at addr.  */
specifier|static
name|int
name|i2cProbe
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|status
decl_stmt|;
comment|/* the START */
if|#
directive|if
name|defined
argument_list|(
name|EXTRA_START
argument_list|)
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release data */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
endif|#
directive|endif
comment|/* EXTRA_START */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower data */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower clock */
comment|/* write addr */
for|for
control|(
name|x
operator|=
literal|7
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
block|{
if|if
condition|(
name|addr
operator|&
operator|(
literal|1
operator|<<
name|x
operator|)
condition|)
block|{
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* assert HI data */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
else|else
block|{
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* assert LO data */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
block|}
comment|/* look for an ACK */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* float data */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|status
operator|=
name|INL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|)
operator|&
literal|1
expr_stmt|;
comment|/* read the ACK bit */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
comment|/* the STOP */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower clock& data */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
name|OUTL
argument_list|(
name|bktr
argument_list|,
name|BKTR_I2C_DATA_CTL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release data */
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|EXTRA_START
end_undef

begin_undef
undef|#
directive|undef
name|BITD
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I2C_SOFTWARE_PROBE */
end_comment

begin_define
define|#
directive|define
name|ABSENT
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FreeBSD, BSDI, NetBSD, OpenBSD */
end_comment

end_unit

