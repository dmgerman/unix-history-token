begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BT848 1.3-ALPHA  Driver for Brooktree's Bt848 based cards.    The Brooktree  BT848 Driver driver is based upon Mark Tinguely and    Jim Lowe's driver for the Matrox Meteor PCI card . The     Philips SAA 7116 and SAA 7196 are very different chipsets than    the BT848. For starters, the BT848 is a one chipset solution and    it incorporates a RISC engine to control the DMA transfers --    that is it the actual dma process is control by a program which    resides in the hosts memory also the register definitions between    the Philips chipsets and the Bt848 are very different.     The original copyright notice by Mark and Jim is included mostly    to honor their fantastic work in the Matrox Meteor driver!        Enjoy,       Amancio   */
end_comment

begin_comment
comment|/*  * 1. Redistributions of source code must retain the   * Copyright (c) 1997 Amancio Hasty  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Amancio Hasty  * 4. The name of the author may not be used to endorse or promote products   *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * 1. Redistributions of source code must retain the   * Copyright (c) 1995 Mark Tinguely and Jim Lowe  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Mark Tinguely and Jim Lowe  * 4. The name of the author may not be used to endorse or promote products   *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*		Change History: 1.0		1/24/97	   First Alpha release  1.1		2/20/97	   Added video ioctl so we can do PCI To PCI 			   data transfers. This is for capturing data 			   directly to a vga frame buffer which has 			   a linear frame buffer. Minor code clean-up.  1.3		2/23/97	   Fixed system lock-up reported by  			   Randall Hopper<rhh@ct.picker.com>. This 			   problem seems somehow to be exhibited only 			   in his system. I changed the setting of 			   INT_MASK for CAP_CONTINUOUS to be exactly 			   the same as CAP_SINGLE apparently setting 			   bit 23 cleared the system lock up.  			   version 1.1 of the driver has been reported 			   to work with STB's WinTv, Hauppage's Wincast/Tv 			   and last but not least with the Intel Smart 			   Video Recorder.  1.4		3/9/97	   fsmp@freefall.org 			   Merged code to support tuners on STB and WinCast 			   cards. 			   Modifications to the contrast and chroma ioctls. 			   Textual cleanup.  1.5             3/15/97    fsmp@freefall.org                 	   new bt848 specific versions of hue/bright/                            contrast/satu/satv.                            Amancio's patch to fix "screen freeze" problem.  1.6             3/19/97    fsmp@freefall.org 			   new table-driven frequency lookup. 			   removed disable_intr()/enable_intr() calls from i2c. 			   misc. cleanup.  1.7             3/19/97    fsmp@freefall.org 			   added audio support submitted by: 				Michael Petry<petry@netwolf.NetMasters.com>  1.8             3/20/97    fsmp@freefall.org 			   extended audio support. 			   card auto-detection. 			   major cleanup, order of routines, declarations, etc.  1.9             3/22/97    fsmp@freefall.org 			   merged in Amancio's minor unit for tuner control 			   mods. 			   misc. cleanup, especially in the _intr routine. 			   made AUDIO_SUPPORT mainline code.  1.10            3/23/97    fsmp@freefall.org 			   added polled hardware i2c routines, 			   removed all existing software i2c routines. 			   created software i2cProbe() routine. 			   Randall Hopper's fixes of BT848_GHUE& BT848_GBRIG. 			   eeprom support. */
end_comment

begin_include
include|#
directive|include
file|"bktr.h"
end_include

begin_if
if|#
directive|if
name|NBKTR
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVFS */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/ioctl_meteor.h>
end_include

begin_include
include|#
directive|include
file|<machine/ioctl_bt848.h>
end_include

begin_comment
comment|/* extensions to ioctl_meteor.h */
end_comment

begin_include
include|#
directive|include
file|<pci/brktree_reg.h>
end_include

begin_define
define|#
directive|define
name|METPRI
value|(PZERO+8)|PCATCH
end_define

begin_decl_stmt
specifier|static
name|void
name|bktr_intr
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|bt_enable_cnt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|btl_status_prev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Allocate enough memory for:  *	768x576 RGB 16 or YUV (16 storage bits/pixel) = 884736 = 216 pages  *  * You may override this using the options "METEOR_ALLOC_PAGES=value" in your  * kernel configuration file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BROOKTREE_ALLOC_PAGES
end_ifndef

begin_define
define|#
directive|define
name|BROOKTREE_ALLOC_PAGES
value|217*4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BROOKTREE_ALLOC
value|(BROOKTREE_ALLOC_PAGES * PAGE_SIZE)
end_define

begin_decl_stmt
specifier|static
name|bktr_reg_t
name|brooktree
index|[
name|NBKTR
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BROOKTRE_NUM
parameter_list|(
name|mtr
parameter_list|)
value|((bktr -&brooktree[0])/sizeof(bktr_reg_t))
end_define

begin_define
define|#
directive|define
name|BKTRPRI
value|(PZERO+8)|PCATCH
end_define

begin_function_decl
specifier|static
name|char
modifier|*
name|bktr_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bktr_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_long
name|bktr_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|bktr_device
init|=
block|{
literal|"bktr"
block|,
name|bktr_probe
block|,
name|bktr_attach
block|,
operator|&
name|bktr_count
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|bktr_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|bktr_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|bktr_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|bktr_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|bktr_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|bktr_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|bktr_mmap
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|79
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|bktr_cdevsw
init|=
block|{
name|bktr_open
block|,
name|bktr_close
block|,
name|bktr_read
block|,
name|bktr_write
block|,
name|bktr_ioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
name|seltrue
block|,
name|bktr_mmap
block|,
name|NULL
block|,
literal|"bktr"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is for start-up convenience only, NOT mandatory.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DEFAULT_CHNLSET
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEFAULT_CHNLSET
value|CHNLSET_NABCST
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * the recognized cards.  * used as indexes of several tables.  */
end_comment

begin_define
define|#
directive|define
name|CARD_UNKNOWN
value|0
end_define

begin_define
define|#
directive|define
name|CARD_MIRO
value|1
end_define

begin_define
define|#
directive|define
name|CARD_HAUPPAUGE
value|2
end_define

begin_define
define|#
directive|define
name|CARD_STB
value|3
end_define

begin_define
define|#
directive|define
name|CARD_INTEL
value|4
end_define

begin_comment
comment|/*  * i2c things:  */
end_comment

begin_comment
comment|/* XXX FIXME: experimental code, use with caution! */
end_comment

begin_define
define|#
directive|define
name|EEPROM_SUPPORT
end_define

begin_comment
comment|/* guaranteed address for any TSA5522/3 (PLL on all(?) tuners) */
end_comment

begin_define
define|#
directive|define
name|TSA5522_WADDR
value|0xc2
end_define

begin_define
define|#
directive|define
name|TSA5522_RADDR
value|0xc3
end_define

begin_define
define|#
directive|define
name|TEMIC_TSA5522_RADDR
value|0xc1
end_define

begin_define
define|#
directive|define
name|PHILIPS_TSA5523_RADDR
value|0xc7
end_define

begin_comment
comment|/* address of BTSC/SAP decoder chip */
end_comment

begin_define
define|#
directive|define
name|TDA9850_WADDR
value|0xb6
end_define

begin_define
define|#
directive|define
name|TDA9850_RADDR
value|0xb7
end_define

begin_comment
comment|/* EEProm (128 * 8) on an STB card */
end_comment

begin_define
define|#
directive|define
name|X24C01_WADDR
value|0xae
end_define

begin_define
define|#
directive|define
name|X24C01_RADDR
value|0xaf
end_define

begin_comment
comment|/* EEProm (256 * 8) on a Hauppauge card */
end_comment

begin_define
define|#
directive|define
name|PFC8582_WADDR
value|0xa0
end_define

begin_define
define|#
directive|define
name|PFC8582_RADDR
value|0xa1
end_define

begin_comment
comment|/* debug utility for holding previous INT_STAT contents */
end_comment

begin_define
define|#
directive|define
name|STATUS
end_define

begin_decl_stmt
specifier|static
name|u_long
name|status_sum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: magic#s sync detect threashold */
end_comment

begin_if
if|#
directive|if
literal|1
end_if

begin_define
define|#
directive|define
name|SYNC_LEVEL
value|0x81
end_define

begin_comment
comment|/* threashold ~125 mV */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SYNC_LEVEL
value|0xa1
end_define

begin_comment
comment|/* threashold ~75 mV */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * misc. support routines.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|CARDTYPE
name|card_types
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|probe_card
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|verbose
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|get_bktr_mem
parameter_list|(
name|int
name|unit
parameter_list|,
name|unsigned
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * bt848 RISC programming routines.  */
end_comment

begin_function_decl
specifier|static
name|int
name|dump_bt848
parameter_list|(
name|bt848_reg_t
name|bt848
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|yuvpack_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|yuv422_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rgb_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|pixel_width
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_dma_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * video& video capture specific routines.  */
end_comment

begin_function_decl
specifier|static
name|int
name|video_open
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|video_close
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|video_ioctl
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_capture
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|unsigned
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_fps
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|u_short
name|fps
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * tuner specific functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|tuner_open
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tuner_close
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tuner_ioctl
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tv_channel
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tv_freq
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|frequency
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * audio specific functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|set_audio
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_BTSC
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|control
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *   */
end_comment

begin_function_decl
specifier|static
name|int
name|common_ioctl
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|bt848_reg_t
name|bt848
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * i2c primitives  */
end_comment

begin_function_decl
specifier|static
name|int
name|i2cWrite
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|byte1
parameter_list|,
name|int
name|byte2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i2cRead
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EEPROM_SUPPORT
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|readEEProm
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EEPROM_SUPPORT */
end_comment

begin_comment
comment|/*  * the boot time probe routine.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|bktr_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BROOKTREE_848_ID
case|:
return|return
operator|(
literal|"BrookTree 848"
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * what should we do here?  */
end_comment

begin_function
specifier|static
name|void
name|bktr_init
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/*  * the attach routine.  */
end_comment

begin_function
specifier|static
name|void
name|bktr_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|bktr_reg_t
modifier|*
name|bktr
decl_stmt|;
name|bt848_reg_t
name|bt848
decl_stmt|;
ifdef|#
directive|ifdef
name|BROOKTREE_IRQ
name|u_long
name|old_irq
decl_stmt|,
name|new_irq
decl_stmt|;
endif|#
directive|endif
name|u_char
modifier|*
name|test
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
name|u_long
name|latency
decl_stmt|;
name|u_long
name|fun
decl_stmt|;
name|bt_enable_cnt
operator|=
literal|0
expr_stmt|;
name|bktr
operator|=
operator|&
name|brooktree
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
block|{
name|printf
argument_list|(
literal|"brooktree%d: attach: only %d units configured.\n"
argument_list|,
name|unit
argument_list|,
name|NBKTR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"brooktree%d: attach: invalid unit number.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return ;
block|}
name|bktr
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|pci_map_mem
argument_list|(
name|tag
argument_list|,
name|PCI_MAP_REG_START
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|base
argument_list|,
operator|&
name|bktr
operator|->
name|phys_base
argument_list|)
expr_stmt|;
name|fun
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BROOKTREE_IRQ
comment|/* from the configuration file */
name|old_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|,
name|BROOKTREE_IRQ
argument_list|)
expr_stmt|;
name|new_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bktr%d: attach: irq changed from %d to %d\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|old_irq
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
name|new_irq
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* setup the interrupt handling routine */
name|pci_map_int
argument_list|(
name|tag
argument_list|,
name|bktr_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bktr
argument_list|,
operator|&
name|net_imask
argument_list|)
expr_stmt|;
comment|/*  * PCI latency timer.  32 is a good value for 4 bus mastering slots, if  * you have more than for, then 16 would probably be a better value.  */
ifndef|#
directive|ifndef
name|BROOKTREE_DEF_LATENCY_VALUE
define|#
directive|define
name|BROOKTREE_DEF_LATENCY_VALUE
value|10
endif|#
directive|endif
name|latency
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_LATENCY_TIMER
argument_list|)
expr_stmt|;
name|latency
operator|=
operator|(
name|latency
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|latency
condition|)
name|printf
argument_list|(
literal|"brooktree%d: PCI bus latency is"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"brooktree%d: PCI bus latency was 0 changing to"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|latency
condition|)
block|{
name|latency
operator|=
name|BROOKTREE_DEF_LATENCY_VALUE
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_LATENCY_TIMER
argument_list|,
name|latency
operator|<<
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|" %d.\n"
argument_list|,
name|latency
argument_list|)
expr_stmt|;
block|}
comment|/*	bktr_init(bktr);	 set up the bt848 */
comment|/* allocate space for dma program */
name|bktr
operator|->
name|dma_prog
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|odd_dma_prog
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|BROOKTREE_ALLOC
condition|)
name|buf
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|BROOKTREE_ALLOC
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: buffer size %d, addr 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|BROOKTREE_ALLOC
argument_list|,
name|vtophys
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bktr
operator|->
name|bigbuf
operator|=
name|buf
expr_stmt|;
name|bktr
operator|->
name|alloc_pages
operator|=
name|BROOKTREE_ALLOC_PAGES
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
name|BROOKTREE_ALLOC
argument_list|)
expr_stmt|;
name|buf
operator|=
name|vtophys
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|amancio
comment|/* 640x480 RGB 16 */
name|amancio
label|:
name|setup
name|dma
name|risc
name|program
name|bktr
operator|->
name|base
operator|->
name|dma1e
init|=
name|buf
decl_stmt|;
name|bktr
operator|->
name|base
operator|->
name|dma1o
operator|=
name|buf
operator|+
literal|0x500
expr_stmt|;
name|bktr
operator|->
name|base
operator|->
name|dma_end_e
operator|=
name|bktr
operator|->
name|base
operator|->
name|dma_end_o
operator|=
name|buf
operator|+
name|METEOR_ALLOC
expr_stmt|;
name|end
name|of
name|setup
name|up
name|dma
name|risc
name|program
comment|/* 1 frame of 640x480 RGB 16 */
name|bktr
operator|->
name|flags
operator||=
name|METEOR_INITALIZED
operator||
name|METEOR_AUTOMODE
operator||
name|METEOR_DEV0
operator||
name|METEOR_RGB16
expr_stmt|;
endif|#
directive|endif
comment|/* amancio */
name|bktr
operator|->
name|flags
operator|=
name|METEOR_INITALIZED
operator||
name|METEOR_AUTOMODE
operator||
name|METEOR_DEV0
operator||
name|METEOR_RGB16
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|cols
operator|=
literal|640
expr_stmt|;
name|bktr
operator|->
name|rows
operator|=
literal|480
expr_stmt|;
name|bktr
operator|->
name|depth
operator|=
literal|2
expr_stmt|;
comment|/* two bytes per pixel */
name|bktr
operator|->
name|frames
operator|=
literal|1
expr_stmt|;
comment|/* one frame */
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|0
expr_stmt|;
block|}
comment|/* defaults for the tuner section of the card */
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|channel
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|chnlset
operator|=
name|DEFAULT_CHNLSET
expr_stmt|;
name|probe_card
argument_list|(
name|bktr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|bktr
operator|->
name|devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|bktr_cdevsw
argument_list|,
name|unit
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0644
argument_list|,
literal|"brooktree"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEVFS */
block|}
end_function

begin_comment
comment|/*  * interrupt handling routine complete bktr_read() if using interrupts.  */
end_comment

begin_function
specifier|static
name|void
name|bktr_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|bktr_reg_t
modifier|*
name|bktr
init|=
operator|(
name|bktr_reg_t
operator|*
operator|)
name|arg
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|bktr_pc
decl_stmt|;
name|bt848_reg_t
name|bt848
decl_stmt|;
name|u_long
name|bktr_status
decl_stmt|;
name|u_char
name|dstatus
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* 	 * check to see if any interrupts are unmasked on this device.  If 	 * none are, then we likely got here by way of being on a PCI shared 	 * interrupt dispatch list. 	 */
if|if
condition|(
name|bt848
operator|->
name|int_mask
operator|==
literal|0
condition|)
return|return;
comment|/* bail out now, before we do something we 				   shouldn't */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_OPEN
operator|)
condition|)
block|{
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
literal|0
expr_stmt|;
comment|/* return; ?? */
block|}
comment|/* record and clear the INTerrupt status bits */
name|bktr_status
operator|=
name|bt848
operator|->
name|int_stat
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|bt848
operator|->
name|int_stat
expr_stmt|;
comment|/* record and clear the device status register */
name|dstatus
operator|=
name|bt848
operator|->
name|dstatus
expr_stmt|;
name|bt848
operator|->
name|dstatus
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|STATUS
argument_list|)
comment|/* add any new device status or INTerrupt status bits */
name|status_sum
operator||=
operator|(
name|bktr_status
operator|&
operator|~
literal|0xc0
operator|)
expr_stmt|;
comment|/* clear 2 resv bits */
name|status_sum
operator||=
operator|(
operator|(
name|dstatus
operator|&
literal|0x03
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
comment|/* device LOF/COF */
endif|#
directive|endif
comment|/* STATUS */
if|#
directive|if
literal|0
comment|/* check i2c status */
block|if (bt848->int_stat& (1<< 25))
comment|/* XXX bug, already cleared above */
block|bt848->int_stat |= 1<< 8;
endif|#
directive|endif
if|#
directive|if
literal|0
block|bktr_pc = bt848->risc_count; 	printf( " STATUS %x %x %x \n", dstatus, bktr_status, *bktr_pc );
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
operator|(
name|bktr_status
operator|&
literal|0x800
operator|)
operator|||
operator|(
name|bktr_status
operator|&
literal|1
operator|<<
literal|19
operator|)
operator|)
condition|)
block|{
name|btl_status_prev
operator|=
name|bktr_status
expr_stmt|;
comment|/* return; */
block|}
comment|/* if risc was disabled re-start process again */
if|if
condition|(
operator|!
operator|(
name|bktr_status
operator|&
operator|(
literal|1
operator|<<
literal|27
operator|)
operator|)
operator|||
operator|(
operator|(
name|bktr_status
operator|&
literal|0xff000
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* XXX isn't this redundant ??? */
name|bt848
operator|->
name|int_stat
operator|=
name|bt848
operator|->
name|int_stat
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|risc_strt_add
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|1
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
literal|1
operator|<<
literal|23
operator||
literal|1
operator|<<
literal|11
operator||
literal|2
operator||
literal|1
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
name|bktr
operator|->
name|bktr_cap_ctl
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|bktr_status
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|)
condition|)
return|return;
if|#
directive|if
literal|0
block|printf( "intr status %x %x %x\n", bktr_status, dstatus, 	       bt848->risc_count);
endif|#
directive|endif
comment|/* 	 * Disable future interrupts if a capture mode is not selected. 	 * This can happen when we are in the process of closing or  	 * changing capture modes, otherwise it shouldn't happen. 	 */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
operator|)
condition|)
name|bt848
operator|->
name|cap_ctl
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we have a complete frame. 	 */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_WANT_MASK
operator|)
condition|)
block|{
name|bktr
operator|->
name|frames_captured
operator|++
expr_stmt|;
comment|/* 		 * post the completion time.  		 */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_WANT_TS
condition|)
block|{
name|struct
name|timeval
modifier|*
name|ts
decl_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|<=
operator|(
name|bktr
operator|->
name|frame_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
operator|)
condition|)
block|{
name|ts
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|bktr
operator|->
name|bigbuf
operator|+
name|bktr
operator|->
name|frame_size
expr_stmt|;
comment|/* doesn't work in synch mode except 				 *  for first frame */
comment|/* XXX */
name|microtime
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Wake up the user in single capture mode. 		 */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_SINGLE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bktr_status
operator|&
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|)
condition|)
return|return;
comment|/* stop dma */
name|bt848
operator|->
name|int_mask
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|1
expr_stmt|;
comment|/* disable risc and fifo */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the user requested to be notified via signal, 		 * let them know the frame is complete. 		 */
if|if
condition|(
name|bktr
operator|->
name|proc
operator|&&
operator|!
operator|(
name|bktr
operator|->
name|signal
operator|&
name|METEOR_SIG_MODE_MASK
operator|)
condition|)
name|psignal
argument_list|(
name|bktr
operator|->
name|proc
argument_list|,
name|bktr
operator|->
name|signal
operator|&
operator|(
operator|~
name|METEOR_SIG_MODE_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Reset the want flags if in continuous or 		 * synchronous capture mode. 		 */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------- ** **	BrookTree 848 character device driver routines ** **--------------------------------------------------------- */
end_comment

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x0f)
end_define

begin_define
define|#
directive|define
name|MINOR
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xf0)
end_define

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|bktr_reg_t
modifier|*
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|minor
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bt848_reg_t
name|bt848
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_INITALIZED
operator|)
condition|)
comment|/* device not found */
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x0010
condition|)
return|return
name|tuner_open
argument_list|(
name|bktr
argument_list|)
return|;
else|else
return|return
name|video_open
argument_list|(
name|bktr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|video_open
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|)
block|{
name|bt848_reg_t
name|bt848
decl_stmt|;
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_OPEN
condition|)
comment|/* device is busy */
return|return
operator|(
name|EBUSY
operator|)
return|;
name|bktr
operator|->
name|flags
operator||=
name|METEOR_OPEN
expr_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
if|#
directive|if
literal|0
block|dump_bt848( bt848 );
endif|#
directive|endif
comment|/* 0 */
name|bt848
operator|->
name|dstatus
operator|=
literal|0x00
expr_stmt|;
comment|/* bt848[ DSTATUS ] */
name|bt848
operator|->
name|adc
operator|=
name|SYNC_LEVEL
expr_stmt|;
name|bt848
operator|->
name|iform
operator|=
literal|0x69
expr_stmt|;
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV0
expr_stmt|;
name|bt848
operator|->
name|color_ctl
operator|=
literal|0x20
expr_stmt|;
name|bt848
operator|->
name|e_hscale_lo
operator|=
literal|0xaa
expr_stmt|;
name|bt848
operator|->
name|o_hscale_lo
operator|=
literal|0xaa
expr_stmt|;
name|bt848
operator|->
name|e_delay_lo
operator|=
literal|0x72
expr_stmt|;
name|bt848
operator|->
name|o_delay_lo
operator|=
literal|0x72
expr_stmt|;
name|bt848
operator|->
name|e_scloop
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|o_scloop
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|vbi_pack_size
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|vbi_pack_del
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|bktr
operator|->
name|bigbuf
argument_list|,
literal|640
operator|*
literal|480
operator|*
literal|4
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|fifo_errors
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|dma_errors
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|frames_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|even_fields_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|odd_fields_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
expr_stmt|;
name|set_fps
argument_list|(
name|bktr
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|width
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|banksize
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|ramsize
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
literal|1
operator|<<
literal|23
expr_stmt|;
comment|/* ? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|tuner_open
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|)
block|{
name|bt848_reg_t
name|bt848
init|=
name|bktr
operator|->
name|base
decl_stmt|;
define|#
directive|define
name|GPIO_AUDIOMUX_BITS
value|0x07
name|bt848
operator|->
name|gpio_out_en
operator|=
name|GPIO_AUDIOMUX_BITS
expr_stmt|;
comment|/* drive low 3 bits */
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_UNMUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|card
operator|->
name|dbx
condition|)
name|set_BTSC
argument_list|(
name|bktr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* enable stereo */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|bktr_reg_t
modifier|*
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|bt848_reg_t
name|bt848
decl_stmt|;
ifdef|#
directive|ifdef
name|METEOR_DEALLOC_ABOVE
name|int
name|temp
decl_stmt|;
endif|#
directive|endif
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x0010
condition|)
return|return
name|tuner_close
argument_list|(
name|bktr
argument_list|)
return|;
else|else
return|return
name|video_close
argument_list|(
name|bktr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|video_close
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|)
block|{
name|bt848_reg_t
name|bt848
decl_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_OPEN
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_CAP_MASK
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|tdec
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|sreset
operator|=
literal|0xf
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
literal|0xffffffff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tuner close handle,  *  place holder for tuner specific operations on a close.  */
end_comment

begin_function
specifier|static
name|int
name|tuner_close
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|)
block|{
name|bt848_reg_t
name|bt848
init|=
name|bktr
operator|->
name|base
decl_stmt|;
comment|/* mute the audio by switching the mux */
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_MUTE
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|gpio_out_en
operator|=
literal|0
expr_stmt|;
comment|/* float low 3 bits */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|bktr_reg_t
modifier|*
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|count
decl_stmt|;
name|bt848_reg_t
name|bt848
decl_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated (ioctl failed) */
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* already capturing */
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|count
operator|=
name|bktr
operator|->
name|rows
operator|*
name|bktr
operator|->
name|cols
operator|*
name|bktr
operator|->
name|depth
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<
name|count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_CAP_MASK
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
comment|/* Start capture */
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|0x1
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|0x3
expr_stmt|;
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
argument_list|,
name|METPRI
argument_list|,
literal|"capturing"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
comment|/* successful capture */
name|status
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|bigbuf
argument_list|,
name|count
argument_list|,
name|uio
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"meteor%d: read: tsleep error %d\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_write
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
name|bktr_reg_t
modifier|*
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated (ioctl failed) */
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x0010
condition|)
return|return
name|tuner_ioctl
argument_list|(
name|bktr
argument_list|,
name|unit
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|pr
argument_list|)
return|;
else|else
return|return
name|video_ioctl
argument_list|(
name|bktr
argument_list|,
name|unit
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|pr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * video ioctls  */
end_comment

begin_function
specifier|static
name|int
name|video_ioctl
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|tmp_int
decl_stmt|;
name|bt848_reg_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_char
name|c_temp
decl_stmt|;
specifier|volatile
name|u_short
name|s_temp
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|,
name|temp1
decl_stmt|;
name|unsigned
name|int
name|error
decl_stmt|;
name|struct
name|meteor_geomet
modifier|*
name|geo
decl_stmt|;
name|struct
name|meteor_counts
modifier|*
name|cnt
decl_stmt|;
name|struct
name|meteor_video
modifier|*
name|video
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|METEORSTATUS
case|:
comment|/* get Bt848 status */
name|c_temp
operator|=
name|bt848
operator|->
name|dstatus
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c_temp
operator|&
literal|0x40
operator|)
condition|)
name|temp
operator||=
name|METEOR_STATUS_HCLK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c_temp
operator|&
literal|0x10
operator|)
condition|)
name|temp
operator||=
name|METEOR_STATUS_FIDT
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|METEORSFMT
case|:
comment|/* set input format */
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|METEOR_FORM_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_FMT_NTSC
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_NTSC
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
literal|0x3
expr_stmt|;
name|bt848
operator|->
name|iform
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|METEOR_FMT_AUTOMODE
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_AUTOMODE
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
literal|0x3
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
break|break;
case|case
name|METEORGFMT
case|:
comment|/* get input format */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|flags
operator|&
name|METEOR_FORM_MASK
expr_stmt|;
break|break;
case|case
name|METEORSCOUNT
case|:
comment|/* (re)set error counts */
name|cnt
operator|=
operator|(
expr|struct
name|meteor_counts
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|fifo_errors
operator|=
name|cnt
operator|->
name|fifo_errors
expr_stmt|;
name|bktr
operator|->
name|dma_errors
operator|=
name|cnt
operator|->
name|dma_errors
expr_stmt|;
name|bktr
operator|->
name|frames_captured
operator|=
name|cnt
operator|->
name|frames_captured
expr_stmt|;
name|bktr
operator|->
name|even_fields_captured
operator|=
name|cnt
operator|->
name|even_fields_captured
expr_stmt|;
name|bktr
operator|->
name|odd_fields_captured
operator|=
name|cnt
operator|->
name|odd_fields_captured
expr_stmt|;
break|break;
case|case
name|METEORGCOUNT
case|:
comment|/* get error counts */
name|cnt
operator|=
operator|(
expr|struct
name|meteor_counts
operator|*
operator|)
name|arg
expr_stmt|;
name|cnt
operator|->
name|fifo_errors
operator|=
name|bktr
operator|->
name|fifo_errors
expr_stmt|;
name|cnt
operator|->
name|dma_errors
operator|=
name|bktr
operator|->
name|dma_errors
expr_stmt|;
name|cnt
operator|->
name|frames_captured
operator|=
name|bktr
operator|->
name|frames_captured
expr_stmt|;
name|cnt
operator|->
name|even_fields_captured
operator|=
name|bktr
operator|->
name|even_fields_captured
expr_stmt|;
name|cnt
operator|->
name|odd_fields_captured
operator|=
name|bktr
operator|->
name|odd_fields_captured
expr_stmt|;
break|break;
case|case
name|METEORGVIDEO
case|:
name|video
operator|=
operator|(
expr|struct
name|meteor_video
operator|*
operator|)
name|arg
expr_stmt|;
name|video
operator|->
name|addr
operator|=
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
name|video
operator|->
name|width
operator|=
name|bktr
operator|->
name|video
operator|.
name|width
expr_stmt|;
name|video
operator|->
name|banksize
operator|=
name|bktr
operator|->
name|video
operator|.
name|banksize
expr_stmt|;
name|video
operator|->
name|ramsize
operator|=
name|bktr
operator|->
name|video
operator|.
name|ramsize
expr_stmt|;
break|break;
case|case
name|METEORSVIDEO
case|:
name|video
operator|=
operator|(
expr|struct
name|meteor_video
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|addr
operator|=
name|video
operator|->
name|addr
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|width
operator|=
name|video
operator|->
name|width
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|banksize
operator|=
name|video
operator|->
name|banksize
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|ramsize
operator|=
name|video
operator|->
name|ramsize
expr_stmt|;
break|break;
case|case
name|METEORSFPS
case|:
name|set_fps
argument_list|(
name|bktr
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGFPS
case|:
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|fps
expr_stmt|;
break|break;
case|case
name|METEORSHUE
case|:
comment|/* set hue */
name|bt848
operator|->
name|hue
operator|=
operator|(
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|METEORGHUE
case|:
comment|/* get hue */
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
name|bt848
operator|->
name|hue
expr_stmt|;
break|break;
case|case
name|METEORSBRIG
case|:
comment|/* set brightness */
name|bt848
operator|->
name|bright
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|METEORGBRIG
case|:
comment|/* get brightness */
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
name|bt848
operator|->
name|bright
expr_stmt|;
break|break;
case|case
name|METEORSCSAT
case|:
comment|/* set chroma saturation */
name|temp
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
expr_stmt|;
name|bt848
operator|->
name|sat_u_lo
operator|=
name|bt848
operator|->
name|sat_v_lo
operator|=
operator|(
name|temp
operator|<<
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
literal|0x3
expr_stmt|;
comment|/* clear U/V MSBs */
name|bt848
operator|->
name|o_control
operator|&=
operator|~
literal|0x3
expr_stmt|;
comment|/* clear U/V MSBs */
if|if
condition|(
name|temp
operator|&
literal|0x80
condition|)
block|{
name|bt848
operator|->
name|e_control
operator||=
literal|0x3
expr_stmt|;
name|bt848
operator|->
name|o_control
operator||=
literal|0x3
expr_stmt|;
block|}
break|break;
case|case
name|METEORGCSAT
case|:
comment|/* get chroma saturation */
name|temp
operator|=
operator|(
name|bt848
operator|->
name|sat_v_lo
operator|>>
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
literal|0x01
condition|)
name|temp
operator||=
literal|0x80
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
operator|(
name|u_char
operator|)
name|temp
expr_stmt|;
break|break;
case|case
name|METEORSCONT
case|:
comment|/* set contrast */
name|temp
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|&
literal|0xff
expr_stmt|;
name|temp
operator|<<=
literal|1
expr_stmt|;
name|bt848
operator|->
name|contrast_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
literal|0x4
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|&=
operator|~
literal|0x4
expr_stmt|;
name|bt848
operator|->
name|e_control
operator||=
operator|(
operator|(
name|temp
operator|&
literal|0x100
operator|)
operator|>>
literal|6
operator|)
operator|&
literal|0x4
expr_stmt|;
name|bt848
operator|->
name|o_control
operator||=
operator|(
operator|(
name|temp
operator|&
literal|0x100
operator|)
operator|>>
literal|6
operator|)
operator|&
literal|0x4
expr_stmt|;
break|break;
case|case
name|METEORGCONT
case|:
comment|/* get contrast */
name|temp
operator|=
operator|(
name|int
operator|)
name|bt848
operator|->
name|contrast_lo
operator|&
literal|0xff
expr_stmt|;
name|temp
operator||=
operator|(
operator|(
name|int
operator|)
name|bt848
operator|->
name|o_control
operator|&
literal|0x04
operator|)
operator|<<
literal|6
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|temp
operator|>>
literal|1
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORSSIGNAL
case|:
name|bktr
operator|->
name|signal
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|proc
operator|=
name|pr
expr_stmt|;
break|break;
case|case
name|METEORGSIGNAL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|signal
expr_stmt|;
break|break;
case|case
name|METEORCAPTUR
case|:
name|temp
operator|=
name|bktr
operator|->
name|flags
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
condition|)
block|{
case|case
name|METEOR_CAP_SINGLE
case|:
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated */
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/*			if (temp& METEOR_CAP_MASK) 				return(EIO);		 already capturing */
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_SINGLE
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|flags
operator||=
name|METEOR_SINGLE
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_MASK
expr_stmt|;
comment|/* wait for capture to complete */
name|bt848
operator|->
name|int_stat
operator|=
literal|0xffffffff
expr_stmt|;
if|#
directive|if
literal|0
block|XXX why was this done??? 			bt848->gpio_out_en = 1;
endif|#
directive|endif
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|0x1
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
literal|1
operator|<<
literal|23
operator||
literal|1
operator|<<
literal|11
operator||
literal|2
operator||
literal|1
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
argument_list|,
name|METPRI
argument_list|,
literal|"capturing"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: tsleep error %d %x\n"
argument_list|,
name|unit
argument_list|,
name|error
argument_list|,
name|bt848
operator|->
name|risc_count
argument_list|)
expr_stmt|;
block|}
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
comment|/* bt848->int_stat; ?? */
break|break;
case|case
name|METEOR_CAP_CONTINOUS
case|:
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated */
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|temp
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* already capturing */
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_CONTIN
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|bt848
operator|->
name|int_stat
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|1
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
literal|1
operator|<<
literal|23
operator||
literal|1
operator|<<
literal|11
operator||
literal|2
operator||
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|dump_bt848( bt848 );
endif|#
directive|endif
comment|/* 0 */
break|break;
case|case
name|METEOR_CAP_STOP_CONT
case|:
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CONTIN
condition|)
block|{
comment|/* turn off capture */
name|bt848
operator|->
name|int_mask
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|METEORSETGEO
case|:
name|geo
operator|=
operator|(
expr|struct
name|meteor_geomet
operator|*
operator|)
name|arg
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Either even or odd, if even& odd, then these a zero */
if|if
condition|(
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
operator|)
operator|&&
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: Geometry odd or even only.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* set/clear even/odd flags */
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
condition|)
name|bktr
operator|->
name|flags
operator||=
name|METEOR_ONLY_ODD_FIELDS
expr_stmt|;
else|else
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_ONLY_ODD_FIELDS
expr_stmt|;
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
condition|)
name|bktr
operator|->
name|flags
operator||=
name|METEOR_ONLY_EVEN_FIELDS
expr_stmt|;
else|else
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_ONLY_EVEN_FIELDS
expr_stmt|;
comment|/* can't change parameters while capturing */
comment|/* XXX: 		if (bktr->flags& METEOR_CAP_MASK) 			return(EBUSY); */
if|if
condition|(
operator|(
name|geo
operator|->
name|columns
operator|&
literal|0x3fe
operator|)
operator|!=
name|geo
operator|->
name|columns
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: %d: columns too large or not even.\n"
argument_list|,
name|unit
argument_list|,
name|geo
operator|->
name|columns
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|geo
operator|->
name|rows
operator|&
literal|0x7fe
operator|)
operator|!=
name|geo
operator|->
name|rows
operator|)
operator|||
operator|(
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_FIELD_MASK
operator|)
operator|&&
operator|(
operator|(
name|geo
operator|->
name|rows
operator|&
literal|0x3fe
operator|)
operator|!=
name|geo
operator|->
name|rows
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: %d: rows too large or not even.\n"
argument_list|,
name|unit
argument_list|,
name|geo
operator|->
name|rows
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|geo
operator|->
name|frames
operator|>
literal|32
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: too many frames.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|temp
operator|=
name|geo
operator|->
name|rows
operator|*
name|geo
operator|->
name|columns
operator|*
name|geo
operator|->
name|frames
operator|*
literal|2
condition|)
block|{
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_RGB24
condition|)
name|temp
operator|=
name|temp
operator|*
literal|2
expr_stmt|;
comment|/* meteor_mem structure for SYNC Capture */
if|if
condition|(
name|geo
operator|->
name|frames
operator|>
literal|1
condition|)
name|temp
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|temp
operator|=
name|btoc
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|temp
operator|>
name|bktr
operator|->
name|alloc_pages
operator|&&
name|bktr
operator|->
name|video
operator|.
name|addr
operator|==
literal|0
condition|)
block|{
name|buf
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|temp
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|bktr
operator|->
name|bigbuf
argument_list|,
operator|(
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|bigbuf
operator|=
name|buf
expr_stmt|;
name|bktr
operator|->
name|alloc_pages
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"meteor%d: ioctl: Allocating %d bytes\n"
argument_list|,
name|unit
argument_list|,
name|temp
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|bktr
operator|->
name|rows
operator|=
name|geo
operator|->
name|rows
expr_stmt|;
name|bktr
operator|->
name|cols
operator|=
name|geo
operator|->
name|columns
expr_stmt|;
name|bktr
operator|->
name|frames
operator|=
name|geo
operator|->
name|frames
expr_stmt|;
comment|/* horizontal scale */
comment|/* temp = ((910.0/( (float) bktr->cols *1.21875)) - 1.0) * 4096.0;*/
comment|/* temp = ((910.0/( (float) bktr->cols *1.212)) - 1.0) * 4096.0; */
name|temp
operator|=
operator|(
operator|(
literal|910.0
operator|/
operator|(
operator|(
name|float
operator|)
name|bktr
operator|->
name|cols
operator|*
literal|1.21875
operator|)
operator|)
operator|-
literal|1.0
operator|)
operator|*
literal|4096.0
expr_stmt|;
comment|/* temp = ((754.0/(float) bktr->cols) - 1 ) * 4096.0;*/
name|bt848
operator|->
name|e_hscale_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_hscale_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_hscale_hi
operator|=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_hscale_hi
operator|=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* horizontal active */
name|temp
operator|=
name|bktr
operator|->
name|cols
expr_stmt|;
name|bt848
operator|->
name|e_hactive_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_hactive_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator|&=
operator|~
literal|0x3
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator|&=
operator|~
literal|0x3
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator||=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0x3
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator||=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0x3
expr_stmt|;
comment|/* horizontal delay */
name|temp
operator|=
operator|(
operator|(
literal|135.0
operator|/
literal|754.0
operator|)
operator|*
operator|(
name|float
operator|)
name|bktr
operator|->
name|cols
operator|)
expr_stmt|;
name|temp
operator|=
name|temp
operator|+
literal|2
expr_stmt|;
name|temp
operator|=
name|temp
operator|&
literal|0x3fe
expr_stmt|;
name|bt848
operator|->
name|e_delay_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_delay_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator|&=
operator|~
literal|0xc
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator|&=
operator|~
literal|0xc
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator||=
operator|(
name|temp
operator|>>
literal|6
operator|)
operator|&
literal|0xc
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator||=
operator|(
name|temp
operator|>>
literal|6
operator|)
operator|&
literal|0xc
expr_stmt|;
comment|/* vscale */
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
operator|||
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
condition|)
block|{
name|tmp_int
operator|=
literal|65536.0
operator|-
operator|(
operator|(
operator|(
literal|240.0
operator|/
operator|(
name|float
operator|)
name|bktr
operator|->
name|rows
operator|)
operator|-
literal|1.0
operator|)
operator|*
literal|512.0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tmp_int
operator|=
literal|65536
operator|-
operator|(
operator|(
operator|(
literal|480.0
operator|/
operator|(
name|float
operator|)
name|bktr
operator|->
name|rows
operator|)
operator|-
literal|1.0
operator|)
operator|*
literal|512
operator|)
expr_stmt|;
block|}
name|tmp_int
operator|&=
literal|0x1fff
expr_stmt|;
comment|/* Vertical scaling */
name|bt848
operator|->
name|e_vscale_lo
operator|=
name|tmp_int
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_vscale_lo
operator|=
name|tmp_int
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator|&=
operator|~
literal|0x1f
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator|&=
operator|~
literal|0x1f
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator||=
operator|(
name|tmp_int
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator||=
operator|(
name|tmp_int
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_422
expr_stmt|;
switch|switch
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_OUTPUT_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_GEO_RGB16
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB16
expr_stmt|;
name|bktr
operator|->
name|depth
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_RGB24
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB24
expr_stmt|;
name|bktr
operator|->
name|depth
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_YUV_422
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_422
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_YUV_PACKED
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_PACKED
expr_stmt|;
break|break;
block|}
comment|/* 		if (geo->oformat& METEOR_GEO_YUV_12 ) 			bktr->format |= METEOR_GEO_YUV_12; 		else if (geo->oformat& METEOR_GEO_YUV_9 ) 			bktr->format |= METEOR_GEO_YUV_9; */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_CONTIN
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|bt848
operator|->
name|int_stat
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|0x1
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
literal|1
operator|<<
literal|23
operator||
literal|2
operator||
literal|1
expr_stmt|;
block|}
block|}
break|break;
comment|/* end of METEORSETGEO */
default|default:
return|return
name|common_ioctl
argument_list|(
name|bktr
argument_list|,
name|bt848
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * tuner ioctls  */
end_comment

begin_function
specifier|static
name|int
name|tuner_ioctl
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
name|bt848_reg_t
name|bt848
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|tmp_int
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|,
name|temp1
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EEPROM_SUPPORT
argument_list|)
name|int
name|offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
endif|#
directive|endif
comment|/* EEPROM_SUPPORT */
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TVTUNER_SETCHNL
case|:
name|tmp_int
operator|=
name|bktr
operator|->
name|audio_mute_state
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_MUTE
argument_list|)
expr_stmt|;
comment|/* prevent 'click' */
name|temp
operator|=
name|tv_channel
argument_list|(
name|bktr
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
argument_list|,
name|PZERO
argument_list|,
literal|"tuning"
argument_list|,
name|hz
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|==
name|FALSE
condition|)
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_UNMUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETCHNL
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|channel
expr_stmt|;
break|break;
case|case
name|TVTUNER_SETTYPE
case|:
name|temp
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|<
name|CHNLSET_MIN
operator|)
operator|||
operator|(
name|temp
operator|>
name|CHNLSET_MAX
operator|)
condition|)
return|return
name|EINVAL
return|;
name|bktr
operator|->
name|tuner
operator|.
name|chnlset
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETTYPE
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|chnlset
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETSTATUS
case|:
name|temp
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|TSA5522_RADDR
argument_list|)
expr_stmt|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|TVTUNER_SETFREQ
case|:
if|#
directive|if
name|defined
argument_list|(
name|AUDIO_SUPPORT_XXX
argument_list|)
name|tmp_int
operator|=
name|bktr
operator|->
name|audio_mute_state
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_MUTE
argument_list|)
expr_stmt|;
comment|/* prevent 'click' */
endif|#
directive|endif
comment|/* AUDIO_SUPPORT */
name|temp
operator|=
name|tv_freq
argument_list|(
name|bktr
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AUDIO_SUPPORT_XXX
argument_list|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
argument_list|,
name|PZERO
argument_list|,
literal|"tuning"
argument_list|,
name|hz
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|==
name|FALSE
condition|)
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_UNMUTE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUDIO_SUPPORT */
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETFREQ
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|frequency
expr_stmt|;
break|break;
case|case
name|BT848_SAUDIO
case|:
comment|/* set audio channel */
if|if
condition|(
name|set_audio
argument_list|(
name|bktr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
operator|<
literal|0
condition|)
return|return
name|EIO
return|;
break|break;
comment|/* hue is a 2's compliment number, -90' to +89.3' in 0.7' steps */
case|case
name|BT848_SHUE
case|:
comment|/* set hue */
name|bt848
operator|->
name|hue
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GHUE
case|:
comment|/* get hue */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
name|bt848
operator|->
name|hue
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
comment|/* brightness is a 2's compliment #, -50 to +%49.6% in 0.39% steps */
case|case
name|BT848_SBRIG
case|:
comment|/* set brightness */
name|bt848
operator|->
name|bright
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GBRIG
case|:
comment|/* get brightness */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
name|bt848
operator|->
name|bright
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SCSAT
case|:
comment|/* set chroma saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|e_control
operator|&
literal|0xfc
expr_stmt|;
name|temp1
operator|=
name|bt848
operator|->
name|o_control
operator|&
literal|0xfc
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
literal|0x100
condition|)
block|{
name|temp
operator||=
literal|0x03
expr_stmt|;
name|temp1
operator||=
literal|0x03
expr_stmt|;
block|}
name|bt848
operator|->
name|sat_u_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|sat_v_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|=
name|temp
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GCSAT
case|:
comment|/* get chroma saturation */
name|tmp_int
operator|=
call|(
name|int
call|)
argument_list|(
name|bt848
operator|->
name|sat_v_lo
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
literal|0x01
condition|)
name|tmp_int
operator||=
literal|0x0100
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SVSAT
case|:
comment|/* set chroma V saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|e_control
operator|&
literal|0xfe
expr_stmt|;
name|temp1
operator|=
name|bt848
operator|->
name|o_control
operator|&
literal|0xfe
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
literal|0x100
condition|)
block|{
name|temp
operator||=
literal|0x01
expr_stmt|;
name|temp1
operator||=
literal|0x01
expr_stmt|;
block|}
name|bt848
operator|->
name|sat_v_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|=
name|temp
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GVSAT
case|:
comment|/* get chroma V saturation */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|bt848
operator|->
name|sat_v_lo
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
literal|0x01
condition|)
name|tmp_int
operator||=
literal|0x0100
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SUSAT
case|:
comment|/* set chroma U saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|e_control
operator|&
literal|0xfd
expr_stmt|;
name|temp1
operator|=
name|bt848
operator|->
name|o_control
operator|&
literal|0xfd
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
literal|0x100
condition|)
block|{
name|temp
operator||=
literal|0x02
expr_stmt|;
name|temp1
operator||=
literal|0x02
expr_stmt|;
block|}
name|bt848
operator|->
name|sat_u_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|=
name|temp
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GUSAT
case|:
comment|/* get chroma U saturation */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|bt848
operator|->
name|sat_u_lo
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
literal|0x02
condition|)
name|tmp_int
operator||=
literal|0x0100
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SCONT
case|:
comment|/* set contrast */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|e_control
operator|&
literal|0xfb
expr_stmt|;
name|temp1
operator|=
name|bt848
operator|->
name|o_control
operator|&
literal|0xfb
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
literal|0x100
condition|)
block|{
name|temp
operator||=
literal|0x04
expr_stmt|;
name|temp1
operator||=
literal|0x04
expr_stmt|;
block|}
name|bt848
operator|->
name|contrast_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|=
name|temp
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GCONT
case|:
comment|/* get contrast */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|bt848
operator|->
name|contrast_lo
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
literal|0x04
condition|)
name|tmp_int
operator||=
literal|0x0100
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
case|case
name|BT848_SCBARS
case|:
comment|/* set colorbar output */
name|bt848
operator|->
name|color_ctl
operator||=
literal|0x40
expr_stmt|;
break|break;
case|case
name|BT848_CCBARS
case|:
comment|/* clear colorbar output */
name|bt848
operator|->
name|color_ctl
operator|&=
operator|~
literal|0x40
expr_stmt|;
break|break;
case|case
name|BT848_GAUDIO
case|:
comment|/* get audio channel */
name|temp
operator|=
name|bktr
operator|->
name|audio_mux_select
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|audio_mute_state
operator|==
name|TRUE
condition|)
name|temp
operator||=
name|AUDIO_MUTE
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|BT848_SBTSC
case|:
comment|/* set audio channel */
if|if
condition|(
name|set_BTSC
argument_list|(
name|bktr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
operator|<
literal|0
condition|)
return|return
name|EIO
return|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|EEPROM_SUPPORT
argument_list|)
case|case
name|BT848_WEEPROM
case|:
comment|/* write eeprom */
return|return
name|EINVAL
return|;
case|case
name|BT848_REEPROM
case|:
comment|/* read eeprom */
name|offset
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|offset
operator|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
operator|)
expr_stmt|;
name|buf
operator|=
operator|&
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|readEEProm
argument_list|(
name|bktr
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
name|EIO
return|;
break|break;
endif|#
directive|endif
comment|/* EEPROM_SUPPORT */
default|default:
return|return
name|common_ioctl
argument_list|(
name|bktr
argument_list|,
name|bt848
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * common ioctls  */
end_comment

begin_function
name|int
name|common_ioctl
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|bt848_reg_t
name|bt848
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|METEORSINPUT
case|:
comment|/* set input device */
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|METEOR_DEV_MASK
condition|)
block|{
comment|/* this is the RCA video input */
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_INPUT_DEV0
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV0
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
literal|0x60
expr_stmt|;
name|bt848
operator|->
name|iform
operator||=
literal|0x60
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
literal|0x40
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|&=
operator|~
literal|0x40
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_EXTERN
argument_list|)
expr_stmt|;
break|break;
comment|/* this is the tuner input */
case|case
name|METEOR_INPUT_DEV1
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV1
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
literal|0x60
expr_stmt|;
name|bt848
operator|->
name|iform
operator||=
literal|0x40
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
literal|0x40
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|&=
operator|~
literal|0x40
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_TUNER
argument_list|)
expr_stmt|;
break|break;
comment|/* this is the S-VHS input */
case|case
name|METEOR_INPUT_DEV2
case|:
case|case
name|METEOR_INPUT_DEV_SVIDEO
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV2
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
literal|0x60
expr_stmt|;
name|bt848
operator|->
name|iform
operator||=
literal|0x20
expr_stmt|;
name|bt848
operator|->
name|e_control
operator||=
literal|0x40
expr_stmt|;
name|bt848
operator|->
name|o_control
operator||=
literal|0x40
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_EXTERN
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
break|break;
case|case
name|METEORGINPUT
case|:
comment|/* get input device */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|flags
operator|&
name|METEOR_DEV_MASK
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|STATUS
argument_list|)
case|case
name|BT848_GSTATUS
case|:
comment|/* reap status */
name|disable_intr
argument_list|()
expr_stmt|;
name|temp
operator|=
name|status_sum
expr_stmt|;
name|status_sum
operator|=
literal|0
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* STATUS */
default|default:
return|return
name|ENODEV
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_mmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|bktr_reg_t
modifier|*
name|bktr
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
operator|||
name|minor
argument_list|(
name|dev
argument_list|)
operator|>
literal|0
condition|)
comment|/* at this point could this happen? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|offset
operator|>=
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i386_btop
argument_list|(
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * bt848 RISC programming routines:  */
end_comment

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|dump_bt848
parameter_list|(
name|bt848_reg_t
name|bt848
parameter_list|)
block|{
specifier|volatile
name|u_char
modifier|*
name|bt848r
init|=
operator|(
name|u_char
operator|*
operator|)
name|bt848
decl_stmt|;
name|int
name|r
index|[
literal|60
index|]
init|=
block|{
literal|4
block|,
literal|8
block|,
literal|0xc
block|,
literal|0x8c
block|,
literal|0x10
block|,
literal|0x90
block|,
literal|0x14
block|,
literal|0x94
block|,
literal|0x18
block|,
literal|0x98
block|,
literal|0x1c
block|,
literal|0x9c
block|,
literal|0x20
block|,
literal|0xa0
block|,
literal|0x24
block|,
literal|0xa4
block|,
literal|0x28
block|,
literal|0x2c
block|,
literal|0xac
block|,
literal|0x30
block|,
literal|0x34
block|,
literal|0x38
block|,
literal|0x3c
block|,
literal|0x40
block|,
literal|0xc0
block|,
literal|0x48
block|,
literal|0x4c
block|,
literal|0xcc
block|,
literal|0x50
block|,
literal|0xd0
block|,
literal|0xd4
block|,
literal|0x60
block|,
literal|0x64
block|,
literal|0x68
block|,
literal|0x6c
block|,
literal|0xec
block|,
literal|0xd8
block|,
literal|0xdc
block|,
literal|0xe0
block|,
literal|0xe4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|40
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|printf
argument_list|(
literal|" Reg:value : \t%x:%x \t%x:%x \t %x:%x \t %x:%x\n"
argument_list|,
name|r
index|[
name|i
index|]
argument_list|,
name|bt848r
index|[
name|r
index|[
name|i
index|]
index|]
argument_list|,
name|r
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|bt848r
index|[
name|r
index|[
name|i
operator|+
literal|1
index|]
index|]
argument_list|,
name|r
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|bt848r
index|[
name|r
index|[
name|i
operator|+
literal|2
index|]
index|]
argument_list|,
name|r
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|bt848r
index|[
name|r
index|[
name|i
operator|+
literal|3
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" INT STAT %x \n"
argument_list|,
name|bt848
operator|->
name|int_stat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Reg INT_MASK %x \n"
argument_list|,
name|bt848
operator|->
name|int_mask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Reg GPIO_DMA_CTL %x \n"
argument_list|,
name|bt848
operator|->
name|gpio_dma_ctl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * build write instruction  */
end_comment

begin_define
define|#
directive|define
name|BKTR_FM1
value|0x6
end_define

begin_define
define|#
directive|define
name|BKTR_FM3
value|0xe
end_define

begin_define
define|#
directive|define
name|BKTR_VRE
value|0x4
end_define

begin_define
define|#
directive|define
name|BKTR_VRO
value|0xC
end_define

begin_define
define|#
directive|define
name|BKTR_PXV
value|0x0
end_define

begin_define
define|#
directive|define
name|BKTR_EOL
value|0x1
end_define

begin_define
define|#
directive|define
name|BKTR_SOL
value|0x2
end_define

begin_define
define|#
directive|define
name|OP_WRITE
value|(0x1<< 28)
end_define

begin_define
define|#
directive|define
name|OP_WRITEC
value|(0x5<< 28)
end_define

begin_define
define|#
directive|define
name|OP_JUMP
value|(0x7<< 28)
end_define

begin_define
define|#
directive|define
name|OP_SYNC
value|(0x8<< 28)
end_define

begin_define
define|#
directive|define
name|OP_WRITE123
value|(0x9<< 28)
end_define

begin_define
define|#
directive|define
name|OP_WRITES123
value|(0xb<< 28)
end_define

begin_define
define|#
directive|define
name|OP_SOL
value|(1<< 27)
end_define

begin_define
define|#
directive|define
name|OP_EOL
value|(1<< 26)
end_define

begin_function
specifier|static
name|void
name|rgb_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|pixel_width
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
name|bt848_reg_t
name|bt848
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst2
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst3
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|buffer
decl_stmt|;
specifier|volatile
name|u_long
name|pitch
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|,
modifier|*
name|t_test
decl_stmt|;
name|int
name|b
decl_stmt|,
name|c
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* color format : rgb32 */
if|if
condition|(
name|bktr
operator|->
name|depth
operator|==
literal|4
condition|)
name|bt848
operator|->
name|color_fmt
operator|=
literal|0
expr_stmt|;
else|else
name|bt848
operator|->
name|color_fmt
operator|=
literal|0x33
expr_stmt|;
name|bt848
operator|->
name|color_ctl
operator|=
literal|0x40
expr_stmt|;
name|bt848
operator|->
name|color_ctl
operator|=
literal|0x10
expr_stmt|;
if|#
directive|if
literal|0
block|bt848->e_vdelay_low = 0x1C; 	bt848->o_vdelay_low = 0x1C;
endif|#
directive|endif
name|bt848
operator|->
name|vbi_pack_size
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|vbi_pack_del
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|adc
operator|=
name|SYNC_LEVEL
expr_stmt|;
name|bt848
operator|->
name|color_ctl
operator|=
literal|0x20
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator||=
literal|0xc0
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator||=
literal|0xc0
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|3
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
comment|/* Construct Write */
name|bt_enable_cnt
operator|=
literal|0
expr_stmt|;
name|b
operator|=
operator|(
name|cols
operator|*
name|pixel_width
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* write, sol, eol */
name|inst
operator|=
name|OP_WRITE
operator||
name|OP_SOL
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|b
operator|)
expr_stmt|;
name|inst2
operator|=
name|OP_WRITE
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|*
name|pixel_width
operator|/
literal|2
operator|)
expr_stmt|;
comment|/* write , sol, eol */
name|inst3
operator|=
name|OP_WRITE
operator||
name|OP_EOL
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|b
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
name|pitch
operator|=
name|bktr
operator|->
name|video
operator|.
name|width
expr_stmt|;
block|}
else|else
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|pitch
operator|=
name|cols
operator|*
name|pixel_width
expr_stmt|;
block|}
name|buffer
operator|=
name|target_buffer
expr_stmt|;
comment|/* contruct sync : for video packet format */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
comment|/* sync, mode indicator packed data */
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
operator|+
name|b
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|pitch
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xC
operator|<<
literal|24
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|20
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xc
operator|<<
literal|24
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|buffer
operator|+
name|pitch
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
comment|/* sync vre IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xc
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
operator|+
name|b
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|pitch
expr_stmt|;
block|}
block|}
comment|/* sync vre IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xc
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xc
operator|<<
literal|24
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|void
name|yuvpack_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst2
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst3
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|buffer
decl_stmt|;
name|bt848_reg_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|int
name|b
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* color format : yuvpack */
name|bt848
operator|->
name|color_fmt
operator|=
literal|0x44
expr_stmt|;
name|bt848
operator|->
name|e_scloop
operator||=
literal|0x40
expr_stmt|;
comment|/* enable chroma comb */
name|bt848
operator|->
name|o_scloop
operator||=
literal|0x40
expr_stmt|;
name|bt848
operator|->
name|color_ctl
operator|=
literal|0x30
expr_stmt|;
name|bt848
operator|->
name|adc
operator|=
name|SYNC_LEVEL
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|5
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
comment|/* Construct Write */
name|bt_enable_cnt
operator|=
literal|0
expr_stmt|;
comment|/* write , sol, eol */
name|inst
operator|=
name|OP_WRITE
operator||
name|OP_SOL
operator||
literal|0xf
operator|<<
literal|16
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|*
literal|2
operator|)
expr_stmt|;
comment|/* write , sol, eol */
name|inst3
operator|=
name|OP_WRITE
operator||
name|OP_EOL
operator||
literal|0xf
operator|<<
literal|16
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|)
expr_stmt|;
name|inst2
operator|=
name|OP_WRITE
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
else|else
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|target_buffer
expr_stmt|;
comment|/* contruct sync : for video packet format */
comment|/* sync, mode indicator packed data */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|b
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
operator|+
name|b
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
operator|(
name|cols
operator|*
literal|2
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|20
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|0xf
operator|<<
literal|16
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|buffer
operator|+
name|cols
operator|*
literal|2
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|0xf
operator|<<
literal|16
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
operator|+
name|b
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
operator|(
name|cols
operator|*
literal|2
operator|)
expr_stmt|;
block|}
block|}
comment|/* sync vre IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|0xf
operator|<<
literal|16
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xf
operator|<<
literal|16
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|void
name|yuv422_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst2
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|instskip
decl_stmt|,
name|instskip2
decl_stmt|,
name|instskip3
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst3
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|t1
decl_stmt|,
name|buffer
decl_stmt|;
name|bt848_reg_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|int
name|b
decl_stmt|,
name|b1
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|3
expr_stmt|;
name|bt848
operator|->
name|adc
operator|=
name|SYNC_LEVEL
expr_stmt|;
name|bt848
operator|->
name|oform
operator|=
literal|0x00
expr_stmt|;
name|bt848
operator|->
name|e_control
operator||=
literal|0x20
expr_stmt|;
comment|/* disable luma decimation */
name|bt848
operator|->
name|o_control
operator||=
literal|0x20
expr_stmt|;
name|bt848
operator|->
name|e_scloop
operator||=
literal|0x40
expr_stmt|;
comment|/* chroma agc enable */
name|bt848
operator|->
name|o_scloop
operator||=
literal|0x40
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator||=
literal|0xc0
expr_stmt|;
comment|/* luma comb and comb enable */
name|bt848
operator|->
name|o_vscale_hi
operator||=
literal|0xc0
expr_stmt|;
name|bt848
operator|->
name|color_fmt
operator|=
literal|0x88
expr_stmt|;
name|bt848
operator|->
name|color_ctl
operator|=
literal|0x10
expr_stmt|;
comment|/* disable gamma correction */
name|bt_enable_cnt
operator|=
literal|0
expr_stmt|;
comment|/* Construct Write */
name|inst
operator|=
name|OP_WRITE123
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|)
expr_stmt|;
name|inst2
operator|=
name|OP_WRITES123
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
else|else
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|target_buffer
expr_stmt|;
name|t1
operator|=
name|target_buffer
expr_stmt|;
comment|/* contruct sync : for video packet format */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM3
expr_stmt|;
comment|/*sync, mode indicator packed data*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
name|cols
operator|/
literal|2
operator|<<
literal|16
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
operator|(
name|cols
operator|*
name|rows
operator|/
literal|2
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
comment|/*sync vre*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xc
operator|<<
literal|24
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
break|break;
case|case
literal|2
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRO
expr_stmt|;
comment|/*sync vre*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
break|break;
case|case
literal|3
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xc
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xc
operator|<<
literal|24
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|buffer
operator|+
name|cols
expr_stmt|;
name|t1
operator|=
name|target_buffer
operator|+
name|cols
operator|/
literal|2
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xc
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
name|cols
operator|/
literal|2
operator|<<
literal|16
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
operator|(
name|cols
operator|*
name|rows
operator|/
literal|2
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
block|}
block|}
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xC
operator|<<
literal|24
expr_stmt|;
empty_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|void
name|build_dma_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|pixel_width
decl_stmt|,
name|rows
decl_stmt|,
name|cols
decl_stmt|,
name|byte_count
decl_stmt|,
name|interlace
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst2
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst3
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|;
name|bt848_reg_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|int
name|b
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|&=
operator|~
literal|3
expr_stmt|;
comment|/* capture control */
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
literal|0x11
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
literal|0x11
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|interlace
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
literal|0x12
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
literal|0x12
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|interlace
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
literal|0x13
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
literal|0x13
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator||=
literal|0x20
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator||=
literal|0x20
expr_stmt|;
name|interlace
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|bt848
operator|->
name|risc_strt_add
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
name|pixel_width
operator|=
name|bktr
operator|->
name|depth
expr_stmt|;
name|rows
operator|=
name|bktr
operator|->
name|rows
expr_stmt|;
name|cols
operator|=
name|bktr
operator|->
name|cols
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|format
operator|==
name|METEOR_GEO_RGB24
operator|||
name|bktr
operator|->
name|format
operator|==
name|METEOR_GEO_RGB16
condition|)
block|{
name|rgb_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|pixel_width
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bktr
operator|->
name|format
operator|==
name|METEOR_GEO_YUV_422
condition|)
block|{
name|yuv422_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bktr
operator|->
name|format
operator|==
name|METEOR_GEO_YUV_PACKED
condition|)
block|{
name|yuvpack_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * video& video capture specific routines:  */
end_comment

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|void
name|start_capture
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|unsigned
name|type
parameter_list|)
block|{
name|bt848_reg_t
name|bt848
decl_stmt|;
name|u_char
name|i_flag
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|dstatus
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|bt848
operator|->
name|int_stat
expr_stmt|;
name|bktr
operator|->
name|flags
operator||=
name|type
expr_stmt|;
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
name|i_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
name|i_flag
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
name|i_flag
operator|=
literal|3
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|bktr
operator|->
name|dma_prog_loaded
condition|)
block|{
name|build_dma_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
literal|1
expr_stmt|;
block|}
comment|/*XXX 	switch(bktr->flags& METEOR_ONLY_FIELDS_MASK) { 	default: 	*bts_reg |= 0xb;   bts_reg never been initialized! 	} */
name|bt848
operator|->
name|risc_strt_add
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
comment|/*XXX 	bt848->gpio_dma_ctl = 0x3; */
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|void
name|set_fps
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|u_short
name|fps
parameter_list|)
block|{
name|bt848_reg_t
name|bt848
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
literal|0xffffffff
expr_stmt|;
name|bktr
operator|->
name|fps
operator|=
name|fps
expr_stmt|;
if|if
condition|(
name|fps
operator|==
literal|30
condition|)
block|{
name|bt848
operator|->
name|tdec
operator|=
literal|0
expr_stmt|;
return|return;
block|}
else|else
block|{
name|bt848
operator|->
name|tdec
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|float
operator|)
name|fps
operator|/
literal|30.0
operator|)
operator|*
literal|60.0
argument_list|)
operator|&
literal|0x3f
expr_stmt|;
name|bt848
operator|->
name|tdec
operator||=
literal|0x80
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
block|{
name|bt848
operator|->
name|int_stat
operator|=
literal|0xffffffff
expr_stmt|;
name|bt848
operator|->
name|risc_strt_add
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
literal|1
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
literal|1
operator|<<
literal|11
operator||
literal|2
operator||
literal|1
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * There is also a problem with range checking on the 7116.  * It seems to only work for 22 bits, so the max size we can allocate  * is 22 bits long or 4194304 bytes assuming that we put the beginning  * of the buffer on a 2^24 bit boundary.  The range registers will use  * the top 8 bits of the dma start registers along with the bottom 22  * bits of the range register to determine if we go out of range.  * This makes getting memory a real kludge.  *  */
end_comment

begin_define
define|#
directive|define
name|RANGE_BOUNDARY
value|(1<<22)
end_define

begin_function
specifier|static
name|vm_offset_t
name|get_bktr_mem
parameter_list|(
name|int
name|unit
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|vm_offset_t
name|addr
init|=
literal|0
decl_stmt|;
name|addr
operator|=
name|vm_page_alloc_contig
argument_list|(
name|size
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
literal|1
operator|<<
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|vm_page_alloc_contig
argument_list|(
name|size
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"meteor%d: Unable to allocate %d bytes of memory.\n"
argument_list|,
name|unit
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * i2c primitives:  */
end_comment

begin_typedef
typedef|typedef
specifier|volatile
name|u_long
modifier|*
name|i2c_regptr_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|I2C_REGADDR
parameter_list|()
value|((i2c_regptr_t)&bktr->base->i2c_data_ctl)
end_define

begin_define
define|#
directive|define
name|RACK
value|(1<< 25)
end_define

begin_define
define|#
directive|define
name|I2CDONE
value|(1<< 8)
end_define

begin_define
define|#
directive|define
name|I2CDIV
value|(0x0f<< 4)
end_define

begin_define
define|#
directive|define
name|I2CBITTIME
value|(0x05<< 4)
end_define

begin_define
define|#
directive|define
name|I2CSYNC
value|(0x01<< 3)
end_define

begin_define
define|#
directive|define
name|I2CW3B
value|(0x01<< 2)
end_define

begin_define
define|#
directive|define
name|I2CSCL
value|(0x01<< 1)
end_define

begin_define
define|#
directive|define
name|I2CSDA
value|(0x01<< 0)
end_define

begin_define
define|#
directive|define
name|I2C_READ
value|0x01
end_define

begin_define
define|#
directive|define
name|I2C_COMMAND
value|(I2CBITTIME | I2CSCL | I2CSDA)
end_define

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|i2cWrite
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|byte1
parameter_list|,
name|int
name|byte2
parameter_list|)
block|{
name|u_long
name|x
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|i2c_regptr_t
name|bti2c
decl_stmt|;
comment|/* setup register addresses */
name|bti2c
operator|=
name|I2C_REGADDR
argument_list|()
expr_stmt|;
comment|/* clear status bits */
name|bktr
operator|->
name|base
operator|->
name|int_stat
operator|=
operator|(
name|RACK
operator||
name|I2CDONE
operator|)
expr_stmt|;
comment|/* build the command datum */
name|data
operator|=
operator|(
operator|(
name|addr
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|byte1
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
name|I2C_COMMAND
expr_stmt|;
if|if
condition|(
name|byte2
operator|!=
operator|-
literal|1
condition|)
block|{
name|data
operator||=
operator|(
operator|(
name|byte2
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|data
operator||=
name|I2CW3B
expr_stmt|;
block|}
comment|/* write the address and data */
operator|*
name|bti2c
operator|=
name|data
expr_stmt|;
comment|/* wait for completion */
for|for
control|(
name|x
operator|=
literal|0xffffffff
init|;
name|x
condition|;
operator|--
name|x
control|)
block|{
comment|/* safety valve */
if|if
condition|(
name|bktr
operator|->
name|base
operator|->
name|int_stat
operator|&
name|I2CDONE
condition|)
break|break;
block|}
comment|/* check for ACK */
if|if
condition|(
operator|!
name|x
operator|||
operator|!
operator|(
name|bktr
operator|->
name|base
operator|->
name|int_stat
operator|&
name|RACK
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* return OK */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|i2cRead
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|u_long
name|x
decl_stmt|;
name|i2c_regptr_t
name|bti2c
decl_stmt|;
comment|/* setup register addresses */
name|bti2c
operator|=
name|I2C_REGADDR
argument_list|()
expr_stmt|;
comment|/* clear status bits */
name|bktr
operator|->
name|base
operator|->
name|int_stat
operator|=
operator|(
name|RACK
operator||
name|I2CDONE
operator|)
expr_stmt|;
comment|/* write the READ address */
operator|*
name|bti2c
operator|=
operator|(
operator|(
name|addr
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
name|I2C_COMMAND
expr_stmt|;
comment|/* wait for completion */
for|for
control|(
name|x
operator|=
literal|0xffffffff
init|;
name|x
condition|;
operator|--
name|x
control|)
block|{
comment|/* safety valve */
if|if
condition|(
name|bktr
operator|->
name|base
operator|->
name|int_stat
operator|&
name|I2CDONE
condition|)
break|break;
block|}
comment|/* check for ACK */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|base
operator|->
name|int_stat
operator|&
name|RACK
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* it was a read */
return|return
operator|(
operator|*
name|bti2c
operator|>>
literal|8
operator|)
operator|&
literal|0xff
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|I2C_SOFTWARE_PROBE
argument_list|)
end_if

begin_comment
comment|/*  * we are keeping this around for any parts that we need to probe  * but that CANNOT be probed via an i2c read.  * this is necessary because the hardware i2c mechanism  * cannot be programmed for 1 byte writes.  * currently there are no known i2c parts that we need to probe  * and that cannot be safely read.  */
end_comment

begin_function_decl
specifier|static
name|int
name|i2cProbe
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|,
name|int
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BITDELAY
value|40
end_define

begin_define
define|#
directive|define
name|EXTRA_START
end_define

begin_comment
comment|/*  * probe for an I2C device at addr.  */
end_comment

begin_function
specifier|static
name|int
name|i2cProbe
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|status
decl_stmt|;
comment|/* the START */
if|#
directive|if
name|defined
argument_list|(
name|EXTRA_START
argument_list|)
operator|*
name|bti2c
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* release data */
operator|*
name|bti2c
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* release clock */
endif|#
directive|endif
comment|/* EXTRA_START */
operator|*
name|bti2c
operator|=
literal|2
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* lower data */
operator|*
name|bti2c
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* lower clock */
comment|/* write addr */
for|for
control|(
name|x
operator|=
literal|7
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
block|{
if|if
condition|(
name|addr
operator|&
operator|(
literal|1
operator|<<
name|x
operator|)
condition|)
block|{
operator|*
name|bti2c
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* assert HI data */
operator|*
name|bti2c
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* strobe clock */
operator|*
name|bti2c
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
else|else
block|{
operator|*
name|bti2c
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* assert LO data */
operator|*
name|bti2c
operator|=
literal|2
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* strobe clock */
operator|*
name|bti2c
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
block|}
comment|/* look for an ACK */
operator|*
name|bti2c
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* float data */
operator|*
name|bti2c
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|status
operator|=
operator|*
name|bti2c
operator|&
literal|1
expr_stmt|;
comment|/* read the ACK bit */
operator|*
name|bti2c
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* release clock */
comment|/* the STOP */
operator|*
name|bti2c
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* lower clock& data */
operator|*
name|bti2c
operator|=
literal|2
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* release clock */
operator|*
name|bti2c
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITDELAY
argument_list|)
expr_stmt|;
comment|/* release data */
return|return
name|status
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|EXTRA_START
end_undef

begin_undef
undef|#
directive|undef
name|BITDELAY
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I2C_SOFTWARE_PROBE */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EEPROM_SUPPORT
argument_list|)
end_if

begin_function
specifier|static
name|int
name|readEEProm
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|max
decl_stmt|;
name|int
name|byte
decl_stmt|;
comment|/* get the address of the EEProm */
name|addr
operator|=
call|(
name|int
call|)
argument_list|(
name|bktr
operator|->
name|card
operator|->
name|eepromAddr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|max
operator|=
call|(
name|int
call|)
argument_list|(
name|bktr
operator|->
name|card
operator|->
name|eepromSize
operator|*
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|+
name|count
operator|)
operator|>
name|max
condition|)
return|return
operator|-
literal|1
return|;
comment|/* set the start address */
if|if
condition|(
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* the read cycle */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|(
name|byte
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
operator|(
name|addr
operator||
literal|1
operator|)
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|data
index|[
name|x
index|]
operator|=
name|byte
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EEPROM_SUPPORT */
end_comment

begin_comment
comment|/******************************************************************************  * card probe  */
end_comment

begin_comment
comment|/*  * the data for each type of card  */
end_comment

begin_define
define|#
directive|define
name|NO_TUNER
value|0
end_define

begin_define
define|#
directive|define
name|TEMIC_TUNER
value|1
end_define

begin_define
define|#
directive|define
name|PHILIPS_TUNER
value|2
end_define

begin_comment
comment|/*  * Note:  *   these entried MUST be kept in the order defined by the CARD_XXX defines!  */
end_comment

begin_decl_stmt
name|struct
name|CARDTYPE
name|card_types
index|[]
init|=
block|{
comment|/* CARD_UNKNOWN */
block|{
literal|"Unknown"
block|,
name|NO_TUNER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
comment|/* CARD_MIRO */
block|{
literal|"Miro TV"
block|,
name|NO_TUNER
block|,
comment|/** TEMIC_TUNER ??? */
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0x02
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|/* XXX ??? */
comment|/* CARD_HAUPPAUGE */
block|{
literal|"Hauppauge WinCast/TV"
block|,
name|PHILIPS_TUNER
block|,
literal|0
block|,
name|PFC8582_WADDR
block|,
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
block|,
comment|/* 256 bytes */
block|{
literal|0x00
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0x01
block|}
block|}
block|,
comment|/* CARD_STB */
block|{
literal|"STB TV/PCI"
block|,
name|TEMIC_TUNER
block|,
literal|0
block|,
name|X24C01_WADDR
block|,
call|(
name|u_char
call|)
argument_list|(
literal|128
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
block|,
comment|/* 128 bytes */
block|{
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x02
block|}
block|}
block|,
comment|/* CARD_INTEL */
block|{
literal|"Intel Smart Video III"
block|,
name|NO_TUNER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If probe_card() fails to detect the proper card on boot you can  * override it by setting the following define to the card you are using:  * #define OVERRIDE_CARD<card type>  *  * where<card type> is one of the card defines in the above array.  */
end_comment

begin_define
define|#
directive|define
name|ABSENT
value|(-1)
end_define

begin_function
specifier|static
name|int
name|probe_card
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OVERRIDE_CARD
argument_list|)
name|bktr
operator|->
name|card_type
operator|=
name|OVERRIDE_CARD
expr_stmt|;
name|bktr
operator|->
name|card
operator|=
operator|&
operator|(
name|card_types
index|[
name|bktr
operator|->
name|card_type
index|]
operator|)
expr_stmt|;
goto|goto
name|end
goto|;
endif|#
directive|endif
comment|/* look for a tuner */
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|TSA5522_RADDR
argument_list|)
operator|==
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card_type
operator|=
name|CARD_INTEL
expr_stmt|;
name|bktr
operator|->
name|card
operator|=
operator|&
operator|(
name|card_types
index|[
name|bktr
operator|->
name|card_type
index|]
operator|)
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
comment|/* look for a hauppauge card */
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|PFC8582_RADDR
argument_list|)
operator|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card_type
operator|=
name|CARD_HAUPPAUGE
expr_stmt|;
name|bktr
operator|->
name|card
operator|=
operator|&
operator|(
name|card_types
index|[
name|bktr
operator|->
name|card_type
index|]
operator|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
comment|/* look for an STB card */
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|X24C01_RADDR
argument_list|)
operator|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card_type
operator|=
name|CARD_STB
expr_stmt|;
name|bktr
operator|->
name|card
operator|=
operator|&
operator|(
name|card_types
index|[
name|bktr
operator|->
name|card_type
index|]
operator|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
comment|/* XXX FIXME: (how do I) look for a Miro card */
name|bktr
operator|->
name|card_type
operator|=
name|CARD_MIRO
expr_stmt|;
name|bktr
operator|->
name|card
operator|=
operator|&
operator|(
name|card_types
index|[
name|bktr
operator|->
name|card_type
index|]
operator|)
expr_stmt|;
name|checkTuner
label|:
comment|/* differentiate TEMIC vs. PHILIPS tuners */
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|TEMIC_TSA5522_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card
operator|->
name|tuner
operator|=
name|TEMIC_TUNER
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_TSA5523_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card
operator|->
name|tuner
operator|=
name|PHILIPS_TUNER
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
comment|/* no tuner found */
name|bktr
operator|->
name|card
operator|->
name|tuner
operator|=
name|NO_TUNER
expr_stmt|;
name|checkDBX
label|:
comment|/* probe for BTSC (dbx) chips */
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|TDA9850_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
name|bktr
operator|->
name|card
operator|->
name|dbx
operator|=
literal|1
expr_stmt|;
name|end
label|:
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|bktr
operator|->
name|card
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|card
operator|->
name|tuner
condition|)
name|printf
argument_list|(
literal|", %s tuner"
argument_list|,
name|bktr
operator|->
name|card
operator|->
name|tuner
operator|==
name|TEMIC_TUNER
condition|?
literal|"Temic"
else|:
literal|"Philips"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|card
operator|->
name|dbx
condition|)
name|printf
argument_list|(
literal|", dbx stereo"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|bktr
operator|->
name|card_type
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|ABSENT
end_undef

begin_define
define|#
directive|define
name|TSA5522_BANDA
value|band_addrs[card_types[bktr->card_type].tuner-1][0]
end_define

begin_define
define|#
directive|define
name|TSA5522_BANDB
value|band_addrs[card_types[bktr->card_type].tuner-1][1]
end_define

begin_define
define|#
directive|define
name|TSA5522_BANDC
value|band_addrs[card_types[bktr->card_type].tuner-1][2]
end_define

begin_decl_stmt
name|u_char
name|band_addrs
index|[]
index|[
literal|3
index|]
init|=
block|{
comment|/* BANDA BANDB  BANDC */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|}
block|,
comment|/* TEMIC */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|}
comment|/* PHILIPS */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************  * tuner specific routines:  */
end_comment

begin_comment
comment|/*  * bit 7: CONTROL BYTE = 1  * bit 6: CP = 0		moderate speed tuning, better FM  * bit 5: T2 = 0		normal operation  * bit 4: T1 = 0		normal operation  * bit 3: T0 = 1		normal operation  * bit 2: RSA = 1		62.5kHz  * bit 1: RSB = 1		62.5kHz  * bit 0: OS = 0		normal operation  *  * FIXME: create defines for the above bitfields.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|TSA5522_CONTROL
value|0xce
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TSA5522_CONTROL
value|0x8e
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* scaling factor for frequencies expressed as ints */
end_comment

begin_define
define|#
directive|define
name|FREQFACTOR
value|16
end_define

begin_comment
comment|/*  * Format:  *	entry 0:         MAX legal channel  *	entry 1:         IF frequency  *			 expressed as fi{mHz} * 16,  *			 eg 45.75mHz == 45.75 * 16 = 732  *	entry 2:         [place holder/future]  *	entry 3:         base of channel record 0  *	entry 3 + (x*3): base of channel record 'x'  *	entry LAST:      NULL channel entry marking end of records  *  * Record:  *	int 0:		base channel  *	int 1:		frequency of base channel,  *			 expressed as fb{mHz} * 16,  *	int 2:		offset frequency between channels,  *			 expressed as fo{mHz} * 16,  */
end_comment

begin_comment
comment|/*  * North American Broadcast Channels:  *  *  2:  55.25 mHz -  4:  67.25 mHz  *  5:  77.25 mHz -  6:	 83.25 mHz  *  7: 175.25 mHz - 13:	211.25 mHz  * 14: 471.25 mHz - 83:	885.25 mHz  *  * IF freq: 45.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_decl_stmt
name|int
name|nabcst
index|[]
init|=
block|{
literal|83
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|55.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * North American Cable Channels, IRC:  *  *  2:  55.25 mHz -  4:  67.25 mHz  *  5:  77.25 mHz -  6:  83.25 mHz  *  7: 175.25 mHz - 13: 211.25 mHz  * 14: 121.25 mHz - 22: 169.25 mHz  * 23: 217.25 mHz - 94: 643.25 mHz  * 95:  91.25 mHz - 99: 115.25 mHz  *  * IF freq: 45.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_decl_stmt
name|int
name|irccable
index|[]
init|=
block|{
literal|99
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|95
block|,
call|(
name|int
call|)
argument_list|(
literal|91.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|23
block|,
call|(
name|int
call|)
argument_list|(
literal|217.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|121.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|55.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * North American Cable Channels, HRC:  *  */
end_comment

begin_decl_stmt
name|int
name|hrccable
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Western European channels:  *  */
end_comment

begin_decl_stmt
name|int
name|weurope
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|freqTable
index|[]
init|=
block|{
name|NULL
block|,
name|nabcst
block|,
name|irccable
block|,
name|hrccable
block|,
name|weurope
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TBL_CHNL
value|freqTable[ bktr->tuner.chnlset ][ x ]
end_define

begin_define
define|#
directive|define
name|TBL_BASE_FREQ
value|freqTable[ bktr->tuner.chnlset ][ x + 1 ]
end_define

begin_define
define|#
directive|define
name|TBL_OFFSET
value|freqTable[ bktr->tuner.chnlset ][ x + 2 ]
end_define

begin_function
specifier|static
name|int
name|frequency_lookup
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* check for "> MAX channel" */
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|channel
operator|>
name|TBL_CHNL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* search the table for data */
for|for
control|(
name|x
operator|=
literal|3
init|;
name|TBL_CHNL
condition|;
name|x
operator|+=
literal|3
control|)
block|{
if|if
condition|(
name|channel
operator|>=
name|TBL_CHNL
condition|)
block|{
return|return
operator|(
name|TBL_BASE_FREQ
operator|+
operator|(
operator|(
name|channel
operator|-
name|TBL_CHNL
operator|)
operator|*
name|TBL_OFFSET
operator|)
operator|)
return|;
block|}
block|}
comment|/* not found, must be below the MIN channel */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|TBL_OFFSET
end_undef

begin_undef
undef|#
directive|undef
name|TBL_BASE_FREQ
end_undef

begin_undef
undef|#
directive|undef
name|TBL_CHNL
end_undef

begin_define
define|#
directive|define
name|TBL_IF
value|freqTable[ bktr->tuner.chnlset ][ 1 ]
end_define

begin_comment
comment|/*  * set the frequency of the tuner  */
end_comment

begin_function
specifier|static
name|int
name|tv_freq
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|frequency
parameter_list|)
block|{
name|i2c_regptr_t
name|bti2c
decl_stmt|;
name|u_char
name|band
decl_stmt|;
name|int
name|N
decl_stmt|;
name|int
name|order
decl_stmt|;
comment|/* 	 * select the band based on frequency 	 * FIXME: do the cross-over points need to be set on a 	 * tuner by tuner basis? 	 */
if|if
condition|(
name|frequency
operator|<
operator|(
literal|160
operator|*
name|FREQFACTOR
operator|)
condition|)
name|band
operator|=
name|TSA5522_BANDA
expr_stmt|;
elseif|else
if|if
condition|(
name|frequency
operator|<
operator|(
literal|454
operator|*
name|FREQFACTOR
operator|)
condition|)
name|band
operator|=
name|TSA5522_BANDB
expr_stmt|;
else|else
name|band
operator|=
name|TSA5522_BANDC
expr_stmt|;
comment|/* 	 * N = 16 * { fRF(pc) + fIF(pc) } 	 * where: 	 *  pc is picture carrier, fRF& fIF are in mHz 	 * 	 * frequency was passed in as mHz * 16 	 */
name|N
operator|=
name|frequency
operator|+
name|TBL_IF
expr_stmt|;
if|if
condition|(
name|frequency
operator|>
name|bktr
operator|->
name|tuner
operator|.
name|frequency
condition|)
block|{
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|TSA5522_WADDR
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|TSA5522_WADDR
argument_list|,
name|TSA5522_CONTROL
argument_list|,
name|band
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|TSA5522_WADDR
argument_list|,
name|TSA5522_CONTROL
argument_list|,
name|band
argument_list|)
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|TSA5522_WADDR
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
comment|/* update frequency */
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
name|frequency
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|TBL_IF
end_undef

begin_comment
comment|/*  * set the channel of the tuner  */
end_comment

begin_function
specifier|static
name|int
name|tv_channel
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|int
name|frequency
decl_stmt|;
comment|/* calculate the frequency according to tuner type */
if|if
condition|(
operator|(
name|frequency
operator|=
name|frequency_lookup
argument_list|(
name|bktr
argument_list|,
name|channel
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* set the new frequency */
if|if
condition|(
name|tv_freq
argument_list|(
name|bktr
argument_list|,
name|frequency
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* OK to update records */
name|bktr
operator|->
name|tuner
operator|.
name|channel
operator|=
name|channel
expr_stmt|;
return|return
name|channel
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * audio specific routines:  */
end_comment

begin_comment
comment|/*  *   */
end_comment

begin_define
define|#
directive|define
name|AUDIOMUX_DISCOVER_NOT
end_define

begin_function
specifier|static
name|int
name|set_audio
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|bt848_reg_t
name|bt848
decl_stmt|;
name|u_long
name|temp
decl_stmt|;
specifier|volatile
name|u_char
name|idx
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AUDIOMUX_DISCOVER
argument_list|)
if|if
condition|(
name|cmd
operator|>=
literal|200
condition|)
name|cmd
operator|-=
literal|200
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* AUDIOMUX_DISCOVER */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|AUDIO_TUNER
case|:
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDIO_EXTERN
case|:
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AUDIO_INTERN
case|:
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|AUDIO_MUTE
case|:
name|bktr
operator|->
name|audio_mute_state
operator|=
name|TRUE
expr_stmt|;
comment|/* set mute */
break|break;
case|case
name|AUDIO_UNMUTE
case|:
name|bktr
operator|->
name|audio_mute_state
operator|=
name|FALSE
expr_stmt|;
comment|/* clear mute */
break|break;
default|default:
name|printf
argument_list|(
literal|"bktr: audio cmd error %02x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* 	 * Leave the upper bits of the GPIO port alone in case they control 	 * something like the dbx or teletext chips.  This doesn't guarantee 	 * success, but follows the rule of least astonishment. 	 */
comment|/* this was an 8 bit reference before ?? */
name|bt848
operator|->
name|gpio_reg_inp
operator|=
operator|(
operator|~
name|GPIO_AUDIOMUX_BITS
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|audio_mute_state
operator|==
name|TRUE
condition|)
name|idx
operator|=
literal|3
expr_stmt|;
else|else
name|idx
operator|=
name|bktr
operator|->
name|audio_mux_select
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|gpio_data
operator|&
operator|~
name|GPIO_AUDIOMUX_BITS
expr_stmt|;
name|bt848
operator|->
name|gpio_data
operator|=
if|#
directive|if
name|defined
argument_list|(
name|AUDIOMUX_DISCOVER
argument_list|)
name|bt848
operator|->
name|gpio_data
operator|=
name|temp
operator||
operator|(
name|cmd
operator|&
literal|0xff
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"cmd: %d\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|#
directive|else
name|temp
operator||
name|bktr
operator|->
name|card
operator|->
name|audiomuxs
index|[
name|idx
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* AUDIOMUX_DISCOVER */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_define
define|#
directive|define
name|CON1ADDR
value|0x04
end_define

begin_define
define|#
directive|define
name|CON2ADDR
value|0x05
end_define

begin_define
define|#
directive|define
name|CON3ADDR
value|0x06
end_define

begin_define
define|#
directive|define
name|CON4ADDR
value|0x07
end_define

begin_function
specifier|static
name|int
name|set_BTSC
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|control
parameter_list|)
block|{
return|return
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|TDA9850_WADDR
argument_list|,
name|CON3ADDR
argument_list|,
name|control
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * magic:  */
end_comment

begin_expr_stmt
specifier|static
name|bktr_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|bktr_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|bktr_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|bktr_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bktr_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|bktrdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|bktr_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NBKTR> 0 */
end_comment

begin_comment
comment|/* Local Variables: */
end_comment

begin_comment
comment|/* mode: C */
end_comment

begin_comment
comment|/* c-indent-level: 8 */
end_comment

begin_comment
comment|/* c-brace-offset: -8 */
end_comment

begin_comment
comment|/* c-argdecl-indent: 8 */
end_comment

begin_comment
comment|/* c-label-offset: -8 */
end_comment

begin_comment
comment|/* c-continued-statement-offset: 8 */
end_comment

begin_comment
comment|/* c-tab-always-indent: nil */
end_comment

begin_comment
comment|/* End: */
end_comment

end_unit

