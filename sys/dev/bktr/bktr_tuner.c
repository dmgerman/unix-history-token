begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * This is part of the Driver for Video Capture Cards (Frame grabbers)  * and TV Tuner cards using the Brooktree Bt848, Bt848A, Bt849A, Bt878, Bt879  * chipset.  * Copyright Roger Hardiman and Amancio Hasty.  *  * bktr_tuner : This deals with controlling the tuner fitted to TV cards.  *  */
end_comment

begin_comment
comment|/*  * 1. Redistributions of source code must retain the  * Copyright (c) 1997 Amancio Hasty, 1999 Roger Hardiman  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Amancio Hasty and  *      Roger Hardiman  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<machine/ioctl_meteor.h>
end_include

begin_include
include|#
directive|include
file|<machine/ioctl_bt848.h>
end_include

begin_comment
comment|/* extensions to ioctl_meteor.h */
end_comment

begin_include
include|#
directive|include
file|<dev/bktr/bktr_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_tuner.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_card.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_core.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
end_if

begin_define
define|#
directive|define
name|AFC_DELAY
value|10000
end_define

begin_comment
comment|/* 10 millisend delay */
end_comment

begin_define
define|#
directive|define
name|AFC_BITS
value|0x07
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_MINUS_125
value|0x00
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_MINUS_62
value|0x01
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_CENTERED
value|0x02
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_PLUS_62
value|0x03
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_PLUS_125
value|0x04
end_define

begin_define
define|#
directive|define
name|AFC_MAX_STEP
value|(5 * FREQFACTOR)
end_define

begin_comment
comment|/* no more than 5 MHz */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TUNER_AFC */
end_comment

begin_define
define|#
directive|define
name|TTYPE_XXX
value|0
end_define

begin_define
define|#
directive|define
name|TTYPE_NTSC
value|1
end_define

begin_define
define|#
directive|define
name|TTYPE_NTSC_J
value|2
end_define

begin_define
define|#
directive|define
name|TTYPE_PAL
value|3
end_define

begin_define
define|#
directive|define
name|TTYPE_PAL_M
value|4
end_define

begin_define
define|#
directive|define
name|TTYPE_PAL_N
value|5
end_define

begin_define
define|#
directive|define
name|TTYPE_SECAM
value|6
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_MSB
value|(0x80)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_CP
value|(1<<6)
end_define

begin_comment
comment|/* set this for fast tuning */
end_comment

begin_define
define|#
directive|define
name|TSA552x_CB_T2
value|(1<<5)
end_define

begin_comment
comment|/* test mode - Normally set to 0 */
end_comment

begin_define
define|#
directive|define
name|TSA552x_CB_T1
value|(1<<4)
end_define

begin_comment
comment|/* test mode - Normally set to 0 */
end_comment

begin_define
define|#
directive|define
name|TSA552x_CB_T0
value|(1<<3)
end_define

begin_comment
comment|/* test mode - Normally set to 1 */
end_comment

begin_define
define|#
directive|define
name|TSA552x_CB_RSA
value|(1<<2)
end_define

begin_comment
comment|/* 0 for 31.25 khz, 1 for 62.5 kHz */
end_comment

begin_define
define|#
directive|define
name|TSA552x_CB_RSB
value|(1<<1)
end_define

begin_comment
comment|/* 0 for FM 50kHz steps, 1 = Use RSA*/
end_comment

begin_define
define|#
directive|define
name|TSA552x_CB_OS
value|(1<<0)
end_define

begin_comment
comment|/* Set to 0 for normal operation */
end_comment

begin_define
define|#
directive|define
name|TSA552x_RADIO
value|(TSA552x_CB_MSB |       \                                  TSA552x_CB_T0)
end_define

begin_comment
comment|/* raise the charge pump voltage for fast tuning */
end_comment

begin_define
define|#
directive|define
name|TSA552x_FCONTROL
value|(TSA552x_CB_MSB |       \                                  TSA552x_CB_CP  |       \                                  TSA552x_CB_T0  |       \                                  TSA552x_CB_RSA |       \                                  TSA552x_CB_RSB)
end_define

begin_comment
comment|/* lower the charge pump voltage for better residual oscillator FM */
end_comment

begin_define
define|#
directive|define
name|TSA552x_SCONTROL
value|(TSA552x_CB_MSB |       \                                  TSA552x_CB_T0  |       \                                  TSA552x_CB_RSA |       \                                  TSA552x_CB_RSB)
end_define

begin_comment
comment|/* The control value for the ALPS TSCH5 Tuner */
end_comment

begin_define
define|#
directive|define
name|TSCH5_FCONTROL
value|0x82
end_define

begin_define
define|#
directive|define
name|TSCH5_RADIO
value|0x86
end_define

begin_comment
comment|/* The control value for the ALPS TSBH1 Tuner */
end_comment

begin_define
define|#
directive|define
name|TSBH1_FCONTROL
value|0xce
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|TUNER
name|tuners
index|[]
init|=
block|{
comment|/* XXX FIXME: fill in the band-switch crosspoints */
comment|/* NO_TUNER */
block|{
literal|"<no>"
block|,
comment|/* the 'name' */
name|TTYPE_XXX
block|,
comment|/* input type */
block|{
literal|0x00
block|,
comment|/* control byte for Tuner PLL */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_NTSC */
block|{
literal|"Temic NTSC"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_PAL */
block|{
literal|"Temic PAL"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_SECAM */
block|{
literal|"Temic SECAM"
block|,
comment|/* the 'name' */
name|TTYPE_SECAM
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_NTSC */
block|{
literal|"Philips NTSC"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_PAL */
block|{
literal|"Philips PAL"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_SECAM */
block|{
literal|"Philips SECAM"
block|,
comment|/* the 'name' */
name|TTYPE_SECAM
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_PAL I */
block|{
literal|"Temic PAL I"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_PALI */
block|{
literal|"Philips PAL I"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_FR1236_NTSC */
block|{
literal|"Philips FR1236 NTSC FM"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSA552x_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_FCONTROL
block|,
name|TSA552x_FCONTROL
block|,
name|TSA552x_RADIO
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0xa4
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_FR1216_PAL */
block|{
literal|"Philips FR1216 PAL FM"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_FCONTROL
block|,
name|TSA552x_FCONTROL
block|,
name|TSA552x_RADIO
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0xa4
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_FR1236_SECAM */
block|{
literal|"Philips FR1236 SECAM FM"
block|,
comment|/* the 'name' */
name|TTYPE_SECAM
block|,
comment|/* input type */
block|{
name|TSA552x_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_FCONTROL
block|,
name|TSA552x_FCONTROL
block|,
name|TSA552x_RADIO
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0xa4
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* ALPS TSCH5 NTSC */
block|{
literal|"ALPS TSCH5 NTSC FM"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSCH5_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSCH5_FCONTROL
block|,
name|TSCH5_FCONTROL
block|,
name|TSCH5_RADIO
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x14
block|,
literal|0x12
block|,
literal|0x11
block|,
literal|0x04
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* ALPS TSBH1 NTSC */
block|{
literal|"ALPS TSBH1 NTSC"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSBH1_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSBH1_FCONTROL
block|,
name|TSBH1_FCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x08
block|,
literal|0x00
block|}
block|}
comment|/* the band-switch values */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scaling factor for frequencies expressed as ints */
end_comment

begin_define
define|#
directive|define
name|FREQFACTOR
value|16
end_define

begin_comment
comment|/*  * Format:  *	entry 0:         MAX legal channel  *	entry 1:         IF frequency  *			 expressed as fi{mHz} * 16,  *			 eg 45.75mHz == 45.75 * 16 = 732  *	entry 2:         [place holder/future]  *	entry 3:         base of channel record 0  *	entry 3 + (x*3): base of channel record 'x'  *	entry LAST:      NULL channel entry marking end of records  *  * Record:  *	int 0:		base channel  *	int 1:		frequency of base channel,  *			 expressed as fb{mHz} * 16,  *	int 2:		offset frequency between channels,  *			 expressed as fo{mHz} * 16,  */
end_comment

begin_comment
comment|/*  * North American Broadcast Channels:  *  *  2:  55.25 mHz -  4:  67.25 mHz  *  5:  77.25 mHz -  6:	 83.25 mHz  *  7: 175.25 mHz - 13:	211.25 mHz  * 14: 471.25 mHz - 83:	885.25 mHz  *  * IF freq: 45.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_decl_stmt
specifier|static
name|int
name|nabcst
index|[]
init|=
block|{
literal|83
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|55.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * North American Cable Channels, IRC:  *  *  2:  55.25 mHz -  4:  67.25 mHz  *  5:  77.25 mHz -  6:  83.25 mHz  *  7: 175.25 mHz - 13: 211.25 mHz  * 14: 121.25 mHz - 22: 169.25 mHz  * 23: 217.25 mHz - 94: 643.25 mHz  * 95:  91.25 mHz - 99: 115.25 mHz  *  * IF freq: 45.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_decl_stmt
specifier|static
name|int
name|irccable
index|[]
init|=
block|{
literal|99
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|95
block|,
call|(
name|int
call|)
argument_list|(
literal|91.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|23
block|,
call|(
name|int
call|)
argument_list|(
literal|217.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|121.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|55.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * North American Cable Channels, HRC:  *  * 2:   54 mHz  - 4:    66 mHz  * 5:   78 mHz  - 6:    84 mHz  * 7:  174 mHz  - 13:  210 mHz  * 14: 120 mHz  - 22:  168 mHz  * 23: 216 mHz  - 94:  642 mHz  * 95:  90 mHz  - 99:  114 mHz  *  * IF freq: 45.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_decl_stmt
specifier|static
name|int
name|hrccable
index|[]
init|=
block|{
literal|99
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|95
block|,
call|(
name|int
call|)
argument_list|(
literal|90.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|23
block|,
call|(
name|int
call|)
argument_list|(
literal|216.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|120.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|174.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|78.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|54.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * Western European broadcast channels:  *  * (there are others that appear to vary between countries - rmt)  *  * here's the table Philips provides:  * caution, some of the offsets don't compute...  *  *  1	 4525	700	N21  *   *  2	 4825	700	E2  *  3	 5525	700	E3  *  4	 6225	700	E4  *   *  5	17525	700	E5  *  6	18225	700	E6  *  7	18925	700	E7  *  8	19625	700	E8  *  9	20325	700	E9  * 10	21025	700	E10  * 11	21725	700	E11  * 12	22425	700	E12  *   * 13	 5375	700	ITA  * 14	 6225	700	ITB  *   * 15	 8225	700	ITC  *   * 16	17525	700	ITD  * 17	18325	700	ITE  *   * 18	19225	700	ITF  * 19	20125	700	ITG  * 20	21025	700	ITH  *   * 21	47125	800	E21  * 22	47925	800	E22  * 23	48725	800	E23  * 24	49525	800	E24  * 25	50325	800	E25  * 26	51125	800	E26  * 27	51925	800	E27  * 28	52725	800	E28  * 29	53525	800	E29  * 30	54325	800	E30  * 31	55125	800	E31  * 32	55925	800	E32  * 33	56725	800	E33  * 34	57525	800	E34  * 35	58325	800	E35  * 36	59125	800	E36  * 37	59925	800	E37  * 38	60725	800	E38  * 39	61525	800	E39  * 40	62325	800	E40  * 41	63125	800	E41  * 42	63925	800	E42  * 43	64725	800	E43  * 44	65525	800	E44  * 45	66325	800	E45  * 46	67125	800	E46  * 47	67925	800	E47  * 48	68725	800	E48  * 49	69525	800	E49  * 50	70325	800	E50  * 51	71125	800	E51  * 52	71925	800	E52  * 53	72725	800	E53  * 54	73525	800	E54  * 55	74325	800	E55  * 56	75125	800	E56  * 57	75925	800	E57  * 58	76725	800	E58  * 59	77525	800	E59  * 60	78325	800	E60  * 61	79125	800	E61  * 62	79925	800	E62  * 63	80725	800	E63  * 64	81525	800	E64  * 65	82325	800	E65  * 66	83125	800	E66  * 67	83925	800	E67  * 68	84725	800	E68  * 69	85525	800	E69  *   * 70	 4575	800	IA  * 71	 5375	800	IB  * 72	 6175	800	IC  *   * 74	 6925	700	S01  * 75	 7625	700	S02  * 76	 8325	700	S03  *   * 80	10525	700	S1  * 81	11225	700	S2  * 82	11925	700	S3  * 83	12625	700	S4  * 84	13325	700	S5  * 85	14025	700	S6  * 86	14725	700	S7  * 87	15425	700	S8  * 88	16125	700	S9  * 89	16825	700	S10  * 90	23125	700	S11  * 91	23825	700	S12  * 92	24525	700	S13  * 93	25225	700	S14  * 94	25925	700	S15  * 95	26625	700	S16  * 96	27325	700	S17  * 97	28025	700	S18  * 98	28725	700	S19  * 99	29425	700	S20  *  *  * Channels S21 - S41 are taken from  * http://gemma.apple.com:80/dev/technotes/tn/tn1012.html  *  * 100	30325	800	S21  * 101	31125	800	S22  * 102	31925	800	S23  * 103	32725	800	S24  * 104	33525	800	S25  * 105	34325	800	S26           * 106	35125	800	S27           * 107	35925	800	S28           * 108	36725	800	S29           * 109	37525	800	S30           * 110	38325	800	S31           * 111	39125	800	S32           * 112	39925	800	S33           * 113	40725	800	S34           * 114	41525	800	S35           * 115	42325	800	S36           * 116	43125	800	S37           * 117	43925	800	S38           * 118	44725	800	S39           * 119	45525	800	S40           * 120	46325	800	S41  *   * 121	 3890	000	IFFREQ  *   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|weurope
index|[]
init|=
block|{
literal|121
block|,
call|(
name|int
call|)
argument_list|(
literal|38.90
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|100
block|,
call|(
name|int
call|)
argument_list|(
literal|303.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|90
block|,
call|(
name|int
call|)
argument_list|(
literal|231.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|80
block|,
call|(
name|int
call|)
argument_list|(
literal|105.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|74
block|,
call|(
name|int
call|)
argument_list|(
literal|69.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|21
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|17
block|,
call|(
name|int
call|)
argument_list|(
literal|183.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|9.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|16
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|9.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|15
block|,
call|(
name|int
call|)
argument_list|(
literal|82.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.50
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|13
block|,
call|(
name|int
call|)
argument_list|(
literal|53.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.50
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|48.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Japanese Broadcast Channels:  *  *  1:  91.25MHz -  3: 103.25MHz  *  4: 171.25MHz -  7: 189.25MHz  *  8: 193.25MHz - 12: 217.25MHz  (VHF)  * 13: 471.25MHz - 62: 765.25MHz  (UHF)  *  * IF freq: 45.75 mHz  *  OR  * IF freq: 58.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_define
define|#
directive|define
name|IF_FREQ
value|45.75
end_define

begin_decl_stmt
specifier|static
name|int
name|jpnbcst
index|[]
init|=
block|{
literal|62
block|,
call|(
name|int
call|)
argument_list|(
name|IF_FREQ
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|13
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|8
block|,
call|(
name|int
call|)
argument_list|(
literal|193.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|4
block|,
call|(
name|int
call|)
argument_list|(
literal|171.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|1
block|,
call|(
name|int
call|)
argument_list|(
literal|91.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|IF_FREQ
end_undef

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * Japanese Cable Channels:  *  *  1:  91.25MHz -  3: 103.25MHz  *  4: 171.25MHz -  7: 189.25MHz  *  8: 193.25MHz - 12: 217.25MHz  * 13: 109.25MHz - 21: 157.25MHz  * 22: 165.25MHz  * 23: 223.25MHz - 63: 463.25MHz  *  * IF freq: 45.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_define
define|#
directive|define
name|IF_FREQ
value|45.75
end_define

begin_decl_stmt
specifier|static
name|int
name|jpncable
index|[]
init|=
block|{
literal|63
block|,
call|(
name|int
call|)
argument_list|(
name|IF_FREQ
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|23
block|,
call|(
name|int
call|)
argument_list|(
literal|223.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|22
block|,
call|(
name|int
call|)
argument_list|(
literal|165.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|13
block|,
call|(
name|int
call|)
argument_list|(
literal|109.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|8
block|,
call|(
name|int
call|)
argument_list|(
literal|193.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|4
block|,
call|(
name|int
call|)
argument_list|(
literal|171.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|1
block|,
call|(
name|int
call|)
argument_list|(
literal|91.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|IF_FREQ
end_undef

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * xUSSR Broadcast Channels:  *  *  1:  49.75MHz -  2:  59.25MHz  *  3:  77.25MHz -  5:  93.25MHz  *  6: 175.25MHz - 12: 223.25MHz  * 13-20 - not exist  * 21: 471.25MHz - 34: 575.25MHz  * 35: 583.25MHz - 69: 855.25MHz  *  * Cable channels  *  * 70: 111.25MHz - 77: 167.25MHz  * 78: 231.25MHz -107: 463.25MHz  *  * IF freq: 38.90 MHz  */
end_comment

begin_define
define|#
directive|define
name|IF_FREQ
value|38.90
end_define

begin_decl_stmt
specifier|static
name|int
name|xussr
index|[]
init|=
block|{
literal|107
block|,
call|(
name|int
call|)
argument_list|(
name|IF_FREQ
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|78
block|,
call|(
name|int
call|)
argument_list|(
literal|231.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|70
block|,
call|(
name|int
call|)
argument_list|(
literal|111.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|35
block|,
call|(
name|int
call|)
argument_list|(
literal|583.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|21
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|6
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|3
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|1
block|,
call|(
name|int
call|)
argument_list|(
literal|49.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|9.50
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|IF_FREQ
end_undef

begin_comment
comment|/*  * Australian broadcast channels  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|7.00
end_define

begin_decl_stmt
specifier|static
name|int
name|australia
index|[]
init|=
block|{
literal|83
block|,
call|(
name|int
call|)
argument_list|(
literal|45.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|28
block|,
call|(
name|int
call|)
argument_list|(
literal|520.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|11
block|,
call|(
name|int
call|)
argument_list|(
literal|214.50
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|10
block|,
call|(
name|int
call|)
argument_list|(
literal|201.50
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|13.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|174.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|3
block|,
call|(
name|int
call|)
argument_list|(
literal|85.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|56.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_struct
specifier|static
struct|struct
block|{
name|int
modifier|*
name|ptr
decl_stmt|;
name|char
name|name
index|[
name|BT848_MAX_CHNLSET_NAME_LEN
index|]
decl_stmt|;
block|}
name|freqTable
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|""
block|}
block|,
block|{
name|nabcst
block|,
literal|"nabcst"
block|}
block|,
block|{
name|irccable
block|,
literal|"cableirc"
block|}
block|,
block|{
name|hrccable
block|,
literal|"cablehrc"
block|}
block|,
block|{
name|weurope
block|,
literal|"weurope"
block|}
block|,
block|{
name|jpnbcst
block|,
literal|"jpnbcst"
block|}
block|,
block|{
name|jpncable
block|,
literal|"jpncable"
block|}
block|,
block|{
name|xussr
block|,
literal|"xussr"
block|}
block|,
block|{
name|australia
block|,
literal|"australia"
block|}
block|,   }
struct|;
end_struct

begin_define
define|#
directive|define
name|TBL_CHNL
value|freqTable[ bktr->tuner.chnlset ].ptr[ x ]
end_define

begin_define
define|#
directive|define
name|TBL_BASE_FREQ
value|freqTable[ bktr->tuner.chnlset ].ptr[ x + 1 ]
end_define

begin_define
define|#
directive|define
name|TBL_OFFSET
value|freqTable[ bktr->tuner.chnlset ].ptr[ x + 2 ]
end_define

begin_function
specifier|static
name|int
name|frequency_lookup
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* check for "> MAX channel" */
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|channel
operator|>
name|TBL_CHNL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* search the table for data */
for|for
control|(
name|x
operator|=
literal|3
init|;
name|TBL_CHNL
condition|;
name|x
operator|+=
literal|3
control|)
block|{
if|if
condition|(
name|channel
operator|>=
name|TBL_CHNL
condition|)
block|{
return|return
operator|(
name|TBL_BASE_FREQ
operator|+
operator|(
operator|(
name|channel
operator|-
name|TBL_CHNL
operator|)
operator|*
name|TBL_OFFSET
operator|)
operator|)
return|;
block|}
block|}
comment|/* not found, must be below the MIN channel */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|TBL_OFFSET
end_undef

begin_undef
undef|#
directive|undef
name|TBL_BASE_FREQ
end_undef

begin_undef
undef|#
directive|undef
name|TBL_CHNL
end_undef

begin_define
define|#
directive|define
name|TBL_IF
value|freqTable[ bktr->tuner.chnlset ].ptr[ 1 ]
end_define

begin_comment
comment|/* Initialise the tuner structures in the bktr_softc */
end_comment

begin_comment
comment|/* This is needed as the tuner details are no longer globally declared */
end_comment

begin_function
name|void
name|select_tuner
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|tuner_type
parameter_list|)
block|{
if|if
condition|(
name|tuner_type
operator|<
name|Bt848_MAX_TUNER
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|tuner_type
index|]
expr_stmt|;
block|}
else|else
block|{
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Tuner Notes:  * Programming the tuner properly is quite complicated.  * Here are some notes, based on a FM1246 data sheet for a PAL-I tuner.  * The tuner (front end) covers 45.75 Mhz - 855.25 Mhz and an FM band of  * 87.5 Mhz to 108.0 Mhz.  *  * RF and IF.  RF = radio frequencies, it is the transmitted signal.  *             IF is the Intermediate Frequency (the offset from the base  *             signal where the video, color,  audio and NICAM signals are.  *  * Eg, Picture at 38.9 Mhz, Colour at 34.47 MHz, sound at 32.9 MHz  * NICAM at 32.348 Mhz.  * Strangely enough, there is an IF (intermediate frequency) for  * FM Radio which is 10.7 Mhz.  *  * The tuner also works in Bands. Philips bands are  * FM radio band 87.50 to 108.00 MHz  * Low band 45.75 to 170.00 MHz  * Mid band 170.00 to 450.00 MHz  * High band 450.00 to 855.25 MHz  *  *  * Now we need to set the PLL on the tuner to the required freuqncy.  * It has a programmable divisor.  * For TV we want  *  N = 16 (freq RF(pc) + freq IF(pc))  pc is picture carrier and RF and IF  *  are in MHz.   * For RADIO we want a different equation.  *  freq IF is 10.70 MHz (so the data sheet tells me)  * N = (freq RF + freq IF) / step size  * The step size must be set to 50 khz (so the data sheet tells me)  * (note this is 50 kHz, the other things are in MHz)  * so we end up with N = 20x(freq RF + 10.7)  *  */
end_comment

begin_define
define|#
directive|define
name|LOW_BAND
value|0
end_define

begin_define
define|#
directive|define
name|MID_BAND
value|1
end_define

begin_define
define|#
directive|define
name|HIGH_BAND
value|2
end_define

begin_define
define|#
directive|define
name|FM_RADIO_BAND
value|3
end_define

begin_comment
comment|/* Check if these are correct for other than Philips PAL */
end_comment

begin_define
define|#
directive|define
name|STATUSBIT_COLD
value|0x80
end_define

begin_define
define|#
directive|define
name|STATUSBIT_LOCK
value|0x40
end_define

begin_define
define|#
directive|define
name|STATUSBIT_TV
value|0x20
end_define

begin_define
define|#
directive|define
name|STATUSBIT_STEREO
value|0x10
end_define

begin_comment
comment|/* valid if FM (aka not TV) */
end_comment

begin_define
define|#
directive|define
name|STATUSBIT_ADC
value|0x07
end_define

begin_comment
comment|/*  * set the frequency of the tuner  * If 'type' is TV_FREQUENCY, the frequency is freq MHz*16  * If 'type' is FM_RADIO_FREQUENCY, the frequency is freq MHz * 100   * (note *16 gives is 4 bits of fraction, eg steps of nnn.0625)  *  */
end_comment

begin_function
name|int
name|tv_freq
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|frequency
parameter_list|,
name|int
name|type
parameter_list|)
block|{
specifier|const
name|struct
name|TUNER
modifier|*
name|tuner
decl_stmt|;
name|u_char
name|addr
decl_stmt|;
name|u_char
name|control
decl_stmt|;
name|u_char
name|band
decl_stmt|;
name|int
name|N
decl_stmt|;
name|int
name|band_select
init|=
literal|0
decl_stmt|;
name|tuner
operator|=
name|bktr
operator|->
name|card
operator|.
name|tuner
expr_stmt|;
if|if
condition|(
name|tuner
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|TV_FREQUENCY
condition|)
block|{
comment|/* 		 * select the band based on frequency 		 * XXX FIXME: get the cross-over points from the tuner struct 		 */
if|if
condition|(
name|frequency
operator|<
operator|(
literal|160
operator|*
name|FREQFACTOR
operator|)
condition|)
name|band_select
operator|=
name|LOW_BAND
expr_stmt|;
elseif|else
if|if
condition|(
name|frequency
operator|<
operator|(
literal|454
operator|*
name|FREQFACTOR
operator|)
condition|)
name|band_select
operator|=
name|MID_BAND
expr_stmt|;
else|else
name|band_select
operator|=
name|HIGH_BAND
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
if|if
condition|(
name|bktr
operator|->
name|tuner
operator|.
name|afc
condition|)
name|frequency
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * N = 16 * { fRF(pc) + fIF(pc) } 		 * or N = 16* fRF(pc) + 16*fIF(pc) } 		 * where: 		 *  pc is picture carrier, fRF& fIF are in MHz 		 * 		 * fortunatly, frequency is passed in as MHz * 16 		 * and the TBL_IF frequency is also stored in MHz * 16 		 */
name|N
operator|=
name|frequency
operator|+
name|TBL_IF
expr_stmt|;
comment|/* set the address of the PLL */
name|addr
operator|=
name|bktr
operator|->
name|card
operator|.
name|tuner_pllAddr
expr_stmt|;
name|control
operator|=
name|tuner
operator|->
name|pllControl
index|[
name|band_select
index|]
expr_stmt|;
name|band
operator|=
name|tuner
operator|->
name|bandAddrs
index|[
name|band_select
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|band
operator|&&
name|control
operator|)
condition|)
comment|/* Don't try to set un-	*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* supported modes.	*/
if|if
condition|(
name|frequency
operator|>
name|bktr
operator|->
name|tuner
operator|.
name|frequency
condition|)
block|{
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|band
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|band
argument_list|)
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
if|if
condition|(
name|bktr
operator|->
name|tuner
operator|.
name|afc
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
operator|(
name|N
operator|=
name|do_afc
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|N
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* AFC failed, restore requested frequency */
name|N
operator|=
name|frequency
operator|+
name|TBL_IF
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
name|frequency
operator|=
name|N
operator|-
name|TBL_IF
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TUNER_AFC */
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
name|frequency
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|FM_RADIO_FREQUENCY
condition|)
block|{
name|band_select
operator|=
name|FM_RADIO_BAND
expr_stmt|;
comment|/* 		 * N = { fRF(pc) + fIF(pc) }/step_size                  * The step size is 50kHz for FM radio. 		 * (eg after 102.35MHz comes 102.40 MHz) 		 * fIF is 10.7 MHz (as detailed in the specs) 		 * 		 * frequency is passed in as MHz * 100 		 * 		 * So, we have N = (frequency/100 + 10.70)  /(50/1000) 		 */
name|N
operator|=
operator|(
name|frequency
operator|+
literal|1070
operator|)
operator|/
literal|5
expr_stmt|;
comment|/* set the address of the PLL */
name|addr
operator|=
name|bktr
operator|->
name|card
operator|.
name|tuner_pllAddr
expr_stmt|;
name|control
operator|=
name|tuner
operator|->
name|pllControl
index|[
name|band_select
index|]
expr_stmt|;
name|band
operator|=
name|tuner
operator|->
name|bandAddrs
index|[
name|band_select
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|band
operator|&&
name|control
operator|)
condition|)
comment|/* Don't try to set un-	*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* supported modes.	*/
comment|/*		band |= bktr->tuner.radio_mode;*/
comment|/* tuner.radio_mode is set in 						 * the ioctls RADIO_SETMODE 						 * and RADIO_GETMODE */
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|band
argument_list|)
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
operator|(
name|N
operator|*
literal|5
operator|)
operator|-
literal|1070
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
end_if

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|do_afc
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|frequency
parameter_list|)
block|{
name|int
name|step
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|origFrequency
decl_stmt|;
name|origFrequency
operator|=
name|frequency
expr_stmt|;
comment|/* wait for first setting to take effect */
name|tsleep
argument_list|(
name|BKTR_SLEEP
argument_list|,
name|PZERO
argument_list|,
literal|"tuning"
argument_list|,
name|hz
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|addr
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"\nOriginal freq: %d, status: 0x%02x\n"
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|step
operator|=
literal|0
init|;
name|step
operator|<
name|AFC_MAX_STEP
condition|;
operator|++
name|step
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|addr
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|fubar
goto|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|0x40
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"no lock!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|fubar
goto|;
block|}
switch|switch
condition|(
name|status
operator|&
name|AFC_BITS
condition|)
block|{
case|case
name|AFC_FREQ_CENTERED
case|:
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"Centered, freq: %d, status: 0x%02x\n"
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|frequency
operator|)
return|;
case|case
name|AFC_FREQ_MINUS_125
case|:
case|case
name|AFC_FREQ_MINUS_62
case|:
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"Low, freq: %d, status: 0x%02x\n"
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|frequency
expr_stmt|;
break|break;
case|case
name|AFC_FREQ_PLUS_62
case|:
case|case
name|AFC_FREQ_PLUS_125
case|:
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"Hi, freq: %d, status: 0x%02x\n"
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|frequency
expr_stmt|;
break|break;
block|}
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|frequency
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|frequency
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|AFC_DELAY
argument_list|)
expr_stmt|;
block|}
name|fubar
label|:
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|origFrequency
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|origFrequency
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TUNER_AFC */
end_comment

begin_undef
undef|#
directive|undef
name|TBL_IF
end_undef

begin_comment
comment|/*  * Get the Tuner status and signal strength  */
end_comment

begin_function
name|int
name|get_tuner_status
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
return|return
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|card
operator|.
name|tuner_pllAddr
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * set the channel of the tuner  */
end_comment

begin_function
name|int
name|tv_channel
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|int
name|frequency
decl_stmt|;
comment|/* calculate the frequency according to tuner type */
if|if
condition|(
operator|(
name|frequency
operator|=
name|frequency_lookup
argument_list|(
name|bktr
argument_list|,
name|channel
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* set the new frequency */
if|if
condition|(
name|tv_freq
argument_list|(
name|bktr
argument_list|,
name|frequency
argument_list|,
name|TV_FREQUENCY
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* OK to update records */
return|return
operator|(
operator|(
name|bktr
operator|->
name|tuner
operator|.
name|channel
operator|=
name|channel
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * get channelset name  */
end_comment

begin_function
name|int
name|tuner_getchnlset
parameter_list|(
name|struct
name|bktr_chnlset
modifier|*
name|chnlset
parameter_list|)
block|{
if|if
condition|(
operator|(
name|chnlset
operator|->
name|index
operator|<
name|CHNLSET_MIN
operator|)
operator|||
operator|(
name|chnlset
operator|->
name|index
operator|>
name|CHNLSET_MAX
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
operator|&
name|chnlset
operator|->
name|name
argument_list|,
operator|&
name|freqTable
index|[
name|chnlset
operator|->
name|index
index|]
operator|.
name|name
argument_list|,
name|BT848_MAX_CHNLSET_NAME_LEN
argument_list|)
expr_stmt|;
name|chnlset
operator|->
name|max_channel
operator|=
name|freqTable
index|[
name|chnlset
operator|->
name|index
index|]
operator|.
name|ptr
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

