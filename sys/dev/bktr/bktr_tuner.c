begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * 1. Redistributions of source code must retain the  * Copyright (c) 1997 Amancio Hasty, 1999 Roger Hardiman  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Amancio Hasty and  *      Roger Hardiman  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This is part of the Driver for Video Capture Cards (Frame grabbers)  * and TV Tuner cards using the Brooktree Bt848, Bt848A, Bt849A, Bt878, Bt879  * chipset.  * Copyright Roger Hardiman and Amancio Hasty.  *  * bktr_tuner : This deals with controlling the tuner fitted to TV cards.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|500000
operator|)
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/ic/bt8xx.h>
end_include

begin_comment
comment|/* NetBSD .h file location */
end_comment

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_tuner.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_card.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/bktr/bktr_core.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dev/bktr/ioctl_meteor.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/ioctl_bt848.h>
end_include

begin_comment
comment|/* extensions to ioctl_meteor.h */
end_comment

begin_include
include|#
directive|include
file|<dev/bktr/bktr_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_tuner.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_card.h>
end_include

begin_include
include|#
directive|include
file|<dev/bktr/bktr_core.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
end_if

begin_define
define|#
directive|define
name|AFC_DELAY
value|10000
end_define

begin_comment
comment|/* 10 millisend delay */
end_comment

begin_define
define|#
directive|define
name|AFC_BITS
value|0x07
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_MINUS_125
value|0x00
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_MINUS_62
value|0x01
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_CENTERED
value|0x02
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_PLUS_62
value|0x03
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_PLUS_125
value|0x04
end_define

begin_define
define|#
directive|define
name|AFC_MAX_STEP
value|(5 * FREQFACTOR)
end_define

begin_comment
comment|/* no more than 5 MHz */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TUNER_AFC */
end_comment

begin_define
define|#
directive|define
name|TTYPE_XXX
value|0
end_define

begin_define
define|#
directive|define
name|TTYPE_NTSC
value|1
end_define

begin_define
define|#
directive|define
name|TTYPE_NTSC_J
value|2
end_define

begin_define
define|#
directive|define
name|TTYPE_PAL
value|3
end_define

begin_define
define|#
directive|define
name|TTYPE_PAL_M
value|4
end_define

begin_define
define|#
directive|define
name|TTYPE_PAL_N
value|5
end_define

begin_define
define|#
directive|define
name|TTYPE_SECAM
value|6
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_MSB
value|(0x80)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_CP
value|(1<<6)
end_define

begin_comment
comment|/* set this for fast tuning */
end_comment

begin_define
define|#
directive|define
name|TSA552x_CB_T2
value|(1<<5)
end_define

begin_comment
comment|/* test mode - Normally set to 0 */
end_comment

begin_define
define|#
directive|define
name|TSA552x_CB_T1
value|(1<<4)
end_define

begin_comment
comment|/* test mode - Normally set to 0 */
end_comment

begin_define
define|#
directive|define
name|TSA552x_CB_T0
value|(1<<3)
end_define

begin_comment
comment|/* test mode - Normally set to 1 */
end_comment

begin_define
define|#
directive|define
name|TSA552x_CB_RSA
value|(1<<2)
end_define

begin_comment
comment|/* 0 for 31.25 khz, 1 for 62.5 kHz */
end_comment

begin_define
define|#
directive|define
name|TSA552x_CB_RSB
value|(1<<1)
end_define

begin_comment
comment|/* 0 for FM 50kHz steps, 1 = Use RSA*/
end_comment

begin_define
define|#
directive|define
name|TSA552x_CB_OS
value|(1<<0)
end_define

begin_comment
comment|/* Set to 0 for normal operation */
end_comment

begin_define
define|#
directive|define
name|TSA552x_RADIO
value|(TSA552x_CB_MSB |       \                                  TSA552x_CB_T0)
end_define

begin_comment
comment|/* raise the charge pump voltage for fast tuning */
end_comment

begin_define
define|#
directive|define
name|TSA552x_FCONTROL
value|(TSA552x_CB_MSB |       \                                  TSA552x_CB_CP  |       \                                  TSA552x_CB_T0  |       \                                  TSA552x_CB_RSA |       \                                  TSA552x_CB_RSB)
end_define

begin_comment
comment|/* lower the charge pump voltage for better residual oscillator FM */
end_comment

begin_define
define|#
directive|define
name|TSA552x_SCONTROL
value|(TSA552x_CB_MSB |       \                                  TSA552x_CB_T0  |       \                                  TSA552x_CB_RSA |       \                                  TSA552x_CB_RSB)
end_define

begin_comment
comment|/* The control value for the ALPS TSCH5 Tuner */
end_comment

begin_define
define|#
directive|define
name|TSCH5_FCONTROL
value|0x82
end_define

begin_define
define|#
directive|define
name|TSCH5_RADIO
value|0x86
end_define

begin_comment
comment|/* The control value for the ALPS TSBH1 Tuner */
end_comment

begin_define
define|#
directive|define
name|TSBH1_FCONTROL
value|0xce
end_define

begin_function_decl
specifier|static
name|void
name|mt2032_set_tv_freq
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|int
name|freq
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|TUNER
name|tuners
index|[]
init|=
block|{
comment|/* XXX FIXME: fill in the band-switch crosspoints */
comment|/* NO_TUNER */
block|{
literal|"<no>"
block|,
comment|/* the 'name' */
name|TTYPE_XXX
block|,
comment|/* input type */
block|{
literal|0x00
block|,
comment|/* control byte for Tuner PLL */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_NTSC */
block|{
literal|"Temic NTSC"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_PAL */
block|{
literal|"Temic PAL"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_SECAM */
block|{
literal|"Temic SECAM"
block|,
comment|/* the 'name' */
name|TTYPE_SECAM
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_NTSC */
block|{
literal|"Philips NTSC"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_PAL */
block|{
literal|"Philips PAL"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_SECAM */
block|{
literal|"Philips SECAM"
block|,
comment|/* the 'name' */
name|TTYPE_SECAM
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa7
block|,
literal|0x97
block|,
literal|0x37
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_PAL I */
block|{
literal|"Temic PAL I"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_PALI */
block|{
literal|"Philips PAL I"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_FR1236_NTSC */
block|{
literal|"Philips FR1236 NTSC FM"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSA552x_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_FCONTROL
block|,
name|TSA552x_FCONTROL
block|,
name|TSA552x_RADIO
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0xa4
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_FR1216_PAL */
block|{
literal|"Philips FR1216 PAL FM"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_FCONTROL
block|,
name|TSA552x_FCONTROL
block|,
name|TSA552x_RADIO
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0xa4
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_FR1236_SECAM */
block|{
literal|"Philips FR1236 SECAM FM"
block|,
comment|/* the 'name' */
name|TTYPE_SECAM
block|,
comment|/* input type */
block|{
name|TSA552x_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_FCONTROL
block|,
name|TSA552x_FCONTROL
block|,
name|TSA552x_RADIO
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa7
block|,
literal|0x97
block|,
literal|0x37
block|,
literal|0xa4
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* ALPS TSCH5 NTSC */
block|{
literal|"ALPS TSCH5 NTSC FM"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSCH5_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSCH5_FCONTROL
block|,
name|TSCH5_FCONTROL
block|,
name|TSCH5_RADIO
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x14
block|,
literal|0x12
block|,
literal|0x11
block|,
literal|0x04
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* ALPS TSBH1 NTSC */
block|{
literal|"ALPS TSBH1 NTSC"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSBH1_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSBH1_FCONTROL
block|,
name|TSBH1_FCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x08
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* MT2032 Microtune */
block|{
literal|"MT2032"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* LG TPI8PSB12P PAL */
block|{
literal|"LG TPI8PSB12P PAL"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0x8e
block|}
block|}
block|,
comment|/* the band-switch values */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scaling factor for frequencies expressed as ints */
end_comment

begin_define
define|#
directive|define
name|FREQFACTOR
value|16
end_define

begin_comment
comment|/*  * Format:  *	entry 0:         MAX legal channel  *	entry 1:         IF frequency  *			 expressed as fi{mHz} * 16,  *			 eg 45.75mHz == 45.75 * 16 = 732  *	entry 2:         [place holder/future]  *	entry 3:         base of channel record 0  *	entry 3 + (x*3): base of channel record 'x'  *	entry LAST:      NULL channel entry marking end of records  *  * Record:  *	int 0:		base channel  *	int 1:		frequency of base channel,  *			 expressed as fb{mHz} * 16,  *	int 2:		offset frequency between channels,  *			 expressed as fo{mHz} * 16,  */
end_comment

begin_comment
comment|/*  * North American Broadcast Channels:  *  *  2:  55.25 mHz -  4:  67.25 mHz  *  5:  77.25 mHz -  6:	 83.25 mHz  *  7: 175.25 mHz - 13:	211.25 mHz  * 14: 471.25 mHz - 83:	885.25 mHz  *  * IF freq: 45.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_decl_stmt
specifier|static
name|int
name|nabcst
index|[]
init|=
block|{
literal|83
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|55.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * North American Cable Channels, IRC:  *  *  2:  55.25 mHz -  4:  67.25 mHz  *  5:  77.25 mHz -  6:  83.25 mHz  *  7: 175.25 mHz - 13: 211.25 mHz  * 14: 121.25 mHz - 22: 169.25 mHz  * 23: 217.25 mHz - 94: 643.25 mHz  * 95:  91.25 mHz - 99: 115.25 mHz  *  * IF freq: 45.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_decl_stmt
specifier|static
name|int
name|irccable
index|[]
init|=
block|{
literal|116
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|100
block|,
call|(
name|int
call|)
argument_list|(
literal|649.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|95
block|,
call|(
name|int
call|)
argument_list|(
literal|91.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|23
block|,
call|(
name|int
call|)
argument_list|(
literal|217.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|121.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|55.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * North American Cable Channels, HRC:  *  * 2:   54 mHz  - 4:    66 mHz  * 5:   78 mHz  - 6:    84 mHz  * 7:  174 mHz  - 13:  210 mHz  * 14: 120 mHz  - 22:  168 mHz  * 23: 216 mHz  - 94:  642 mHz  * 95:  90 mHz  - 99:  114 mHz  *  * IF freq: 45.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_decl_stmt
specifier|static
name|int
name|hrccable
index|[]
init|=
block|{
literal|116
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|100
block|,
call|(
name|int
call|)
argument_list|(
literal|648.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|95
block|,
call|(
name|int
call|)
argument_list|(
literal|90.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|23
block|,
call|(
name|int
call|)
argument_list|(
literal|216.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|120.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|174.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|78.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|54.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * Western European broadcast channels:  *  * (there are others that appear to vary between countries - rmt)  *  * here's the table Philips provides:  * caution, some of the offsets don't compute...  *  *  1	 4525	700	N21  *   *  2	 4825	700	E2  *  3	 5525	700	E3  *  4	 6225	700	E4  *   *  5	17525	700	E5  *  6	18225	700	E6  *  7	18925	700	E7  *  8	19625	700	E8  *  9	20325	700	E9  * 10	21025	700	E10  * 11	21725	700	E11  * 12	22425	700	E12  *   * 13	 5375	700	ITA  * 14	 6225	700	ITB  *   * 15	 8225	700	ITC  *   * 16	17525	700	ITD  * 17	18325	700	ITE  *   * 18	19225	700	ITF  * 19	20125	700	ITG  * 20	21025	700	ITH  *   * 21	47125	800	E21  * 22	47925	800	E22  * 23	48725	800	E23  * 24	49525	800	E24  * 25	50325	800	E25  * 26	51125	800	E26  * 27	51925	800	E27  * 28	52725	800	E28  * 29	53525	800	E29  * 30	54325	800	E30  * 31	55125	800	E31  * 32	55925	800	E32  * 33	56725	800	E33  * 34	57525	800	E34  * 35	58325	800	E35  * 36	59125	800	E36  * 37	59925	800	E37  * 38	60725	800	E38  * 39	61525	800	E39  * 40	62325	800	E40  * 41	63125	800	E41  * 42	63925	800	E42  * 43	64725	800	E43  * 44	65525	800	E44  * 45	66325	800	E45  * 46	67125	800	E46  * 47	67925	800	E47  * 48	68725	800	E48  * 49	69525	800	E49  * 50	70325	800	E50  * 51	71125	800	E51  * 52	71925	800	E52  * 53	72725	800	E53  * 54	73525	800	E54  * 55	74325	800	E55  * 56	75125	800	E56  * 57	75925	800	E57  * 58	76725	800	E58  * 59	77525	800	E59  * 60	78325	800	E60  * 61	79125	800	E61  * 62	79925	800	E62  * 63	80725	800	E63  * 64	81525	800	E64  * 65	82325	800	E65  * 66	83125	800	E66  * 67	83925	800	E67  * 68	84725	800	E68  * 69	85525	800	E69  *   * 70	 4575	800	IA  * 71	 5375	800	IB  * 72	 6175	800	IC  *   * 74	 6925	700	S01  * 75	 7625	700	S02  * 76	 8325	700	S03  *   * 80	10525	700	S1  * 81	11225	700	S2  * 82	11925	700	S3  * 83	12625	700	S4  * 84	13325	700	S5  * 85	14025	700	S6  * 86	14725	700	S7  * 87	15425	700	S8  * 88	16125	700	S9  * 89	16825	700	S10  * 90	23125	700	S11  * 91	23825	700	S12  * 92	24525	700	S13  * 93	25225	700	S14  * 94	25925	700	S15  * 95	26625	700	S16  * 96	27325	700	S17  * 97	28025	700	S18  * 98	28725	700	S19  * 99	29425	700	S20  *  *  * Channels S21 - S41 are taken from  * http://gemma.apple.com:80/dev/technotes/tn/tn1012.html  *  * 100	30325	800	S21  * 101	31125	800	S22  * 102	31925	800	S23  * 103	32725	800	S24  * 104	33525	800	S25  * 105	34325	800	S26           * 106	35125	800	S27           * 107	35925	800	S28           * 108	36725	800	S29           * 109	37525	800	S30           * 110	38325	800	S31           * 111	39125	800	S32           * 112	39925	800	S33           * 113	40725	800	S34           * 114	41525	800	S35           * 115	42325	800	S36           * 116	43125	800	S37           * 117	43925	800	S38           * 118	44725	800	S39           * 119	45525	800	S40           * 120	46325	800	S41  *   * 121	 3890	000	IFFREQ  *   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|weurope
index|[]
init|=
block|{
literal|121
block|,
call|(
name|int
call|)
argument_list|(
literal|38.90
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|100
block|,
call|(
name|int
call|)
argument_list|(
literal|303.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|90
block|,
call|(
name|int
call|)
argument_list|(
literal|231.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|80
block|,
call|(
name|int
call|)
argument_list|(
literal|105.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|74
block|,
call|(
name|int
call|)
argument_list|(
literal|69.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|21
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|17
block|,
call|(
name|int
call|)
argument_list|(
literal|183.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|9.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|16
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|9.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|15
block|,
call|(
name|int
call|)
argument_list|(
literal|82.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.50
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|13
block|,
call|(
name|int
call|)
argument_list|(
literal|53.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.50
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|48.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Japanese Broadcast Channels:  *  *  1:  91.25MHz -  3: 103.25MHz  *  4: 171.25MHz -  7: 189.25MHz  *  8: 193.25MHz - 12: 217.25MHz  (VHF)  * 13: 471.25MHz - 62: 765.25MHz  (UHF)  *  * IF freq: 45.75 mHz  *  OR  * IF freq: 58.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_define
define|#
directive|define
name|IF_FREQ
value|45.75
end_define

begin_decl_stmt
specifier|static
name|int
name|jpnbcst
index|[]
init|=
block|{
literal|62
block|,
call|(
name|int
call|)
argument_list|(
name|IF_FREQ
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|13
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|8
block|,
call|(
name|int
call|)
argument_list|(
literal|193.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|4
block|,
call|(
name|int
call|)
argument_list|(
literal|171.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|1
block|,
call|(
name|int
call|)
argument_list|(
literal|91.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|IF_FREQ
end_undef

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * Japanese Cable Channels:  *  *  1:  91.25MHz -  3: 103.25MHz  *  4: 171.25MHz -  7: 189.25MHz  *  8: 193.25MHz - 12: 217.25MHz  * 13: 109.25MHz - 21: 157.25MHz  * 22: 165.25MHz  * 23: 223.25MHz - 63: 463.25MHz  *  * IF freq: 45.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_define
define|#
directive|define
name|IF_FREQ
value|45.75
end_define

begin_decl_stmt
specifier|static
name|int
name|jpncable
index|[]
init|=
block|{
literal|63
block|,
call|(
name|int
call|)
argument_list|(
name|IF_FREQ
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|23
block|,
call|(
name|int
call|)
argument_list|(
literal|223.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|22
block|,
call|(
name|int
call|)
argument_list|(
literal|165.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|13
block|,
call|(
name|int
call|)
argument_list|(
literal|109.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|8
block|,
call|(
name|int
call|)
argument_list|(
literal|193.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|4
block|,
call|(
name|int
call|)
argument_list|(
literal|171.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|1
block|,
call|(
name|int
call|)
argument_list|(
literal|91.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|IF_FREQ
end_undef

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * xUSSR Broadcast Channels:  *  *  1:  49.75MHz -  2:  59.25MHz  *  3:  77.25MHz -  5:  93.25MHz  *  6: 175.25MHz - 12: 223.25MHz  * 13-20 - not exist  * 21: 471.25MHz - 34: 575.25MHz  * 35: 583.25MHz - 69: 855.25MHz  *  * Cable channels  *  * 70: 111.25MHz - 77: 167.25MHz  * 78: 231.25MHz -107: 463.25MHz  *  * IF freq: 38.90 MHz  */
end_comment

begin_define
define|#
directive|define
name|IF_FREQ
value|38.90
end_define

begin_decl_stmt
specifier|static
name|int
name|xussr
index|[]
init|=
block|{
literal|107
block|,
call|(
name|int
call|)
argument_list|(
name|IF_FREQ
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|78
block|,
call|(
name|int
call|)
argument_list|(
literal|231.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|70
block|,
call|(
name|int
call|)
argument_list|(
literal|111.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|35
block|,
call|(
name|int
call|)
argument_list|(
literal|583.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|21
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|6
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|3
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|1
block|,
call|(
name|int
call|)
argument_list|(
literal|49.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|9.50
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|IF_FREQ
end_undef

begin_comment
comment|/*  * Australian broadcast channels  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|7.00
end_define

begin_define
define|#
directive|define
name|IF_FREQ
value|38.90
end_define

begin_decl_stmt
specifier|static
name|int
name|australia
index|[]
init|=
block|{
literal|83
block|,
call|(
name|int
call|)
argument_list|(
name|IF_FREQ
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|28
block|,
call|(
name|int
call|)
argument_list|(
literal|527.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|10
block|,
call|(
name|int
call|)
argument_list|(
literal|209.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|6
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|4
block|,
call|(
name|int
call|)
argument_list|(
literal|95.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|3
block|,
call|(
name|int
call|)
argument_list|(
literal|86.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|1
block|,
call|(
name|int
call|)
argument_list|(
literal|57.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_undef
undef|#
directive|undef
name|IF_FREQ
end_undef

begin_comment
comment|/*   * France broadcast channels  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|8.00
end_define

begin_define
define|#
directive|define
name|IF_FREQ
value|38.90
end_define

begin_decl_stmt
specifier|static
name|int
name|france
index|[]
init|=
block|{
literal|69
block|,
call|(
name|int
call|)
argument_list|(
name|IF_FREQ
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|21
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
comment|/* 21 -> 69 */
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|176.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
comment|/* 5 -> 10 */
literal|4
block|,
call|(
name|int
call|)
argument_list|(
literal|63.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
comment|/* 4    */
literal|3
block|,
call|(
name|int
call|)
argument_list|(
literal|60.50
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
comment|/* 3    */
literal|1
block|,
call|(
name|int
call|)
argument_list|(
literal|47.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
comment|/* 1  2 */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_undef
undef|#
directive|undef
name|IF_FREQ
end_undef

begin_struct
specifier|static
struct|struct
block|{
name|int
modifier|*
name|ptr
decl_stmt|;
name|char
name|name
index|[
name|BT848_MAX_CHNLSET_NAME_LEN
index|]
decl_stmt|;
block|}
name|freqTable
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|""
block|}
block|,
block|{
name|nabcst
block|,
literal|"nabcst"
block|}
block|,
block|{
name|irccable
block|,
literal|"cableirc"
block|}
block|,
block|{
name|hrccable
block|,
literal|"cablehrc"
block|}
block|,
block|{
name|weurope
block|,
literal|"weurope"
block|}
block|,
block|{
name|jpnbcst
block|,
literal|"jpnbcst"
block|}
block|,
block|{
name|jpncable
block|,
literal|"jpncable"
block|}
block|,
block|{
name|xussr
block|,
literal|"xussr"
block|}
block|,
block|{
name|australia
block|,
literal|"australia"
block|}
block|,
block|{
name|france
block|,
literal|"france"
block|}
block|,   }
struct|;
end_struct

begin_define
define|#
directive|define
name|TBL_CHNL
value|freqTable[ bktr->tuner.chnlset ].ptr[ x ]
end_define

begin_define
define|#
directive|define
name|TBL_BASE_FREQ
value|freqTable[ bktr->tuner.chnlset ].ptr[ x + 1 ]
end_define

begin_define
define|#
directive|define
name|TBL_OFFSET
value|freqTable[ bktr->tuner.chnlset ].ptr[ x + 2 ]
end_define

begin_function
specifier|static
name|int
name|frequency_lookup
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* check for "> MAX channel" */
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|channel
operator|>
name|TBL_CHNL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* search the table for data */
for|for
control|(
name|x
operator|=
literal|3
init|;
name|TBL_CHNL
condition|;
name|x
operator|+=
literal|3
control|)
block|{
if|if
condition|(
name|channel
operator|>=
name|TBL_CHNL
condition|)
block|{
return|return
operator|(
name|TBL_BASE_FREQ
operator|+
operator|(
operator|(
name|channel
operator|-
name|TBL_CHNL
operator|)
operator|*
name|TBL_OFFSET
operator|)
operator|)
return|;
block|}
block|}
comment|/* not found, must be below the MIN channel */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|TBL_OFFSET
end_undef

begin_undef
undef|#
directive|undef
name|TBL_BASE_FREQ
end_undef

begin_undef
undef|#
directive|undef
name|TBL_CHNL
end_undef

begin_define
define|#
directive|define
name|TBL_IF
value|(bktr->format_params == BT848_IFORM_F_NTSCJ || \                  bktr->format_params == BT848_IFORM_F_NTSCM ? \                  nabcst[1] : weurope[1])
end_define

begin_comment
comment|/* Initialise the tuner structures in the bktr_softc */
end_comment

begin_comment
comment|/* This is needed as the tuner details are no longer globally declared */
end_comment

begin_function
name|void
name|select_tuner
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|tuner_type
parameter_list|)
block|{
if|if
condition|(
name|tuner_type
operator|<
name|Bt848_MAX_TUNER
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|tuner_type
index|]
expr_stmt|;
block|}
else|else
block|{
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Tuner Notes:  * Programming the tuner properly is quite complicated.  * Here are some notes, based on a FM1246 data sheet for a PAL-I tuner.  * The tuner (front end) covers 45.75 Mhz - 855.25 Mhz and an FM band of  * 87.5 Mhz to 108.0 Mhz.  *  * RF and IF.  RF = radio frequencies, it is the transmitted signal.  *             IF is the Intermediate Frequency (the offset from the base  *             signal where the video, color,  audio and NICAM signals are.  *  * Eg, Picture at 38.9 Mhz, Colour at 34.47 MHz, sound at 32.9 MHz  * NICAM at 32.348 Mhz.  * Strangely enough, there is an IF (intermediate frequency) for  * FM Radio which is 10.7 Mhz.  *  * The tuner also works in Bands. Philips bands are  * FM radio band 87.50 to 108.00 MHz  * Low band 45.75 to 170.00 MHz  * Mid band 170.00 to 450.00 MHz  * High band 450.00 to 855.25 MHz  *  *  * Now we need to set the PLL on the tuner to the required freuqncy.  * It has a programmable divisor.  * For TV we want  *  N = 16 (freq RF(pc) + freq IF(pc))  pc is picture carrier and RF and IF  *  are in MHz.   * For RADIO we want a different equation.  *  freq IF is 10.70 MHz (so the data sheet tells me)  * N = (freq RF + freq IF) / step size  * The step size must be set to 50 khz (so the data sheet tells me)  * (note this is 50 kHz, the other things are in MHz)  * so we end up with N = 20x(freq RF + 10.7)  *  */
end_comment

begin_define
define|#
directive|define
name|LOW_BAND
value|0
end_define

begin_define
define|#
directive|define
name|MID_BAND
value|1
end_define

begin_define
define|#
directive|define
name|HIGH_BAND
value|2
end_define

begin_define
define|#
directive|define
name|FM_RADIO_BAND
value|3
end_define

begin_comment
comment|/* Check if these are correct for other than Philips PAL */
end_comment

begin_define
define|#
directive|define
name|STATUSBIT_COLD
value|0x80
end_define

begin_define
define|#
directive|define
name|STATUSBIT_LOCK
value|0x40
end_define

begin_define
define|#
directive|define
name|STATUSBIT_TV
value|0x20
end_define

begin_define
define|#
directive|define
name|STATUSBIT_STEREO
value|0x10
end_define

begin_comment
comment|/* valid if FM (aka not TV) */
end_comment

begin_define
define|#
directive|define
name|STATUSBIT_ADC
value|0x07
end_define

begin_comment
comment|/*  * set the frequency of the tuner  * If 'type' is TV_FREQUENCY, the frequency is freq MHz*16  * If 'type' is FM_RADIO_FREQUENCY, the frequency is freq MHz * 100   * (note *16 gives is 4 bits of fraction, eg steps of nnn.0625)  *  */
end_comment

begin_function
name|int
name|tv_freq
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|frequency
parameter_list|,
name|int
name|type
parameter_list|)
block|{
specifier|const
name|struct
name|TUNER
modifier|*
name|tuner
decl_stmt|;
name|u_char
name|addr
decl_stmt|;
name|u_char
name|control
decl_stmt|;
name|u_char
name|band
decl_stmt|;
name|int
name|N
decl_stmt|;
name|int
name|band_select
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|int
name|oldFrequency
decl_stmt|,
name|afcDelta
decl_stmt|;
endif|#
directive|endif
name|tuner
operator|=
name|bktr
operator|->
name|card
operator|.
name|tuner
expr_stmt|;
if|if
condition|(
name|tuner
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|tuner
operator|==
operator|&
name|tuners
index|[
name|TUNER_MT2032
index|]
condition|)
block|{
name|mt2032_set_tv_freq
argument_list|(
name|bktr
argument_list|,
name|frequency
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|type
operator|==
name|TV_FREQUENCY
condition|)
block|{
comment|/* 		 * select the band based on frequency 		 * XXX FIXME: get the cross-over points from the tuner struct 		 */
if|if
condition|(
name|frequency
operator|<
operator|(
literal|160
operator|*
name|FREQFACTOR
operator|)
condition|)
name|band_select
operator|=
name|LOW_BAND
expr_stmt|;
elseif|else
if|if
condition|(
name|frequency
operator|<
operator|(
literal|454
operator|*
name|FREQFACTOR
operator|)
condition|)
name|band_select
operator|=
name|MID_BAND
expr_stmt|;
else|else
name|band_select
operator|=
name|HIGH_BAND
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
if|if
condition|(
name|bktr
operator|->
name|tuner
operator|.
name|afc
condition|)
name|frequency
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * N = 16 * { fRF(pc) + fIF(pc) } 		 * or N = 16* fRF(pc) + 16*fIF(pc) } 		 * where: 		 *  pc is picture carrier, fRF& fIF are in MHz 		 * 		 * fortunatly, frequency is passed in as MHz * 16 		 * and the TBL_IF frequency is also stored in MHz * 16 		 */
name|N
operator|=
name|frequency
operator|+
name|TBL_IF
expr_stmt|;
comment|/* set the address of the PLL */
name|addr
operator|=
name|bktr
operator|->
name|card
operator|.
name|tuner_pllAddr
expr_stmt|;
name|control
operator|=
name|tuner
operator|->
name|pllControl
index|[
name|band_select
index|]
expr_stmt|;
name|band
operator|=
name|tuner
operator|->
name|bandAddrs
index|[
name|band_select
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|band
operator|&&
name|control
operator|)
condition|)
comment|/* Don't try to set un-	*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* supported modes.	*/
if|if
condition|(
name|frequency
operator|>
name|bktr
operator|->
name|tuner
operator|.
name|frequency
condition|)
block|{
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|band
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|band
argument_list|)
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
if|if
condition|(
name|bktr
operator|->
name|tuner
operator|.
name|afc
operator|==
name|TRUE
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|oldFrequency
operator|=
name|frequency
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|N
operator|=
name|do_afc
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|N
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* AFC failed, restore requested frequency */
name|N
operator|=
name|frequency
operator|+
name|TBL_IF
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"%s: do_afc: failed to lock\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
name|frequency
operator|=
name|N
operator|-
name|TBL_IF
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"%s: do_afc: returned freq %d (%d %% %d)\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|frequency
argument_list|,
name|frequency
operator|/
literal|16
argument_list|,
name|frequency
operator|%
literal|16
argument_list|)
expr_stmt|;
name|afcDelta
operator|=
name|frequency
operator|-
name|oldFrequency
expr_stmt|;
name|printf
argument_list|(
literal|"%s: changed by: %d clicks (%d mod %d)\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|afcDelta
argument_list|,
name|afcDelta
operator|/
literal|16
argument_list|,
name|afcDelta
operator|%
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* TUNER_AFC */
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
name|frequency
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|FM_RADIO_FREQUENCY
condition|)
block|{
name|band_select
operator|=
name|FM_RADIO_BAND
expr_stmt|;
comment|/* 		 * N = { fRF(pc) + fIF(pc) }/step_size                  * The step size is 50kHz for FM radio. 		 * (eg after 102.35MHz comes 102.40 MHz) 		 * fIF is 10.7 MHz (as detailed in the specs) 		 * 		 * frequency is passed in as MHz * 100 		 * 		 * So, we have N = (frequency/100 + 10.70)  /(50/1000) 		 */
name|N
operator|=
operator|(
name|frequency
operator|+
literal|1070
operator|)
operator|/
literal|5
expr_stmt|;
comment|/* set the address of the PLL */
name|addr
operator|=
name|bktr
operator|->
name|card
operator|.
name|tuner_pllAddr
expr_stmt|;
name|control
operator|=
name|tuner
operator|->
name|pllControl
index|[
name|band_select
index|]
expr_stmt|;
name|band
operator|=
name|tuner
operator|->
name|bandAddrs
index|[
name|band_select
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|band
operator|&&
name|control
operator|)
condition|)
comment|/* Don't try to set un-	*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* supported modes.	*/
name|band
operator||=
name|bktr
operator|->
name|tuner
operator|.
name|radio_mode
expr_stmt|;
comment|/* tuner.radio_mode is set in 						 * the ioctls RADIO_SETMODE 						 * and RADIO_GETMODE */
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|band
argument_list|)
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
operator|(
name|N
operator|*
literal|5
operator|)
operator|-
literal|1070
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
end_if

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|do_afc
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|frequency
parameter_list|)
block|{
name|int
name|step
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|origFrequency
decl_stmt|;
name|origFrequency
operator|=
name|frequency
expr_stmt|;
comment|/* wait for first setting to take effect */
name|tsleep
argument_list|(
name|BKTR_SLEEP
argument_list|,
name|PZERO
argument_list|,
literal|"tuning"
argument_list|,
name|hz
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|addr
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"%s: Original freq: %d, status: 0x%02x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|step
operator|=
literal|0
init|;
name|step
operator|<
name|AFC_MAX_STEP
condition|;
operator|++
name|step
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|addr
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|fubar
goto|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|0x40
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"%s: no lock!\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|fubar
goto|;
block|}
switch|switch
condition|(
name|status
operator|&
name|AFC_BITS
condition|)
block|{
case|case
name|AFC_FREQ_CENTERED
case|:
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"%s: Centered, freq: %d, status: 0x%02x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|frequency
operator|)
return|;
case|case
name|AFC_FREQ_MINUS_125
case|:
case|case
name|AFC_FREQ_MINUS_62
case|:
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"%s: Low, freq: %d, status: 0x%02x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|frequency
expr_stmt|;
break|break;
case|case
name|AFC_FREQ_PLUS_62
case|:
case|case
name|AFC_FREQ_PLUS_125
case|:
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"%s: Hi, freq: %d, status: 0x%02x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|frequency
expr_stmt|;
break|break;
block|}
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|frequency
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|frequency
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|AFC_DELAY
argument_list|)
expr_stmt|;
block|}
name|fubar
label|:
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|origFrequency
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|origFrequency
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TUNER_AFC */
end_comment

begin_undef
undef|#
directive|undef
name|TBL_IF
end_undef

begin_comment
comment|/*  * Get the Tuner status and signal strength  */
end_comment

begin_function
name|int
name|get_tuner_status
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|==
operator|&
name|tuners
index|[
name|TUNER_MT2032
index|]
condition|)
return|return
literal|0
return|;
return|return
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|card
operator|.
name|tuner_pllAddr
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * set the channel of the tuner  */
end_comment

begin_function
name|int
name|tv_channel
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|int
name|frequency
decl_stmt|;
comment|/* calculate the frequency according to tuner type */
if|if
condition|(
operator|(
name|frequency
operator|=
name|frequency_lookup
argument_list|(
name|bktr
argument_list|,
name|channel
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* set the new frequency */
if|if
condition|(
name|tv_freq
argument_list|(
name|bktr
argument_list|,
name|frequency
argument_list|,
name|TV_FREQUENCY
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* OK to update records */
return|return
operator|(
operator|(
name|bktr
operator|->
name|tuner
operator|.
name|channel
operator|=
name|channel
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * get channelset name  */
end_comment

begin_function
name|int
name|tuner_getchnlset
parameter_list|(
name|struct
name|bktr_chnlset
modifier|*
name|chnlset
parameter_list|)
block|{
if|if
condition|(
operator|(
name|chnlset
operator|->
name|index
operator|<
name|CHNLSET_MIN
operator|)
operator|||
operator|(
name|chnlset
operator|->
name|index
operator|>
name|CHNLSET_MAX
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
operator|&
name|chnlset
operator|->
name|name
argument_list|,
operator|&
name|freqTable
index|[
name|chnlset
operator|->
name|index
index|]
operator|.
name|name
argument_list|,
name|BT848_MAX_CHNLSET_NAME_LEN
argument_list|)
expr_stmt|;
name|chnlset
operator|->
name|max_channel
operator|=
name|freqTable
index|[
name|chnlset
operator|->
name|index
index|]
operator|.
name|ptr
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TDA9887_ADDR
value|0x86
end_define

begin_function
specifier|static
name|int
name|TDA9887_init
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|output2_enable
parameter_list|)
block|{
name|u_char
name|addr
init|=
name|TDA9887_ADDR
decl_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|,
name|output2_enable
condition|?
literal|0x50
else|:
literal|0xd0
argument_list|)
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|,
literal|0x6e
argument_list|)
expr_stmt|;
comment|/* takeover point / de-emphasis */
comment|/* PAL BG: 0x09  PAL I: 0x0a  NTSC: 0x04 */
ifdef|#
directive|ifdef
name|MT2032_NTSC
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
literal|2
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
else|#
directive|else
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
literal|2
argument_list|,
literal|0x09
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MT2032_OPTIMIZE_VCO
value|1
end_define

begin_comment
comment|/* holds the value of XOGC register after init */
end_comment

begin_decl_stmt
specifier|static
name|int
name|MT2032_XOGC
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* card.tuner_pllAddr not set during init */
end_comment

begin_define
define|#
directive|define
name|MT2032_ADDR
value|0xc0
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MT2032_ADDR
end_ifndef

begin_define
define|#
directive|define
name|MT2032_ADDR
value|(bktr->card.tuner_pllAddr)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|_MT2032_GetRegister
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|u_char
name|regNum
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|MT2032_ADDR
argument_list|,
name|regNum
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: MT2032 write failed (i2c addr %#x)\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|MT2032_ADDR
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|ch
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|MT2032_ADDR
operator|+
literal|1
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: MT2032 get register %d failed\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|regNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_MT2032_SetRegister
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|u_char
name|regNum
parameter_list|,
name|u_char
name|data
parameter_list|)
block|{
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|MT2032_ADDR
argument_list|,
name|regNum
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MT2032_GetRegister
parameter_list|(
name|r
parameter_list|)
value|_MT2032_GetRegister(bktr,r)
end_define

begin_define
define|#
directive|define
name|MT2032_SetRegister
parameter_list|(
name|r
parameter_list|,
name|d
parameter_list|)
value|_MT2032_SetRegister(bktr,r,d)
end_define

begin_function
name|int
name|mt2032_init
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|u_char
name|rdbuf
index|[
literal|22
index|]
decl_stmt|;
name|int
name|xogc
decl_stmt|,
name|xok
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|x
decl_stmt|;
name|TDA9887_init
argument_list|(
name|bktr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|21
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|MT2032_GetRegister
argument_list|(
name|i
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
break|break;
name|rdbuf
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|21
condition|)
return|return
operator|-
literal|1
return|;
name|printf
argument_list|(
literal|"%s: MT2032: Companycode=%02x%02x Part=%02x Revision=%02x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|rdbuf
index|[
literal|0x11
index|]
argument_list|,
name|rdbuf
index|[
literal|0x12
index|]
argument_list|,
name|rdbuf
index|[
literal|0x13
index|]
argument_list|,
name|rdbuf
index|[
literal|0x14
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdbuf
index|[
literal|0x13
index|]
operator|!=
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"%s: MT2032 not found or unknown type\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Initialize Registers per spec. */
name|MT2032_SetRegister
argument_list|(
literal|2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|3
argument_list|,
literal|0x0f
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|4
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|6
argument_list|,
literal|0xe4
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|7
argument_list|,
literal|0x8f
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|8
argument_list|,
literal|0xc3
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|9
argument_list|,
literal|0x4e
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|10
argument_list|,
literal|0xec
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|13
argument_list|,
literal|0x32
argument_list|)
expr_stmt|;
comment|/* Adjust XOGC (register 7), wait for XOK */
name|xogc
operator|=
literal|7
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|xok
operator|=
name|MT2032_GetRegister
argument_list|(
literal|0x0e
argument_list|)
operator|&
literal|0x01
expr_stmt|;
if|if
condition|(
name|xok
operator|==
literal|1
condition|)
block|{
break|break;
block|}
name|xogc
operator|--
expr_stmt|;
if|if
condition|(
name|xogc
operator|==
literal|3
condition|)
block|{
name|xogc
operator|=
literal|4
expr_stmt|;
comment|/* min. 4 per spec */
break|break;
block|}
name|MT2032_SetRegister
argument_list|(
literal|7
argument_list|,
literal|0x88
operator|+
name|xogc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|xok
operator|!=
literal|1
condition|)
do|;
name|TDA9887_init
argument_list|(
name|bktr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MT2032_XOGC
operator|=
name|xogc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|MT2032_SpurCheck
parameter_list|(
name|int
name|f1
parameter_list|,
name|int
name|f2
parameter_list|,
name|int
name|spectrum_from
parameter_list|,
name|int
name|spectrum_to
parameter_list|)
block|{
name|int
name|n1
init|=
literal|1
decl_stmt|,
name|n2
decl_stmt|,
name|f
decl_stmt|;
name|f1
operator|=
name|f1
operator|/
literal|1000
expr_stmt|;
comment|/* scale to kHz to avoid 32bit overflows */
name|f2
operator|=
name|f2
operator|/
literal|1000
expr_stmt|;
name|spectrum_from
operator|/=
literal|1000
expr_stmt|;
name|spectrum_to
operator|/=
literal|1000
expr_stmt|;
do|do
block|{
name|n2
operator|=
operator|-
name|n1
expr_stmt|;
name|f
operator|=
name|n1
operator|*
operator|(
name|f1
operator|-
name|f2
operator|)
expr_stmt|;
do|do
block|{
name|n2
operator|--
expr_stmt|;
name|f
operator|=
name|f
operator|-
name|f2
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|>
name|spectrum_from
operator|)
operator|&&
operator|(
name|f
operator|<
name|spectrum_to
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
do|while
condition|(
operator|(
name|f
operator|>
operator|(
name|f2
operator|-
name|spectrum_to
operator|)
operator|)
operator|||
operator|(
name|n2
operator|>
operator|-
literal|5
operator|)
condition|)
do|;
name|n1
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|n1
operator|<
literal|5
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|MT2032_ComputeFreq
parameter_list|(
name|int
name|rfin
parameter_list|,
name|int
name|if1
parameter_list|,
name|int
name|if2
parameter_list|,
name|int
name|spectrum_from
parameter_list|,
name|int
name|spectrum_to
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|ret_sel
parameter_list|,
name|int
name|xogc
parameter_list|)
block|{
comment|/* all in Hz */
name|int
name|fref
decl_stmt|,
name|lo1
decl_stmt|,
name|lo1n
decl_stmt|,
name|lo1a
decl_stmt|,
name|s
decl_stmt|,
name|sel
decl_stmt|;
name|int
name|lo1freq
decl_stmt|,
name|desired_lo1
decl_stmt|,
name|desired_lo2
decl_stmt|,
name|lo2
decl_stmt|,
name|lo2n
decl_stmt|,
name|lo2a
decl_stmt|,
name|lo2num
decl_stmt|,
name|lo2freq
decl_stmt|;
name|int
name|nLO1adjust
decl_stmt|;
name|fref
operator|=
literal|5250
operator|*
literal|1000
expr_stmt|;
comment|/* 5.25MHz */
comment|/* per spec 2.3.1 */
name|desired_lo1
operator|=
name|rfin
operator|+
name|if1
expr_stmt|;
name|lo1
operator|=
operator|(
literal|2
operator|*
operator|(
name|desired_lo1
operator|/
literal|1000
operator|)
operator|+
operator|(
name|fref
operator|/
literal|1000
operator|)
operator|)
operator|/
operator|(
literal|2
operator|*
name|fref
operator|/
literal|1000
operator|)
expr_stmt|;
name|lo1freq
operator|=
name|lo1
operator|*
name|fref
expr_stmt|;
name|desired_lo2
operator|=
name|lo1freq
operator|-
name|rfin
operator|-
name|if2
expr_stmt|;
comment|/* per spec 2.3.2 */
for|for
control|(
name|nLO1adjust
operator|=
literal|1
init|;
name|nLO1adjust
operator|<
literal|3
condition|;
name|nLO1adjust
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|MT2032_SpurCheck
argument_list|(
name|lo1freq
argument_list|,
name|desired_lo2
argument_list|,
name|spectrum_from
argument_list|,
name|spectrum_to
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|lo1freq
operator|<
name|desired_lo1
condition|)
block|{
name|lo1
operator|+=
name|nLO1adjust
expr_stmt|;
block|}
else|else
block|{
name|lo1
operator|-=
name|nLO1adjust
expr_stmt|;
block|}
name|lo1freq
operator|=
name|lo1
operator|*
name|fref
expr_stmt|;
name|desired_lo2
operator|=
name|lo1freq
operator|-
name|rfin
operator|-
name|if2
expr_stmt|;
block|}
comment|/* per spec 2.3.3 */
name|s
operator|=
name|lo1freq
operator|/
literal|1000
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|MT2032_OPTIMIZE_VCO
condition|)
block|{
if|if
condition|(
name|s
operator|>
literal|1890
condition|)
block|{
name|sel
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|>
literal|1720
condition|)
block|{
name|sel
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|>
literal|1530
condition|)
block|{
name|sel
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|>
literal|1370
condition|)
block|{
name|sel
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|sel
operator|=
literal|4
expr_stmt|;
comment|/*>1090 */
block|}
block|}
else|else
block|{
if|if
condition|(
name|s
operator|>
literal|1790
condition|)
block|{
name|sel
operator|=
literal|0
expr_stmt|;
comment|/*<1958 */
block|}
elseif|else
if|if
condition|(
name|s
operator|>
literal|1617
condition|)
block|{
name|sel
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|>
literal|1449
condition|)
block|{
name|sel
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|>
literal|1291
condition|)
block|{
name|sel
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|sel
operator|=
literal|4
expr_stmt|;
comment|/*>1090 */
block|}
block|}
operator|*
name|ret_sel
operator|=
name|sel
expr_stmt|;
comment|/* per spec 2.3.4 */
name|lo1n
operator|=
name|lo1
operator|/
literal|8
expr_stmt|;
name|lo1a
operator|=
name|lo1
operator|-
operator|(
name|lo1n
operator|*
literal|8
operator|)
expr_stmt|;
name|lo2
operator|=
name|desired_lo2
operator|/
name|fref
expr_stmt|;
name|lo2n
operator|=
name|lo2
operator|/
literal|8
expr_stmt|;
name|lo2a
operator|=
name|lo2
operator|-
operator|(
name|lo2n
operator|*
literal|8
operator|)
expr_stmt|;
comment|/* scale to fit in 32bit arith */
name|lo2num
operator|=
operator|(
operator|(
name|desired_lo2
operator|/
literal|1000
operator|)
operator|%
operator|(
name|fref
operator|/
literal|1000
operator|)
operator|)
operator|*
literal|3780
operator|/
operator|(
name|fref
operator|/
literal|1000
operator|)
expr_stmt|;
name|lo2freq
operator|=
operator|(
name|lo2a
operator|+
literal|8
operator|*
name|lo2n
operator|)
operator|*
name|fref
operator|+
name|lo2num
operator|*
operator|(
name|fref
operator|/
literal|1000
operator|)
operator|/
literal|3780
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|lo1a
operator|<
literal|0
operator|||
name|lo1a
operator|>
literal|7
operator|||
name|lo1n
operator|<
literal|17
operator|||
name|lo1n
operator|>
literal|48
operator|||
name|lo2a
operator|<
literal|0
operator|||
name|lo2a
operator|>
literal|7
operator|||
name|lo2n
operator|<
literal|17
operator|||
name|lo2n
operator|>
literal|30
condition|)
block|{
name|printf
argument_list|(
literal|"MT2032: parameter out of range\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* set up MT2032 register map for transfer over i2c */
name|buf
index|[
literal|0
index|]
operator|=
name|lo1n
operator|-
literal|1
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|lo1a
operator||
operator|(
name|sel
operator|<<
literal|4
operator|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|0x86
expr_stmt|;
comment|/* LOGC */
name|buf
index|[
literal|3
index|]
operator|=
literal|0x0f
expr_stmt|;
comment|/* reserved */
name|buf
index|[
literal|4
index|]
operator|=
literal|0x1f
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
operator|(
name|lo2n
operator|-
literal|1
operator|)
operator||
operator|(
name|lo2a
operator|<<
literal|5
operator|)
expr_stmt|;
if|if
condition|(
name|rfin
operator|<
literal|400
operator|*
literal|1000
operator|*
literal|1000
condition|)
block|{
name|buf
index|[
literal|6
index|]
operator|=
literal|0xe4
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|6
index|]
operator|=
literal|0xf4
expr_stmt|;
comment|/* set PKEN per rev 1.2 */
block|}
name|buf
index|[
literal|7
index|]
operator|=
literal|8
operator|+
name|xogc
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
literal|0xc3
expr_stmt|;
comment|/* reserved */
name|buf
index|[
literal|9
index|]
operator|=
literal|0x4e
expr_stmt|;
comment|/* reserved */
name|buf
index|[
literal|10
index|]
operator|=
literal|0xec
expr_stmt|;
comment|/* reserved */
name|buf
index|[
literal|11
index|]
operator|=
operator|(
name|lo2num
operator|&
literal|0xff
operator|)
expr_stmt|;
name|buf
index|[
literal|12
index|]
operator|=
operator|(
name|lo2num
operator|>>
literal|8
operator|)
operator||
literal|0x80
expr_stmt|;
comment|/* Lo2RST */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|MT2032_CheckLOLock
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|int
name|t
decl_stmt|,
name|lock
init|=
literal|0
decl_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|10
condition|;
name|t
operator|++
control|)
block|{
name|lock
operator|=
name|MT2032_GetRegister
argument_list|(
literal|0x0e
argument_list|)
operator|&
literal|0x06
expr_stmt|;
if|if
condition|(
name|lock
operator|==
literal|6
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
name|lock
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|MT2032_OptimizeVCO
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|sel
parameter_list|,
name|int
name|lock
parameter_list|)
block|{
name|int
name|tad1
decl_stmt|,
name|lo1a
decl_stmt|;
name|tad1
operator|=
name|MT2032_GetRegister
argument_list|(
literal|0x0f
argument_list|)
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
name|tad1
operator|==
literal|0
condition|)
block|{
return|return
name|lock
return|;
block|}
if|if
condition|(
name|tad1
operator|==
literal|1
condition|)
block|{
return|return
name|lock
return|;
block|}
if|if
condition|(
name|tad1
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|sel
operator|==
literal|0
condition|)
block|{
return|return
name|lock
return|;
block|}
else|else
block|{
name|sel
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sel
operator|<
literal|4
condition|)
block|{
name|sel
operator|++
expr_stmt|;
block|}
else|else
block|{
return|return
name|lock
return|;
block|}
block|}
name|lo1a
operator|=
name|MT2032_GetRegister
argument_list|(
literal|0x01
argument_list|)
operator|&
literal|0x07
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|0x01
argument_list|,
name|lo1a
operator||
operator|(
name|sel
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|lock
operator|=
name|MT2032_CheckLOLock
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
return|return
name|lock
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|MT2032_SetIFFreq
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|rfin
parameter_list|,
name|int
name|if1
parameter_list|,
name|int
name|if2
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|21
index|]
decl_stmt|;
name|int
name|lint_try
decl_stmt|,
name|sel
decl_stmt|,
name|lock
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|MT2032_ComputeFreq
argument_list|(
name|rfin
argument_list|,
name|if1
argument_list|,
name|if2
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|sel
argument_list|,
name|MT2032_XOGC
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|TDA9887_init
argument_list|(
name|bktr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send only the relevant registers per Rev. 1.2 */
name|MT2032_SetRegister
argument_list|(
literal|0
argument_list|,
name|buf
index|[
literal|0x00
index|]
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|1
argument_list|,
name|buf
index|[
literal|0x01
index|]
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|2
argument_list|,
name|buf
index|[
literal|0x02
index|]
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|5
argument_list|,
name|buf
index|[
literal|0x05
index|]
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|6
argument_list|,
name|buf
index|[
literal|0x06
index|]
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|7
argument_list|,
name|buf
index|[
literal|0x07
index|]
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|11
argument_list|,
name|buf
index|[
literal|0x0B
index|]
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|12
argument_list|,
name|buf
index|[
literal|0x0C
index|]
argument_list|)
expr_stmt|;
comment|/* wait for PLLs to lock (per manual), retry LINT if not. */
for|for
control|(
name|lint_try
operator|=
literal|0
init|;
name|lint_try
operator|<
literal|2
condition|;
name|lint_try
operator|++
control|)
block|{
name|lock
operator|=
name|MT2032_CheckLOLock
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
if|if
condition|(
name|MT2032_OPTIMIZE_VCO
condition|)
block|{
name|lock
operator|=
name|MT2032_OptimizeVCO
argument_list|(
name|bktr
argument_list|,
name|sel
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock
operator|==
literal|6
condition|)
block|{
break|break;
block|}
comment|/* set LINT to re-init PLLs */
name|MT2032_SetRegister
argument_list|(
literal|7
argument_list|,
literal|0x80
operator|+
literal|8
operator|+
name|MT2032_XOGC
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|7
argument_list|,
literal|8
operator|+
name|MT2032_XOGC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock
operator|!=
literal|6
condition|)
name|printf
argument_list|(
literal|"%s: PLL didn't lock\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
name|MT2032_SetRegister
argument_list|(
literal|2
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|TDA9887_init
argument_list|(
name|bktr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mt2032_set_tv_freq
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|int
name|freq
parameter_list|)
block|{
name|int
name|if2
decl_stmt|,
name|from
decl_stmt|,
name|to
decl_stmt|;
name|int
name|stat
decl_stmt|,
name|tad
decl_stmt|;
ifdef|#
directive|ifdef
name|MT2032_NTSC
name|from
operator|=
literal|40750
operator|*
literal|1000
expr_stmt|;
name|to
operator|=
literal|46750
operator|*
literal|1000
expr_stmt|;
name|if2
operator|=
literal|45750
operator|*
literal|1000
expr_stmt|;
else|#
directive|else
name|from
operator|=
literal|32900
operator|*
literal|1000
expr_stmt|;
name|to
operator|=
literal|39900
operator|*
literal|1000
expr_stmt|;
name|if2
operator|=
literal|38900
operator|*
literal|1000
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|MT2032_SetIFFreq
argument_list|(
name|bktr
argument_list|,
name|freq
operator|*
literal|62500
comment|/* freq*1000*1000/16 */
argument_list|,
literal|1090
operator|*
literal|1000
operator|*
literal|1000
argument_list|,
name|if2
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
name|freq
expr_stmt|;
name|stat
operator|=
name|MT2032_GetRegister
argument_list|(
literal|0x0e
argument_list|)
expr_stmt|;
name|tad
operator|=
name|MT2032_GetRegister
argument_list|(
literal|0x0f
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: frequency set to %d, st = %#x, tad = %#x\n"
argument_list|,
name|bktr_name
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|freq
operator|*
literal|62500
argument_list|,
name|stat
argument_list|,
name|tad
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

