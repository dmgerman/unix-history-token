begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005 Poul-Henning Kamp  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ia64__
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEV_APIC
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"opt_apic.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/timeet.h>
end_include

begin_include
include|#
directive|include
file|<sys/timetc.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpi_hpet.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_APIC
end_ifdef

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HPET_VENDID_AMD
value|0x4353
end_define

begin_define
define|#
directive|define
name|HPET_VENDID_INTEL
value|0x8086
end_define

begin_expr_stmt
name|ACPI_SERIAL_DECL
argument_list|(
name|hpet
argument_list|,
literal|"ACPI HPET support"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|hpet_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ACPI CA debugging */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_TIMER
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"HPET"
argument_list|)
end_macro

begin_struct
struct|struct
name|hpet_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|mem_rid
decl_stmt|;
name|int
name|intr_rid
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|int
name|useirq
decl_stmt|;
name|struct
name|resource
modifier|*
name|mem_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|intr_res
decl_stmt|;
name|void
modifier|*
name|intr_handle
decl_stmt|;
name|ACPI_HANDLE
name|handle
decl_stmt|;
name|uint64_t
name|freq
decl_stmt|;
name|struct
name|timecounter
name|tc
decl_stmt|;
struct|struct
name|hpet_timer
block|{
name|struct
name|eventtimer
name|et
decl_stmt|;
name|struct
name|hpet_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|intr_rid
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|int
name|pcpu_master
decl_stmt|;
name|int
name|pcpu_slaves
index|[
name|MAXCPU
index|]
decl_stmt|;
name|struct
name|resource
modifier|*
name|intr_res
decl_stmt|;
name|void
modifier|*
name|intr_handle
decl_stmt|;
name|uint32_t
name|caps
decl_stmt|;
name|uint32_t
name|vectors
decl_stmt|;
name|uint32_t
name|div
decl_stmt|;
name|uint32_t
name|last
decl_stmt|;
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
block|}
name|t
index|[
literal|32
index|]
struct|;
name|int
name|num_timers
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|u_int
name|hpet_get_timecount
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpet_test
parameter_list|(
name|struct
name|hpet_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hpet_ids
index|[]
init|=
block|{
literal|"PNP0103"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|u_int
name|hpet_get_timecount
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
block|{
name|struct
name|hpet_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|tc
operator|->
name|tc_priv
expr_stmt|;
return|return
operator|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_MAIN_COUNTER
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpet_enable
parameter_list|(
name|struct
name|hpet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|HPET_CNF_LEG_RT
expr_stmt|;
name|val
operator||=
name|HPET_CNF_ENABLE
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpet_disable
parameter_list|(
name|struct
name|hpet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|HPET_CNF_ENABLE
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpet_start
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|,
name|struct
name|bintime
modifier|*
name|first
parameter_list|,
name|struct
name|bintime
modifier|*
name|period
parameter_list|)
block|{
name|struct
name|hpet_timer
modifier|*
name|mt
init|=
operator|(
expr|struct
name|hpet_timer
operator|*
operator|)
name|et
operator|->
name|et_priv
decl_stmt|;
name|struct
name|hpet_timer
modifier|*
name|t
decl_stmt|;
name|struct
name|hpet_softc
modifier|*
name|sc
init|=
name|mt
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|fdiv
decl_stmt|;
name|t
operator|=
operator|(
name|mt
operator|->
name|pcpu_master
operator|<
literal|0
operator|)
condition|?
name|mt
else|:
operator|&
name|sc
operator|->
name|t
index|[
name|mt
operator|->
name|pcpu_slaves
index|[
name|curcpu
index|]
index|]
expr_stmt|;
if|if
condition|(
name|period
operator|!=
name|NULL
condition|)
block|{
name|t
operator|->
name|mode
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|div
operator|=
operator|(
name|sc
operator|->
name|freq
operator|*
operator|(
name|period
operator|->
name|frac
operator|>>
literal|32
operator|)
operator|)
operator|>>
literal|32
expr_stmt|;
if|if
condition|(
name|period
operator|->
name|sec
operator|!=
literal|0
condition|)
name|t
operator|->
name|div
operator|+=
name|sc
operator|->
name|freq
operator|*
name|period
operator|->
name|sec
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
name|first
operator|=
name|period
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|mode
operator|=
literal|2
expr_stmt|;
name|t
operator|->
name|div
operator|=
literal|0
expr_stmt|;
block|}
name|fdiv
operator|=
operator|(
name|sc
operator|->
name|freq
operator|*
operator|(
name|first
operator|->
name|frac
operator|>>
literal|32
operator|)
operator|)
operator|>>
literal|32
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|sec
operator|!=
literal|0
condition|)
name|fdiv
operator|+=
name|sc
operator|->
name|freq
operator|*
name|first
operator|->
name|sec
expr_stmt|;
name|t
operator|->
name|last
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_MAIN_COUNTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|mode
operator|==
literal|1
operator|&&
operator|(
name|t
operator|->
name|caps
operator|&
name|HPET_TCAP_PER_INT
operator|)
condition|)
block|{
name|t
operator|->
name|caps
operator||=
name|HPET_TCNF_TYPE
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_CAP_CNF
argument_list|(
name|t
operator|->
name|num
argument_list|)
argument_list|,
name|t
operator|->
name|caps
operator||
name|HPET_TCNF_VAL_SET
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_COMPARATOR
argument_list|(
name|t
operator|->
name|num
argument_list|)
argument_list|,
name|t
operator|->
name|last
operator|+
name|fdiv
argument_list|)
expr_stmt|;
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_COMPARATOR
argument_list|(
name|t
operator|->
name|num
argument_list|)
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_COMPARATOR
argument_list|(
name|t
operator|->
name|num
argument_list|)
argument_list|,
name|t
operator|->
name|div
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_COMPARATOR
argument_list|(
name|t
operator|->
name|num
argument_list|)
argument_list|,
name|t
operator|->
name|last
operator|+
name|fdiv
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|caps
operator||=
name|HPET_TCNF_INT_ENB
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_ISR
argument_list|,
literal|1
operator|<<
name|t
operator|->
name|num
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_CAP_CNF
argument_list|(
name|t
operator|->
name|num
argument_list|)
argument_list|,
name|t
operator|->
name|caps
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpet_stop
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|)
block|{
name|struct
name|hpet_timer
modifier|*
name|mt
init|=
operator|(
expr|struct
name|hpet_timer
operator|*
operator|)
name|et
operator|->
name|et_priv
decl_stmt|;
name|struct
name|hpet_timer
modifier|*
name|t
decl_stmt|;
name|struct
name|hpet_softc
modifier|*
name|sc
init|=
name|mt
operator|->
name|sc
decl_stmt|;
name|t
operator|=
operator|(
name|mt
operator|->
name|pcpu_master
operator|<
literal|0
operator|)
condition|?
name|mt
else|:
operator|&
name|sc
operator|->
name|t
index|[
name|mt
operator|->
name|pcpu_slaves
index|[
name|curcpu
index|]
index|]
expr_stmt|;
name|t
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|caps
operator|&=
operator|~
operator|(
name|HPET_TCNF_INT_ENB
operator||
name|HPET_TCNF_TYPE
operator|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_CAP_CNF
argument_list|(
name|t
operator|->
name|num
argument_list|)
argument_list|,
name|t
operator|->
name|caps
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpet_intr_single
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hpet_timer
modifier|*
name|t
init|=
operator|(
expr|struct
name|hpet_timer
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|hpet_timer
modifier|*
name|mt
decl_stmt|;
name|struct
name|hpet_softc
modifier|*
name|sc
init|=
name|t
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|now
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|mode
operator|==
literal|1
operator|&&
operator|(
name|t
operator|->
name|caps
operator|&
name|HPET_TCAP_PER_INT
operator|)
operator|==
literal|0
condition|)
block|{
name|t
operator|->
name|last
operator|+=
name|t
operator|->
name|div
expr_stmt|;
name|now
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_MAIN_COUNTER
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|int32_t
call|)
argument_list|(
name|now
operator|-
operator|(
name|t
operator|->
name|last
operator|+
name|t
operator|->
name|div
operator|/
literal|2
operator|)
argument_list|)
operator|>
literal|0
condition|)
name|t
operator|->
name|last
operator|=
name|now
operator|-
name|t
operator|->
name|div
operator|/
literal|2
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_COMPARATOR
argument_list|(
name|t
operator|->
name|num
argument_list|)
argument_list|,
name|t
operator|->
name|last
operator|+
name|t
operator|->
name|div
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|mode
operator|==
literal|2
condition|)
name|t
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|mt
operator|=
operator|(
name|t
operator|->
name|pcpu_master
operator|<
literal|0
operator|)
condition|?
name|t
else|:
operator|&
name|sc
operator|->
name|t
index|[
name|t
operator|->
name|pcpu_master
index|]
expr_stmt|;
if|if
condition|(
name|mt
operator|->
name|et
operator|.
name|et_active
condition|)
block|{
name|mt
operator|->
name|et
operator|.
name|et_event_cb
argument_list|(
operator|&
name|mt
operator|->
name|et
argument_list|,
name|mt
operator|->
name|et
operator|.
name|et_arg
condition|?
name|mt
operator|->
name|et
operator|.
name|et_arg
else|:
name|curthread
operator|->
name|td_intr_frame
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpet_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hpet_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|hpet_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_ISR
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_ISR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
name|sc
operator|->
name|useirq
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_timers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|hpet_intr_single
argument_list|(
operator|&
name|sc
operator|->
name|t
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
return|return
operator|(
name|FILTER_STRAY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|hpet_find
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
modifier|*
name|status
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|ids
decl_stmt|;
name|uint32_t
name|id
init|=
operator|(
name|uint32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|context
decl_stmt|;
name|uint32_t
name|uid
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ids
operator|=
name|hpet_ids
init|;
operator|*
name|ids
operator|!=
name|NULL
condition|;
name|ids
operator|++
control|)
block|{
if|if
condition|(
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
operator|*
name|ids
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|ids
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|acpi_GetInteger
argument_list|(
name|handle
argument_list|,
literal|"_UID"
argument_list|,
operator|&
name|uid
argument_list|)
argument_list|)
operator|||
name|id
operator|==
name|uid
condition|)
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|status
operator|)
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Discover the HPET via the ACPI table of the same name. */
end_comment

begin_function
specifier|static
name|void
name|hpet_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|ACPI_TABLE_HPET
modifier|*
name|hpet
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
decl_stmt|;
comment|/* Only one HPET device can be added. */
if|if
condition|(
name|devclass_get_device
argument_list|(
name|hpet_devclass
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
comment|/* Search for HPET table. */
name|status
operator|=
name|AcpiGetTable
argument_list|(
name|ACPI_SIG_HPET
argument_list|,
name|i
argument_list|,
operator|(
name|ACPI_TABLE_HEADER
operator|*
operator|*
operator|)
operator|&
name|hpet
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return;
comment|/* Search for HPET device with same ID. */
name|found
operator|=
literal|0
expr_stmt|;
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_DEVICE
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
literal|100
argument_list|,
name|hpet_find
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|hpet
operator|->
name|Sequence
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|found
argument_list|)
expr_stmt|;
comment|/* If found - let it be probed in normal way. */
if|if
condition|(
name|found
condition|)
continue|continue;
comment|/* If not - create it from table info. */
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
name|ACPI_DEV_BASE_ORDER
argument_list|,
literal|"hpet"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't add child\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bus_set_resource
argument_list|(
name|child
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|hpet
operator|->
name|Address
operator|.
name|Address
argument_list|,
name|HPET_MEM_WIDTH
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hpet_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"hpet"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|!=
name|NULL
operator|&&
name|ACPI_ID_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|hpet_ids
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"High Precision Event Timer"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpet_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hpet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hpet_timer
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|num_msi
decl_stmt|,
name|num_timers
decl_stmt|,
name|num_percpu_et
decl_stmt|,
name|num_percpu_t
decl_stmt|,
name|cur_cpu
decl_stmt|;
name|int
name|pcpu_master
decl_stmt|;
specifier|static
name|int
name|maxhpetet
init|=
literal|0
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|val2
decl_stmt|,
name|cvectors
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|,
name|rev
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|mem_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Validate that we can access the whole region. */
if|if
condition|(
name|rman_get_size
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
operator|<
name|HPET_MEM_WIDTH
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"memory region width %ld too small\n"
argument_list|,
name|rman_get_size
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|)
expr_stmt|;
name|bus_free_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Be sure timer is enabled. */
name|hpet_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Read basic statistics about the timer. */
name|val
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_PERIOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid period\n"
argument_list|)
expr_stmt|;
name|hpet_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_free_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|freq
operator|=
operator|(
literal|1000000000000000LL
operator|+
name|val
operator|/
literal|2
operator|)
operator|/
name|val
expr_stmt|;
name|val
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_CAPABILITIES
argument_list|)
expr_stmt|;
name|vendor
operator|=
operator|(
name|val
operator|&
name|HPET_CAP_VENDOR_ID
operator|)
operator|>>
literal|16
expr_stmt|;
name|rev
operator|=
name|val
operator|&
name|HPET_CAP_REV_ID
expr_stmt|;
name|num_timers
operator|=
literal|1
operator|+
operator|(
operator|(
name|val
operator|&
name|HPET_CAP_NUM_TIM
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
comment|/* 	 * ATI/AMD violates IA-PC HPET (High Precision Event Timers) 	 * Specification and provides an off by one number 	 * of timers/comparators. 	 * Additionally, they use unregistered value in VENDOR_ID field. 	 */
if|if
condition|(
name|vendor
operator|==
name|HPET_VENDID_AMD
operator|&&
name|rev
operator|<
literal|0x10
operator|&&
name|num_timers
operator|>
literal|0
condition|)
name|num_timers
operator|--
expr_stmt|;
name|sc
operator|->
name|num_timers
operator|=
name|num_timers
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"vendor 0x%x, rev 0x%x, %jdHz%s, %d timers,%s\n"
argument_list|,
name|vendor
argument_list|,
name|rev
argument_list|,
name|sc
operator|->
name|freq
argument_list|,
operator|(
name|val
operator|&
name|HPET_CAP_COUNT_SIZE
operator|)
condition|?
literal|" 64bit"
else|:
literal|""
argument_list|,
name|num_timers
argument_list|,
operator|(
name|val
operator|&
name|HPET_CAP_LEG_RT
operator|)
condition|?
literal|" legacy route"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|num_msi
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_timers
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
operator|&
name|sc
operator|->
name|t
index|[
name|i
index|]
expr_stmt|;
name|t
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|t
operator|->
name|num
operator|=
name|i
expr_stmt|;
name|t
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|intr_rid
operator|=
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|irq
operator|=
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|pcpu_master
operator|=
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|caps
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_CAP_CNF
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|vectors
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_CAP_CNF
argument_list|(
name|i
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|" t%d: irqs 0x%08x (%d)%s%s%s\n"
argument_list|,
name|i
argument_list|,
name|t
operator|->
name|vectors
argument_list|,
operator|(
name|t
operator|->
name|caps
operator|&
name|HPET_TCNF_INT_ROUTE
operator|)
operator|>>
literal|9
argument_list|,
operator|(
name|t
operator|->
name|caps
operator|&
name|HPET_TCAP_FSB_INT_DEL
operator|)
condition|?
literal|", MSI"
else|:
literal|""
argument_list|,
operator|(
name|t
operator|->
name|caps
operator|&
name|HPET_TCAP_SIZE
operator|)
condition|?
literal|", 64bit"
else|:
literal|""
argument_list|,
operator|(
name|t
operator|->
name|caps
operator|&
name|HPET_TCAP_PER_INT
operator|)
condition|?
literal|", periodic"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEV_APIC
if|if
condition|(
name|t
operator|->
name|caps
operator|&
name|HPET_TCAP_FSB_INT_DEL
condition|)
name|num_msi
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|testenv
argument_list|(
literal|"debug.acpi.hpet_test"
argument_list|)
condition|)
name|hpet_test
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Don't attach if the timer never increments.  Since the spec 	 * requires it to be at least 10 MHz, it has to change in 1 us. 	 */
name|val
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_MAIN_COUNTER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|val2
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_MAIN_COUNTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|val2
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"HPET never increments, disabling\n"
argument_list|)
expr_stmt|;
name|hpet_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_free_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Announce first HPET as timecounter. */
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tc
operator|.
name|tc_get_timecount
operator|=
name|hpet_get_timecount
operator|,
name|sc
operator|->
name|tc
operator|.
name|tc_counter_mask
operator|=
operator|~
literal|0u
operator|,
name|sc
operator|->
name|tc
operator|.
name|tc_name
operator|=
literal|"HPET"
operator|,
name|sc
operator|->
name|tc
operator|.
name|tc_quality
operator|=
literal|900
operator|,
name|sc
operator|->
name|tc
operator|.
name|tc_frequency
operator|=
name|sc
operator|->
name|freq
expr_stmt|;
name|sc
operator|->
name|tc
operator|.
name|tc_priv
operator|=
name|sc
expr_stmt|;
name|tc_init
argument_list|(
operator|&
name|sc
operator|->
name|tc
argument_list|)
expr_stmt|;
block|}
comment|/* If not disabled - setup and announce event timers. */
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"clock"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|&&
name|i
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|num_percpu_et
operator|=
name|min
argument_list|(
name|num_msi
operator|/
name|mp_ncpus
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|num_percpu_t
operator|=
name|num_percpu_et
operator|*
name|mp_ncpus
expr_stmt|;
name|cur_cpu
operator|=
name|CPU_FIRST
argument_list|()
expr_stmt|;
name|pcpu_master
operator|=
literal|0
expr_stmt|;
comment|/* Find common legacy IRQ vectors for all timers. */
name|cvectors
operator|=
literal|0xffff0000
expr_stmt|;
comment|/* 	 * HPETs in AMD chipsets before SB800 have problems with IRQs>= 16 	 * Lower are also not always working for different reasons. 	 * SB800 fixed it, but seems do not implements level triggering 	 * properly, that makes it very unreliable - it freezes after any 	 * interrupt loss. Avoid legacy IRQs for AMD. 	 */
if|if
condition|(
name|vendor
operator|==
name|HPET_VENDID_AMD
condition|)
name|cvectors
operator|=
literal|0x00000000
expr_stmt|;
name|sc
operator|->
name|useirq
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_timers
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
operator|&
name|sc
operator|->
name|t
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_APIC
if|if
condition|(
name|t
operator|->
name|caps
operator|&
name|HPET_TCAP_FSB_INT_DEL
condition|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|PCIB_ALLOC_MSIX
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|dev
argument_list|,
operator|&
name|t
operator|->
name|irq
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't allocate interrupt: %d.\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|intr_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|t
operator|->
name|intr_rid
argument_list|,
name|t
operator|->
name|irq
argument_list|,
name|t
operator|->
name|irq
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't map interrupt.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|t
operator|->
name|intr_res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_CLK
argument_list|,
operator|(
name|driver_filter_t
operator|*
operator|)
name|hpet_intr_single
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|,
operator|&
name|t
operator|->
name|intr_handle
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't setup interrupt.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|t
operator|->
name|intr_res
argument_list|,
name|t
operator|->
name|intr_handle
argument_list|,
literal|"t%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|num_msi
operator|++
expr_stmt|;
if|if
condition|(
name|num_percpu_t
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cur_cpu
operator|==
name|CPU_FIRST
argument_list|()
condition|)
name|pcpu_master
operator|=
name|i
expr_stmt|;
name|t
operator|->
name|pcpu_master
operator|=
name|pcpu_master
expr_stmt|;
name|sc
operator|->
name|t
index|[
name|pcpu_master
index|]
operator|.
name|pcpu_slaves
index|[
name|cur_cpu
index|]
operator|=
name|i
expr_stmt|;
name|bus_bind_intr
argument_list|(
name|dev
argument_list|,
name|t
operator|->
name|intr_res
argument_list|,
name|cur_cpu
argument_list|)
expr_stmt|;
name|cur_cpu
operator|=
name|CPU_NEXT
argument_list|(
name|cur_cpu
argument_list|)
expr_stmt|;
name|num_percpu_t
operator|--
expr_stmt|;
block|}
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|(
name|cvectors
operator|&
name|t
operator|->
name|vectors
operator|)
operator|!=
literal|0
condition|)
block|{
name|cvectors
operator|&=
name|t
operator|->
name|vectors
expr_stmt|;
name|sc
operator|->
name|useirq
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
block|}
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_ISR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|intr_rid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If at least one timer needs legacy IRQ - setup it. */
if|if
condition|(
name|sc
operator|->
name|useirq
condition|)
block|{
name|j
operator|=
name|i
operator|=
name|fls
argument_list|(
name|cvectors
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|>
literal|0
operator|&&
operator|(
name|cvectors
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|j
operator|--
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|intr_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|intr_rid
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't map interrupt.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|intr_res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_CLK
argument_list|,
operator|(
name|driver_filter_t
operator|*
operator|)
name|hpet_intr
argument_list|,
name|NULL
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_handle
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't setup interrupt.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|irq
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|intr_res
argument_list|)
expr_stmt|;
comment|/* Bind IRQ to BSP to avoid live migration. */
name|bus_bind_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|intr_res
argument_list|,
name|CPU_FIRST
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Program and announce event timers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_timers
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
operator|&
name|sc
operator|->
name|t
index|[
name|i
index|]
expr_stmt|;
name|t
operator|->
name|caps
operator|&=
operator|~
operator|(
name|HPET_TCNF_FSB_EN
operator||
name|HPET_TCNF_INT_ROUTE
operator|)
expr_stmt|;
name|t
operator|->
name|caps
operator|&=
operator|~
operator|(
name|HPET_TCNF_VAL_SET
operator||
name|HPET_TCNF_INT_ENB
operator|)
expr_stmt|;
name|t
operator|->
name|caps
operator||=
name|HPET_TCNF_32MODE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_APIC
if|if
condition|(
name|t
operator|->
name|irq
operator|>=
literal|0
condition|)
block|{
name|uint64_t
name|addr
decl_stmt|;
name|uint32_t
name|data
decl_stmt|;
if|if
condition|(
name|PCIB_MAP_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|dev
argument_list|,
name|t
operator|->
name|irq
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|data
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_FSB_ADDR
argument_list|(
name|i
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_FSB_VAL
argument_list|(
name|i
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|t
operator|->
name|caps
operator||=
name|HPET_TCNF_FSB_EN
expr_stmt|;
block|}
else|else
name|t
operator|->
name|irq
operator|=
operator|-
literal|2
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|irq
operator|>=
literal|0
operator|&&
operator|(
name|t
operator|->
name|vectors
operator|&
operator|(
literal|1
operator|<<
name|sc
operator|->
name|irq
operator|)
operator|)
condition|)
name|t
operator|->
name|caps
operator||=
operator|(
name|sc
operator|->
name|irq
operator|<<
literal|9
operator|)
operator||
name|HPET_TCNF_INT_TYPE
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_CAP_CNF
argument_list|(
name|i
argument_list|)
argument_list|,
name|t
operator|->
name|caps
argument_list|)
expr_stmt|;
comment|/* Skip event timers without set up IRQ. */
if|if
condition|(
name|t
operator|->
name|irq
operator|<
literal|0
operator|&&
operator|(
name|sc
operator|->
name|irq
operator|<
literal|0
operator|||
operator|(
name|t
operator|->
name|vectors
operator|&
operator|(
literal|1
operator|<<
name|sc
operator|->
name|irq
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
comment|/* Announce the reset. */
if|if
condition|(
name|maxhpetet
operator|==
literal|0
condition|)
name|t
operator|->
name|et
operator|.
name|et_name
operator|=
literal|"HPET"
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|t
operator|->
name|name
argument_list|,
literal|"HPET%d"
argument_list|,
name|maxhpetet
argument_list|)
expr_stmt|;
name|t
operator|->
name|et
operator|.
name|et_name
operator|=
name|t
operator|->
name|name
expr_stmt|;
block|}
name|t
operator|->
name|et
operator|.
name|et_flags
operator|=
name|ET_FLAGS_PERIODIC
operator||
name|ET_FLAGS_ONESHOT
expr_stmt|;
name|t
operator|->
name|et
operator|.
name|et_quality
operator|=
literal|450
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|pcpu_master
operator|>=
literal|0
condition|)
block|{
name|t
operator|->
name|et
operator|.
name|et_flags
operator||=
name|ET_FLAGS_PERCPU
expr_stmt|;
name|t
operator|->
name|et
operator|.
name|et_quality
operator|+=
literal|100
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|caps
operator|&
name|HPET_TCAP_PER_INT
operator|)
operator|==
literal|0
condition|)
name|t
operator|->
name|et
operator|.
name|et_quality
operator|-=
literal|10
expr_stmt|;
name|t
operator|->
name|et
operator|.
name|et_frequency
operator|=
name|sc
operator|->
name|freq
expr_stmt|;
name|t
operator|->
name|et
operator|.
name|et_start
operator|=
name|hpet_start
expr_stmt|;
name|t
operator|->
name|et
operator|.
name|et_stop
operator|=
name|hpet_stop
expr_stmt|;
name|t
operator|->
name|et
operator|.
name|et_priv
operator|=
operator|&
name|sc
operator|->
name|t
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|pcpu_master
operator|<
literal|0
operator|||
name|t
operator|->
name|pcpu_master
operator|==
name|i
condition|)
block|{
name|et_register
argument_list|(
operator|&
name|t
operator|->
name|et
argument_list|)
expr_stmt|;
name|maxhpetet
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpet_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX Without a tc_remove() function, we can't detach. */
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpet_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hpet_softc
modifier|*
name|sc
decl_stmt|;
comment|/* 	 * Disable the timer during suspend.  The timer will not lose 	 * its state in S1 or S2, but we are required to disable 	 * it. 	 */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hpet_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpet_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hpet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hpet_timer
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Re-enable the timer after a resume to keep the clock advancing. */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hpet_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Restart event timers that were running on suspend. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_timers
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
operator|&
name|sc
operator|->
name|t
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_APIC
if|if
condition|(
name|t
operator|->
name|irq
operator|>=
literal|0
condition|)
block|{
name|uint64_t
name|addr
decl_stmt|;
name|uint32_t
name|data
decl_stmt|;
if|if
condition|(
name|PCIB_MAP_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|dev
argument_list|,
name|t
operator|->
name|irq
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|data
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_FSB_ADDR
argument_list|(
name|i
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_FSB_VAL
argument_list|(
name|i
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|t
operator|->
name|mode
operator|==
literal|0
condition|)
continue|continue;
name|t
operator|->
name|last
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_MAIN_COUNTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|mode
operator|==
literal|1
operator|&&
operator|(
name|t
operator|->
name|caps
operator|&
name|HPET_TCAP_PER_INT
operator|)
condition|)
block|{
name|t
operator|->
name|caps
operator||=
name|HPET_TCNF_TYPE
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_CAP_CNF
argument_list|(
name|t
operator|->
name|num
argument_list|)
argument_list|,
name|t
operator|->
name|caps
operator||
name|HPET_TCNF_VAL_SET
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_COMPARATOR
argument_list|(
name|t
operator|->
name|num
argument_list|)
argument_list|,
name|t
operator|->
name|last
operator|+
name|t
operator|->
name|div
argument_list|)
expr_stmt|;
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_COMPARATOR
argument_list|(
name|t
operator|->
name|num
argument_list|)
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_COMPARATOR
argument_list|(
name|t
operator|->
name|num
argument_list|)
argument_list|,
name|t
operator|->
name|div
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_COMPARATOR
argument_list|(
name|t
operator|->
name|num
argument_list|)
argument_list|,
name|t
operator|->
name|last
operator|+
name|sc
operator|->
name|freq
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_ISR
argument_list|,
literal|1
operator|<<
name|t
operator|->
name|num
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_CAP_CNF
argument_list|(
name|t
operator|->
name|num
argument_list|)
argument_list|,
name|t
operator|->
name|caps
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print some basic latency/rate information to assist in debugging. */
end_comment

begin_function
specifier|static
name|void
name|hpet_test
parameter_list|(
name|struct
name|hpet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|u1
decl_stmt|,
name|u2
decl_stmt|;
name|struct
name|bintime
name|b0
decl_stmt|,
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|binuptime
argument_list|(
operator|&
name|b0
argument_list|)
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|b0
argument_list|)
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|b1
argument_list|)
expr_stmt|;
name|u1
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_MAIN_COUNTER
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
name|u2
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_MAIN_COUNTER
argument_list|)
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|b2
argument_list|)
expr_stmt|;
name|u2
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_MAIN_COUNTER
argument_list|)
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|b2
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|b1
argument_list|,
operator|&
name|b0
argument_list|)
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|b2
argument_list|,
operator|&
name|b1
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|b2
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%ld.%09ld: %u ... %u = %u\n"
argument_list|,
operator|(
name|long
operator|)
name|ts
operator|.
name|tv_sec
argument_list|,
name|ts
operator|.
name|tv_nsec
argument_list|,
name|u1
argument_list|,
name|u2
argument_list|,
name|u2
operator|-
name|u1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"time per call: %ld ns\n"
argument_list|,
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_APIC
end_ifdef

begin_function
specifier|static
name|int
name|hpet_remap_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|struct
name|hpet_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hpet_timer
modifier|*
name|t
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint32_t
name|data
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_timers
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
operator|&
name|sc
operator|->
name|t
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|irq
operator|!=
name|irq
condition|)
continue|continue;
name|error
operator|=
name|PCIB_MAP_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|dev
argument_list|,
name|irq
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|hpet_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Stop timer to avoid interrupt loss. */
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_FSB_ADDR
argument_list|(
name|i
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|HPET_TIMER_FSB_VAL
argument_list|(
name|i
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hpet_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|device_method_t
name|hpet_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|hpet_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hpet_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hpet_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hpet_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|hpet_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|hpet_resume
argument_list|)
block|,
ifdef|#
directive|ifdef
name|DEV_APIC
name|DEVMETHOD
argument_list|(
name|bus_remap_intr
argument_list|,
name|hpet_remap_intr
argument_list|)
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|hpet_driver
init|=
block|{
literal|"hpet"
block|,
name|hpet_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|hpet_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|hpet
argument_list|,
name|acpi
argument_list|,
name|hpet_driver
argument_list|,
name|hpet_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|hpet
argument_list|,
name|acpi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

