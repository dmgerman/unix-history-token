begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Michael Smith  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_comment
comment|/* XXX trim includes */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|"acpi.h"
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpiio.h>
end_include

begin_comment
comment|/*  * ACPI power resource management.  *  * Power resource behaviour is slightly complicated by the fact that  * a single power resource may provide power for more than one device.  * Thus, we must track the device(s) being powered by a given power  * resource, and only deactivate it when there are no powered devices.  *  * Note that this only manages resources for known devices.  There is an  * ugly case where we may turn of power to a device which is in use because  * we don't know that it depends on a given resource.  We should perhaps  * try to be smarter about this, but a more complete solution would involve  * scanning all of the ACPI namespace to find devices we're not currently  * aware of, and this raises questions about whether they should be left   * on, turned off, etc.  *  * XXX locking  */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ACPIPWR
argument_list|,
literal|"acpipwr"
argument_list|,
literal|"ACPI power resources"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Hooks for the ACPI CA debugging infrastructure  */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_POWER
end_define

begin_macro
name|MODULE_NAME
argument_list|(
literal|"POWERRES"
argument_list|)
end_macro

begin_comment
comment|/* return values from _STA on a power resource */
end_comment

begin_define
define|#
directive|define
name|ACPI_PWR_OFF
value|0
end_define

begin_define
define|#
directive|define
name|ACPI_PWR_ON
value|1
end_define

begin_comment
comment|/*  * A relationship between a power resource and a consumer.  */
end_comment

begin_struct
struct|struct
name|acpi_powerreference
block|{
name|struct
name|acpi_powerconsumer
modifier|*
name|ar_consumer
decl_stmt|;
name|struct
name|acpi_powerresource
modifier|*
name|ar_resource
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|acpi_powerreference
argument_list|)
name|ar_rlink
expr_stmt|;
comment|/* link on resource list */
name|TAILQ_ENTRY
argument_list|(
argument|acpi_powerreference
argument_list|)
name|ar_clink
expr_stmt|;
comment|/* link on consumer */
block|}
struct|;
end_struct

begin_comment
comment|/*  * A power-managed device.  */
end_comment

begin_struct
struct|struct
name|acpi_powerconsumer
block|{
name|ACPI_HANDLE
name|ac_consumer
decl_stmt|;
comment|/* device which is powered */
name|int
name|ac_state
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|acpi_powerconsumer
argument_list|)
name|ac_link
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|acpi_powerreference
argument_list|)
name|ac_references
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * A power resource.  */
end_comment

begin_struct
struct|struct
name|acpi_powerresource
block|{
name|TAILQ_ENTRY
argument_list|(
argument|acpi_powerresource
argument_list|)
name|ap_link
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|acpi_powerreference
argument_list|)
name|ap_references
expr_stmt|;
name|ACPI_HANDLE
name|ap_resource
decl_stmt|;
comment|/* the resource's handle */
name|ACPI_INTEGER
name|ap_systemlevel
decl_stmt|;
name|ACPI_INTEGER
name|ap_order
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|acpi_powerresource_list
argument_list|,
argument|acpi_powerresource
argument_list|)
name|acpi_powerresources
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|acpi_powerconsumer_list
argument_list|,
argument|acpi_powerconsumer
argument_list|)
name|acpi_powerconsumers
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_pwr_register_consumer
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_pwr_deregister_consumer
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_pwr_register_resource
parameter_list|(
name|ACPI_HANDLE
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_pwr_deregister_resource
parameter_list|(
name|ACPI_HANDLE
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_pwr_reference_resource
parameter_list|(
name|ACPI_OBJECT
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_pwr_switch_power
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|acpi_powerresource
modifier|*
name|acpi_pwr_find_resource
parameter_list|(
name|ACPI_HANDLE
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|acpi_powerconsumer
modifier|*
name|acpi_pwr_find_consumer
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Initialise our lists.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_pwr_init
parameter_list|(
name|void
modifier|*
name|junk
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|acpi_powerresources
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|acpi_powerconsumers
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|acpi_powerresource
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|acpi_pwr_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Register a power resource.  *  * It's OK to call this if we already know about the resource.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_pwr_register_resource
parameter_list|(
name|ACPI_HANDLE
name|res
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|obj
decl_stmt|;
name|struct
name|acpi_powerresource
modifier|*
name|rp
decl_stmt|,
modifier|*
name|srp
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
comment|/* look to see if we know about this resource */
if|if
condition|(
name|acpi_pwr_find_resource
argument_list|(
name|res
argument_list|)
operator|!=
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
comment|/* already know about it */
comment|/* allocate a new resource */
if|if
condition|(
operator|(
name|rp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
argument_list|,
name|M_ACPIPWR
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|AE_NO_MEMORY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|rp
operator|->
name|ap_references
argument_list|)
expr_stmt|;
name|rp
operator|->
name|ap_resource
operator|=
name|res
expr_stmt|;
comment|/* get the Power Resource object */
name|bzero
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|acpi_EvaluateIntoBuffer
argument_list|(
name|res
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"no power resource object\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|obj
operator|=
name|buf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|Type
operator|!=
name|ACPI_TYPE_POWER
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"questionable power resource object %s\n"
operator|,
name|acpi_name
argument_list|(
name|res
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|AE_TYPE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rp
operator|->
name|ap_systemlevel
operator|=
name|obj
operator|->
name|PowerResource
operator|.
name|SystemLevel
expr_stmt|;
name|rp
operator|->
name|ap_order
operator|=
name|obj
operator|->
name|PowerResource
operator|.
name|ResourceOrder
expr_stmt|;
comment|/* sort the resource into the list */
name|status
operator|=
name|AE_OK
expr_stmt|;
name|srp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|acpi_powerresources
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|srp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|rp
operator|->
name|ap_order
operator|<
name|srp
operator|->
name|ap_order
operator|)
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|acpi_powerresources
argument_list|,
name|rp
argument_list|,
name|ap_link
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|srp
argument_list|,
argument|&acpi_powerresources
argument_list|,
argument|ap_link
argument_list|)
if|if
condition|(
name|rp
operator|->
name|ap_order
operator|<
name|srp
operator|->
name|ap_order
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|srp
argument_list|,
name|rp
argument_list|,
name|ap_link
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|acpi_powerresources
argument_list|,
name|rp
argument_list|,
name|ap_link
argument_list|)
expr_stmt|;
name|done
label|:
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"registered power resource %s\n"
operator|,
name|acpi_name
argument_list|(
name|res
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
name|AcpiOsFree
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|AE_OK
operator|)
operator|&&
operator|(
name|rp
operator|!=
name|NULL
operator|)
condition|)
name|free
argument_list|(
name|rp
argument_list|,
name|M_ACPIPWR
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deregister a power resource.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_pwr_deregister_resource
parameter_list|(
name|ACPI_HANDLE
name|res
parameter_list|)
block|{
name|struct
name|acpi_powerresource
modifier|*
name|rp
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
comment|/* find the resource */
if|if
condition|(
operator|(
name|rp
operator|=
name|acpi_pwr_find_resource
argument_list|(
name|res
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
comment|/* check that there are no consumers referencing this resource */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|rp
operator|->
name|ap_references
argument_list|)
operator|!=
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
comment|/* pull it off the list and free it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|acpi_powerresources
argument_list|,
name|rp
argument_list|,
name|ap_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rp
argument_list|,
name|M_ACPIPWR
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"deregistered power resource %s\n"
operator|,
name|acpi_name
argument_list|(
name|res
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Register a power consumer.    *  * It's OK to call this if we already know about the consumer.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_pwr_register_consumer
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|)
block|{
name|struct
name|acpi_powerconsumer
modifier|*
name|pc
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
comment|/* check to see whether we know about this consumer already */
if|if
condition|(
operator|(
name|pc
operator|=
name|acpi_pwr_find_consumer
argument_list|(
name|consumer
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
comment|/* allocate a new power consumer */
if|if
condition|(
operator|(
name|pc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pc
argument_list|)
argument_list|,
name|M_ACPIPWR
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_NO_MEMORY
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|acpi_powerconsumers
argument_list|,
name|pc
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pc
operator|->
name|ac_references
argument_list|)
expr_stmt|;
name|pc
operator|->
name|ac_consumer
operator|=
name|consumer
expr_stmt|;
name|pc
operator|->
name|ac_state
operator|=
name|ACPI_STATE_UNKNOWN
expr_stmt|;
comment|/* XXX we should try to find its current state */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"registered power consumer %s\n"
operator|,
name|acpi_name
argument_list|(
name|consumer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deregister a power consumer.  *  * This should only be done once the consumer has been powered off.  * (XXX is this correct?  Check once implemented)  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_pwr_deregister_consumer
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|)
block|{
name|struct
name|acpi_powerconsumer
modifier|*
name|pc
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
comment|/* find the consumer */
if|if
condition|(
operator|(
name|pc
operator|=
name|acpi_pwr_find_consumer
argument_list|(
name|consumer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
comment|/* make sure the consumer's not referencing anything right now */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|pc
operator|->
name|ac_references
argument_list|)
operator|!=
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
comment|/* pull the consumer off the list and free it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|acpi_powerconsumers
argument_list|,
name|pc
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"deregistered power consumer %s\n"
operator|,
name|acpi_name
argument_list|(
name|consumer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a power consumer to a particular power state.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_pwr_switch_consumer
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|acpi_powerconsumer
modifier|*
name|pc
decl_stmt|;
name|struct
name|acpi_powerreference
modifier|*
name|pr
decl_stmt|;
name|ACPI_HANDLE
name|method_handle
decl_stmt|,
name|reslist_handle
decl_stmt|,
name|pr0_handle
decl_stmt|;
name|ACPI_BUFFER
name|reslist_buffer
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|reslist_object
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|char
modifier|*
name|method_name
decl_stmt|,
modifier|*
name|reslist_name
decl_stmt|;
name|int
name|res_changed
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
comment|/* find the consumer */
if|if
condition|(
operator|(
name|pc
operator|=
name|acpi_pwr_find_consumer
argument_list|(
name|consumer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|acpi_pwr_register_consumer
argument_list|(
name|consumer
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pc
operator|=
name|acpi_pwr_find_consumer
argument_list|(
name|consumer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_ERROR
argument_list|)
expr_stmt|;
comment|/* something very wrong */
block|}
block|}
comment|/* check for valid transitions */
if|if
condition|(
operator|(
name|pc
operator|->
name|ac_state
operator|==
name|ACPI_STATE_D3
operator|)
operator|&&
operator|(
name|state
operator|!=
name|ACPI_STATE_D0
operator|)
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
comment|/* can only go to D0 from D3 */
comment|/* find transition mechanism(s) */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ACPI_STATE_D0
case|:
name|method_name
operator|=
literal|"_PS0"
expr_stmt|;
name|reslist_name
operator|=
literal|"_PR0"
expr_stmt|;
break|break;
case|case
name|ACPI_STATE_D1
case|:
name|method_name
operator|=
literal|"_PS1"
expr_stmt|;
name|reslist_name
operator|=
literal|"_PR1"
expr_stmt|;
break|break;
case|case
name|ACPI_STATE_D2
case|:
name|method_name
operator|=
literal|"_PS2"
expr_stmt|;
name|reslist_name
operator|=
literal|"_PR2"
expr_stmt|;
break|break;
case|case
name|ACPI_STATE_D3
case|:
name|method_name
operator|=
literal|"_PS3"
expr_stmt|;
name|reslist_name
operator|=
literal|"_PR3"
expr_stmt|;
break|break;
default|default:
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"setup to switch %s D%d -> D%d\n"
operator|,
name|acpi_name
argument_list|(
name|consumer
argument_list|)
operator|,
name|pc
operator|->
name|ac_state
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Verify that this state is supported, ie. one of method or      * reslist must be present.  We need to do this before we go       * dereferencing resources (since we might be trying to go to      * a state we don't support).      *      * Note that if any states are supported, the device has to      * support D0 and D3.  It's never an error to try to go to      * D0.      */
name|reslist_object
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|AcpiGetHandle
argument_list|(
name|consumer
argument_list|,
name|method_name
argument_list|,
operator|&
name|method_handle
argument_list|)
operator|!=
name|AE_OK
condition|)
name|method_handle
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|AcpiGetHandle
argument_list|(
name|consumer
argument_list|,
name|reslist_name
argument_list|,
operator|&
name|reslist_handle
argument_list|)
operator|!=
name|AE_OK
condition|)
name|reslist_handle
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|reslist_handle
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|method_handle
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|ACPI_STATE_D0
condition|)
block|{
name|pc
operator|->
name|ac_state
operator|=
name|ACPI_STATE_D0
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|!=
name|ACPI_STATE_D3
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
comment|/* turn off the resources listed in _PR0 to go to D3. */
if|if
condition|(
name|AcpiGetHandle
argument_list|(
name|consumer
argument_list|,
literal|"_PR0"
argument_list|,
operator|&
name|pr0_handle
argument_list|)
operator|!=
name|AE_OK
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|bzero
argument_list|(
operator|&
name|reslist_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|reslist_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|acpi_EvaluateIntoBuffer
argument_list|(
name|pr0_handle
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|reslist_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|AE_OK
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|reslist_object
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|reslist_buffer
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
operator|(
name|reslist_object
operator|->
name|Type
operator|!=
name|ACPI_TYPE_PACKAGE
operator|)
operator|||
operator|(
name|reslist_object
operator|->
name|Package
operator|.
name|Count
operator|==
literal|0
operator|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|AcpiOsFree
argument_list|(
name|reslist_object
argument_list|)
expr_stmt|;
block|}
comment|/*      * Check that we can actually fetch the list of power resources      */
if|if
condition|(
name|reslist_handle
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|reslist_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|reslist_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|acpi_EvaluateIntoBuffer
argument_list|(
name|reslist_handle
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|reslist_buffer
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"can't evaluate resource list %s\n"
operator|,
name|acpi_name
argument_list|(
name|reslist_handle
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
name|reslist_object
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|reslist_buffer
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|reslist_object
operator|->
name|Type
operator|!=
name|ACPI_TYPE_PACKAGE
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"resource list is not ACPI_TYPE_PACKAGE (%d)\n"
operator|,
name|reslist_object
operator|->
name|Type
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_TYPE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|reslist_object
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * Now we are ready to switch, so  kill off any current power resource references.      */
name|res_changed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|pr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pc
operator|->
name|ac_references
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|res_changed
operator|=
literal|1
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"removing reference to %s\n"
operator|,
name|acpi_name
argument_list|(
name|pr
operator|->
name|ar_resource
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pr
operator|->
name|ar_resource
operator|->
name|ap_references
argument_list|,
name|pr
argument_list|,
name|ar_rlink
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pc
operator|->
name|ac_references
argument_list|,
name|pr
argument_list|,
name|ar_clink
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pr
argument_list|,
name|M_ACPIPWR
argument_list|)
expr_stmt|;
block|}
comment|/*      * Add new power resource references, if we have any.  Traverse the      * package that we got from evaluating reslist_handle, and look up each      * of the resources that are referenced.      */
if|if
condition|(
name|reslist_object
operator|!=
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"referencing %d new resources\n"
operator|,
name|reslist_object
operator|->
name|Package
operator|.
name|Count
operator|)
argument_list|)
expr_stmt|;
name|acpi_ForeachPackageObject
argument_list|(
name|reslist_object
argument_list|,
name|acpi_pwr_reference_resource
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|res_changed
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * If we changed anything in the resource list, we need to run a switch      * pass now.      */
if|if
condition|(
operator|(
name|status
operator|=
name|acpi_pwr_switch_power
argument_list|()
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"failed to correctly switch resources to move %s to D%d\n"
operator|,
name|acpi_name
argument_list|(
name|consumer
argument_list|)
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* XXX is this appropriate?  Should we return to previous state? */
block|}
comment|/* invoke power state switch method (if present) */
if|if
condition|(
name|method_handle
operator|!=
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"invoking state transition method %s\n"
operator|,
name|acpi_name
argument_list|(
name|method_handle
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|method_handle
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
name|pc
operator|->
name|ac_state
operator|=
name|ACPI_STATE_UNKNOWN
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* XXX is this appropriate?  Should we return to previous state? */
block|}
comment|/* transition was successful */
name|pc
operator|->
name|ac_state
operator|=
name|state
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
name|bad
label|:
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"attempt to set unsupported state D%d\n"
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reslist_object
condition|)
name|AcpiOsFree
argument_list|(
name|reslist_object
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to create a reference between a power consumer and a power resource  * identified in the object.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_pwr_reference_resource
parameter_list|(
name|ACPI_OBJECT
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|acpi_powerconsumer
modifier|*
name|pc
init|=
operator|(
expr|struct
name|acpi_powerconsumer
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|acpi_powerreference
modifier|*
name|pr
decl_stmt|;
name|struct
name|acpi_powerresource
modifier|*
name|rp
decl_stmt|;
name|ACPI_HANDLE
name|res
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
comment|/* check the object type */
if|if
condition|(
name|obj
operator|->
name|Type
operator|!=
name|ACPI_TYPE_STRING
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"don't know how to create a power reference to object type %d\n"
operator|,
name|obj
operator|->
name|Type
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"building reference from %s to %s\n"
operator|,
name|acpi_name
argument_list|(
name|pc
operator|->
name|ac_consumer
argument_list|)
operator|,
name|obj
operator|->
name|String
operator|.
name|Pointer
operator|)
argument_list|)
expr_stmt|;
comment|/* get the handle of the resource */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiGetHandle
argument_list|(
name|NULL
argument_list|,
name|obj
operator|->
name|String
operator|.
name|Pointer
argument_list|,
operator|&
name|res
argument_list|)
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"couldn't find power resource %s\n"
operator|,
name|obj
operator|->
name|String
operator|.
name|Pointer
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
comment|/* create/look up the resource */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|acpi_pwr_register_resource
argument_list|(
name|res
argument_list|)
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"couldn't register power resource %s - %s\n"
operator|,
name|obj
operator|->
name|String
operator|.
name|Pointer
operator|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rp
operator|=
name|acpi_pwr_find_resource
argument_list|(
name|res
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"power resource list corrupted\n"
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"found power resource %s\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* create a reference between the consumer and resource */
if|if
condition|(
operator|(
name|pr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pr
argument_list|)
argument_list|,
name|M_ACPIPWR
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"couldn't allocate memory for a power consumer reference\n"
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
name|pr
operator|->
name|ar_consumer
operator|=
name|pc
expr_stmt|;
name|pr
operator|->
name|ar_resource
operator|=
name|rp
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pc
operator|->
name|ac_references
argument_list|,
name|pr
argument_list|,
name|ar_clink
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|rp
operator|->
name|ap_references
argument_list|,
name|pr
argument_list|,
name|ar_rlink
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Switch power resources to conform to the desired state.  *  * Consumers may have modified the power resource list in an arbitrary  * fashion; we sweep it in sequence order.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_pwr_switch_power
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|acpi_powerresource
modifier|*
name|rp
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|cur
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
comment|/*      * Sweep the list forwards turning things on.      */
name|TAILQ_FOREACH
argument_list|(
argument|rp
argument_list|,
argument|&acpi_powerresources
argument_list|,
argument|ap_link
argument_list|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|rp
operator|->
name|ap_references
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"%s has no references, not turning on\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* we could cache this if we trusted it not to change under us */
if|if
condition|(
operator|(
name|status
operator|=
name|acpi_EvaluateInteger
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|,
literal|"_STA"
argument_list|,
operator|&
name|cur
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"can't get status of %s - %d\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
continue|continue;
comment|/* XXX is this correct?  Always switch if in doubt? */
block|}
comment|/* 	 * Switch if required.  Note that we ignore the result of the switch 	 * effort; we don't know what to do if it fails, so checking wouldn't 	 * help much. 	 */
if|if
condition|(
name|cur
operator|!=
name|ACPI_PWR_ON
condition|)
block|{
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|,
literal|"_ON"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"failed to switch %s on - %s\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"switched %s on\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"%s is already on\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Sweep the list backwards turning things off.      */
name|TAILQ_FOREACH_REVERSE
argument_list|(
argument|rp
argument_list|,
argument|&acpi_powerresources
argument_list|,
argument|acpi_powerresource_list
argument_list|,
argument|ap_link
argument_list|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|rp
operator|->
name|ap_references
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"%s has references, not turning off\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* we could cache this if we trusted it not to change under us */
if|if
condition|(
operator|(
name|status
operator|=
name|acpi_EvaluateInteger
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|,
literal|"_STA"
argument_list|,
operator|&
name|cur
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"can't get status of %s - %d\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
continue|continue;
comment|/* XXX is this correct?  Always switch if in doubt? */
block|}
comment|/* 	 * Switch if required.  Note that we ignore the result of the switch 	 * effort; we don't know what to do if it fails, so checking wouldn't 	 * help much. 	 */
if|if
condition|(
name|cur
operator|!=
name|ACPI_PWR_OFF
condition|)
block|{
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|,
literal|"_OFF"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"failed to switch %s off - %s\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"switched %s off\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"%s is already off\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find a power resource's control structure.  */
end_comment

begin_function
specifier|static
name|struct
name|acpi_powerresource
modifier|*
name|acpi_pwr_find_resource
parameter_list|(
name|ACPI_HANDLE
name|res
parameter_list|)
block|{
name|struct
name|acpi_powerresource
modifier|*
name|rp
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rp
argument_list|,
argument|&acpi_powerresources
argument_list|,
argument|ap_link
argument_list|)
if|if
condition|(
name|rp
operator|->
name|ap_resource
operator|==
name|res
condition|)
break|break;
name|return_PTR
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find a power consumer's control structure.  */
end_comment

begin_function
specifier|static
name|struct
name|acpi_powerconsumer
modifier|*
name|acpi_pwr_find_consumer
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|)
block|{
name|struct
name|acpi_powerconsumer
modifier|*
name|pc
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pc
argument_list|,
argument|&acpi_powerconsumers
argument_list|,
argument|ac_link
argument_list|)
if|if
condition|(
name|pc
operator|->
name|ac_consumer
operator|==
name|consumer
condition|)
break|break;
name|return_PTR
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

