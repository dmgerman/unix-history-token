begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Michael Smith  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_comment
comment|/*  * ACPI power resource management.  *  * Power resource behaviour is slightly complicated by the fact that  * a single power resource may provide power for more than one device.  * Thus, we must track the device(s) being powered by a given power  * resource, and only deactivate it when there are no powered devices.  *  * Note that this only manages resources for known devices.  There is an  * ugly case where we may turn of power to a device which is in use because  * we don't know that it depends on a given resource.  We should perhaps  * try to be smarter about this, but a more complete solution would involve  * scanning all of the ACPI namespace to find devices we're not currently  * aware of, and this raises questions about whether they should be left   * on, turned off, etc.  */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ACPIPWR
argument_list|,
literal|"acpipwr"
argument_list|,
literal|"ACPI power resources"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Hooks for the ACPI CA debugging infrastructure */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_POWERRES
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"POWERRES"
argument_list|)
end_macro

begin_comment
comment|/* Return values from _STA on a power resource */
end_comment

begin_define
define|#
directive|define
name|ACPI_PWR_OFF
value|0
end_define

begin_define
define|#
directive|define
name|ACPI_PWR_ON
value|1
end_define

begin_define
define|#
directive|define
name|ACPI_PWR_UNK
value|(-1)
end_define

begin_comment
comment|/* A relationship between a power resource and a consumer. */
end_comment

begin_struct
struct|struct
name|acpi_powerreference
block|{
name|struct
name|acpi_powerconsumer
modifier|*
name|ar_consumer
decl_stmt|;
name|struct
name|acpi_powerresource
modifier|*
name|ar_resource
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|acpi_powerreference
argument_list|)
name|ar_rlink
expr_stmt|;
comment|/* link on resource list */
name|TAILQ_ENTRY
argument_list|(
argument|acpi_powerreference
argument_list|)
name|ar_clink
expr_stmt|;
comment|/* link on consumer */
block|}
struct|;
end_struct

begin_comment
comment|/* A power-managed device. */
end_comment

begin_struct
struct|struct
name|acpi_powerconsumer
block|{
comment|/* Device which is powered */
name|ACPI_HANDLE
name|ac_consumer
decl_stmt|;
name|int
name|ac_state
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|acpi_powerconsumer
argument_list|)
name|ac_link
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|acpi_powerreference
argument_list|)
name|ac_references
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A power resource. */
end_comment

begin_struct
struct|struct
name|acpi_powerresource
block|{
name|TAILQ_ENTRY
argument_list|(
argument|acpi_powerresource
argument_list|)
name|ap_link
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|acpi_powerreference
argument_list|)
name|ap_references
expr_stmt|;
name|ACPI_HANDLE
name|ap_resource
decl_stmt|;
name|UINT64
name|ap_systemlevel
decl_stmt|;
name|UINT64
name|ap_order
decl_stmt|;
name|int
name|ap_state
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|acpi_powerresource_list
argument_list|,
argument|acpi_powerresource
argument_list|)
name|acpi_powerresources
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|acpi_powerconsumer_list
argument_list|,
argument|acpi_powerconsumer
argument_list|)
name|acpi_powerconsumers
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ACPI_SERIAL_DECL
argument_list|(
name|powerres
argument_list|,
literal|"ACPI power resources"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_pwr_register_consumer
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_pwr_deregister_consumer
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_pwr_register_resource
parameter_list|(
name|ACPI_HANDLE
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_pwr_deregister_resource
parameter_list|(
name|ACPI_HANDLE
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_function_decl
specifier|static
name|void
name|acpi_pwr_reference_resource
parameter_list|(
name|ACPI_OBJECT
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_pwr_dereference_resource
parameter_list|(
name|struct
name|acpi_powerconsumer
modifier|*
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_pwr_switch_power
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|acpi_powerresource
modifier|*
name|acpi_pwr_find_resource
parameter_list|(
name|ACPI_HANDLE
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|acpi_powerconsumer
modifier|*
name|acpi_pwr_find_consumer
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Initialise our lists. */
end_comment

begin_function
specifier|static
name|void
name|acpi_pwr_init
parameter_list|(
name|void
modifier|*
name|junk
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|acpi_powerresources
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|acpi_powerconsumers
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|acpi_powerresource
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|acpi_pwr_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Register a power resource.  *  * It's OK to call this if we already know about the resource.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_pwr_register_resource
parameter_list|(
name|ACPI_HANDLE
name|res
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|obj
decl_stmt|;
name|struct
name|acpi_powerresource
modifier|*
name|rp
decl_stmt|,
modifier|*
name|srp
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|powerres
argument_list|)
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
comment|/* Look to see if we know about this resource */
if|if
condition|(
name|acpi_pwr_find_resource
argument_list|(
name|res
argument_list|)
operator|!=
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
comment|/* already know about it */
comment|/* Allocate a new resource */
if|if
condition|(
operator|(
name|rp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
argument_list|,
name|M_ACPIPWR
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|AE_NO_MEMORY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|rp
operator|->
name|ap_references
argument_list|)
expr_stmt|;
name|rp
operator|->
name|ap_resource
operator|=
name|res
expr_stmt|;
comment|/* Get the Power Resource object */
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|res
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"no power resource object\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|obj
operator|=
name|buf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|Type
operator|!=
name|ACPI_TYPE_POWER
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"questionable power resource object %s\n"
operator|,
name|acpi_name
argument_list|(
name|res
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|AE_TYPE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rp
operator|->
name|ap_systemlevel
operator|=
name|obj
operator|->
name|PowerResource
operator|.
name|SystemLevel
expr_stmt|;
name|rp
operator|->
name|ap_order
operator|=
name|obj
operator|->
name|PowerResource
operator|.
name|ResourceOrder
expr_stmt|;
name|rp
operator|->
name|ap_state
operator|=
name|ACPI_PWR_UNK
expr_stmt|;
comment|/* Sort the resource into the list */
name|status
operator|=
name|AE_OK
expr_stmt|;
name|srp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|acpi_powerresources
argument_list|)
expr_stmt|;
if|if
condition|(
name|srp
operator|==
name|NULL
operator|||
name|rp
operator|->
name|ap_order
operator|<
name|srp
operator|->
name|ap_order
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|acpi_powerresources
argument_list|,
name|rp
argument_list|,
name|ap_link
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|srp
argument_list|,
argument|&acpi_powerresources
argument_list|,
argument|ap_link
argument_list|)
block|{
if|if
condition|(
name|rp
operator|->
name|ap_order
operator|<
name|srp
operator|->
name|ap_order
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|srp
argument_list|,
name|rp
argument_list|,
name|ap_link
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|acpi_powerresources
argument_list|,
name|rp
argument_list|,
name|ap_link
argument_list|)
expr_stmt|;
name|done
label|:
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"registered power resource %s\n"
operator|,
name|acpi_name
argument_list|(
name|res
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|buf
operator|.
name|Pointer
operator|!=
name|NULL
condition|)
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
operator|&&
name|rp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rp
argument_list|,
name|M_ACPIPWR
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/*  * Deregister a power resource.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_pwr_deregister_resource
parameter_list|(
name|ACPI_HANDLE
name|res
parameter_list|)
block|{
name|struct
name|acpi_powerresource
modifier|*
name|rp
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|powerres
argument_list|)
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
comment|/* Find the resource */
if|if
condition|(
operator|(
name|rp
operator|=
name|acpi_pwr_find_resource
argument_list|(
name|res
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
comment|/* Check that there are no consumers referencing this resource */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|rp
operator|->
name|ap_references
argument_list|)
operator|!=
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
comment|/* Pull it off the list and free it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|acpi_powerresources
argument_list|,
name|rp
argument_list|,
name|ap_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rp
argument_list|,
name|M_ACPIPWR
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"deregistered power resource %s\n"
operator|,
name|acpi_name
argument_list|(
name|res
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_comment
comment|/*  * Register a power consumer.    *  * It's OK to call this if we already know about the consumer.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_pwr_register_consumer
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|)
block|{
name|struct
name|acpi_powerconsumer
modifier|*
name|pc
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|powerres
argument_list|)
expr_stmt|;
comment|/* Check to see whether we know about this consumer already */
if|if
condition|(
name|acpi_pwr_find_consumer
argument_list|(
name|consumer
argument_list|)
operator|!=
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
comment|/* Allocate a new power consumer */
if|if
condition|(
operator|(
name|pc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pc
argument_list|)
argument_list|,
name|M_ACPIPWR
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_NO_MEMORY
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|acpi_powerconsumers
argument_list|,
name|pc
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pc
operator|->
name|ac_references
argument_list|)
expr_stmt|;
name|pc
operator|->
name|ac_consumer
operator|=
name|consumer
expr_stmt|;
comment|/* XXX we should try to find its current state */
name|pc
operator|->
name|ac_state
operator|=
name|ACPI_STATE_UNKNOWN
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"registered power consumer %s\n"
operator|,
name|acpi_name
argument_list|(
name|consumer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/*  * Deregister a power consumer.  *  * This should only be done once the consumer has been powered off.  * (XXX is this correct?  Check once implemented)  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_pwr_deregister_consumer
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|)
block|{
name|struct
name|acpi_powerconsumer
modifier|*
name|pc
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|powerres
argument_list|)
expr_stmt|;
comment|/* Find the consumer */
if|if
condition|(
operator|(
name|pc
operator|=
name|acpi_pwr_find_consumer
argument_list|(
name|consumer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
comment|/* Make sure the consumer's not referencing anything right now */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|pc
operator|->
name|ac_references
argument_list|)
operator|!=
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
comment|/* Pull the consumer off the list and free it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|acpi_powerconsumers
argument_list|,
name|pc
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pc
argument_list|,
name|M_ACPIPWR
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"deregistered power consumer %s\n"
operator|,
name|acpi_name
argument_list|(
name|consumer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_comment
comment|/*  * Set a power consumer to a particular power state.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_pwr_switch_consumer
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|acpi_powerconsumer
modifier|*
name|pc
decl_stmt|;
name|ACPI_HANDLE
name|method_handle
decl_stmt|,
name|reslist_handle
decl_stmt|,
name|pr0_handle
decl_stmt|;
name|ACPI_BUFFER
name|reslist_buffer
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|reslist_object
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|char
modifier|*
name|method_name
decl_stmt|,
modifier|*
name|reslist_name
decl_stmt|;
name|int
name|res_changed
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* It's never ok to switch a non-existent consumer. */
if|if
condition|(
name|consumer
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_NOT_FOUND
argument_list|)
expr_stmt|;
name|reslist_buffer
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|reslist_object
operator|=
name|NULL
expr_stmt|;
name|ACPI_SERIAL_BEGIN
argument_list|(
name|powerres
argument_list|)
expr_stmt|;
comment|/* Find the consumer */
if|if
condition|(
operator|(
name|pc
operator|=
name|acpi_pwr_find_consumer
argument_list|(
name|consumer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|acpi_pwr_register_consumer
argument_list|(
name|consumer
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|pc
operator|=
name|acpi_pwr_find_consumer
argument_list|(
name|consumer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"acpi added power consumer but can't find it"
argument_list|)
expr_stmt|;
block|}
comment|/* Check for valid transitions.  We can only go to D0 from D3. */
name|status
operator|=
name|AE_BAD_PARAMETER
expr_stmt|;
if|if
condition|(
name|pc
operator|->
name|ac_state
operator|==
name|ACPI_STATE_D3
operator|&&
name|state
operator|!=
name|ACPI_STATE_D0
condition|)
goto|goto
name|out
goto|;
comment|/* Find transition mechanism(s) */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ACPI_STATE_D0
case|:
name|method_name
operator|=
literal|"_PS0"
expr_stmt|;
name|reslist_name
operator|=
literal|"_PR0"
expr_stmt|;
break|break;
case|case
name|ACPI_STATE_D1
case|:
name|method_name
operator|=
literal|"_PS1"
expr_stmt|;
name|reslist_name
operator|=
literal|"_PR1"
expr_stmt|;
break|break;
case|case
name|ACPI_STATE_D2
case|:
name|method_name
operator|=
literal|"_PS2"
expr_stmt|;
name|reslist_name
operator|=
literal|"_PR2"
expr_stmt|;
break|break;
case|case
name|ACPI_STATE_D3
case|:
name|method_name
operator|=
literal|"_PS3"
expr_stmt|;
name|reslist_name
operator|=
literal|"_PR3"
expr_stmt|;
break|break;
default|default:
goto|goto
name|out
goto|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"setup to switch %s D%d -> D%d\n"
operator|,
name|acpi_name
argument_list|(
name|consumer
argument_list|)
operator|,
name|pc
operator|->
name|ac_state
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Verify that this state is supported, ie. one of method or      * reslist must be present.  We need to do this before we go       * dereferencing resources (since we might be trying to go to      * a state we don't support).      *      * Note that if any states are supported, the device has to      * support D0 and D3.  It's never an error to try to go to      * D0.      */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiGetHandle
argument_list|(
name|consumer
argument_list|,
name|method_name
argument_list|,
operator|&
name|method_handle
argument_list|)
argument_list|)
condition|)
name|method_handle
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiGetHandle
argument_list|(
name|consumer
argument_list|,
name|reslist_name
argument_list|,
operator|&
name|reslist_handle
argument_list|)
argument_list|)
condition|)
name|reslist_handle
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|reslist_handle
operator|==
name|NULL
operator|&&
name|method_handle
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|ACPI_STATE_D0
condition|)
block|{
name|pc
operator|->
name|ac_state
operator|=
name|ACPI_STATE_D0
expr_stmt|;
name|status
operator|=
name|AE_OK
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|state
operator|!=
name|ACPI_STATE_D3
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"attempt to set unsupported state D%d\n"
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Turn off the resources listed in _PR0 to go to D3.  If there is 	 * no _PR0 method, this object doesn't support ACPI power states. 	 */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiGetHandle
argument_list|(
name|consumer
argument_list|,
literal|"_PR0"
argument_list|,
operator|&
name|pr0_handle
argument_list|)
argument_list|)
condition|)
block|{
name|status
operator|=
name|AE_NOT_FOUND
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"device missing _PR0 (desired state was D%d)\n"
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|reslist_buffer
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|pr0_handle
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|reslist_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"can't evaluate _PR0 for device %s, state D%d\n"
operator|,
name|acpi_name
argument_list|(
name|consumer
argument_list|)
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|reslist_object
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|reslist_buffer
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
operator|!
name|ACPI_PKG_VALID
argument_list|(
name|reslist_object
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"invalid package object for state D%d\n"
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|AE_TYPE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|AcpiOsFree
argument_list|(
name|reslist_buffer
operator|.
name|Pointer
argument_list|)
expr_stmt|;
name|reslist_buffer
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|reslist_object
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * Check that we can actually fetch the list of power resources      */
if|if
condition|(
name|reslist_handle
operator|!=
name|NULL
condition|)
block|{
name|reslist_buffer
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|reslist_handle
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|reslist_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"can't evaluate resource list %s\n"
operator|,
name|acpi_name
argument_list|(
name|reslist_handle
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|reslist_object
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|reslist_buffer
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|reslist_object
operator|->
name|Type
operator|!=
name|ACPI_TYPE_PACKAGE
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"resource list is not ACPI_TYPE_PACKAGE (%d)\n"
operator|,
name|reslist_object
operator|->
name|Type
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|AE_TYPE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/*      * Now we are ready to switch, so kill off any current power      * resource references.      */
name|res_changed
operator|=
name|acpi_pwr_dereference_resource
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/*      * Add new power resource references, if we have any.  Traverse the      * package that we got from evaluating reslist_handle, and look up each      * of the resources that are referenced.      */
if|if
condition|(
name|reslist_object
operator|!=
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"referencing %d new resources\n"
operator|,
name|reslist_object
operator|->
name|Package
operator|.
name|Count
operator|)
argument_list|)
expr_stmt|;
name|acpi_ForeachPackageObject
argument_list|(
name|reslist_object
argument_list|,
name|acpi_pwr_reference_resource
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|res_changed
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * If we changed anything in the resource list, we need to run a switch      * pass now.      */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|acpi_pwr_switch_power
argument_list|()
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"failed to switch resources from %s to D%d\n"
operator|,
name|acpi_name
argument_list|(
name|consumer
argument_list|)
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX is this appropriate?  Should we return to previous state? */
goto|goto
name|out
goto|;
block|}
comment|/* Invoke power state switch method (if present) */
if|if
condition|(
name|method_handle
operator|!=
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"invoking state transition method %s\n"
operator|,
name|acpi_name
argument_list|(
name|method_handle
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|method_handle
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"failed to set state - %s\n"
operator|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|pc
operator|->
name|ac_state
operator|=
name|ACPI_STATE_UNKNOWN
expr_stmt|;
comment|/* XXX Should we return to previous state? */
goto|goto
name|out
goto|;
block|}
block|}
comment|/* Transition was successful */
name|pc
operator|->
name|ac_state
operator|=
name|state
expr_stmt|;
name|status
operator|=
name|AE_OK
expr_stmt|;
name|out
label|:
name|ACPI_SERIAL_END
argument_list|(
name|powerres
argument_list|)
expr_stmt|;
if|if
condition|(
name|reslist_buffer
operator|.
name|Pointer
operator|!=
name|NULL
condition|)
name|AcpiOsFree
argument_list|(
name|reslist_buffer
operator|.
name|Pointer
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enable or disable a power resource for wake */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_pwr_wake_enable
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|struct
name|acpi_powerconsumer
modifier|*
name|pc
decl_stmt|;
name|struct
name|acpi_prw_data
name|prw
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|consumer
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
name|ACPI_SERIAL_BEGIN
argument_list|(
name|powerres
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pc
operator|=
name|acpi_pwr_find_consumer
argument_list|(
name|consumer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|acpi_pwr_register_consumer
argument_list|(
name|consumer
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|pc
operator|=
name|acpi_pwr_find_consumer
argument_list|(
name|consumer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"acpi wake added power consumer but can't find it"
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|AE_OK
expr_stmt|;
if|if
condition|(
name|acpi_parse_prw
argument_list|(
name|consumer
argument_list|,
operator|&
name|prw
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prw
operator|.
name|power_res_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|enable
condition|)
name|acpi_pwr_reference_resource
argument_list|(
operator|&
name|prw
operator|.
name|power_res
index|[
name|i
index|]
argument_list|,
name|pc
argument_list|)
expr_stmt|;
else|else
name|acpi_pwr_dereference_resource
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|prw
operator|.
name|power_res_count
operator|>
literal|0
condition|)
name|acpi_pwr_switch_power
argument_list|()
expr_stmt|;
name|out
label|:
name|ACPI_SERIAL_END
argument_list|(
name|powerres
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called to create a reference between a power consumer and a power resource  * identified in the object.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_pwr_reference_resource
parameter_list|(
name|ACPI_OBJECT
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|acpi_powerconsumer
modifier|*
name|pc
init|=
operator|(
expr|struct
name|acpi_powerconsumer
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|acpi_powerreference
modifier|*
name|pr
decl_stmt|;
name|struct
name|acpi_powerresource
modifier|*
name|rp
decl_stmt|;
name|ACPI_HANDLE
name|res
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|powerres
argument_list|)
expr_stmt|;
name|res
operator|=
name|acpi_GetReference
argument_list|(
name|NULL
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"can't create a power reference for object type %d\n"
operator|,
name|obj
operator|->
name|Type
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
comment|/* Create/look up the resource */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|acpi_pwr_register_resource
argument_list|(
name|res
argument_list|)
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"couldn't register power resource %s - %s\n"
operator|,
name|obj
operator|->
name|String
operator|.
name|Pointer
operator|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rp
operator|=
name|acpi_pwr_find_resource
argument_list|(
name|res
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"power resource list corrupted\n"
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"found power resource %s\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Create a reference between the consumer and resource */
if|if
condition|(
operator|(
name|pr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pr
argument_list|)
argument_list|,
name|M_ACPIPWR
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"allocation failed for a power consumer reference\n"
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
name|pr
operator|->
name|ar_consumer
operator|=
name|pc
expr_stmt|;
name|pr
operator|->
name|ar_resource
operator|=
name|rp
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pc
operator|->
name|ac_references
argument_list|,
name|pr
argument_list|,
name|ar_clink
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|rp
operator|->
name|ap_references
argument_list|,
name|pr
argument_list|,
name|ar_rlink
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_pwr_dereference_resource
parameter_list|(
name|struct
name|acpi_powerconsumer
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|acpi_powerreference
modifier|*
name|pr
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|powerres
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|pr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pc
operator|->
name|ac_references
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"removing reference to %s\n"
operator|,
name|acpi_name
argument_list|(
name|pr
operator|->
name|ar_resource
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pr
operator|->
name|ar_resource
operator|->
name|ap_references
argument_list|,
name|pr
argument_list|,
name|ar_rlink
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pc
operator|->
name|ac_references
argument_list|,
name|pr
argument_list|,
name|ar_clink
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pr
argument_list|,
name|M_ACPIPWR
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|changed
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Switch power resources to conform to the desired state.  *  * Consumers may have modified the power resource list in an arbitrary  * fashion; we sweep it in sequence order.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_pwr_switch_power
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|acpi_powerresource
modifier|*
name|rp
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|cur
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|powerres
argument_list|)
expr_stmt|;
comment|/*      * Sweep the list forwards turning things on.      */
name|TAILQ_FOREACH
argument_list|(
argument|rp
argument_list|,
argument|&acpi_powerresources
argument_list|,
argument|ap_link
argument_list|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|rp
operator|->
name|ap_references
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"%s has no references, not turning on\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We could cache this if we trusted it not to change under us */
name|status
operator|=
name|acpi_GetInteger
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|,
literal|"_STA"
argument_list|,
operator|&
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"can't get status of %s - %d\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX is this correct?  Always switch if in doubt? */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|ap_state
operator|==
name|ACPI_PWR_UNK
condition|)
name|rp
operator|->
name|ap_state
operator|=
name|cur
expr_stmt|;
comment|/* 	 * Switch if required.  Note that we ignore the result of the switch 	 * effort; we don't know what to do if it fails, so checking wouldn't 	 * help much. 	 */
if|if
condition|(
name|rp
operator|->
name|ap_state
operator|!=
name|ACPI_PWR_ON
condition|)
block|{
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|,
literal|"_ON"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"failed to switch %s on - %s\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|->
name|ap_state
operator|=
name|ACPI_PWR_ON
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"switched %s on\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"%s is already on\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Sweep the list backwards turning things off. */
name|TAILQ_FOREACH_REVERSE
argument_list|(
argument|rp
argument_list|,
argument|&acpi_powerresources
argument_list|,
argument|acpi_powerresource_list
argument_list|,
argument|ap_link
argument_list|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|rp
operator|->
name|ap_references
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"%s has references, not turning off\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We could cache this if we trusted it not to change under us */
name|status
operator|=
name|acpi_GetInteger
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|,
literal|"_STA"
argument_list|,
operator|&
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"can't get status of %s - %d\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX is this correct?  Always switch if in doubt? */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|ap_state
operator|==
name|ACPI_PWR_UNK
condition|)
name|rp
operator|->
name|ap_state
operator|=
name|cur
expr_stmt|;
comment|/* 	 * Switch if required.  Note that we ignore the result of the switch 	 * effort; we don't know what to do if it fails, so checking wouldn't 	 * help much. 	 */
if|if
condition|(
name|rp
operator|->
name|ap_state
operator|!=
name|ACPI_PWR_OFF
condition|)
block|{
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|,
literal|"_OFF"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"failed to switch %s off - %s\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|->
name|ap_state
operator|=
name|ACPI_PWR_OFF
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"switched %s off\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"%s is already off\n"
operator|,
name|acpi_name
argument_list|(
name|rp
operator|->
name|ap_resource
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find a power resource's control structure.  */
end_comment

begin_function
specifier|static
name|struct
name|acpi_powerresource
modifier|*
name|acpi_pwr_find_resource
parameter_list|(
name|ACPI_HANDLE
name|res
parameter_list|)
block|{
name|struct
name|acpi_powerresource
modifier|*
name|rp
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|powerres
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rp
argument_list|,
argument|&acpi_powerresources
argument_list|,
argument|ap_link
argument_list|)
block|{
if|if
condition|(
name|rp
operator|->
name|ap_resource
operator|==
name|res
condition|)
break|break;
block|}
name|return_PTR
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find a power consumer's control structure.  */
end_comment

begin_function
specifier|static
name|struct
name|acpi_powerconsumer
modifier|*
name|acpi_pwr_find_consumer
parameter_list|(
name|ACPI_HANDLE
name|consumer
parameter_list|)
block|{
name|struct
name|acpi_powerconsumer
modifier|*
name|pc
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|powerres
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pc
argument_list|,
argument|&acpi_powerconsumers
argument_list|,
argument|ac_link
argument_list|)
block|{
if|if
condition|(
name|pc
operator|->
name|ac_consumer
operator|==
name|consumer
condition|)
break|break;
block|}
name|return_PTR
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

