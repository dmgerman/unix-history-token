begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2005 Nate Lawson (SDG)  * Copyright (c) 2001 Michael Smith  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/power.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/acpi.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_comment
comment|/*  * Support for ACPI Processor devices, including C[1-3] sleep states.  */
end_comment

begin_comment
comment|/* Hooks for the ACPI CA debugging infrastructure */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_PROCESSOR
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"PROCESSOR"
argument_list|)
end_macro

begin_struct
struct|struct
name|acpi_cx
block|{
name|struct
name|resource
modifier|*
name|p_lvlx
decl_stmt|;
comment|/* Register to read to enter state. */
name|uint32_t
name|type
decl_stmt|;
comment|/* C1-3 (C4 and up treated as C3). */
name|uint32_t
name|trans_lat
decl_stmt|;
comment|/* Transition latency (usec). */
name|uint32_t
name|power
decl_stmt|;
comment|/* Power consumed (mW). */
name|int
name|res_type
decl_stmt|;
comment|/* Resource type for p_lvlx. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_CX_STATES
value|8
end_define

begin_struct
struct|struct
name|acpi_cpu_softc
block|{
name|device_t
name|cpu_dev
decl_stmt|;
name|ACPI_HANDLE
name|cpu_handle
decl_stmt|;
name|struct
name|pcpu
modifier|*
name|cpu_pcpu
decl_stmt|;
name|uint32_t
name|cpu_acpi_id
decl_stmt|;
comment|/* ACPI processor id */
name|uint32_t
name|cpu_p_blk
decl_stmt|;
comment|/* ACPI P_BLK location */
name|uint32_t
name|cpu_p_blk_len
decl_stmt|;
comment|/* P_BLK length (must be 6). */
name|struct
name|acpi_cx
name|cpu_cx_states
index|[
name|MAX_CX_STATES
index|]
decl_stmt|;
name|int
name|cpu_cx_count
decl_stmt|;
comment|/* Number of valid Cx states. */
name|int
name|cpu_prev_sleep
decl_stmt|;
comment|/* Last idle sleep duration. */
name|int
name|cpu_features
decl_stmt|;
comment|/* Child driver supported features. */
comment|/* Runtime state. */
name|int
name|cpu_non_c3
decl_stmt|;
comment|/* Index of lowest non-C3 state. */
name|int
name|cpu_short_slp
decl_stmt|;
comment|/* Count of< 1us sleeps. */
name|u_int
name|cpu_cx_stats
index|[
name|MAX_CX_STATES
index|]
decl_stmt|;
comment|/* Cx usage history. */
comment|/* Values for sysctl. */
name|struct
name|sysctl_ctx_list
name|cpu_sysctl_ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|cpu_sysctl_tree
decl_stmt|;
name|int
name|cpu_cx_lowest
decl_stmt|;
name|char
name|cpu_cx_supported
index|[
literal|64
index|]
decl_stmt|;
name|int
name|cpu_rid
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|acpi_cpu_device
block|{
name|struct
name|resource_list
name|ad_rl
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CPU_GET_REG
parameter_list|(
name|reg
parameter_list|,
name|width
parameter_list|)
define|\
value|(bus_space_read_ ## width(rman_get_bustag((reg)), 			\ 		      rman_get_bushandle((reg)), 0))
end_define

begin_define
define|#
directive|define
name|CPU_SET_REG
parameter_list|(
name|reg
parameter_list|,
name|width
parameter_list|,
name|val
parameter_list|)
define|\
value|(bus_space_write_ ## width(rman_get_bustag((reg)), 			\ 		       rman_get_bushandle((reg)), 0, (val)))
end_define

begin_define
define|#
directive|define
name|PM_USEC
parameter_list|(
name|x
parameter_list|)
value|((x)>> 2)
end_define

begin_comment
comment|/* ~4 clocks per usec (3.57955 Mhz) */
end_comment

begin_define
define|#
directive|define
name|ACPI_NOTIFY_CX_STATES
value|0x81
end_define

begin_comment
comment|/* _CST changed. */
end_comment

begin_define
define|#
directive|define
name|CPU_QUIRK_NO_C3
value|(1<<0)
end_define

begin_comment
comment|/* C3-type states are not usable. */
end_comment

begin_define
define|#
directive|define
name|CPU_QUIRK_NO_BM_CTRL
value|(1<<2)
end_define

begin_comment
comment|/* No bus mastering control. */
end_comment

begin_define
define|#
directive|define
name|PCI_VENDOR_INTEL
value|0x8086
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_82371AB_3
value|0x7113
end_define

begin_comment
comment|/* PIIX4 chipset for quirks. */
end_comment

begin_define
define|#
directive|define
name|PCI_REVISION_A_STEP
value|0
end_define

begin_define
define|#
directive|define
name|PCI_REVISION_B_STEP
value|1
end_define

begin_define
define|#
directive|define
name|PCI_REVISION_4E
value|2
end_define

begin_define
define|#
directive|define
name|PCI_REVISION_4M
value|3
end_define

begin_comment
comment|/* Platform hardware resource information. */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|cpu_smi_cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value to write to SMI_CMD. */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|cpu_cst_cnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate we are _CST aware. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cpu_quirks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate any hardware bugs. */
end_comment

begin_comment
comment|/* Runtime state. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cpu_disable_idle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Disable entry to idle function */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cpu_cx_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of valid Cx states */
end_comment

begin_comment
comment|/* Values for sysctl. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sysctl_ctx_list
name|cpu_sysctl_ctx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sysctl_oid
modifier|*
name|cpu_sysctl_tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpu_cx_generic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpu_cx_lowest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_t
modifier|*
name|cpu_devices
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpu_ndevices
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|acpi_cpu_softc
modifier|*
modifier|*
name|cpu_softc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ACPI_SERIAL_DECL
argument_list|(
name|cpu
argument_list|,
literal|"ACPI CPU"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|acpi_cpu_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_pcpu_get_id
parameter_list|(
name|uint32_t
name|idx
parameter_list|,
name|uint32_t
modifier|*
name|acpi_id
parameter_list|,
name|uint32_t
modifier|*
name|cpu_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|resource_list
modifier|*
name|acpi_cpu_get_rlist
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|device_t
name|acpi_cpu_add_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|order
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_cx_probe
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_generic_cx_probe
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_cx_cst
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_startup_cx
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_idle
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_notify
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
name|UINT32
name|notify
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_quirks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_usage_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_cx_lowest_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_global_cx_lowest_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|acpi_cpu_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|acpi_cpu_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|acpi_cpu_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|acpi_cpu_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_add_child
argument_list|,
name|acpi_cpu_add_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|acpi_cpu_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource_list
argument_list|,
name|acpi_cpu_get_rlist
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource
argument_list|,
name|bus_generic_rl_get_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_set_resource
argument_list|,
name|bus_generic_rl_set_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|bus_generic_rl_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|bus_generic_rl_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bus_generic_teardown_intr
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|acpi_cpu_driver
init|=
block|{
literal|"cpu"
block|,
name|acpi_cpu_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_cpu_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|acpi_cpu_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cpu
argument_list|,
name|acpi
argument_list|,
name|acpi_cpu_driver
argument_list|,
name|acpi_cpu_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|cpu
argument_list|,
name|acpi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|acpi_cpu_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|acpi_id
decl_stmt|,
name|cpu_id
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_HANDLE
name|handle
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|obj
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"cpu"
argument_list|)
operator|||
name|acpi_get_type
argument_list|(
name|dev
argument_list|)
operator|!=
name|ACPI_TYPE_PROCESSOR
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu_softc
operator|==
name|NULL
condition|)
name|cpu_softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_cpu_softc
operator|*
argument_list|)
operator|*
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
argument_list|,
name|M_TEMP
comment|/* XXX */
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Get our Processor object. */
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|handle
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"probe failed to get Processor obj - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|obj
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|buf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|Type
operator|!=
name|ACPI_TYPE_PROCESSOR
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Processor object has bad type %d\n"
argument_list|,
name|obj
operator|->
name|Type
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*      * Find the processor associated with our unit.  We could use the      * ProcId as a key, however, some boxes do not have the same values      * in their Processor object as the ProcId values in the MADT.      */
name|acpi_id
operator|=
name|obj
operator|->
name|Processor
operator|.
name|ProcId
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|acpi_pcpu_get_id
argument_list|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|acpi_id
argument_list|,
operator|&
name|cpu_id
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*      * Check if we already probed this processor.  We scan the bus twice      * so it's possible we've already seen this one.      */
if|if
condition|(
name|cpu_softc
index|[
name|cpu_id
index|]
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Mark this processor as in-use and save our derived id for attach. */
name|cpu_softc
index|[
name|cpu_id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
name|acpi_set_magic
argument_list|(
name|dev
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ACPI CPU"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_OBJECT
name|arg
decl_stmt|,
modifier|*
name|obj
decl_stmt|;
name|ACPI_OBJECT_LIST
name|arglist
decl_stmt|;
name|struct
name|pcpu
modifier|*
name|pcpu_data
decl_stmt|;
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|acpi_softc
modifier|*
name|acpi_sc
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|u_int
name|features
decl_stmt|;
name|int
name|cpu_id
decl_stmt|,
name|drv_count
decl_stmt|,
name|i
decl_stmt|;
name|driver_t
modifier|*
modifier|*
name|drivers
decl_stmt|;
name|uint32_t
name|cap_set
index|[
literal|3
index|]
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cpu_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|cpu_handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cpu_id
operator|=
name|acpi_get_magic
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cpu_softc
index|[
name|cpu_id
index|]
operator|=
name|sc
expr_stmt|;
name|pcpu_data
operator|=
name|pcpu_find
argument_list|(
name|cpu_id
argument_list|)
expr_stmt|;
name|pcpu_data
operator|->
name|pc_device
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|cpu_pcpu
operator|=
name|pcpu_data
expr_stmt|;
name|cpu_smi_cmd
operator|=
name|AcpiGbl_FADT
operator|->
name|SmiCmd
expr_stmt|;
name|cpu_cst_cnt
operator|=
name|AcpiGbl_FADT
operator|->
name|CstCnt
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|sc
operator|->
name|cpu_handle
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"attach failed to get Processor obj - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|obj
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|buf
operator|.
name|Pointer
expr_stmt|;
name|sc
operator|->
name|cpu_p_blk
operator|=
name|obj
operator|->
name|Processor
operator|.
name|PblkAddress
expr_stmt|;
name|sc
operator|->
name|cpu_p_blk_len
operator|=
name|obj
operator|->
name|Processor
operator|.
name|PblkLength
expr_stmt|;
name|sc
operator|->
name|cpu_acpi_id
operator|=
name|obj
operator|->
name|Processor
operator|.
name|ProcId
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu%d: P_BLK at %#x/%d\n"
operator|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|,
name|sc
operator|->
name|cpu_p_blk
operator|,
name|sc
operator|->
name|cpu_p_blk_len
operator|)
argument_list|)
expr_stmt|;
comment|/*      * If this is the first cpu we attach, create and initialize the generic      * resources that will be used by all acpi cpu devices.      */
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Assume we won't be using generic Cx mode by default */
name|cpu_cx_generic
operator|=
name|FALSE
expr_stmt|;
comment|/* Install hw.acpi.cpu sysctl tree */
name|acpi_sc
operator|=
name|acpi_device_get_parent_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|cpu_sysctl_ctx
argument_list|)
expr_stmt|;
name|cpu_sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|acpi_sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cpu"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"node for CPU children"
argument_list|)
expr_stmt|;
comment|/* Queue post cpu-probing task handler */
name|AcpiOsQueueForExecution
argument_list|(
name|OSD_PRIORITY_LO
argument_list|,
name|acpi_cpu_startup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/*      * Before calling any CPU methods, collect child driver feature hints      * and notify ACPI of them.  We support unified SMP power control      * so advertise this ourselves.  Note this is not the same as independent      * SMP control where each CPU can have different settings.      */
name|sc
operator|->
name|cpu_features
operator|=
name|ACPI_CAP_SMP_SAME
operator||
name|ACPI_CAP_SMP_SAME_C3
expr_stmt|;
if|if
condition|(
name|devclass_get_drivers
argument_list|(
name|acpi_cpu_devclass
argument_list|,
operator|&
name|drivers
argument_list|,
operator|&
name|drv_count
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|drv_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ACPI_GET_FEATURES
argument_list|(
name|drivers
index|[
name|i
index|]
argument_list|,
operator|&
name|features
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|cpu_features
operator||=
name|features
expr_stmt|;
block|}
name|free
argument_list|(
name|drivers
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
comment|/*      * CPU capabilities are specified as a buffer of 32-bit integers:      * revision, count, and one or more capabilities.  The revision of      * "1" is not specified anywhere but seems to match Linux.  We should      * also support _OSC here.      */
if|if
condition|(
name|sc
operator|->
name|cpu_features
condition|)
block|{
name|arglist
operator|.
name|Pointer
operator|=
operator|&
name|arg
expr_stmt|;
name|arglist
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|arg
operator|.
name|Type
operator|=
name|ACPI_TYPE_BUFFER
expr_stmt|;
name|arg
operator|.
name|Buffer
operator|.
name|Length
operator|=
sizeof|sizeof
argument_list|(
name|cap_set
argument_list|)
expr_stmt|;
name|arg
operator|.
name|Buffer
operator|.
name|Pointer
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|cap_set
expr_stmt|;
name|cap_set
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* revision */
name|cap_set
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* number of capabilities integers */
name|cap_set
index|[
literal|2
index|]
operator|=
name|sc
operator|->
name|cpu_features
expr_stmt|;
name|AcpiEvaluateObject
argument_list|(
name|sc
operator|->
name|cpu_handle
argument_list|,
literal|"_PDC"
argument_list|,
operator|&
name|arglist
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Probe for Cx state support. */
name|acpi_cpu_cx_probe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Finally,  call identify and probe/attach for child devices. */
name|bus_generic_probe
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the nth present CPU and return its pc_cpuid as well as set the  * pc_acpi_id from the most reliable source.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_pcpu_get_id
parameter_list|(
name|uint32_t
name|idx
parameter_list|,
name|uint32_t
modifier|*
name|acpi_id
parameter_list|,
name|uint32_t
modifier|*
name|cpu_id
parameter_list|)
block|{
name|struct
name|pcpu
modifier|*
name|pcpu_data
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|acpi_id
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Null acpi_id"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cpu_id
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Null cpu_id"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|pcpu_data
operator|=
name|pcpu_find
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pcpu_data
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no pcpu data for %d"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|--
operator|==
literal|0
condition|)
block|{
comment|/* 	     * If pc_acpi_id was not initialized (e.g., a non-APIC UP box) 	     * override it with the value from the ASL.  Otherwise, if the 	     * two don't match, prefer the MADT-derived value.  Finally, 	     * return the pc_cpuid to reference this processor. 	     */
if|if
condition|(
name|pcpu_data
operator|->
name|pc_acpi_id
operator|==
literal|0xffffffff
condition|)
name|pcpu_data
operator|->
name|pc_acpi_id
operator|=
operator|*
name|acpi_id
expr_stmt|;
elseif|else
if|if
condition|(
name|pcpu_data
operator|->
name|pc_acpi_id
operator|!=
operator|*
name|acpi_id
condition|)
operator|*
name|acpi_id
operator|=
name|pcpu_data
operator|->
name|pc_acpi_id
expr_stmt|;
operator|*
name|cpu_id
operator|=
name|pcpu_data
operator|->
name|pc_cpuid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource_list
modifier|*
name|acpi_cpu_get_rlist
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|acpi_cpu_device
modifier|*
name|ad
decl_stmt|;
name|ad
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|ad
operator|->
name|ad_rl
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|device_t
name|acpi_cpu_add_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|order
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|acpi_cpu_device
modifier|*
name|ad
decl_stmt|;
name|device_t
name|child
decl_stmt|;
if|if
condition|(
operator|(
name|ad
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ad
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|resource_list_init
argument_list|(
operator|&
name|ad
operator|->
name|ad_rl
argument_list|)
expr_stmt|;
name|child
operator|=
name|device_add_child_ordered
argument_list|(
name|dev
argument_list|,
name|order
argument_list|,
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|ad
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|ad
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|ACPI_IVAR_HANDLE
case|:
operator|*
name|result
operator|=
operator|(
name|uintptr_t
operator|)
name|sc
operator|->
name|cpu_handle
expr_stmt|;
break|break;
case|case
name|CPU_IVAR_PCPU
case|:
operator|*
name|result
operator|=
operator|(
name|uintptr_t
operator|)
name|sc
operator|->
name|cpu_pcpu
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* Allow children to shutdown first. */
name|bus_generic_shutdown
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Disable any entry to the idle function. */
name|cpu_disable_idle
operator|=
name|TRUE
expr_stmt|;
comment|/* Signal and wait for all processors to exit acpi_cpu_idle(). */
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_cpu_cx_probe
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* Use initial sleep value of 1 sec. to start with lowest idle state. */
name|sc
operator|->
name|cpu_prev_sleep
operator|=
literal|1000000
expr_stmt|;
name|sc
operator|->
name|cpu_cx_lowest
operator|=
literal|0
expr_stmt|;
comment|/*      * Check for the ACPI 2.0 _CST sleep states object. If we can't find      * any, we'll revert to generic FADT/P_BLK Cx control method which will      * be handled by acpi_cpu_startup. We need to defer to after having      * probed all the cpus in the system before probing for generic Cx      * states as we may already have found cpus with valid _CST packages      */
if|if
condition|(
operator|!
name|cpu_cx_generic
operator|&&
name|acpi_cpu_cx_cst
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 	 * We were unable to find a _CST package for this cpu or there 	 * was an error parsing it. Switch back to generic mode. 	 */
name|cpu_cx_generic
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"switching to generic Cx mode\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * TODO: _CSD Package should be checked here.      */
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_cpu_generic_cx_probe
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ACPI_GENERIC_ADDRESS
name|gas
decl_stmt|;
name|struct
name|acpi_cx
modifier|*
name|cx_ptr
decl_stmt|;
name|sc
operator|->
name|cpu_cx_count
operator|=
literal|0
expr_stmt|;
name|cx_ptr
operator|=
name|sc
operator|->
name|cpu_cx_states
expr_stmt|;
comment|/* Use initial sleep value of 1 sec. to start with lowest idle state. */
name|sc
operator|->
name|cpu_prev_sleep
operator|=
literal|1000000
expr_stmt|;
comment|/* C1 has been required since just after ACPI 1.0 */
name|cx_ptr
operator|->
name|type
operator|=
name|ACPI_STATE_C1
expr_stmt|;
name|cx_ptr
operator|->
name|trans_lat
operator|=
literal|0
expr_stmt|;
name|cx_ptr
operator|++
expr_stmt|;
name|sc
operator|->
name|cpu_cx_count
operator|++
expr_stmt|;
comment|/*       * The spec says P_BLK must be 6 bytes long.  However, some systems      * use it to indicate a fractional set of features present so we      * take 5 as C2.  Some may also have a value of 7 to indicate      * another C3 but most use _CST for this (as required) and having      * "only" C1-C3 is not a hardship.      */
if|if
condition|(
name|sc
operator|->
name|cpu_p_blk_len
operator|<
literal|5
condition|)
return|return;
comment|/* Validate and allocate resources for C2 (P_LVL2). */
name|gas
operator|.
name|AddressSpaceId
operator|=
name|ACPI_ADR_SPACE_SYSTEM_IO
expr_stmt|;
name|gas
operator|.
name|RegisterBitWidth
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|AcpiGbl_FADT
operator|->
name|Plvl2Lat
operator|<=
literal|100
condition|)
block|{
name|gas
operator|.
name|Address
operator|=
name|sc
operator|->
name|cpu_p_blk
operator|+
literal|4
expr_stmt|;
name|acpi_bus_alloc_gas
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
operator|&
name|cx_ptr
operator|->
name|res_type
argument_list|,
operator|&
name|sc
operator|->
name|cpu_rid
argument_list|,
operator|&
name|gas
argument_list|,
operator|&
name|cx_ptr
operator|->
name|p_lvlx
argument_list|,
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx_ptr
operator|->
name|p_lvlx
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|cpu_rid
operator|++
expr_stmt|;
name|cx_ptr
operator|->
name|type
operator|=
name|ACPI_STATE_C2
expr_stmt|;
name|cx_ptr
operator|->
name|trans_lat
operator|=
name|AcpiGbl_FADT
operator|->
name|Plvl2Lat
expr_stmt|;
name|cx_ptr
operator|++
expr_stmt|;
name|sc
operator|->
name|cpu_cx_count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|cpu_p_blk_len
operator|<
literal|6
condition|)
return|return;
comment|/* Validate and allocate resources for C3 (P_LVL3). */
if|if
condition|(
name|AcpiGbl_FADT
operator|->
name|Plvl3Lat
operator|<=
literal|1000
condition|)
block|{
name|gas
operator|.
name|Address
operator|=
name|sc
operator|->
name|cpu_p_blk
operator|+
literal|5
expr_stmt|;
name|acpi_bus_alloc_gas
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
operator|&
name|cx_ptr
operator|->
name|res_type
argument_list|,
operator|&
name|sc
operator|->
name|cpu_rid
argument_list|,
operator|&
name|gas
argument_list|,
operator|&
name|cx_ptr
operator|->
name|p_lvlx
argument_list|,
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx_ptr
operator|->
name|p_lvlx
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|cpu_rid
operator|++
expr_stmt|;
name|cx_ptr
operator|->
name|type
operator|=
name|ACPI_STATE_C3
expr_stmt|;
name|cx_ptr
operator|->
name|trans_lat
operator|=
name|AcpiGbl_FADT
operator|->
name|Plvl3Lat
expr_stmt|;
name|cx_ptr
operator|++
expr_stmt|;
name|sc
operator|->
name|cpu_cx_count
operator|++
expr_stmt|;
block|}
block|}
comment|/* Update the largest cx_count seen so far */
if|if
condition|(
name|sc
operator|->
name|cpu_cx_count
operator|>
name|cpu_cx_count
condition|)
name|cpu_cx_count
operator|=
name|sc
operator|->
name|cpu_cx_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse a _CST package and set up its Cx states.  Since the _CST object  * can change dynamically, our notify handler may call this function  * to clean up and probe the new _CST package.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_cpu_cx_cst
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|acpi_cx
modifier|*
name|cx_ptr
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|top
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|pkg
decl_stmt|;
name|uint32_t
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|sc
operator|->
name|cpu_handle
argument_list|,
literal|"_CST"
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* _CST is a package with a count and at least one Cx package. */
name|top
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|buf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
operator|!
name|ACPI_PKG_VALID
argument_list|(
name|top
argument_list|,
literal|2
argument_list|)
operator|||
name|acpi_PkgInt32
argument_list|(
name|top
argument_list|,
literal|0
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"invalid _CST package\n"
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|count
operator|!=
name|top
operator|->
name|Package
operator|.
name|Count
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"invalid _CST state count (%d != %d)\n"
argument_list|,
name|count
argument_list|,
name|top
operator|->
name|Package
operator|.
name|Count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
name|top
operator|->
name|Package
operator|.
name|Count
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
name|MAX_CX_STATES
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"_CST has too many states (%d)\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|count
operator|=
name|MAX_CX_STATES
expr_stmt|;
block|}
comment|/* Set up all valid states. */
name|sc
operator|->
name|cpu_cx_count
operator|=
literal|0
expr_stmt|;
name|cx_ptr
operator|=
name|sc
operator|->
name|cpu_cx_states
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pkg
operator|=
operator|&
name|top
operator|->
name|Package
operator|.
name|Elements
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ACPI_PKG_VALID
argument_list|(
name|pkg
argument_list|,
literal|4
argument_list|)
operator|||
name|acpi_PkgInt32
argument_list|(
name|pkg
argument_list|,
literal|1
argument_list|,
operator|&
name|cx_ptr
operator|->
name|type
argument_list|)
operator|!=
literal|0
operator|||
name|acpi_PkgInt32
argument_list|(
name|pkg
argument_list|,
literal|2
argument_list|,
operator|&
name|cx_ptr
operator|->
name|trans_lat
argument_list|)
operator|!=
literal|0
operator|||
name|acpi_PkgInt32
argument_list|(
name|pkg
argument_list|,
literal|3
argument_list|,
operator|&
name|cx_ptr
operator|->
name|power
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"skipping invalid Cx state package\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Validate the state to see if we should use it. */
switch|switch
condition|(
name|cx_ptr
operator|->
name|type
condition|)
block|{
case|case
name|ACPI_STATE_C1
case|:
name|sc
operator|->
name|cpu_non_c3
operator|=
name|i
expr_stmt|;
name|cx_ptr
operator|++
expr_stmt|;
name|sc
operator|->
name|cpu_cx_count
operator|++
expr_stmt|;
continue|continue;
case|case
name|ACPI_STATE_C2
case|:
if|if
condition|(
name|cx_ptr
operator|->
name|trans_lat
operator|>
literal|100
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu%d: C2[%d] not available.\n"
operator|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|cpu_non_c3
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|ACPI_STATE_C3
case|:
default|default:
if|if
condition|(
name|cx_ptr
operator|->
name|trans_lat
operator|>
literal|1000
operator|||
operator|(
name|cpu_quirks
operator|&
name|CPU_QUIRK_NO_C3
operator|)
operator|!=
literal|0
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu%d: C3[%d] not available.\n"
operator|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* Free up any previous register. */
if|if
condition|(
name|cx_ptr
operator|->
name|p_lvlx
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cx_ptr
operator|->
name|p_lvlx
argument_list|)
expr_stmt|;
name|cx_ptr
operator|->
name|p_lvlx
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Allocate the control register for C2 or C3. */
name|acpi_PkgGas
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
name|pkg
argument_list|,
literal|0
argument_list|,
operator|&
name|cx_ptr
operator|->
name|res_type
argument_list|,
operator|&
name|sc
operator|->
name|cpu_rid
argument_list|,
operator|&
name|cx_ptr
operator|->
name|p_lvlx
argument_list|,
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx_ptr
operator|->
name|p_lvlx
condition|)
block|{
name|sc
operator|->
name|cpu_rid
operator|++
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu%d: Got C%d - %d latency\n"
operator|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
operator|,
name|cx_ptr
operator|->
name|type
operator|,
name|cx_ptr
operator|->
name|trans_lat
operator|)
argument_list|)
expr_stmt|;
name|cx_ptr
operator|++
expr_stmt|;
name|sc
operator|->
name|cpu_cx_count
operator|++
expr_stmt|;
block|}
block|}
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Call this *after* all CPUs have been attached.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_cpu_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get set of CPU devices */
name|devclass_get_devices
argument_list|(
name|acpi_cpu_devclass
argument_list|,
operator|&
name|cpu_devices
argument_list|,
operator|&
name|cpu_ndevices
argument_list|)
expr_stmt|;
comment|/*      * Setup any quirks that might necessary now that we have probed      * all the CPUs      */
name|acpi_cpu_quirks
argument_list|()
expr_stmt|;
name|cpu_cx_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cpu_cx_generic
condition|)
block|{
comment|/* 	 * We are using generic Cx mode, probe for available Cx states 	 * for all processors. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpu_ndevices
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
name|device_get_softc
argument_list|(
name|cpu_devices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|acpi_cpu_generic_cx_probe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find the highest Cx state common to all CPUs 	 * in the system, taking quirks into account. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpu_ndevices
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
name|device_get_softc
argument_list|(
name|cpu_devices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cpu_cx_count
operator|<
name|cpu_cx_count
condition|)
name|cpu_cx_count
operator|=
name|sc
operator|->
name|cpu_cx_count
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * We are using _CST mode, remove C3 state if necessary. 	 * Update the largest Cx state supported in the global cpu_cx_count. 	 * It will be used in the global Cx sysctl handler. 	 * As we now know for sure that we will be using _CST mode 	 * install our notify handler. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpu_ndevices
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
name|device_get_softc
argument_list|(
name|cpu_devices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu_quirks
operator|&&
name|CPU_QUIRK_NO_C3
condition|)
block|{
name|sc
operator|->
name|cpu_cx_count
operator|=
name|sc
operator|->
name|cpu_non_c3
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|cpu_cx_count
operator|>
name|cpu_cx_count
condition|)
name|cpu_cx_count
operator|=
name|sc
operator|->
name|cpu_cx_count
expr_stmt|;
name|AcpiInstallNotifyHandler
argument_list|(
name|sc
operator|->
name|cpu_handle
argument_list|,
name|ACPI_DEVICE_NOTIFY
argument_list|,
name|acpi_cpu_notify
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Perform Cx final initialization. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpu_ndevices
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
name|device_get_softc
argument_list|(
name|cpu_devices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|acpi_cpu_startup_cx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Add a sysctl handler to handle global Cx lowest setting */
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|cpu_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cx_lowest"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|acpi_cpu_global_cx_lowest_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"Global lowest Cx sleep state to use"
argument_list|)
expr_stmt|;
comment|/* Take over idling from cpu_idle_default(). */
name|cpu_cx_lowest
operator|=
literal|0
expr_stmt|;
name|cpu_disable_idle
operator|=
name|FALSE
expr_stmt|;
name|cpu_idle_hook
operator|=
name|acpi_cpu_idle
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_cpu_startup_cx
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sbuf
name|sb
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Set up the list of Cx states      */
name|sc
operator|->
name|cpu_non_c3
operator|=
literal|0
expr_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|sc
operator|->
name|cpu_cx_supported
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cpu_cx_supported
argument_list|)
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|cpu_cx_count
condition|;
name|i
operator|++
control|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"C%d/%d "
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|sc
operator|->
name|cpu_cx_states
index|[
name|i
index|]
operator|.
name|trans_lat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cpu_cx_states
index|[
name|i
index|]
operator|.
name|type
operator|<
name|ACPI_STATE_C3
condition|)
name|sc
operator|->
name|cpu_non_c3
operator|=
name|i
expr_stmt|;
block|}
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
operator|&
name|sc
operator|->
name|cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cx_supported"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sc
operator|->
name|cpu_cx_supported
argument_list|,
literal|0
argument_list|,
literal|"Cx/microsecond values for supported Cx states"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cx_lowest"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|acpi_cpu_cx_lowest_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"lowest Cx sleep state to use"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cx_usage"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|acpi_cpu_usage_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"percent usage for each Cx state"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* Signal platform that we can handle _CST notification. */
if|if
condition|(
operator|!
name|cpu_cx_generic
operator|&&
name|cpu_cst_cnt
operator|!=
literal|0
condition|)
block|{
name|ACPI_LOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
name|AcpiOsWritePort
argument_list|(
name|cpu_smi_cmd
argument_list|,
name|cpu_cst_cnt
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Idle the CPU in the lowest state possible.  This function is called with  * interrupts disabled.  Note that once it re-enables interrupts, a task  * switch can occur so do not access shared data (i.e. the softc) after  * interrupts are re-enabled.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_cpu_idle
parameter_list|()
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|acpi_cx
modifier|*
name|cx_next
decl_stmt|;
name|uint32_t
name|start_time
decl_stmt|,
name|end_time
decl_stmt|;
name|int
name|bm_active
decl_stmt|,
name|cx_next_idx
decl_stmt|,
name|i
decl_stmt|;
comment|/* If disabled, return immediately. */
if|if
condition|(
name|cpu_disable_idle
condition|)
block|{
name|ACPI_ENABLE_IRQS
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/*      * Look up our CPU id to get our softc.  If it's NULL, we'll use C1      * since there is no ACPI processor object for this CPU.  This occurs      * for logical CPUs in the HTT case.      */
name|sc
operator|=
name|cpu_softc
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|acpi_cpu_c1
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/*      * If we slept 100 us or more, use the lowest Cx state.  Otherwise,      * find the lowest state that has a latency less than or equal to      * the length of our last sleep.      */
name|cx_next_idx
operator|=
name|sc
operator|->
name|cpu_cx_lowest
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cpu_prev_sleep
operator|<
literal|100
condition|)
block|{
comment|/* 	 * If we sleep too short all the time, this system may not implement 	 * C2/3 correctly (i.e. reads return immediately).  In this case, 	 * back off and use the next higher level. 	 * It seems that when you have a dual core cpu (like the Intel Core Duo) 	 * that both cores will get out of C3 state as soon as one of them 	 * requires it. This breaks the sleep detection logic as the sleep 	 * counter is local to each cpu. Disable the sleep logic for now as a 	 * workaround if there's more than one CPU. The right fix would probably 	 * be to add quirks for system that don't really support C3 state. 	 */
if|if
condition|(
name|mp_ncpus
operator|<
literal|2
operator|&&
name|sc
operator|->
name|cpu_prev_sleep
operator|<=
literal|1
condition|)
block|{
name|sc
operator|->
name|cpu_short_slp
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cpu_short_slp
operator|==
literal|1000
operator|&&
name|sc
operator|->
name|cpu_cx_lowest
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|cpu_non_c3
operator|==
name|sc
operator|->
name|cpu_cx_lowest
operator|&&
name|sc
operator|->
name|cpu_non_c3
operator|!=
literal|0
condition|)
name|sc
operator|->
name|cpu_non_c3
operator|--
expr_stmt|;
name|sc
operator|->
name|cpu_cx_lowest
operator|--
expr_stmt|;
name|sc
operator|->
name|cpu_short_slp
operator|=
literal|0
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"too many short sleeps, backing off to C%d\n"
argument_list|,
name|sc
operator|->
name|cpu_cx_lowest
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sc
operator|->
name|cpu_short_slp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|cpu_cx_lowest
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|sc
operator|->
name|cpu_cx_states
index|[
name|i
index|]
operator|.
name|trans_lat
operator|<=
name|sc
operator|->
name|cpu_prev_sleep
condition|)
block|{
name|cx_next_idx
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/*      * Check for bus master activity.  If there was activity, clear      * the bit and use the lowest non-C3 state.  Note that the USB      * driver polling for new devices keeps this bit set all the      * time if USB is loaded.      */
if|if
condition|(
operator|(
name|cpu_quirks
operator|&
name|CPU_QUIRK_NO_BM_CTRL
operator|)
operator|==
literal|0
condition|)
block|{
name|AcpiGetRegister
argument_list|(
name|ACPI_BITREG_BUS_MASTER_STATUS
argument_list|,
operator|&
name|bm_active
argument_list|,
name|ACPI_MTX_DO_NOT_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|bm_active
operator|!=
literal|0
condition|)
block|{
name|AcpiSetRegister
argument_list|(
name|ACPI_BITREG_BUS_MASTER_STATUS
argument_list|,
literal|1
argument_list|,
name|ACPI_MTX_DO_NOT_LOCK
argument_list|)
expr_stmt|;
name|cx_next_idx
operator|=
name|min
argument_list|(
name|cx_next_idx
argument_list|,
name|sc
operator|->
name|cpu_non_c3
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Select the next state and update statistics. */
name|cx_next
operator|=
operator|&
name|sc
operator|->
name|cpu_cx_states
index|[
name|cx_next_idx
index|]
expr_stmt|;
name|sc
operator|->
name|cpu_cx_stats
index|[
name|cx_next_idx
index|]
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|cx_next
operator|->
name|type
operator|!=
name|ACPI_STATE_C0
argument_list|,
operator|(
literal|"acpi_cpu_idle: C0 sleep"
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Execute HLT (or equivalent) and wait for an interrupt.  We can't      * calculate the time spent in C1 since the place we wake up is an      * ISR.  Assume we slept one quantum and return.      */
if|if
condition|(
name|cx_next
operator|->
name|type
operator|==
name|ACPI_STATE_C1
condition|)
block|{
name|sc
operator|->
name|cpu_prev_sleep
operator|=
literal|1000000
operator|/
name|hz
expr_stmt|;
name|acpi_cpu_c1
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/*      * For C3, disable bus master arbitration and enable bus master wake      * if BM control is available, otherwise flush the CPU cache.      */
if|if
condition|(
name|cx_next
operator|->
name|type
operator|==
name|ACPI_STATE_C3
condition|)
block|{
if|if
condition|(
operator|(
name|cpu_quirks
operator|&
name|CPU_QUIRK_NO_BM_CTRL
operator|)
operator|==
literal|0
condition|)
block|{
name|AcpiSetRegister
argument_list|(
name|ACPI_BITREG_ARB_DISABLE
argument_list|,
literal|1
argument_list|,
name|ACPI_MTX_DO_NOT_LOCK
argument_list|)
expr_stmt|;
name|AcpiSetRegister
argument_list|(
name|ACPI_BITREG_BUS_MASTER_RLD
argument_list|,
literal|1
argument_list|,
name|ACPI_MTX_DO_NOT_LOCK
argument_list|)
expr_stmt|;
block|}
else|else
name|ACPI_FLUSH_CPU_CACHE
argument_list|()
expr_stmt|;
block|}
comment|/*      * Read from P_LVLx to enter C2(+), checking time spent asleep.      * Use the ACPI timer for measuring sleep time.  Since we need to      * get the time very close to the CPU start/stop clock logic, this      * is the only reliable time source.      */
name|AcpiHwLowLevelRead
argument_list|(
literal|32
argument_list|,
operator|&
name|start_time
argument_list|,
operator|&
name|AcpiGbl_FADT
operator|->
name|XPmTmrBlk
argument_list|)
expr_stmt|;
name|CPU_GET_REG
argument_list|(
name|cx_next
operator|->
name|p_lvlx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Read the end time twice.  Since it may take an arbitrary time      * to enter the idle state, the first read may be executed before      * the processor has stopped.  Doing it again provides enough      * margin that we are certain to have a correct value.      */
name|AcpiHwLowLevelRead
argument_list|(
literal|32
argument_list|,
operator|&
name|end_time
argument_list|,
operator|&
name|AcpiGbl_FADT
operator|->
name|XPmTmrBlk
argument_list|)
expr_stmt|;
name|AcpiHwLowLevelRead
argument_list|(
literal|32
argument_list|,
operator|&
name|end_time
argument_list|,
operator|&
name|AcpiGbl_FADT
operator|->
name|XPmTmrBlk
argument_list|)
expr_stmt|;
comment|/* Enable bus master arbitration and disable bus master wakeup. */
if|if
condition|(
name|cx_next
operator|->
name|type
operator|==
name|ACPI_STATE_C3
operator|&&
operator|(
name|cpu_quirks
operator|&
name|CPU_QUIRK_NO_BM_CTRL
operator|)
operator|==
literal|0
condition|)
block|{
name|AcpiSetRegister
argument_list|(
name|ACPI_BITREG_ARB_DISABLE
argument_list|,
literal|0
argument_list|,
name|ACPI_MTX_DO_NOT_LOCK
argument_list|)
expr_stmt|;
name|AcpiSetRegister
argument_list|(
name|ACPI_BITREG_BUS_MASTER_RLD
argument_list|,
literal|0
argument_list|,
name|ACPI_MTX_DO_NOT_LOCK
argument_list|)
expr_stmt|;
block|}
name|ACPI_ENABLE_IRQS
argument_list|()
expr_stmt|;
comment|/* Find the actual time asleep in microseconds, minus overhead. */
name|end_time
operator|=
name|acpi_TimerDelta
argument_list|(
name|end_time
argument_list|,
name|start_time
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cpu_prev_sleep
operator|=
name|PM_USEC
argument_list|(
name|end_time
argument_list|)
operator|-
name|cx_next
operator|->
name|trans_lat
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Re-evaluate the _CST object when we are notified that it changed.  *  * XXX Re-evaluation disabled until locking is done.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_cpu_notify
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
name|UINT32
name|notify
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_cpu_softc
operator|*
operator|)
name|context
decl_stmt|;
if|if
condition|(
name|notify
operator|!=
name|ACPI_NOTIFY_CX_STATES
condition|)
return|return;
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"Cx states changed\n"
argument_list|)
expr_stmt|;
comment|/* acpi_cpu_cx_cst(sc); */
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_quirks
parameter_list|(
name|void
parameter_list|)
block|{
name|device_t
name|acpi_dev
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/*      * Bus mastering arbitration control is needed to keep caches coherent      * while sleeping in C3.  If it's not present but a working flush cache      * instruction is present, flush the caches before entering C3 instead.      * Otherwise, just disable C3 completely.      */
if|if
condition|(
name|AcpiGbl_FADT
operator|->
name|V1_Pm2CntBlk
operator|==
literal|0
operator|||
name|AcpiGbl_FADT
operator|->
name|Pm2CntLen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|AcpiGbl_FADT
operator|->
name|WbInvd
operator|&&
name|AcpiGbl_FADT
operator|->
name|WbInvdFlush
operator|==
literal|0
condition|)
block|{
name|cpu_quirks
operator||=
name|CPU_QUIRK_NO_BM_CTRL
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu: no BM control, using flush cache method\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cpu_quirks
operator||=
name|CPU_QUIRK_NO_C3
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu: no BM control, C3 not available\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * If we are using generic Cx mode, C3 on multiple CPUs requires using      * the expensive flush cache instruction.      */
if|if
condition|(
name|cpu_cx_generic
operator|&&
name|mp_ncpus
operator|>
literal|1
condition|)
block|{
name|cpu_quirks
operator||=
name|CPU_QUIRK_NO_BM_CTRL
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu: SMP, using flush cache mode for C3\n"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Look for various quirks of the PIIX4 part. */
name|acpi_dev
operator|=
name|pci_find_device
argument_list|(
name|PCI_VENDOR_INTEL
argument_list|,
name|PCI_DEVICE_82371AB_3
argument_list|)
expr_stmt|;
if|if
condition|(
name|acpi_dev
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|pci_get_revid
argument_list|(
name|acpi_dev
argument_list|)
condition|)
block|{
comment|/* 	 * Disable C3 support for all PIIX4 chipsets.  Some of these parts 	 * do not report the BMIDE status to the BM status register and 	 * others have a livelock bug if Type-F DMA is enabled.  Linux 	 * works around the BMIDE bug by reading the BM status directly 	 * but we take the simpler approach of disabling C3 for these 	 * parts. 	 * 	 * See erratum #18 ("C3 Power State/BMIDE and Type-F DMA 	 * Livelock") from the January 2002 PIIX4 specification update. 	 * Applies to all PIIX4 models. 	 */
case|case
name|PCI_REVISION_4E
case|:
case|case
name|PCI_REVISION_4M
case|:
name|cpu_quirks
operator||=
name|CPU_QUIRK_NO_C3
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu: working around PIIX4 bug, disabling C3\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_usage_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uintmax_t
name|fract
decl_stmt|,
name|sum
decl_stmt|,
name|whole
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|acpi_cpu_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|cpu_cx_count
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|sc
operator|->
name|cpu_cx_stats
index|[
name|i
index|]
expr_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|cpu_cx_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sum
operator|>
literal|0
condition|)
block|{
name|whole
operator|=
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|cpu_cx_stats
index|[
name|i
index|]
operator|*
literal|100
expr_stmt|;
name|fract
operator|=
operator|(
name|whole
operator|%
name|sum
operator|)
operator|*
literal|100
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%u.%02u%% "
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|whole
operator|/
name|sum
argument_list|)
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|fract
operator|/
name|sum
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"0%% "
argument_list|)
expr_stmt|;
block|}
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_cx_lowest_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|char
name|state
index|[
literal|8
index|]
decl_stmt|;
name|int
name|val
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|acpi_cpu_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|snprintf
argument_list|(
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|,
literal|"C%d"
argument_list|,
name|sc
operator|->
name|cpu_cx_lowest
operator|+
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|strlen
argument_list|(
name|state
argument_list|)
operator|<
literal|2
operator|||
name|toupper
argument_list|(
name|state
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|'C'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|val
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|state
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
name|sc
operator|->
name|cpu_cx_count
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ACPI_SERIAL_BEGIN
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cpu_cx_lowest
operator|=
name|val
expr_stmt|;
comment|/* If not disabling, cache the new lowest non-C3 state. */
name|sc
operator|->
name|cpu_non_c3
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|cpu_cx_lowest
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|cpu_cx_states
index|[
name|i
index|]
operator|.
name|type
operator|<
name|ACPI_STATE_C3
condition|)
block|{
name|sc
operator|->
name|cpu_non_c3
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* Reset the statistics counters. */
name|bzero
argument_list|(
name|sc
operator|->
name|cpu_cx_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cpu_cx_stats
argument_list|)
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_END
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_global_cx_lowest_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|char
name|state
index|[
literal|8
index|]
decl_stmt|;
name|int
name|val
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|snprintf
argument_list|(
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|,
literal|"C%d"
argument_list|,
name|cpu_cx_lowest
operator|+
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|strlen
argument_list|(
name|state
argument_list|)
operator|<
literal|2
operator|||
name|toupper
argument_list|(
name|state
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|'C'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|val
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|state
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
name|cpu_cx_count
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cpu_cx_lowest
operator|=
name|val
expr_stmt|;
comment|/*      * Update the new lowest useable Cx state for all CPUs      */
name|ACPI_SERIAL_BEGIN
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpu_ndevices
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
name|device_get_softc
argument_list|(
name|cpu_devices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cpu_cx_lowest
operator|=
name|cpu_cx_lowest
expr_stmt|;
name|sc
operator|->
name|cpu_non_c3
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|sc
operator|->
name|cpu_cx_lowest
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|cpu_cx_states
index|[
name|i
index|]
operator|.
name|type
operator|<
name|ACPI_STATE_C3
condition|)
block|{
name|sc
operator|->
name|cpu_non_c3
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* Reset the statistics counters. */
name|bzero
argument_list|(
name|sc
operator|->
name|cpu_cx_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cpu_cx_stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ACPI_SERIAL_END
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

