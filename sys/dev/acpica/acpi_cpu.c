begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Michael Smith  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|"acpi.h"
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_comment
comment|/*  * Support for ACPI Processor devices.  *  * Note that this only provides ACPI 1.0 support (with the exception of the  * PSTATE_CNT field).  2.0 support will involve implementing _PTC, _PCT,  * _PSS and _PPC.  */
end_comment

begin_comment
comment|/*  * Hooks for the ACPI CA debugging infrastructure  */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_PROCESSOR
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"PROCESSOR"
argument_list|)
end_macro

begin_struct
struct|struct
name|acpi_cpu_softc
block|{
name|device_t
name|cpu_dev
decl_stmt|;
name|ACPI_HANDLE
name|cpu_handle
decl_stmt|;
name|u_int32_t
name|cpu_id
decl_stmt|;
comment|/* CPU throttling control register */
name|struct
name|resource
modifier|*
name|cpu_p_blk
decl_stmt|;
define|#
directive|define
name|CPU_GET_P_CNT
parameter_list|(
name|sc
parameter_list|)
value|(bus_space_read_4(rman_get_bustag((sc)->cpu_p_blk), 	\ 						  rman_get_bushandle((sc)->cpu_p_blk),	\ 						  0))
define|#
directive|define
name|CPU_SET_P_CNT
parameter_list|(
name|sc
parameter_list|,
name|val
parameter_list|)
value|(bus_space_write_4(rman_get_bustag((sc)->cpu_p_blk), 	\ 						  rman_get_bushandle((sc)->cpu_p_blk),	\ 						  0, (val)))
define|#
directive|define
name|CPU_P_CNT_THT_EN
value|(1<<4)
block|}
struct|;
end_struct

begin_comment
comment|/*   * Speeds are stored in counts, from 1 - CPU_MAX_SPEED, and  * reported to the user in tenths of a percent.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|cpu_duty_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|cpu_duty_width
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CPU_MAX_SPEED
value|(1<< cpu_duty_width)
end_define

begin_define
define|#
directive|define
name|CPU_SPEED_PERCENT
parameter_list|(
name|x
parameter_list|)
value|((1000 * (x)) / CPU_MAX_SPEED)
end_define

begin_define
define|#
directive|define
name|CPU_SPEED_PRINTABLE
parameter_list|(
name|x
parameter_list|)
value|(CPU_SPEED_PERCENT(x) / 10),(CPU_SPEED_PERCENT(x) % 10)
end_define

begin_decl_stmt
specifier|static
name|u_int32_t
name|cpu_smi_cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should be a generic way to do this */
end_comment

begin_decl_stmt
specifier|static
name|u_int8_t
name|cpu_pstate_cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|cpu_current_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|cpu_performance_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|cpu_economy_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|cpu_max_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_t
modifier|*
name|cpu_devices
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpu_ndevices
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sysctl_ctx_list
name|acpi_cpu_sysctl_ctx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sysctl_oid
modifier|*
name|acpi_cpu_sysctl_tree
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|acpi_cpu_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_init_throttling
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_set_speed
parameter_list|(
name|u_int32_t
name|speed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_powerprofile
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_speed_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|acpi_cpu_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|acpi_cpu_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|acpi_cpu_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|acpi_cpu_driver
init|=
block|{
literal|"acpi_cpu"
block|,
name|acpi_cpu_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_cpu_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|acpi_cpu_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|acpi_cpu
argument_list|,
name|acpi
argument_list|,
name|acpi_cpu_driver
argument_list|,
name|acpi_cpu_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|acpi_cpu_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|acpi_disabled
argument_list|(
literal|"cpu"
argument_list|)
operator|&&
operator|(
name|acpi_get_type
argument_list|(
name|dev
argument_list|)
operator|==
name|ACPI_TYPE_PROCESSOR
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"CPU"
argument_list|)
expr_stmt|;
comment|/* XXX get more verbose description? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|acpi_softc
modifier|*
name|acpi_sc
decl_stmt|;
name|ACPI_OBJECT
name|processor
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|u_int32_t
name|p_blk
decl_stmt|;
name|u_int32_t
name|p_blk_length
decl_stmt|;
name|u_int32_t
name|duty_end
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cpu_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|cpu_handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/*      * Get global parameters from the FADT.      */
if|if
condition|(
name|device_get_unit
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_duty_offset
operator|=
name|AcpiGbl_FADT
operator|->
name|DutyOffset
expr_stmt|;
name|cpu_duty_width
operator|=
name|AcpiGbl_FADT
operator|->
name|DutyWidth
expr_stmt|;
name|cpu_smi_cmd
operator|=
name|AcpiGbl_FADT
operator|->
name|SmiCmd
expr_stmt|;
name|cpu_pstate_cnt
operator|=
name|AcpiGbl_FADT
operator|->
name|PstateCnt
expr_stmt|;
comment|/* validate the offset/width */
if|if
condition|(
name|cpu_duty_width
operator|>
literal|0
condition|)
block|{
name|duty_end
operator|=
name|cpu_duty_offset
operator|+
name|cpu_duty_width
operator|-
literal|1
expr_stmt|;
comment|/* check that it fits */
if|if
condition|(
name|duty_end
operator|>
literal|31
condition|)
block|{
name|printf
argument_list|(
literal|"acpi_cpu: CLK_VAL field overflows P_CNT register\n"
argument_list|)
expr_stmt|;
name|cpu_duty_width
operator|=
literal|0
expr_stmt|;
block|}
comment|/* check for overlap with the THT_EN bit */
if|if
condition|(
operator|(
name|cpu_duty_offset
operator|<=
literal|4
operator|)
operator|&&
operator|(
name|duty_end
operator|>=
literal|4
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"acpi_cpu: CLK_VAL field overlaps THT_EN bit\n"
argument_list|)
expr_stmt|;
name|cpu_duty_width
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*  	 * Start the throttling process once the probe phase completes, if we think that 	 * it's going to be useful.  If the duty width value is zero, there are no significant 	 * bits in the register and thus no throttled states. 	 */
if|if
condition|(
name|cpu_duty_width
operator|>
literal|0
condition|)
block|{
name|AcpiOsQueueForExecution
argument_list|(
name|OSD_PRIORITY_LO
argument_list|,
name|acpi_cpu_init_throttling
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|acpi_sc
operator|=
name|acpi_device_get_parent_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|acpi_cpu_sysctl_ctx
argument_list|)
expr_stmt|;
name|acpi_cpu_sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|acpi_cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|acpi_sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cpu"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|acpi_cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|acpi_cpu_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_speed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|cpu_max_state
argument_list|,
literal|0
argument_list|,
literal|"maximum CPU speed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|acpi_cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|acpi_cpu_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"current_speed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|cpu_current_state
argument_list|,
literal|0
argument_list|,
literal|"current CPU speed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|acpi_cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|acpi_cpu_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"performance_speed"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|cpu_performance_state
argument_list|,
literal|0
argument_list|,
name|acpi_cpu_speed_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|acpi_cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|acpi_cpu_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"economy_speed"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|cpu_economy_state
argument_list|,
literal|0
argument_list|,
name|acpi_cpu_speed_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Get the processor object.      */
name|buf
operator|.
name|Pointer
operator|=
operator|&
name|processor
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
sizeof|sizeof
argument_list|(
name|processor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|sc
operator|->
name|cpu_handle
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"couldn't get Processor object - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|processor
operator|.
name|Type
operator|!=
name|ACPI_TYPE_PROCESSOR
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"Processor object has bad type %d\n"
argument_list|,
name|processor
operator|.
name|Type
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|cpu_id
operator|=
name|processor
operator|.
name|Processor
operator|.
name|ProcId
expr_stmt|;
comment|/*      * If it looks like we support throttling, find this CPU's P_BLK.      *      * Note that some systems seem to duplicate the P_BLK pointer across        * multiple CPUs, so not getting the resource is not fatal.      *       * XXX should support _PTC here as well, once we work out how to parse it.      *      * XXX is it valid to assume that the P_BLK must be 6 bytes long?      */
if|if
condition|(
name|cpu_duty_width
operator|>
literal|0
condition|)
block|{
name|p_blk
operator|=
name|processor
operator|.
name|Processor
operator|.
name|PblkAddress
expr_stmt|;
name|p_blk_length
operator|=
name|processor
operator|.
name|Processor
operator|.
name|PblkLength
expr_stmt|;
comment|/* allocate bus space if possible */
if|if
condition|(
operator|(
name|p_blk
operator|>
literal|0
operator|)
operator|&&
operator|(
name|p_blk_length
operator|==
literal|6
operator|)
condition|)
block|{
name|rid
operator|=
literal|0
expr_stmt|;
name|bus_set_resource
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|rid
argument_list|,
name|p_blk
argument_list|,
name|p_blk_length
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cpu_p_blk
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_IO
operator|,
literal|"acpi_cpu%d: throttling with P_BLK at 0x%x/%d%s\n"
operator|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
operator|,
name|p_blk
operator|,
name|p_blk_length
operator|,
name|sc
operator|->
name|cpu_p_blk
condition|?
literal|""
else|:
literal|" (shadowed)"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|return_VALUE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Call this *after* all CPUs have been attached.  *  * Takes the ACPI lock to avoid fighting anyone over the SMI command  * port.  Could probably lock less code.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_cpu_init_throttling
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|cpu_temp_speed
decl_stmt|;
name|ACPI_LOCK
expr_stmt|;
comment|/* get set of CPU devices */
name|devclass_get_devices
argument_list|(
name|acpi_cpu_devclass
argument_list|,
operator|&
name|cpu_devices
argument_list|,
operator|&
name|cpu_ndevices
argument_list|)
expr_stmt|;
comment|/* initialise throttling states */
name|cpu_max_state
operator|=
name|CPU_MAX_SPEED
expr_stmt|;
name|cpu_performance_state
operator|=
name|cpu_max_state
expr_stmt|;
name|cpu_economy_state
operator|=
name|cpu_performance_state
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|cpu_economy_state
operator|==
literal|0
condition|)
comment|/* 0 is 'reserved' */
name|cpu_economy_state
operator|++
expr_stmt|;
if|if
condition|(
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.acpi.cpu.performance_speed"
argument_list|,
operator|&
name|cpu_temp_speed
argument_list|)
operator|&&
name|cpu_temp_speed
operator|>
literal|0
operator|&&
name|cpu_temp_speed
operator|<=
name|cpu_max_state
condition|)
name|cpu_performance_state
operator|=
name|cpu_temp_speed
expr_stmt|;
if|if
condition|(
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.acpi.cpu.economy_speed"
argument_list|,
operator|&
name|cpu_temp_speed
argument_list|)
operator|&&
name|cpu_temp_speed
operator|>
literal|0
operator|&&
name|cpu_temp_speed
operator|<=
name|cpu_max_state
condition|)
name|cpu_economy_state
operator|=
name|cpu_temp_speed
expr_stmt|;
comment|/* register performance profile change handler */
name|EVENTHANDLER_REGISTER
argument_list|(
name|powerprofile_change
argument_list|,
name|acpi_cpu_powerprofile
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if ACPI 2.0+, signal platform that we are taking over throttling */
if|if
condition|(
name|cpu_pstate_cnt
operator|!=
literal|0
condition|)
block|{
comment|/* XXX should be a generic interface for this */
name|AcpiOsWritePort
argument_list|(
name|cpu_smi_cmd
argument_list|,
name|cpu_pstate_cnt
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|ACPI_UNLOCK
expr_stmt|;
comment|/* set initial speed */
name|acpi_cpu_powerprofile
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"acpi_cpu: CPU throttling enabled, %d steps from 100%% to %d.%d%%\n"
argument_list|,
name|CPU_MAX_SPEED
argument_list|,
name|CPU_SPEED_PRINTABLE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set CPUs to the new state.  *  * Must be called with the ACPI lock held.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_cpu_set_speed
parameter_list|(
name|u_int32_t
name|speed
parameter_list|)
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int32_t
name|p_cnt
decl_stmt|,
name|clk_val
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
comment|/* iterate over processors */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpu_ndevices
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
name|device_get_softc
argument_list|(
name|cpu_devices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cpu_p_blk
operator|==
name|NULL
condition|)
continue|continue;
comment|/* get the current P_CNT value and disable throttling */
name|p_cnt
operator|=
name|CPU_GET_P_CNT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|p_cnt
operator|&=
operator|~
name|CPU_P_CNT_THT_EN
expr_stmt|;
name|CPU_SET_P_CNT
argument_list|(
name|sc
argument_list|,
name|p_cnt
argument_list|)
expr_stmt|;
comment|/* if we're at maximum speed, that's all */
if|if
condition|(
name|speed
operator|<
name|CPU_MAX_SPEED
condition|)
block|{
comment|/* mask the old CLK_VAL off and or-in the new value */
name|clk_val
operator|=
name|CPU_MAX_SPEED
operator|<<
name|cpu_duty_offset
expr_stmt|;
name|p_cnt
operator|&=
operator|~
name|clk_val
expr_stmt|;
name|p_cnt
operator||=
operator|(
name|speed
operator|<<
name|cpu_duty_offset
operator|)
expr_stmt|;
comment|/* write the new P_CNT value and then enable throttling */
name|CPU_SET_P_CNT
argument_list|(
name|sc
argument_list|,
name|p_cnt
argument_list|)
expr_stmt|;
name|p_cnt
operator||=
name|CPU_P_CNT_THT_EN
expr_stmt|;
name|CPU_SET_P_CNT
argument_list|(
name|sc
argument_list|,
name|p_cnt
argument_list|)
expr_stmt|;
block|}
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
argument_list|,
literal|"set speed to %d.%d%%\n"
argument_list|,
name|CPU_SPEED_PRINTABLE
argument_list|(
name|speed
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cpu_current_state
operator|=
name|speed
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Power profile change hook.  *  * Uses the ACPI lock to avoid reentrancy.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_cpu_powerprofile
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|u_int32_t
name|new
decl_stmt|;
name|ACPI_LOCK
expr_stmt|;
name|new
operator|=
operator|(
name|powerprofile_get_state
argument_list|()
operator|==
name|POWERPROFILE_PERFORMANCE
operator|)
condition|?
name|cpu_performance_state
else|:
name|cpu_economy_state
expr_stmt|;
if|if
condition|(
name|cpu_current_state
operator|!=
name|new
condition|)
name|acpi_cpu_set_speed
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|ACPI_UNLOCK
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle changes in the performance/ecomony CPU settings.  *  * Does not need the ACPI lock (although setting *argp should  * probably be atomic).  */
end_comment

begin_function
specifier|static
name|int
name|acpi_cpu_speed_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|argp
decl_stmt|;
name|u_int32_t
name|arg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|argp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|arg
operator|=
operator|*
name|argp
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* error or no new value */
if|if
condition|(
operator|(
name|error
operator|!=
literal|0
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* range check */
if|if
condition|(
operator|(
name|arg
operator|<
literal|1
operator|)
operator|||
operator|(
name|arg
operator|>
name|cpu_max_state
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* set new value and possibly switch */
operator|*
name|argp
operator|=
name|arg
expr_stmt|;
name|acpi_cpu_powerprofile
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

