begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Nate Lawson (SDG)  * Copyright (c) 2001 Michael Smith  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/power.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__ia64__
end_ifdef

begin_include
include|#
directive|include
file|<machine/pal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|"acpi.h"
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_comment
comment|/*  * Support for ACPI Processor devices, including ACPI 2.0 throttling  * and C[1-3] sleep states.  *  * TODO: implement scans of all CPUs to be sure all Cx states are  * equivalent.  */
end_comment

begin_comment
comment|/* Hooks for the ACPI CA debugging infrastructure */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_PROCESSOR
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"PROCESSOR"
argument_list|)
end_macro

begin_struct
struct|struct
name|acpi_cx
block|{
name|struct
name|resource
modifier|*
name|p_lvlx
decl_stmt|;
comment|/* Register to read to enter state. */
name|uint32_t
name|type
decl_stmt|;
comment|/* C1-3 (C4 and up treated as C3). */
name|uint32_t
name|trans_lat
decl_stmt|;
comment|/* Transition latency (usec). */
name|uint32_t
name|power
decl_stmt|;
comment|/* Power consumed (mW). */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_CX_STATES
value|8
end_define

begin_struct
struct|struct
name|acpi_cx_stats
block|{
name|int
name|long_slp
decl_stmt|;
comment|/* Count of sleeps>= trans_lat. */
name|int
name|short_slp
decl_stmt|;
comment|/* Count of sleeps< trans_lat. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|acpi_cpu_softc
block|{
name|device_t
name|cpu_dev
decl_stmt|;
name|ACPI_HANDLE
name|cpu_handle
decl_stmt|;
name|uint32_t
name|acpi_id
decl_stmt|;
comment|/* ACPI processor id */
name|uint32_t
name|cpu_p_blk
decl_stmt|;
comment|/* ACPI P_BLK location */
name|uint32_t
name|cpu_p_blk_len
decl_stmt|;
comment|/* P_BLK length (must be 6). */
name|struct
name|resource
modifier|*
name|cpu_p_cnt
decl_stmt|;
comment|/* Throttling control register */
name|struct
name|acpi_cx
name|cpu_cx_states
index|[
name|MAX_CX_STATES
index|]
decl_stmt|;
name|int
name|cpu_cx_count
decl_stmt|;
comment|/* Number of valid Cx states. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CPU_GET_REG
parameter_list|(
name|reg
parameter_list|,
name|width
parameter_list|)
define|\
value|(bus_space_read_ ## width(rman_get_bustag((reg)), 			\ 		      rman_get_bushandle((reg)), 0))
end_define

begin_define
define|#
directive|define
name|CPU_SET_REG
parameter_list|(
name|reg
parameter_list|,
name|width
parameter_list|,
name|val
parameter_list|)
define|\
value|(bus_space_write_ ## width(rman_get_bustag((reg)), 			\ 		       rman_get_bushandle((reg)), 0, (val)))
end_define

begin_comment
comment|/*  * Speeds are stored in counts, from 1 to CPU_MAX_SPEED, and  * reported to the user in tenths of a percent.  */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|cpu_duty_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|cpu_duty_width
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CPU_MAX_SPEED
value|(1<< cpu_duty_width)
end_define

begin_define
define|#
directive|define
name|CPU_SPEED_PERCENT
parameter_list|(
name|x
parameter_list|)
value|((1000 * (x)) / CPU_MAX_SPEED)
end_define

begin_define
define|#
directive|define
name|CPU_SPEED_PRINTABLE
parameter_list|(
name|x
parameter_list|)
value|(CPU_SPEED_PERCENT(x) / 10),	\ 				(CPU_SPEED_PERCENT(x) % 10)
end_define

begin_define
define|#
directive|define
name|CPU_P_CNT_THT_EN
value|(1<<4)
end_define

begin_define
define|#
directive|define
name|PM_USEC
parameter_list|(
name|x
parameter_list|)
value|((x)>> 2)
end_define

begin_comment
comment|/* ~4 clocks per usec (3.57955 Mhz) */
end_comment

begin_define
define|#
directive|define
name|ACPI_CPU_NOTIFY_PERF_STATES
value|0x80
end_define

begin_comment
comment|/* _PSS changed. */
end_comment

begin_define
define|#
directive|define
name|ACPI_CPU_NOTIFY_CX_STATES
value|0x81
end_define

begin_comment
comment|/* _CST changed. */
end_comment

begin_define
define|#
directive|define
name|CPU_QUIRK_NO_C3
value|0x0001
end_define

begin_comment
comment|/* C3-type states are not usable. */
end_comment

begin_define
define|#
directive|define
name|CPU_QUIRK_NO_THROTTLE
value|0x0002
end_define

begin_comment
comment|/* Throttling is not usable. */
end_comment

begin_define
define|#
directive|define
name|PCI_VENDOR_INTEL
value|0x8086
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_82371AB_3
value|0x7113
end_define

begin_comment
comment|/* PIIX4 chipset for quirks. */
end_comment

begin_define
define|#
directive|define
name|PCI_REVISION_A_STEP
value|0
end_define

begin_define
define|#
directive|define
name|PCI_REVISION_B_STEP
value|1
end_define

begin_define
define|#
directive|define
name|PCI_REVISION_4E
value|2
end_define

begin_define
define|#
directive|define
name|PCI_REVISION_4M
value|3
end_define

begin_comment
comment|/* Platform hardware resource information. */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|cpu_smi_cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value to write to SMI_CMD. */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|cpu_pstate_cnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register to take over throttling. */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|cpu_cst_cnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate we are _CST aware. */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|cpu_rid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Driver-wide resource id. */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|cpu_quirks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate any hardware bugs. */
end_comment

begin_comment
comment|/* Runtime state. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cpu_cx_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of valid states */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|cpu_cx_next
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* State to use for next sleep. */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|cpu_non_c3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of lowest non-C3 state. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|acpi_cx_stats
name|cpu_cx_stats
index|[
name|MAX_CX_STATES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpu_idle_busy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of CPUs in acpi_cpu_idle. */
end_comment

begin_comment
comment|/* Values for sysctl. */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|cpu_throttle_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|cpu_throttle_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpu_cx_lowest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cpu_cx_supported
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_t
modifier|*
name|cpu_devices
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpu_ndevices
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|acpi_cpu_softc
modifier|*
modifier|*
name|cpu_softc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sysctl_ctx_list
name|acpi_cpu_sysctl_ctx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sysctl_oid
modifier|*
name|acpi_cpu_sysctl_tree
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|acpi_cpu_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_pcpu_get_id
parameter_list|(
name|uint32_t
name|idx
parameter_list|,
name|uint32_t
modifier|*
name|acpi_id
parameter_list|,
name|uint32_t
modifier|*
name|cpu_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_throttle_probe
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_cx_probe
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_cx_cst
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_startup_throttling
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_startup_cx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_throttle_set
parameter_list|(
name|uint32_t
name|speed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_idle
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_c1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_cpu_notify
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
name|UINT32
name|notify
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_quirks
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_throttle_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_history_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_cpu_cx_lowest_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|acpi_cpu_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|acpi_cpu_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|acpi_cpu_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|acpi_cpu_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|acpi_cpu_driver
init|=
block|{
literal|"cpu"
block|,
name|acpi_cpu_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_cpu_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|acpi_cpu_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cpu
argument_list|,
name|acpi
argument_list|,
name|acpi_cpu_driver
argument_list|,
name|acpi_cpu_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|cpu
argument_list|,
name|acpi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|acpi_cpu_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|acpi_id
decl_stmt|,
name|cpu_id
decl_stmt|,
name|cx_count
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_HANDLE
name|handle
decl_stmt|;
name|char
name|msg
index|[
literal|32
index|]
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|obj
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"cpu"
argument_list|)
operator|||
name|acpi_get_type
argument_list|(
name|dev
argument_list|)
operator|!=
name|ACPI_TYPE_PROCESSOR
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu_softc
operator|==
name|NULL
condition|)
name|cpu_softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_cpu_softc
operator|*
argument_list|)
operator|*
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
argument_list|,
name|M_TEMP
comment|/* XXX */
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Get our Processor object. */
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|handle
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"probe failed to get Processor obj - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|obj
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|buf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|Type
operator|!=
name|ACPI_TYPE_PROCESSOR
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Processor object has bad type %d\n"
argument_list|,
name|obj
operator|->
name|Type
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*      * Find the processor associated with our unit.  We could use the      * ProcId as a key, however, some boxes do not have the same values      * in their Processor object as the ProcId values in the MADT.      */
name|acpi_id
operator|=
name|obj
operator|->
name|Processor
operator|.
name|ProcId
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|acpi_pcpu_get_id
argument_list|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|acpi_id
argument_list|,
operator|&
name|cpu_id
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*      * Check if we already probed this processor.  We scan the bus twice      * so it's possible we've already seen this one.      */
if|if
condition|(
name|cpu_softc
index|[
name|cpu_id
index|]
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Get a count of Cx states for our device string. */
name|cx_count
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|handle
argument_list|,
literal|"_CST"
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|obj
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|buf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|ACPI_PKG_VALID
argument_list|(
name|obj
argument_list|,
literal|2
argument_list|)
condition|)
name|acpi_PkgInt32
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
operator|&
name|cx_count
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|AcpiGbl_FADT
operator|->
name|Plvl2Lat
operator|<=
literal|100
condition|)
name|cx_count
operator|++
expr_stmt|;
if|if
condition|(
name|AcpiGbl_FADT
operator|->
name|Plvl3Lat
operator|<=
literal|1000
condition|)
name|cx_count
operator|++
expr_stmt|;
if|if
condition|(
name|cx_count
operator|>
literal|0
condition|)
name|cx_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cx_count
operator|>
literal|0
condition|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"ACPI CPU (%d Cx states)"
argument_list|,
name|cx_count
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|msg
argument_list|,
literal|"ACPI CPU"
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* Mark this processor as in-use and save our derived id for attach. */
name|cpu_softc
index|[
name|cpu_id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
name|acpi_set_magic
argument_list|(
name|dev
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|obj
decl_stmt|;
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|acpi_softc
modifier|*
name|acpi_sc
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|thr_ret
decl_stmt|,
name|cx_ret
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cpu_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|cpu_handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cpu_softc
index|[
name|acpi_get_magic
argument_list|(
name|dev
argument_list|)
index|]
operator|=
name|sc
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|sc
operator|->
name|cpu_handle
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"attach failed to get Processor obj - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|obj
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|buf
operator|.
name|Pointer
expr_stmt|;
name|sc
operator|->
name|cpu_p_blk
operator|=
name|obj
operator|->
name|Processor
operator|.
name|PblkAddress
expr_stmt|;
name|sc
operator|->
name|cpu_p_blk_len
operator|=
name|obj
operator|->
name|Processor
operator|.
name|PblkLength
expr_stmt|;
name|sc
operator|->
name|acpi_id
operator|=
name|obj
operator|->
name|Processor
operator|.
name|ProcId
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu%d: P_BLK at %#x/%d\n"
operator|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|,
name|sc
operator|->
name|cpu_p_blk
operator|,
name|sc
operator|->
name|cpu_p_blk_len
operator|)
argument_list|)
expr_stmt|;
name|acpi_sc
operator|=
name|acpi_device_get_parent_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|acpi_cpu_sysctl_ctx
argument_list|)
expr_stmt|;
name|acpi_cpu_sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|acpi_cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|acpi_sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cpu"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* If this is the first device probed, check for quirks. */
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
condition|)
name|acpi_cpu_quirks
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Probe for throttling and Cx state support.      * If none of these is present, free up unused resources.      */
name|thr_ret
operator|=
name|acpi_cpu_throttle_probe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cx_ret
operator|=
name|acpi_cpu_cx_probe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|thr_ret
operator|==
literal|0
operator|||
name|cx_ret
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|AcpiInstallNotifyHandler
argument_list|(
name|sc
operator|->
name|cpu_handle
argument_list|,
name|ACPI_DEVICE_NOTIFY
argument_list|,
name|acpi_cpu_notify
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
condition|)
name|AcpiOsQueueForExecution
argument_list|(
name|OSD_PRIORITY_LO
argument_list|,
name|acpi_cpu_startup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sysctl_ctx_free
argument_list|(
operator|&
name|acpi_cpu_sysctl_ctx
argument_list|)
expr_stmt|;
block|}
name|return_VALUE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the nth present CPU and return its pc_cpuid as well as set the  * pc_acpi_id from the most reliable source.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_pcpu_get_id
parameter_list|(
name|uint32_t
name|idx
parameter_list|,
name|uint32_t
modifier|*
name|acpi_id
parameter_list|,
name|uint32_t
modifier|*
name|cpu_id
parameter_list|)
block|{
name|struct
name|pcpu
modifier|*
name|pcpu_data
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|acpi_id
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Null acpi_id"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cpu_id
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Null cpu_id"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|pcpu_data
operator|=
name|pcpu_find
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pcpu_data
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no pcpu data for %d"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|--
operator|==
literal|0
condition|)
block|{
comment|/* 	     * If pc_acpi_id was not initialized (e.g., a non-APIC UP box) 	     * override it with the value from the ASL.  Otherwise, if the 	     * two don't match, prefer the MADT-derived value.  Finally, 	     * return the pc_cpuid to reference this processor. 	     */
if|if
condition|(
name|pcpu_data
operator|->
name|pc_acpi_id
operator|==
literal|0xffffffff
condition|)
name|pcpu_data
operator|->
name|pc_acpi_id
operator|=
operator|*
name|acpi_id
expr_stmt|;
elseif|else
if|if
condition|(
name|pcpu_data
operator|->
name|pc_acpi_id
operator|!=
operator|*
name|acpi_id
condition|)
operator|*
name|acpi_id
operator|=
name|pcpu_data
operator|->
name|pc_acpi_id
expr_stmt|;
operator|*
name|cpu_id
operator|=
name|pcpu_data
operator|->
name|pc_cpuid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* Disable any entry to the idle function. */
name|cpu_cx_count
operator|=
literal|0
expr_stmt|;
comment|/* Wait for all processors to exit acpi_cpu_idle(). */
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|cpu_idle_busy
operator|>
literal|0
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_throttle_probe
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|duty_end
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_OBJECT
name|obj
decl_stmt|;
name|ACPI_GENERIC_ADDRESS
name|gas
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
comment|/* Get throttling parameters from the FADT.  0 means not supported. */
if|if
condition|(
name|device_get_unit
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_smi_cmd
operator|=
name|AcpiGbl_FADT
operator|->
name|SmiCmd
expr_stmt|;
name|cpu_pstate_cnt
operator|=
name|AcpiGbl_FADT
operator|->
name|PstateCnt
expr_stmt|;
name|cpu_cst_cnt
operator|=
name|AcpiGbl_FADT
operator|->
name|CstCnt
expr_stmt|;
name|cpu_duty_offset
operator|=
name|AcpiGbl_FADT
operator|->
name|DutyOffset
expr_stmt|;
name|cpu_duty_width
operator|=
name|AcpiGbl_FADT
operator|->
name|DutyWidth
expr_stmt|;
block|}
if|if
condition|(
name|cpu_duty_width
operator|==
literal|0
operator|||
operator|(
name|cpu_quirks
operator|&
name|CPU_QUIRK_NO_THROTTLE
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Validate the duty offset/width. */
name|duty_end
operator|=
name|cpu_duty_offset
operator|+
name|cpu_duty_width
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|duty_end
operator|>
literal|31
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"CLK_VAL field overflows P_CNT register\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|cpu_duty_offset
operator|<=
literal|4
operator|&&
name|duty_end
operator|>=
literal|4
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"CLK_VAL field overlaps THT_EN bit\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*      * If not present, fall back to using the processor's P_BLK to find      * the P_CNT register.      *      * Note that some systems seem to duplicate the P_BLK pointer      * across multiple CPUs, so not getting the resource is not fatal.      */
name|buf
operator|.
name|Pointer
operator|=
operator|&
name|obj
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
sizeof|sizeof
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|sc
operator|->
name|cpu_handle
argument_list|,
literal|"_PTC"
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|obj
operator|.
name|Buffer
operator|.
name|Length
operator|<
sizeof|sizeof
argument_list|(
name|ACPI_GENERIC_ADDRESS
argument_list|)
operator|+
literal|3
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"_PTC buffer too small\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|gas
argument_list|,
name|obj
operator|.
name|Buffer
operator|.
name|Pointer
operator|+
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|gas
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cpu_p_cnt
operator|=
name|acpi_bus_alloc_gas
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
operator|&
name|cpu_rid
argument_list|,
operator|&
name|gas
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cpu_p_cnt
operator|!=
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu%d: P_CNT from _PTC\n"
operator|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If _PTC not present or other failure, try the P_BLK. */
if|if
condition|(
name|sc
operator|->
name|cpu_p_cnt
operator|==
name|NULL
condition|)
block|{
comment|/*  	 * The spec says P_BLK must be 6 bytes long.  However, some 	 * systems use it to indicate a fractional set of features 	 * present so we take anything>= 4. 	 */
if|if
condition|(
name|sc
operator|->
name|cpu_p_blk_len
operator|<
literal|4
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|gas
operator|.
name|Address
operator|=
name|sc
operator|->
name|cpu_p_blk
expr_stmt|;
name|gas
operator|.
name|AddressSpaceId
operator|=
name|ACPI_ADR_SPACE_SYSTEM_IO
expr_stmt|;
name|gas
operator|.
name|RegisterBitWidth
operator|=
literal|32
expr_stmt|;
name|sc
operator|->
name|cpu_p_cnt
operator|=
name|acpi_bus_alloc_gas
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
operator|&
name|cpu_rid
argument_list|,
operator|&
name|gas
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cpu_p_cnt
operator|!=
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu%d: P_CNT from P_BLK\n"
operator|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"Failed to attach throttling P_CNT\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
name|cpu_rid
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_cx_probe
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ACPI_GENERIC_ADDRESS
name|gas
decl_stmt|;
name|struct
name|acpi_cx
modifier|*
name|cx_ptr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* Bus mastering arbitration control is needed for C3. */
if|if
condition|(
name|AcpiGbl_FADT
operator|->
name|V1_Pm2CntBlk
operator|==
literal|0
operator|||
name|AcpiGbl_FADT
operator|->
name|Pm2CntLen
operator|==
literal|0
condition|)
block|{
name|cpu_quirks
operator||=
name|CPU_QUIRK_NO_C3
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu%d: No BM control, C3 disabled\n"
operator|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * First, check for the ACPI 2.0 _CST sleep states object.      * If not usable, fall back to the P_BLK's P_LVL2 and P_LVL3.      */
name|sc
operator|->
name|cpu_cx_count
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|acpi_cpu_cx_cst
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cx_ptr
operator|=
name|sc
operator|->
name|cpu_cx_states
expr_stmt|;
comment|/* C1 has been required since just after ACPI 1.0 */
name|cx_ptr
operator|->
name|type
operator|=
name|ACPI_STATE_C1
expr_stmt|;
name|cx_ptr
operator|->
name|trans_lat
operator|=
literal|0
expr_stmt|;
name|cpu_non_c3
operator|=
literal|0
expr_stmt|;
name|cx_ptr
operator|++
expr_stmt|;
name|sc
operator|->
name|cpu_cx_count
operator|++
expr_stmt|;
comment|/*  	 * The spec says P_BLK must be 6 bytes long.  However, some systems 	 * use it to indicate a fractional set of features present so we 	 * take 5 as C2.  Some may also have a value of 7 to indicate 	 * another C3 but most use _CST for this (as required) and having 	 * "only" C1-C3 is not a hardship. 	 */
if|if
condition|(
name|sc
operator|->
name|cpu_p_blk_len
operator|<
literal|5
condition|)
goto|goto
name|done
goto|;
comment|/* Validate and allocate resources for C2 (P_LVL2). */
name|gas
operator|.
name|AddressSpaceId
operator|=
name|ACPI_ADR_SPACE_SYSTEM_IO
expr_stmt|;
name|gas
operator|.
name|RegisterBitWidth
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|AcpiGbl_FADT
operator|->
name|Plvl2Lat
operator|<=
literal|100
condition|)
block|{
name|gas
operator|.
name|Address
operator|=
name|sc
operator|->
name|cpu_p_blk
operator|+
literal|4
expr_stmt|;
name|cx_ptr
operator|->
name|p_lvlx
operator|=
name|acpi_bus_alloc_gas
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
operator|&
name|cpu_rid
argument_list|,
operator|&
name|gas
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx_ptr
operator|->
name|p_lvlx
operator|!=
name|NULL
condition|)
block|{
name|cpu_rid
operator|++
expr_stmt|;
name|cx_ptr
operator|->
name|type
operator|=
name|ACPI_STATE_C2
expr_stmt|;
name|cx_ptr
operator|->
name|trans_lat
operator|=
name|AcpiGbl_FADT
operator|->
name|Plvl2Lat
expr_stmt|;
name|cpu_non_c3
operator|=
literal|1
expr_stmt|;
name|cx_ptr
operator|++
expr_stmt|;
name|sc
operator|->
name|cpu_cx_count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|cpu_p_blk_len
operator|<
literal|6
condition|)
goto|goto
name|done
goto|;
comment|/* Validate and allocate resources for C3 (P_LVL3). */
if|if
condition|(
name|AcpiGbl_FADT
operator|->
name|Plvl3Lat
operator|<=
literal|1000
operator|&&
operator|(
name|cpu_quirks
operator|&
name|CPU_QUIRK_NO_C3
operator|)
operator|==
literal|0
condition|)
block|{
name|gas
operator|.
name|Address
operator|=
name|sc
operator|->
name|cpu_p_blk
operator|+
literal|5
expr_stmt|;
name|cx_ptr
operator|->
name|p_lvlx
operator|=
name|acpi_bus_alloc_gas
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
operator|&
name|cpu_rid
argument_list|,
operator|&
name|gas
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx_ptr
operator|->
name|p_lvlx
operator|!=
name|NULL
condition|)
block|{
name|cpu_rid
operator|++
expr_stmt|;
name|cx_ptr
operator|->
name|type
operator|=
name|ACPI_STATE_C3
expr_stmt|;
name|cx_ptr
operator|->
name|trans_lat
operator|=
name|AcpiGbl_FADT
operator|->
name|Plvl3Lat
expr_stmt|;
name|cx_ptr
operator|++
expr_stmt|;
name|sc
operator|->
name|cpu_cx_count
operator|++
expr_stmt|;
block|}
block|}
block|}
name|done
label|:
comment|/* If no valid registers were found, don't attach. */
if|if
condition|(
name|sc
operator|->
name|cpu_cx_count
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a _CST package and set up its Cx states.  Since the _CST object  * can change dynamically, our notify handler may call this function  * to clean up and probe the new _CST package.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_cpu_cx_cst
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|acpi_cx
modifier|*
name|cx_ptr
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|top
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|pkg
decl_stmt|;
name|uint32_t
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|sc
operator|->
name|cpu_handle
argument_list|,
literal|"_CST"
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* _CST is a package with a count and at least one Cx package. */
name|top
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|buf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
operator|!
name|ACPI_PKG_VALID
argument_list|(
name|top
argument_list|,
literal|2
argument_list|)
operator|||
name|acpi_PkgInt32
argument_list|(
name|top
argument_list|,
literal|0
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"Invalid _CST package\n"
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|count
operator|!=
name|top
operator|->
name|Package
operator|.
name|Count
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"Invalid _CST state count (%d != %d)\n"
argument_list|,
name|count
argument_list|,
name|top
operator|->
name|Package
operator|.
name|Count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
name|top
operator|->
name|Package
operator|.
name|Count
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
name|MAX_CX_STATES
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"_CST has too many states (%d)\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|count
operator|=
name|MAX_CX_STATES
expr_stmt|;
block|}
comment|/* Set up all valid states. */
name|sc
operator|->
name|cpu_cx_count
operator|=
literal|0
expr_stmt|;
name|cx_ptr
operator|=
name|sc
operator|->
name|cpu_cx_states
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pkg
operator|=
operator|&
name|top
operator|->
name|Package
operator|.
name|Elements
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ACPI_PKG_VALID
argument_list|(
name|pkg
argument_list|,
literal|4
argument_list|)
operator|||
name|acpi_PkgInt32
argument_list|(
name|pkg
argument_list|,
literal|1
argument_list|,
operator|&
name|cx_ptr
operator|->
name|type
argument_list|)
operator|!=
literal|0
operator|||
name|acpi_PkgInt32
argument_list|(
name|pkg
argument_list|,
literal|2
argument_list|,
operator|&
name|cx_ptr
operator|->
name|trans_lat
argument_list|)
operator|!=
literal|0
operator|||
name|acpi_PkgInt32
argument_list|(
name|pkg
argument_list|,
literal|3
argument_list|,
operator|&
name|cx_ptr
operator|->
name|power
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"Skipping invalid Cx state package\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Validate the state to see if we should use it. */
switch|switch
condition|(
name|cx_ptr
operator|->
name|type
condition|)
block|{
case|case
name|ACPI_STATE_C1
case|:
name|cpu_non_c3
operator|=
name|i
expr_stmt|;
name|cx_ptr
operator|++
expr_stmt|;
name|sc
operator|->
name|cpu_cx_count
operator|++
expr_stmt|;
continue|continue;
case|case
name|ACPI_STATE_C2
case|:
if|if
condition|(
name|cx_ptr
operator|->
name|trans_lat
operator|>
literal|100
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu%d: C2[%d] not available.\n"
operator|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cpu_non_c3
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|ACPI_STATE_C3
case|:
default|default:
if|if
condition|(
name|cx_ptr
operator|->
name|trans_lat
operator|>
literal|1000
operator|||
operator|(
name|cpu_quirks
operator|&
name|CPU_QUIRK_NO_C3
operator|)
operator|!=
literal|0
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu%d: C3[%d] not available.\n"
operator|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* Free up any previous register. */
if|if
condition|(
name|cx_ptr
operator|->
name|p_lvlx
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cx_ptr
operator|->
name|p_lvlx
argument_list|)
expr_stmt|;
name|cx_ptr
operator|->
name|p_lvlx
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Allocate the control register for C2 or C3. */
name|acpi_PkgGas
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
name|pkg
argument_list|,
literal|0
argument_list|,
operator|&
name|cpu_rid
argument_list|,
operator|&
name|cx_ptr
operator|->
name|p_lvlx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx_ptr
operator|->
name|p_lvlx
operator|!=
name|NULL
condition|)
block|{
name|cpu_rid
operator|++
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"acpi_cpu%d: Got C%d - %d latency\n"
operator|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
operator|,
name|cx_ptr
operator|->
name|type
operator|,
name|cx_ptr
operator|->
name|trans_lat
operator|)
argument_list|)
expr_stmt|;
name|cx_ptr
operator|++
expr_stmt|;
name|sc
operator|->
name|cpu_cx_count
operator|++
expr_stmt|;
block|}
block|}
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Call this *after* all CPUs have been attached.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_cpu_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
comment|/* Get set of CPU devices */
name|devclass_get_devices
argument_list|(
name|acpi_cpu_devclass
argument_list|,
operator|&
name|cpu_devices
argument_list|,
operator|&
name|cpu_ndevices
argument_list|)
expr_stmt|;
comment|/*      * Make sure all the processors' Cx counts match.  We should probably      * also check the contents of each.  However, no known systems have      * non-matching Cx counts so we'll deal with this later.      */
name|count
operator|=
name|MAX_CX_STATES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpu_ndevices
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
name|device_get_softc
argument_list|(
name|cpu_devices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|sc
operator|->
name|cpu_cx_count
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|cpu_cx_count
operator|=
name|count
expr_stmt|;
comment|/* Perform throttling and Cx final initialization. */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|cpu_devices
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cpu_p_cnt
operator|!=
name|NULL
condition|)
name|acpi_cpu_startup_throttling
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpu_cx_count
operator|>
literal|0
condition|)
name|acpi_cpu_startup_cx
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Takes the ACPI lock to avoid fighting anyone over the SMI command  * port.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_cpu_startup_throttling
parameter_list|()
block|{
name|ACPI_LOCK_DECL
expr_stmt|;
comment|/* Initialise throttling states */
name|cpu_throttle_max
operator|=
name|CPU_MAX_SPEED
expr_stmt|;
name|cpu_throttle_state
operator|=
name|CPU_MAX_SPEED
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|acpi_cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|acpi_cpu_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"throttle_max"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|cpu_throttle_max
argument_list|,
literal|0
argument_list|,
literal|"maximum CPU speed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|acpi_cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|acpi_cpu_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"throttle_state"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|cpu_throttle_state
argument_list|,
literal|0
argument_list|,
name|acpi_cpu_throttle_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"current CPU speed"
argument_list|)
expr_stmt|;
comment|/* If ACPI 2.0+, signal platform that we are taking over throttling. */
name|ACPI_LOCK
expr_stmt|;
if|if
condition|(
name|cpu_pstate_cnt
operator|!=
literal|0
condition|)
name|AcpiOsWritePort
argument_list|(
name|cpu_smi_cmd
argument_list|,
name|cpu_pstate_cnt
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Set initial speed to maximum. */
name|acpi_cpu_throttle_set
argument_list|(
name|cpu_throttle_max
argument_list|)
expr_stmt|;
name|ACPI_UNLOCK
expr_stmt|;
name|printf
argument_list|(
literal|"acpi_cpu: throttling enabled, %d steps (100%% to %d.%d%%), "
literal|"currently %d.%d%%\n"
argument_list|,
name|CPU_MAX_SPEED
argument_list|,
name|CPU_SPEED_PRINTABLE
argument_list|(
literal|1
argument_list|)
argument_list|,
name|CPU_SPEED_PRINTABLE
argument_list|(
name|cpu_throttle_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_cpu_startup_cx
parameter_list|()
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ACPI_LOCK_DECL
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|cpu_devices
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|cpu_cx_supported
argument_list|,
sizeof|sizeof
argument_list|(
name|cpu_cx_supported
argument_list|)
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpu_cx_count
condition|;
name|i
operator|++
control|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"C%d/%d "
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|sc
operator|->
name|cpu_cx_states
index|[
name|i
index|]
operator|.
name|trans_lat
argument_list|)
expr_stmt|;
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
operator|&
name|acpi_cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|acpi_cpu_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cx_supported"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|cpu_cx_supported
argument_list|,
literal|0
argument_list|,
literal|"Cx/microsecond values for supported Cx states"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|acpi_cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|acpi_cpu_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cx_lowest"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|acpi_cpu_cx_lowest_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"lowest Cx sleep state to use"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|acpi_cpu_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|acpi_cpu_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cx_history"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|acpi_cpu_history_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"count of full sleeps for Cx state / short sleeps"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* Signal platform that we can handle _CST notification. */
if|if
condition|(
name|cpu_cst_cnt
operator|!=
literal|0
condition|)
block|{
name|ACPI_LOCK
expr_stmt|;
name|AcpiOsWritePort
argument_list|(
name|cpu_smi_cmd
argument_list|,
name|cpu_cst_cnt
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ACPI_UNLOCK
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Take over idling from cpu_idle_default(). */
name|cpu_cx_next
operator|=
name|cpu_cx_lowest
expr_stmt|;
name|cpu_idle_hook
operator|=
name|acpi_cpu_idle
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set CPUs to the new state.  *  * Must be called with the ACPI lock held.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_cpu_throttle_set
parameter_list|(
name|uint32_t
name|speed
parameter_list|)
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|p_cnt
decl_stmt|,
name|clk_val
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
comment|/* Iterate over processors */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpu_ndevices
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
name|device_get_softc
argument_list|(
name|cpu_devices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cpu_p_cnt
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Get the current P_CNT value and disable throttling */
name|p_cnt
operator|=
name|CPU_GET_REG
argument_list|(
name|sc
operator|->
name|cpu_p_cnt
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p_cnt
operator|&=
operator|~
name|CPU_P_CNT_THT_EN
expr_stmt|;
name|CPU_SET_REG
argument_list|(
name|sc
operator|->
name|cpu_p_cnt
argument_list|,
literal|4
argument_list|,
name|p_cnt
argument_list|)
expr_stmt|;
comment|/* If we're at maximum speed, that's all */
if|if
condition|(
name|speed
operator|<
name|CPU_MAX_SPEED
condition|)
block|{
comment|/* Mask the old CLK_VAL off and or-in the new value */
name|clk_val
operator|=
operator|(
name|CPU_MAX_SPEED
operator|-
literal|1
operator|)
operator|<<
name|cpu_duty_offset
expr_stmt|;
name|p_cnt
operator|&=
operator|~
name|clk_val
expr_stmt|;
name|p_cnt
operator||=
operator|(
name|speed
operator|<<
name|cpu_duty_offset
operator|)
expr_stmt|;
comment|/* Write the new P_CNT value and then enable throttling */
name|CPU_SET_REG
argument_list|(
name|sc
operator|->
name|cpu_p_cnt
argument_list|,
literal|4
argument_list|,
name|p_cnt
argument_list|)
expr_stmt|;
name|p_cnt
operator||=
name|CPU_P_CNT_THT_EN
expr_stmt|;
name|CPU_SET_REG
argument_list|(
name|sc
operator|->
name|cpu_p_cnt
argument_list|,
literal|4
argument_list|,
name|p_cnt
argument_list|)
expr_stmt|;
block|}
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|)
argument_list|,
literal|"set speed to %d.%d%%\n"
argument_list|,
name|CPU_SPEED_PRINTABLE
argument_list|(
name|speed
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cpu_throttle_state
operator|=
name|speed
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Idle the CPU in the lowest state possible.  * This function is called with interrupts disabled.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_cpu_idle
parameter_list|()
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|acpi_cx
modifier|*
name|cx_next
decl_stmt|;
name|uint32_t
name|start_time
decl_stmt|,
name|end_time
decl_stmt|;
name|int
name|bm_active
decl_stmt|,
name|i
decl_stmt|,
name|asleep
decl_stmt|;
comment|/* If disabled, return immediately. */
if|if
condition|(
name|cpu_cx_count
operator|==
literal|0
condition|)
block|{
name|ACPI_ENABLE_IRQS
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/*      * Look up our CPU id to get our softc.  If it's NULL, we'll use C1      * since there is no ACPI processor object for this CPU.  This occurs      * for logical CPUs in the HTT case.      */
name|sc
operator|=
name|cpu_softc
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|acpi_cpu_c1
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Record that a CPU is in the idle function. */
name|atomic_add_int
argument_list|(
operator|&
name|cpu_idle_busy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Check for bus master activity.  If there was activity, clear      * the bit and use the lowest non-C3 state.  Note that the USB      * driver polling for new devices keeps this bit set all the      * time if USB is enabled.      */
name|AcpiGetRegister
argument_list|(
name|ACPI_BITREG_BUS_MASTER_STATUS
argument_list|,
operator|&
name|bm_active
argument_list|,
name|ACPI_MTX_DO_NOT_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|bm_active
operator|!=
literal|0
condition|)
block|{
name|AcpiSetRegister
argument_list|(
name|ACPI_BITREG_BUS_MASTER_STATUS
argument_list|,
literal|1
argument_list|,
name|ACPI_MTX_DO_NOT_LOCK
argument_list|)
expr_stmt|;
name|cpu_cx_next
operator|=
name|min
argument_list|(
name|cpu_cx_next
argument_list|,
name|cpu_non_c3
argument_list|)
expr_stmt|;
block|}
comment|/* Perform the actual sleep based on the Cx-specific semantics. */
name|cx_next
operator|=
operator|&
name|sc
operator|->
name|cpu_cx_states
index|[
name|cpu_cx_next
index|]
expr_stmt|;
switch|switch
condition|(
name|cx_next
operator|->
name|type
condition|)
block|{
case|case
name|ACPI_STATE_C0
case|:
name|panic
argument_list|(
literal|"acpi_cpu_idle: attempting to sleep in C0"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|ACPI_STATE_C1
case|:
comment|/* Execute HLT (or equivalent) and wait for an interrupt. */
name|acpi_cpu_c1
argument_list|()
expr_stmt|;
comment|/* 	 * We can't calculate the time spent in C1 since the place we 	 * wake up is an ISR.  Use a constant time of 1 ms. 	 */
name|start_time
operator|=
literal|0
expr_stmt|;
name|end_time
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
name|ACPI_STATE_C2
case|:
comment|/* 	 * Read from P_LVLx to enter C2, checking time spent asleep. 	 * Use the ACPI timer for measuring sleep time.  Since we need to 	 * get the time very close to the CPU start/stop clock logic, this 	 * is the only reliable time source. 	 */
name|AcpiHwLowLevelRead
argument_list|(
literal|32
argument_list|,
operator|&
name|start_time
argument_list|,
operator|&
name|AcpiGbl_FADT
operator|->
name|XPmTmrBlk
argument_list|)
expr_stmt|;
name|CPU_GET_REG
argument_list|(
name|cx_next
operator|->
name|p_lvlx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Read the end time twice.  Since it may take an arbitrary time 	 * to enter the idle state, the first read may be executed before 	 * the processor has stopped.  Doing it again provides enough 	 * margin that we are certain to have a correct value. 	 */
name|AcpiHwLowLevelRead
argument_list|(
literal|32
argument_list|,
operator|&
name|end_time
argument_list|,
operator|&
name|AcpiGbl_FADT
operator|->
name|XPmTmrBlk
argument_list|)
expr_stmt|;
name|AcpiHwLowLevelRead
argument_list|(
literal|32
argument_list|,
operator|&
name|end_time
argument_list|,
operator|&
name|AcpiGbl_FADT
operator|->
name|XPmTmrBlk
argument_list|)
expr_stmt|;
name|ACPI_ENABLE_IRQS
argument_list|()
expr_stmt|;
break|break;
case|case
name|ACPI_STATE_C3
case|:
default|default:
comment|/* Disable bus master arbitration and enable bus master wakeup. */
name|AcpiSetRegister
argument_list|(
name|ACPI_BITREG_ARB_DISABLE
argument_list|,
literal|1
argument_list|,
name|ACPI_MTX_DO_NOT_LOCK
argument_list|)
expr_stmt|;
name|AcpiSetRegister
argument_list|(
name|ACPI_BITREG_BUS_MASTER_RLD
argument_list|,
literal|1
argument_list|,
name|ACPI_MTX_DO_NOT_LOCK
argument_list|)
expr_stmt|;
comment|/* Read from P_LVLx to enter C3, checking time spent asleep. */
name|AcpiHwLowLevelRead
argument_list|(
literal|32
argument_list|,
operator|&
name|start_time
argument_list|,
operator|&
name|AcpiGbl_FADT
operator|->
name|XPmTmrBlk
argument_list|)
expr_stmt|;
name|CPU_GET_REG
argument_list|(
name|cx_next
operator|->
name|p_lvlx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Read the end time twice.  See comment for C2 above. */
name|AcpiHwLowLevelRead
argument_list|(
literal|32
argument_list|,
operator|&
name|end_time
argument_list|,
operator|&
name|AcpiGbl_FADT
operator|->
name|XPmTmrBlk
argument_list|)
expr_stmt|;
name|AcpiHwLowLevelRead
argument_list|(
literal|32
argument_list|,
operator|&
name|end_time
argument_list|,
operator|&
name|AcpiGbl_FADT
operator|->
name|XPmTmrBlk
argument_list|)
expr_stmt|;
comment|/* Enable bus master arbitration and disable bus master wakeup. */
name|AcpiSetRegister
argument_list|(
name|ACPI_BITREG_ARB_DISABLE
argument_list|,
literal|0
argument_list|,
name|ACPI_MTX_DO_NOT_LOCK
argument_list|)
expr_stmt|;
name|AcpiSetRegister
argument_list|(
name|ACPI_BITREG_BUS_MASTER_RLD
argument_list|,
literal|0
argument_list|,
name|ACPI_MTX_DO_NOT_LOCK
argument_list|)
expr_stmt|;
name|ACPI_ENABLE_IRQS
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* Find the actual time asleep in microseconds, minus overhead. */
name|end_time
operator|=
name|acpi_TimerDelta
argument_list|(
name|end_time
argument_list|,
name|start_time
argument_list|)
expr_stmt|;
name|asleep
operator|=
name|PM_USEC
argument_list|(
name|end_time
argument_list|)
operator|-
name|cx_next
operator|->
name|trans_lat
expr_stmt|;
comment|/* Record statistics */
if|if
condition|(
name|asleep
operator|<
name|cx_next
operator|->
name|trans_lat
condition|)
name|cpu_cx_stats
index|[
name|cpu_cx_next
index|]
operator|.
name|short_slp
operator|++
expr_stmt|;
else|else
name|cpu_cx_stats
index|[
name|cpu_cx_next
index|]
operator|.
name|long_slp
operator|++
expr_stmt|;
comment|/*      * If we slept 100 us or more, use the lowest Cx state.      * Otherwise, find the lowest state that has a latency less than      * or equal to the length of our last sleep.      */
if|if
condition|(
name|asleep
operator|>=
literal|100
condition|)
name|cpu_cx_next
operator|=
name|cpu_cx_lowest
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
name|cpu_cx_lowest
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|cpu_cx_states
index|[
name|i
index|]
operator|.
name|trans_lat
operator|<=
name|asleep
condition|)
block|{
name|cpu_cx_next
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Decrement reference count checked by acpi_cpu_shutdown(). */
name|atomic_subtract_int
argument_list|(
operator|&
name|cpu_idle_busy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put the CPU in C1 in a machine-dependant way. */
end_comment

begin_function
specifier|static
name|void
name|acpi_cpu_c1
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|__ia64__
name|ia64_call_pal_static
argument_list|(
name|PAL_HALT_LIGHT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
asm|__asm __volatile("sti; hlt");
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Re-evaluate the _PSS and _CST objects when we are notified that they  * have changed.  *  * XXX Re-evaluation disabled until locking is done.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_cpu_notify
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
name|UINT32
name|notify
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_cpu_softc
operator|*
operator|)
name|context
decl_stmt|;
switch|switch
condition|(
name|notify
condition|)
block|{
case|case
name|ACPI_CPU_NOTIFY_PERF_STATES
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"Performance states changed\n"
argument_list|)
expr_stmt|;
comment|/* acpi_cpu_px_available(sc); */
break|break;
case|case
name|ACPI_CPU_NOTIFY_CX_STATES
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"Cx states changed\n"
argument_list|)
expr_stmt|;
comment|/* acpi_cpu_cx_cst(sc); */
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|cpu_dev
argument_list|,
literal|"Unknown notify %#x\n"
argument_list|,
name|notify
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_quirks
parameter_list|(
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/*      * C3 is not supported on multiple CPUs since this would require      * flushing all caches which is currently too expensive.      */
if|if
condition|(
name|mp_ncpus
operator|>
literal|1
condition|)
name|cpu_quirks
operator||=
name|CPU_QUIRK_NO_C3
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* Look for various quirks of the PIIX4 part. */
name|acpi_dev
operator|=
name|pci_find_device
argument_list|(
name|PCI_VENDOR_INTEL
argument_list|,
name|PCI_DEVICE_82371AB_3
argument_list|)
expr_stmt|;
if|if
condition|(
name|acpi_dev
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|pci_get_revid
argument_list|(
name|acpi_dev
argument_list|)
condition|)
block|{
comment|/* 	 * Disable throttling control on PIIX4 A and B-step. 	 * See specification changes #13 ("Manual Throttle Duty Cycle") 	 * and #14 ("Enabling and Disabling Manual Throttle"), plus 	 * erratum #5 ("STPCLK# Deassertion Time") from the January 	 * 2002 PIIX4 specification update.  Note that few (if any) 	 * mobile systems ever used this part. 	 */
case|case
name|PCI_REVISION_A_STEP
case|:
case|case
name|PCI_REVISION_B_STEP
case|:
name|cpu_quirks
operator||=
name|CPU_QUIRK_NO_THROTTLE
expr_stmt|;
comment|/* FALLTHROUGH */
comment|/* 	 * Disable C3 support for all PIIX4 chipsets.  Some of these parts 	 * do not report the BMIDE status to the BM status register and 	 * others have a livelock bug if Type-F DMA is enabled.  Linux 	 * works around the BMIDE bug by reading the BM status directly 	 * but we take the simpler approach of disabling C3 for these 	 * parts. 	 * 	 * See erratum #18 ("C3 Power State/BMIDE and Type-F DMA 	 * Livelock") from the January 2002 PIIX4 specification update. 	 * Applies to all PIIX4 models. 	 */
case|case
name|PCI_REVISION_4E
case|:
case|case
name|PCI_REVISION_4M
case|:
name|cpu_quirks
operator||=
name|CPU_QUIRK_NO_C3
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle changes in the CPU throttling setting. */
end_comment

begin_function
specifier|static
name|int
name|acpi_cpu_throttle_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uint32_t
modifier|*
name|argp
decl_stmt|;
name|uint32_t
name|arg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ACPI_LOCK_DECL
expr_stmt|;
name|argp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|arg
operator|=
operator|*
name|argp
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* Error or no new value */
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|arg
operator|<
literal|1
operator|||
name|arg
operator|>
name|cpu_throttle_max
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* If throttling changed, notify the BIOS of the new rate. */
name|ACPI_LOCK
expr_stmt|;
if|if
condition|(
operator|*
name|argp
operator|!=
name|arg
condition|)
block|{
operator|*
name|argp
operator|=
name|arg
expr_stmt|;
name|acpi_cpu_throttle_set
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
name|ACPI_UNLOCK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_history_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sbuf
name|sb
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpu_cx_count
condition|;
name|i
operator|++
control|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%u/%u "
argument_list|,
name|cpu_cx_stats
index|[
name|i
index|]
operator|.
name|long_slp
argument_list|,
name|cpu_cx_stats
index|[
name|i
index|]
operator|.
name|short_slp
argument_list|)
expr_stmt|;
block|}
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_cpu_cx_lowest_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|acpi_cpu_softc
modifier|*
name|sc
decl_stmt|;
name|char
name|state
index|[
literal|8
index|]
decl_stmt|;
name|int
name|val
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|cpu_devices
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|,
literal|"C%d"
argument_list|,
name|cpu_cx_lowest
operator|+
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|strlen
argument_list|(
name|state
argument_list|)
operator|<
literal|2
operator|||
name|toupper
argument_list|(
name|state
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|'C'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|val
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|state
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
name|cpu_cx_count
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Use the new value for the next idle slice. */
name|cpu_cx_lowest
operator|=
name|val
expr_stmt|;
name|cpu_cx_next
operator|=
name|val
expr_stmt|;
comment|/* If not disabling, cache the new lowest non-C3 state. */
name|cpu_non_c3
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cpu_cx_lowest
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|cpu_cx_states
index|[
name|i
index|]
operator|.
name|type
operator|<
name|ACPI_STATE_C3
condition|)
block|{
name|cpu_non_c3
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* Reset the statistics counters. */
name|memset
argument_list|(
name|cpu_cx_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cpu_cx_stats
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

