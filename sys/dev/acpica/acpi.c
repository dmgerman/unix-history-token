begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Takanori Watanabe<takawata@jp.freebsd.org>  * Copyright (c) 2000 Mitsuru IWASAKI<iwasaki@jp.freebsd.org>  * Copyright (c) 2000, 2001 Michael Smith  * Copyright (c) 2000 BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/power.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<isa/pnpvar.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/acpi.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpiio.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/achware.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/acnamesp.h>
end_include

begin_include
include|#
directive|include
file|"pci_if.h"
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ACPIDEV
argument_list|,
literal|"acpidev"
argument_list|,
literal|"ACPI devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Hooks for the ACPI CA debugging infrastructure */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_BUS
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"ACPI"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|d_open_t
name|acpiopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|acpiclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|acpiioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|acpi_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|acpiopen
block|,
operator|.
name|d_close
operator|=
name|acpiclose
block|,
operator|.
name|d_ioctl
operator|=
name|acpiioctl
block|,
operator|.
name|d_name
operator|=
literal|"acpi"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global mutex for locking access to the ACPI subsystem. */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|acpi_mutex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bitmap of device quirks. */
end_comment

begin_decl_stmt
name|int
name|acpi_quirks
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|acpi_modevent
parameter_list|(
name|struct
name|module
modifier|*
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|junk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|device_t
name|acpi_add_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|int
name|order
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_print_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_probe_nomatch
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_driver_added
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|driver_t
modifier|*
name|driver
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|resource_list
modifier|*
name|acpi_get_rlist
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_sysres_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|resource_list_entry
modifier|*
name|acpi_sysres_find
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|type
parameter_list|,
name|u_long
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|resource
modifier|*
name|acpi_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_release_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_delete_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|acpi_isa_get_logicalid
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_isa_get_compatid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
modifier|*
name|cids
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|acpi_device_id_probe
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|char
modifier|*
modifier|*
name|ids
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_device_eval_obj
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|ACPI_STRING
name|pathname
parameter_list|,
name|ACPI_OBJECT_LIST
modifier|*
name|parameters
parameter_list|,
name|ACPI_BUFFER
modifier|*
name|ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_device_pwr_for_sleep
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|dstate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_device_scan_cb
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
modifier|*
name|retval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_device_scan_children
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|max_depth
parameter_list|,
name|acpi_scan_cb_t
name|user_fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_set_powerstate_method
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_isa_pnp_probe
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|isa_pnp_id
modifier|*
name|ids
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_probe_children
parameter_list|(
name|device_t
name|bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_probe_order
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|int
modifier|*
name|order
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_probe_child
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOLEAN
name|acpi_MatchHid
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|hid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_shutdown_final
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_enable_fixed_events
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_wake_sleep_prep
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|int
name|sstate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_wake_run_prep
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|int
name|sstate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_wake_prep_walk
parameter_list|(
name|int
name|sstate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_wake_sysctl_walk
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_wake_set_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_system_eventhandler_sleep
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_system_eventhandler_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_supported_sleep_state_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_sleep_state_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_pm_func
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_child_location_str_method
parameter_list|(
name|device_t
name|acdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_child_pnpinfo_str_method
parameter_list|(
name|device_t
name|acdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|acpi_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|acpi_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|acpi_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|acpi_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|acpi_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|acpi_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|acpi_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_add_child
argument_list|,
name|acpi_add_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|acpi_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_probe_nomatch
argument_list|,
name|acpi_probe_nomatch
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|acpi_driver_added
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|acpi_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|acpi_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource_list
argument_list|,
name|acpi_get_rlist
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_set_resource
argument_list|,
name|bus_generic_rl_set_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource
argument_list|,
name|bus_generic_rl_get_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|acpi_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|acpi_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_delete_resource
argument_list|,
name|acpi_delete_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_pnpinfo_str
argument_list|,
name|acpi_child_pnpinfo_str_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|acpi_child_location_str_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bus_generic_teardown_intr
argument_list|)
block|,
comment|/* ACPI bus */
name|DEVMETHOD
argument_list|(
name|acpi_id_probe
argument_list|,
name|acpi_device_id_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|acpi_evaluate_object
argument_list|,
name|acpi_device_eval_obj
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|acpi_pwr_for_sleep
argument_list|,
name|acpi_device_pwr_for_sleep
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|acpi_scan_children
argument_list|,
name|acpi_device_scan_children
argument_list|)
block|,
comment|/* PCI emulation */
name|DEVMETHOD
argument_list|(
name|pci_set_powerstate
argument_list|,
name|acpi_set_powerstate_method
argument_list|)
block|,
comment|/* ISA emulation */
name|DEVMETHOD
argument_list|(
name|isa_pnp_probe
argument_list|,
name|acpi_isa_pnp_probe
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|acpi_driver
init|=
block|{
literal|"acpi"
block|,
name|acpi_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|acpi_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|acpi
argument_list|,
name|nexus
argument_list|,
name|acpi_driver
argument_list|,
name|acpi_devclass
argument_list|,
name|acpi_modevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|acpi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ACPI_SERIAL_DECL
argument_list|(
name|acpi
argument_list|,
literal|"ACPI root bus"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Local pools for managing system resources for ACPI child devices. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rman
name|acpi_rman_io
decl_stmt|,
name|acpi_rman_mem
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ACPI_MINIMUM_AWAKETIME
value|5
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sleep_state_names
index|[]
init|=
block|{
literal|"S0"
block|,
literal|"S1"
block|,
literal|"S2"
block|,
literal|"S3"
block|,
literal|"S4"
block|,
literal|"S5"
block|,
literal|"NONE"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|acpi
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"ACPI debugging"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
name|acpi_ca_version
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_debug_acpi
argument_list|,
name|OID_AUTO
argument_list|,
name|acpi_ca_version
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|acpi_ca_version
argument_list|,
literal|0
argument_list|,
literal|"Version of Intel ACPI-CA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Allow override of whether methods execute in parallel or not.  * Enable this for serial behavior, which fixes "AE_ALREADY_EXISTS"  * errors for AML that really can't handle parallel method execution.  * It is off by default since this breaks recursive methods and  * some IBMs use such code.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|acpi_serialize_methods
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.acpi.serialize_methods"
argument_list|,
operator|&
name|acpi_serialize_methods
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Power devices off and on in suspend and resume.  XXX Remove once tested. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|acpi_do_powerstate
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.acpi.do_powerstate"
argument_list|,
operator|&
name|acpi_do_powerstate
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_acpi
argument_list|,
name|OID_AUTO
argument_list|,
name|do_powerstate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|acpi_do_powerstate
argument_list|,
literal|1
argument_list|,
literal|"Turn off devices when suspending."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Allow users to override quirks. */
end_comment

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.acpi.quirks"
argument_list|,
operator|&
name|acpi_quirks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ACPI can only be loaded as a module by the loader; activating it after  * system bootstrap time is not useful, and can be fatal to the system.  * It also cannot be unloaded, since the entire system bus heirarchy hangs  * off it.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_modevent
parameter_list|(
name|struct
name|module
modifier|*
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|junk
parameter_list|)
block|{
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
operator|!
name|cold
condition|)
block|{
name|printf
argument_list|(
literal|"The ACPI driver cannot be loaded after boot.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
break|break;
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
operator|!
name|cold
operator|&&
name|power_pm_get_type
argument_list|()
operator|==
name|POWER_PM_TYPE_ACPI
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform early initialization.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_Startup
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|started
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|,
name|val
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* Only run the startup code once.  The MADT driver also calls this. */
if|if
condition|(
name|started
condition|)
name|return_VALUE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|started
operator|=
literal|1
expr_stmt|;
comment|/* Initialise the ACPI mutex */
name|mtx_init
argument_list|(
operator|&
name|acpi_mutex
argument_list|,
literal|"ACPI global lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/*      * Set the globals from our tunables.  This is needed because ACPI-CA      * uses UINT8 for some values and we have no tunable_byte.      */
name|AcpiGbl_AllMethodsSerialized
operator|=
name|acpi_serialize_methods
expr_stmt|;
name|AcpiGbl_EnableInterpreterSlack
operator|=
name|TRUE
expr_stmt|;
comment|/* Start up the ACPI CA subsystem. */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
operator|=
name|AcpiInitializeSubsystem
argument_list|()
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI: initialisation failed: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
operator|=
name|AcpiLoadTables
argument_list|()
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI: table load failed: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|AcpiTerminate
argument_list|()
expr_stmt|;
name|return_VALUE
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Set up any quirks we have for this system. */
if|if
condition|(
name|acpi_quirks
operator|==
literal|0
condition|)
name|acpi_table_quirks
argument_list|(
operator|&
name|acpi_quirks
argument_list|)
expr_stmt|;
comment|/* If the user manually set the disabled hint to 0, force-enable ACPI. */
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"acpi"
argument_list|,
literal|0
argument_list|,
literal|"disabled"
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|&&
name|val
operator|==
literal|0
condition|)
name|acpi_quirks
operator|&=
operator|~
name|ACPI_Q_BROKEN
expr_stmt|;
if|if
condition|(
name|acpi_quirks
operator|&
name|ACPI_Q_BROKEN
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI disabled by blacklist.  Contact your BIOS vendor.\n"
argument_list|)
expr_stmt|;
name|AcpiTerminate
argument_list|()
expr_stmt|;
name|return_VALUE
argument_list|(
name|AE_ERROR
argument_list|)
expr_stmt|;
block|}
name|return_VALUE
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Detect ACPI, perform early initialisation  */
end_comment

begin_function
specifier|static
name|void
name|acpi_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cold
condition|)
name|return_VOID
expr_stmt|;
comment|/* Check that we haven't been disabled with a hint. */
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"acpi"
argument_list|,
literal|0
argument_list|)
condition|)
name|return_VOID
expr_stmt|;
comment|/* Make sure we're not being doubly invoked. */
if|if
condition|(
name|device_find_child
argument_list|(
name|parent
argument_list|,
literal|"acpi"
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL
condition|)
name|return_VOID
expr_stmt|;
comment|/* Initialize ACPI-CA. */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|acpi_Startup
argument_list|()
argument_list|)
condition|)
name|return_VOID
expr_stmt|;
name|snprintf
argument_list|(
name|acpi_ca_version
argument_list|,
sizeof|sizeof
argument_list|(
name|acpi_ca_version
argument_list|)
argument_list|,
literal|"%x"
argument_list|,
name|ACPI_CA_VERSION
argument_list|)
expr_stmt|;
comment|/* Attach the actual ACPI device. */
if|if
condition|(
operator|(
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"acpi"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"device_identify failed\n"
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Fetch some descriptive data from ACPI to put in our attach message.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_TABLE_HEADER
name|th
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_pm_get_type
argument_list|()
operator|!=
name|POWER_PM_TYPE_NONE
operator|&&
name|power_pm_get_type
argument_list|()
operator|!=
name|POWER_PM_TYPE_ACPI
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"probe failed, other PM system enabled.\n"
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiGetTableHeader
argument_list|(
name|ACPI_TABLE_XSDT
argument_list|,
literal|1
argument_list|,
operator|&
name|th
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't get XSDT header: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
else|else
block|{
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
operator|&
name|sb
argument_list|,
name|th
operator|.
name|OemId
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_putc
argument_list|(
operator|&
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
operator|&
name|sb
argument_list|,
name|th
operator|.
name|OemTableId
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|return_VALUE
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|error
decl_stmt|,
name|state
decl_stmt|;
name|UINT32
name|flags
decl_stmt|;
name|UINT8
name|TypeA
decl_stmt|,
name|TypeB
decl_stmt|;
name|char
modifier|*
name|env
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_dev
operator|=
name|dev
expr_stmt|;
comment|/* Initialize resource manager. */
name|acpi_rman_io
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|acpi_rman_io
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|acpi_rman_io
operator|.
name|rm_end
operator|=
literal|0xffff
expr_stmt|;
name|acpi_rman_io
operator|.
name|rm_descr
operator|=
literal|"ACPI I/O ports"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|acpi_rman_io
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"acpi rman_init IO ports failed"
argument_list|)
expr_stmt|;
name|acpi_rman_mem
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|acpi_rman_mem
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|acpi_rman_mem
operator|.
name|rm_end
operator|=
operator|~
literal|0ul
expr_stmt|;
name|acpi_rman_mem
operator|.
name|rm_descr
operator|=
literal|"ACPI I/O memory addresses"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|acpi_rman_mem
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"acpi rman_init memory failed"
argument_list|)
expr_stmt|;
comment|/* Install the default address space handlers. */
name|error
operator|=
name|ENXIO
expr_stmt|;
name|status
operator|=
name|AcpiInstallAddressSpaceHandler
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_ADR_SPACE_SYSTEM_MEMORY
argument_list|,
name|ACPI_DEFAULT_HANDLER
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not initialise SystemMemory handler: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|status
operator|=
name|AcpiInstallAddressSpaceHandler
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_ADR_SPACE_SYSTEM_IO
argument_list|,
name|ACPI_DEFAULT_HANDLER
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not initialise SystemIO handler: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|status
operator|=
name|AcpiInstallAddressSpaceHandler
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_ADR_SPACE_PCI_CONFIG
argument_list|,
name|ACPI_DEFAULT_HANDLER
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not initialise PciConfig handler: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Note that some systems (specifically, those with namespace evaluation      * issues that require the avoidance of parts of the namespace) must      * avoid running _INI and _STA on everything, as well as dodging the final      * object init pass.      *      * For these devices, we set ACPI_NO_DEVICE_INIT and ACPI_NO_OBJECT_INIT).      *      * XXX We should arrange for the object init pass after we have attached      *     all our child devices, but on many systems it works here.      */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|testenv
argument_list|(
literal|"debug.acpi.avoid"
argument_list|)
condition|)
name|flags
operator|=
name|ACPI_NO_DEVICE_INIT
operator||
name|ACPI_NO_OBJECT_INIT
expr_stmt|;
comment|/* Bring the hardware and basic handlers online. */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiEnableSubsystem
argument_list|(
name|flags
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not enable ACPI: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Call the ECDT probe function to provide EC functionality before      * the namespace has been evaluated.      *      * XXX This happens before the sysresource devices have been probed and      * attached so its resources come from nexus0.  In practice, this isn't      * a problem but should be addressed eventually.      */
name|acpi_ec_ecdt_probe
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Bring device objects and regions online. */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiInitializeObjects
argument_list|(
name|flags
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not initialize ACPI objects: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Setup our sysctl tree.      *      * XXX: This doesn't check to make sure that none of these fail.      */
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"supported_sleep_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|acpi_supported_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"power_button_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_power_button_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sleep_button_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_sleep_button_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lid_switch_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_lid_switch_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"standby_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_standby_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"suspend_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_suspend_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sleep_delay"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_sleep_delay
argument_list|,
literal|0
argument_list|,
literal|"sleep delay"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"s4bios"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_s4bios
argument_list|,
literal|0
argument_list|,
literal|"S4BIOS mode"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"verbose"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_verbose
argument_list|,
literal|0
argument_list|,
literal|"verbose mode"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"disable_on_reboot"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_do_disable
argument_list|,
literal|0
argument_list|,
literal|"Disable ACPI when rebooting/halting system"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"handle_reboot"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_handle_reboot
argument_list|,
literal|0
argument_list|,
literal|"Use ACPI Reset Register to reboot"
argument_list|)
expr_stmt|;
comment|/*      * Default to 1 second before sleeping to give some machines time to      * stabilize.      */
name|sc
operator|->
name|acpi_sleep_delay
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|sc
operator|->
name|acpi_verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|env
operator|=
name|getenv
argument_list|(
literal|"hw.acpi.verbose"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|env
argument_list|,
literal|"0"
argument_list|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|acpi_verbose
operator|=
literal|1
expr_stmt|;
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
comment|/* Only enable S4BIOS by default if the FACS says it is available. */
if|if
condition|(
name|AcpiGbl_FACS
operator|->
name|S4Bios_f
operator|!=
literal|0
condition|)
name|sc
operator|->
name|acpi_s4bios
operator|=
literal|1
expr_stmt|;
comment|/*      * Dispatch the default sleep state to devices.  The lid switch is set      * to NONE by default to avoid surprising users.      */
name|sc
operator|->
name|acpi_power_button_sx
operator|=
name|ACPI_STATE_S5
expr_stmt|;
name|sc
operator|->
name|acpi_lid_switch_sx
operator|=
name|ACPI_S_STATES_MAX
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|acpi_standby_sx
operator|=
name|ACPI_STATE_S1
expr_stmt|;
name|sc
operator|->
name|acpi_suspend_sx
operator|=
name|ACPI_STATE_S3
expr_stmt|;
comment|/* Pick the first valid sleep state for the sleep button default. */
name|sc
operator|->
name|acpi_sleep_button_sx
operator|=
name|ACPI_S_STATES_MAX
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|state
operator|=
name|ACPI_STATE_S1
init|;
name|state
operator|<
name|ACPI_STATE_S5
condition|;
name|state
operator|++
control|)
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetSleepTypeData
argument_list|(
name|state
argument_list|,
operator|&
name|TypeA
argument_list|,
operator|&
name|TypeB
argument_list|)
argument_list|)
condition|)
block|{
name|sc
operator|->
name|acpi_sleep_button_sx
operator|=
name|state
expr_stmt|;
break|break;
block|}
name|acpi_enable_fixed_events
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Scan the namespace and attach/initialise children.      */
comment|/* Register our shutdown handler. */
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|acpi_shutdown_final
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_LAST
argument_list|)
expr_stmt|;
comment|/*      * Register our acpi event handlers.      * XXX should be configurable eg. via userland policy manager.      */
name|EVENTHANDLER_REGISTER
argument_list|(
name|acpi_sleep_event
argument_list|,
name|acpi_system_eventhandler_sleep
argument_list|,
name|sc
argument_list|,
name|ACPI_EVENT_PRI_LAST
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|acpi_wakeup_event
argument_list|,
name|acpi_system_eventhandler_wakeup
argument_list|,
name|sc
argument_list|,
name|ACPI_EVENT_PRI_LAST
argument_list|)
expr_stmt|;
comment|/* Flag our initial states. */
name|sc
operator|->
name|acpi_enabled
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|acpi_sstate
operator|=
name|ACPI_STATE_S0
expr_stmt|;
name|sc
operator|->
name|acpi_sleep_disabled
operator|=
literal|0
expr_stmt|;
comment|/* Create the control device */
name|sc
operator|->
name|acpi_dev_t
operator|=
name|make_dev
argument_list|(
operator|&
name|acpi_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0644
argument_list|,
literal|"acpi"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_dev_t
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|acpi_machdep_init
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* Register ACPI again to pass the correct argument of pm_func. */
name|power_pm_register
argument_list|(
name|POWER_PM_TYPE_ACPI
argument_list|,
name|acpi_pm_func
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acpi_disabled
argument_list|(
literal|"bus"
argument_list|)
condition|)
name|acpi_probe_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|return_VALUE
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|,
modifier|*
name|devlist
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|numdevs
decl_stmt|,
name|pstate
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/* First give child devices a chance to suspend. */
name|error
operator|=
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/*      * Now, set them into the appropriate power state, usually D3.  If the      * device has an _SxD method for the next sleep state, use that power      * state instead.      */
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
comment|/* If the device is not attached, we've powered it down elsewhere. */
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|child
argument_list|)
condition|)
continue|continue;
comment|/* 	 * Default to D3 for all sleep states.  The _SxD method is optional 	 * so set the powerstate even if it's absent. 	 */
name|pstate
operator|=
name|PCI_POWERSTATE_D3
expr_stmt|;
name|error
operator|=
name|acpi_device_pwr_for_sleep
argument_list|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
argument_list|,
name|child
argument_list|,
operator|&
name|pstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ESRCH
operator|)
operator|&&
name|acpi_do_powerstate
condition|)
name|pci_set_powerstate
argument_list|(
name|child
argument_list|,
name|pstate
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_HANDLE
name|handle
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numdevs
decl_stmt|;
name|device_t
name|child
decl_stmt|,
modifier|*
name|devlist
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/*      * Put all devices in D0 before resuming them.  Call _S0D on each one      * since some systems expect this.      */
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
name|handle
operator|=
name|acpi_get_handle
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
condition|)
name|AcpiEvaluateObject
argument_list|(
name|handle
argument_list|,
literal|"_S0D"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|child
argument_list|)
operator|&&
name|acpi_do_powerstate
condition|)
name|pci_set_powerstate
argument_list|(
name|child
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|GIANT_REQUIRED
expr_stmt|;
comment|/* Allow children to shutdown first. */
name|bus_generic_shutdown
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/*      * Enable any GPEs that are able to power-on the system (i.e., RTC).      * Also, disable any that are not valid for this state (most).      */
name|acpi_wake_prep_walk
argument_list|(
name|ACPI_STATE_S5
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle a new device being added  */
end_comment

begin_function
specifier|static
name|device_t
name|acpi_add_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|int
name|order
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
name|device_t
name|child
decl_stmt|;
if|if
condition|(
operator|(
name|ad
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ad
argument_list|)
argument_list|,
name|M_ACPIDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|resource_list_init
argument_list|(
operator|&
name|ad
operator|->
name|ad_rl
argument_list|)
expr_stmt|;
name|child
operator|=
name|device_add_child_ordered
argument_list|(
name|bus
argument_list|,
name|order
argument_list|,
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|ad
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|ad
argument_list|,
name|M_ACPIDEV
argument_list|)
expr_stmt|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_print_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|adev
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|adev
operator|->
name|ad_rl
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"port"
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|"%#lx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"iomem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#lx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"irq"
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|"%ld"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"drq"
argument_list|,
name|SYS_RES_DRQ
argument_list|,
literal|"%ld"
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_flags
argument_list|(
name|child
argument_list|)
condition|)
name|retval
operator|+=
name|printf
argument_list|(
literal|" flags %#x"
argument_list|,
name|device_get_flags
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If this device is an ACPI child but no one claimed it, attempt  * to power it off.  We'll power it back up when a driver is added.  *  * XXX Disabled for now since many necessary devices (like fdc and  * ATA) don't claim the devices we created for them but still expect  * them to be powered up.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_probe_nomatch
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
comment|/* pci_set_powerstate(child, PCI_POWERSTATE_D3); */
block|}
end_function

begin_comment
comment|/*  * If a new driver has a chance to probe a child, first power it up.  *  * XXX Disabled for now (see acpi_probe_nomatch for details).  */
end_comment

begin_function
specifier|static
name|void
name|acpi_driver_added
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|driver_t
modifier|*
name|driver
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|,
modifier|*
name|devlist
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numdevs
decl_stmt|;
name|DEVICE_IDENTIFY
argument_list|(
name|driver
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|device_get_state
argument_list|(
name|child
argument_list|)
operator|==
name|DS_NOTPRESENT
condition|)
block|{
comment|/* pci_set_powerstate(child, PCI_POWERSTATE_D0); */
if|if
condition|(
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
comment|/* pci_set_powerstate(child, PCI_POWERSTATE_D3); */
block|}
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Location hint for devctl(8) */
end_comment

begin_function
specifier|static
name|int
name|acpi_child_location_str_method
parameter_list|(
name|device_t
name|cbdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|ad_handle
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"handle=%s"
argument_list|,
name|acpi_name
argument_list|(
name|dinfo
operator|->
name|ad_handle
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* PnP information for devctl(8) */
end_comment

begin_function
specifier|static
name|int
name|acpi_child_pnpinfo_str_method
parameter_list|(
name|device_t
name|cbdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|ACPI_BUFFER
name|adbuf
init|=
block|{
name|ACPI_ALLOCATE_BUFFER
block|,
name|NULL
block|}
decl_stmt|;
name|ACPI_DEVICE_INFO
modifier|*
name|adinfo
decl_stmt|;
name|struct
name|acpi_device
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|AcpiGetObjectInfo
argument_list|(
name|dinfo
operator|->
name|ad_handle
argument_list|,
operator|&
name|adbuf
argument_list|)
expr_stmt|;
name|adinfo
operator|=
operator|(
name|ACPI_DEVICE_INFO
operator|*
operator|)
name|adbuf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"_HID=%s _UID=%lu"
argument_list|,
operator|(
name|adinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_HID
operator|)
condition|?
name|adinfo
operator|->
name|HardwareId
operator|.
name|Value
else|:
literal|"none"
argument_list|,
operator|(
name|adinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_UID
operator|)
condition|?
name|strtoul
argument_list|(
name|adinfo
operator|->
name|UniqueId
operator|.
name|Value
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|adinfo
condition|)
name|AcpiOsFree
argument_list|(
name|adinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle per-device ivars  */
end_comment

begin_function
specifier|static
name|int
name|acpi_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
if|if
condition|(
operator|(
name|ad
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"device has no ivars\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* ACPI and ISA compatibility ivars */
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|ACPI_IVAR_HANDLE
case|:
operator|*
operator|(
name|ACPI_HANDLE
operator|*
operator|)
name|result
operator|=
name|ad
operator|->
name|ad_handle
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_MAGIC
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|ad
operator|->
name|ad_magic
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_PRIVATE
case|:
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|result
operator|=
name|ad
operator|->
name|ad_private
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_FLAGS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|ad
operator|->
name|ad_flags
expr_stmt|;
break|break;
case|case
name|ISA_IVAR_VENDORID
case|:
case|case
name|ISA_IVAR_SERIAL
case|:
case|case
name|ISA_IVAR_COMPATID
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|ISA_IVAR_LOGICALID
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|acpi_isa_get_logicalid
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
if|if
condition|(
operator|(
name|ad
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"device has no ivars\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|ACPI_IVAR_HANDLE
case|:
name|ad
operator|->
name|ad_handle
operator|=
operator|(
name|ACPI_HANDLE
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_MAGIC
case|:
name|ad
operator|->
name|ad_magic
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_PRIVATE
case|:
name|ad
operator|->
name|ad_private
operator|=
operator|(
name|void
operator|*
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_FLAGS
case|:
name|ad
operator|->
name|ad_flags
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"bad ivar write request (%d)"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle child resource allocation/removal  */
end_comment

begin_function
specifier|static
name|struct
name|resource_list
modifier|*
name|acpi_get_rlist
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
name|ad
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|ad
operator|->
name|ad_rl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pre-allocate/manage all memory and IO resources.  Since rman can't handle  * duplicates, we merge any in the sysresource attach routine.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_sysres_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|char
modifier|*
name|sysres_ids
index|[]
init|=
block|{
literal|"PNP0C01"
block|,
literal|"PNP0C02"
block|,
name|NULL
block|}
decl_stmt|;
name|device_t
modifier|*
name|children
decl_stmt|;
name|int
name|child_count
decl_stmt|,
name|i
decl_stmt|;
comment|/*      * Probe/attach any sysresource devices.  This would be unnecessary if we      * had multi-pass probe/attach.      */
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|children
argument_list|,
operator|&
name|child_count
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|child_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ACPI_ID_PROBE
argument_list|(
name|dev
argument_list|,
name|children
index|[
name|i
index|]
argument_list|,
name|sysres_ids
argument_list|)
operator|!=
name|NULL
condition|)
name|device_probe_and_attach
argument_list|(
name|children
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|children
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|rl
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"duplicate resource for %lx\n"
argument_list|,
name|rle
operator|->
name|start
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Only memory and IO resources are valid here. */
switch|switch
condition|(
name|rle
operator|->
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|rm
operator|=
operator|&
name|acpi_rman_io
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|rm
operator|=
operator|&
name|acpi_rman_mem
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
comment|/* Pre-allocate resource and add to our rman pool. */
name|res
operator|=
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|rle
operator|->
name|type
argument_list|,
operator|&
name|rle
operator|->
name|rid
argument_list|,
name|rle
operator|->
name|start
argument_list|,
name|rle
operator|->
name|start
operator|+
name|rle
operator|->
name|count
operator|-
literal|1
argument_list|,
name|rle
operator|->
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
block|{
name|rman_manage_region
argument_list|(
name|rm
argument_list|,
name|rman_get_start
argument_list|(
name|res
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|rle
operator|->
name|res
operator|=
name|res
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"reservation of %lx, %lx (%d) failed\n"
argument_list|,
name|rle
operator|->
name|start
argument_list|,
name|rle
operator|->
name|count
argument_list|,
name|rle
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find if we manage a given resource. */
end_comment

begin_function
specifier|static
name|struct
name|resource_list_entry
modifier|*
name|acpi_sysres_find
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|type
parameter_list|,
name|u_long
name|addr
parameter_list|)
block|{
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
comment|/* We only consider IO and memory resources for our pool. */
name|rle
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|SYS_RES_IOPORT
operator|&&
name|type
operator|!=
name|SYS_RES_MEMORY
condition|)
goto|goto
name|out
goto|;
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|rl
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|type
operator|==
name|rle
operator|->
name|type
operator|&&
name|addr
operator|>=
name|rle
operator|->
name|start
operator|&&
name|addr
operator|<
name|rle
operator|->
name|start
operator|+
name|rle
operator|->
name|count
condition|)
break|break;
block|}
name|out
label|:
return|return
operator|(
name|rle
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|acpi_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|ACPI_RESOURCE
name|ares
decl_stmt|;
name|struct
name|acpi_device
modifier|*
name|ad
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|ad
operator|->
name|ad_rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|res
operator|=
name|NULL
expr_stmt|;
name|ACPI_SERIAL_BEGIN
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
comment|/*      * If this is an allocation of the "default" range for a given RID, and      * we know what the resources for this device are (i.e., they're on the      * child's resource list), use those start/end values.      */
if|if
condition|(
name|bus
operator|==
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|&&
name|start
operator|==
literal|0UL
operator|&&
name|end
operator|==
operator|~
literal|0UL
condition|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|start
operator|=
name|rle
operator|->
name|start
expr_stmt|;
name|end
operator|=
name|rle
operator|->
name|end
expr_stmt|;
name|count
operator|=
name|rle
operator|->
name|count
expr_stmt|;
block|}
comment|/* If we don't manage this address, pass the request up to the parent. */
name|rle
operator|=
name|acpi_sysres_find
argument_list|(
name|bus
argument_list|,
name|type
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
condition|)
block|{
name|res
operator|=
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We only handle memory and IO resources through rman. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|rm
operator|=
operator|&
name|acpi_rman_io
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|rm
operator|=
operator|&
name|acpi_rman_mem
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"acpi_alloc_resource: invalid res type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* If we do know it, allocate it from the local pool. */
name|res
operator|=
name|rman_reserve_resource
argument_list|(
name|rm
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_ACTIVE
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* Copy the bus tag and handle from the pre-allocated resource. */
name|rman_set_rid
argument_list|(
name|res
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
name|rman_set_bustag
argument_list|(
name|res
argument_list|,
name|rman_get_bustag
argument_list|(
name|rle
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|rman_set_bushandle
argument_list|(
name|res
argument_list|,
name|rman_get_start
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If requested, activate the resource using the parent's method. */
if|if
condition|(
name|flags
operator|&
name|RF_ACTIVE
condition|)
if|if
condition|(
name|bus_activate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|res
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rman_release_resource
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|res
operator|!=
name|NULL
operator|&&
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|==
name|bus
condition|)
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IRQ
case|:
comment|/* 	     * Since bus_config_intr() takes immediate effect, we cannot 	     * configure the interrupt associated with a device when we 	     * parse the resources but have to defer it until a driver 	     * actually allocates the interrupt via bus_alloc_resource(). 	     * 	     * XXX: Should we handle the lookup failing? 	     */
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|acpi_lookup_irq_resource
argument_list|(
name|child
argument_list|,
operator|*
name|rid
argument_list|,
name|res
argument_list|,
operator|&
name|ares
argument_list|)
argument_list|)
condition|)
name|acpi_config_intr
argument_list|(
name|child
argument_list|,
operator|&
name|ares
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
name|ACPI_SERIAL_END
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_release_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ACPI_SERIAL_BEGIN
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
comment|/*      * If we know about this address, deactivate it and release it to the      * local pool.  If we don't, pass this request up to the parent.      */
if|if
condition|(
name|acpi_sysres_find
argument_list|(
name|bus
argument_list|,
name|type
argument_list|,
name|rman_get_start
argument_list|(
name|r
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rman_get_flags
argument_list|(
name|r
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
block|{
name|ret
operator|=
name|bus_deactivate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|rman_release_resource
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|BUS_RELEASE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|out
label|:
name|ACPI_SERIAL_END
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_delete_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|)
block|{
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|rl
operator|=
name|acpi_get_rlist
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|resource_list_delete
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate an IO port or memory resource, given its GAS. */
end_comment

begin_function
name|int
name|acpi_bus_alloc_gas
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|ACPI_GENERIC_ADDRESS
modifier|*
name|gas
parameter_list|,
name|struct
name|resource
modifier|*
modifier|*
name|res
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|res_type
decl_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
name|rid
operator|==
name|NULL
operator|||
name|gas
operator|==
name|NULL
operator|||
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* We only support memory and IO spaces. */
switch|switch
condition|(
name|gas
operator|->
name|AddressSpaceId
condition|)
block|{
case|case
name|ACPI_ADR_SPACE_SYSTEM_MEMORY
case|:
name|res_type
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
break|break;
case|case
name|ACPI_ADR_SPACE_SYSTEM_IO
case|:
name|res_type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
comment|/*      * If the register width is less than 8, assume the BIOS author means      * it is a bit field and just allocate a byte.      */
if|if
condition|(
name|gas
operator|->
name|RegisterBitWidth
operator|&&
name|gas
operator|->
name|RegisterBitWidth
operator|<
literal|8
condition|)
name|gas
operator|->
name|RegisterBitWidth
operator|=
literal|8
expr_stmt|;
comment|/* Validate the address after we're sure we support the space. */
if|if
condition|(
operator|!
name|ACPI_VALID_ADDRESS
argument_list|(
name|gas
operator|->
name|Address
argument_list|)
operator|||
name|gas
operator|->
name|RegisterBitWidth
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|res_type
argument_list|,
operator|*
name|rid
argument_list|,
name|gas
operator|->
name|Address
argument_list|,
name|gas
operator|->
name|RegisterBitWidth
operator|/
literal|8
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|res_type
argument_list|,
name|rid
argument_list|,
name|RF_ACTIVE
operator||
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|res
operator|!=
name|NULL
condition|)
block|{
operator|*
name|type
operator|=
name|res_type
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|bus_delete_resource
argument_list|(
name|dev
argument_list|,
name|res_type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Probe _HID and _CID for compatible ISA PNP ids. */
end_comment

begin_function
specifier|static
name|uint32_t
name|acpi_isa_get_logicalid
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_DEVICE_INFO
modifier|*
name|devinfo
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_STATUS
name|error
decl_stmt|;
name|u_int32_t
name|pnpid
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|pnpid
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
comment|/* Fetch and validate the HID. */
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|devinfo
operator|=
operator|(
name|ACPI_DEVICE_INFO
operator|*
operator|)
name|buf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_HID
operator|)
operator|!=
literal|0
condition|)
name|pnpid
operator|=
name|PNP_EISAID
argument_list|(
name|devinfo
operator|->
name|HardwareId
operator|.
name|Value
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|buf
operator|.
name|Pointer
operator|!=
name|NULL
condition|)
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|pnpid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_isa_get_compatid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
modifier|*
name|cids
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|ACPI_DEVICE_INFO
modifier|*
name|devinfo
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_STATUS
name|error
decl_stmt|;
name|uint32_t
modifier|*
name|pnpid
decl_stmt|;
name|int
name|valid
decl_stmt|,
name|i
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|pnpid
operator|=
name|cids
expr_stmt|;
name|valid
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
comment|/* Fetch and validate the CID */
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|devinfo
operator|=
operator|(
name|ACPI_DEVICE_INFO
operator|*
operator|)
name|buf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_CID
operator|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|devinfo
operator|->
name|CompatibilityId
operator|.
name|Count
operator|<
name|count
condition|)
name|count
operator|=
name|devinfo
operator|->
name|CompatibilityId
operator|.
name|Count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|devinfo
operator|->
name|CompatibilityId
operator|.
name|Id
index|[
name|i
index|]
operator|.
name|Value
argument_list|,
literal|"PNP"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
operator|*
name|pnpid
operator|++
operator|=
name|PNP_EISAID
argument_list|(
name|devinfo
operator|->
name|CompatibilityId
operator|.
name|Id
index|[
name|i
index|]
operator|.
name|Value
argument_list|)
expr_stmt|;
name|valid
operator|++
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|buf
operator|.
name|Pointer
operator|!=
name|NULL
condition|)
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|valid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|acpi_device_id_probe
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|char
modifier|*
modifier|*
name|ids
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
name|int
name|i
decl_stmt|;
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ids
operator|==
name|NULL
operator|||
name|h
operator|==
name|NULL
operator|||
name|acpi_get_type
argument_list|(
name|dev
argument_list|)
operator|!=
name|ACPI_TYPE_DEVICE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Try to match one of the array of IDs with a HID or CID. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ids
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|acpi_MatchHid
argument_list|(
name|h
argument_list|,
name|ids
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|ids
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_device_eval_obj
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|ACPI_STRING
name|pathname
parameter_list|,
name|ACPI_OBJECT_LIST
modifier|*
name|parameters
parameter_list|,
name|ACPI_BUFFER
modifier|*
name|ret
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
name|h
operator|=
name|ACPI_ROOT_OBJECT
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
return|return
operator|(
name|AcpiEvaluateObject
argument_list|(
name|h
argument_list|,
name|pathname
argument_list|,
name|parameters
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_device_pwr_for_sleep
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|dstate
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_HANDLE
name|handle
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|char
name|sxd
index|[
literal|8
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/*      * XXX If we find these devices, don't try to power them down.      * The serial and IRDA ports on my T23 hang the system when      * set to D3 and it appears that such legacy devices may      * need special handling in their drivers.      */
if|if
condition|(
name|handle
operator|==
name|NULL
operator|||
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0500"
argument_list|)
operator|||
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0501"
argument_list|)
operator|||
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0502"
argument_list|)
operator|||
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0510"
argument_list|)
operator|||
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0511"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*      * Override next state with the value from _SxD, if present.  If no      * dstate argument was provided, don't fetch the return value.      */
name|snprintf
argument_list|(
name|sxd
argument_list|,
sizeof|sizeof
argument_list|(
name|sxd
argument_list|)
argument_list|,
literal|"_S%dD"
argument_list|,
name|sc
operator|->
name|acpi_sstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstate
condition|)
name|status
operator|=
name|acpi_GetInteger
argument_list|(
name|handle
argument_list|,
name|sxd
argument_list|,
name|dstate
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|handle
argument_list|,
name|sxd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|AE_OK
case|:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AE_NOT_FOUND
case|:
name|error
operator|=
name|ESRCH
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Callback arg for our implementation of walking the namespace. */
end_comment

begin_struct
struct|struct
name|acpi_device_scan_ctx
block|{
name|acpi_scan_cb_t
name|user_fn
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|ACPI_HANDLE
name|parent
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_device_scan_cb
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|acpi_device_scan_ctx
modifier|*
name|ctx
decl_stmt|;
name|device_t
name|dev
decl_stmt|,
name|old_dev
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_OBJECT_TYPE
name|type
decl_stmt|;
comment|/*      * Skip this device if we think we'll have trouble with it or it is      * the parent where the scan began.      */
name|ctx
operator|=
operator|(
expr|struct
name|acpi_device_scan_ctx
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|acpi_avoid
argument_list|(
name|h
argument_list|)
operator|||
name|h
operator|==
name|ctx
operator|->
name|parent
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
comment|/* If this is not a valid device type (e.g., a method), skip it. */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiGetType
argument_list|(
name|h
argument_list|,
operator|&
name|type
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
if|if
condition|(
name|type
operator|!=
name|ACPI_TYPE_DEVICE
operator|&&
name|type
operator|!=
name|ACPI_TYPE_PROCESSOR
operator|&&
name|type
operator|!=
name|ACPI_TYPE_THERMAL
operator|&&
name|type
operator|!=
name|ACPI_TYPE_POWER
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
comment|/*      * Call the user function with the current device.  If it is unchanged      * afterwards, return.  Otherwise, we update the handle to the new dev.      */
name|old_dev
operator|=
name|acpi_get_device
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|dev
operator|=
name|old_dev
expr_stmt|;
name|status
operator|=
name|ctx
operator|->
name|user_fn
argument_list|(
name|h
argument_list|,
operator|&
name|dev
argument_list|,
name|level
argument_list|,
name|ctx
operator|->
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
operator|||
name|old_dev
operator|==
name|dev
condition|)
return|return
operator|(
name|status
operator|)
return|;
comment|/* Remove the old child and its connection to the handle. */
if|if
condition|(
name|old_dev
operator|!=
name|NULL
condition|)
block|{
name|device_delete_child
argument_list|(
name|device_get_parent
argument_list|(
name|old_dev
argument_list|)
argument_list|,
name|old_dev
argument_list|)
expr_stmt|;
name|AcpiDetachData
argument_list|(
name|h
argument_list|,
name|acpi_fake_objhandler
argument_list|)
expr_stmt|;
block|}
comment|/* Recreate the handle association if the user created a device. */
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
name|AcpiAttachData
argument_list|(
name|h
argument_list|,
name|acpi_fake_objhandler
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_device_scan_children
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|max_depth
parameter_list|,
name|acpi_scan_cb_t
name|user_fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
name|struct
name|acpi_device_scan_ctx
name|ctx
decl_stmt|;
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"children"
argument_list|)
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
name|h
operator|=
name|ACPI_ROOT_OBJECT
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
name|ctx
operator|.
name|user_fn
operator|=
name|user_fn
expr_stmt|;
name|ctx
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|ctx
operator|.
name|parent
operator|=
name|h
expr_stmt|;
return|return
operator|(
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|h
argument_list|,
name|max_depth
argument_list|,
name|acpi_device_scan_cb
argument_list|,
operator|&
name|ctx
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Even though ACPI devices are not PCI, we use the PCI approach for setting  * device power states since it's close enough to ACPI.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_set_powerstate_method
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|<
name|ACPI_STATE_D0
operator|||
name|state
operator|>
name|ACPI_STATE_D3
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Ignore errors if the power methods aren't present. */
name|status
operator|=
name|acpi_pwr_switch_consumer
argument_list|(
name|h
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
operator|&&
name|status
operator|!=
name|AE_NOT_FOUND
operator|&&
name|status
operator|!=
name|AE_BAD_PARAMETER
condition|)
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"failed to set ACPI power state D%d on %s: %s\n"
argument_list|,
name|state
argument_list|,
name|acpi_name
argument_list|(
name|h
argument_list|)
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_isa_pnp_probe
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|isa_pnp_id
modifier|*
name|ids
parameter_list|)
block|{
name|int
name|result
decl_stmt|,
name|cid_count
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|lid
decl_stmt|,
name|cids
index|[
literal|8
index|]
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/*      * ISA-style drivers attached to ACPI may persist and      * probe manually if we return ENOENT.  We never want      * that to happen, so don't ever return it.      */
name|result
operator|=
name|ENXIO
expr_stmt|;
comment|/* Scan the supplied IDs for a match */
name|lid
operator|=
name|acpi_isa_get_logicalid
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cid_count
operator|=
name|acpi_isa_get_compatid
argument_list|(
name|child
argument_list|,
name|cids
argument_list|,
literal|8
argument_list|)
expr_stmt|;
while|while
condition|(
name|ids
operator|&&
name|ids
operator|->
name|ip_id
condition|)
block|{
if|if
condition|(
name|lid
operator|==
name|ids
operator|->
name|ip_id
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cid_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cids
index|[
name|i
index|]
operator|==
name|ids
operator|->
name|ip_id
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ids
operator|++
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|result
operator|==
literal|0
operator|&&
name|ids
operator|->
name|ip_desc
condition|)
name|device_set_desc
argument_list|(
name|child
argument_list|,
name|ids
operator|->
name|ip_desc
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scan all of the ACPI namespace and attach child devices.  *  * We should only expect to find devices in the \_PR, \_TZ, \_SI, and  * \_SB scopes, and \_PR and \_TZ became obsolete in the ACPI 2.0 spec.  * However, in violation of the spec, some systems place their PCI link  * devices in \, so we have to walk the whole namespace.  We check the  * type of namespace nodes, so this should be ok.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_probe_children
parameter_list|(
name|device_t
name|bus
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/*      * Scan the namespace and insert placeholders for all the devices that      * we find.  We also probe/attach any early devices.      *      * Note that we use AcpiWalkNamespace rather than AcpiGetDevices because      * we want to create nodes for all devices, not just those that are      * currently present. (This assumes that we don't want to create/remove      * devices as they appear, which might be smarter.)      */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"namespace scan\n"
operator|)
argument_list|)
expr_stmt|;
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
literal|100
argument_list|,
name|acpi_probe_child
argument_list|,
name|bus
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Pre-allocate resources for our rman from any sysresource devices. */
name|acpi_sysres_alloc
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/* Create any static children by calling device identify methods. */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"device identify routines\n"
operator|)
argument_list|)
expr_stmt|;
name|bus_generic_probe
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/* Probe/attach all children, created staticly and from the namespace. */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"first bus_generic_attach\n"
operator|)
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/*      * Some of these children may have attached others as part of their attach      * process (eg. the root PCI bus driver), so rescan.      */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"second bus_generic_attach\n"
operator|)
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/* Attach wake sysctls. */
name|acpi_wake_sysctl_walk
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"done attaching children\n"
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine the probe order for a given device and return non-zero if it  * should be attached immediately.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_probe_order
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|int
modifier|*
name|order
parameter_list|)
block|{
comment|/*      * 1. I/O port and memory system resource holders      * 2. Embedded controllers (to handle early accesses)      * 3. PCI Link Devices      */
if|if
condition|(
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0C01"
argument_list|)
operator|||
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0C02"
argument_list|)
condition|)
operator|*
name|order
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0C09"
argument_list|)
condition|)
operator|*
name|order
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0C0F"
argument_list|)
condition|)
operator|*
name|order
operator|=
literal|3
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a child device and determine whether we might attach a device to  * it.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_probe_child
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
modifier|*
name|status
parameter_list|)
block|{
name|ACPI_OBJECT_TYPE
name|type
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|device_t
name|bus
decl_stmt|,
name|child
decl_stmt|;
name|int
name|order
decl_stmt|;
name|char
modifier|*
name|handle_str
decl_stmt|,
modifier|*
modifier|*
name|search
decl_stmt|;
specifier|static
name|char
modifier|*
name|scopes
index|[]
init|=
block|{
literal|"\\_PR_"
block|,
literal|"\\_TZ_"
block|,
literal|"\\_SI_"
block|,
literal|"\\_SB_"
block|,
name|NULL
block|}
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* Skip this device if we think we'll have trouble with it. */
if|if
condition|(
name|acpi_avoid
argument_list|(
name|handle
argument_list|)
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
name|bus
operator|=
operator|(
name|device_t
operator|)
name|context
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetType
argument_list|(
name|handle
argument_list|,
operator|&
name|type
argument_list|)
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ACPI_TYPE_DEVICE
case|:
case|case
name|ACPI_TYPE_PROCESSOR
case|:
case|case
name|ACPI_TYPE_THERMAL
case|:
case|case
name|ACPI_TYPE_POWER
case|:
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"children"
argument_list|)
condition|)
break|break;
comment|/* 	     * Since we scan from \, be sure to skip system scope objects. 	     * At least \_SB and \_TZ are detected as devices (ACPI-CA bug?) 	     */
name|handle_str
operator|=
name|acpi_name
argument_list|(
name|handle
argument_list|)
expr_stmt|;
for|for
control|(
name|search
operator|=
name|scopes
init|;
operator|*
name|search
operator|!=
name|NULL
condition|;
name|search
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|handle_str
argument_list|,
operator|*
name|search
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|search
operator|!=
name|NULL
condition|)
break|break;
comment|/*  	     * Create a placeholder device for this node.  Sort the placeholder 	     * so that the probe/attach passes will run breadth-first.  Orders 	     * less than 10 are reserved for special objects (i.e., system 	     * resources).  Larger values are used for all other devices. 	     */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"scanning '%s'\n"
operator|,
name|handle_str
operator|)
argument_list|)
expr_stmt|;
name|order
operator|=
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|10
expr_stmt|;
name|acpi_probe_order
argument_list|(
name|handle
argument_list|,
operator|&
name|order
argument_list|)
expr_stmt|;
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|bus
argument_list|,
name|order
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
break|break;
comment|/* Associate the handle with the device_t and vice versa. */
name|acpi_set_handle
argument_list|(
name|child
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|AcpiAttachData
argument_list|(
name|handle
argument_list|,
name|acpi_fake_objhandler
argument_list|,
name|child
argument_list|)
expr_stmt|;
comment|/* 	     * Check that the device is present.  If it's not present, 	     * leave it disabled (so that we have a device_t attached to 	     * the handle, but we don't probe it). 	     * 	     * XXX PCI link devices sometimes report "present" but not 	     * "functional" (i.e. if disabled).  Go ahead and probe them 	     * anyway since we may enable them later. 	     */
if|if
condition|(
name|type
operator|==
name|ACPI_TYPE_DEVICE
operator|&&
operator|!
name|acpi_DeviceIsPresent
argument_list|(
name|child
argument_list|)
condition|)
block|{
comment|/* Never disable PCI link devices. */
if|if
condition|(
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0C0F"
argument_list|)
condition|)
break|break;
comment|/* 		 * Docking stations should remain enabled since the system 		 * may be undocked at boot. 		 */
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetHandle
argument_list|(
name|handle
argument_list|,
literal|"_DCK"
argument_list|,
operator|&
name|h
argument_list|)
argument_list|)
condition|)
break|break;
name|device_disable
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	     * Get the device's resource settings and attach them. 	     * Note that if the device has _PRS but no _CRS, we need 	     * to decide when it's appropriate to try to configure the 	     * device.  Ignore the return value here; it's OK for the 	     * device not to have any resources. 	     */
name|acpi_parse_resources
argument_list|(
name|child
argument_list|,
name|handle
argument_list|,
operator|&
name|acpi_res_parse_set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * AcpiAttachData() requires an object handler but never uses it.  This is a  * placeholder object handler so we can store a device_t in an ACPI_HANDLE.  */
end_comment

begin_function
name|void
name|acpi_fake_objhandler
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
name|UINT32
name|fn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|acpi_shutdown_final
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
comment|/*      * XXX Shutdown code should only run on the BSP (cpuid 0).      * Some chipsets do not power off the system correctly if called from      * an AP.      */
name|sc
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|howto
operator|&
name|RB_POWEROFF
operator|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|AcpiEnterSleepStatePrep
argument_list|(
name|ACPI_STATE_S5
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"AcpiEnterSleepStatePrep failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Powering system off using ACPI\n"
argument_list|)
expr_stmt|;
name|ACPI_DISABLE_IRQS
argument_list|()
expr_stmt|;
name|status
operator|=
name|AcpiEnterSleepState
argument_list|(
name|ACPI_STATE_S5
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI power-off failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ACPI power-off failed - timeout\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|howto
operator|&
name|RB_HALT
operator|)
operator|==
literal|0
operator|&&
name|AcpiGbl_FADT
operator|->
name|ResetRegSup
operator|&&
name|sc
operator|->
name|acpi_handle_reboot
condition|)
block|{
comment|/* Reboot using the reset register. */
name|status
operator|=
name|AcpiHwLowLevelWrite
argument_list|(
name|AcpiGbl_FADT
operator|->
name|ResetRegister
operator|.
name|RegisterBitWidth
argument_list|,
name|AcpiGbl_FADT
operator|->
name|ResetValue
argument_list|,
operator|&
name|AcpiGbl_FADT
operator|->
name|ResetRegister
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI reset failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ACPI reset failed - timeout\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|acpi_do_disable
operator|&&
name|panicstr
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Only disable ACPI if the user requested.  On some systems, writing 	 * the disable value to SMI_CMD hangs the system. 	 */
name|printf
argument_list|(
literal|"Shutting down ACPI\n"
argument_list|)
expr_stmt|;
name|AcpiTerminate
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_enable_fixed_events
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|int
name|first_time
init|=
literal|1
decl_stmt|;
comment|/* Enable and clear fixed events and install handlers. */
if|if
condition|(
name|AcpiGbl_FADT
operator|!=
name|NULL
operator|&&
name|AcpiGbl_FADT
operator|->
name|PwrButton
operator|==
literal|0
condition|)
block|{
name|AcpiClearEvent
argument_list|(
name|ACPI_EVENT_POWER_BUTTON
argument_list|)
expr_stmt|;
name|AcpiInstallFixedEventHandler
argument_list|(
name|ACPI_EVENT_POWER_BUTTON
argument_list|,
name|acpi_event_power_button_sleep
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_time
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"Power Button (fixed)\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AcpiGbl_FADT
operator|!=
name|NULL
operator|&&
name|AcpiGbl_FADT
operator|->
name|SleepButton
operator|==
literal|0
condition|)
block|{
name|AcpiClearEvent
argument_list|(
name|ACPI_EVENT_SLEEP_BUTTON
argument_list|)
expr_stmt|;
name|AcpiInstallFixedEventHandler
argument_list|(
name|ACPI_EVENT_SLEEP_BUTTON
argument_list|,
name|acpi_event_sleep_button_sleep
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_time
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"Sleep Button (fixed)\n"
argument_list|)
expr_stmt|;
block|}
name|first_time
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the device is actually present and should  * be attached to.  This requires the present, enabled, UI-visible   * and diagnostics-passed bits to be set.  */
end_comment

begin_function
name|BOOLEAN
name|acpi_DeviceIsPresent
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_DEVICE_INFO
modifier|*
name|devinfo
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_STATUS
name|error
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|error
operator|=
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|devinfo
operator|=
operator|(
name|ACPI_DEVICE_INFO
operator|*
operator|)
name|buf
operator|.
name|Pointer
expr_stmt|;
comment|/* If no _STA method, must be present */
if|if
condition|(
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_STA
operator|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
comment|/* Return true for 'present' and 'functioning' */
if|if
condition|(
name|ACPI_DEVICE_PRESENT
argument_list|(
name|devinfo
operator|->
name|CurrentStatus
argument_list|)
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the battery is actually present and inserted.  */
end_comment

begin_function
name|BOOLEAN
name|acpi_BatteryIsPresent
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_DEVICE_INFO
modifier|*
name|devinfo
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_STATUS
name|error
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|error
operator|=
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|devinfo
operator|=
operator|(
name|ACPI_DEVICE_INFO
operator|*
operator|)
name|buf
operator|.
name|Pointer
expr_stmt|;
comment|/* If no _STA method, must be present */
if|if
condition|(
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_STA
operator|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
comment|/* Return true for 'present', 'battery present', and 'functioning' */
if|if
condition|(
name|ACPI_BATTERY_PRESENT
argument_list|(
name|devinfo
operator|->
name|CurrentStatus
argument_list|)
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Match a HID string against a handle  */
end_comment

begin_function
specifier|static
name|BOOLEAN
name|acpi_MatchHid
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|hid
parameter_list|)
block|{
name|ACPI_DEVICE_INFO
modifier|*
name|devinfo
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_STATUS
name|error
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|hid
operator|==
name|NULL
operator|||
name|h
operator|==
name|NULL
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|error
operator|=
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
argument_list|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|devinfo
operator|=
operator|(
name|ACPI_DEVICE_INFO
operator|*
operator|)
name|buf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_HID
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|hid
argument_list|,
name|devinfo
operator|->
name|HardwareId
operator|.
name|Value
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_CID
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|CompatibilityId
operator|.
name|Count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|hid
argument_list|,
name|devinfo
operator|->
name|CompatibilityId
operator|.
name|Id
index|[
name|i
index|]
operator|.
name|Value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the handle of a named object within our scope, ie. that of (parent)  * or one if its parents.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_GetHandleInScope
parameter_list|(
name|ACPI_HANDLE
name|parent
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|ACPI_HANDLE
modifier|*
name|result
parameter_list|)
block|{
name|ACPI_HANDLE
name|r
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
comment|/* Walk back up the tree to the root */
for|for
control|(
init|;
condition|;
control|)
block|{
name|status
operator|=
name|AcpiGetHandle
argument_list|(
name|parent
argument_list|,
name|path
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
operator|*
name|result
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* XXX Return error here? */
if|if
condition|(
name|status
operator|!=
name|AE_NOT_FOUND
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiGetParent
argument_list|(
name|parent
argument_list|,
operator|&
name|r
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|AE_NOT_FOUND
operator|)
return|;
name|parent
operator|=
name|r
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the difference between two PM tick counts. */
end_comment

begin_function
name|uint32_t
name|acpi_TimerDelta
parameter_list|(
name|uint32_t
name|end
parameter_list|,
name|uint32_t
name|start
parameter_list|)
block|{
name|uint32_t
name|delta
decl_stmt|;
if|if
condition|(
name|end
operator|>=
name|start
condition|)
name|delta
operator|=
name|end
operator|-
name|start
expr_stmt|;
elseif|else
if|if
condition|(
name|AcpiGbl_FADT
operator|->
name|TmrValExt
operator|==
literal|0
condition|)
name|delta
operator|=
operator|(
operator|(
literal|0x00FFFFFF
operator|-
name|start
operator|)
operator|+
name|end
operator|+
literal|1
operator|)
operator|&
literal|0x00FFFFFF
expr_stmt|;
else|else
name|delta
operator|=
operator|(
operator|(
literal|0xFFFFFFFF
operator|-
name|start
operator|)
operator|+
name|end
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|delta
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a buffer with a preset data size.  */
end_comment

begin_function
name|ACPI_BUFFER
modifier|*
name|acpi_AllocBuffer
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|ACPI_BUFFER
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|size
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|M_ACPIDEV
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|buf
operator|->
name|Length
operator|=
name|size
expr_stmt|;
name|buf
operator|->
name|Pointer
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|ACPI_STATUS
name|acpi_SetInteger
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|UINT32
name|number
parameter_list|)
block|{
name|ACPI_OBJECT
name|arg1
decl_stmt|;
name|ACPI_OBJECT_LIST
name|args
decl_stmt|;
name|arg1
operator|.
name|Type
operator|=
name|ACPI_TYPE_INTEGER
expr_stmt|;
name|arg1
operator|.
name|Integer
operator|.
name|Value
operator|=
name|number
expr_stmt|;
name|args
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|args
operator|.
name|Pointer
operator|=
operator|&
name|arg1
expr_stmt|;
return|return
operator|(
name|AcpiEvaluateObject
argument_list|(
name|handle
argument_list|,
name|path
argument_list|,
operator|&
name|args
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a path that should return an integer.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_GetInteger
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|UINT32
modifier|*
name|number
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_OBJECT
name|param
decl_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
name|handle
operator|=
name|ACPI_ROOT_OBJECT
expr_stmt|;
comment|/*      * Assume that what we've been pointed at is an Integer object, or      * a method that will return an Integer.      */
name|buf
operator|.
name|Pointer
operator|=
operator|&
name|param
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
sizeof|sizeof
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|handle
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|param
operator|.
name|Type
operator|==
name|ACPI_TYPE_INTEGER
condition|)
operator|*
name|number
operator|=
name|param
operator|.
name|Integer
operator|.
name|Value
expr_stmt|;
else|else
name|status
operator|=
name|AE_TYPE
expr_stmt|;
block|}
comment|/*       * In some applications, a method that's expected to return an Integer      * may instead return a Buffer (probably to simplify some internal      * arithmetic).  We'll try to fetch whatever it is, and if it's a Buffer,      * convert it into an Integer as best we can.      *      * This is a hack.      */
if|if
condition|(
name|status
operator|==
name|AE_BUFFER_OVERFLOW
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|.
name|Pointer
operator|=
name|AcpiOsAllocate
argument_list|(
name|buf
operator|.
name|Length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|AE_NO_MEMORY
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|handle
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|acpi_ConvertBufferToInteger
argument_list|(
operator|&
name|buf
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|ACPI_STATUS
name|acpi_ConvertBufferToInteger
parameter_list|(
name|ACPI_BUFFER
modifier|*
name|bufp
parameter_list|,
name|UINT32
modifier|*
name|number
parameter_list|)
block|{
name|ACPI_OBJECT
modifier|*
name|p
decl_stmt|;
name|UINT8
modifier|*
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|bufp
operator|->
name|Pointer
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|Type
operator|==
name|ACPI_TYPE_INTEGER
condition|)
block|{
operator|*
name|number
operator|=
name|p
operator|->
name|Integer
operator|.
name|Value
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|Type
operator|!=
name|ACPI_TYPE_BUFFER
condition|)
return|return
operator|(
name|AE_TYPE
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|Buffer
operator|.
name|Length
operator|>
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|(
name|AE_BAD_DATA
operator|)
return|;
operator|*
name|number
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|p
operator|->
name|Buffer
operator|.
name|Pointer
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|Buffer
operator|.
name|Length
condition|;
name|i
operator|++
control|)
operator|*
name|number
operator|+=
name|val
index|[
name|i
index|]
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over the elements of an a package object, calling the supplied  * function for each element.  *  * XXX possible enhancement might be to abort traversal on error.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_ForeachPackageObject
parameter_list|(
name|ACPI_OBJECT
modifier|*
name|pkg
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|ACPI_OBJECT
modifier|*
name|comp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ACPI_OBJECT
modifier|*
name|comp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pkg
operator|==
name|NULL
operator|||
name|pkg
operator|->
name|Type
operator|!=
name|ACPI_TYPE_PACKAGE
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
comment|/* Iterate over components */
name|i
operator|=
literal|0
expr_stmt|;
name|comp
operator|=
name|pkg
operator|->
name|Package
operator|.
name|Elements
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|pkg
operator|->
name|Package
operator|.
name|Count
condition|;
name|i
operator|++
operator|,
name|comp
operator|++
control|)
name|func
argument_list|(
name|comp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the (index)th resource object in a set.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_FindIndexedResource
parameter_list|(
name|ACPI_BUFFER
modifier|*
name|buf
parameter_list|,
name|int
name|index
parameter_list|,
name|ACPI_RESOURCE
modifier|*
modifier|*
name|resp
parameter_list|)
block|{
name|ACPI_RESOURCE
modifier|*
name|rp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rp
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
name|buf
operator|->
name|Pointer
expr_stmt|;
name|i
operator|=
name|index
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* Range check */
if|if
condition|(
name|rp
operator|>
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|->
name|Pointer
operator|+
name|buf
operator|->
name|Length
operator|)
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
comment|/* Check for terminator */
if|if
condition|(
name|rp
operator|->
name|Type
operator|==
name|ACPI_RESOURCE_TYPE_END_TAG
operator|||
name|rp
operator|->
name|Length
operator|==
literal|0
condition|)
return|return
operator|(
name|AE_NOT_FOUND
operator|)
return|;
name|rp
operator|=
name|ACPI_NEXT_RESOURCE
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resp
operator|!=
name|NULL
condition|)
operator|*
name|resp
operator|=
name|rp
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append an ACPI_RESOURCE to an ACPI_BUFFER.  *  * Given a pointer to an ACPI_RESOURCE structure, expand the ACPI_BUFFER  * provided to contain it.  If the ACPI_BUFFER is empty, allocate a sensible  * backing block.  If the ACPI_RESOURCE is NULL, return an empty set of  * resources.  */
end_comment

begin_define
define|#
directive|define
name|ACPI_INITIAL_RESOURCE_BUFFER_SIZE
value|512
end_define

begin_function
name|ACPI_STATUS
name|acpi_AppendBufferResource
parameter_list|(
name|ACPI_BUFFER
modifier|*
name|buf
parameter_list|,
name|ACPI_RESOURCE
modifier|*
name|res
parameter_list|)
block|{
name|ACPI_RESOURCE
modifier|*
name|rp
decl_stmt|;
name|void
modifier|*
name|newp
decl_stmt|;
comment|/* Initialise the buffer if necessary. */
if|if
condition|(
name|buf
operator|->
name|Pointer
operator|==
name|NULL
condition|)
block|{
name|buf
operator|->
name|Length
operator|=
name|ACPI_INITIAL_RESOURCE_BUFFER_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|->
name|Pointer
operator|=
name|AcpiOsAllocate
argument_list|(
name|buf
operator|->
name|Length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
name|rp
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
name|buf
operator|->
name|Pointer
expr_stmt|;
name|rp
operator|->
name|Type
operator|=
name|ACPI_RESOURCE_TYPE_END_TAG
expr_stmt|;
name|rp
operator|->
name|Length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
comment|/*      * Scan the current buffer looking for the terminator.      * This will either find the terminator or hit the end      * of the buffer and return an error.      */
name|rp
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
name|buf
operator|->
name|Pointer
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Range check, don't go outside the buffer */
if|if
condition|(
name|rp
operator|>=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|->
name|Pointer
operator|+
name|buf
operator|->
name|Length
operator|)
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
if|if
condition|(
name|rp
operator|->
name|Type
operator|==
name|ACPI_RESOURCE_TYPE_END_TAG
operator|||
name|rp
operator|->
name|Length
operator|==
literal|0
condition|)
break|break;
name|rp
operator|=
name|ACPI_NEXT_RESOURCE
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
comment|/*      * Check the size of the buffer and expand if required.      *      * Required size is:      *	size of existing resources before terminator +       *	size of new resource and header +      * 	size of terminator.      *      * Note that this loop should really only run once, unless      * for some reason we are stuffing a *really* huge resource.      */
while|while
condition|(
operator|(
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|rp
operator|-
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|->
name|Pointer
operator|)
operator|+
name|res
operator|->
name|Length
operator|+
name|ACPI_RS_SIZE_NO_DATA
operator|+
name|ACPI_RS_SIZE_MIN
operator|)
operator|>=
name|buf
operator|->
name|Length
condition|)
block|{
if|if
condition|(
operator|(
name|newp
operator|=
name|AcpiOsAllocate
argument_list|(
name|buf
operator|->
name|Length
operator|*
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
name|bcopy
argument_list|(
name|buf
operator|->
name|Pointer
argument_list|,
name|newp
argument_list|,
name|buf
operator|->
name|Length
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|newp
operator|+
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|rp
operator|-
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|->
name|Pointer
operator|)
operator|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|buf
operator|->
name|Pointer
argument_list|)
expr_stmt|;
name|buf
operator|->
name|Pointer
operator|=
name|newp
expr_stmt|;
name|buf
operator|->
name|Length
operator|+=
name|buf
operator|->
name|Length
expr_stmt|;
block|}
comment|/* Insert the new resource. */
name|bcopy
argument_list|(
name|res
argument_list|,
name|rp
argument_list|,
name|res
operator|->
name|Length
operator|+
name|ACPI_RS_SIZE_NO_DATA
argument_list|)
expr_stmt|;
comment|/* And add the terminator. */
name|rp
operator|=
name|ACPI_NEXT_RESOURCE
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Type
operator|=
name|ACPI_RESOURCE_TYPE_END_TAG
expr_stmt|;
name|rp
operator|->
name|Length
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set interrupt model.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_SetIntrModel
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
operator|(
name|acpi_SetInteger
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
literal|"_PIC"
argument_list|,
name|model
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_sleep_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
operator|(
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|arg
operator|)
operator|->
name|acpi_sleep_disabled
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_enum
enum|enum
name|acpi_sleep_state
block|{
name|ACPI_SS_NONE
block|,
name|ACPI_SS_GPE_SET
block|,
name|ACPI_SS_DEV_SUSPEND
block|,
name|ACPI_SS_SLP_PREP
block|,
name|ACPI_SS_SLEPT
block|, }
enum|;
end_enum

begin_comment
comment|/*  * Set the system sleep state  *  * Currently we support S1-S5 but S4 is only S4BIOS  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_SetSleepState
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|UINT8
name|TypeA
decl_stmt|;
name|UINT8
name|TypeB
decl_stmt|;
name|enum
name|acpi_sleep_state
name|slp_state
decl_stmt|;
name|ACPI_FUNCTION_TRACE_U32
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|status
operator|=
name|AE_OK
expr_stmt|;
name|ACPI_LOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|acpi_sleep_disabled
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|acpi_sstate
operator|!=
name|ACPI_STATE_S0
condition|)
name|status
operator|=
name|AE_ERROR
expr_stmt|;
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"acpi: suspend request ignored (not ready yet)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|sc
operator|->
name|acpi_sleep_disabled
operator|=
literal|1
expr_stmt|;
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
comment|/*      * Be sure to hold Giant across DEVICE_SUSPEND/RESUME since non-MPSAFE      * drivers need this.      */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|slp_state
operator|=
name|ACPI_SS_NONE
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ACPI_STATE_S1
case|:
case|case
name|ACPI_STATE_S2
case|:
case|case
name|ACPI_STATE_S3
case|:
case|case
name|ACPI_STATE_S4
case|:
name|status
operator|=
name|AcpiGetSleepTypeData
argument_list|(
name|state
argument_list|,
operator|&
name|TypeA
argument_list|,
operator|&
name|TypeB
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|AE_NOT_FOUND
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"Sleep state S%d not supported by BIOS\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"AcpiGetSleepTypeData failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|acpi_sstate
operator|=
name|state
expr_stmt|;
comment|/* Enable any GPEs as appropriate and requested by the user. */
name|acpi_wake_prep_walk
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|slp_state
operator|=
name|ACPI_SS_GPE_SET
expr_stmt|;
comment|/* 	 * Inform all devices that we are going to sleep.  If at least one 	 * device fails, DEVICE_SUSPEND() automatically resumes the tree. 	 * 	 * XXX Note that a better two-pass approach with a 'veto' pass 	 * followed by a "real thing" pass would be better, but the current 	 * bus interface does not provide for this. 	 */
if|if
condition|(
name|DEVICE_SUSPEND
argument_list|(
name|root_bus
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"device_suspend failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|slp_state
operator|=
name|ACPI_SS_DEV_SUSPEND
expr_stmt|;
name|status
operator|=
name|AcpiEnterSleepStatePrep
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"AcpiEnterSleepStatePrep failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|slp_state
operator|=
name|ACPI_SS_SLP_PREP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|acpi_sleep_delay
operator|>
literal|0
condition|)
name|DELAY
argument_list|(
name|sc
operator|->
name|acpi_sleep_delay
operator|*
literal|1000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|ACPI_STATE_S1
condition|)
block|{
name|acpi_sleep_machdep
argument_list|(
name|sc
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Re-enable ACPI hardware on wakeup from sleep state 4. */
if|if
condition|(
name|state
operator|==
name|ACPI_STATE_S4
condition|)
name|AcpiEnable
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ACPI_DISABLE_IRQS
argument_list|()
expr_stmt|;
name|status
operator|=
name|AcpiEnterSleepState
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"AcpiEnterSleepState failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|slp_state
operator|=
name|ACPI_SS_SLEPT
expr_stmt|;
break|break;
case|case
name|ACPI_STATE_S5
case|:
comment|/* 	 * Shut down cleanly and power off.  This will call us back through the 	 * shutdown handlers. 	 */
name|shutdown_nice
argument_list|(
name|RB_POWEROFF
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_STATE_S0
case|:
default|default:
name|status
operator|=
name|AE_BAD_PARAMETER
expr_stmt|;
break|break;
block|}
comment|/*      * Back out state according to how far along we got in the suspend      * process.  This handles both the error and success cases.      */
if|if
condition|(
name|slp_state
operator|>=
name|ACPI_SS_GPE_SET
condition|)
block|{
name|acpi_wake_prep_walk
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_sstate
operator|=
name|ACPI_STATE_S0
expr_stmt|;
block|}
if|if
condition|(
name|slp_state
operator|>=
name|ACPI_SS_SLP_PREP
condition|)
name|AcpiLeaveSleepState
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|slp_state
operator|>=
name|ACPI_SS_DEV_SUSPEND
condition|)
name|DEVICE_RESUME
argument_list|(
name|root_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|slp_state
operator|>=
name|ACPI_SS_SLEPT
condition|)
name|acpi_enable_fixed_events
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Allow another sleep request after a while. */
if|if
condition|(
name|state
operator|!=
name|ACPI_STATE_S5
condition|)
name|timeout
argument_list|(
name|acpi_sleep_enable
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|hz
operator|*
name|ACPI_MINIMUM_AWAKETIME
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize a device's wake GPE. */
end_comment

begin_function
name|int
name|acpi_wake_init
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|acpi_prw_data
name|prw
decl_stmt|;
comment|/* Evaluate _PRW to find the GPE. */
if|if
condition|(
name|acpi_parse_prw
argument_list|(
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|prw
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Set the requested type for the GPE (runtime, wake, or both). */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiSetGpeType
argument_list|(
name|prw
operator|.
name|gpe_handle
argument_list|,
name|prw
operator|.
name|gpe_bit
argument_list|,
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"set GPE type failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Enable or disable the device's wake GPE. */
end_comment

begin_function
name|int
name|acpi_wake_set_enable
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|struct
name|acpi_prw_data
name|prw
decl_stmt|;
name|ACPI_HANDLE
name|handle
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* Make sure the device supports waking the system and get the GPE. */
name|handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|acpi_parse_prw
argument_list|(
name|handle
argument_list|,
operator|&
name|prw
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|flags
operator|=
name|acpi_get_flags
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|status
operator|=
name|AcpiEnableGpe
argument_list|(
name|prw
operator|.
name|gpe_handle
argument_list|,
name|prw
operator|.
name|gpe_bit
argument_list|,
name|ACPI_NOT_ISR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"enable wake failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|acpi_set_flags
argument_list|(
name|dev
argument_list|,
name|flags
operator||
name|ACPI_FLAG_WAKE_ENABLED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|AcpiDisableGpe
argument_list|(
name|prw
operator|.
name|gpe_handle
argument_list|,
name|prw
operator|.
name|gpe_bit
argument_list|,
name|ACPI_NOT_ISR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"disable wake failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|acpi_set_flags
argument_list|(
name|dev
argument_list|,
name|flags
operator|&
operator|~
name|ACPI_FLAG_WAKE_ENABLED
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_wake_sleep_prep
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|int
name|sstate
parameter_list|)
block|{
name|struct
name|acpi_prw_data
name|prw
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
comment|/* Check that this is a wake-capable device and get its GPE. */
if|if
condition|(
name|acpi_parse_prw
argument_list|(
name|handle
argument_list|,
operator|&
name|prw
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dev
operator|=
name|acpi_get_device
argument_list|(
name|handle
argument_list|)
expr_stmt|;
comment|/*      * The destination sleep state must be less than (i.e., higher power)      * or equal to the value specified by _PRW.  If this GPE cannot be      * enabled for the next sleep state, then disable it.  If it can and      * the user requested it be enabled, turn on any required power resources      * and set _PSW.      */
if|if
condition|(
name|sstate
operator|>
name|prw
operator|.
name|lowest_wake
condition|)
block|{
name|AcpiDisableGpe
argument_list|(
name|prw
operator|.
name|gpe_handle
argument_list|,
name|prw
operator|.
name|gpe_bit
argument_list|,
name|ACPI_NOT_ISR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"wake_prep disabled wake for %s (S%d)\n"
argument_list|,
name|acpi_name
argument_list|(
name|handle
argument_list|)
argument_list|,
name|sstate
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dev
operator|&&
operator|(
name|acpi_get_flags
argument_list|(
name|dev
argument_list|)
operator|&
name|ACPI_FLAG_WAKE_ENABLED
operator|)
operator|!=
literal|0
condition|)
block|{
name|acpi_pwr_wake_enable
argument_list|(
name|handle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acpi_SetInteger
argument_list|(
name|handle
argument_list|,
literal|"_PSW"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"wake_prep enabled for %s (S%d)\n"
argument_list|,
name|acpi_name
argument_list|(
name|handle
argument_list|)
argument_list|,
name|sstate
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_wake_run_prep
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|int
name|sstate
parameter_list|)
block|{
name|struct
name|acpi_prw_data
name|prw
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
comment|/*      * Check that this is a wake-capable device and get its GPE.  Return      * now if the user didn't enable this device for wake.      */
if|if
condition|(
name|acpi_parse_prw
argument_list|(
name|handle
argument_list|,
operator|&
name|prw
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dev
operator|=
name|acpi_get_device
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
operator|||
operator|(
name|acpi_get_flags
argument_list|(
name|dev
argument_list|)
operator|&
name|ACPI_FLAG_WAKE_ENABLED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*      * If this GPE couldn't be enabled for the previous sleep state, it was      * disabled before going to sleep so re-enable it.  If it was enabled,      * clear _PSW and turn off any power resources it used.      */
if|if
condition|(
name|sstate
operator|>
name|prw
operator|.
name|lowest_wake
condition|)
block|{
name|AcpiEnableGpe
argument_list|(
name|prw
operator|.
name|gpe_handle
argument_list|,
name|prw
operator|.
name|gpe_bit
argument_list|,
name|ACPI_NOT_ISR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"run_prep re-enabled %s\n"
argument_list|,
name|acpi_name
argument_list|(
name|handle
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|acpi_SetInteger
argument_list|(
name|handle
argument_list|,
literal|"_PSW"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|acpi_pwr_wake_enable
argument_list|(
name|handle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"run_prep cleaned up for %s\n"
argument_list|,
name|acpi_name
argument_list|(
name|handle
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_wake_prep
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
modifier|*
name|status
parameter_list|)
block|{
name|int
name|sstate
decl_stmt|;
comment|/* If suspending, run the sleep prep function, otherwise wake. */
name|sstate
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|context
expr_stmt|;
if|if
condition|(
name|AcpiGbl_SystemAwakeAndRunning
condition|)
name|acpi_wake_sleep_prep
argument_list|(
name|handle
argument_list|,
name|sstate
argument_list|)
expr_stmt|;
else|else
name|acpi_wake_run_prep
argument_list|(
name|handle
argument_list|,
name|sstate
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Walk the tree rooted at acpi0 to prep devices for suspend/resume. */
end_comment

begin_function
specifier|static
name|int
name|acpi_wake_prep_walk
parameter_list|(
name|int
name|sstate
parameter_list|)
block|{
name|ACPI_HANDLE
name|sb_handle
decl_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetHandle
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
literal|"\\_SB_"
argument_list|,
operator|&
name|sb_handle
argument_list|)
argument_list|)
condition|)
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_DEVICE
argument_list|,
name|sb_handle
argument_list|,
literal|100
argument_list|,
name|acpi_wake_prep
argument_list|,
operator|&
name|sstate
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Walk the tree rooted at acpi0 to attach per-device wake sysctls. */
end_comment

begin_function
specifier|static
name|int
name|acpi_wake_sysctl_walk
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|numdevs
decl_stmt|;
name|device_t
modifier|*
name|devlist
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|error
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|numdevs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|numdevs
operator|==
literal|0
condition|)
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
name|acpi_wake_sysctl_walk
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|child
argument_list|)
condition|)
continue|continue;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|acpi_get_handle
argument_list|(
name|child
argument_list|)
argument_list|,
literal|"_PRW"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|child
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|child
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"wake"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|child
argument_list|,
literal|0
argument_list|,
name|acpi_wake_set_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Device set to wake the system"
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Enable or disable wake from userland. */
end_comment

begin_function
specifier|static
name|int
name|acpi_wake_set_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|enable
decl_stmt|,
name|error
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
operator|(
name|device_t
operator|)
name|arg1
expr_stmt|;
name|enable
operator|=
operator|(
name|acpi_get_flags
argument_list|(
name|dev
argument_list|)
operator|&
name|ACPI_FLAG_WAKE_ENABLED
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|enable
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|enable
operator|!=
literal|0
operator|&&
name|enable
operator|!=
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|acpi_wake_set_enable
argument_list|(
name|dev
argument_list|,
name|enable
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a device's _PRW into a structure. */
end_comment

begin_function
name|int
name|acpi_parse_prw
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
name|struct
name|acpi_prw_data
modifier|*
name|prw
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_BUFFER
name|prw_buffer
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|res
decl_stmt|,
modifier|*
name|res2
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|power_count
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|prw
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*      * The _PRW object (7.2.9) is only required for devices that have the      * ability to wake the system from a sleeping state.      */
name|error
operator|=
name|EINVAL
expr_stmt|;
name|prw_buffer
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|prw_buffer
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|h
argument_list|,
literal|"_PRW"
argument_list|,
name|NULL
argument_list|,
operator|&
name|prw_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|res
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|prw_buffer
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
operator|!
name|ACPI_PKG_VALID
argument_list|(
name|res
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/*      * Element 1 of the _PRW object:      * The lowest power system sleeping state that can be entered while still      * providing wake functionality.  The sleeping state being entered must      * be less than (i.e., higher power) or equal to this value.      */
if|if
condition|(
name|acpi_PkgInt32
argument_list|(
name|res
argument_list|,
literal|1
argument_list|,
operator|&
name|prw
operator|->
name|lowest_wake
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*      * Element 0 of the _PRW object:      */
switch|switch
condition|(
name|res
operator|->
name|Package
operator|.
name|Elements
index|[
literal|0
index|]
operator|.
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_INTEGER
case|:
comment|/* 	 * If the data type of this package element is numeric, then this 	 * _PRW package element is the bit index in the GPEx_EN, in the 	 * GPE blocks described in the FADT, of the enable bit that is 	 * enabled for the wake event. 	 */
name|prw
operator|->
name|gpe_handle
operator|=
name|NULL
expr_stmt|;
name|prw
operator|->
name|gpe_bit
operator|=
name|res
operator|->
name|Package
operator|.
name|Elements
index|[
literal|0
index|]
operator|.
name|Integer
operator|.
name|Value
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_PACKAGE
case|:
comment|/* 	 * If the data type of this package element is a package, then this 	 * _PRW package element is itself a package containing two 	 * elements.  The first is an object reference to the GPE Block 	 * device that contains the GPE that will be triggered by the wake 	 * event.  The second element is numeric and it contains the bit 	 * index in the GPEx_EN, in the GPE Block referenced by the 	 * first element in the package, of the enable bit that is enabled for 	 * the wake event. 	 * 	 * For example, if this field is a package then it is of the form: 	 * Package() {\_SB.PCI0.ISA.GPE, 2} 	 */
name|res2
operator|=
operator|&
name|res
operator|->
name|Package
operator|.
name|Elements
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ACPI_PKG_VALID
argument_list|(
name|res2
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|prw
operator|->
name|gpe_handle
operator|=
name|acpi_GetReference
argument_list|(
name|NULL
argument_list|,
operator|&
name|res2
operator|->
name|Package
operator|.
name|Elements
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|prw
operator|->
name|gpe_handle
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|acpi_PkgInt32
argument_list|(
name|res2
argument_list|,
literal|1
argument_list|,
operator|&
name|prw
operator|->
name|gpe_bit
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
goto|goto
name|out
goto|;
block|}
comment|/* Elements 2 to N of the _PRW object are power resources. */
name|power_count
operator|=
name|res
operator|->
name|Package
operator|.
name|Count
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|power_count
operator|>
name|ACPI_PRW_MAX_POWERRES
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI device %s has too many power resources\n"
argument_list|,
name|acpi_name
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|power_count
operator|=
literal|0
expr_stmt|;
block|}
name|prw
operator|->
name|power_res_count
operator|=
name|power_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|power_count
condition|;
name|i
operator|++
control|)
name|prw
operator|->
name|power_res
index|[
name|i
index|]
operator|=
name|res
operator|->
name|Package
operator|.
name|Elements
index|[
name|i
index|]
expr_stmt|;
name|out
label|:
if|if
condition|(
name|prw_buffer
operator|.
name|Pointer
operator|!=
name|NULL
condition|)
name|AcpiOsFree
argument_list|(
name|prw_buffer
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ACPI Event Handlers  */
end_comment

begin_comment
comment|/* System Event Handlers (registered by EVENTHANDLER_REGISTER) */
end_comment

begin_function
specifier|static
name|void
name|acpi_system_eventhandler_sleep
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE_U32
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|>=
name|ACPI_STATE_S0
operator|&&
name|state
operator|<=
name|ACPI_S_STATES_MAX
condition|)
name|acpi_SetSleepState
argument_list|(
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|arg
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_system_eventhandler_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE_U32
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Currently, nothing to do for wakeup. */
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * ACPICA Event Handlers (FixedEvent, also called from button notify handler)  */
end_comment

begin_function
name|UINT32
name|acpi_event_power_button_sleep
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|acpi_sleep_event
argument_list|,
name|sc
operator|->
name|acpi_power_button_sx
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|UINT32
name|acpi_event_power_button_wake
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|acpi_wakeup_event
argument_list|,
name|sc
operator|->
name|acpi_power_button_sx
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|UINT32
name|acpi_event_sleep_button_sleep
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|acpi_sleep_event
argument_list|,
name|sc
operator|->
name|acpi_sleep_button_sx
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|UINT32
name|acpi_event_sleep_button_wake
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|acpi_wakeup_event
argument_list|,
name|sc
operator|->
name|acpi_sleep_button_sx
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX This static buffer is suboptimal.  There is no locking so only  * use this for single-threaded callers.  */
end_comment

begin_function
name|char
modifier|*
name|acpi_name
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|)
block|{
name|ACPI_BUFFER
name|buf
decl_stmt|;
specifier|static
name|char
name|data
index|[
literal|256
index|]
decl_stmt|;
name|buf
operator|.
name|Length
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|handle
operator|&&
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetName
argument_list|(
name|handle
argument_list|,
name|ACPI_FULL_PATHNAME
argument_list|,
operator|&
name|buf
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|data
operator|)
return|;
return|return
operator|(
literal|"(unknown)"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Debugging/bug-avoidance.  Avoid trying to fetch info on various  * parts of the namespace.  */
end_comment

begin_function
name|int
name|acpi_avoid
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|env
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|int
name|len
decl_stmt|;
name|np
operator|=
name|acpi_name
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|==
literal|'\\'
condition|)
name|np
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|env
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.avoid"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Scan the avoid list checking for a match */
name|cp
operator|=
name|env
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|cp
operator|!=
literal|0
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
break|break;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
index|[
name|len
index|]
operator|!=
literal|0
operator|&&
operator|!
name|isspace
argument_list|(
name|cp
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
name|np
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|len
expr_stmt|;
block|}
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Debugging/bug-avoidance.  Disable ACPI subsystem components.  */
end_comment

begin_function
name|int
name|acpi_disabled
parameter_list|(
name|char
modifier|*
name|subsys
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|env
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|env
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.disabled"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|env
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Scan the disable list, checking for a match. */
name|cp
operator|=
name|env
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
index|[
name|len
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
name|cp
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|subsys
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|len
expr_stmt|;
block|}
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Control interface.  *  * We multiplex ioctls for all participating ACPI devices here.  Individual   * drivers wanting to be accessible via /dev/acpi should use the  * register/deregister interface to make their handlers visible.  */
end_comment

begin_struct
struct|struct
name|acpi_ioctl_hook
block|{
name|TAILQ_ENTRY
argument_list|(
argument|acpi_ioctl_hook
argument_list|)
name|link
expr_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|acpi_ioctl_fn
name|fn
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|acpi_ioctl_hook
argument_list|)
name|acpi_ioctl_hooks
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|acpi_ioctl_hooks_initted
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|acpi_register_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|acpi_ioctl_fn
name|fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|acpi_ioctl_hook
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hp
argument_list|)
argument_list|,
name|M_ACPIDEV
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|hp
operator|->
name|cmd
operator|=
name|cmd
expr_stmt|;
name|hp
operator|->
name|fn
operator|=
name|fn
expr_stmt|;
name|hp
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|ACPI_LOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|acpi_ioctl_hooks_initted
operator|==
literal|0
condition|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|acpi_ioctl_hooks
argument_list|)
expr_stmt|;
name|acpi_ioctl_hooks_initted
operator|=
literal|1
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|acpi_ioctl_hooks
argument_list|,
name|hp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|acpi_deregister_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|acpi_ioctl_fn
name|fn
parameter_list|)
block|{
name|struct
name|acpi_ioctl_hook
modifier|*
name|hp
decl_stmt|;
name|ACPI_LOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|hp
argument_list|,
argument|&acpi_ioctl_hooks
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|hp
operator|->
name|cmd
operator|==
name|cmd
operator|&&
name|hp
operator|->
name|fn
operator|==
name|fn
condition|)
break|break;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|acpi_ioctl_hooks
argument_list|,
name|hp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hp
argument_list|,
name|M_ACPIDEV
argument_list|)
expr_stmt|;
block|}
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpiopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpiclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpiioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|acpi_ioctl_hook
modifier|*
name|hp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|state
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|hp
operator|=
name|NULL
expr_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
comment|/*      * Scan the list of registered ioctls, looking for handlers.      */
name|ACPI_LOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|acpi_ioctl_hooks_initted
condition|)
name|TAILQ_FOREACH
argument_list|(
argument|hp
argument_list|,
argument|&acpi_ioctl_hooks
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|hp
operator|->
name|cmd
operator|==
name|cmd
condition|)
break|break;
block|}
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
return|return
operator|(
name|hp
operator|->
name|fn
argument_list|(
name|cmd
argument_list|,
name|addr
argument_list|,
name|hp
operator|->
name|arg
argument_list|)
operator|)
return|;
comment|/*      * Core ioctls are not permitted for non-writable user.      * Currently, other ioctls just fetch information.      * Not changing system behavior.      */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* Core system ioctls. */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ACPIIO_SETSLPSTATE
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
name|state
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|state
operator|>=
name|ACPI_STATE_S0
operator|&&
name|state
operator|<=
name|ACPI_S_STATES_MAX
condition|)
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|acpi_SetSleepState
argument_list|(
name|sc
argument_list|,
name|state
argument_list|)
argument_list|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_supported_sleep_state_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|UINT8
name|state
decl_stmt|,
name|TypeA
decl_stmt|,
name|TypeB
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|32
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
expr_stmt|;
for|for
control|(
name|state
operator|=
name|ACPI_STATE_S1
init|;
name|state
operator|<
name|ACPI_S_STATES_MAX
operator|+
literal|1
condition|;
name|state
operator|++
control|)
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetSleepTypeData
argument_list|(
name|state
argument_list|,
operator|&
name|TypeA
argument_list|,
operator|&
name|TypeB
argument_list|)
argument_list|)
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"S%d "
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_sleep_state_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|sleep_state
index|[
literal|10
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|new_state
decl_stmt|,
name|old_state
decl_stmt|;
name|old_state
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
if|if
condition|(
name|old_state
operator|>
name|ACPI_S_STATES_MAX
operator|+
literal|1
condition|)
name|strlcpy
argument_list|(
name|sleep_state
argument_list|,
literal|"unknown"
argument_list|,
sizeof|sizeof
argument_list|(
name|sleep_state
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|sleep_state
argument_list|,
name|sleep_state_names
index|[
name|old_state
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sleep_state
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sleep_state
argument_list|,
sizeof|sizeof
argument_list|(
name|sleep_state
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
name|new_state
operator|=
name|ACPI_STATE_S0
expr_stmt|;
for|for
control|(
init|;
name|new_state
operator|<=
name|ACPI_S_STATES_MAX
operator|+
literal|1
condition|;
name|new_state
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sleep_state
argument_list|,
name|sleep_state_names
index|[
name|new_state
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|new_state
operator|<=
name|ACPI_S_STATES_MAX
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|new_state
operator|!=
name|old_state
condition|)
operator|*
operator|(
name|u_int
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|=
name|new_state
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Inform devctl(4) when we receive a Notify. */
end_comment

begin_function
name|void
name|acpi_UserNotify
parameter_list|(
specifier|const
name|char
modifier|*
name|subsystem
parameter_list|,
name|ACPI_HANDLE
name|h
parameter_list|,
name|uint8_t
name|notify
parameter_list|)
block|{
name|char
name|notify_buf
index|[
literal|16
index|]
decl_stmt|;
name|ACPI_BUFFER
name|handle_buf
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
if|if
condition|(
name|subsystem
operator|==
name|NULL
condition|)
return|return;
name|handle_buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|handle_buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiNsHandleToPathname
argument_list|(
name|h
argument_list|,
operator|&
name|handle_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return;
name|snprintf
argument_list|(
name|notify_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|notify_buf
argument_list|)
argument_list|,
literal|"notify=0x%02x"
argument_list|,
name|notify
argument_list|)
expr_stmt|;
name|devctl_notify
argument_list|(
literal|"ACPI"
argument_list|,
name|subsystem
argument_list|,
name|handle_buf
operator|.
name|Pointer
argument_list|,
name|notify_buf
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|handle_buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ACPI_DEBUG
end_ifdef

begin_comment
comment|/*  * Support for parsing debug options from the kernel environment.  *  * Bits may be set in the AcpiDbgLayer and AcpiDbgLevel debug registers  * by specifying the names of the bits in the debug.acpi.layer and  * debug.acpi.level environment variables.  Bits may be unset by   * prefixing the bit name with !.  */
end_comment

begin_struct
struct|struct
name|debugtag
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|UINT32
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|debugtag
name|dbg_layer
index|[]
init|=
block|{
block|{
literal|"ACPI_UTILITIES"
block|,
name|ACPI_UTILITIES
block|}
block|,
block|{
literal|"ACPI_HARDWARE"
block|,
name|ACPI_HARDWARE
block|}
block|,
block|{
literal|"ACPI_EVENTS"
block|,
name|ACPI_EVENTS
block|}
block|,
block|{
literal|"ACPI_TABLES"
block|,
name|ACPI_TABLES
block|}
block|,
block|{
literal|"ACPI_NAMESPACE"
block|,
name|ACPI_NAMESPACE
block|}
block|,
block|{
literal|"ACPI_PARSER"
block|,
name|ACPI_PARSER
block|}
block|,
block|{
literal|"ACPI_DISPATCHER"
block|,
name|ACPI_DISPATCHER
block|}
block|,
block|{
literal|"ACPI_EXECUTER"
block|,
name|ACPI_EXECUTER
block|}
block|,
block|{
literal|"ACPI_RESOURCES"
block|,
name|ACPI_RESOURCES
block|}
block|,
block|{
literal|"ACPI_CA_DEBUGGER"
block|,
name|ACPI_CA_DEBUGGER
block|}
block|,
block|{
literal|"ACPI_OS_SERVICES"
block|,
name|ACPI_OS_SERVICES
block|}
block|,
block|{
literal|"ACPI_CA_DISASSEMBLER"
block|,
name|ACPI_CA_DISASSEMBLER
block|}
block|,
block|{
literal|"ACPI_ALL_COMPONENTS"
block|,
name|ACPI_ALL_COMPONENTS
block|}
block|,
block|{
literal|"ACPI_AC_ADAPTER"
block|,
name|ACPI_AC_ADAPTER
block|}
block|,
block|{
literal|"ACPI_BATTERY"
block|,
name|ACPI_BATTERY
block|}
block|,
block|{
literal|"ACPI_BUS"
block|,
name|ACPI_BUS
block|}
block|,
block|{
literal|"ACPI_BUTTON"
block|,
name|ACPI_BUTTON
block|}
block|,
block|{
literal|"ACPI_EC"
block|,
name|ACPI_EC
block|}
block|,
block|{
literal|"ACPI_FAN"
block|,
name|ACPI_FAN
block|}
block|,
block|{
literal|"ACPI_POWERRES"
block|,
name|ACPI_POWERRES
block|}
block|,
block|{
literal|"ACPI_PROCESSOR"
block|,
name|ACPI_PROCESSOR
block|}
block|,
block|{
literal|"ACPI_THERMAL"
block|,
name|ACPI_THERMAL
block|}
block|,
block|{
literal|"ACPI_TIMER"
block|,
name|ACPI_TIMER
block|}
block|,
block|{
literal|"ACPI_ALL_DRIVERS"
block|,
name|ACPI_ALL_DRIVERS
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|debugtag
name|dbg_level
index|[]
init|=
block|{
block|{
literal|"ACPI_LV_ERROR"
block|,
name|ACPI_LV_ERROR
block|}
block|,
block|{
literal|"ACPI_LV_WARN"
block|,
name|ACPI_LV_WARN
block|}
block|,
block|{
literal|"ACPI_LV_INIT"
block|,
name|ACPI_LV_INIT
block|}
block|,
block|{
literal|"ACPI_LV_DEBUG_OBJECT"
block|,
name|ACPI_LV_DEBUG_OBJECT
block|}
block|,
block|{
literal|"ACPI_LV_INFO"
block|,
name|ACPI_LV_INFO
block|}
block|,
block|{
literal|"ACPI_LV_ALL_EXCEPTIONS"
block|,
name|ACPI_LV_ALL_EXCEPTIONS
block|}
block|,
comment|/* Trace verbosity level 1 [Standard Trace Level] */
block|{
literal|"ACPI_LV_INIT_NAMES"
block|,
name|ACPI_LV_INIT_NAMES
block|}
block|,
block|{
literal|"ACPI_LV_PARSE"
block|,
name|ACPI_LV_PARSE
block|}
block|,
block|{
literal|"ACPI_LV_LOAD"
block|,
name|ACPI_LV_LOAD
block|}
block|,
block|{
literal|"ACPI_LV_DISPATCH"
block|,
name|ACPI_LV_DISPATCH
block|}
block|,
block|{
literal|"ACPI_LV_EXEC"
block|,
name|ACPI_LV_EXEC
block|}
block|,
block|{
literal|"ACPI_LV_NAMES"
block|,
name|ACPI_LV_NAMES
block|}
block|,
block|{
literal|"ACPI_LV_OPREGION"
block|,
name|ACPI_LV_OPREGION
block|}
block|,
block|{
literal|"ACPI_LV_BFIELD"
block|,
name|ACPI_LV_BFIELD
block|}
block|,
block|{
literal|"ACPI_LV_TABLES"
block|,
name|ACPI_LV_TABLES
block|}
block|,
block|{
literal|"ACPI_LV_VALUES"
block|,
name|ACPI_LV_VALUES
block|}
block|,
block|{
literal|"ACPI_LV_OBJECTS"
block|,
name|ACPI_LV_OBJECTS
block|}
block|,
block|{
literal|"ACPI_LV_RESOURCES"
block|,
name|ACPI_LV_RESOURCES
block|}
block|,
block|{
literal|"ACPI_LV_USER_REQUESTS"
block|,
name|ACPI_LV_USER_REQUESTS
block|}
block|,
block|{
literal|"ACPI_LV_PACKAGE"
block|,
name|ACPI_LV_PACKAGE
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSITY1"
block|,
name|ACPI_LV_VERBOSITY1
block|}
block|,
comment|/* Trace verbosity level 2 [Function tracing and memory allocation] */
block|{
literal|"ACPI_LV_ALLOCATIONS"
block|,
name|ACPI_LV_ALLOCATIONS
block|}
block|,
block|{
literal|"ACPI_LV_FUNCTIONS"
block|,
name|ACPI_LV_FUNCTIONS
block|}
block|,
block|{
literal|"ACPI_LV_OPTIMIZATIONS"
block|,
name|ACPI_LV_OPTIMIZATIONS
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSITY2"
block|,
name|ACPI_LV_VERBOSITY2
block|}
block|,
block|{
literal|"ACPI_LV_ALL"
block|,
name|ACPI_LV_ALL
block|}
block|,
comment|/* Trace verbosity level 3 [Threading, I/O, and Interrupts] */
block|{
literal|"ACPI_LV_MUTEX"
block|,
name|ACPI_LV_MUTEX
block|}
block|,
block|{
literal|"ACPI_LV_THREADS"
block|,
name|ACPI_LV_THREADS
block|}
block|,
block|{
literal|"ACPI_LV_IO"
block|,
name|ACPI_LV_IO
block|}
block|,
block|{
literal|"ACPI_LV_INTERRUPTS"
block|,
name|ACPI_LV_INTERRUPTS
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSITY3"
block|,
name|ACPI_LV_VERBOSITY3
block|}
block|,
comment|/* Exceptionally verbose output -- also used in the global "DebugLevel"  */
block|{
literal|"ACPI_LV_AML_DISASSEMBLE"
block|,
name|ACPI_LV_AML_DISASSEMBLE
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSE_INFO"
block|,
name|ACPI_LV_VERBOSE_INFO
block|}
block|,
block|{
literal|"ACPI_LV_FULL_TABLES"
block|,
name|ACPI_LV_FULL_TABLES
block|}
block|,
block|{
literal|"ACPI_LV_EVENTS"
block|,
name|ACPI_LV_EVENTS
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSE"
block|,
name|ACPI_LV_VERBOSE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|acpi_parse_debug
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|struct
name|debugtag
modifier|*
name|tag
parameter_list|,
name|UINT32
modifier|*
name|flag
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|int
name|set
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
name|ep
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|ep
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|ep
argument_list|)
condition|)
name|ep
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'!'
condition|)
block|{
name|set
operator|=
literal|0
expr_stmt|;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|ep
condition|)
continue|continue;
block|}
else|else
block|{
name|set
operator|=
literal|1
expr_stmt|;
block|}
name|l
operator|=
name|ep
operator|-
name|cp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tag
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
name|tag
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|l
argument_list|)
condition|)
block|{
if|if
condition|(
name|set
condition|)
operator|*
name|flag
operator||=
name|tag
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
else|else
operator|*
name|flag
operator|&=
operator|~
name|tag
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
block|}
name|cp
operator|=
name|ep
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_set_debugging
parameter_list|(
name|void
modifier|*
name|junk
parameter_list|)
block|{
name|char
modifier|*
name|layer
decl_stmt|,
modifier|*
name|level
decl_stmt|;
if|if
condition|(
name|cold
condition|)
block|{
name|AcpiDbgLayer
operator|=
literal|0
expr_stmt|;
name|AcpiDbgLevel
operator|=
literal|0
expr_stmt|;
block|}
name|layer
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.layer"
argument_list|)
expr_stmt|;
name|level
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.level"
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|NULL
operator|&&
name|level
operator|==
name|NULL
condition|)
return|return;
name|printf
argument_list|(
literal|"ACPI set debug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"NONE"
argument_list|,
name|layer
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" layer '%s'"
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|acpi_parse_debug
argument_list|(
name|layer
argument_list|,
operator|&
name|dbg_layer
index|[
literal|0
index|]
argument_list|,
operator|&
name|AcpiDbgLayer
argument_list|)
expr_stmt|;
name|freeenv
argument_list|(
name|layer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"NONE"
argument_list|,
name|level
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" level '%s'"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|acpi_parse_debug
argument_list|(
name|level
argument_list|,
operator|&
name|dbg_level
index|[
literal|0
index|]
argument_list|,
operator|&
name|AcpiDbgLevel
argument_list|)
expr_stmt|;
name|freeenv
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|acpi_debugging
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|acpi_set_debugging
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|acpi_debug_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
modifier|*
name|dbg
decl_stmt|;
name|struct
name|debugtag
modifier|*
name|tag
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
if|if
condition|(
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|oidp
operator|->
name|oid_arg1
argument_list|,
literal|"debug.acpi.layer"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tag
operator|=
operator|&
name|dbg_layer
index|[
literal|0
index|]
expr_stmt|;
name|dbg
operator|=
operator|&
name|AcpiDbgLayer
expr_stmt|;
block|}
else|else
block|{
name|tag
operator|=
operator|&
name|dbg_level
index|[
literal|0
index|]
expr_stmt|;
name|dbg
operator|=
operator|&
name|AcpiDbgLevel
expr_stmt|;
block|}
comment|/* Get old values if this is a get request. */
name|ACPI_SERIAL_BEGIN
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dbg
operator|==
literal|0
condition|)
block|{
name|sbuf_cpy
argument_list|(
operator|&
name|sb
argument_list|,
literal|"NONE"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|tag
operator|->
name|name
operator|!=
name|NULL
condition|;
name|tag
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|dbg
operator|&
name|tag
operator|->
name|value
operator|)
operator|==
name|tag
operator|->
name|value
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s "
argument_list|,
name|tag
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
comment|/* Copy out the old values to the user. */
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
comment|/* If the user is setting a string, parse it. */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|dbg
operator|=
literal|0
expr_stmt|;
name|setenv
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|req
operator|->
name|newptr
argument_list|)
expr_stmt|;
name|acpi_set_debugging
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ACPI_SERIAL_END
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_acpi
argument_list|,
name|OID_AUTO
argument_list|,
name|layer
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLTYPE_STRING
argument_list|,
literal|"debug.acpi.layer"
argument_list|,
literal|0
argument_list|,
name|acpi_debug_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_acpi
argument_list|,
name|OID_AUTO
argument_list|,
name|level
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLTYPE_STRING
argument_list|,
literal|"debug.acpi.level"
argument_list|,
literal|0
argument_list|,
name|acpi_debug_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ACPI_DEBUG */
end_comment

begin_function
specifier|static
name|int
name|acpi_pm_func
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|state
decl_stmt|,
name|acpi_state
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|POWER_CMD_SUSPEND
case|:
name|sc
operator|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|state
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|POWER_SLEEP_STATE_STANDBY
case|:
name|acpi_state
operator|=
name|sc
operator|->
name|acpi_standby_sx
expr_stmt|;
break|break;
case|case
name|POWER_SLEEP_STATE_SUSPEND
case|:
name|acpi_state
operator|=
name|sc
operator|->
name|acpi_suspend_sx
expr_stmt|;
break|break;
case|case
name|POWER_SLEEP_STATE_HIBERNATE
case|:
name|acpi_state
operator|=
name|ACPI_STATE_S4
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|acpi_SetSleepState
argument_list|(
name|sc
argument_list|,
name|acpi_state
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_pm_register
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cold
operator|||
name|resource_disabled
argument_list|(
literal|"acpi"
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|power_pm_register
argument_list|(
name|POWER_PM_TYPE_ACPI
argument_list|,
name|acpi_pm_func
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|power
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|acpi_pm_register
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

