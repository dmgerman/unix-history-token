begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Takanori Watanabe<takawata@jp.freebsd.org>  * Copyright (c) 2000 Mitsuru IWASAKI<iwasaki@jp.freebsd.org>  * Copyright (c) 2000, 2001 Michael Smith  * Copyright (c) 2000 BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|"acpi.h"
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpiio.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ACPIDEV
argument_list|,
literal|"acpidev"
argument_list|,
literal|"ACPI devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Hooks for the ACPI CA debugging infrastructure  */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_BUS
end_define

begin_macro
name|MODULE_NAME
argument_list|(
literal|"ACPI"
argument_list|)
end_macro

begin_comment
comment|/*  * Character device   */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|acpiopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|acpiclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|acpiioctl
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|152
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|acpi_cdevsw
init|=
block|{
name|acpiopen
block|,
name|acpiclose
block|,
name|noread
block|,
name|nowrite
block|,
name|acpiioctl
block|,
name|nopoll
block|,
name|nommap
block|,
name|nostrategy
block|,
literal|"acpi"
block|,
name|CDEV_MAJOR
block|,
name|nodump
block|,
name|nopsize
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sleep_state_names
index|[]
init|=
block|{
literal|"S0"
block|,
literal|"S1"
block|,
literal|"S2"
block|,
literal|"S3"
block|,
literal|"S4"
block|,
literal|"S5"
block|,
literal|"S4B"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this has to be static, as the softc is gone when we need it */
end_comment

begin_decl_stmt
specifier|static
name|int
name|acpi_off_state
init|=
name|ACPI_STATE_S5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|acpi_mutex
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|acpi_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|device_t
name|acpi_add_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|int
name|order
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_print_resources
parameter_list|(
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_print_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_set_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_get_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|u_long
modifier|*
name|startp
parameter_list|,
name|u_long
modifier|*
name|countp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|resource
modifier|*
name|acpi_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_release_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_probe_children
parameter_list|(
name|device_t
name|bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_probe_child
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_shutdown_pre_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_shutdown_final
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_enable_fixed_events
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_system_eventhandler_sleep
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_system_eventhandler_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_sleep_state_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|acpi_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|acpi_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|acpi_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|acpi_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_add_child
argument_list|,
name|acpi_add_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|acpi_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|acpi_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|acpi_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_set_resource
argument_list|,
name|acpi_set_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource
argument_list|,
name|acpi_get_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|acpi_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|acpi_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bus_generic_teardown_intr
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|acpi_driver
init|=
block|{
literal|"acpi"
block|,
name|acpi_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|acpi_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|acpi
argument_list|,
name|nexus
argument_list|,
name|acpi_driver
argument_list|,
name|acpi_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|acpi_debug_layer
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|AcpiDbgLayer
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|acpi_debug_level
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|AcpiDbgLevel
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Detect ACPI, perform early initialisation  */
end_comment

begin_function
specifier|static
name|void
name|acpi_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_DEBUGGER
name|char
modifier|*
name|debugpoint
init|=
name|getenv
argument_list|(
literal|"debug.acpi.debugger"
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cold
condition|)
block|{
name|printf
argument_list|(
literal|"Don't load this driver from userland!!\n"
argument_list|)
expr_stmt|;
return|return ;
block|}
comment|/*      * Make sure we're not being doubly invoked.      */
if|if
condition|(
name|device_find_child
argument_list|(
name|parent
argument_list|,
literal|"acpi"
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL
condition|)
name|return_VOID
expr_stmt|;
comment|/* initialise the ACPI mutex */
name|mtx_init
argument_list|(
operator|&
name|acpi_mutex
argument_list|,
literal|"ACPI global lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/*      * Start up the ACPI CA subsystem.      */
ifdef|#
directive|ifdef
name|ENABLE_DEBUGGER
if|if
condition|(
name|debugpoint
operator|&&
operator|!
name|strcmp
argument_list|(
name|debugpoint
argument_list|,
literal|"init"
argument_list|)
condition|)
name|acpi_EnterDebugger
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|AcpiInitializeSubsystem
argument_list|()
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI: initialisation failed: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_DEBUGGER
if|if
condition|(
name|debugpoint
operator|&&
operator|!
name|strcmp
argument_list|(
name|debugpoint
argument_list|,
literal|"tables"
argument_list|)
condition|)
name|acpi_EnterDebugger
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|AcpiLoadTables
argument_list|()
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI: table load failed: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
comment|/*      * Attach the actual ACPI device.      */
if|if
condition|(
operator|(
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"acpi"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"ACPI: could not attach\n"
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Fetch some descriptive data from ACPI to put in our attach message  */
end_comment

begin_function
specifier|static
name|int
name|acpi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_TABLE_HEADER
name|th
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|error
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_LOCK
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|AcpiGetTableHeader
argument_list|(
name|ACPI_TABLE_XSDT
argument_list|,
literal|1
argument_list|,
operator|&
name|th
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't get XSDT header: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.6s %.8s"
argument_list|,
name|th
operator|.
name|OemId
argument_list|,
name|th
operator|.
name|OemTableId
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|ACPI_UNLOCK
expr_stmt|;
name|return_VALUE
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_DEBUGGER
name|char
modifier|*
name|debugpoint
init|=
name|getenv
argument_list|(
literal|"debug.acpi.debugger"
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_LOCK
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_dev
operator|=
name|dev
expr_stmt|;
name|acpi_install_wakeup_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_DEBUGGER
if|if
condition|(
name|debugpoint
operator|&&
operator|!
name|strcmp
argument_list|(
name|debugpoint
argument_list|,
literal|"spaces"
argument_list|)
condition|)
name|acpi_EnterDebugger
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/*      * Install the default address space handlers.      */
name|error
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|AcpiInstallAddressSpaceHandler
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_ADR_SPACE_SYSTEM_MEMORY
argument_list|,
name|ACPI_DEFAULT_HANDLER
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not initialise SystemMemory handler: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|AcpiInstallAddressSpaceHandler
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_ADR_SPACE_SYSTEM_IO
argument_list|,
name|ACPI_DEFAULT_HANDLER
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not initialise SystemIO handler: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|AcpiInstallAddressSpaceHandler
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_ADR_SPACE_PCI_CONFIG
argument_list|,
name|ACPI_DEFAULT_HANDLER
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not initialise PciConfig handler: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Bring ACPI fully online.      *      * Note that we request that device _STA and _INI methods not be run (ACPI_NO_DEVICE_INIT)      * and the final object initialisation pass be skipped (ACPI_NO_OBJECT_INIT).       *      * XXX We need to arrange for the object init pass after we have attached all our       *     child devices.      */
ifdef|#
directive|ifdef
name|ENABLE_DEBUGGER
if|if
condition|(
name|debugpoint
operator|&&
operator|!
name|strcmp
argument_list|(
name|debugpoint
argument_list|,
literal|"enable"
argument_list|)
condition|)
name|acpi_EnterDebugger
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|status
operator|=
name|AcpiEnableSubsystem
argument_list|(
name|ACPI_NO_DEVICE_INIT
operator||
name|ACPI_NO_OBJECT_INIT
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not enable ACPI: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Setup our sysctl tree.      *      * XXX: This doesn't check to make sure that none of these fail.      */
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"power_button_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_power_button_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sleep_button_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_sleep_button_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lid_switch_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_lid_switch_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/*      * Dispatch the default sleep state to devices.      * TBD: should be configured from userland policy manager.      */
name|sc
operator|->
name|acpi_power_button_sx
operator|=
name|ACPI_POWER_BUTTON_DEFAULT_SX
expr_stmt|;
name|sc
operator|->
name|acpi_sleep_button_sx
operator|=
name|ACPI_SLEEP_BUTTON_DEFAULT_SX
expr_stmt|;
name|sc
operator|->
name|acpi_lid_switch_sx
operator|=
name|ACPI_LID_SWITCH_DEFAULT_SX
expr_stmt|;
name|acpi_enable_fixed_events
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Scan the namespace and attach/initialise children.      */
ifdef|#
directive|ifdef
name|ENABLE_DEBUGGER
if|if
condition|(
name|debugpoint
operator|&&
operator|!
name|strcmp
argument_list|(
name|debugpoint
argument_list|,
literal|"probe"
argument_list|)
condition|)
name|acpi_EnterDebugger
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|acpi_disabled
argument_list|(
literal|"bus"
argument_list|)
condition|)
name|acpi_probe_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/*      * Register our shutdown handlers      */
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_pre_sync
argument_list|,
name|acpi_shutdown_pre_sync
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_LAST
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|acpi_shutdown_final
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_LAST
argument_list|)
expr_stmt|;
comment|/*      * Register our acpi event handlers.      * XXX should be configurable eg. via userland policy manager.      */
name|EVENTHANDLER_REGISTER
argument_list|(
name|acpi_sleep_event
argument_list|,
name|acpi_system_eventhandler_sleep
argument_list|,
name|sc
argument_list|,
name|ACPI_EVENT_PRI_LAST
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|acpi_wakeup_event
argument_list|,
name|acpi_system_eventhandler_wakeup
argument_list|,
name|sc
argument_list|,
name|ACPI_EVENT_PRI_LAST
argument_list|)
expr_stmt|;
comment|/*      * Flag our initial states.      */
name|sc
operator|->
name|acpi_enabled
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|acpi_sstate
operator|=
name|ACPI_STATE_S0
expr_stmt|;
comment|/*      * Create the control device      */
name|sc
operator|->
name|acpi_dev_t
operator|=
name|make_dev
argument_list|(
operator|&
name|acpi_cdevsw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|0660
argument_list|,
literal|"acpi"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_dev_t
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_DEBUGGER
if|if
condition|(
name|debugpoint
operator|&&
operator|!
name|strcmp
argument_list|(
name|debugpoint
argument_list|,
literal|"running"
argument_list|)
condition|)
name|acpi_EnterDebugger
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|ACPI_UNLOCK
expr_stmt|;
name|return_VALUE
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a new device being added  */
end_comment

begin_function
specifier|static
name|device_t
name|acpi_add_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|int
name|order
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
name|device_t
name|child
decl_stmt|;
if|if
condition|(
operator|(
name|ad
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ad
argument_list|)
argument_list|,
name|M_ACPIDEV
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|ad
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ad
argument_list|)
argument_list|)
expr_stmt|;
name|resource_list_init
argument_list|(
operator|&
name|ad
operator|->
name|ad_rl
argument_list|)
expr_stmt|;
name|child
operator|=
name|device_add_child_ordered
argument_list|(
name|bus
argument_list|,
name|order
argument_list|,
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|ad
argument_list|)
expr_stmt|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print child device resource usage  */
end_comment

begin_function
specifier|static
name|int
name|acpi_print_resources
parameter_list|(
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|printed
decl_stmt|,
name|retval
decl_stmt|;
name|printed
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_FIRST
argument_list|(
name|rl
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Yes, this is kinda cheating */
name|SLIST_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|rl
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|rle
operator|->
name|type
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|printed
operator|==
literal|0
condition|)
name|retval
operator|+=
name|printf
argument_list|(
literal|" %s "
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|printed
operator|>
literal|0
condition|)
name|retval
operator|+=
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printed
operator|++
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
name|format
argument_list|,
name|rle
operator|->
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|count
operator|>
literal|1
condition|)
block|{
name|retval
operator|+=
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
name|format
argument_list|,
name|rle
operator|->
name|start
operator|+
name|rle
operator|->
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_print_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|adev
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|adev
operator|->
name|ad_rl
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|acpi_print_resources
argument_list|(
name|rl
argument_list|,
literal|"port"
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|"%#lx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|acpi_print_resources
argument_list|(
name|rl
argument_list|,
literal|"iomem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#lx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|acpi_print_resources
argument_list|(
name|rl
argument_list|,
literal|"irq"
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|"%ld"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle per-device ivars  */
end_comment

begin_function
specifier|static
name|int
name|acpi_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
if|if
condition|(
operator|(
name|ad
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"device has no ivars\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
comment|/* ACPI ivars */
case|case
name|ACPI_IVAR_HANDLE
case|:
operator|*
operator|(
name|ACPI_HANDLE
operator|*
operator|)
name|result
operator|=
name|ad
operator|->
name|ad_handle
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_MAGIC
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|ad
operator|->
name|ad_magic
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_PRIVATE
case|:
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|result
operator|=
name|ad
operator|->
name|ad_private
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"bad ivar read request (%d)\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
if|if
condition|(
operator|(
name|ad
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"device has no ivars\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
comment|/* ACPI ivars */
case|case
name|ACPI_IVAR_HANDLE
case|:
name|ad
operator|->
name|ad_handle
operator|=
operator|(
name|ACPI_HANDLE
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_MAGIC
case|:
name|ad
operator|->
name|ad_magic
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_PRIVATE
case|:
name|ad
operator|->
name|ad_private
operator|=
operator|(
name|void
operator|*
operator|)
name|value
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"bad ivar write request (%d)\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle child resource allocation/removal  */
end_comment

begin_function
specifier|static
name|int
name|acpi_set_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|count
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|ad
operator|->
name|ad_rl
decl_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|count
operator|-
literal|1
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_get_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|u_long
modifier|*
name|startp
parameter_list|,
name|u_long
modifier|*
name|countp
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|ad
operator|->
name|ad_rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rle
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|startp
condition|)
operator|*
name|startp
operator|=
name|rle
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|countp
condition|)
operator|*
name|countp
operator|=
name|rle
operator|->
name|count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|acpi_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|ad
operator|->
name|ad_rl
decl_stmt|;
return|return
operator|(
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_release_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|ad
operator|->
name|ad_rl
decl_stmt|;
return|return
operator|(
name|resource_list_release
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scan relevant portions of the ACPI namespace and attach child devices.  *  * Note that we only expect to find devices in the \_PR_, \_TZ_, \_SI_ and \_SB_ scopes,   * and \_PR_ and \_TZ_ become obsolete in the ACPI 2.0 spec.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_probe_children
parameter_list|(
name|device_t
name|bus
parameter_list|)
block|{
name|ACPI_HANDLE
name|parent
decl_stmt|;
specifier|static
name|char
modifier|*
name|scopes
index|[]
init|=
block|{
literal|"\\_PR_"
block|,
literal|"\\_TZ_"
block|,
literal|"\\_SI"
block|,
literal|"\\_SB_"
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
comment|/*      * Create any static children by calling device identify methods.      */
name|DEBUG_PRINT
argument_list|(
name|TRACE_OBJECTS
argument_list|,
operator|(
literal|"device identify routines\n"
operator|)
argument_list|)
expr_stmt|;
name|bus_generic_probe
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/*      * Scan the namespace and insert placeholders for all the devices that      * we find.      *      * Note that we use AcpiWalkNamespace rather than AcpiGetDevices because      * we want to create nodes for all devices, not just those that are currently      * present. (This assumes that we don't want to create/remove devices as they      * appear, which might be smarter.)      */
name|DEBUG_PRINT
argument_list|(
name|TRACE_OBJECTS
argument_list|,
operator|(
literal|"namespace scan\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scopes
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|AcpiGetHandle
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
name|scopes
index|[
name|i
index|]
argument_list|,
operator|&
name|parent
argument_list|)
operator|)
operator|==
name|AE_OK
condition|)
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|parent
argument_list|,
literal|100
argument_list|,
name|acpi_probe_child
argument_list|,
name|bus
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * Scan all of the child devices we have created and let them probe/attach.      */
name|DEBUG_PRINT
argument_list|(
name|TRACE_OBJECTS
argument_list|,
operator|(
literal|"first bus_generic_attach\n"
operator|)
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/*      * Some of these children may have attached others as part of their attach      * process (eg. the root PCI bus driver), so rescan.      */
name|DEBUG_PRINT
argument_list|(
name|TRACE_OBJECTS
argument_list|,
operator|(
literal|"second bus_generic_attach\n"
operator|)
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a child device and determine whether we might attach a device to  * it.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_probe_child
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
modifier|*
name|status
parameter_list|)
block|{
name|ACPI_OBJECT_TYPE
name|type
decl_stmt|;
name|device_t
name|child
decl_stmt|,
name|bus
init|=
operator|(
name|device_t
operator|)
name|context
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
comment|/*      * Skip this device if we think we'll have trouble with it.      */
if|if
condition|(
name|acpi_avoid
argument_list|(
name|handle
argument_list|)
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|AcpiGetType
argument_list|(
name|handle
argument_list|,
operator|&
name|type
argument_list|)
operator|==
name|AE_OK
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ACPI_TYPE_DEVICE
case|:
case|case
name|ACPI_TYPE_PROCESSOR
case|:
case|case
name|ACPI_TYPE_THERMAL
case|:
case|case
name|ACPI_TYPE_POWER
case|:
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"children"
argument_list|)
condition|)
break|break;
comment|/*  	     * Create a placeholder device for this node.  Sort the placeholder 	     * so that the probe/attach passes will run breadth-first. 	     */
name|DEBUG_PRINT
argument_list|(
argument|TRACE_OBJECTS
argument_list|,
argument|(
literal|"scanning '%s'\n"
argument|, acpi_name(handle))
argument_list|)
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|bus
argument_list|,
name|level
operator|*
literal|10
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|acpi_set_handle
argument_list|(
name|child
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|DEBUG_EXEC
argument_list|(
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_shutdown_pre_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|ACPI_ASSERTLOCK
expr_stmt|;
comment|/*      * Disable all ACPI events before soft off, otherwise the system      * will be turned on again on some laptops.      *      * XXX this should probably be restricted to masking some events just      *     before powering down, since we may still need ACPI during the      *     shutdown process.      */
name|acpi_Disable
argument_list|(
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_shutdown_final
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
if|if
condition|(
name|howto
operator|&
name|RB_POWEROFF
condition|)
block|{
name|printf
argument_list|(
literal|"Power system off using ACPI...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|AcpiEnterSleepState
argument_list|(
name|acpi_off_state
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI power-off failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ACPI power-off failed - timeout\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_enable_fixed_events
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|int
name|first_time
init|=
literal|1
decl_stmt|;
define|#
directive|define
name|MSGFORMAT
value|"%s button is handled as a fixed feature programming model.\n"
name|ACPI_ASSERTLOCK
expr_stmt|;
comment|/* Enable and clear fixed events and install handlers. */
if|if
condition|(
operator|(
name|AcpiGbl_FADT
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|AcpiGbl_FADT
operator|->
name|PwrButton
operator|==
literal|0
operator|)
condition|)
block|{
name|AcpiEnableEvent
argument_list|(
name|ACPI_EVENT_POWER_BUTTON
argument_list|,
name|ACPI_EVENT_FIXED
argument_list|)
expr_stmt|;
name|AcpiClearEvent
argument_list|(
name|ACPI_EVENT_POWER_BUTTON
argument_list|,
name|ACPI_EVENT_FIXED
argument_list|)
expr_stmt|;
name|AcpiInstallFixedEventHandler
argument_list|(
name|ACPI_EVENT_POWER_BUTTON
argument_list|,
name|acpi_eventhandler_power_button_for_sleep
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_time
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
name|MSGFORMAT
argument_list|,
literal|"power"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|AcpiGbl_FADT
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|AcpiGbl_FADT
operator|->
name|SleepButton
operator|==
literal|0
operator|)
condition|)
block|{
name|AcpiEnableEvent
argument_list|(
name|ACPI_EVENT_SLEEP_BUTTON
argument_list|,
name|ACPI_EVENT_FIXED
argument_list|)
expr_stmt|;
name|AcpiClearEvent
argument_list|(
name|ACPI_EVENT_SLEEP_BUTTON
argument_list|,
name|ACPI_EVENT_FIXED
argument_list|)
expr_stmt|;
name|AcpiInstallFixedEventHandler
argument_list|(
name|ACPI_EVENT_SLEEP_BUTTON
argument_list|,
name|acpi_eventhandler_sleep_button_for_sleep
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_time
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
name|MSGFORMAT
argument_list|,
literal|"sleep"
argument_list|)
expr_stmt|;
block|}
block|}
name|first_time
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the device is actually present and should  * be attached to.  This requires the present, enabled, UI-visible   * and diagnostics-passed bits to be set.  */
end_comment

begin_function
name|BOOLEAN
name|acpi_DeviceIsPresent
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_DEVICE_INFO
name|devinfo
decl_stmt|;
name|ACPI_STATUS
name|error
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|devinfo
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* XXX 0xf is probably not appropriate */
if|if
condition|(
operator|(
name|devinfo
operator|.
name|Valid
operator|&
name|ACPI_VALID_HID
operator|)
operator|&&
operator|(
name|devinfo
operator|.
name|CurrentStatus
operator|&
literal|0xf
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Match a HID string against a device  */
end_comment

begin_function
name|BOOLEAN
name|acpi_MatchHid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|char
modifier|*
name|hid
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_DEVICE_INFO
name|devinfo
decl_stmt|;
name|ACPI_STATUS
name|error
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
if|if
condition|(
name|hid
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|devinfo
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|devinfo
operator|.
name|Valid
operator|&
name|ACPI_VALID_HID
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|hid
argument_list|,
name|devinfo
operator|.
name|HardwareId
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the handle of a named object within our scope, ie. that of (parent)  * or one if its parents.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_GetHandleInScope
parameter_list|(
name|ACPI_HANDLE
name|parent
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|ACPI_HANDLE
modifier|*
name|result
parameter_list|)
block|{
name|ACPI_HANDLE
name|r
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
comment|/* walk back up the tree to the root */
for|for
control|(
init|;
condition|;
control|)
block|{
name|status
operator|=
name|AcpiGetHandle
argument_list|(
name|parent
argument_list|,
name|path
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|AE_OK
condition|)
block|{
operator|*
name|result
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
if|if
condition|(
name|status
operator|!=
name|AE_NOT_FOUND
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
if|if
condition|(
name|AcpiGetParent
argument_list|(
name|parent
argument_list|,
operator|&
name|r
argument_list|)
operator|!=
name|AE_OK
condition|)
return|return
operator|(
name|AE_NOT_FOUND
operator|)
return|;
name|parent
operator|=
name|r
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a buffer with a preset data size.  */
end_comment

begin_function
name|ACPI_BUFFER
modifier|*
name|acpi_AllocBuffer
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|ACPI_BUFFER
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|size
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|M_ACPIDEV
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|buf
operator|->
name|Length
operator|=
name|size
expr_stmt|;
name|buf
operator|->
name|Pointer
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform the tedious double-get procedure required for fetching something into  * an ACPI_BUFFER that has not been initialised.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_GetIntoBuffer
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|ACPI_STATUS
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|ACPI_HANDLE
parameter_list|,
name|ACPI_BUFFER
modifier|*
parameter_list|)
parameter_list|,
name|ACPI_BUFFER
modifier|*
name|buf
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
name|buf
operator|->
name|Length
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|Pointer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|func
argument_list|(
name|handle
argument_list|,
name|buf
argument_list|)
operator|)
operator|!=
name|AE_BUFFER_OVERFLOW
condition|)
return|return
operator|(
name|status
operator|)
return|;
if|if
condition|(
operator|(
name|buf
operator|->
name|Pointer
operator|=
name|AcpiOsCallocate
argument_list|(
name|buf
operator|->
name|Length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
return|return
operator|(
name|func
argument_list|(
name|handle
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform the tedious double-get procedure required for fetching a table into  * an ACPI_BUFFER that has not been initialised.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_GetTableIntoBuffer
parameter_list|(
name|ACPI_TABLE_TYPE
name|table
parameter_list|,
name|UINT32
name|instance
parameter_list|,
name|ACPI_BUFFER
modifier|*
name|buf
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
name|buf
operator|->
name|Length
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|Pointer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|AcpiGetTable
argument_list|(
name|table
argument_list|,
name|instance
argument_list|,
name|buf
argument_list|)
operator|)
operator|!=
name|AE_BUFFER_OVERFLOW
condition|)
return|return
operator|(
name|status
operator|)
return|;
if|if
condition|(
operator|(
name|buf
operator|->
name|Pointer
operator|=
name|AcpiOsCallocate
argument_list|(
name|buf
operator|->
name|Length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
return|return
operator|(
name|AcpiGetTable
argument_list|(
name|table
argument_list|,
name|instance
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform the tedious double-evaluate procedure for evaluating something into  * an ACPI_BUFFER that has not been initialised.  Note that this evaluates  * twice, so avoid applying this to things that may have side-effects.  *  * This is like AcpiEvaluateObject with automatic buffer allocation.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_EvaluateIntoBuffer
parameter_list|(
name|ACPI_HANDLE
name|object
parameter_list|,
name|ACPI_STRING
name|pathname
parameter_list|,
name|ACPI_OBJECT_LIST
modifier|*
name|params
parameter_list|,
name|ACPI_BUFFER
modifier|*
name|buf
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
name|buf
operator|->
name|Length
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|Pointer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|object
argument_list|,
name|pathname
argument_list|,
name|params
argument_list|,
name|buf
argument_list|)
operator|)
operator|!=
name|AE_BUFFER_OVERFLOW
condition|)
return|return
operator|(
name|status
operator|)
return|;
if|if
condition|(
operator|(
name|buf
operator|->
name|Pointer
operator|=
name|AcpiOsCallocate
argument_list|(
name|buf
operator|->
name|Length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
return|return
operator|(
name|AcpiEvaluateObject
argument_list|(
name|object
argument_list|,
name|pathname
argument_list|,
name|params
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a path that should return an integer.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_EvaluateInteger
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
modifier|*
name|number
parameter_list|)
block|{
name|ACPI_STATUS
name|error
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_OBJECT
name|param
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
name|handle
operator|=
name|ACPI_ROOT_OBJECT
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
operator|&
name|param
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
sizeof|sizeof
argument_list|(
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|AcpiEvaluateObject
argument_list|(
name|handle
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
operator|)
operator|==
name|AE_OK
condition|)
block|{
if|if
condition|(
name|param
operator|.
name|Type
operator|==
name|ACPI_TYPE_INTEGER
condition|)
block|{
operator|*
name|number
operator|=
name|param
operator|.
name|Integer
operator|.
name|Value
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|AE_TYPE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over the elements of an a package object, calling the supplied  * function for each element.  *  * XXX possible enhancement might be to abort traversal on error.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_ForeachPackageObject
parameter_list|(
name|ACPI_OBJECT
modifier|*
name|pkg
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|ACPI_OBJECT
modifier|*
name|comp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ACPI_OBJECT
modifier|*
name|comp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|pkg
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pkg
operator|->
name|Type
operator|!=
name|ACPI_TYPE_PACKAGE
operator|)
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
comment|/* iterate over components */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|comp
operator|=
name|pkg
operator|->
name|Package
operator|.
name|Elements
init|;
name|i
operator|<
name|pkg
operator|->
name|Package
operator|.
name|Count
condition|;
name|i
operator|++
operator|,
name|comp
operator|++
control|)
name|func
argument_list|(
name|comp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the (index)th resource object in a set.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_FindIndexedResource
parameter_list|(
name|ACPI_RESOURCE
modifier|*
name|resbuf
parameter_list|,
name|int
name|index
parameter_list|,
name|ACPI_RESOURCE
modifier|*
modifier|*
name|resp
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|resbuf
expr_stmt|;
name|i
operator|=
name|index
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* range check */
if|if
condition|(
name|p
operator|>
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|resbuf
operator|+
name|resbuf
operator|->
name|Length
operator|)
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
name|p
operator|+=
operator|(
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
name|p
operator|)
operator|->
name|Length
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|resp
operator|!=
name|NULL
condition|)
operator|*
name|resp
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
name|p
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|__inline
name|acpi_wakeup
parameter_list|(
name|UINT8
name|state
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_OBJECT_LIST
name|Arg_list
decl_stmt|;
name|ACPI_OBJECT
name|Arg
decl_stmt|;
name|ACPI_OBJECT
name|Objects
index|[
literal|3
index|]
decl_stmt|;
comment|/* package plus 2 number objects */
name|ACPI_BUFFER
name|ReturnBuffer
decl_stmt|;
name|FUNCTION_TRACE_U32
argument_list|(
name|__func__
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
comment|/*      * Evaluate the _WAK method      */
name|bzero
argument_list|(
operator|&
name|Arg_list
argument_list|,
sizeof|sizeof
argument_list|(
name|Arg_list
argument_list|)
argument_list|)
expr_stmt|;
name|Arg_list
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|Arg_list
operator|.
name|Pointer
operator|=
operator|&
name|Arg
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|Arg
argument_list|,
sizeof|sizeof
argument_list|(
name|Arg
argument_list|)
argument_list|)
expr_stmt|;
name|Arg
operator|.
name|Type
operator|=
name|ACPI_TYPE_INTEGER
expr_stmt|;
name|Arg
operator|.
name|Integer
operator|.
name|Value
operator|=
name|state
expr_stmt|;
comment|/*       * Set up _WAK result code buffer.      *      * XXX should use acpi_EvaluateIntoBuffer      */
name|bzero
argument_list|(
name|Objects
argument_list|,
sizeof|sizeof
argument_list|(
name|Objects
argument_list|)
argument_list|)
expr_stmt|;
name|ReturnBuffer
operator|.
name|Length
operator|=
sizeof|sizeof
argument_list|(
name|Objects
argument_list|)
expr_stmt|;
name|ReturnBuffer
operator|.
name|Pointer
operator|=
name|Objects
expr_stmt|;
name|AcpiEvaluateObject
argument_list|(
name|NULL
argument_list|,
literal|"\\_WAK"
argument_list|,
operator|&
name|Arg_list
argument_list|,
operator|&
name|ReturnBuffer
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AE_OK
expr_stmt|;
comment|/* Check result code for _WAK */
if|if
condition|(
name|Objects
index|[
literal|0
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_PACKAGE
operator|||
name|Objects
index|[
literal|1
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_INTEGER
operator|||
name|Objects
index|[
literal|2
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_INTEGER
condition|)
block|{
comment|/* 	 * In many BIOSes, _WAK doesn't return a result code. 	 * We don't need to worry about it too much :-). 	 */
name|DEBUG_PRINT
argument_list|(
name|ACPI_INFO
argument_list|,
operator|(
literal|"acpi_wakeup: _WAK result code is corrupted, "
literal|"but should be OK.\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* evaluate status code */
switch|switch
condition|(
name|Objects
index|[
literal|1
index|]
operator|.
name|Integer
operator|.
name|Value
condition|)
block|{
case|case
literal|0x00000001
case|:
name|DEBUG_PRINT
argument_list|(
name|ACPI_ERROR
argument_list|,
operator|(
literal|"acpi_wakeup: Wake was signaled "
literal|"but failed due to lack of power.\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AE_ERROR
expr_stmt|;
break|break;
case|case
literal|0x00000002
case|:
name|DEBUG_PRINT
argument_list|(
name|ACPI_ERROR
argument_list|,
operator|(
literal|"acpi_wakeup: Wake was signaled "
literal|"but failed due to thermal condition.\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AE_ERROR
expr_stmt|;
break|break;
block|}
comment|/* evaluate PSS code */
if|if
condition|(
name|Objects
index|[
literal|2
index|]
operator|.
name|Integer
operator|.
name|Value
operator|==
literal|0
condition|)
block|{
name|DEBUG_PRINT
argument_list|(
name|ACPI_ERROR
argument_list|,
operator|(
literal|"acpi_wakeup: The targeted S-state "
literal|"was not entered because of too much current "
literal|"being drawn from the power supply.\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AE_ERROR
expr_stmt|;
block|}
block|}
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the system sleep state  *  * Currently we only support S1 and S5  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_SetSleepState
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|ACPI_STATUS
name|status
init|=
name|AE_OK
decl_stmt|;
name|UINT16
name|Count
decl_stmt|;
name|FUNCTION_TRACE_U32
argument_list|(
name|__func__
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ACPI_STATE_S0
case|:
comment|/* XXX only for testing */
name|status
operator|=
name|AcpiEnterSleepState
argument_list|(
operator|(
name|UINT8
operator|)
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|AE_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"AcpiEnterSleepState failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACPI_STATE_S1
case|:
case|case
name|ACPI_STATE_S2
case|:
case|case
name|ACPI_STATE_S3
case|:
case|case
name|ACPI_STATE_S4
case|:
comment|/* 	 * Inform all devices that we are going to sleep. 	 */
if|if
condition|(
name|DEVICE_SUSPEND
argument_list|(
name|root_bus
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 	     * Re-wake the system. 	     * 	     * XXX note that a better two-pass approach with a 'veto' pass 	     *     followed by a "real thing" pass would be better, but the 	     *     current bus interface does not provide for this. 	     */
name|DEVICE_RESUME
argument_list|(
name|root_bus
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_ERROR
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|acpi_sstate
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|ACPI_STATE_S1
condition|)
block|{
name|acpi_sleep_machdep
argument_list|(
name|sc
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* AcpiEnterSleepState() maybe incompleted, unlock here. */
name|AcpiUtReleaseMutex
argument_list|(
name|ACPI_MTX_HARDWARE
argument_list|)
expr_stmt|;
comment|/* Re-enable ACPI hardware on wakeup from sleep state 4. */
if|if
condition|(
name|state
operator|>=
name|ACPI_STATE_S4
condition|)
block|{
name|acpi_Disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|acpi_Enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|status
operator|=
name|AcpiEnterSleepState
argument_list|(
operator|(
name|UINT8
operator|)
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|AE_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"AcpiEnterSleepState failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* wait for the WAK_STS bit */
name|Count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|AcpiHwRegisterBitAccess
argument_list|(
name|ACPI_READ
argument_list|,
name|ACPI_MTX_LOCK
argument_list|,
name|WAK_STS
argument_list|)
operator|)
condition|)
block|{
name|AcpiOsSleep
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Some BIOSes don't set WAK_STS at all, 		 * give up waiting for wakeup if we time out. 		 */
if|if
condition|(
name|Count
operator|>
literal|1000
condition|)
block|{
break|break;
comment|/* giving up */
block|}
name|Count
operator|++
expr_stmt|;
block|}
block|}
name|acpi_wakeup
argument_list|(
operator|(
name|UINT8
operator|)
name|state
argument_list|)
expr_stmt|;
name|DEVICE_RESUME
argument_list|(
name|root_bus
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_sstate
operator|=
name|ACPI_STATE_S0
expr_stmt|;
name|acpi_enable_fixed_events
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_STATE_S5
case|:
comment|/* 	 * Shut down cleanly and power off.  This will call us back through the 	 * shutdown handlers. 	 */
name|shutdown_nice
argument_list|(
name|RB_POWEROFF
argument_list|)
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|AE_BAD_PARAMETER
expr_stmt|;
break|break;
block|}
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable/Disable ACPI  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_Enable
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
name|flags
operator|=
name|ACPI_NO_ADDRESS_SPACE_INIT
operator||
name|ACPI_NO_HARDWARE_INIT
operator||
name|ACPI_NO_DEVICE_INIT
operator||
name|ACPI_NO_OBJECT_INIT
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|acpi_enabled
condition|)
block|{
name|status
operator|=
name|AcpiEnableSubsystem
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|AE_OK
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|AE_OK
condition|)
name|sc
operator|->
name|acpi_enabled
operator|=
literal|1
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ACPI_STATUS
name|acpi_Disable
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|acpi_enabled
condition|)
block|{
name|status
operator|=
name|AcpiDisable
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|AE_OK
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|AE_OK
condition|)
name|sc
operator|->
name|acpi_enabled
operator|=
literal|0
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ACPI Event Handlers  */
end_comment

begin_comment
comment|/* System Event Handlers (registered by EVENTHANDLER_REGISTER) */
end_comment

begin_function
specifier|static
name|void
name|acpi_system_eventhandler_sleep
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|FUNCTION_TRACE_U32
argument_list|(
name|__func__
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ACPI_LOCK
expr_stmt|;
if|if
condition|(
name|state
operator|>=
name|ACPI_STATE_S0
operator|&&
name|state
operator|<=
name|ACPI_S_STATES_MAX
condition|)
name|acpi_SetSleepState
argument_list|(
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|arg
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ACPI_UNLOCK
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_system_eventhandler_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|FUNCTION_TRACE_U32
argument_list|(
name|__func__
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Well, what to do? :-) */
name|ACPI_LOCK
expr_stmt|;
name|ACPI_UNLOCK
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * ACPICA Event Handlers (FixedEvent, also called from button notify handler)  */
end_comment

begin_function
name|UINT32
name|acpi_eventhandler_power_button_for_sleep
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|acpi_sleep_event
argument_list|,
name|sc
operator|->
name|acpi_power_button_sx
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|UINT32
name|acpi_eventhandler_power_button_for_wakeup
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|acpi_wakeup_event
argument_list|,
name|sc
operator|->
name|acpi_power_button_sx
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|UINT32
name|acpi_eventhandler_sleep_button_for_sleep
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|acpi_sleep_event
argument_list|,
name|sc
operator|->
name|acpi_sleep_button_sx
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|UINT32
name|acpi_eventhandler_sleep_button_for_wakeup
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|acpi_wakeup_event
argument_list|,
name|sc
operator|->
name|acpi_sleep_button_sx
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX This is kinda ugly, and should not be here.  */
end_comment

begin_struct
struct|struct
name|acpi_staticbuf
block|{
name|ACPI_BUFFER
name|buffer
decl_stmt|;
name|char
name|data
index|[
literal|512
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|char
modifier|*
name|acpi_name
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|)
block|{
specifier|static
name|struct
name|acpi_staticbuf
name|buf
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
name|buf
operator|.
name|buffer
operator|.
name|Length
operator|=
literal|512
expr_stmt|;
name|buf
operator|.
name|buffer
operator|.
name|Pointer
operator|=
operator|&
name|buf
operator|.
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|AcpiGetName
argument_list|(
name|handle
argument_list|,
name|ACPI_FULL_PATHNAME
argument_list|,
operator|&
name|buf
operator|.
name|buffer
argument_list|)
operator|==
name|AE_OK
condition|)
return|return
operator|(
name|buf
operator|.
name|buffer
operator|.
name|Pointer
operator|)
return|;
return|return
operator|(
literal|"(unknown path)"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Debugging/bug-avoidance.  Avoid trying to fetch info on various  * parts of the namespace.  */
end_comment

begin_function
name|int
name|acpi_avoid
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|int
name|len
decl_stmt|;
name|np
operator|=
name|acpi_name
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|==
literal|'\\'
condition|)
name|np
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.avoid"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* scan the avoid list checking for a match */
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|0
operator|)
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
break|break;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|cp
index|[
name|len
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
name|cp
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
name|np
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|DEBUG_PRINT
argument_list|(
name|TRACE_OBJECTS
argument_list|,
operator|(
literal|"avoiding '%s'\n"
operator|,
name|np
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|len
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Debugging/bug-avoidance.  Disable ACPI subsystem components.  */
end_comment

begin_function
name|int
name|acpi_disabled
parameter_list|(
name|char
modifier|*
name|subsys
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.disable"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"all"
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* scan the disable list checking for a match */
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|0
operator|)
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
break|break;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|cp
index|[
name|len
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
name|cp
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
name|subsys
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|DEBUG_PRINT
argument_list|(
name|TRACE_OBJECTS
argument_list|,
operator|(
literal|"disabled '%s'\n"
operator|,
name|subsys
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|len
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Control interface.  *  * We multiplex ioctls for all participating ACPI devices here.  Individual   * drivers wanting to be accessible via /dev/acpi should use the register/deregister  * interface to make their handlers visible.  */
end_comment

begin_struct
struct|struct
name|acpi_ioctl_hook
block|{
name|TAILQ_ENTRY
argument_list|(
argument|acpi_ioctl_hook
argument_list|)
name|link
expr_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|int
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|acpi_ioctl_hook
argument_list|)
name|acpi_ioctl_hooks
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|acpi_ioctl_hooks_initted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Register an ioctl handler.  */
end_comment

begin_function
name|int
name|acpi_register_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|int
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|acpi_ioctl_hook
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hp
argument_list|)
argument_list|,
name|M_ACPIDEV
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|hp
operator|->
name|cmd
operator|=
name|cmd
expr_stmt|;
name|hp
operator|->
name|fn
operator|=
name|fn
expr_stmt|;
name|hp
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|acpi_ioctl_hooks_initted
operator|==
literal|0
condition|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|acpi_ioctl_hooks
argument_list|)
expr_stmt|;
name|acpi_ioctl_hooks_initted
operator|=
literal|1
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|acpi_ioctl_hooks
argument_list|,
name|hp
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deregister an ioctl handler.  */
end_comment

begin_function
name|void
name|acpi_deregister_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|int
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
parameter_list|)
block|{
name|struct
name|acpi_ioctl_hook
modifier|*
name|hp
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|hp
argument_list|,
argument|&acpi_ioctl_hooks
argument_list|,
argument|link
argument_list|)
if|if
condition|(
operator|(
name|hp
operator|->
name|cmd
operator|==
name|cmd
operator|)
operator|&&
operator|(
name|hp
operator|->
name|fn
operator|==
name|fn
operator|)
condition|)
break|break;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|acpi_ioctl_hooks
argument_list|,
name|hp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hp
argument_list|,
name|M_ACPIDEV
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|acpiopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpiclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpiioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|acpi_ioctl_hook
modifier|*
name|hp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|xerror
decl_stmt|,
name|state
decl_stmt|;
name|ACPI_LOCK
expr_stmt|;
name|error
operator|=
name|state
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
comment|/*      * Scan the list of registered ioctls, looking for handlers.      */
if|if
condition|(
name|acpi_ioctl_hooks_initted
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|hp
argument_list|,
argument|&acpi_ioctl_hooks
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|hp
operator|->
name|cmd
operator|==
name|cmd
condition|)
block|{
name|xerror
operator|=
name|hp
operator|->
name|fn
argument_list|(
name|cmd
argument_list|,
name|addr
argument_list|,
name|hp
operator|->
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|xerror
operator|!=
literal|0
condition|)
name|error
operator|=
name|xerror
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
comment|/*      * Core system ioctls.      */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ACPIIO_ENABLE
case|:
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|acpi_Enable
argument_list|(
name|sc
argument_list|)
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
case|case
name|ACPIIO_DISABLE
case|:
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|acpi_Disable
argument_list|(
name|sc
argument_list|)
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
case|case
name|ACPIIO_SETSLPSTATE
case|:
if|if
condition|(
operator|!
name|sc
operator|->
name|acpi_enabled
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|state
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|state
operator|>=
name|ACPI_STATE_S0
operator|&&
name|state
operator|<=
name|ACPI_S_STATES_MAX
condition|)
block|{
name|acpi_SetSleepState
argument_list|(
name|sc
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|out
label|:
name|ACPI_UNLOCK
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_sleep_state_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|sleep_state
index|[
literal|10
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|new_state
decl_stmt|,
name|old_state
decl_stmt|;
name|old_state
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
if|if
condition|(
name|old_state
operator|>
name|ACPI_S_STATES_MAX
condition|)
block|{
name|strcpy
argument_list|(
name|sleep_state
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|sleep_state
argument_list|,
name|sleep_state_names
index|[
name|old_state
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sleep_state_names
index|[
name|old_state
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sleep_state
argument_list|,
sizeof|sizeof
argument_list|(
name|sleep_state
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|new_state
operator|=
name|ACPI_STATE_S0
init|;
name|new_state
operator|<=
name|ACPI_S_STATES_MAX
condition|;
name|new_state
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|sleep_state
argument_list|,
name|sleep_state_names
index|[
name|new_state
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sleep_state
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|new_state
operator|!=
name|old_state
operator|)
operator|&&
operator|(
name|new_state
operator|<=
name|ACPI_S_STATES_MAX
operator|)
condition|)
block|{
operator|*
operator|(
name|u_int
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|=
name|new_state
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ACPI_DEBUG
end_ifdef

begin_comment
comment|/*  * Support for parsing debug options from the kernel environment.  *  * Bits may be set in the AcpiDbgLayer and AcpiDbgLevel debug registers  * by specifying the names of the bits in the debug.acpi.layer and  * debug.acpi.level environment variables.  Bits may be unset by   * prefixing the bit name with !.  */
end_comment

begin_struct
struct|struct
name|debugtag
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|UINT32
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|debugtag
name|dbg_layer
index|[]
init|=
block|{
block|{
literal|"ACPI_UTILITIES"
block|,
name|ACPI_UTILITIES
block|}
block|,
block|{
literal|"ACPI_HARDWARE"
block|,
name|ACPI_HARDWARE
block|}
block|,
block|{
literal|"ACPI_EVENTS"
block|,
name|ACPI_EVENTS
block|}
block|,
block|{
literal|"ACPI_TABLES"
block|,
name|ACPI_TABLES
block|}
block|,
block|{
literal|"ACPI_NAMESPACE"
block|,
name|ACPI_NAMESPACE
block|}
block|,
block|{
literal|"ACPI_PARSER"
block|,
name|ACPI_PARSER
block|}
block|,
block|{
literal|"ACPI_DISPATCHER"
block|,
name|ACPI_DISPATCHER
block|}
block|,
block|{
literal|"ACPI_EXECUTER"
block|,
name|ACPI_EXECUTER
block|}
block|,
block|{
literal|"ACPI_RESOURCES"
block|,
name|ACPI_RESOURCES
block|}
block|,
block|{
literal|"ACPI_POWER"
block|,
name|ACPI_POWER
block|}
block|,
block|{
literal|"ACPI_BUS"
block|,
name|ACPI_BUS
block|}
block|,
block|{
literal|"ACPI_POWER"
block|,
name|ACPI_POWER
block|}
block|,
block|{
literal|"ACPI_EC"
block|,
name|ACPI_EC
block|}
block|,
block|{
literal|"ACPI_PROCESSOR"
block|,
name|ACPI_PROCESSOR
block|}
block|,
block|{
literal|"ACPI_AC_ADAPTER"
block|,
name|ACPI_AC_ADAPTER
block|}
block|,
block|{
literal|"ACPI_BATTERY"
block|,
name|ACPI_BATTERY
block|}
block|,
block|{
literal|"ACPI_BUTTON"
block|,
name|ACPI_BUTTON
block|}
block|,
block|{
literal|"ACPI_SYSTEM"
block|,
name|ACPI_SYSTEM
block|}
block|,
block|{
literal|"ACPI_THERMAL"
block|,
name|ACPI_THERMAL
block|}
block|,
block|{
literal|"ACPI_DEBUGGER"
block|,
name|ACPI_DEBUGGER
block|}
block|,
block|{
literal|"ACPI_OS_SERVICES"
block|,
name|ACPI_OS_SERVICES
block|}
block|,
block|{
literal|"ACPI_ALL_COMPONENTS"
block|,
name|ACPI_ALL_COMPONENTS
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|debugtag
name|dbg_level
index|[]
init|=
block|{
block|{
literal|"ACPI_OK"
block|,
name|ACPI_OK
block|}
block|,
block|{
literal|"ACPI_INFO"
block|,
name|ACPI_INFO
block|}
block|,
block|{
literal|"ACPI_WARN"
block|,
name|ACPI_WARN
block|}
block|,
block|{
literal|"ACPI_ERROR"
block|,
name|ACPI_ERROR
block|}
block|,
block|{
literal|"ACPI_FATAL"
block|,
name|ACPI_FATAL
block|}
block|,
block|{
literal|"ACPI_DEBUG_OBJECT"
block|,
name|ACPI_DEBUG_OBJECT
block|}
block|,
block|{
literal|"ACPI_ALL"
block|,
name|ACPI_ALL
block|}
block|,
block|{
literal|"TRACE_THREADS"
block|,
name|TRACE_THREADS
block|}
block|,
block|{
literal|"TRACE_PARSE"
block|,
name|TRACE_PARSE
block|}
block|,
block|{
literal|"TRACE_DISPATCH"
block|,
name|TRACE_DISPATCH
block|}
block|,
block|{
literal|"TRACE_LOAD"
block|,
name|TRACE_LOAD
block|}
block|,
block|{
literal|"TRACE_EXEC"
block|,
name|TRACE_EXEC
block|}
block|,
block|{
literal|"TRACE_NAMES"
block|,
name|TRACE_NAMES
block|}
block|,
block|{
literal|"TRACE_OPREGION"
block|,
name|TRACE_OPREGION
block|}
block|,
block|{
literal|"TRACE_BFIELD"
block|,
name|TRACE_BFIELD
block|}
block|,
block|{
literal|"TRACE_TRASH"
block|,
name|TRACE_TRASH
block|}
block|,
block|{
literal|"TRACE_TABLES"
block|,
name|TRACE_TABLES
block|}
block|,
block|{
literal|"TRACE_FUNCTIONS"
block|,
name|TRACE_FUNCTIONS
block|}
block|,
block|{
literal|"TRACE_VALUES"
block|,
name|TRACE_VALUES
block|}
block|,
block|{
literal|"TRACE_OBJECTS"
block|,
name|TRACE_OBJECTS
block|}
block|,
block|{
literal|"TRACE_ALLOCATIONS"
block|,
name|TRACE_ALLOCATIONS
block|}
block|,
block|{
literal|"TRACE_RESOURCES"
block|,
name|TRACE_RESOURCES
block|}
block|,
block|{
literal|"TRACE_IO"
block|,
name|TRACE_IO
block|}
block|,
block|{
literal|"TRACE_INTERRUPTS"
block|,
name|TRACE_INTERRUPTS
block|}
block|,
block|{
literal|"TRACE_USER_REQUESTS"
block|,
name|TRACE_USER_REQUESTS
block|}
block|,
block|{
literal|"TRACE_PACKAGE"
block|,
name|TRACE_PACKAGE
block|}
block|,
block|{
literal|"TRACE_MUTEX"
block|,
name|TRACE_MUTEX
block|}
block|,
block|{
literal|"TRACE_INIT"
block|,
name|TRACE_INIT
block|}
block|,
block|{
literal|"TRACE_ALL"
block|,
name|TRACE_ALL
block|}
block|,
block|{
literal|"VERBOSE_AML_DISASSEMBLE"
block|,
name|VERBOSE_AML_DISASSEMBLE
block|}
block|,
block|{
literal|"VERBOSE_INFO"
block|,
name|VERBOSE_INFO
block|}
block|,
block|{
literal|"VERBOSE_TABLES"
block|,
name|VERBOSE_TABLES
block|}
block|,
block|{
literal|"VERBOSE_EVENTS"
block|,
name|VERBOSE_EVENTS
block|}
block|,
block|{
literal|"VERBOSE_ALL"
block|,
name|VERBOSE_ALL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|acpi_parse_debug
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|struct
name|debugtag
modifier|*
name|tag
parameter_list|,
name|UINT32
modifier|*
name|flag
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|int
name|set
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
name|ep
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|ep
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|ep
argument_list|)
condition|)
name|ep
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'!'
condition|)
block|{
name|set
operator|=
literal|0
expr_stmt|;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|ep
condition|)
continue|continue;
block|}
else|else
block|{
name|set
operator|=
literal|1
expr_stmt|;
block|}
name|l
operator|=
name|ep
operator|-
name|cp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tag
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
name|tag
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|l
argument_list|)
condition|)
block|{
if|if
condition|(
name|set
condition|)
block|{
operator|*
name|flag
operator||=
name|tag
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
operator|*
name|flag
operator|&=
operator|~
name|tag
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ACPI_DEBUG: set '%s'\n"
argument_list|,
name|tag
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|cp
operator|=
name|ep
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_set_debugging
parameter_list|(
name|void
modifier|*
name|junk
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|AcpiDbgLayer
operator|=
literal|0
expr_stmt|;
name|AcpiDbgLevel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.layer"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|acpi_parse_debug
argument_list|(
name|cp
argument_list|,
operator|&
name|dbg_layer
index|[
literal|0
index|]
argument_list|,
operator|&
name|AcpiDbgLayer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.level"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|acpi_parse_debug
argument_list|(
name|cp
argument_list|,
operator|&
name|dbg_level
index|[
literal|0
index|]
argument_list|,
operator|&
name|AcpiDbgLevel
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ACPI debug layer 0x%x  debug level 0x%x\n"
argument_list|,
name|AcpiDbgLayer
argument_list|,
name|AcpiDbgLevel
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|acpi_debugging
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|acpi_set_debugging
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

