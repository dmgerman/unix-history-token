begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Takanori Watanabe<takawata@jp.freebsd.org>  * Copyright (c) 2000 Mitsuru IWASAKI<iwasaki@jp.freebsd.org>  * Copyright (c) 2000, 2001 Michael Smith  * Copyright (c) 2000 BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/power.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|"acpi.h"
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpica_support.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpiio.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ACPIDEV
argument_list|,
literal|"acpidev"
argument_list|,
literal|"ACPI devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Hooks for the ACPI CA debugging infrastructure */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_BUS
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"ACPI"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|d_open_t
name|acpiopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|acpiclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|acpiioctl
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|152
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|acpi_cdevsw
init|=
block|{
operator|.
name|d_open
operator|=
name|acpiopen
block|,
operator|.
name|d_close
operator|=
name|acpiclose
block|,
operator|.
name|d_ioctl
operator|=
name|acpiioctl
block|,
operator|.
name|d_name
operator|=
literal|"acpi"
block|,
operator|.
name|d_maj
operator|=
name|CDEV_MAJOR
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sleep_state_names
index|[]
init|=
block|{
literal|"S0"
block|,
literal|"S1"
block|,
literal|"S2"
block|,
literal|"S3"
block|,
literal|"S4"
block|,
literal|"S5"
block|,
literal|"NONE"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this has to be static, as the softc is gone when we need it */
end_comment

begin_decl_stmt
specifier|static
name|int
name|acpi_off_state
init|=
name|ACPI_STATE_S5
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
end_if

begin_decl_stmt
name|struct
name|mtx
name|acpi_mutex
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|acpi_modevent
parameter_list|(
name|struct
name|module
modifier|*
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|junk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|device_t
name|acpi_add_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|int
name|order
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_print_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_set_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_get_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|u_long
modifier|*
name|startp
parameter_list|,
name|u_long
modifier|*
name|countp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|resource
modifier|*
name|acpi_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_release_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|acpi_isa_get_logicalid
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|acpi_isa_get_compatid
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_isa_pnp_probe
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|isa_pnp_id
modifier|*
name|ids
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_probe_children
parameter_list|(
name|device_t
name|bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_probe_child
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_shutdown_pre_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_shutdown_final
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_enable_fixed_events
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_system_eventhandler_sleep
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_system_eventhandler_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_supported_sleep_state_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_sleep_state_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_pm_func
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|acpi_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|acpi_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|acpi_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|acpi_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_add_child
argument_list|,
name|acpi_add_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|acpi_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|acpi_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|acpi_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_set_resource
argument_list|,
name|acpi_set_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource
argument_list|,
name|acpi_get_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|acpi_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|acpi_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bus_generic_teardown_intr
argument_list|)
block|,
comment|/* ISA emulation */
name|DEVMETHOD
argument_list|(
name|isa_pnp_probe
argument_list|,
name|acpi_isa_pnp_probe
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|acpi_driver
init|=
block|{
literal|"acpi"
block|,
name|acpi_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|acpi_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|acpi
argument_list|,
name|nexus
argument_list|,
name|acpi_driver
argument_list|,
name|acpi_devclass
argument_list|,
name|acpi_modevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|acpi
argument_list|,
literal|100
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|acpi_debug_layer
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|AcpiDbgLayer
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|acpi_debug_level
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|AcpiDbgLevel
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|acpi_ca_version
init|=
name|ACPI_CA_VERSION
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|acpi_ca_version
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|acpi_ca_version
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ACPI can only be loaded as a module by the loader; activating it after  * system bootstrap time is not useful, and can be fatal to the system.  * It also cannot be unloaded, since the entire system bus heirarchy hangs  * off it.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_modevent
parameter_list|(
name|struct
name|module
modifier|*
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|junk
parameter_list|)
block|{
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
operator|!
name|cold
condition|)
block|{
name|printf
argument_list|(
literal|"The ACPI driver cannot be loaded after boot.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
break|break;
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
operator|!
name|cold
operator|&&
name|power_pm_get_type
argument_list|()
operator|==
name|POWER_PM_TYPE_ACPI
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detect ACPI, perform early initialisation  */
end_comment

begin_function
specifier|static
name|void
name|acpi_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|ACPI_DEBUGGER
name|char
modifier|*
name|debugpoint
decl_stmt|;
endif|#
directive|endif
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cold
condition|)
name|return_VOID
expr_stmt|;
comment|/* Check that we haven't been disabled with a hint. */
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"acpi"
argument_list|,
literal|0
argument_list|)
condition|)
name|return_VOID
expr_stmt|;
comment|/* Make sure we're not being doubly invoked. */
if|if
condition|(
name|device_find_child
argument_list|(
name|parent
argument_list|,
literal|"acpi"
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL
condition|)
name|return_VOID
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
comment|/* Initialise the ACPI mutex */
name|mtx_init
argument_list|(
operator|&
name|acpi_mutex
argument_list|,
literal|"ACPI global lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Start up the ACPI CA subsystem. */
ifdef|#
directive|ifdef
name|ACPI_DEBUGGER
name|debugpoint
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.debugger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugpoint
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|debugpoint
argument_list|,
literal|"init"
argument_list|)
condition|)
name|acpi_EnterDebugger
argument_list|()
expr_stmt|;
name|freeenv
argument_list|(
name|debugpoint
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
operator|=
name|AcpiInitializeSubsystem
argument_list|()
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI: initialisation failed: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ACPI_DEBUGGER
name|debugpoint
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.debugger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugpoint
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|debugpoint
argument_list|,
literal|"tables"
argument_list|)
condition|)
name|acpi_EnterDebugger
argument_list|()
expr_stmt|;
name|freeenv
argument_list|(
name|debugpoint
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
operator|=
name|AcpiLoadTables
argument_list|()
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI: table load failed: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
comment|/* Attach the actual ACPI device. */
if|if
condition|(
operator|(
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"acpi"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"ACPI: could not attach\n"
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Fetch some descriptive data from ACPI to put in our attach message  */
end_comment

begin_function
specifier|static
name|int
name|acpi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_TABLE_HEADER
name|th
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ACPI_LOCK_DECL
expr_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_pm_get_type
argument_list|()
operator|!=
name|POWER_PM_TYPE_NONE
operator|&&
name|power_pm_get_type
argument_list|()
operator|!=
name|POWER_PM_TYPE_ACPI
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Other PM system enabled.\n"
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
name|ACPI_LOCK
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiGetTableHeader
argument_list|(
name|ACPI_TABLE_XSDT
argument_list|,
literal|1
argument_list|,
operator|&
name|th
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't get XSDT header: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.6s %.8s"
argument_list|,
name|th
operator|.
name|OemId
argument_list|,
name|th
operator|.
name|OemTableId
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|ACPI_UNLOCK
expr_stmt|;
name|return_VALUE
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|error
decl_stmt|;
name|UINT32
name|flags
decl_stmt|;
name|char
modifier|*
name|env
decl_stmt|;
ifdef|#
directive|ifdef
name|ACPI_DEBUGGER
name|char
modifier|*
name|debugpoint
decl_stmt|;
endif|#
directive|endif
name|ACPI_LOCK_DECL
expr_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_LOCK
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_dev
operator|=
name|dev
expr_stmt|;
ifdef|#
directive|ifdef
name|ACPI_DEBUGGER
name|debugpoint
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.debugger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugpoint
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|debugpoint
argument_list|,
literal|"spaces"
argument_list|)
condition|)
name|acpi_EnterDebugger
argument_list|()
expr_stmt|;
name|freeenv
argument_list|(
name|debugpoint
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Install the default address space handlers. */
name|error
operator|=
name|ENXIO
expr_stmt|;
name|status
operator|=
name|AcpiInstallAddressSpaceHandler
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_ADR_SPACE_SYSTEM_MEMORY
argument_list|,
name|ACPI_DEFAULT_HANDLER
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not initialise SystemMemory handler: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|status
operator|=
name|AcpiInstallAddressSpaceHandler
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_ADR_SPACE_SYSTEM_IO
argument_list|,
name|ACPI_DEFAULT_HANDLER
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not initialise SystemIO handler: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|status
operator|=
name|AcpiInstallAddressSpaceHandler
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_ADR_SPACE_PCI_CONFIG
argument_list|,
name|ACPI_DEFAULT_HANDLER
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not initialise PciConfig handler: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Bring ACPI fully online.      *      * Note that some systems (specifically, those with namespace evaluation      * issues that require the avoidance of parts of the namespace) must      * avoid running _INI and _STA on everything, as well as dodging the final      * object init pass.      *      * For these devices, we set ACPI_NO_DEVICE_INIT and ACPI_NO_OBJECT_INIT).      *      * XXX We should arrange for the object init pass after we have attached      *     all our child devices, but on many systems it works here.      */
ifdef|#
directive|ifdef
name|ACPI_DEBUGGER
name|debugpoint
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.debugger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugpoint
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|debugpoint
argument_list|,
literal|"enable"
argument_list|)
condition|)
name|acpi_EnterDebugger
argument_list|()
expr_stmt|;
name|freeenv
argument_list|(
name|debugpoint
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|testenv
argument_list|(
literal|"debug.acpi.avoid"
argument_list|)
condition|)
name|flags
operator|=
name|ACPI_NO_DEVICE_INIT
operator||
name|ACPI_NO_OBJECT_INIT
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiEnableSubsystem
argument_list|(
name|flags
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not enable ACPI: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Call the ECDT probe function to provide EC functionality before      * the namespace has been evaluated.      */
name|acpi_ec_ecdt_probe
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiInitializeObjects
argument_list|(
name|flags
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not initialize ACPI objects: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Setup our sysctl tree.      *      * XXX: This doesn't check to make sure that none of these fail.      */
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"supported_sleep_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|acpi_supported_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"power_button_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_power_button_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sleep_button_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_sleep_button_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lid_switch_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_lid_switch_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"standby_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_standby_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"suspend_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_suspend_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sleep_delay"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_sleep_delay
argument_list|,
literal|0
argument_list|,
literal|"sleep delay"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"s4bios"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_s4bios
argument_list|,
literal|0
argument_list|,
literal|"S4BIOS mode"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"verbose"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_verbose
argument_list|,
literal|0
argument_list|,
literal|"verbose mode"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"disable_on_poweroff"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_disable_on_poweroff
argument_list|,
literal|0
argument_list|,
literal|"ACPI subsystem disable on poweroff"
argument_list|)
expr_stmt|;
comment|/*      * Default to 5 seconds before sleeping to give some machines time to      * stabilize.      */
name|sc
operator|->
name|acpi_sleep_delay
operator|=
literal|5
expr_stmt|;
name|sc
operator|->
name|acpi_disable_on_poweroff
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|acpi_s4bios
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|sc
operator|->
name|acpi_verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|env
operator|=
name|getenv
argument_list|(
literal|"hw.acpi.verbose"
argument_list|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|env
argument_list|,
literal|"0"
argument_list|)
condition|)
block|{
name|sc
operator|->
name|acpi_verbose
operator|=
literal|1
expr_stmt|;
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
comment|/*      * Dispatch the default sleep state to devices.      * TBD: should be configured from userland policy manager.      */
name|sc
operator|->
name|acpi_power_button_sx
operator|=
name|ACPI_POWER_BUTTON_DEFAULT_SX
expr_stmt|;
name|sc
operator|->
name|acpi_sleep_button_sx
operator|=
name|ACPI_SLEEP_BUTTON_DEFAULT_SX
expr_stmt|;
name|sc
operator|->
name|acpi_lid_switch_sx
operator|=
name|ACPI_LID_SWITCH_DEFAULT_SX
expr_stmt|;
name|sc
operator|->
name|acpi_standby_sx
operator|=
name|ACPI_STATE_S1
expr_stmt|;
name|sc
operator|->
name|acpi_suspend_sx
operator|=
name|ACPI_STATE_S3
expr_stmt|;
name|acpi_enable_fixed_events
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Scan the namespace and attach/initialise children.      */
ifdef|#
directive|ifdef
name|ACPI_DEBUGGER
name|debugpoint
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.debugger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugpoint
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|debugpoint
argument_list|,
literal|"probe"
argument_list|)
condition|)
name|acpi_EnterDebugger
argument_list|()
expr_stmt|;
name|freeenv
argument_list|(
name|debugpoint
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Register our shutdown handlers */
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_pre_sync
argument_list|,
name|acpi_shutdown_pre_sync
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_LAST
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|acpi_shutdown_final
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_LAST
argument_list|)
expr_stmt|;
comment|/*      * Register our acpi event handlers.      * XXX should be configurable eg. via userland policy manager.      */
name|EVENTHANDLER_REGISTER
argument_list|(
name|acpi_sleep_event
argument_list|,
name|acpi_system_eventhandler_sleep
argument_list|,
name|sc
argument_list|,
name|ACPI_EVENT_PRI_LAST
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|acpi_wakeup_event
argument_list|,
name|acpi_system_eventhandler_wakeup
argument_list|,
name|sc
argument_list|,
name|ACPI_EVENT_PRI_LAST
argument_list|)
expr_stmt|;
comment|/* Flag our initial states. */
name|sc
operator|->
name|acpi_enabled
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|acpi_sstate
operator|=
name|ACPI_STATE_S0
expr_stmt|;
name|sc
operator|->
name|acpi_sleep_disabled
operator|=
literal|0
expr_stmt|;
comment|/* Create the control device */
name|sc
operator|->
name|acpi_dev_t
operator|=
name|make_dev
argument_list|(
operator|&
name|acpi_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0644
argument_list|,
literal|"acpi"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_dev_t
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
ifdef|#
directive|ifdef
name|ACPI_DEBUGGER
name|debugpoint
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.debugger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugpoint
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|debugpoint
argument_list|,
literal|"running"
argument_list|)
operator|==
literal|0
condition|)
name|acpi_EnterDebugger
argument_list|()
expr_stmt|;
name|freeenv
argument_list|(
name|debugpoint
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACPI_USE_THREADS
if|if
condition|(
operator|(
name|error
operator|=
name|acpi_task_thread_init
argument_list|()
operator|)
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|acpi_machdep_init
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* Register ACPI again to pass the correct argument of pm_func. */
name|power_pm_register
argument_list|(
name|POWER_PM_TYPE_ACPI
argument_list|,
name|acpi_pm_func
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acpi_disabled
argument_list|(
literal|"bus"
argument_list|)
condition|)
name|acpi_probe_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|ACPI_UNLOCK
expr_stmt|;
name|return_VALUE
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a new device being added  */
end_comment

begin_function
specifier|static
name|device_t
name|acpi_add_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|int
name|order
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
name|device_t
name|child
decl_stmt|;
if|if
condition|(
operator|(
name|ad
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ad
argument_list|)
argument_list|,
name|M_ACPIDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|resource_list_init
argument_list|(
operator|&
name|ad
operator|->
name|ad_rl
argument_list|)
expr_stmt|;
name|child
operator|=
name|device_add_child_ordered
argument_list|(
name|bus
argument_list|,
name|order
argument_list|,
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|ad
argument_list|)
expr_stmt|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_print_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|adev
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|adev
operator|->
name|ad_rl
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"port"
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|"%#lx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"iomem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#lx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"irq"
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|"%ld"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"drq"
argument_list|,
name|SYS_RES_DRQ
argument_list|,
literal|"%ld"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle per-device ivars  */
end_comment

begin_function
specifier|static
name|int
name|acpi_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
if|if
condition|(
operator|(
name|ad
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"device has no ivars\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* ACPI and ISA compatibility ivars */
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|ACPI_IVAR_HANDLE
case|:
operator|*
operator|(
name|ACPI_HANDLE
operator|*
operator|)
name|result
operator|=
name|ad
operator|->
name|ad_handle
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_MAGIC
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|ad
operator|->
name|ad_magic
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_PRIVATE
case|:
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|result
operator|=
name|ad
operator|->
name|ad_private
expr_stmt|;
break|break;
case|case
name|ISA_IVAR_VENDORID
case|:
case|case
name|ISA_IVAR_SERIAL
case|:
case|case
name|ISA_IVAR_COMPATID
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|ISA_IVAR_LOGICALID
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|acpi_isa_get_logicalid
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
if|if
condition|(
operator|(
name|ad
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"device has no ivars\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|ACPI_IVAR_HANDLE
case|:
name|ad
operator|->
name|ad_handle
operator|=
operator|(
name|ACPI_HANDLE
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_MAGIC
case|:
name|ad
operator|->
name|ad_magic
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_PRIVATE
case|:
name|ad
operator|->
name|ad_private
operator|=
operator|(
name|void
operator|*
operator|)
name|value
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"bad ivar write request (%d)"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|ACPI_HANDLE
name|acpi_get_handle
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uintptr_t
name|up
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
if|if
condition|(
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|ACPI_IVAR_HANDLE
argument_list|,
operator|&
name|up
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|h
operator|=
operator|(
name|ACPI_HANDLE
operator|)
name|up
expr_stmt|;
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_function
name|int
name|acpi_set_handle
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|ACPI_HANDLE
name|h
parameter_list|)
block|{
name|uintptr_t
name|up
decl_stmt|;
name|up
operator|=
operator|(
name|uintptr_t
operator|)
name|h
expr_stmt|;
return|return
operator|(
name|BUS_WRITE_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|ACPI_IVAR_HANDLE
argument_list|,
name|up
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|acpi_get_magic
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uintptr_t
name|up
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|ACPI_IVAR_MAGIC
argument_list|,
operator|&
name|up
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|=
operator|(
name|int
operator|)
name|up
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|int
name|acpi_set_magic
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|m
parameter_list|)
block|{
name|uintptr_t
name|up
decl_stmt|;
name|up
operator|=
operator|(
name|uintptr_t
operator|)
name|m
expr_stmt|;
return|return
operator|(
name|BUS_WRITE_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|ACPI_IVAR_MAGIC
argument_list|,
name|up
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|acpi_get_private
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uintptr_t
name|up
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|ACPI_IVAR_PRIVATE
argument_list|,
operator|&
name|up
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|up
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|int
name|acpi_set_private
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|uintptr_t
name|up
decl_stmt|;
name|up
operator|=
operator|(
name|uintptr_t
operator|)
name|p
expr_stmt|;
return|return
operator|(
name|BUS_WRITE_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|ACPI_IVAR_PRIVATE
argument_list|,
name|up
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ACPI_OBJECT_TYPE
name|acpi_get_type
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_OBJECT_TYPE
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ACPI_TYPE_NOT_FOUND
operator|)
return|;
if|if
condition|(
name|AcpiGetType
argument_list|(
name|h
argument_list|,
operator|&
name|t
argument_list|)
operator|!=
name|AE_OK
condition|)
return|return
operator|(
name|ACPI_TYPE_NOT_FOUND
operator|)
return|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle child resource allocation/removal  */
end_comment

begin_function
specifier|static
name|int
name|acpi_set_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|count
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|ad
operator|->
name|ad_rl
decl_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|count
operator|-
literal|1
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_get_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|u_long
modifier|*
name|startp
parameter_list|,
name|u_long
modifier|*
name|countp
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|ad
operator|->
name|ad_rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rle
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|startp
condition|)
operator|*
name|startp
operator|=
name|rle
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|countp
condition|)
operator|*
name|countp
operator|=
name|rle
operator|->
name|count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|acpi_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|ad
operator|->
name|ad_rl
decl_stmt|;
return|return
operator|(
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_release_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|ad
operator|->
name|ad_rl
decl_stmt|;
return|return
operator|(
name|resource_list_release
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle ISA-like devices probing for a PnP ID to match.  */
end_comment

begin_define
define|#
directive|define
name|PNP_EISAID
parameter_list|(
name|s
parameter_list|)
define|\
value|((((s[0] - '@')& 0x1f)<< 2)		\ 	 | (((s[1] - '@')& 0x18)>> 3)		\ 	 | (((s[1] - '@')& 0x07)<< 13)	\ 	 | (((s[2] - '@')& 0x1f)<< 8)		\ 	 | (PNP_HEXTONUM(s[4])<< 16)		\ 	 | (PNP_HEXTONUM(s[3])<< 20)		\ 	 | (PNP_HEXTONUM(s[6])<< 24)		\ 	 | (PNP_HEXTONUM(s[5])<< 28))
end_define

begin_function
specifier|static
name|u_int32_t
name|acpi_isa_get_logicalid
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_DEVICE_INFO
name|devinfo
decl_stmt|;
name|ACPI_BUFFER
name|buf
init|=
block|{
sizeof|sizeof
argument_list|(
name|devinfo
argument_list|)
block|,
operator|&
name|devinfo
block|}
decl_stmt|;
name|ACPI_STATUS
name|error
decl_stmt|;
name|u_int32_t
name|pnpid
decl_stmt|;
name|ACPI_LOCK_DECL
expr_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|pnpid
operator|=
literal|0
expr_stmt|;
name|ACPI_LOCK
expr_stmt|;
comment|/* Fetch and validate the HID. */
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|devinfo
operator|.
name|Valid
operator|&
name|ACPI_VALID_HID
operator|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|pnpid
operator|=
name|PNP_EISAID
argument_list|(
name|devinfo
operator|.
name|HardwareId
operator|.
name|Value
argument_list|)
expr_stmt|;
name|out
label|:
name|ACPI_UNLOCK
expr_stmt|;
name|return_VALUE
argument_list|(
name|pnpid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|acpi_isa_get_compatid
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_STATUS
name|error
decl_stmt|;
name|u_int32_t
name|pnpid
decl_stmt|;
name|ACPI_LOCK_DECL
expr_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|pnpid
operator|=
literal|0
expr_stmt|;
name|ACPI_LOCK
expr_stmt|;
comment|/* Fetch and validate the HID */
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
operator|=
name|acpi_EvaluateInteger
argument_list|(
name|h
argument_list|,
literal|"_CID"
argument_list|,
operator|&
name|pnpid
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|out
label|:
name|ACPI_UNLOCK
expr_stmt|;
name|return_VALUE
argument_list|(
name|pnpid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_isa_pnp_probe
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|isa_pnp_id
modifier|*
name|ids
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|u_int32_t
name|lid
decl_stmt|,
name|cid
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/*      * ISA-style drivers attached to ACPI may persist and      * probe manually if we return ENOENT.  We never want      * that to happen, so don't ever return it.      */
name|result
operator|=
name|ENXIO
expr_stmt|;
comment|/* Scan the supplied IDs for a match */
name|lid
operator|=
name|acpi_isa_get_logicalid
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cid
operator|=
name|acpi_isa_get_compatid
argument_list|(
name|child
argument_list|)
expr_stmt|;
while|while
condition|(
name|ids
operator|&&
name|ids
operator|->
name|ip_id
condition|)
block|{
if|if
condition|(
name|lid
operator|==
name|ids
operator|->
name|ip_id
operator|||
name|cid
operator|==
name|ids
operator|->
name|ip_id
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ids
operator|++
expr_stmt|;
block|}
name|out
label|:
name|return_VALUE
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scan relevant portions of the ACPI namespace and attach child devices.  *  * Note that we only expect to find devices in the \_PR_, \_TZ_, \_SI_ and  * \_SB_ scopes, and \_PR_ and \_TZ_ become obsolete in the ACPI 2.0 spec.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_probe_children
parameter_list|(
name|device_t
name|bus
parameter_list|)
block|{
name|ACPI_HANDLE
name|parent
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
specifier|static
name|char
modifier|*
name|scopes
index|[]
init|=
block|{
literal|"\\_PR_"
block|,
literal|"\\_TZ_"
block|,
literal|"\\_SI"
block|,
literal|"\\_SB_"
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
comment|/* Create any static children by calling device identify methods. */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"device identify routines\n"
operator|)
argument_list|)
expr_stmt|;
name|bus_generic_probe
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/*      * Scan the namespace and insert placeholders for all the devices that      * we find.      *      * Note that we use AcpiWalkNamespace rather than AcpiGetDevices because      * we want to create nodes for all devices, not just those that are      * currently present. (This assumes that we don't want to create/remove      * devices as they appear, which might be smarter.)      */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"namespace scan\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scopes
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|AcpiGetHandle
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
name|scopes
index|[
name|i
index|]
argument_list|,
operator|&
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|parent
argument_list|,
literal|100
argument_list|,
name|acpi_probe_child
argument_list|,
name|bus
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Scan all of the child devices we have created and let them probe/attach.      */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"first bus_generic_attach\n"
operator|)
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/*      * Some of these children may have attached others as part of their attach      * process (eg. the root PCI bus driver), so rescan.      */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"second bus_generic_attach\n"
operator|)
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"done attaching children\n"
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a child device and determine whether we might attach a device to  * it.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_probe_child
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
modifier|*
name|status
parameter_list|)
block|{
name|ACPI_OBJECT_TYPE
name|type
decl_stmt|;
name|device_t
name|child
decl_stmt|,
name|bus
init|=
operator|(
name|device_t
operator|)
name|context
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* Skip this device if we think we'll have trouble with it. */
if|if
condition|(
name|acpi_avoid
argument_list|(
name|handle
argument_list|)
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetType
argument_list|(
name|handle
argument_list|,
operator|&
name|type
argument_list|)
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ACPI_TYPE_DEVICE
case|:
case|case
name|ACPI_TYPE_PROCESSOR
case|:
case|case
name|ACPI_TYPE_THERMAL
case|:
case|case
name|ACPI_TYPE_POWER
case|:
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"children"
argument_list|)
condition|)
break|break;
comment|/*  	     * Create a placeholder device for this node.  Sort the placeholder 	     * so that the probe/attach passes will run breadth-first. 	     */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"scanning '%s'\n"
operator|,
name|acpi_name
argument_list|(
name|handle
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|bus
argument_list|,
name|level
operator|*
literal|10
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
break|break;
name|acpi_set_handle
argument_list|(
name|child
argument_list|,
name|handle
argument_list|)
expr_stmt|;
comment|/* 	     * Check that the device is present.  If it's not present, 	     * leave it disabled (so that we have a device_t attached to 	     * the handle, but we don't probe it). 	     */
if|if
condition|(
name|type
operator|==
name|ACPI_TYPE_DEVICE
operator|&&
operator|!
name|acpi_DeviceIsPresent
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|device_disable
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	     * Get the device's resource settings and attach them. 	     * Note that if the device has _PRS but no _CRS, we need 	     * to decide when it's appropriate to try to configure the 	     * device.  Ignore the return value here; it's OK for the 	     * device not to have any resources. 	     */
name|acpi_parse_resources
argument_list|(
name|child
argument_list|,
name|handle
argument_list|,
operator|&
name|acpi_res_parse_set
argument_list|)
expr_stmt|;
comment|/* If we're debugging, probe/attach now rather than later */
name|ACPI_DEBUG_EXEC
argument_list|(
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_shutdown_pre_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
comment|/*      * Disable all ACPI events before soft off, otherwise the system      * will be turned on again on some laptops.      *      * XXX this should probably be restricted to masking some events just      *     before powering down, since we may still need ACPI during the      *     shutdown process.      */
if|if
condition|(
name|sc
operator|->
name|acpi_disable_on_poweroff
condition|)
name|acpi_Disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_shutdown_final
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
if|if
condition|(
operator|(
name|howto
operator|&
name|RB_POWEROFF
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Powering system off using ACPI\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|AcpiEnterSleepStatePrep
argument_list|(
name|acpi_off_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"AcpiEnterSleepStatePrep failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|status
operator|=
name|AcpiEnterSleepState
argument_list|(
name|acpi_off_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI power-off failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ACPI power-off failed - timeout\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Shutting down ACPI\n"
argument_list|)
expr_stmt|;
name|AcpiTerminate
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_enable_fixed_events
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|int
name|first_time
init|=
literal|1
decl_stmt|;
define|#
directive|define
name|MSGFORMAT
value|"%s button is handled as a fixed feature programming model.\n"
name|ACPI_ASSERTLOCK
expr_stmt|;
comment|/* Enable and clear fixed events and install handlers. */
if|if
condition|(
name|AcpiGbl_FADT
operator|!=
name|NULL
operator|&&
name|AcpiGbl_FADT
operator|->
name|PwrButton
operator|==
literal|0
condition|)
block|{
name|AcpiEnableEvent
argument_list|(
name|ACPI_EVENT_POWER_BUTTON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AcpiClearEvent
argument_list|(
name|ACPI_EVENT_POWER_BUTTON
argument_list|)
expr_stmt|;
name|AcpiInstallFixedEventHandler
argument_list|(
name|ACPI_EVENT_POWER_BUTTON
argument_list|,
name|acpi_eventhandler_power_button_for_sleep
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_time
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
name|MSGFORMAT
argument_list|,
literal|"power"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AcpiGbl_FADT
operator|!=
name|NULL
operator|&&
name|AcpiGbl_FADT
operator|->
name|SleepButton
operator|==
literal|0
condition|)
block|{
name|AcpiEnableEvent
argument_list|(
name|ACPI_EVENT_SLEEP_BUTTON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AcpiClearEvent
argument_list|(
name|ACPI_EVENT_SLEEP_BUTTON
argument_list|)
expr_stmt|;
name|AcpiInstallFixedEventHandler
argument_list|(
name|ACPI_EVENT_SLEEP_BUTTON
argument_list|,
name|acpi_eventhandler_sleep_button_for_sleep
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_time
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
name|MSGFORMAT
argument_list|,
literal|"sleep"
argument_list|)
expr_stmt|;
block|}
name|first_time
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the device is actually present and should  * be attached to.  This requires the present, enabled, UI-visible   * and diagnostics-passed bits to be set.  */
end_comment

begin_function
name|BOOLEAN
name|acpi_DeviceIsPresent
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_DEVICE_INFO
name|devinfo
decl_stmt|;
name|ACPI_BUFFER
name|buf
init|=
block|{
sizeof|sizeof
argument_list|(
name|devinfo
argument_list|)
block|,
operator|&
name|devinfo
block|}
decl_stmt|;
name|ACPI_STATUS
name|error
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|error
operator|=
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* If no _STA method, must be present */
if|if
condition|(
operator|(
name|devinfo
operator|.
name|Valid
operator|&
name|ACPI_VALID_STA
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* Return true for 'present' and 'functioning' */
if|if
condition|(
operator|(
name|devinfo
operator|.
name|CurrentStatus
operator|&
literal|0x9
operator|)
operator|==
literal|0x9
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the battery is actually present and inserted.  */
end_comment

begin_function
name|BOOLEAN
name|acpi_BatteryIsPresent
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_DEVICE_INFO
name|devinfo
decl_stmt|;
name|ACPI_BUFFER
name|buf
init|=
block|{
sizeof|sizeof
argument_list|(
name|devinfo
argument_list|)
block|,
operator|&
name|devinfo
block|}
decl_stmt|;
name|ACPI_STATUS
name|error
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|error
operator|=
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* If no _STA method, must be present */
if|if
condition|(
operator|(
name|devinfo
operator|.
name|Valid
operator|&
name|ACPI_VALID_STA
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* Return true for 'present' and 'functioning' */
if|if
condition|(
operator|(
name|devinfo
operator|.
name|CurrentStatus
operator|&
literal|0x19
operator|)
operator|==
literal|0x19
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Match a HID string against a device  */
end_comment

begin_function
name|BOOLEAN
name|acpi_MatchHid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|char
modifier|*
name|hid
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_DEVICE_INFO
name|devinfo
decl_stmt|;
name|ACPI_BUFFER
name|buf
init|=
block|{
sizeof|sizeof
argument_list|(
name|devinfo
argument_list|)
block|,
operator|&
name|devinfo
block|}
decl_stmt|;
name|ACPI_STATUS
name|error
decl_stmt|;
name|int
name|cid
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
if|if
condition|(
name|hid
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|error
operator|=
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|devinfo
operator|.
name|Valid
operator|&
name|ACPI_VALID_HID
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|hid
argument_list|,
name|devinfo
operator|.
name|HardwareId
operator|.
name|Value
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|error
operator|=
name|acpi_EvaluateInteger
argument_list|(
name|h
argument_list|,
literal|"_CID"
argument_list|,
operator|&
name|cid
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|cid
operator|==
name|PNP_EISAID
argument_list|(
name|hid
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the handle of a named object within our scope, ie. that of (parent)  * or one if its parents.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_GetHandleInScope
parameter_list|(
name|ACPI_HANDLE
name|parent
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|ACPI_HANDLE
modifier|*
name|result
parameter_list|)
block|{
name|ACPI_HANDLE
name|r
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
comment|/* Walk back up the tree to the root */
for|for
control|(
init|;
condition|;
control|)
block|{
name|status
operator|=
name|AcpiGetHandle
argument_list|(
name|parent
argument_list|,
name|path
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
operator|*
name|result
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
if|if
condition|(
name|status
operator|!=
name|AE_NOT_FOUND
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiGetParent
argument_list|(
name|parent
argument_list|,
operator|&
name|r
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|AE_NOT_FOUND
operator|)
return|;
name|parent
operator|=
name|r
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a buffer with a preset data size.  */
end_comment

begin_function
name|ACPI_BUFFER
modifier|*
name|acpi_AllocBuffer
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|ACPI_BUFFER
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|size
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|M_ACPIDEV
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|buf
operator|->
name|Length
operator|=
name|size
expr_stmt|;
name|buf
operator|->
name|Pointer
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a path that should return an integer.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_EvaluateInteger
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
modifier|*
name|number
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_OBJECT
name|param
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
name|handle
operator|=
name|ACPI_ROOT_OBJECT
expr_stmt|;
comment|/*      * Assume that what we've been pointed at is an Integer object, or      * a method that will return an Integer.      */
name|buf
operator|.
name|Pointer
operator|=
operator|&
name|param
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
sizeof|sizeof
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|handle
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|param
operator|.
name|Type
operator|==
name|ACPI_TYPE_INTEGER
condition|)
operator|*
name|number
operator|=
name|param
operator|.
name|Integer
operator|.
name|Value
expr_stmt|;
else|else
name|status
operator|=
name|AE_TYPE
expr_stmt|;
block|}
comment|/*       * In some applications, a method that's expected to return an Integer      * may instead return a Buffer (probably to simplify some internal      * arithmetic).  We'll try to fetch whatever it is, and if it's a Buffer,      * convert it into an Integer as best we can.      *      * This is a hack.      */
if|if
condition|(
name|status
operator|==
name|AE_BUFFER_OVERFLOW
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|.
name|Pointer
operator|=
name|AcpiOsAllocate
argument_list|(
name|buf
operator|.
name|Length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|AE_NO_MEMORY
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|handle
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|acpi_ConvertBufferToInteger
argument_list|(
operator|&
name|buf
argument_list|,
name|number
argument_list|)
expr_stmt|;
block|}
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|ACPI_STATUS
name|acpi_ConvertBufferToInteger
parameter_list|(
name|ACPI_BUFFER
modifier|*
name|bufp
parameter_list|,
name|int
modifier|*
name|number
parameter_list|)
block|{
name|ACPI_OBJECT
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|bufp
operator|->
name|Pointer
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|Type
operator|==
name|ACPI_TYPE_INTEGER
condition|)
block|{
operator|*
name|number
operator|=
name|p
operator|->
name|Integer
operator|.
name|Value
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|Type
operator|!=
name|ACPI_TYPE_BUFFER
condition|)
return|return
operator|(
name|AE_TYPE
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|Buffer
operator|.
name|Length
operator|>
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|(
name|AE_BAD_DATA
operator|)
return|;
operator|*
name|number
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|Buffer
operator|.
name|Length
condition|;
name|i
operator|++
control|)
operator|*
name|number
operator|+=
operator|(
operator|*
operator|(
name|p
operator|->
name|Buffer
operator|.
name|Pointer
operator|+
name|i
operator|)
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over the elements of an a package object, calling the supplied  * function for each element.  *  * XXX possible enhancement might be to abort traversal on error.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_ForeachPackageObject
parameter_list|(
name|ACPI_OBJECT
modifier|*
name|pkg
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|ACPI_OBJECT
modifier|*
name|comp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ACPI_OBJECT
modifier|*
name|comp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pkg
operator|==
name|NULL
operator|||
name|pkg
operator|->
name|Type
operator|!=
name|ACPI_TYPE_PACKAGE
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
comment|/* Iterate over components */
name|i
operator|=
literal|0
expr_stmt|;
name|comp
operator|=
name|pkg
operator|->
name|Package
operator|.
name|Elements
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|pkg
operator|->
name|Package
operator|.
name|Count
condition|;
name|i
operator|++
operator|,
name|comp
operator|++
control|)
name|func
argument_list|(
name|comp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the (index)th resource object in a set.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_FindIndexedResource
parameter_list|(
name|ACPI_BUFFER
modifier|*
name|buf
parameter_list|,
name|int
name|index
parameter_list|,
name|ACPI_RESOURCE
modifier|*
modifier|*
name|resp
parameter_list|)
block|{
name|ACPI_RESOURCE
modifier|*
name|rp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rp
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
name|buf
operator|->
name|Pointer
expr_stmt|;
name|i
operator|=
name|index
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* Range check */
if|if
condition|(
name|rp
operator|>
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|->
name|Pointer
operator|+
name|buf
operator|->
name|Length
operator|)
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
comment|/* Check for terminator */
if|if
condition|(
name|rp
operator|->
name|Id
operator|==
name|ACPI_RSTYPE_END_TAG
operator|||
name|rp
operator|->
name|Length
operator|==
literal|0
condition|)
return|return
operator|(
name|AE_NOT_FOUND
operator|)
return|;
name|rp
operator|=
name|ACPI_RESOURCE_NEXT
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resp
operator|!=
name|NULL
condition|)
operator|*
name|resp
operator|=
name|rp
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append an ACPI_RESOURCE to an ACPI_BUFFER.  *  * Given a pointer to an ACPI_RESOURCE structure, expand the ACPI_BUFFER  * provided to contain it.  If the ACPI_BUFFER is empty, allocate a sensible  * backing block.  If the ACPI_RESOURCE is NULL, return an empty set of  * resources.  */
end_comment

begin_define
define|#
directive|define
name|ACPI_INITIAL_RESOURCE_BUFFER_SIZE
value|512
end_define

begin_function
name|ACPI_STATUS
name|acpi_AppendBufferResource
parameter_list|(
name|ACPI_BUFFER
modifier|*
name|buf
parameter_list|,
name|ACPI_RESOURCE
modifier|*
name|res
parameter_list|)
block|{
name|ACPI_RESOURCE
modifier|*
name|rp
decl_stmt|;
name|void
modifier|*
name|newp
decl_stmt|;
comment|/* Initialise the buffer if necessary. */
if|if
condition|(
name|buf
operator|->
name|Pointer
operator|==
name|NULL
condition|)
block|{
name|buf
operator|->
name|Length
operator|=
name|ACPI_INITIAL_RESOURCE_BUFFER_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|->
name|Pointer
operator|=
name|AcpiOsAllocate
argument_list|(
name|buf
operator|->
name|Length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
name|rp
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
name|buf
operator|->
name|Pointer
expr_stmt|;
name|rp
operator|->
name|Id
operator|=
name|ACPI_RSTYPE_END_TAG
expr_stmt|;
name|rp
operator|->
name|Length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
comment|/*      * Scan the current buffer looking for the terminator.      * This will either find the terminator or hit the end      * of the buffer and return an error.      */
name|rp
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
name|buf
operator|->
name|Pointer
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Range check, don't go outside the buffer */
if|if
condition|(
name|rp
operator|>=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|->
name|Pointer
operator|+
name|buf
operator|->
name|Length
operator|)
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
if|if
condition|(
name|rp
operator|->
name|Id
operator|==
name|ACPI_RSTYPE_END_TAG
operator|||
name|rp
operator|->
name|Length
operator|==
literal|0
condition|)
break|break;
name|rp
operator|=
name|ACPI_RESOURCE_NEXT
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
comment|/*      * Check the size of the buffer and expand if required.      *      * Required size is:      *	size of existing resources before terminator +       *	size of new resource and header +      * 	size of terminator.      *      * Note that this loop should really only run once, unless      * for some reason we are stuffing a *really* huge resource.      */
while|while
condition|(
operator|(
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|rp
operator|-
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|->
name|Pointer
operator|)
operator|+
name|res
operator|->
name|Length
operator|+
name|ACPI_RESOURCE_LENGTH_NO_DATA
operator|+
name|ACPI_RESOURCE_LENGTH
operator|)
operator|>=
name|buf
operator|->
name|Length
condition|)
block|{
if|if
condition|(
operator|(
name|newp
operator|=
name|AcpiOsAllocate
argument_list|(
name|buf
operator|->
name|Length
operator|*
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
name|bcopy
argument_list|(
name|buf
operator|->
name|Pointer
argument_list|,
name|newp
argument_list|,
name|buf
operator|->
name|Length
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|newp
operator|+
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|rp
operator|-
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|->
name|Pointer
operator|)
operator|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|buf
operator|->
name|Pointer
argument_list|)
expr_stmt|;
name|buf
operator|->
name|Pointer
operator|=
name|newp
expr_stmt|;
name|buf
operator|->
name|Length
operator|+=
name|buf
operator|->
name|Length
expr_stmt|;
block|}
comment|/* Insert the new resource. */
name|bcopy
argument_list|(
name|res
argument_list|,
name|rp
argument_list|,
name|res
operator|->
name|Length
operator|+
name|ACPI_RESOURCE_LENGTH_NO_DATA
argument_list|)
expr_stmt|;
comment|/* And add the terminator. */
name|rp
operator|=
name|ACPI_RESOURCE_NEXT
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Id
operator|=
name|ACPI_RSTYPE_END_TAG
expr_stmt|;
name|rp
operator|->
name|Length
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set interrupt model.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_SetIntrModel
parameter_list|(
name|int
name|model
parameter_list|)
block|{
name|ACPI_OBJECT_LIST
name|ArgList
decl_stmt|;
name|ACPI_OBJECT
name|Arg
decl_stmt|;
name|Arg
operator|.
name|Type
operator|=
name|ACPI_TYPE_INTEGER
expr_stmt|;
name|Arg
operator|.
name|Integer
operator|.
name|Value
operator|=
name|model
expr_stmt|;
name|ArgList
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|ArgList
operator|.
name|Pointer
operator|=
operator|&
name|Arg
expr_stmt|;
return|return
operator|(
name|AcpiEvaluateObject
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
literal|"_PIC"
argument_list|,
operator|&
name|ArgList
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ACPI_MINIMUM_AWAKETIME
value|5
end_define

begin_function
specifier|static
name|void
name|acpi_sleep_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
operator|(
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|arg
operator|)
operator|->
name|acpi_sleep_disabled
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the system sleep state  *  * Currently we support S1-S5 but S4 is only S4BIOS  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_SetSleepState
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|ACPI_STATUS
name|status
init|=
name|AE_OK
decl_stmt|;
name|UINT8
name|TypeA
decl_stmt|;
name|UINT8
name|TypeB
decl_stmt|;
name|ACPI_FUNCTION_TRACE_U32
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|acpi_sstate
operator|!=
name|ACPI_STATE_S0
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
comment|/* avoid reentry */
if|if
condition|(
name|sc
operator|->
name|acpi_sleep_disabled
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ACPI_STATE_S0
case|:
comment|/* XXX only for testing */
name|status
operator|=
name|AcpiEnterSleepState
argument_list|(
operator|(
name|UINT8
operator|)
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"AcpiEnterSleepState failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACPI_STATE_S1
case|:
case|case
name|ACPI_STATE_S2
case|:
case|case
name|ACPI_STATE_S3
case|:
case|case
name|ACPI_STATE_S4
case|:
name|status
operator|=
name|AcpiGetSleepTypeData
argument_list|(
operator|(
name|UINT8
operator|)
name|state
argument_list|,
operator|&
name|TypeA
argument_list|,
operator|&
name|TypeB
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"AcpiGetSleepTypeData failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|acpi_sstate
operator|=
name|state
expr_stmt|;
name|sc
operator|->
name|acpi_sleep_disabled
operator|=
literal|1
expr_stmt|;
comment|/* Inform all devices that we are going to sleep. */
if|if
condition|(
name|DEVICE_SUSPEND
argument_list|(
name|root_bus
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 	     * Re-wake the system. 	     * 	     * XXX note that a better two-pass approach with a 'veto' pass 	     *     followed by a "real thing" pass would be better, but the 	     *     current bus interface does not provide for this. 	     */
name|DEVICE_RESUME
argument_list|(
name|root_bus
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_ERROR
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|AcpiEnterSleepStatePrep
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"AcpiEnterSleepStatePrep failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|acpi_sleep_delay
operator|>
literal|0
condition|)
name|DELAY
argument_list|(
name|sc
operator|->
name|acpi_sleep_delay
operator|*
literal|1000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|ACPI_STATE_S1
condition|)
block|{
name|acpi_sleep_machdep
argument_list|(
name|sc
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* AcpiEnterSleepState() may be incomplete, unlock if locked. */
if|if
condition|(
name|AcpiGbl_MutexInfo
index|[
name|ACPI_MTX_HARDWARE
index|]
operator|.
name|OwnerId
operator|!=
name|ACPI_MUTEX_NOT_ACQUIRED
condition|)
block|{
name|AcpiUtReleaseMutex
argument_list|(
name|ACPI_MTX_HARDWARE
argument_list|)
expr_stmt|;
block|}
comment|/* Re-enable ACPI hardware on wakeup from sleep state 4. */
if|if
condition|(
name|state
operator|==
name|ACPI_STATE_S4
condition|)
name|AcpiEnable
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|AcpiEnterSleepState
argument_list|(
operator|(
name|UINT8
operator|)
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"AcpiEnterSleepState failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|AcpiLeaveSleepState
argument_list|(
operator|(
name|UINT8
operator|)
name|state
argument_list|)
expr_stmt|;
name|DEVICE_RESUME
argument_list|(
name|root_bus
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_sstate
operator|=
name|ACPI_STATE_S0
expr_stmt|;
name|acpi_enable_fixed_events
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_STATE_S5
case|:
comment|/* 	 * Shut down cleanly and power off.  This will call us back through the 	 * shutdown handlers. 	 */
name|shutdown_nice
argument_list|(
name|RB_POWEROFF
argument_list|)
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|AE_BAD_PARAMETER
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|acpi_sleep_disabled
condition|)
name|timeout
argument_list|(
name|acpi_sleep_enable
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|hz
operator|*
name|ACPI_MINIMUM_AWAKETIME
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable/Disable ACPI  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_Enable
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
name|flags
operator|=
name|ACPI_NO_ADDRESS_SPACE_INIT
operator||
name|ACPI_NO_HARDWARE_INIT
operator||
name|ACPI_NO_DEVICE_INIT
operator||
name|ACPI_NO_OBJECT_INIT
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|acpi_enabled
condition|)
name|status
operator|=
name|AcpiEnableSubsystem
argument_list|(
name|flags
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|AE_OK
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|AE_OK
condition|)
name|sc
operator|->
name|acpi_enabled
operator|=
literal|1
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ACPI_STATUS
name|acpi_Disable
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|acpi_enabled
condition|)
name|status
operator|=
name|AcpiDisable
argument_list|()
expr_stmt|;
else|else
name|status
operator|=
name|AE_OK
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|AE_OK
condition|)
name|sc
operator|->
name|acpi_enabled
operator|=
literal|0
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ACPI Event Handlers  */
end_comment

begin_comment
comment|/* System Event Handlers (registered by EVENTHANDLER_REGISTER) */
end_comment

begin_function
specifier|static
name|void
name|acpi_system_eventhandler_sleep
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|ACPI_LOCK_DECL
expr_stmt|;
name|ACPI_FUNCTION_TRACE_U32
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ACPI_LOCK
expr_stmt|;
if|if
condition|(
name|state
operator|>=
name|ACPI_STATE_S0
operator|&&
name|state
operator|<=
name|ACPI_S_STATES_MAX
condition|)
name|acpi_SetSleepState
argument_list|(
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|arg
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ACPI_UNLOCK
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_system_eventhandler_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|ACPI_LOCK_DECL
expr_stmt|;
name|ACPI_FUNCTION_TRACE_U32
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Well, what to do? :-) */
name|ACPI_LOCK
expr_stmt|;
name|ACPI_UNLOCK
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * ACPICA Event Handlers (FixedEvent, also called from button notify handler)  */
end_comment

begin_function
name|UINT32
name|acpi_eventhandler_power_button_for_sleep
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|acpi_sleep_event
argument_list|,
name|sc
operator|->
name|acpi_power_button_sx
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|UINT32
name|acpi_eventhandler_power_button_for_wakeup
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|acpi_wakeup_event
argument_list|,
name|sc
operator|->
name|acpi_power_button_sx
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|UINT32
name|acpi_eventhandler_sleep_button_for_sleep
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|acpi_sleep_event
argument_list|,
name|sc
operator|->
name|acpi_sleep_button_sx
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|UINT32
name|acpi_eventhandler_sleep_button_for_wakeup
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|acpi_wakeup_event
argument_list|,
name|sc
operator|->
name|acpi_sleep_button_sx
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX This is kinda ugly, and should not be here.  */
end_comment

begin_struct
struct|struct
name|acpi_staticbuf
block|{
name|ACPI_BUFFER
name|buffer
decl_stmt|;
name|char
name|data
index|[
literal|512
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|char
modifier|*
name|acpi_name
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|)
block|{
specifier|static
name|struct
name|acpi_staticbuf
name|buf
decl_stmt|;
name|ACPI_ASSERTLOCK
expr_stmt|;
name|buf
operator|.
name|buffer
operator|.
name|Length
operator|=
literal|512
expr_stmt|;
name|buf
operator|.
name|buffer
operator|.
name|Pointer
operator|=
operator|&
name|buf
operator|.
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetName
argument_list|(
name|handle
argument_list|,
name|ACPI_FULL_PATHNAME
argument_list|,
operator|&
name|buf
operator|.
name|buffer
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|buf
operator|.
name|buffer
operator|.
name|Pointer
operator|)
return|;
return|return
operator|(
literal|"(unknown path)"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Debugging/bug-avoidance.  Avoid trying to fetch info on various  * parts of the namespace.  */
end_comment

begin_function
name|int
name|acpi_avoid
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|env
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|int
name|len
decl_stmt|;
name|np
operator|=
name|acpi_name
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|==
literal|'\\'
condition|)
name|np
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|env
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.avoid"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Scan the avoid list checking for a match */
name|cp
operator|=
name|env
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|0
operator|)
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
break|break;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|cp
index|[
name|len
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
name|cp
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
name|np
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|len
expr_stmt|;
block|}
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Debugging/bug-avoidance.  Disable ACPI subsystem components.  */
end_comment

begin_function
name|int
name|acpi_disabled
parameter_list|(
name|char
modifier|*
name|subsys
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|env
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|env
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.disable"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|env
argument_list|,
literal|"all"
argument_list|)
condition|)
block|{
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* scan the disable list checking for a match */
name|cp
operator|=
name|env
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|0
operator|)
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
break|break;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|cp
index|[
name|len
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
name|cp
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
name|subsys
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|len
expr_stmt|;
block|}
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device wake capability enable/disable.  */
end_comment

begin_function
name|void
name|acpi_device_enable_wake_capability
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|ACPI_OBJECT_LIST
name|ArgList
decl_stmt|;
name|ACPI_OBJECT
name|Arg
decl_stmt|;
comment|/*      * TBD: All Power Resources referenced by elements 2 through N      *      of the _PRW object are put into the ON state.      */
name|ArgList
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|ArgList
operator|.
name|Pointer
operator|=
operator|&
name|Arg
expr_stmt|;
name|Arg
operator|.
name|Type
operator|=
name|ACPI_TYPE_INTEGER
expr_stmt|;
name|Arg
operator|.
name|Integer
operator|.
name|Value
operator|=
name|enable
expr_stmt|;
operator|(
name|void
operator|)
name|AcpiEvaluateObject
argument_list|(
name|h
argument_list|,
literal|"_PSW"
argument_list|,
operator|&
name|ArgList
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|acpi_device_enable_wake_event
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_BUFFER
name|prw_buffer
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|res
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|acpi_devclass
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
comment|/*      * _PRW object is only required for devices that have the ability      * to wake the system from a system sleeping state.      */
name|prw_buffer
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|h
argument_list|,
literal|"_PRW"
argument_list|,
name|NULL
argument_list|,
operator|&
name|prw_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return;
name|res
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|prw_buffer
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|res
operator|->
name|Type
operator|!=
name|ACPI_TYPE_PACKAGE
operator|)
operator|||
operator|(
name|res
operator|->
name|Package
operator|.
name|Count
operator|<
literal|2
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/*      * The element 1 of the _PRW object:      * The lowest power system sleeping state that can be entered      * while still providing wake functionality.      * The sleeping state being entered must be greater or equal to      * the power state declared in element 1 of the _PRW object.      */
if|if
condition|(
name|res
operator|->
name|Package
operator|.
name|Elements
index|[
literal|1
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_INTEGER
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|sc
operator|->
name|acpi_sstate
operator|>
name|res
operator|->
name|Package
operator|.
name|Elements
index|[
literal|1
index|]
operator|.
name|Integer
operator|.
name|Value
condition|)
goto|goto
name|out
goto|;
comment|/*      * The element 0 of the _PRW object:      */
switch|switch
condition|(
name|res
operator|->
name|Package
operator|.
name|Elements
index|[
literal|0
index|]
operator|.
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_INTEGER
case|:
comment|/*  	 * If the data type of this package element is numeric, then this 	 * _PRW package element is the bit index in the GPEx_EN, in the 	 * GPE blocks described in the FADT, of the enable bit that is 	 * enabled for the wake event. 	 */
name|status
operator|=
name|AcpiEnableGpe
argument_list|(
name|NULL
argument_list|,
name|res
operator|->
name|Package
operator|.
name|Elements
index|[
literal|0
index|]
operator|.
name|Integer
operator|.
name|Value
argument_list|,
name|ACPI_EVENT_WAKE_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s: EnableEvent Failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_PACKAGE
case|:
comment|/* 	 * XXX TBD 	 * 	 * If the data type of this package element is a package, then this 	 * _PRW package element is itself a package containing two 	 * elements. The first is an object reference to the GPE Block 	 * device that contains the GPE that will be triggered by the wake 	 * event. The second element is numeric and it contains the bit 	 * index in the GPEx_EN, in the GPE Block referenced by the 	 * first element in the package, of the enable bit that is enabled for 	 * the wake event. 	 * For example, if this field is a package then it is of the form: 	 * Package() {\_SB.PCI0.ISA.GPE, 2} 	 */
break|break;
default|default:
break|break;
block|}
name|out
label|:
if|if
condition|(
name|prw_buffer
operator|.
name|Pointer
operator|!=
name|NULL
condition|)
name|AcpiOsFree
argument_list|(
name|prw_buffer
operator|.
name|Pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Control interface.  *  * We multiplex ioctls for all participating ACPI devices here.  Individual   * drivers wanting to be accessible via /dev/acpi should use the  * register/deregister interface to make their handlers visible.  */
end_comment

begin_struct
struct|struct
name|acpi_ioctl_hook
block|{
name|TAILQ_ENTRY
argument_list|(
argument|acpi_ioctl_hook
argument_list|)
name|link
expr_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|acpi_ioctl_fn
name|fn
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|acpi_ioctl_hook
argument_list|)
name|acpi_ioctl_hooks
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|acpi_ioctl_hooks_initted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Register an ioctl handler.  */
end_comment

begin_function
name|int
name|acpi_register_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|acpi_ioctl_fn
name|fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|acpi_ioctl_hook
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hp
argument_list|)
argument_list|,
name|M_ACPIDEV
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|hp
operator|->
name|cmd
operator|=
name|cmd
expr_stmt|;
name|hp
operator|->
name|fn
operator|=
name|fn
expr_stmt|;
name|hp
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|acpi_ioctl_hooks_initted
operator|==
literal|0
condition|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|acpi_ioctl_hooks
argument_list|)
expr_stmt|;
name|acpi_ioctl_hooks_initted
operator|=
literal|1
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|acpi_ioctl_hooks
argument_list|,
name|hp
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deregister an ioctl handler.  */
end_comment

begin_function
name|void
name|acpi_deregister_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|acpi_ioctl_fn
name|fn
parameter_list|)
block|{
name|struct
name|acpi_ioctl_hook
modifier|*
name|hp
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|hp
argument_list|,
argument|&acpi_ioctl_hooks
argument_list|,
argument|link
argument_list|)
if|if
condition|(
operator|(
name|hp
operator|->
name|cmd
operator|==
name|cmd
operator|)
operator|&&
operator|(
name|hp
operator|->
name|fn
operator|==
name|fn
operator|)
condition|)
break|break;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|acpi_ioctl_hooks
argument_list|,
name|hp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hp
argument_list|,
name|M_ACPIDEV
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|acpiopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpiclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpiioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|acpi_ioctl_hook
modifier|*
name|hp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|xerror
decl_stmt|,
name|state
decl_stmt|;
name|ACPI_LOCK_DECL
expr_stmt|;
name|ACPI_LOCK
expr_stmt|;
name|error
operator|=
name|state
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
comment|/*      * Scan the list of registered ioctls, looking for handlers.      */
if|if
condition|(
name|acpi_ioctl_hooks_initted
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|hp
argument_list|,
argument|&acpi_ioctl_hooks
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|hp
operator|->
name|cmd
operator|==
name|cmd
condition|)
block|{
name|xerror
operator|=
name|hp
operator|->
name|fn
argument_list|(
name|cmd
argument_list|,
name|addr
argument_list|,
name|hp
operator|->
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|xerror
operator|!=
literal|0
condition|)
name|error
operator|=
name|xerror
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
comment|/*      * Core ioctls are not permitted for non-writable user.      * Currently, other ioctls just fetch information.      * Not changing system behavior.      */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* Core system ioctls. */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ACPIIO_ENABLE
case|:
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|acpi_Enable
argument_list|(
name|sc
argument_list|)
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
case|case
name|ACPIIO_DISABLE
case|:
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|acpi_Disable
argument_list|(
name|sc
argument_list|)
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
case|case
name|ACPIIO_SETSLPSTATE
case|:
if|if
condition|(
operator|!
name|sc
operator|->
name|acpi_enabled
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|state
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|state
operator|>=
name|ACPI_STATE_S0
operator|&&
name|state
operator|<=
name|ACPI_S_STATES_MAX
condition|)
name|acpi_SetSleepState
argument_list|(
name|sc
argument_list|,
name|state
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|out
label|:
name|ACPI_UNLOCK
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_supported_sleep_state_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|sleep_state
index|[
literal|4
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|UINT8
name|state
decl_stmt|,
name|TypeA
decl_stmt|,
name|TypeB
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|state
operator|=
name|ACPI_STATE_S1
init|;
name|state
operator|<
name|ACPI_S_STATES_MAX
operator|+
literal|1
condition|;
name|state
operator|++
control|)
block|{
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetSleepTypeData
argument_list|(
name|state
argument_list|,
operator|&
name|TypeA
argument_list|,
operator|&
name|TypeB
argument_list|)
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|sleep_state
argument_list|,
literal|"S%d "
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|sleep_state
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_sleep_state_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|sleep_state
index|[
literal|10
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|new_state
decl_stmt|,
name|old_state
decl_stmt|;
name|old_state
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
if|if
condition|(
name|old_state
operator|>
name|ACPI_S_STATES_MAX
operator|+
literal|1
condition|)
block|{
name|strcpy
argument_list|(
name|sleep_state
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|sleep_state
argument_list|,
sizeof|sizeof
argument_list|(
name|sleep_state
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|sleep_state
argument_list|,
name|sleep_state_names
index|[
name|old_state
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sleep_state_names
index|[
name|old_state
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sleep_state
argument_list|,
sizeof|sizeof
argument_list|(
name|sleep_state
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
name|new_state
operator|=
name|ACPI_STATE_S0
expr_stmt|;
for|for
control|(
init|;
name|new_state
operator|<=
name|ACPI_S_STATES_MAX
operator|+
literal|1
condition|;
name|new_state
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|sleep_state
argument_list|,
name|sleep_state_names
index|[
name|new_state
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sleep_state
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|new_state
operator|<=
name|ACPI_S_STATES_MAX
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|new_state
operator|!=
name|old_state
condition|)
operator|*
operator|(
name|u_int
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|=
name|new_state
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ACPI_DEBUG
end_ifdef

begin_comment
comment|/*  * Support for parsing debug options from the kernel environment.  *  * Bits may be set in the AcpiDbgLayer and AcpiDbgLevel debug registers  * by specifying the names of the bits in the debug.acpi.layer and  * debug.acpi.level environment variables.  Bits may be unset by   * prefixing the bit name with !.  */
end_comment

begin_struct
struct|struct
name|debugtag
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|UINT32
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|debugtag
name|dbg_layer
index|[]
init|=
block|{
block|{
literal|"ACPI_UTILITIES"
block|,
name|ACPI_UTILITIES
block|}
block|,
block|{
literal|"ACPI_HARDWARE"
block|,
name|ACPI_HARDWARE
block|}
block|,
block|{
literal|"ACPI_EVENTS"
block|,
name|ACPI_EVENTS
block|}
block|,
block|{
literal|"ACPI_TABLES"
block|,
name|ACPI_TABLES
block|}
block|,
block|{
literal|"ACPI_NAMESPACE"
block|,
name|ACPI_NAMESPACE
block|}
block|,
block|{
literal|"ACPI_PARSER"
block|,
name|ACPI_PARSER
block|}
block|,
block|{
literal|"ACPI_DISPATCHER"
block|,
name|ACPI_DISPATCHER
block|}
block|,
block|{
literal|"ACPI_EXECUTER"
block|,
name|ACPI_EXECUTER
block|}
block|,
block|{
literal|"ACPI_RESOURCES"
block|,
name|ACPI_RESOURCES
block|}
block|,
block|{
literal|"ACPI_CA_DEBUGGER"
block|,
name|ACPI_CA_DEBUGGER
block|}
block|,
block|{
literal|"ACPI_OS_SERVICES"
block|,
name|ACPI_OS_SERVICES
block|}
block|,
block|{
literal|"ACPI_CA_DISASSEMBLER"
block|,
name|ACPI_CA_DISASSEMBLER
block|}
block|,
block|{
literal|"ACPI_BUS"
block|,
name|ACPI_BUS
block|}
block|,
block|{
literal|"ACPI_SYSTEM"
block|,
name|ACPI_SYSTEM
block|}
block|,
block|{
literal|"ACPI_POWER"
block|,
name|ACPI_POWER
block|}
block|,
block|{
literal|"ACPI_EC"
block|,
name|ACPI_EC
block|}
block|,
block|{
literal|"ACPI_AC_ADAPTER"
block|,
name|ACPI_AC_ADAPTER
block|}
block|,
block|{
literal|"ACPI_BATTERY"
block|,
name|ACPI_BATTERY
block|}
block|,
block|{
literal|"ACPI_BUTTON"
block|,
name|ACPI_BUTTON
block|}
block|,
block|{
literal|"ACPI_PROCESSOR"
block|,
name|ACPI_PROCESSOR
block|}
block|,
block|{
literal|"ACPI_THERMAL"
block|,
name|ACPI_THERMAL
block|}
block|,
block|{
literal|"ACPI_FAN"
block|,
name|ACPI_FAN
block|}
block|,
block|{
literal|"ACPI_ALL_DRIVERS"
block|,
name|ACPI_ALL_DRIVERS
block|}
block|,
block|{
literal|"ACPI_ALL_COMPONENTS"
block|,
name|ACPI_ALL_COMPONENTS
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|debugtag
name|dbg_level
index|[]
init|=
block|{
block|{
literal|"ACPI_LV_ERROR"
block|,
name|ACPI_LV_ERROR
block|}
block|,
block|{
literal|"ACPI_LV_WARN"
block|,
name|ACPI_LV_WARN
block|}
block|,
block|{
literal|"ACPI_LV_INIT"
block|,
name|ACPI_LV_INIT
block|}
block|,
block|{
literal|"ACPI_LV_DEBUG_OBJECT"
block|,
name|ACPI_LV_DEBUG_OBJECT
block|}
block|,
block|{
literal|"ACPI_LV_INFO"
block|,
name|ACPI_LV_INFO
block|}
block|,
block|{
literal|"ACPI_LV_ALL_EXCEPTIONS"
block|,
name|ACPI_LV_ALL_EXCEPTIONS
block|}
block|,
comment|/* Trace verbosity level 1 [Standard Trace Level] */
block|{
literal|"ACPI_LV_PARSE"
block|,
name|ACPI_LV_PARSE
block|}
block|,
block|{
literal|"ACPI_LV_LOAD"
block|,
name|ACPI_LV_LOAD
block|}
block|,
block|{
literal|"ACPI_LV_DISPATCH"
block|,
name|ACPI_LV_DISPATCH
block|}
block|,
block|{
literal|"ACPI_LV_EXEC"
block|,
name|ACPI_LV_EXEC
block|}
block|,
block|{
literal|"ACPI_LV_NAMES"
block|,
name|ACPI_LV_NAMES
block|}
block|,
block|{
literal|"ACPI_LV_OPREGION"
block|,
name|ACPI_LV_OPREGION
block|}
block|,
block|{
literal|"ACPI_LV_BFIELD"
block|,
name|ACPI_LV_BFIELD
block|}
block|,
block|{
literal|"ACPI_LV_TABLES"
block|,
name|ACPI_LV_TABLES
block|}
block|,
block|{
literal|"ACPI_LV_VALUES"
block|,
name|ACPI_LV_VALUES
block|}
block|,
block|{
literal|"ACPI_LV_OBJECTS"
block|,
name|ACPI_LV_OBJECTS
block|}
block|,
block|{
literal|"ACPI_LV_RESOURCES"
block|,
name|ACPI_LV_RESOURCES
block|}
block|,
block|{
literal|"ACPI_LV_USER_REQUESTS"
block|,
name|ACPI_LV_USER_REQUESTS
block|}
block|,
block|{
literal|"ACPI_LV_PACKAGE"
block|,
name|ACPI_LV_PACKAGE
block|}
block|,
block|{
literal|"ACPI_LV_INIT_NAMES"
block|,
name|ACPI_LV_INIT_NAMES
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSITY1"
block|,
name|ACPI_LV_VERBOSITY1
block|}
block|,
comment|/* Trace verbosity level 2 [Function tracing and memory allocation] */
block|{
literal|"ACPI_LV_ALLOCATIONS"
block|,
name|ACPI_LV_ALLOCATIONS
block|}
block|,
block|{
literal|"ACPI_LV_FUNCTIONS"
block|,
name|ACPI_LV_FUNCTIONS
block|}
block|,
block|{
literal|"ACPI_LV_OPTIMIZATIONS"
block|,
name|ACPI_LV_OPTIMIZATIONS
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSITY2"
block|,
name|ACPI_LV_VERBOSITY2
block|}
block|,
block|{
literal|"ACPI_LV_ALL"
block|,
name|ACPI_LV_ALL
block|}
block|,
comment|/* Trace verbosity level 3 [Threading, I/O, and Interrupts] */
block|{
literal|"ACPI_LV_MUTEX"
block|,
name|ACPI_LV_MUTEX
block|}
block|,
block|{
literal|"ACPI_LV_THREADS"
block|,
name|ACPI_LV_THREADS
block|}
block|,
block|{
literal|"ACPI_LV_IO"
block|,
name|ACPI_LV_IO
block|}
block|,
block|{
literal|"ACPI_LV_INTERRUPTS"
block|,
name|ACPI_LV_INTERRUPTS
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSITY3"
block|,
name|ACPI_LV_VERBOSITY3
block|}
block|,
comment|/* Exceptionally verbose output -- also used in the global "DebugLevel"  */
block|{
literal|"ACPI_LV_AML_DISASSEMBLE"
block|,
name|ACPI_LV_AML_DISASSEMBLE
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSE_INFO"
block|,
name|ACPI_LV_VERBOSE_INFO
block|}
block|,
block|{
literal|"ACPI_LV_FULL_TABLES"
block|,
name|ACPI_LV_FULL_TABLES
block|}
block|,
block|{
literal|"ACPI_LV_EVENTS"
block|,
name|ACPI_LV_EVENTS
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSE"
block|,
name|ACPI_LV_VERBOSE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|acpi_parse_debug
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|struct
name|debugtag
modifier|*
name|tag
parameter_list|,
name|UINT32
modifier|*
name|flag
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|int
name|set
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
name|ep
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|ep
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|ep
argument_list|)
condition|)
name|ep
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'!'
condition|)
block|{
name|set
operator|=
literal|0
expr_stmt|;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|ep
condition|)
continue|continue;
block|}
else|else
block|{
name|set
operator|=
literal|1
expr_stmt|;
block|}
name|l
operator|=
name|ep
operator|-
name|cp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tag
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
name|tag
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|l
argument_list|)
condition|)
block|{
if|if
condition|(
name|set
condition|)
operator|*
name|flag
operator||=
name|tag
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
else|else
operator|*
name|flag
operator|&=
operator|~
name|tag
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
name|printf
argument_list|(
literal|"ACPI_DEBUG: set '%s'\n"
argument_list|,
name|tag
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|cp
operator|=
name|ep
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_set_debugging
parameter_list|(
name|void
modifier|*
name|junk
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|cold
condition|)
return|return;
name|AcpiDbgLayer
operator|=
literal|0
expr_stmt|;
name|AcpiDbgLevel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.layer"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|acpi_parse_debug
argument_list|(
name|cp
argument_list|,
operator|&
name|dbg_layer
index|[
literal|0
index|]
argument_list|,
operator|&
name|AcpiDbgLayer
argument_list|)
expr_stmt|;
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"debug.acpi.level"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|acpi_parse_debug
argument_list|(
name|cp
argument_list|,
operator|&
name|dbg_level
index|[
literal|0
index|]
argument_list|,
operator|&
name|AcpiDbgLevel
argument_list|)
expr_stmt|;
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ACPI debug layer 0x%x debug level 0x%x\n"
argument_list|,
name|AcpiDbgLayer
argument_list|,
name|AcpiDbgLevel
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|acpi_debugging
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|acpi_set_debugging
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|acpi_pm_func
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|state
decl_stmt|,
name|acpi_state
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|POWER_CMD_SUSPEND
case|:
name|sc
operator|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|state
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|POWER_SLEEP_STATE_STANDBY
case|:
name|acpi_state
operator|=
name|sc
operator|->
name|acpi_standby_sx
expr_stmt|;
break|break;
case|case
name|POWER_SLEEP_STATE_SUSPEND
case|:
name|acpi_state
operator|=
name|sc
operator|->
name|acpi_suspend_sx
expr_stmt|;
break|break;
case|case
name|POWER_SLEEP_STATE_HIBERNATE
case|:
name|acpi_state
operator|=
name|ACPI_STATE_S4
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|acpi_SetSleepState
argument_list|(
name|sc
argument_list|,
name|acpi_state
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_pm_register
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cold
operator|||
name|resource_disabled
argument_list|(
literal|"acpi"
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|power_pm_register
argument_list|(
name|POWER_PM_TYPE_ACPI
argument_list|,
name|acpi_pm_func
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|power
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|acpi_pm_register
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

