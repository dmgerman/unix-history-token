begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Takanori Watanabe<takawata@jp.freebsd.org>  * Copyright (c) 2000 Mitsuru IWASAKI<iwasaki@jp.freebsd.org>  * Copyright (c) 2000, 2001 Michael Smith  * Copyright (c) 2000 BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_include
include|#
directive|include
file|"opt_device_numa.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/power.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/timetc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/pci_cfgreg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<isa/pnpvar.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acnamesp.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpiio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_ACPIDEV
argument_list|,
literal|"acpidev"
argument_list|,
literal|"ACPI devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Hooks for the ACPI CA debugging infrastructure */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_BUS
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"ACPI"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|d_open_t
name|acpiopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|acpiclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|acpiioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|acpi_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|acpiopen
block|,
operator|.
name|d_close
operator|=
name|acpiclose
block|,
operator|.
name|d_ioctl
operator|=
name|acpiioctl
block|,
operator|.
name|d_name
operator|=
literal|"acpi"
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|acpi_interface
block|{
name|ACPI_STRING
modifier|*
name|data
decl_stmt|;
name|int
name|num
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Global mutex for locking access to the ACPI subsystem. */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|acpi_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|callout
name|acpi_sleep_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bitmap of device quirks. */
end_comment

begin_decl_stmt
name|int
name|acpi_quirks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Supported sleep states. */
end_comment

begin_decl_stmt
specifier|static
name|BOOLEAN
name|acpi_sleep_states
index|[
name|ACPI_S_STATE_COUNT
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|acpi_lookup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|device_t
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_modevent
parameter_list|(
name|struct
name|module
modifier|*
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|junk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|device_t
name|acpi_add_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|u_int
name|order
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_print_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_probe_nomatch
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_driver_added
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|driver_t
modifier|*
name|driver
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|resource_list
modifier|*
name|acpi_get_rlist
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_reserve_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_sysres_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_set_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|resource
modifier|*
name|acpi_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_adjust_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_release_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_delete_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|acpi_isa_get_logicalid
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_isa_get_compatid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
modifier|*
name|cids
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|acpi_device_id_probe
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|char
modifier|*
modifier|*
name|ids
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_device_eval_obj
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|ACPI_STRING
name|pathname
parameter_list|,
name|ACPI_OBJECT_LIST
modifier|*
name|parameters
parameter_list|,
name|ACPI_BUFFER
modifier|*
name|ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_device_scan_cb
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
modifier|*
name|retval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_device_scan_children
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|max_depth
parameter_list|,
name|acpi_scan_cb_t
name|user_fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_set_powerstate
parameter_list|(
name|device_t
name|child
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_isa_pnp_probe
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|isa_pnp_id
modifier|*
name|ids
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_probe_children
parameter_list|(
name|device_t
name|bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_probe_order
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|int
modifier|*
name|order
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_probe_child
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_sleep_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_sleep_disable
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|acpi_EnterSleepState
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_shutdown_final
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_enable_fixed_events
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOLEAN
name|acpi_has_hid
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_resync_clock
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_wake_sleep_prep
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|int
name|sstate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_wake_run_prep
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|int
name|sstate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_wake_prep_walk
parameter_list|(
name|int
name|sstate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_wake_sysctl_walk
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_wake_set_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_system_eventhandler_sleep
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_system_eventhandler_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_sname2sstate
parameter_list|(
specifier|const
name|char
modifier|*
name|sname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|acpi_sstate2sname
parameter_list|(
name|int
name|sstate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_supported_sleep_state_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_sleep_state_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_debug_objects_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_pm_func
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_child_location_str_method
parameter_list|(
name|device_t
name|acdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_child_pnpinfo_str_method
parameter_list|(
name|device_t
name|acdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|acpi_enable_pcie
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|acpi_hint_device_unit
parameter_list|(
name|device_t
name|acdev
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|unitp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_reset_interfaces
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|acpi_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|acpi_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|acpi_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|acpi_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|acpi_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|acpi_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_add_child
argument_list|,
name|acpi_add_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|acpi_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_probe_nomatch
argument_list|,
name|acpi_probe_nomatch
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|acpi_driver_added
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|acpi_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|acpi_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource_list
argument_list|,
name|acpi_get_rlist
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_set_resource
argument_list|,
name|acpi_set_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource
argument_list|,
name|bus_generic_rl_get_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|acpi_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_adjust_resource
argument_list|,
name|acpi_adjust_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|acpi_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_delete_resource
argument_list|,
name|acpi_delete_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_pnpinfo_str
argument_list|,
name|acpi_child_pnpinfo_str_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|acpi_child_location_str_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bus_generic_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_hint_device_unit
argument_list|,
name|acpi_hint_device_unit
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_cpus
argument_list|,
name|acpi_get_cpus
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_domain
argument_list|,
name|acpi_get_domain
argument_list|)
block|,
comment|/* ACPI bus */
name|DEVMETHOD
argument_list|(
name|acpi_id_probe
argument_list|,
name|acpi_device_id_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|acpi_evaluate_object
argument_list|,
name|acpi_device_eval_obj
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|acpi_pwr_for_sleep
argument_list|,
name|acpi_device_pwr_for_sleep
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|acpi_scan_children
argument_list|,
name|acpi_device_scan_children
argument_list|)
block|,
comment|/* ISA emulation */
name|DEVMETHOD
argument_list|(
name|isa_pnp_probe
argument_list|,
name|acpi_isa_pnp_probe
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|acpi_driver
init|=
block|{
literal|"acpi"
block|,
name|acpi_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|acpi_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|acpi
argument_list|,
name|nexus
argument_list|,
name|acpi_driver
argument_list|,
name|acpi_devclass
argument_list|,
name|acpi_modevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|acpi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ACPI_SERIAL_DECL
argument_list|(
name|acpi
argument_list|,
literal|"ACPI root bus"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Local pools for managing system resources for ACPI child devices. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rman
name|acpi_rman_io
decl_stmt|,
name|acpi_rman_mem
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ACPI_MINIMUM_AWAKETIME
value|5
end_define

begin_comment
comment|/* Holds the description of the acpi0 device. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|acpi_desc
index|[
name|ACPI_OEM_ID_SIZE
operator|+
name|ACPI_OEM_TABLE_ID_SIZE
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|acpi
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"ACPI debugging"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
name|acpi_ca_version
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_debug_acpi
argument_list|,
name|OID_AUTO
argument_list|,
name|acpi_ca_version
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|acpi_ca_version
argument_list|,
literal|0
argument_list|,
literal|"Version of Intel ACPI-CA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Allow overriding _OSI methods.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|acpi_install_interface
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_STR
argument_list|(
literal|"hw.acpi.install_interface"
argument_list|,
name|acpi_install_interface
argument_list|,
sizeof|sizeof
argument_list|(
name|acpi_install_interface
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
name|acpi_remove_interface
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_STR
argument_list|(
literal|"hw.acpi.remove_interface"
argument_list|,
name|acpi_remove_interface
argument_list|,
sizeof|sizeof
argument_list|(
name|acpi_remove_interface
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Allow users to dump Debug objects without ACPI debugger. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|acpi_debug_objects
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.acpi.enable_debug_objects"
argument_list|,
operator|&
name|acpi_debug_objects
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_acpi
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_debug_objects
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLTYPE_INT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|acpi_debug_objects_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Enable Debug objects"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Allow the interpreter to ignore common mistakes in BIOS. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|acpi_interpreter_slack
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.acpi.interpreter_slack"
argument_list|,
operator|&
name|acpi_interpreter_slack
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_acpi
argument_list|,
name|OID_AUTO
argument_list|,
name|interpreter_slack
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|acpi_interpreter_slack
argument_list|,
literal|1
argument_list|,
literal|"Turn on interpreter slack mode."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Ignore register widths set by FADT and use default widths instead. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|acpi_ignore_reg_width
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.acpi.default_register_width"
argument_list|,
operator|&
name|acpi_ignore_reg_width
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_acpi
argument_list|,
name|OID_AUTO
argument_list|,
name|default_register_width
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|acpi_ignore_reg_width
argument_list|,
literal|1
argument_list|,
literal|"Ignore register widths set by FADT"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Allow users to override quirks. */
end_comment

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.acpi.quirks"
argument_list|,
operator|&
name|acpi_quirks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|acpi_susp_bounce
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_acpi
argument_list|,
name|OID_AUTO
argument_list|,
name|suspend_bounce
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|acpi_susp_bounce
argument_list|,
literal|0
argument_list|,
literal|"Don't actually suspend, just test devices."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ACPI can only be loaded as a module by the loader; activating it after  * system bootstrap time is not useful, and can be fatal to the system.  * It also cannot be unloaded, since the entire system bus hierarchy hangs  * off it.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_modevent
parameter_list|(
name|struct
name|module
modifier|*
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|junk
parameter_list|)
block|{
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
operator|!
name|cold
condition|)
block|{
name|printf
argument_list|(
literal|"The ACPI driver cannot be loaded after boot.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
break|break;
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
operator|!
name|cold
operator|&&
name|power_pm_get_type
argument_list|()
operator|==
name|POWER_PM_TYPE_ACPI
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform early initialization.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_Startup
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|started
init|=
literal|0
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|val
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* Only run the startup code once.  The MADT driver also calls this. */
if|if
condition|(
name|started
condition|)
name|return_VALUE
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
name|started
operator|=
literal|1
expr_stmt|;
comment|/*      * Initialize the ACPICA subsystem.      */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiInitializeSubsystem
argument_list|()
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI: Could not initialize Subsystem: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
comment|/*      * Pre-allocate space for RSDT/XSDT and DSDT tables and allow resizing      * if more tables exist.      */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiInitializeTables
argument_list|(
name|NULL
argument_list|,
literal|2
argument_list|,
name|TRUE
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI: Table initialisation failed: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* Set up any quirks we have for this system. */
if|if
condition|(
name|acpi_quirks
operator|==
name|ACPI_Q_OK
condition|)
name|acpi_table_quirks
argument_list|(
operator|&
name|acpi_quirks
argument_list|)
expr_stmt|;
comment|/* If the user manually set the disabled hint to 0, force-enable ACPI. */
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"acpi"
argument_list|,
literal|0
argument_list|,
literal|"disabled"
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|&&
name|val
operator|==
literal|0
condition|)
name|acpi_quirks
operator|&=
operator|~
name|ACPI_Q_BROKEN
expr_stmt|;
if|if
condition|(
name|acpi_quirks
operator|&
name|ACPI_Q_BROKEN
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI disabled by blacklist.  Contact your BIOS vendor.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|AE_SUPPORT
expr_stmt|;
block|}
name|return_VALUE
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Detect ACPI and perform early initialisation.  */
end_comment

begin_function
name|int
name|acpi_identify
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_TABLE_RSDP
modifier|*
name|rsdp
decl_stmt|;
name|ACPI_TABLE_HEADER
modifier|*
name|rsdt
decl_stmt|;
name|ACPI_PHYSICAL_ADDRESS
name|paddr
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cold
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Check that we haven't been disabled with a hint. */
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"acpi"
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Check for other PM systems. */
if|if
condition|(
name|power_pm_get_type
argument_list|()
operator|!=
name|POWER_PM_TYPE_NONE
operator|&&
name|power_pm_get_type
argument_list|()
operator|!=
name|POWER_PM_TYPE_ACPI
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI identify failed, other PM system enabled.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Initialize root tables. */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|acpi_Startup
argument_list|()
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI: Try disabling either ACPI or apic support.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|paddr
operator|=
name|AcpiOsGetRootPointer
argument_list|()
operator|)
operator|==
literal|0
operator|||
operator|(
name|rsdp
operator|=
name|AcpiOsMapMemory
argument_list|(
name|paddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ACPI_TABLE_RSDP
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|rsdp
operator|->
name|Revision
operator|>
literal|1
operator|&&
name|rsdp
operator|->
name|XsdtPhysicalAddress
operator|!=
literal|0
condition|)
name|paddr
operator|=
operator|(
name|ACPI_PHYSICAL_ADDRESS
operator|)
name|rsdp
operator|->
name|XsdtPhysicalAddress
expr_stmt|;
else|else
name|paddr
operator|=
operator|(
name|ACPI_PHYSICAL_ADDRESS
operator|)
name|rsdp
operator|->
name|RsdtPhysicalAddress
expr_stmt|;
name|AcpiOsUnmapMemory
argument_list|(
name|rsdp
argument_list|,
sizeof|sizeof
argument_list|(
name|ACPI_TABLE_RSDP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rsdt
operator|=
name|AcpiOsMapMemory
argument_list|(
name|paddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ACPI_TABLE_HEADER
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|acpi_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|acpi_desc
argument_list|)
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
operator|&
name|sb
argument_list|,
name|rsdt
operator|->
name|OemId
argument_list|,
name|ACPI_OEM_ID_SIZE
argument_list|)
expr_stmt|;
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_putc
argument_list|(
operator|&
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
operator|&
name|sb
argument_list|,
name|rsdt
operator|->
name|OemTableId
argument_list|,
name|ACPI_OEM_TABLE_ID_SIZE
argument_list|)
expr_stmt|;
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|AcpiOsUnmapMemory
argument_list|(
name|rsdt
argument_list|,
sizeof|sizeof
argument_list|(
name|ACPI_TABLE_HEADER
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|acpi_ca_version
argument_list|,
sizeof|sizeof
argument_list|(
name|acpi_ca_version
argument_list|)
argument_list|,
literal|"%x"
argument_list|,
name|ACPI_CA_VERSION
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch some descriptive data from ACPI to put in our attach message.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|acpi_desc
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|BUS_PROBE_NOWILDCARD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|error
decl_stmt|,
name|state
decl_stmt|;
name|UINT32
name|flags
decl_stmt|;
name|UINT8
name|TypeA
decl_stmt|,
name|TypeB
decl_stmt|;
name|char
modifier|*
name|env
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_dev
operator|=
name|dev
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|susp_force_to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
comment|/* Initialize resource manager. */
name|acpi_rman_io
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|acpi_rman_io
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|acpi_rman_io
operator|.
name|rm_end
operator|=
literal|0xffff
expr_stmt|;
name|acpi_rman_io
operator|.
name|rm_descr
operator|=
literal|"ACPI I/O ports"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|acpi_rman_io
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"acpi rman_init IO ports failed"
argument_list|)
expr_stmt|;
name|acpi_rman_mem
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|acpi_rman_mem
operator|.
name|rm_descr
operator|=
literal|"ACPI I/O memory addresses"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|acpi_rman_mem
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"acpi rman_init memory failed"
argument_list|)
expr_stmt|;
comment|/* Initialise the ACPI mutex */
name|mtx_init
argument_list|(
operator|&
name|acpi_mutex
argument_list|,
literal|"ACPI global lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/*      * Set the globals from our tunables.  This is needed because ACPI-CA      * uses UINT8 for some values and we have no tunable_byte.      */
name|AcpiGbl_EnableInterpreterSlack
operator|=
name|acpi_interpreter_slack
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|AcpiGbl_EnableAmlDebugObject
operator|=
name|acpi_debug_objects
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|AcpiGbl_UseDefaultRegisterWidths
operator|=
name|acpi_ignore_reg_width
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
ifndef|#
directive|ifndef
name|ACPI_DEBUG
comment|/*      * Disable all debugging layers and levels.      */
name|AcpiDbgLayer
operator|=
literal|0
expr_stmt|;
name|AcpiDbgLevel
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Override OS interfaces if the user requested. */
name|acpi_reset_interfaces
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Load ACPI name space. */
name|status
operator|=
name|AcpiLoadTables
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not load Namespace: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
comment|/* Handle MCFG table if present. */
name|acpi_enable_pcie
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/*      * Note that some systems (specifically, those with namespace evaluation      * issues that require the avoidance of parts of the namespace) must      * avoid running _INI and _STA on everything, as well as dodging the final      * object init pass.      *      * For these devices, we set ACPI_NO_DEVICE_INIT and ACPI_NO_OBJECT_INIT).      *      * XXX We should arrange for the object init pass after we have attached      *     all our child devices, but on many systems it works here.      */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|testenv
argument_list|(
literal|"debug.acpi.avoid"
argument_list|)
condition|)
name|flags
operator|=
name|ACPI_NO_DEVICE_INIT
operator||
name|ACPI_NO_OBJECT_INIT
expr_stmt|;
comment|/* Bring the hardware and basic handlers online. */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiEnableSubsystem
argument_list|(
name|flags
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not enable ACPI: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Call the ECDT probe function to provide EC functionality before      * the namespace has been evaluated.      *      * XXX This happens before the sysresource devices have been probed and      * attached so its resources come from nexus0.  In practice, this isn't      * a problem but should be addressed eventually.      */
name|acpi_ec_ecdt_probe
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Bring device objects and regions online. */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
operator|=
name|AcpiInitializeObjects
argument_list|(
name|flags
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not initialize ACPI objects: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Setup our sysctl tree.      *      * XXX: This doesn't check to make sure that none of these fail.      */
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"supported_sleep_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|acpi_supported_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"List supported ACPI sleep states."
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"power_button_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_power_button_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"Power button ACPI sleep state."
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sleep_button_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_sleep_button_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"Sleep button ACPI sleep state."
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lid_switch_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_lid_switch_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"Lid ACPI sleep state. Set to S3 if you want to suspend your laptop when close the Lid."
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"standby_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_standby_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"suspend_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_suspend_sx
argument_list|,
literal|0
argument_list|,
name|acpi_sleep_state_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sleep_delay"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_sleep_delay
argument_list|,
literal|0
argument_list|,
literal|"sleep delay in seconds"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"s4bios"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_s4bios
argument_list|,
literal|0
argument_list|,
literal|"S4BIOS mode"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"verbose"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_verbose
argument_list|,
literal|0
argument_list|,
literal|"verbose mode"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"disable_on_reboot"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_do_disable
argument_list|,
literal|0
argument_list|,
literal|"Disable ACPI when rebooting/halting system"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|acpi_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|acpi_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"handle_reboot"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|acpi_handle_reboot
argument_list|,
literal|0
argument_list|,
literal|"Use ACPI Reset Register to reboot"
argument_list|)
expr_stmt|;
comment|/*      * Default to 1 second before sleeping to give some machines time to      * stabilize.      */
name|sc
operator|->
name|acpi_sleep_delay
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|sc
operator|->
name|acpi_verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|env
operator|=
name|kern_getenv
argument_list|(
literal|"hw.acpi.verbose"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|env
argument_list|,
literal|"0"
argument_list|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|acpi_verbose
operator|=
literal|1
expr_stmt|;
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
comment|/* Only enable reboot by default if the FADT says it is available. */
if|if
condition|(
name|AcpiGbl_FADT
operator|.
name|Flags
operator|&
name|ACPI_FADT_RESET_REGISTER
condition|)
name|sc
operator|->
name|acpi_handle_reboot
operator|=
literal|1
expr_stmt|;
if|#
directive|if
operator|!
name|ACPI_REDUCED_HARDWARE
comment|/* Only enable S4BIOS by default if the FACS says it is available. */
if|if
condition|(
name|AcpiGbl_FACS
operator|!=
name|NULL
operator|&&
name|AcpiGbl_FACS
operator|->
name|Flags
operator|&
name|ACPI_FACS_S4_BIOS_PRESENT
condition|)
name|sc
operator|->
name|acpi_s4bios
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Probe all supported sleep states. */
name|acpi_sleep_states
index|[
name|ACPI_STATE_S0
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|state
operator|=
name|ACPI_STATE_S1
init|;
name|state
operator|<
name|ACPI_S_STATE_COUNT
condition|;
name|state
operator|++
control|)
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiEvaluateObject
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|AcpiGbl_SleepStateNames
index|[
name|state
index|]
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
operator|&&
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetSleepTypeData
argument_list|(
name|state
argument_list|,
operator|&
name|TypeA
argument_list|,
operator|&
name|TypeB
argument_list|)
argument_list|)
condition|)
name|acpi_sleep_states
index|[
name|state
index|]
operator|=
name|TRUE
expr_stmt|;
comment|/*      * Dispatch the default sleep state to devices.  The lid switch is set      * to UNKNOWN by default to avoid surprising users.      */
name|sc
operator|->
name|acpi_power_button_sx
operator|=
name|acpi_sleep_states
index|[
name|ACPI_STATE_S5
index|]
condition|?
name|ACPI_STATE_S5
else|:
name|ACPI_STATE_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|acpi_lid_switch_sx
operator|=
name|ACPI_STATE_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|acpi_standby_sx
operator|=
name|acpi_sleep_states
index|[
name|ACPI_STATE_S1
index|]
condition|?
name|ACPI_STATE_S1
else|:
name|ACPI_STATE_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|acpi_suspend_sx
operator|=
name|acpi_sleep_states
index|[
name|ACPI_STATE_S3
index|]
condition|?
name|ACPI_STATE_S3
else|:
name|ACPI_STATE_UNKNOWN
expr_stmt|;
comment|/* Pick the first valid sleep state for the sleep button default. */
name|sc
operator|->
name|acpi_sleep_button_sx
operator|=
name|ACPI_STATE_UNKNOWN
expr_stmt|;
for|for
control|(
name|state
operator|=
name|ACPI_STATE_S1
init|;
name|state
operator|<=
name|ACPI_STATE_S4
condition|;
name|state
operator|++
control|)
if|if
condition|(
name|acpi_sleep_states
index|[
name|state
index|]
condition|)
block|{
name|sc
operator|->
name|acpi_sleep_button_sx
operator|=
name|state
expr_stmt|;
break|break;
block|}
name|acpi_enable_fixed_events
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Scan the namespace and attach/initialise children.      */
comment|/* Register our shutdown handler. */
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|acpi_shutdown_final
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_LAST
argument_list|)
expr_stmt|;
comment|/*      * Register our acpi event handlers.      * XXX should be configurable eg. via userland policy manager.      */
name|EVENTHANDLER_REGISTER
argument_list|(
name|acpi_sleep_event
argument_list|,
name|acpi_system_eventhandler_sleep
argument_list|,
name|sc
argument_list|,
name|ACPI_EVENT_PRI_LAST
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|acpi_wakeup_event
argument_list|,
name|acpi_system_eventhandler_wakeup
argument_list|,
name|sc
argument_list|,
name|ACPI_EVENT_PRI_LAST
argument_list|)
expr_stmt|;
comment|/* Flag our initial states. */
name|sc
operator|->
name|acpi_enabled
operator|=
name|TRUE
expr_stmt|;
name|sc
operator|->
name|acpi_sstate
operator|=
name|ACPI_STATE_S0
expr_stmt|;
name|sc
operator|->
name|acpi_sleep_disabled
operator|=
name|TRUE
expr_stmt|;
comment|/* Create the control device */
name|sc
operator|->
name|acpi_dev_t
operator|=
name|make_dev
argument_list|(
operator|&
name|acpi_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0644
argument_list|,
literal|"acpi"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_dev_t
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|acpi_machdep_init
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* Register ACPI again to pass the correct argument of pm_func. */
name|power_pm_register
argument_list|(
name|POWER_PM_TYPE_ACPI
argument_list|,
name|acpi_pm_func
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acpi_disabled
argument_list|(
literal|"bus"
argument_list|)
condition|)
block|{
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_lookup
argument_list|,
name|acpi_lookup
argument_list|,
name|NULL
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|acpi_probe_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Update all GPEs and enable runtime GPEs. */
name|status
operator|=
name|AcpiUpdateAllGpes
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not update all GPEs: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allow sleep request after a while. */
name|callout_init_mtx
argument_list|(
operator|&
name|acpi_sleep_timer
argument_list|,
operator|&
name|acpi_mutex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|acpi_sleep_timer
argument_list|,
name|hz
operator|*
name|ACPI_MINIMUM_AWAKETIME
argument_list|,
name|acpi_sleep_enable
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|return_VALUE
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_set_power_children
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|device_t
modifier|*
name|devlist
decl_stmt|;
name|int
name|dstate
decl_stmt|,
name|i
decl_stmt|,
name|numdevs
decl_stmt|;
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * Retrieve and set D-state for the sleep state if _SxD is present. 	 * Skip children who aren't attached since they are handled separately. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
name|dstate
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|child
argument_list|)
operator|&&
name|acpi_device_pwr_for_sleep
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
operator|&
name|dstate
argument_list|)
operator|==
literal|0
condition|)
name|acpi_set_powerstate
argument_list|(
name|child
argument_list|,
name|dstate
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|error
operator|=
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|acpi_set_power_children
argument_list|(
name|dev
argument_list|,
name|ACPI_STATE_D3
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|GIANT_REQUIRED
expr_stmt|;
name|acpi_set_power_children
argument_list|(
name|dev
argument_list|,
name|ACPI_STATE_D0
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|GIANT_REQUIRED
expr_stmt|;
comment|/* Allow children to shutdown first. */
name|bus_generic_shutdown
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/*      * Enable any GPEs that are able to power-on the system (i.e., RTC).      * Also, disable any that are not valid for this state (most).      */
name|acpi_wake_prep_walk
argument_list|(
name|ACPI_STATE_S5
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle a new device being added  */
end_comment

begin_function
specifier|static
name|device_t
name|acpi_add_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|u_int
name|order
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
name|device_t
name|child
decl_stmt|;
if|if
condition|(
operator|(
name|ad
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ad
argument_list|)
argument_list|,
name|M_ACPIDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|resource_list_init
argument_list|(
operator|&
name|ad
operator|->
name|ad_rl
argument_list|)
expr_stmt|;
name|child
operator|=
name|device_add_child_ordered
argument_list|(
name|bus
argument_list|,
name|order
argument_list|,
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|ad
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|ad
argument_list|,
name|M_ACPIDEV
argument_list|)
expr_stmt|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_print_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|adev
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|adev
operator|->
name|ad_rl
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"port"
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|"%#jx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"iomem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#jx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"irq"
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|"%jd"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"drq"
argument_list|,
name|SYS_RES_DRQ
argument_list|,
literal|"%jd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_flags
argument_list|(
name|child
argument_list|)
condition|)
name|retval
operator|+=
name|printf
argument_list|(
literal|" flags %#x"
argument_list|,
name|device_get_flags
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_domain
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If this device is an ACPI child but no one claimed it, attempt  * to power it off.  We'll power it back up when a driver is added.  *  * XXX Disabled for now since many necessary devices (like fdc and  * ATA) don't claim the devices we created for them but still expect  * them to be powered up.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_probe_nomatch
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ACPI_ENABLE_POWERDOWN_NODRIVER
name|acpi_set_powerstate
argument_list|(
name|child
argument_list|,
name|ACPI_STATE_D3
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * If a new driver has a chance to probe a child, first power it up.  *  * XXX Disabled for now (see acpi_probe_nomatch for details).  */
end_comment

begin_function
specifier|static
name|void
name|acpi_driver_added
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|driver_t
modifier|*
name|driver
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|,
modifier|*
name|devlist
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numdevs
decl_stmt|;
name|DEVICE_IDENTIFY
argument_list|(
name|driver
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|device_get_state
argument_list|(
name|child
argument_list|)
operator|==
name|DS_NOTPRESENT
condition|)
block|{
ifdef|#
directive|ifdef
name|ACPI_ENABLE_POWERDOWN_NODRIVER
name|acpi_set_powerstate
argument_list|(
name|child
argument_list|,
name|ACPI_STATE_D0
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
operator|!=
literal|0
condition|)
name|acpi_set_powerstate
argument_list|(
name|child
argument_list|,
name|ACPI_STATE_D3
argument_list|)
expr_stmt|;
else|#
directive|else
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Location hint for devctl(8) */
end_comment

begin_function
specifier|static
name|int
name|acpi_child_location_str_method
parameter_list|(
name|device_t
name|cbdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|char
name|buf2
index|[
literal|32
index|]
decl_stmt|;
name|int
name|pxm
decl_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|ad_handle
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"handle=%s"
argument_list|,
name|acpi_name
argument_list|(
name|dinfo
operator|->
name|ad_handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|acpi_GetInteger
argument_list|(
name|dinfo
operator|->
name|ad_handle
argument_list|,
literal|"_PXM"
argument_list|,
operator|&
name|pxm
argument_list|)
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|buf2
argument_list|,
literal|32
argument_list|,
literal|" _PXM=%d"
argument_list|,
name|pxm
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|buf2
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* PnP information for devctl(8) */
end_comment

begin_function
specifier|static
name|int
name|acpi_child_pnpinfo_str_method
parameter_list|(
name|device_t
name|cbdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|ACPI_DEVICE_INFO
modifier|*
name|adinfo
decl_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiGetObjectInfo
argument_list|(
name|dinfo
operator|->
name|ad_handle
argument_list|,
operator|&
name|adinfo
argument_list|)
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"_HID=%s _UID=%lu"
argument_list|,
operator|(
name|adinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_HID
operator|)
condition|?
name|adinfo
operator|->
name|HardwareId
operator|.
name|String
else|:
literal|"none"
argument_list|,
operator|(
name|adinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_UID
operator|)
condition|?
name|strtoul
argument_list|(
name|adinfo
operator|->
name|UniqueId
operator|.
name|String
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
else|:
literal|0UL
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|adinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle per-device ivars  */
end_comment

begin_function
specifier|static
name|int
name|acpi_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
if|if
condition|(
operator|(
name|ad
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"device has no ivars\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* ACPI and ISA compatibility ivars */
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|ACPI_IVAR_HANDLE
case|:
operator|*
operator|(
name|ACPI_HANDLE
operator|*
operator|)
name|result
operator|=
name|ad
operator|->
name|ad_handle
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_PRIVATE
case|:
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|result
operator|=
name|ad
operator|->
name|ad_private
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_FLAGS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|ad
operator|->
name|ad_flags
expr_stmt|;
break|break;
case|case
name|ISA_IVAR_VENDORID
case|:
case|case
name|ISA_IVAR_SERIAL
case|:
case|case
name|ISA_IVAR_COMPATID
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|ISA_IVAR_LOGICALID
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|acpi_isa_get_logicalid
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_CLASS
case|:
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|result
operator|=
operator|(
name|ad
operator|->
name|ad_cls_class
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_SUBCLASS
case|:
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|result
operator|=
operator|(
name|ad
operator|->
name|ad_cls_class
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_PROGIF
case|:
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|result
operator|=
operator|(
name|ad
operator|->
name|ad_cls_class
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
if|if
condition|(
operator|(
name|ad
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"device has no ivars\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|ACPI_IVAR_HANDLE
case|:
name|ad
operator|->
name|ad_handle
operator|=
operator|(
name|ACPI_HANDLE
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_PRIVATE
case|:
name|ad
operator|->
name|ad_private
operator|=
operator|(
name|void
operator|*
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|ACPI_IVAR_FLAGS
case|:
name|ad
operator|->
name|ad_flags
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"bad ivar write request (%d)"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle child resource allocation/removal  */
end_comment

begin_function
specifier|static
name|struct
name|resource_list
modifier|*
name|acpi_get_rlist
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
name|ad
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|ad
operator|->
name|ad_rl
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_match_resource_hint
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|type
parameter_list|,
name|long
name|value
parameter_list|)
block|{
name|struct
name|acpi_device
modifier|*
name|ad
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|ad
operator|->
name|ad_rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|rl
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|rle
operator|->
name|type
operator|!=
name|type
condition|)
continue|continue;
if|if
condition|(
name|rle
operator|->
name|start
operator|<=
name|value
operator|&&
name|rle
operator|->
name|end
operator|>=
name|value
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wire device unit numbers based on resource matches in hints.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_hint_device_unit
parameter_list|(
name|device_t
name|acdev
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|unitp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|long
name|value
decl_stmt|;
name|int
name|line
decl_stmt|,
name|matches
decl_stmt|,
name|unit
decl_stmt|;
comment|/*      * Iterate over all the hints for the devices with the specified      * name to see if one's resources are a subset of this device.      */
name|line
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|resource_find_dev
argument_list|(
operator|&
name|line
argument_list|,
name|name
argument_list|,
operator|&
name|unit
argument_list|,
literal|"at"
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Must have an "at" for acpi or isa. */
name|resource_string_value
argument_list|(
name|name
argument_list|,
name|unit
argument_list|,
literal|"at"
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"acpi0"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"acpi"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"isa0"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"isa"
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
comment|/* 	 * Check for matching resources.  We must have at least one match. 	 * Since I/O and memory resources cannot be shared, if we get a 	 * match on either of those, ignore any mismatches in IRQs or DRQs. 	 * 	 * XXX: We may want to revisit this to be more lenient and wire 	 * as long as it gets one match. 	 */
name|matches
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_long_value
argument_list|(
name|name
argument_list|,
name|unit
argument_list|,
literal|"port"
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	     * Floppy drive controllers are notorious for having a 	     * wide variety of resources not all of which include the 	     * first port that is specified by the hint (typically 	     * 0x3f0) (see the comment above fdc_isa_alloc_resources() 	     * in fdc_isa.c).  However, they do all seem to include 	     * port + 2 (e.g. 0x3f2) so for a floppy device, look for 	     * 'value + 2' in the port resources instead of the hint 	     * value. 	     */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"fdc"
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|acpi_match_resource_hint
argument_list|(
name|child
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|value
argument_list|)
condition|)
name|matches
operator|++
expr_stmt|;
else|else
continue|continue;
block|}
if|if
condition|(
name|resource_long_value
argument_list|(
name|name
argument_list|,
name|unit
argument_list|,
literal|"maddr"
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|acpi_match_resource_hint
argument_list|(
name|child
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|value
argument_list|)
condition|)
name|matches
operator|++
expr_stmt|;
else|else
continue|continue;
block|}
if|if
condition|(
name|matches
operator|>
literal|0
condition|)
goto|goto
name|matched
goto|;
if|if
condition|(
name|resource_long_value
argument_list|(
name|name
argument_list|,
name|unit
argument_list|,
literal|"irq"
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|acpi_match_resource_hint
argument_list|(
name|child
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|value
argument_list|)
condition|)
name|matches
operator|++
expr_stmt|;
else|else
continue|continue;
block|}
if|if
condition|(
name|resource_long_value
argument_list|(
name|name
argument_list|,
name|unit
argument_list|,
literal|"drq"
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|acpi_match_resource_hint
argument_list|(
name|child
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|value
argument_list|)
condition|)
name|matches
operator|++
expr_stmt|;
else|else
continue|continue;
block|}
name|matched
label|:
if|if
condition|(
name|matches
operator|>
literal|0
condition|)
block|{
comment|/* We have a winner! */
operator|*
name|unitp
operator|=
name|unit
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Fetch the NUMA domain for a device by mapping the value returned by  * _PXM to a NUMA domain.  If the device does not have a _PXM method,  * -2 is returned.  If any other error occurs, -1 is returned.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_parse_pxm
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEVICE_NUMA
name|ACPI_HANDLE
name|handle
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|pxm
decl_stmt|;
name|handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|status
operator|=
name|acpi_GetInteger
argument_list|(
name|handle
argument_list|,
literal|"_PXM"
argument_list|,
operator|&
name|pxm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|acpi_map_pxm_to_vm_domainid
argument_list|(
name|pxm
argument_list|)
operator|)
return|;
if|if
condition|(
name|status
operator|==
name|AE_NOT_FOUND
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|acpi_get_cpus
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|enum
name|cpu_sets
name|op
parameter_list|,
name|size_t
name|setsize
parameter_list|,
name|cpuset_t
modifier|*
name|cpuset
parameter_list|)
block|{
name|int
name|d
decl_stmt|,
name|error
decl_stmt|;
name|d
operator|=
name|acpi_parse_pxm
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
return|return
operator|(
name|bus_generic_get_cpus
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|op
argument_list|,
name|setsize
argument_list|,
name|cpuset
argument_list|)
operator|)
return|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|LOCAL_CPUS
case|:
if|if
condition|(
name|setsize
operator|!=
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|cpuset
operator|=
name|cpuset_domain
index|[
name|d
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|INTR_CPUS
case|:
name|error
operator|=
name|bus_generic_get_cpus
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|op
argument_list|,
name|setsize
argument_list|,
name|cpuset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|setsize
operator|!=
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|CPU_AND
argument_list|(
name|cpuset
argument_list|,
operator|&
name|cpuset_domain
index|[
name|d
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|bus_generic_get_cpus
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|op
argument_list|,
name|setsize
argument_list|,
name|cpuset
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Fetch the NUMA domain for the given device 'dev'.  *  * If a device has a _PXM method, map that to a NUMA domain.  * Otherwise, pass the request up to the parent.  * If there's no matching domain or the domain cannot be  * determined, return ENOENT.  */
end_comment

begin_function
name|int
name|acpi_get_domain
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
modifier|*
name|domain
parameter_list|)
block|{
name|int
name|d
decl_stmt|;
name|d
operator|=
name|acpi_parse_pxm
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|0
condition|)
block|{
operator|*
name|domain
operator|=
name|d
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|d
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* No _PXM node; go up a level */
return|return
operator|(
name|bus_generic_get_domain
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|domain
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pre-allocate/manage all memory and IO resources.  Since rman can't handle  * duplicates, we merge any in the sysresource attach routine.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_sysres_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|char
modifier|*
name|sysres_ids
index|[]
init|=
block|{
literal|"PNP0C01"
block|,
literal|"PNP0C02"
block|,
name|NULL
block|}
decl_stmt|;
name|device_t
modifier|*
name|children
decl_stmt|;
name|int
name|child_count
decl_stmt|,
name|i
decl_stmt|;
comment|/*      * Probe/attach any sysresource devices.  This would be unnecessary if we      * had multi-pass probe/attach.      */
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|children
argument_list|,
operator|&
name|child_count
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|child_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ACPI_ID_PROBE
argument_list|(
name|dev
argument_list|,
name|children
index|[
name|i
index|]
argument_list|,
name|sysres_ids
argument_list|)
operator|!=
name|NULL
condition|)
name|device_probe_and_attach
argument_list|(
name|children
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|children
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|rl
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"duplicate resource for %jx\n"
argument_list|,
name|rle
operator|->
name|start
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Only memory and IO resources are valid here. */
switch|switch
condition|(
name|rle
operator|->
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|rm
operator|=
operator|&
name|acpi_rman_io
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|rm
operator|=
operator|&
name|acpi_rman_mem
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
comment|/* Pre-allocate resource and add to our rman pool. */
name|res
operator|=
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|rle
operator|->
name|type
argument_list|,
operator|&
name|rle
operator|->
name|rid
argument_list|,
name|rle
operator|->
name|start
argument_list|,
name|rle
operator|->
name|start
operator|+
name|rle
operator|->
name|count
operator|-
literal|1
argument_list|,
name|rle
operator|->
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
block|{
name|rman_manage_region
argument_list|(
name|rm
argument_list|,
name|rman_get_start
argument_list|(
name|res
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|rle
operator|->
name|res
operator|=
name|res
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"reservation of %jx, %jx (%d) failed\n"
argument_list|,
name|rle
operator|->
name|start
argument_list|,
name|rle
operator|->
name|count
argument_list|,
name|rle
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pcilink_ids
index|[]
init|=
block|{
literal|"PNP0C0F"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sysres_ids
index|[]
init|=
block|{
literal|"PNP0C01"
block|,
literal|"PNP0C02"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reserve declared resources for devices found during attach once system  * resources have been allocated.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_reserve_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
modifier|*
name|children
decl_stmt|;
name|int
name|child_count
decl_stmt|,
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|children
argument_list|,
operator|&
name|child_count
argument_list|)
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|child_count
condition|;
name|i
operator|++
control|)
block|{
name|ad
operator|=
name|device_get_ivars
argument_list|(
name|children
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|ad
operator|->
name|ad_rl
expr_stmt|;
comment|/* Don't reserve system resources. */
if|if
condition|(
name|ACPI_ID_PROBE
argument_list|(
name|dev
argument_list|,
name|children
index|[
name|i
index|]
argument_list|,
name|sysres_ids
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
name|STAILQ_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|rl
argument_list|,
argument|link
argument_list|)
block|{
comment|/* 	     * Don't reserve IRQ resources.  There are many sticky things 	     * to get right otherwise (e.g. IRQs for psm, atkbd, and HPET 	     * when using legacy routing). 	     */
if|if
condition|(
name|rle
operator|->
name|type
operator|==
name|SYS_RES_IRQ
condition|)
continue|continue;
comment|/* 	     * Don't reserve the resource if it is already allocated. 	     * The acpi_ec(4) driver can allocate its resources early 	     * if ECDT is present. 	     */
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
continue|continue;
comment|/* 	     * Try to reserve the resource from our parent.  If this 	     * fails because the resource is a system resource, just 	     * let it be.  The resource range is already reserved so 	     * that other devices will not use it.  If the driver 	     * needs to allocate the resource, then 	     * acpi_alloc_resource() will sub-alloc from the system 	     * resource. 	     */
name|resource_list_reserve
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|children
index|[
name|i
index|]
argument_list|,
name|rle
operator|->
name|type
argument_list|,
operator|&
name|rle
operator|->
name|rid
argument_list|,
name|rle
operator|->
name|start
argument_list|,
name|rle
operator|->
name|end
argument_list|,
name|rle
operator|->
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|children
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_resources_reserved
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_set_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|count
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|acpi_device
modifier|*
name|ad
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|ad
operator|->
name|ad_rl
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|ACPI_DEVICE_INFO
modifier|*
name|devinfo
decl_stmt|;
endif|#
directive|endif
name|rman_res_t
name|end
decl_stmt|;
comment|/* Ignore IRQ resources for PCI link devices. */
if|if
condition|(
name|type
operator|==
name|SYS_RES_IRQ
operator|&&
name|ACPI_ID_PROBE
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|pcilink_ids
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*      * Ignore most resources for PCI root bridges.  Some BIOSes      * incorrectly enumerate the memory ranges they decode as plain      * memory resources instead of as ResourceProducer ranges.  Other      * BIOSes incorrectly list system resource entries for I/O ranges      * under the PCI bridge.  Do allow the one known-correct case on      * x86 of a PCI bridge claiming the I/O ports used for PCI config      * access.      */
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|||
name|type
operator|==
name|SYS_RES_IOPORT
condition|)
block|{
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetObjectInfo
argument_list|(
name|ad
operator|->
name|ad_handle
argument_list|,
operator|&
name|devinfo
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|devinfo
operator|->
name|Flags
operator|&
name|ACPI_PCI_ROOT_BRIDGE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
name|start
operator|==
name|CONF1_ADDR_PORT
operator|)
condition|)
block|{
name|AcpiOsFree
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|AcpiOsFree
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* If the resource is already allocated, fail. */
if|if
condition|(
name|resource_list_busy
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* If the resource is already reserved, release it. */
if|if
condition|(
name|resource_list_reserved
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
condition|)
name|resource_list_unreserve
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
comment|/* Add the resource. */
name|end
operator|=
operator|(
name|start
operator|+
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Don't reserve resources until the system resources are allocated. */
if|if
condition|(
operator|!
name|sc
operator|->
name|acpi_resources_reserved
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Don't reserve system resources. */
if|if
condition|(
name|ACPI_ID_PROBE
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|sysres_ids
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*      * Don't reserve IRQ resources.  There are many sticky things to      * get right otherwise (e.g. IRQs for psm, atkbd, and HPET when      * using legacy routing).      */
if|if
condition|(
name|type
operator|==
name|SYS_RES_IRQ
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*      * Reserve the resource.      *      * XXX: Ignores failure for now.  Failure here is probably a      * BIOS/firmware bug?      */
name|resource_list_reserve
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|acpi_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|ACPI_RESOURCE
name|ares
decl_stmt|;
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|isdefault
init|=
name|RMAN_IS_DEFAULT_RANGE
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
decl_stmt|;
comment|/*      * First attempt at allocating the resource.  For direct children,      * use resource_list_alloc() to handle reserved resources.  For      * other devices, pass the request up to our parent.      */
if|if
condition|(
name|bus
operator|==
name|device_get_parent
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|ad
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|ad
operator|->
name|ad_rl
expr_stmt|;
comment|/* 	 * Simulate the behavior of the ISA bus for direct children 	 * devices.  That is, if a non-default range is specified for 	 * a resource that doesn't exist, use bus_set_resource() to 	 * add the resource before allocating it.  Note that these 	 * resources will not be reserved. 	 */
if|if
condition|(
operator|!
name|isdefault
operator|&&
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
operator|==
name|NULL
condition|)
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|res
operator|=
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
operator|&&
name|type
operator|==
name|SYS_RES_IRQ
condition|)
block|{
comment|/* 	     * Since bus_config_intr() takes immediate effect, we cannot 	     * configure the interrupt associated with a device when we 	     * parse the resources but have to defer it until a driver 	     * actually allocates the interrupt via bus_alloc_resource(). 	     * 	     * XXX: Should we handle the lookup failing? 	     */
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|acpi_lookup_irq_resource
argument_list|(
name|child
argument_list|,
operator|*
name|rid
argument_list|,
name|res
argument_list|,
operator|&
name|ares
argument_list|)
argument_list|)
condition|)
name|acpi_config_intr
argument_list|(
name|child
argument_list|,
operator|&
name|ares
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this is an allocation of the "default" range for a given 	 * RID, fetch the exact bounds for this resource from the 	 * resource list entry to try to allocate the range from the 	 * system resource regions. 	 */
if|if
condition|(
name|res
operator|==
name|NULL
operator|&&
name|isdefault
condition|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|!=
name|NULL
condition|)
block|{
name|start
operator|=
name|rle
operator|->
name|start
expr_stmt|;
name|end
operator|=
name|rle
operator|->
name|end
expr_stmt|;
name|count
operator|=
name|rle
operator|->
name|count
expr_stmt|;
block|}
block|}
block|}
else|else
name|res
operator|=
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/*      * If the first attempt failed and this is an allocation of a      * specific range, try to satisfy the request via a suballocation      * from our system resource regions.      */
if|if
condition|(
name|res
operator|==
name|NULL
operator|&&
name|start
operator|+
name|count
operator|-
literal|1
operator|==
name|end
condition|)
name|res
operator|=
name|acpi_alloc_sysres
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to allocate a specific resource range from the system  * resource ranges.  Note that we only handle memory and I/O port  * system resources.  */
end_comment

begin_function
name|struct
name|resource
modifier|*
name|acpi_alloc_sysres
parameter_list|(
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|rm
operator|=
operator|&
name|acpi_rman_io
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|rm
operator|=
operator|&
name|acpi_rman_mem
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|start
operator|+
name|count
operator|-
literal|1
operator|==
name|end
argument_list|,
operator|(
literal|"wildcard resource range"
operator|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|rman_reserve_resource
argument_list|(
name|rm
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_ACTIVE
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rman_set_rid
argument_list|(
name|res
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
comment|/* If requested, activate the resource using the parent's method. */
if|if
condition|(
name|flags
operator|&
name|RF_ACTIVE
condition|)
if|if
condition|(
name|bus_activate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|res
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rman_release_resource
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_is_resource_managed
parameter_list|(
name|int
name|type
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
comment|/* We only handle memory and IO resources through rman. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
return|return
operator|(
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
operator|&
name|acpi_rman_io
argument_list|)
operator|)
return|;
case|case
name|SYS_RES_MEMORY
case|:
return|return
operator|(
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
operator|&
name|acpi_rman_mem
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_adjust_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|)
block|{
if|if
condition|(
name|acpi_is_resource_managed
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
condition|)
return|return
operator|(
name|rman_adjust_resource
argument_list|(
name|r
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
operator|)
return|;
return|return
operator|(
name|bus_generic_adjust_resource
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|r
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_release_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/*      * If this resource belongs to one of our internal managers,      * deactivate it and release it to the local pool.      */
if|if
condition|(
name|acpi_is_resource_managed
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|rman_get_flags
argument_list|(
name|r
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
block|{
name|ret
operator|=
name|bus_deactivate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
return|return
operator|(
name|rman_release_resource
argument_list|(
name|r
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|bus_generic_rl_release_resource
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_delete_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|)
block|{
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|rl
operator|=
name|acpi_get_rlist
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_list_busy
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"delete_resource: Resource still owned by child"
literal|" (type=%d, rid=%d)\n"
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
return|return;
block|}
name|resource_list_unreserve
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
name|resource_list_delete
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate an IO port or memory resource, given its GAS. */
end_comment

begin_function
name|int
name|acpi_bus_alloc_gas
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|ACPI_GENERIC_ADDRESS
modifier|*
name|gas
parameter_list|,
name|struct
name|resource
modifier|*
modifier|*
name|res
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|res_type
decl_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
name|rid
operator|==
name|NULL
operator|||
name|gas
operator|==
name|NULL
operator|||
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* We only support memory and IO spaces. */
switch|switch
condition|(
name|gas
operator|->
name|SpaceId
condition|)
block|{
case|case
name|ACPI_ADR_SPACE_SYSTEM_MEMORY
case|:
name|res_type
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
break|break;
case|case
name|ACPI_ADR_SPACE_SYSTEM_IO
case|:
name|res_type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
comment|/*      * If the register width is less than 8, assume the BIOS author means      * it is a bit field and just allocate a byte.      */
if|if
condition|(
name|gas
operator|->
name|BitWidth
operator|&&
name|gas
operator|->
name|BitWidth
operator|<
literal|8
condition|)
name|gas
operator|->
name|BitWidth
operator|=
literal|8
expr_stmt|;
comment|/* Validate the address after we're sure we support the space. */
if|if
condition|(
name|gas
operator|->
name|Address
operator|==
literal|0
operator|||
name|gas
operator|->
name|BitWidth
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|res_type
argument_list|,
operator|*
name|rid
argument_list|,
name|gas
operator|->
name|Address
argument_list|,
name|gas
operator|->
name|BitWidth
operator|/
literal|8
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|res_type
argument_list|,
name|rid
argument_list|,
name|RF_ACTIVE
operator||
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|res
operator|!=
name|NULL
condition|)
block|{
operator|*
name|type
operator|=
name|res_type
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|bus_delete_resource
argument_list|(
name|dev
argument_list|,
name|res_type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Probe _HID and _CID for compatible ISA PNP ids. */
end_comment

begin_function
specifier|static
name|uint32_t
name|acpi_isa_get_logicalid
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_DEVICE_INFO
modifier|*
name|devinfo
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|uint32_t
name|pnpid
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* Fetch and validate the HID. */
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|ACPI_FAILURE
argument_list|(
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|devinfo
argument_list|)
argument_list|)
condition|)
name|return_VALUE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pnpid
operator|=
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_HID
operator|)
operator|!=
literal|0
operator|&&
name|devinfo
operator|->
name|HardwareId
operator|.
name|Length
operator|>=
name|ACPI_EISAID_STRING_SIZE
condition|?
name|PNP_EISAID
argument_list|(
name|devinfo
operator|->
name|HardwareId
operator|.
name|String
argument_list|)
else|:
literal|0
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|pnpid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_isa_get_compatid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
modifier|*
name|cids
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|ACPI_DEVICE_INFO
modifier|*
name|devinfo
decl_stmt|;
name|ACPI_PNP_DEVICE_ID
modifier|*
name|ids
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|uint32_t
modifier|*
name|pnpid
decl_stmt|;
name|int
name|i
decl_stmt|,
name|valid
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|pnpid
operator|=
name|cids
expr_stmt|;
comment|/* Fetch and validate the CID */
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|ACPI_FAILURE
argument_list|(
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|devinfo
argument_list|)
argument_list|)
condition|)
name|return_VALUE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_CID
operator|)
operator|==
literal|0
condition|)
block|{
name|AcpiOsFree
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devinfo
operator|->
name|CompatibleIdList
operator|.
name|Count
operator|<
name|count
condition|)
name|count
operator|=
name|devinfo
operator|->
name|CompatibleIdList
operator|.
name|Count
expr_stmt|;
name|ids
operator|=
name|devinfo
operator|->
name|CompatibleIdList
operator|.
name|Ids
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|valid
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ids
index|[
name|i
index|]
operator|.
name|Length
operator|>=
name|ACPI_EISAID_STRING_SIZE
operator|&&
name|strncmp
argument_list|(
name|ids
index|[
name|i
index|]
operator|.
name|String
argument_list|,
literal|"PNP"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|pnpid
operator|++
operator|=
name|PNP_EISAID
argument_list|(
name|ids
index|[
name|i
index|]
operator|.
name|String
argument_list|)
expr_stmt|;
name|valid
operator|++
expr_stmt|;
block|}
name|AcpiOsFree
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|valid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|acpi_device_id_probe
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|char
modifier|*
modifier|*
name|ids
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_OBJECT_TYPE
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ids
operator|==
name|NULL
operator|||
name|h
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|t
operator|=
name|acpi_get_type
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|ACPI_TYPE_DEVICE
operator|&&
name|t
operator|!=
name|ACPI_TYPE_PROCESSOR
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Try to match one of the array of IDs with a HID or CID. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ids
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|acpi_MatchHid
argument_list|(
name|h
argument_list|,
name|ids
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|ids
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_device_eval_obj
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|ACPI_STRING
name|pathname
parameter_list|,
name|ACPI_OBJECT_LIST
modifier|*
name|parameters
parameter_list|,
name|ACPI_BUFFER
modifier|*
name|ret
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
name|h
operator|=
name|ACPI_ROOT_OBJECT
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
return|return
operator|(
name|AcpiEvaluateObject
argument_list|(
name|h
argument_list|,
name|pathname
argument_list|,
name|parameters
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|acpi_device_pwr_for_sleep
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|dstate
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_HANDLE
name|handle
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|char
name|sxd
index|[
literal|8
index|]
decl_stmt|;
name|handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/*      * XXX If we find these devices, don't try to power them down.      * The serial and IRDA ports on my T23 hang the system when      * set to D3 and it appears that such legacy devices may      * need special handling in their drivers.      */
if|if
condition|(
name|dstate
operator|==
name|NULL
operator|||
name|handle
operator|==
name|NULL
operator|||
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0500"
argument_list|)
operator|||
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0501"
argument_list|)
operator|||
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0502"
argument_list|)
operator|||
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0510"
argument_list|)
operator|||
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0511"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*      * Override next state with the value from _SxD, if present.      * Note illegal _S0D is evaluated because some systems expect this.      */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sxd
argument_list|,
sizeof|sizeof
argument_list|(
name|sxd
argument_list|)
argument_list|,
literal|"_S%dD"
argument_list|,
name|sc
operator|->
name|acpi_sstate
argument_list|)
expr_stmt|;
name|status
operator|=
name|acpi_GetInteger
argument_list|(
name|handle
argument_list|,
name|sxd
argument_list|,
name|dstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
operator|&&
name|status
operator|!=
name|AE_NOT_FOUND
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to get %s on %s: %s\n"
argument_list|,
name|sxd
argument_list|,
name|acpi_name
argument_list|(
name|handle
argument_list|)
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Callback arg for our implementation of walking the namespace. */
end_comment

begin_struct
struct|struct
name|acpi_device_scan_ctx
block|{
name|acpi_scan_cb_t
name|user_fn
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|ACPI_HANDLE
name|parent
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_device_scan_cb
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|acpi_device_scan_ctx
modifier|*
name|ctx
decl_stmt|;
name|device_t
name|dev
decl_stmt|,
name|old_dev
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_OBJECT_TYPE
name|type
decl_stmt|;
comment|/*      * Skip this device if we think we'll have trouble with it or it is      * the parent where the scan began.      */
name|ctx
operator|=
operator|(
expr|struct
name|acpi_device_scan_ctx
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|acpi_avoid
argument_list|(
name|h
argument_list|)
operator|||
name|h
operator|==
name|ctx
operator|->
name|parent
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
comment|/* If this is not a valid device type (e.g., a method), skip it. */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiGetType
argument_list|(
name|h
argument_list|,
operator|&
name|type
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
if|if
condition|(
name|type
operator|!=
name|ACPI_TYPE_DEVICE
operator|&&
name|type
operator|!=
name|ACPI_TYPE_PROCESSOR
operator|&&
name|type
operator|!=
name|ACPI_TYPE_THERMAL
operator|&&
name|type
operator|!=
name|ACPI_TYPE_POWER
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
comment|/*      * Call the user function with the current device.  If it is unchanged      * afterwards, return.  Otherwise, we update the handle to the new dev.      */
name|old_dev
operator|=
name|acpi_get_device
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|dev
operator|=
name|old_dev
expr_stmt|;
name|status
operator|=
name|ctx
operator|->
name|user_fn
argument_list|(
name|h
argument_list|,
operator|&
name|dev
argument_list|,
name|level
argument_list|,
name|ctx
operator|->
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
operator|||
name|old_dev
operator|==
name|dev
condition|)
return|return
operator|(
name|status
operator|)
return|;
comment|/* Remove the old child and its connection to the handle. */
if|if
condition|(
name|old_dev
operator|!=
name|NULL
condition|)
block|{
name|device_delete_child
argument_list|(
name|device_get_parent
argument_list|(
name|old_dev
argument_list|)
argument_list|,
name|old_dev
argument_list|)
expr_stmt|;
name|AcpiDetachData
argument_list|(
name|h
argument_list|,
name|acpi_fake_objhandler
argument_list|)
expr_stmt|;
block|}
comment|/* Recreate the handle association if the user created a device. */
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
name|AcpiAttachData
argument_list|(
name|h
argument_list|,
name|acpi_fake_objhandler
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_device_scan_children
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|max_depth
parameter_list|,
name|acpi_scan_cb_t
name|user_fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
name|struct
name|acpi_device_scan_ctx
name|ctx
decl_stmt|;
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"children"
argument_list|)
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
name|h
operator|=
name|ACPI_ROOT_OBJECT
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
name|ctx
operator|.
name|user_fn
operator|=
name|user_fn
expr_stmt|;
name|ctx
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|ctx
operator|.
name|parent
operator|=
name|h
expr_stmt|;
return|return
operator|(
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|h
argument_list|,
name|max_depth
argument_list|,
name|acpi_device_scan_cb
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctx
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Even though ACPI devices are not PCI, we use the PCI approach for setting  * device power states since it's close enough to ACPI.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_set_powerstate
parameter_list|(
name|device_t
name|child
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|<
name|ACPI_STATE_D0
operator|||
name|state
operator|>
name|ACPI_D_STATES_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Ignore errors if the power methods aren't present. */
name|status
operator|=
name|acpi_pwr_switch_consumer
argument_list|(
name|h
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"set ACPI power state D%d on %s\n"
argument_list|,
name|state
argument_list|,
name|acpi_name
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|AE_NOT_FOUND
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"failed to set ACPI power state D%d on %s: %s\n"
argument_list|,
name|state
argument_list|,
name|acpi_name
argument_list|(
name|h
argument_list|)
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_isa_pnp_probe
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|isa_pnp_id
modifier|*
name|ids
parameter_list|)
block|{
name|int
name|result
decl_stmt|,
name|cid_count
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|lid
decl_stmt|,
name|cids
index|[
literal|8
index|]
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/*      * ISA-style drivers attached to ACPI may persist and      * probe manually if we return ENOENT.  We never want      * that to happen, so don't ever return it.      */
name|result
operator|=
name|ENXIO
expr_stmt|;
comment|/* Scan the supplied IDs for a match */
name|lid
operator|=
name|acpi_isa_get_logicalid
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cid_count
operator|=
name|acpi_isa_get_compatid
argument_list|(
name|child
argument_list|,
name|cids
argument_list|,
literal|8
argument_list|)
expr_stmt|;
while|while
condition|(
name|ids
operator|&&
name|ids
operator|->
name|ip_id
condition|)
block|{
if|if
condition|(
name|lid
operator|==
name|ids
operator|->
name|ip_id
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cid_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cids
index|[
name|i
index|]
operator|==
name|ids
operator|->
name|ip_id
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ids
operator|++
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|result
operator|==
literal|0
operator|&&
name|ids
operator|->
name|ip_desc
condition|)
name|device_set_desc
argument_list|(
name|child
argument_list|,
name|ids
operator|->
name|ip_desc
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_comment
comment|/*  * Look for a MCFG table.  If it is present, use the settings for  * domain (segment) 0 to setup PCI config space access via the memory  * map.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_enable_pcie
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_TABLE_HEADER
modifier|*
name|hdr
decl_stmt|;
name|ACPI_MCFG_ALLOCATION
modifier|*
name|alloc
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|status
operator|=
name|AcpiGetTable
argument_list|(
name|ACPI_SIG_MCFG
argument_list|,
literal|1
argument_list|,
operator|&
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return;
name|end
operator|=
operator|(
name|ACPI_MCFG_ALLOCATION
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|+
name|hdr
operator|->
name|Length
operator|)
expr_stmt|;
name|alloc
operator|=
operator|(
name|ACPI_MCFG_ALLOCATION
operator|*
operator|)
operator|(
operator|(
name|ACPI_TABLE_MCFG
operator|*
operator|)
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|alloc
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|alloc
operator|->
name|PciSegment
operator|==
literal|0
condition|)
block|{
name|pcie_cfgregopen
argument_list|(
name|alloc
operator|->
name|Address
argument_list|,
name|alloc
operator|->
name|StartBusNumber
argument_list|,
name|alloc
operator|->
name|EndBusNumber
argument_list|)
expr_stmt|;
return|return;
block|}
name|alloc
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Scan all of the ACPI namespace and attach child devices.  *  * We should only expect to find devices in the \_PR, \_TZ, \_SI, and  * \_SB scopes, and \_PR and \_TZ became obsolete in the ACPI 2.0 spec.  * However, in violation of the spec, some systems place their PCI link  * devices in \, so we have to walk the whole namespace.  We check the  * type of namespace nodes, so this should be ok.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_probe_children
parameter_list|(
name|device_t
name|bus
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/*      * Scan the namespace and insert placeholders for all the devices that      * we find.  We also probe/attach any early devices.      *      * Note that we use AcpiWalkNamespace rather than AcpiGetDevices because      * we want to create nodes for all devices, not just those that are      * currently present. (This assumes that we don't want to create/remove      * devices as they appear, which might be smarter.)      */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"namespace scan\n"
operator|)
argument_list|)
expr_stmt|;
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
literal|100
argument_list|,
name|acpi_probe_child
argument_list|,
name|NULL
argument_list|,
name|bus
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Pre-allocate resources for our rman from any sysresource devices. */
name|acpi_sysres_alloc
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/* Reserve resources already allocated to children. */
name|acpi_reserve_resources
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/* Create any static children by calling device identify methods. */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"device identify routines\n"
operator|)
argument_list|)
expr_stmt|;
name|bus_generic_probe
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/* Probe/attach all children, created statically and from the namespace. */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"acpi bus_generic_attach\n"
operator|)
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/* Attach wake sysctls. */
name|acpi_wake_sysctl_walk
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"done attaching children\n"
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine the probe order for a given device.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_probe_order
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|int
modifier|*
name|order
parameter_list|)
block|{
name|ACPI_OBJECT_TYPE
name|type
decl_stmt|;
comment|/* 	 * 0. CPUs 	 * 1. I/O port and memory system resource holders 	 * 2. Clocks and timers (to handle early accesses) 	 * 3. Embedded controllers (to handle early accesses) 	 * 4. PCI Link Devices 	 */
name|AcpiGetType
argument_list|(
name|handle
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ACPI_TYPE_PROCESSOR
condition|)
operator|*
name|order
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0C01"
argument_list|)
operator|||
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0C02"
argument_list|)
condition|)
operator|*
name|order
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0100"
argument_list|)
operator|||
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0103"
argument_list|)
operator|||
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0B00"
argument_list|)
condition|)
operator|*
name|order
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0C09"
argument_list|)
condition|)
operator|*
name|order
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0C0F"
argument_list|)
condition|)
operator|*
name|order
operator|=
literal|4
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a child device and determine whether we might attach a device to  * it.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_probe_child
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
modifier|*
name|status
parameter_list|)
block|{
name|ACPI_DEVICE_INFO
modifier|*
name|devinfo
decl_stmt|;
name|struct
name|acpi_device
modifier|*
name|ad
decl_stmt|;
name|struct
name|acpi_prw_data
name|prw
decl_stmt|;
name|ACPI_OBJECT_TYPE
name|type
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|device_t
name|bus
decl_stmt|,
name|child
decl_stmt|;
name|char
modifier|*
name|handle_str
decl_stmt|;
name|int
name|order
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"children"
argument_list|)
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
comment|/* Skip this device if we think we'll have trouble with it. */
if|if
condition|(
name|acpi_avoid
argument_list|(
name|handle
argument_list|)
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
name|bus
operator|=
operator|(
name|device_t
operator|)
name|context
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetType
argument_list|(
name|handle
argument_list|,
operator|&
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|handle_str
operator|=
name|acpi_name
argument_list|(
name|handle
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ACPI_TYPE_DEVICE
case|:
comment|/* 	     * Since we scan from \, be sure to skip system scope objects. 	     * \_SB_ and \_TZ_ are defined in ACPICA as devices to work around 	     * BIOS bugs.  For example, \_SB_ is to allow \_SB_._INI to be run 	     * during the initialization and \_TZ_ is to support Notify() on it. 	     */
if|if
condition|(
name|strcmp
argument_list|(
name|handle_str
argument_list|,
literal|"\\_SB_"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|handle_str
argument_list|,
literal|"\\_TZ_"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|acpi_parse_prw
argument_list|(
name|handle
argument_list|,
operator|&
name|prw
argument_list|)
operator|==
literal|0
condition|)
name|AcpiSetupGpeForWake
argument_list|(
name|handle
argument_list|,
name|prw
operator|.
name|gpe_handle
argument_list|,
name|prw
operator|.
name|gpe_bit
argument_list|)
expr_stmt|;
comment|/* 	     * Ignore devices that do not have a _HID or _CID.  They should 	     * be discovered by other buses (e.g. the PCI bus driver). 	     */
if|if
condition|(
operator|!
name|acpi_has_hid
argument_list|(
name|handle
argument_list|)
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|ACPI_TYPE_PROCESSOR
case|:
case|case
name|ACPI_TYPE_THERMAL
case|:
case|case
name|ACPI_TYPE_POWER
case|:
comment|/*  	     * Create a placeholder device for this node.  Sort the 	     * placeholder so that the probe/attach passes will run 	     * breadth-first.  Orders less than ACPI_DEV_BASE_ORDER 	     * are reserved for special objects (i.e., system 	     * resources). 	     */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_OBJECTS
operator|,
literal|"scanning '%s'\n"
operator|,
name|handle_str
operator|)
argument_list|)
expr_stmt|;
name|order
operator|=
name|level
operator|*
literal|10
operator|+
name|ACPI_DEV_BASE_ORDER
expr_stmt|;
name|acpi_probe_order
argument_list|(
name|handle
argument_list|,
operator|&
name|order
argument_list|)
expr_stmt|;
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|bus
argument_list|,
name|order
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
break|break;
comment|/* Associate the handle with the device_t and vice versa. */
name|acpi_set_handle
argument_list|(
name|child
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|AcpiAttachData
argument_list|(
name|handle
argument_list|,
name|acpi_fake_objhandler
argument_list|,
name|child
argument_list|)
expr_stmt|;
comment|/* 	     * Check that the device is present.  If it's not present, 	     * leave it disabled (so that we have a device_t attached to 	     * the handle, but we don't probe it). 	     * 	     * XXX PCI link devices sometimes report "present" but not 	     * "functional" (i.e. if disabled).  Go ahead and probe them 	     * anyway since we may enable them later. 	     */
if|if
condition|(
name|type
operator|==
name|ACPI_TYPE_DEVICE
operator|&&
operator|!
name|acpi_DeviceIsPresent
argument_list|(
name|child
argument_list|)
condition|)
block|{
comment|/* Never disable PCI link devices. */
if|if
condition|(
name|acpi_MatchHid
argument_list|(
name|handle
argument_list|,
literal|"PNP0C0F"
argument_list|)
condition|)
break|break;
comment|/* 		 * Docking stations should remain enabled since the system 		 * may be undocked at boot. 		 */
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetHandle
argument_list|(
name|handle
argument_list|,
literal|"_DCK"
argument_list|,
operator|&
name|h
argument_list|)
argument_list|)
condition|)
break|break;
name|device_disable
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	     * Get the device's resource settings and attach them. 	     * Note that if the device has _PRS but no _CRS, we need 	     * to decide when it's appropriate to try to configure the 	     * device.  Ignore the return value here; it's OK for the 	     * device not to have any resources. 	     */
name|acpi_parse_resources
argument_list|(
name|child
argument_list|,
name|handle
argument_list|,
operator|&
name|acpi_res_parse_set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ad
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|ad
operator|->
name|ad_cls_class
operator|=
literal|0xffffff
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetObjectInfo
argument_list|(
name|handle
argument_list|,
operator|&
name|devinfo
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_CLS
operator|)
operator|!=
literal|0
operator|&&
name|devinfo
operator|->
name|ClassCode
operator|.
name|Length
operator|>=
name|ACPI_PCICLS_STRING_SIZE
condition|)
block|{
name|ad
operator|->
name|ad_cls_class
operator|=
name|strtoul
argument_list|(
name|devinfo
operator|->
name|ClassCode
operator|.
name|String
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
name|AcpiOsFree
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * AcpiAttachData() requires an object handler but never uses it.  This is a  * placeholder object handler so we can store a device_t in an ACPI_HANDLE.  */
end_comment

begin_function
name|void
name|acpi_fake_objhandler
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|acpi_shutdown_final
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|register_t
name|intr
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
comment|/*      * XXX Shutdown code should only run on the BSP (cpuid 0).      * Some chipsets do not power off the system correctly if called from      * an AP.      */
if|if
condition|(
operator|(
name|howto
operator|&
name|RB_POWEROFF
operator|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|AcpiEnterSleepStatePrep
argument_list|(
name|ACPI_STATE_S5
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"AcpiEnterSleepStatePrep failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"Powering system off\n"
argument_list|)
expr_stmt|;
name|intr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|status
operator|=
name|AcpiEnterSleepState
argument_list|(
name|ACPI_STATE_S5
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|intr_restore
argument_list|(
name|intr
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"power-off failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|intr_restore
argument_list|(
name|intr
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"power-off failed - timeout\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|howto
operator|&
name|RB_HALT
operator|)
operator|==
literal|0
operator|&&
name|sc
operator|->
name|acpi_handle_reboot
condition|)
block|{
comment|/* Reboot using the reset register. */
name|status
operator|=
name|AcpiReset
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"reset failed - timeout\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|AE_NOT_EXIST
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"reset failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|acpi_do_disable
operator|&&
name|panicstr
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Only disable ACPI if the user requested.  On some systems, writing 	 * the disable value to SMI_CMD hangs the system. 	 */
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"Shutting down\n"
argument_list|)
expr_stmt|;
name|AcpiTerminate
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_enable_fixed_events
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|int
name|first_time
init|=
literal|1
decl_stmt|;
comment|/* Enable and clear fixed events and install handlers. */
if|if
condition|(
operator|(
name|AcpiGbl_FADT
operator|.
name|Flags
operator|&
name|ACPI_FADT_POWER_BUTTON
operator|)
operator|==
literal|0
condition|)
block|{
name|AcpiClearEvent
argument_list|(
name|ACPI_EVENT_POWER_BUTTON
argument_list|)
expr_stmt|;
name|AcpiInstallFixedEventHandler
argument_list|(
name|ACPI_EVENT_POWER_BUTTON
argument_list|,
name|acpi_event_power_button_sleep
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_time
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"Power Button (fixed)\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|AcpiGbl_FADT
operator|.
name|Flags
operator|&
name|ACPI_FADT_SLEEP_BUTTON
operator|)
operator|==
literal|0
condition|)
block|{
name|AcpiClearEvent
argument_list|(
name|ACPI_EVENT_SLEEP_BUTTON
argument_list|)
expr_stmt|;
name|AcpiInstallFixedEventHandler
argument_list|(
name|ACPI_EVENT_SLEEP_BUTTON
argument_list|,
name|acpi_event_sleep_button_sleep
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_time
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"Sleep Button (fixed)\n"
argument_list|)
expr_stmt|;
block|}
name|first_time
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the device is actually present and should  * be attached to.  This requires the present, enabled, UI-visible   * and diagnostics-passed bits to be set.  */
end_comment

begin_function
name|BOOLEAN
name|acpi_DeviceIsPresent
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_DEVICE_INFO
modifier|*
name|devinfo
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|BOOLEAN
name|present
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|ACPI_FAILURE
argument_list|(
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|devinfo
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* If no _STA method, must be present */
name|present
operator|=
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_STA
operator|)
operator|==
literal|0
operator|||
name|ACPI_DEVICE_PRESENT
argument_list|(
name|devinfo
operator|->
name|CurrentStatus
argument_list|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|present
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the battery is actually present and inserted.  */
end_comment

begin_function
name|BOOLEAN
name|acpi_BatteryIsPresent
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_DEVICE_INFO
modifier|*
name|devinfo
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|BOOLEAN
name|present
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|ACPI_FAILURE
argument_list|(
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|devinfo
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* If no _STA method, must be present */
name|present
operator|=
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_STA
operator|)
operator|==
literal|0
operator|||
name|ACPI_BATTERY_PRESENT
argument_list|(
name|devinfo
operator|->
name|CurrentStatus
argument_list|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|present
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if a device has at least one valid device ID.  */
end_comment

begin_function
specifier|static
name|BOOLEAN
name|acpi_has_hid
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|)
block|{
name|ACPI_DEVICE_INFO
modifier|*
name|devinfo
decl_stmt|;
name|BOOLEAN
name|ret
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|ACPI_FAILURE
argument_list|(
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|devinfo
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|ret
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_HID
operator|)
operator|!=
literal|0
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_CID
operator|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|devinfo
operator|->
name|CompatibleIdList
operator|.
name|Count
operator|>
literal|0
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Match a HID string against a handle  */
end_comment

begin_function
name|BOOLEAN
name|acpi_MatchHid
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|hid
parameter_list|)
block|{
name|ACPI_DEVICE_INFO
modifier|*
name|devinfo
decl_stmt|;
name|BOOLEAN
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|hid
operator|==
name|NULL
operator|||
name|h
operator|==
name|NULL
operator|||
name|ACPI_FAILURE
argument_list|(
name|AcpiGetObjectInfo
argument_list|(
name|h
argument_list|,
operator|&
name|devinfo
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|ret
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_HID
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|hid
argument_list|,
name|devinfo
operator|->
name|HardwareId
operator|.
name|String
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|Valid
operator|&
name|ACPI_VALID_CID
operator|)
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|CompatibleIdList
operator|.
name|Count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|hid
argument_list|,
name|devinfo
operator|->
name|CompatibleIdList
operator|.
name|Ids
index|[
name|i
index|]
operator|.
name|String
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|AcpiOsFree
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the handle of a named object within our scope, ie. that of (parent)  * or one if its parents.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_GetHandleInScope
parameter_list|(
name|ACPI_HANDLE
name|parent
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|ACPI_HANDLE
modifier|*
name|result
parameter_list|)
block|{
name|ACPI_HANDLE
name|r
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
comment|/* Walk back up the tree to the root */
for|for
control|(
init|;
condition|;
control|)
block|{
name|status
operator|=
name|AcpiGetHandle
argument_list|(
name|parent
argument_list|,
name|path
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
operator|*
name|result
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* XXX Return error here? */
if|if
condition|(
name|status
operator|!=
name|AE_NOT_FOUND
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiGetParent
argument_list|(
name|parent
argument_list|,
operator|&
name|r
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|AE_NOT_FOUND
operator|)
return|;
name|parent
operator|=
name|r
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a buffer with a preset data size.  */
end_comment

begin_function
name|ACPI_BUFFER
modifier|*
name|acpi_AllocBuffer
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|ACPI_BUFFER
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|size
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|M_ACPIDEV
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|buf
operator|->
name|Length
operator|=
name|size
expr_stmt|;
name|buf
operator|->
name|Pointer
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|ACPI_STATUS
name|acpi_SetInteger
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|UINT32
name|number
parameter_list|)
block|{
name|ACPI_OBJECT
name|arg1
decl_stmt|;
name|ACPI_OBJECT_LIST
name|args
decl_stmt|;
name|arg1
operator|.
name|Type
operator|=
name|ACPI_TYPE_INTEGER
expr_stmt|;
name|arg1
operator|.
name|Integer
operator|.
name|Value
operator|=
name|number
expr_stmt|;
name|args
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|args
operator|.
name|Pointer
operator|=
operator|&
name|arg1
expr_stmt|;
return|return
operator|(
name|AcpiEvaluateObject
argument_list|(
name|handle
argument_list|,
name|path
argument_list|,
operator|&
name|args
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a path that should return an integer.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_GetInteger
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|UINT32
modifier|*
name|number
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_OBJECT
name|param
decl_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
name|handle
operator|=
name|ACPI_ROOT_OBJECT
expr_stmt|;
comment|/*      * Assume that what we've been pointed at is an Integer object, or      * a method that will return an Integer.      */
name|buf
operator|.
name|Pointer
operator|=
operator|&
name|param
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
sizeof|sizeof
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|handle
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|param
operator|.
name|Type
operator|==
name|ACPI_TYPE_INTEGER
condition|)
operator|*
name|number
operator|=
name|param
operator|.
name|Integer
operator|.
name|Value
expr_stmt|;
else|else
name|status
operator|=
name|AE_TYPE
expr_stmt|;
block|}
comment|/*       * In some applications, a method that's expected to return an Integer      * may instead return a Buffer (probably to simplify some internal      * arithmetic).  We'll try to fetch whatever it is, and if it's a Buffer,      * convert it into an Integer as best we can.      *      * This is a hack.      */
if|if
condition|(
name|status
operator|==
name|AE_BUFFER_OVERFLOW
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|.
name|Pointer
operator|=
name|AcpiOsAllocate
argument_list|(
name|buf
operator|.
name|Length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|AE_NO_MEMORY
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|handle
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|acpi_ConvertBufferToInteger
argument_list|(
operator|&
name|buf
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|ACPI_STATUS
name|acpi_ConvertBufferToInteger
parameter_list|(
name|ACPI_BUFFER
modifier|*
name|bufp
parameter_list|,
name|UINT32
modifier|*
name|number
parameter_list|)
block|{
name|ACPI_OBJECT
modifier|*
name|p
decl_stmt|;
name|UINT8
modifier|*
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|bufp
operator|->
name|Pointer
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|Type
operator|==
name|ACPI_TYPE_INTEGER
condition|)
block|{
operator|*
name|number
operator|=
name|p
operator|->
name|Integer
operator|.
name|Value
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|Type
operator|!=
name|ACPI_TYPE_BUFFER
condition|)
return|return
operator|(
name|AE_TYPE
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|Buffer
operator|.
name|Length
operator|>
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|(
name|AE_BAD_DATA
operator|)
return|;
operator|*
name|number
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|p
operator|->
name|Buffer
operator|.
name|Pointer
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|Buffer
operator|.
name|Length
condition|;
name|i
operator|++
control|)
operator|*
name|number
operator|+=
name|val
index|[
name|i
index|]
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over the elements of an a package object, calling the supplied  * function for each element.  *  * XXX possible enhancement might be to abort traversal on error.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_ForeachPackageObject
parameter_list|(
name|ACPI_OBJECT
modifier|*
name|pkg
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|ACPI_OBJECT
modifier|*
name|comp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ACPI_OBJECT
modifier|*
name|comp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pkg
operator|==
name|NULL
operator|||
name|pkg
operator|->
name|Type
operator|!=
name|ACPI_TYPE_PACKAGE
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
comment|/* Iterate over components */
name|i
operator|=
literal|0
expr_stmt|;
name|comp
operator|=
name|pkg
operator|->
name|Package
operator|.
name|Elements
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|pkg
operator|->
name|Package
operator|.
name|Count
condition|;
name|i
operator|++
operator|,
name|comp
operator|++
control|)
name|func
argument_list|(
name|comp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the (index)th resource object in a set.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_FindIndexedResource
parameter_list|(
name|ACPI_BUFFER
modifier|*
name|buf
parameter_list|,
name|int
name|index
parameter_list|,
name|ACPI_RESOURCE
modifier|*
modifier|*
name|resp
parameter_list|)
block|{
name|ACPI_RESOURCE
modifier|*
name|rp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rp
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
name|buf
operator|->
name|Pointer
expr_stmt|;
name|i
operator|=
name|index
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* Range check */
if|if
condition|(
name|rp
operator|>
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|->
name|Pointer
operator|+
name|buf
operator|->
name|Length
operator|)
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
comment|/* Check for terminator */
if|if
condition|(
name|rp
operator|->
name|Type
operator|==
name|ACPI_RESOURCE_TYPE_END_TAG
operator|||
name|rp
operator|->
name|Length
operator|==
literal|0
condition|)
return|return
operator|(
name|AE_NOT_FOUND
operator|)
return|;
name|rp
operator|=
name|ACPI_NEXT_RESOURCE
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resp
operator|!=
name|NULL
condition|)
operator|*
name|resp
operator|=
name|rp
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append an ACPI_RESOURCE to an ACPI_BUFFER.  *  * Given a pointer to an ACPI_RESOURCE structure, expand the ACPI_BUFFER  * provided to contain it.  If the ACPI_BUFFER is empty, allocate a sensible  * backing block.  If the ACPI_RESOURCE is NULL, return an empty set of  * resources.  */
end_comment

begin_define
define|#
directive|define
name|ACPI_INITIAL_RESOURCE_BUFFER_SIZE
value|512
end_define

begin_function
name|ACPI_STATUS
name|acpi_AppendBufferResource
parameter_list|(
name|ACPI_BUFFER
modifier|*
name|buf
parameter_list|,
name|ACPI_RESOURCE
modifier|*
name|res
parameter_list|)
block|{
name|ACPI_RESOURCE
modifier|*
name|rp
decl_stmt|;
name|void
modifier|*
name|newp
decl_stmt|;
comment|/* Initialise the buffer if necessary. */
if|if
condition|(
name|buf
operator|->
name|Pointer
operator|==
name|NULL
condition|)
block|{
name|buf
operator|->
name|Length
operator|=
name|ACPI_INITIAL_RESOURCE_BUFFER_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|->
name|Pointer
operator|=
name|AcpiOsAllocate
argument_list|(
name|buf
operator|->
name|Length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
name|rp
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
name|buf
operator|->
name|Pointer
expr_stmt|;
name|rp
operator|->
name|Type
operator|=
name|ACPI_RESOURCE_TYPE_END_TAG
expr_stmt|;
name|rp
operator|->
name|Length
operator|=
name|ACPI_RS_SIZE_MIN
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
comment|/*      * Scan the current buffer looking for the terminator.      * This will either find the terminator or hit the end      * of the buffer and return an error.      */
name|rp
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
name|buf
operator|->
name|Pointer
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Range check, don't go outside the buffer */
if|if
condition|(
name|rp
operator|>=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|->
name|Pointer
operator|+
name|buf
operator|->
name|Length
operator|)
condition|)
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
if|if
condition|(
name|rp
operator|->
name|Type
operator|==
name|ACPI_RESOURCE_TYPE_END_TAG
operator|||
name|rp
operator|->
name|Length
operator|==
literal|0
condition|)
break|break;
name|rp
operator|=
name|ACPI_NEXT_RESOURCE
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
comment|/*      * Check the size of the buffer and expand if required.      *      * Required size is:      *	size of existing resources before terminator +       *	size of new resource and header +      * 	size of terminator.      *      * Note that this loop should really only run once, unless      * for some reason we are stuffing a *really* huge resource.      */
while|while
condition|(
operator|(
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|rp
operator|-
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|->
name|Pointer
operator|)
operator|+
name|res
operator|->
name|Length
operator|+
name|ACPI_RS_SIZE_NO_DATA
operator|+
name|ACPI_RS_SIZE_MIN
operator|)
operator|>=
name|buf
operator|->
name|Length
condition|)
block|{
if|if
condition|(
operator|(
name|newp
operator|=
name|AcpiOsAllocate
argument_list|(
name|buf
operator|->
name|Length
operator|*
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
name|bcopy
argument_list|(
name|buf
operator|->
name|Pointer
argument_list|,
name|newp
argument_list|,
name|buf
operator|->
name|Length
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|newp
operator|+
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|rp
operator|-
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|->
name|Pointer
operator|)
operator|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|buf
operator|->
name|Pointer
argument_list|)
expr_stmt|;
name|buf
operator|->
name|Pointer
operator|=
name|newp
expr_stmt|;
name|buf
operator|->
name|Length
operator|+=
name|buf
operator|->
name|Length
expr_stmt|;
block|}
comment|/* Insert the new resource. */
name|bcopy
argument_list|(
name|res
argument_list|,
name|rp
argument_list|,
name|res
operator|->
name|Length
operator|+
name|ACPI_RS_SIZE_NO_DATA
argument_list|)
expr_stmt|;
comment|/* And add the terminator. */
name|rp
operator|=
name|ACPI_NEXT_RESOURCE
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Type
operator|=
name|ACPI_RESOURCE_TYPE_END_TAG
expr_stmt|;
name|rp
operator|->
name|Length
operator|=
name|ACPI_RS_SIZE_MIN
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_function
name|ACPI_STATUS
name|acpi_EvaluateOSC
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|uint8_t
modifier|*
name|uuid
parameter_list|,
name|int
name|revision
parameter_list|,
name|int
name|count
parameter_list|,
name|uint32_t
modifier|*
name|caps_in
parameter_list|,
name|uint32_t
modifier|*
name|caps_out
parameter_list|,
name|bool
name|query
parameter_list|)
block|{
name|ACPI_OBJECT
name|arg
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|ACPI_OBJECT_LIST
name|arglist
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|arglist
operator|.
name|Pointer
operator|=
name|arg
expr_stmt|;
name|arglist
operator|.
name|Count
operator|=
literal|4
expr_stmt|;
name|arg
index|[
literal|0
index|]
operator|.
name|Type
operator|=
name|ACPI_TYPE_BUFFER
expr_stmt|;
name|arg
index|[
literal|0
index|]
operator|.
name|Buffer
operator|.
name|Length
operator|=
name|ACPI_UUID_LENGTH
expr_stmt|;
name|arg
index|[
literal|0
index|]
operator|.
name|Buffer
operator|.
name|Pointer
operator|=
name|uuid
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|Type
operator|=
name|ACPI_TYPE_INTEGER
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|Integer
operator|.
name|Value
operator|=
name|revision
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|Type
operator|=
name|ACPI_TYPE_INTEGER
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|Integer
operator|.
name|Value
operator|=
name|count
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|.
name|Type
operator|=
name|ACPI_TYPE_BUFFER
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|.
name|Buffer
operator|.
name|Length
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|caps_in
argument_list|)
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|.
name|Buffer
operator|.
name|Pointer
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|caps_in
expr_stmt|;
name|caps_in
index|[
literal|0
index|]
operator|=
name|query
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObjectTyped
argument_list|(
name|handle
argument_list|,
literal|"_OSC"
argument_list|,
operator|&
name|arglist
argument_list|,
operator|&
name|buf
argument_list|,
name|ACPI_TYPE_BUFFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|status
operator|)
return|;
if|if
condition|(
name|caps_out
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|buf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|Buffer
operator|.
name|Length
operator|!=
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|caps_out
argument_list|)
condition|)
block|{
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_BUFFER_OVERFLOW
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|ret
operator|->
name|Buffer
operator|.
name|Pointer
argument_list|,
name|caps_out
argument_list|,
name|ret
operator|->
name|Buffer
operator|.
name|Length
argument_list|)
expr_stmt|;
block|}
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set interrupt model.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_SetIntrModel
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
operator|(
name|acpi_SetInteger
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
literal|"_PIC"
argument_list|,
name|model
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk subtables of a table and call a callback routine for each  * subtable.  The caller should provide the first subtable and a  * pointer to the end of the table.  This can be used to walk tables  * such as MADT and SRAT that use subtable entries.  */
end_comment

begin_function
name|void
name|acpi_walk_subtables
parameter_list|(
name|void
modifier|*
name|first
parameter_list|,
name|void
modifier|*
name|end
parameter_list|,
name|acpi_subtable_handler
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ACPI_SUBTABLE_HEADER
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|first
init|;
operator|(
name|void
operator|*
operator|)
name|entry
operator|<
name|end
condition|;
control|)
block|{
comment|/* Avoid an infinite loop if we hit a bogus entry. */
if|if
condition|(
name|entry
operator|->
name|Length
operator|<
sizeof|sizeof
argument_list|(
name|ACPI_SUBTABLE_HEADER
argument_list|)
condition|)
return|return;
name|handler
argument_list|(
name|entry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|entry
operator|=
name|ACPI_ADD_PTR
argument_list|(
name|ACPI_SUBTABLE_HEADER
argument_list|,
name|entry
argument_list|,
name|entry
operator|->
name|Length
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * DEPRECATED.  This interface has serious deficiencies and will be  * removed.  *  * Immediately enter the sleep state.  In the old model, acpiconf(8) ran  * rc.suspend and rc.resume so we don't have to notify devd(8) to do this.  */
end_comment

begin_function
name|ACPI_STATUS
name|acpi_SetSleepState
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
specifier|static
name|int
name|once
decl_stmt|;
if|if
condition|(
operator|!
name|once
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"warning: acpi_SetSleepState() deprecated, need to update your software\n"
argument_list|)
expr_stmt|;
name|once
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|acpi_EnterSleepState
argument_list|(
name|sc
argument_list|,
name|state
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_function
specifier|static
name|void
name|acpi_sleep_force_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|acpi_EnterSleepState
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|acpi_next_sstate
argument_list|)
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"force sleep state S%d failed\n"
argument_list|,
name|sc
operator|->
name|acpi_next_sstate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_sleep_force
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"suspend request timed out, forcing sleep now\n"
argument_list|)
expr_stmt|;
comment|/*      * XXX Suspending from callout causes freezes in DEVICE_SUSPEND().      * Suspend from acpi_task thread instead.      */
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiOsExecute
argument_list|(
name|OSL_NOTIFY_HANDLER
argument_list|,
name|acpi_sleep_force_task
argument_list|,
name|sc
argument_list|)
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"AcpiOsExecute() for sleeping failed\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Request that the system enter the given suspend state.  All /dev/apm  * devices and devd(8) will be notified.  Userland then has a chance to  * save state and acknowledge the request.  The system sleeps once all  * acks are in.  */
end_comment

begin_function
name|int
name|acpi_ReqSleepState
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
name|struct
name|apm_clone_data
modifier|*
name|clone
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
if|if
condition|(
name|state
operator|<
name|ACPI_STATE_S1
operator|||
name|state
operator|>
name|ACPI_S_STATES_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|acpi_sleep_states
index|[
name|state
index|]
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/*      * If a reboot/shutdown/suspend request is already in progress or      * suspend is blocked due to an upcoming shutdown, just return.      */
if|if
condition|(
name|rebooting
operator|||
name|sc
operator|->
name|acpi_next_sstate
operator|!=
literal|0
operator|||
name|suspend_blocked
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Wait until sleep is enabled. */
while|while
condition|(
name|sc
operator|->
name|acpi_sleep_disabled
condition|)
block|{
name|AcpiOsSleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|ACPI_LOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_next_sstate
operator|=
name|state
expr_stmt|;
comment|/* S5 (soft-off) should be entered directly with no waiting. */
if|if
condition|(
name|state
operator|==
name|ACPI_STATE_S5
condition|)
block|{
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
name|status
operator|=
name|acpi_EnterSleepState
argument_list|(
name|sc
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|?
literal|0
else|:
name|ENXIO
operator|)
return|;
block|}
comment|/* Record the pending state and notify all apm devices. */
name|STAILQ_FOREACH
argument_list|(
argument|clone
argument_list|,
argument|&sc->apm_cdevs
argument_list|,
argument|entries
argument_list|)
block|{
name|clone
operator|->
name|notify_status
operator|=
name|APM_EV_NONE
expr_stmt|;
if|if
condition|(
operator|(
name|clone
operator|->
name|flags
operator|&
name|ACPI_EVF_DEVD
operator|)
operator|==
literal|0
condition|)
block|{
name|selwakeuppri
argument_list|(
operator|&
name|clone
operator|->
name|sel_read
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|clone
operator|->
name|sel_read
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If devd(8) is not running, immediately enter the sleep state. */
if|if
condition|(
operator|!
name|devctl_process_running
argument_list|()
condition|)
block|{
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
name|status
operator|=
name|acpi_EnterSleepState
argument_list|(
name|sc
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|?
literal|0
else|:
name|ENXIO
operator|)
return|;
block|}
comment|/*      * Set a timeout to fire if userland doesn't ack the suspend request      * in time.  This way we still eventually go to sleep if we were      * overheating or running low on battery, even if userland is hung.      * We cancel this timeout once all userland acks are in or the      * suspend request is aborted.      */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|susp_force_to
argument_list|,
literal|10
operator|*
name|hz
argument_list|,
name|acpi_sleep_force
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
comment|/* Now notify devd(8) also. */
name|acpi_UserNotify
argument_list|(
literal|"Suspend"
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* This platform does not support acpi suspend/resume. */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Acknowledge (or reject) a pending sleep state.  The caller has  * prepared for suspend and is now ready for it to proceed.  If the  * error argument is non-zero, it indicates suspend should be cancelled  * and gives an errno value describing why.  Once all votes are in,  * we suspend the system.  */
end_comment

begin_function
name|int
name|acpi_AckSleepState
parameter_list|(
name|struct
name|apm_clone_data
modifier|*
name|clone
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|sleeping
decl_stmt|;
comment|/* If no pending sleep state, return an error. */
name|ACPI_LOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
name|sc
operator|=
name|clone
operator|->
name|acpi_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|acpi_next_sstate
operator|==
literal|0
condition|)
block|{
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Caller wants to abort suspend process. */
if|if
condition|(
name|error
condition|)
block|{
name|sc
operator|->
name|acpi_next_sstate
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|susp_force_to
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"listener on %s cancelled the pending suspend\n"
argument_list|,
name|devtoname
argument_list|(
name|clone
operator|->
name|cdev
argument_list|)
argument_list|)
expr_stmt|;
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * Mark this device as acking the suspend request.  Then, walk through      * all devices, seeing if they agree yet.  We only count devices that      * are writable since read-only devices couldn't ack the request.      */
name|sleeping
operator|=
name|TRUE
expr_stmt|;
name|clone
operator|->
name|notify_status
operator|=
name|APM_EV_ACKED
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|clone
argument_list|,
argument|&sc->apm_cdevs
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
operator|(
name|clone
operator|->
name|flags
operator|&
name|ACPI_EVF_WRITE
operator|)
operator|!=
literal|0
operator|&&
name|clone
operator|->
name|notify_status
operator|!=
name|APM_EV_ACKED
condition|)
block|{
name|sleeping
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
comment|/* If all devices have voted "yes", we will suspend now. */
if|if
condition|(
name|sleeping
condition|)
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|susp_force_to
argument_list|)
expr_stmt|;
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sleeping
condition|)
block|{
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|acpi_EnterSleepState
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|acpi_next_sstate
argument_list|)
argument_list|)
condition|)
name|ret
operator|=
name|ENODEV
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
else|#
directive|else
comment|/* This platform does not support acpi suspend/resume. */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_sleep_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|ACPI_LOCK_ASSERT
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
comment|/* Reschedule if the system is not fully up and running. */
if|if
condition|(
operator|!
name|AcpiGbl_SystemAwakeAndRunning
condition|)
block|{
name|callout_schedule
argument_list|(
operator|&
name|acpi_sleep_timer
argument_list|,
name|hz
operator|*
name|ACPI_MINIMUM_AWAKETIME
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|acpi_sleep_disabled
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_sleep_disable
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
comment|/* Fail if the system is not fully up and running. */
if|if
condition|(
operator|!
name|AcpiGbl_SystemAwakeAndRunning
condition|)
return|return
operator|(
name|AE_ERROR
operator|)
return|;
name|ACPI_LOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
name|status
operator|=
name|sc
operator|->
name|acpi_sleep_disabled
condition|?
name|AE_ERROR
else|:
name|AE_OK
expr_stmt|;
name|sc
operator|->
name|acpi_sleep_disabled
operator|=
name|TRUE
expr_stmt|;
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_enum
enum|enum
name|acpi_sleep_state
block|{
name|ACPI_SS_NONE
block|,
name|ACPI_SS_GPE_SET
block|,
name|ACPI_SS_DEV_SUSPEND
block|,
name|ACPI_SS_SLP_PREP
block|,
name|ACPI_SS_SLEPT
block|, }
enum|;
end_enum

begin_comment
comment|/*  * Enter the desired system sleep state.  *  * Currently we support S1-S5 but S4 is only S4BIOS  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_EnterSleepState
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|register_t
name|intr
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_EVENT_STATUS
name|power_button_status
decl_stmt|;
name|enum
name|acpi_sleep_state
name|slp_state
decl_stmt|;
name|int
name|sleep_result
decl_stmt|;
name|ACPI_FUNCTION_TRACE_U32
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|<
name|ACPI_STATE_S1
operator|||
name|state
operator|>
name|ACPI_S_STATES_MAX
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acpi_sleep_states
index|[
name|state
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"Sleep state S%d not supported by BIOS\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_SUPPORT
operator|)
return|;
block|}
comment|/* Re-entry once we're suspending is not allowed. */
name|status
operator|=
name|acpi_sleep_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"suspend request ignored (not ready yet)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
if|if
condition|(
name|state
operator|==
name|ACPI_STATE_S5
condition|)
block|{
comment|/* 	 * Shut down cleanly and power off.  This will call us back through the 	 * shutdown handlers. 	 */
name|shutdown_nice
argument_list|(
name|RB_POWEROFF
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
name|EVENTHANDLER_INVOKE
argument_list|(
name|power_suspend_early
argument_list|)
expr_stmt|;
name|stop_all_proc
argument_list|()
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|power_suspend
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EARLY_AP_STARTUP
name|MPASS
argument_list|(
name|mp_ncpus
operator|==
literal|1
operator|||
name|smp_started
argument_list|)
expr_stmt|;
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|curthread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|smp_started
condition|)
block|{
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|curthread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Be sure to hold Giant across DEVICE_SUSPEND/RESUME since non-MPSAFE      * drivers need this.      */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|slp_state
operator|=
name|ACPI_SS_NONE
expr_stmt|;
name|sc
operator|->
name|acpi_sstate
operator|=
name|state
expr_stmt|;
comment|/* Enable any GPEs as appropriate and requested by the user. */
name|acpi_wake_prep_walk
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|slp_state
operator|=
name|ACPI_SS_GPE_SET
expr_stmt|;
comment|/*      * Inform all devices that we are going to sleep.  If at least one      * device fails, DEVICE_SUSPEND() automatically resumes the tree.      *      * XXX Note that a better two-pass approach with a 'veto' pass      * followed by a "real thing" pass would be better, but the current      * bus interface does not provide for this.      */
if|if
condition|(
name|DEVICE_SUSPEND
argument_list|(
name|root_bus
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"device_suspend failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|backout
goto|;
block|}
name|slp_state
operator|=
name|ACPI_SS_DEV_SUSPEND
expr_stmt|;
comment|/* If testing device suspend only, back out of everything here. */
if|if
condition|(
name|acpi_susp_bounce
condition|)
goto|goto
name|backout
goto|;
name|status
operator|=
name|AcpiEnterSleepStatePrep
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"AcpiEnterSleepStatePrep failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|backout
goto|;
block|}
name|slp_state
operator|=
name|ACPI_SS_SLP_PREP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|acpi_sleep_delay
operator|>
literal|0
condition|)
name|DELAY
argument_list|(
name|sc
operator|->
name|acpi_sleep_delay
operator|*
literal|1000000
argument_list|)
expr_stmt|;
name|intr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|ACPI_STATE_S1
condition|)
block|{
name|sleep_result
operator|=
name|acpi_sleep_machdep
argument_list|(
name|sc
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|acpi_wakeup_machdep
argument_list|(
name|sc
argument_list|,
name|state
argument_list|,
name|sleep_result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * XXX According to ACPI specification SCI_EN bit should be restored 	 * by ACPI platform (BIOS, firmware) to its pre-sleep state. 	 * Unfortunately some BIOSes fail to do that and that leads to 	 * unexpected and serious consequences during wake up like a system 	 * getting stuck in SMI handlers. 	 * This hack is picked up from Linux, which claims that it follows 	 * Windows behavior. 	 */
if|if
condition|(
name|sleep_result
operator|==
literal|1
operator|&&
name|state
operator|!=
name|ACPI_STATE_S4
condition|)
name|AcpiWriteBitRegister
argument_list|(
name|ACPI_BITREG_SCI_ENABLE
argument_list|,
name|ACPI_ENABLE_EVENT
argument_list|)
expr_stmt|;
name|AcpiLeaveSleepStatePrep
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleep_result
operator|==
literal|1
operator|&&
name|state
operator|==
name|ACPI_STATE_S3
condition|)
block|{
comment|/* 	     * Prevent mis-interpretation of the wakeup by power button 	     * as a request for power off. 	     * Ideally we should post an appropriate wakeup event, 	     * perhaps using acpi_event_power_button_wake or alike. 	     * 	     * Clearing of power button status after wakeup is mandated 	     * by ACPI specification in section "Fixed Power Button". 	     * 	     * XXX As of ACPICA 20121114 AcpiGetEventStatus provides 	     * status as 0/1 corressponding to inactive/active despite 	     * its type being ACPI_EVENT_STATUS.  In other words, 	     * we should not test for ACPI_EVENT_FLAG_SET for time being. 	     */
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetEventStatus
argument_list|(
name|ACPI_EVENT_POWER_BUTTON
argument_list|,
operator|&
name|power_button_status
argument_list|)
argument_list|)
operator|&&
name|power_button_status
operator|!=
literal|0
condition|)
block|{
name|AcpiClearEvent
argument_list|(
name|ACPI_EVENT_POWER_BUTTON
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"cleared fixed power button status\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|intr_restore
argument_list|(
name|intr
argument_list|)
expr_stmt|;
comment|/* call acpi_wakeup_machdep() again with interrupt enabled */
name|acpi_wakeup_machdep
argument_list|(
name|sc
argument_list|,
name|state
argument_list|,
name|sleep_result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleep_result
operator|==
operator|-
literal|1
condition|)
goto|goto
name|backout
goto|;
comment|/* Re-enable ACPI hardware on wakeup from sleep state 4. */
if|if
condition|(
name|state
operator|==
name|ACPI_STATE_S4
condition|)
name|AcpiEnable
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|AcpiEnterSleepState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|AcpiLeaveSleepStatePrep
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|intr_restore
argument_list|(
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"AcpiEnterSleepState failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|backout
goto|;
block|}
block|}
name|slp_state
operator|=
name|ACPI_SS_SLEPT
expr_stmt|;
comment|/*      * Back out state according to how far along we got in the suspend      * process.  This handles both the error and success cases.      */
name|backout
label|:
if|if
condition|(
name|slp_state
operator|>=
name|ACPI_SS_GPE_SET
condition|)
block|{
name|acpi_wake_prep_walk
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|acpi_sstate
operator|=
name|ACPI_STATE_S0
expr_stmt|;
block|}
if|if
condition|(
name|slp_state
operator|>=
name|ACPI_SS_DEV_SUSPEND
condition|)
name|DEVICE_RESUME
argument_list|(
name|root_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|slp_state
operator|>=
name|ACPI_SS_SLP_PREP
condition|)
name|AcpiLeaveSleepState
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|slp_state
operator|>=
name|ACPI_SS_SLEPT
condition|)
block|{
name|acpi_resync_clock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|acpi_enable_fixed_events
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|acpi_next_sstate
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EARLY_AP_STARTUP
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_unbind
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|smp_started
condition|)
block|{
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_unbind
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|resume_all_proc
argument_list|()
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|power_resume
argument_list|)
expr_stmt|;
comment|/* Allow another sleep request after a while. */
name|callout_schedule
argument_list|(
operator|&
name|acpi_sleep_timer
argument_list|,
name|hz
operator|*
name|ACPI_MINIMUM_AWAKETIME
argument_list|)
expr_stmt|;
comment|/* Run /etc/rc.resume after we are back. */
if|if
condition|(
name|devctl_process_running
argument_list|()
condition|)
name|acpi_UserNotify
argument_list|(
literal|"Resume"
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_resync_clock
parameter_list|(
name|struct
name|acpi_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/*      * Warm up timecounter again and reset system clock.      */
operator|(
name|void
operator|)
name|timecounter
operator|->
name|tc_get_timecount
argument_list|(
name|timecounter
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|timecounter
operator|->
name|tc_get_timecount
argument_list|(
name|timecounter
argument_list|)
expr_stmt|;
name|inittodr
argument_list|(
name|time_second
operator|+
name|sc
operator|->
name|acpi_sleep_delay
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enable or disable the device's wake GPE. */
end_comment

begin_function
name|int
name|acpi_wake_set_enable
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|struct
name|acpi_prw_data
name|prw
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* Make sure the device supports waking the system and get the GPE. */
if|if
condition|(
name|acpi_parse_prw
argument_list|(
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|prw
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|flags
operator|=
name|acpi_get_flags
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|status
operator|=
name|AcpiSetGpeWakeMask
argument_list|(
name|prw
operator|.
name|gpe_handle
argument_list|,
name|prw
operator|.
name|gpe_bit
argument_list|,
name|ACPI_GPE_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"enable wake failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|acpi_set_flags
argument_list|(
name|dev
argument_list|,
name|flags
operator||
name|ACPI_FLAG_WAKE_ENABLED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|AcpiSetGpeWakeMask
argument_list|(
name|prw
operator|.
name|gpe_handle
argument_list|,
name|prw
operator|.
name|gpe_bit
argument_list|,
name|ACPI_GPE_DISABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"disable wake failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|acpi_set_flags
argument_list|(
name|dev
argument_list|,
name|flags
operator|&
operator|~
name|ACPI_FLAG_WAKE_ENABLED
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_wake_sleep_prep
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|int
name|sstate
parameter_list|)
block|{
name|struct
name|acpi_prw_data
name|prw
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
comment|/* Check that this is a wake-capable device and get its GPE. */
if|if
condition|(
name|acpi_parse_prw
argument_list|(
name|handle
argument_list|,
operator|&
name|prw
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dev
operator|=
name|acpi_get_device
argument_list|(
name|handle
argument_list|)
expr_stmt|;
comment|/*      * The destination sleep state must be less than (i.e., higher power)      * or equal to the value specified by _PRW.  If this GPE cannot be      * enabled for the next sleep state, then disable it.  If it can and      * the user requested it be enabled, turn on any required power resources      * and set _PSW.      */
if|if
condition|(
name|sstate
operator|>
name|prw
operator|.
name|lowest_wake
condition|)
block|{
name|AcpiSetGpeWakeMask
argument_list|(
name|prw
operator|.
name|gpe_handle
argument_list|,
name|prw
operator|.
name|gpe_bit
argument_list|,
name|ACPI_GPE_DISABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"wake_prep disabled wake for %s (S%d)\n"
argument_list|,
name|acpi_name
argument_list|(
name|handle
argument_list|)
argument_list|,
name|sstate
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dev
operator|&&
operator|(
name|acpi_get_flags
argument_list|(
name|dev
argument_list|)
operator|&
name|ACPI_FLAG_WAKE_ENABLED
operator|)
operator|!=
literal|0
condition|)
block|{
name|acpi_pwr_wake_enable
argument_list|(
name|handle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acpi_SetInteger
argument_list|(
name|handle
argument_list|,
literal|"_PSW"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"wake_prep enabled for %s (S%d)\n"
argument_list|,
name|acpi_name
argument_list|(
name|handle
argument_list|)
argument_list|,
name|sstate
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_wake_run_prep
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|int
name|sstate
parameter_list|)
block|{
name|struct
name|acpi_prw_data
name|prw
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
comment|/*      * Check that this is a wake-capable device and get its GPE.  Return      * now if the user didn't enable this device for wake.      */
if|if
condition|(
name|acpi_parse_prw
argument_list|(
name|handle
argument_list|,
operator|&
name|prw
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dev
operator|=
name|acpi_get_device
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
operator|||
operator|(
name|acpi_get_flags
argument_list|(
name|dev
argument_list|)
operator|&
name|ACPI_FLAG_WAKE_ENABLED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*      * If this GPE couldn't be enabled for the previous sleep state, it was      * disabled before going to sleep so re-enable it.  If it was enabled,      * clear _PSW and turn off any power resources it used.      */
if|if
condition|(
name|sstate
operator|>
name|prw
operator|.
name|lowest_wake
condition|)
block|{
name|AcpiSetGpeWakeMask
argument_list|(
name|prw
operator|.
name|gpe_handle
argument_list|,
name|prw
operator|.
name|gpe_bit
argument_list|,
name|ACPI_GPE_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"run_prep re-enabled %s\n"
argument_list|,
name|acpi_name
argument_list|(
name|handle
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|acpi_SetInteger
argument_list|(
name|handle
argument_list|,
literal|"_PSW"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|acpi_pwr_wake_enable
argument_list|(
name|handle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"run_prep cleaned up for %s\n"
argument_list|,
name|acpi_name
argument_list|(
name|handle
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_wake_prep
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|UINT32
name|level
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
modifier|*
name|status
parameter_list|)
block|{
name|int
name|sstate
decl_stmt|;
comment|/* If suspending, run the sleep prep function, otherwise wake. */
name|sstate
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|context
expr_stmt|;
if|if
condition|(
name|AcpiGbl_SystemAwakeAndRunning
condition|)
name|acpi_wake_sleep_prep
argument_list|(
name|handle
argument_list|,
name|sstate
argument_list|)
expr_stmt|;
else|else
name|acpi_wake_run_prep
argument_list|(
name|handle
argument_list|,
name|sstate
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Walk the tree rooted at acpi0 to prep devices for suspend/resume. */
end_comment

begin_function
specifier|static
name|int
name|acpi_wake_prep_walk
parameter_list|(
name|int
name|sstate
parameter_list|)
block|{
name|ACPI_HANDLE
name|sb_handle
decl_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetHandle
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
literal|"\\_SB_"
argument_list|,
operator|&
name|sb_handle
argument_list|)
argument_list|)
condition|)
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_DEVICE
argument_list|,
name|sb_handle
argument_list|,
literal|100
argument_list|,
name|acpi_wake_prep
argument_list|,
name|NULL
argument_list|,
operator|&
name|sstate
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Walk the tree rooted at acpi0 to attach per-device wake sysctls. */
end_comment

begin_function
specifier|static
name|int
name|acpi_wake_sysctl_walk
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|numdevs
decl_stmt|;
name|device_t
modifier|*
name|devlist
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|error
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|numdevs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|numdevs
operator|==
literal|0
condition|)
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
name|acpi_wake_sysctl_walk
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|child
argument_list|)
condition|)
continue|continue;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|acpi_get_handle
argument_list|(
name|child
argument_list|)
argument_list|,
literal|"_PRW"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|child
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|child
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"wake"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|child
argument_list|,
literal|0
argument_list|,
name|acpi_wake_set_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Device set to wake the system"
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Enable or disable wake from userland. */
end_comment

begin_function
specifier|static
name|int
name|acpi_wake_set_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|enable
decl_stmt|,
name|error
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
operator|(
name|device_t
operator|)
name|arg1
expr_stmt|;
name|enable
operator|=
operator|(
name|acpi_get_flags
argument_list|(
name|dev
argument_list|)
operator|&
name|ACPI_FLAG_WAKE_ENABLED
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|enable
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|enable
operator|!=
literal|0
operator|&&
name|enable
operator|!=
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|acpi_wake_set_enable
argument_list|(
name|dev
argument_list|,
name|enable
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a device's _PRW into a structure. */
end_comment

begin_function
name|int
name|acpi_parse_prw
parameter_list|(
name|ACPI_HANDLE
name|h
parameter_list|,
name|struct
name|acpi_prw_data
modifier|*
name|prw
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_BUFFER
name|prw_buffer
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|res
decl_stmt|,
modifier|*
name|res2
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|power_count
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|prw
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*      * The _PRW object (7.2.9) is only required for devices that have the      * ability to wake the system from a sleeping state.      */
name|error
operator|=
name|EINVAL
expr_stmt|;
name|prw_buffer
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|prw_buffer
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|h
argument_list|,
literal|"_PRW"
argument_list|,
name|NULL
argument_list|,
operator|&
name|prw_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|res
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|prw_buffer
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
operator|!
name|ACPI_PKG_VALID
argument_list|(
name|res
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/*      * Element 1 of the _PRW object:      * The lowest power system sleeping state that can be entered while still      * providing wake functionality.  The sleeping state being entered must      * be less than (i.e., higher power) or equal to this value.      */
if|if
condition|(
name|acpi_PkgInt32
argument_list|(
name|res
argument_list|,
literal|1
argument_list|,
operator|&
name|prw
operator|->
name|lowest_wake
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*      * Element 0 of the _PRW object:      */
switch|switch
condition|(
name|res
operator|->
name|Package
operator|.
name|Elements
index|[
literal|0
index|]
operator|.
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_INTEGER
case|:
comment|/* 	 * If the data type of this package element is numeric, then this 	 * _PRW package element is the bit index in the GPEx_EN, in the 	 * GPE blocks described in the FADT, of the enable bit that is 	 * enabled for the wake event. 	 */
name|prw
operator|->
name|gpe_handle
operator|=
name|NULL
expr_stmt|;
name|prw
operator|->
name|gpe_bit
operator|=
name|res
operator|->
name|Package
operator|.
name|Elements
index|[
literal|0
index|]
operator|.
name|Integer
operator|.
name|Value
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_PACKAGE
case|:
comment|/* 	 * If the data type of this package element is a package, then this 	 * _PRW package element is itself a package containing two 	 * elements.  The first is an object reference to the GPE Block 	 * device that contains the GPE that will be triggered by the wake 	 * event.  The second element is numeric and it contains the bit 	 * index in the GPEx_EN, in the GPE Block referenced by the 	 * first element in the package, of the enable bit that is enabled for 	 * the wake event. 	 * 	 * For example, if this field is a package then it is of the form: 	 * Package() {\_SB.PCI0.ISA.GPE, 2} 	 */
name|res2
operator|=
operator|&
name|res
operator|->
name|Package
operator|.
name|Elements
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ACPI_PKG_VALID
argument_list|(
name|res2
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|prw
operator|->
name|gpe_handle
operator|=
name|acpi_GetReference
argument_list|(
name|NULL
argument_list|,
operator|&
name|res2
operator|->
name|Package
operator|.
name|Elements
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|prw
operator|->
name|gpe_handle
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|acpi_PkgInt32
argument_list|(
name|res2
argument_list|,
literal|1
argument_list|,
operator|&
name|prw
operator|->
name|gpe_bit
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
goto|goto
name|out
goto|;
block|}
comment|/* Elements 2 to N of the _PRW object are power resources. */
name|power_count
operator|=
name|res
operator|->
name|Package
operator|.
name|Count
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|power_count
operator|>
name|ACPI_PRW_MAX_POWERRES
condition|)
block|{
name|printf
argument_list|(
literal|"ACPI device %s has too many power resources\n"
argument_list|,
name|acpi_name
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|power_count
operator|=
literal|0
expr_stmt|;
block|}
name|prw
operator|->
name|power_res_count
operator|=
name|power_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|power_count
condition|;
name|i
operator|++
control|)
name|prw
operator|->
name|power_res
index|[
name|i
index|]
operator|=
name|res
operator|->
name|Package
operator|.
name|Elements
index|[
name|i
index|]
expr_stmt|;
name|out
label|:
if|if
condition|(
name|prw_buffer
operator|.
name|Pointer
operator|!=
name|NULL
condition|)
name|AcpiOsFree
argument_list|(
name|prw_buffer
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ACPI Event Handlers  */
end_comment

begin_comment
comment|/* System Event Handlers (registered by EVENTHANDLER_REGISTER) */
end_comment

begin_function
specifier|static
name|void
name|acpi_system_eventhandler_sleep
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ACPI_FUNCTION_TRACE_U32
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Check if button action is disabled or unknown. */
if|if
condition|(
name|state
operator|==
name|ACPI_STATE_UNKNOWN
condition|)
return|return;
comment|/* Request that the system prepare to enter the given suspend state. */
name|ret
operator|=
name|acpi_ReqSleepState
argument_list|(
name|sc
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"request to enter state S%d failed (err %d)\n"
argument_list|,
name|state
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_system_eventhandler_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE_U32
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Currently, nothing to do for wakeup. */
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * ACPICA Event Handlers (FixedEvent, also called from button notify handler)  */
end_comment

begin_function
specifier|static
name|void
name|acpi_invoke_sleep_eventhandler
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|EVENTHANDLER_INVOKE
argument_list|(
name|acpi_sleep_event
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_invoke_wake_eventhandler
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|EVENTHANDLER_INVOKE
argument_list|(
name|acpi_wakeup_event
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|UINT32
name|acpi_event_power_button_sleep
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiOsExecute
argument_list|(
name|OSL_NOTIFY_HANDLER
argument_list|,
name|acpi_invoke_sleep_eventhandler
argument_list|,
operator|&
name|sc
operator|->
name|acpi_power_button_sx
argument_list|)
argument_list|)
condition|)
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_NOT_HANDLED
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|UINT32
name|acpi_event_power_button_wake
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiOsExecute
argument_list|(
name|OSL_NOTIFY_HANDLER
argument_list|,
name|acpi_invoke_wake_eventhandler
argument_list|,
operator|&
name|sc
operator|->
name|acpi_power_button_sx
argument_list|)
argument_list|)
condition|)
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_NOT_HANDLED
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|UINT32
name|acpi_event_sleep_button_sleep
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiOsExecute
argument_list|(
name|OSL_NOTIFY_HANDLER
argument_list|,
name|acpi_invoke_sleep_eventhandler
argument_list|,
operator|&
name|sc
operator|->
name|acpi_sleep_button_sx
argument_list|)
argument_list|)
condition|)
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_NOT_HANDLED
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|UINT32
name|acpi_event_sleep_button_wake
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|context
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiOsExecute
argument_list|(
name|OSL_NOTIFY_HANDLER
argument_list|,
name|acpi_invoke_wake_eventhandler
argument_list|,
operator|&
name|sc
operator|->
name|acpi_sleep_button_sx
argument_list|)
argument_list|)
condition|)
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_NOT_HANDLED
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|ACPI_INTERRUPT_HANDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX This static buffer is suboptimal.  There is no locking so only  * use this for single-threaded callers.  */
end_comment

begin_function
name|char
modifier|*
name|acpi_name
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|)
block|{
name|ACPI_BUFFER
name|buf
decl_stmt|;
specifier|static
name|char
name|data
index|[
literal|256
index|]
decl_stmt|;
name|buf
operator|.
name|Length
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|handle
operator|&&
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetName
argument_list|(
name|handle
argument_list|,
name|ACPI_FULL_PATHNAME
argument_list|,
operator|&
name|buf
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|data
operator|)
return|;
return|return
operator|(
literal|"(unknown)"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Debugging/bug-avoidance.  Avoid trying to fetch info on various  * parts of the namespace.  */
end_comment

begin_function
name|int
name|acpi_avoid
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|env
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|int
name|len
decl_stmt|;
name|np
operator|=
name|acpi_name
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|==
literal|'\\'
condition|)
name|np
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|env
operator|=
name|kern_getenv
argument_list|(
literal|"debug.acpi.avoid"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Scan the avoid list checking for a match */
name|cp
operator|=
name|env
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|cp
operator|!=
literal|0
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
break|break;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
index|[
name|len
index|]
operator|!=
literal|0
operator|&&
operator|!
name|isspace
argument_list|(
name|cp
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
name|np
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|len
expr_stmt|;
block|}
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Debugging/bug-avoidance.  Disable ACPI subsystem components.  */
end_comment

begin_function
name|int
name|acpi_disabled
parameter_list|(
name|char
modifier|*
name|subsys
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|env
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|env
operator|=
name|kern_getenv
argument_list|(
literal|"debug.acpi.disabled"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|env
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Scan the disable list, checking for a match. */
name|cp
operator|=
name|env
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
index|[
name|len
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
name|cp
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|subsys
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|len
expr_stmt|;
block|}
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_lookup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|device_t
modifier|*
name|dev
parameter_list|)
block|{
name|ACPI_HANDLE
name|handle
decl_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NULL
condition|)
return|return;
comment|/*      * Allow any handle name that is specified as an absolute path and      * starts with '\'.  We could restrict this to \_SB and friends,      * but see acpi_probe_children() for notes on why we scan the entire      * namespace for devices.      *      * XXX: The pathname argument to AcpiGetHandle() should be fixed to      * be const.      */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'\\'
condition|)
return|return;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|AcpiGetHandle
argument_list|(
name|ACPI_ROOT_OBJECT
argument_list|,
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|name
argument_list|)
argument_list|,
operator|&
name|handle
argument_list|)
argument_list|)
condition|)
return|return;
operator|*
name|dev
operator|=
name|acpi_get_device
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Control interface.  *  * We multiplex ioctls for all participating ACPI devices here.  Individual   * drivers wanting to be accessible via /dev/acpi should use the  * register/deregister interface to make their handlers visible.  */
end_comment

begin_struct
struct|struct
name|acpi_ioctl_hook
block|{
name|TAILQ_ENTRY
argument_list|(
argument|acpi_ioctl_hook
argument_list|)
name|link
expr_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|acpi_ioctl_fn
name|fn
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|acpi_ioctl_hook
argument_list|)
name|acpi_ioctl_hooks
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|acpi_ioctl_hooks_initted
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|acpi_register_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|acpi_ioctl_fn
name|fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|acpi_ioctl_hook
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hp
argument_list|)
argument_list|,
name|M_ACPIDEV
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|hp
operator|->
name|cmd
operator|=
name|cmd
expr_stmt|;
name|hp
operator|->
name|fn
operator|=
name|fn
expr_stmt|;
name|hp
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|ACPI_LOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|acpi_ioctl_hooks_initted
operator|==
literal|0
condition|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|acpi_ioctl_hooks
argument_list|)
expr_stmt|;
name|acpi_ioctl_hooks_initted
operator|=
literal|1
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|acpi_ioctl_hooks
argument_list|,
name|hp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|acpi_deregister_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|acpi_ioctl_fn
name|fn
parameter_list|)
block|{
name|struct
name|acpi_ioctl_hook
modifier|*
name|hp
decl_stmt|;
name|ACPI_LOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|hp
argument_list|,
argument|&acpi_ioctl_hooks
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|hp
operator|->
name|cmd
operator|==
name|cmd
operator|&&
name|hp
operator|->
name|fn
operator|==
name|fn
condition|)
break|break;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|acpi_ioctl_hooks
argument_list|,
name|hp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hp
argument_list|,
name|M_ACPIDEV
argument_list|)
expr_stmt|;
block|}
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpiopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpiclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpiioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|acpi_ioctl_hook
modifier|*
name|hp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|state
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|hp
operator|=
name|NULL
expr_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
comment|/*      * Scan the list of registered ioctls, looking for handlers.      */
name|ACPI_LOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|acpi_ioctl_hooks_initted
condition|)
name|TAILQ_FOREACH
argument_list|(
argument|hp
argument_list|,
argument|&acpi_ioctl_hooks
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|hp
operator|->
name|cmd
operator|==
name|cmd
condition|)
break|break;
block|}
name|ACPI_UNLOCK
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
return|return
operator|(
name|hp
operator|->
name|fn
argument_list|(
name|cmd
argument_list|,
name|addr
argument_list|,
name|hp
operator|->
name|arg
argument_list|)
operator|)
return|;
comment|/*      * Core ioctls are not permitted for non-writable user.      * Currently, other ioctls just fetch information.      * Not changing system behavior.      */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* Core system ioctls. */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ACPIIO_REQSLPSTATE
case|:
name|state
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|ACPI_STATE_S5
condition|)
return|return
operator|(
name|acpi_ReqSleepState
argument_list|(
name|sc
argument_list|,
name|state
argument_list|)
operator|)
return|;
name|device_printf
argument_list|(
name|sc
operator|->
name|acpi_dev
argument_list|,
literal|"power off via acpi ioctl not supported\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
case|case
name|ACPIIO_ACKSLPSTATE
case|:
name|error
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
name|error
operator|=
name|acpi_AckSleepState
argument_list|(
name|sc
operator|->
name|acpi_clone
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPIIO_SETSLPSTATE
case|:
comment|/* DEPRECATED */
name|state
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|state
operator|<
name|ACPI_STATE_S0
operator|||
name|state
operator|>
name|ACPI_S_STATES_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|acpi_sleep_states
index|[
name|state
index|]
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|acpi_SetSleepState
argument_list|(
name|sc
argument_list|,
name|state
argument_list|)
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_sname2sstate
parameter_list|(
specifier|const
name|char
modifier|*
name|sname
parameter_list|)
block|{
name|int
name|sstate
decl_stmt|;
if|if
condition|(
name|toupper
argument_list|(
name|sname
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'S'
condition|)
block|{
name|sstate
operator|=
name|sname
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|sstate
operator|>=
name|ACPI_STATE_S0
operator|&&
name|sstate
operator|<=
name|ACPI_STATE_S5
operator|&&
name|sname
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|sstate
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|sname
argument_list|,
literal|"NONE"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ACPI_STATE_UNKNOWN
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|acpi_sstate2sname
parameter_list|(
name|int
name|sstate
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|snames
index|[]
init|=
block|{
literal|"S0"
block|,
literal|"S1"
block|,
literal|"S2"
block|,
literal|"S3"
block|,
literal|"S4"
block|,
literal|"S5"
block|}
decl_stmt|;
if|if
condition|(
name|sstate
operator|>=
name|ACPI_STATE_S0
operator|&&
name|sstate
operator|<=
name|ACPI_STATE_S5
condition|)
return|return
operator|(
name|snames
index|[
name|sstate
index|]
operator|)
return|;
elseif|else
if|if
condition|(
name|sstate
operator|==
name|ACPI_STATE_UNKNOWN
condition|)
return|return
operator|(
literal|"NONE"
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_supported_sleep_state_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|UINT8
name|state
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|32
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
expr_stmt|;
for|for
control|(
name|state
operator|=
name|ACPI_STATE_S1
init|;
name|state
operator|<
name|ACPI_S_STATE_COUNT
condition|;
name|state
operator|++
control|)
if|if
condition|(
name|acpi_sleep_states
index|[
name|state
index|]
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s "
argument_list|,
name|acpi_sstate2sname
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_sleep_state_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|sleep_state
index|[
literal|10
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|new_state
decl_stmt|,
name|old_state
decl_stmt|;
name|old_state
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|strlcpy
argument_list|(
name|sleep_state
argument_list|,
name|acpi_sstate2sname
argument_list|(
name|old_state
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sleep_state
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sleep_state
argument_list|,
sizeof|sizeof
argument_list|(
name|sleep_state
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
name|new_state
operator|=
name|acpi_sname2sstate
argument_list|(
name|sleep_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_state
operator|<
name|ACPI_STATE_S1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|new_state
operator|<
name|ACPI_S_STATE_COUNT
operator|&&
operator|!
name|acpi_sleep_states
index|[
name|new_state
index|]
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|new_state
operator|!=
name|old_state
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|=
name|new_state
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Inform devctl(4) when we receive a Notify. */
end_comment

begin_function
name|void
name|acpi_UserNotify
parameter_list|(
specifier|const
name|char
modifier|*
name|subsystem
parameter_list|,
name|ACPI_HANDLE
name|h
parameter_list|,
name|uint8_t
name|notify
parameter_list|)
block|{
name|char
name|notify_buf
index|[
literal|16
index|]
decl_stmt|;
name|ACPI_BUFFER
name|handle_buf
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
if|if
condition|(
name|subsystem
operator|==
name|NULL
condition|)
return|return;
name|handle_buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|handle_buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiNsHandleToPathname
argument_list|(
name|h
argument_list|,
operator|&
name|handle_buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return;
name|snprintf
argument_list|(
name|notify_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|notify_buf
argument_list|)
argument_list|,
literal|"notify=0x%02x"
argument_list|,
name|notify
argument_list|)
expr_stmt|;
name|devctl_notify
argument_list|(
literal|"ACPI"
argument_list|,
name|subsystem
argument_list|,
name|handle_buf
operator|.
name|Pointer
argument_list|,
name|notify_buf
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|handle_buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ACPI_DEBUG
end_ifdef

begin_comment
comment|/*  * Support for parsing debug options from the kernel environment.  *  * Bits may be set in the AcpiDbgLayer and AcpiDbgLevel debug registers  * by specifying the names of the bits in the debug.acpi.layer and  * debug.acpi.level environment variables.  Bits may be unset by   * prefixing the bit name with !.  */
end_comment

begin_struct
struct|struct
name|debugtag
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|UINT32
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|debugtag
name|dbg_layer
index|[]
init|=
block|{
block|{
literal|"ACPI_UTILITIES"
block|,
name|ACPI_UTILITIES
block|}
block|,
block|{
literal|"ACPI_HARDWARE"
block|,
name|ACPI_HARDWARE
block|}
block|,
block|{
literal|"ACPI_EVENTS"
block|,
name|ACPI_EVENTS
block|}
block|,
block|{
literal|"ACPI_TABLES"
block|,
name|ACPI_TABLES
block|}
block|,
block|{
literal|"ACPI_NAMESPACE"
block|,
name|ACPI_NAMESPACE
block|}
block|,
block|{
literal|"ACPI_PARSER"
block|,
name|ACPI_PARSER
block|}
block|,
block|{
literal|"ACPI_DISPATCHER"
block|,
name|ACPI_DISPATCHER
block|}
block|,
block|{
literal|"ACPI_EXECUTER"
block|,
name|ACPI_EXECUTER
block|}
block|,
block|{
literal|"ACPI_RESOURCES"
block|,
name|ACPI_RESOURCES
block|}
block|,
block|{
literal|"ACPI_CA_DEBUGGER"
block|,
name|ACPI_CA_DEBUGGER
block|}
block|,
block|{
literal|"ACPI_OS_SERVICES"
block|,
name|ACPI_OS_SERVICES
block|}
block|,
block|{
literal|"ACPI_CA_DISASSEMBLER"
block|,
name|ACPI_CA_DISASSEMBLER
block|}
block|,
block|{
literal|"ACPI_ALL_COMPONENTS"
block|,
name|ACPI_ALL_COMPONENTS
block|}
block|,
block|{
literal|"ACPI_AC_ADAPTER"
block|,
name|ACPI_AC_ADAPTER
block|}
block|,
block|{
literal|"ACPI_BATTERY"
block|,
name|ACPI_BATTERY
block|}
block|,
block|{
literal|"ACPI_BUS"
block|,
name|ACPI_BUS
block|}
block|,
block|{
literal|"ACPI_BUTTON"
block|,
name|ACPI_BUTTON
block|}
block|,
block|{
literal|"ACPI_EC"
block|,
name|ACPI_EC
block|}
block|,
block|{
literal|"ACPI_FAN"
block|,
name|ACPI_FAN
block|}
block|,
block|{
literal|"ACPI_POWERRES"
block|,
name|ACPI_POWERRES
block|}
block|,
block|{
literal|"ACPI_PROCESSOR"
block|,
name|ACPI_PROCESSOR
block|}
block|,
block|{
literal|"ACPI_THERMAL"
block|,
name|ACPI_THERMAL
block|}
block|,
block|{
literal|"ACPI_TIMER"
block|,
name|ACPI_TIMER
block|}
block|,
block|{
literal|"ACPI_ALL_DRIVERS"
block|,
name|ACPI_ALL_DRIVERS
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|debugtag
name|dbg_level
index|[]
init|=
block|{
block|{
literal|"ACPI_LV_INIT"
block|,
name|ACPI_LV_INIT
block|}
block|,
block|{
literal|"ACPI_LV_DEBUG_OBJECT"
block|,
name|ACPI_LV_DEBUG_OBJECT
block|}
block|,
block|{
literal|"ACPI_LV_INFO"
block|,
name|ACPI_LV_INFO
block|}
block|,
block|{
literal|"ACPI_LV_REPAIR"
block|,
name|ACPI_LV_REPAIR
block|}
block|,
block|{
literal|"ACPI_LV_ALL_EXCEPTIONS"
block|,
name|ACPI_LV_ALL_EXCEPTIONS
block|}
block|,
comment|/* Trace verbosity level 1 [Standard Trace Level] */
block|{
literal|"ACPI_LV_INIT_NAMES"
block|,
name|ACPI_LV_INIT_NAMES
block|}
block|,
block|{
literal|"ACPI_LV_PARSE"
block|,
name|ACPI_LV_PARSE
block|}
block|,
block|{
literal|"ACPI_LV_LOAD"
block|,
name|ACPI_LV_LOAD
block|}
block|,
block|{
literal|"ACPI_LV_DISPATCH"
block|,
name|ACPI_LV_DISPATCH
block|}
block|,
block|{
literal|"ACPI_LV_EXEC"
block|,
name|ACPI_LV_EXEC
block|}
block|,
block|{
literal|"ACPI_LV_NAMES"
block|,
name|ACPI_LV_NAMES
block|}
block|,
block|{
literal|"ACPI_LV_OPREGION"
block|,
name|ACPI_LV_OPREGION
block|}
block|,
block|{
literal|"ACPI_LV_BFIELD"
block|,
name|ACPI_LV_BFIELD
block|}
block|,
block|{
literal|"ACPI_LV_TABLES"
block|,
name|ACPI_LV_TABLES
block|}
block|,
block|{
literal|"ACPI_LV_VALUES"
block|,
name|ACPI_LV_VALUES
block|}
block|,
block|{
literal|"ACPI_LV_OBJECTS"
block|,
name|ACPI_LV_OBJECTS
block|}
block|,
block|{
literal|"ACPI_LV_RESOURCES"
block|,
name|ACPI_LV_RESOURCES
block|}
block|,
block|{
literal|"ACPI_LV_USER_REQUESTS"
block|,
name|ACPI_LV_USER_REQUESTS
block|}
block|,
block|{
literal|"ACPI_LV_PACKAGE"
block|,
name|ACPI_LV_PACKAGE
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSITY1"
block|,
name|ACPI_LV_VERBOSITY1
block|}
block|,
comment|/* Trace verbosity level 2 [Function tracing and memory allocation] */
block|{
literal|"ACPI_LV_ALLOCATIONS"
block|,
name|ACPI_LV_ALLOCATIONS
block|}
block|,
block|{
literal|"ACPI_LV_FUNCTIONS"
block|,
name|ACPI_LV_FUNCTIONS
block|}
block|,
block|{
literal|"ACPI_LV_OPTIMIZATIONS"
block|,
name|ACPI_LV_OPTIMIZATIONS
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSITY2"
block|,
name|ACPI_LV_VERBOSITY2
block|}
block|,
block|{
literal|"ACPI_LV_ALL"
block|,
name|ACPI_LV_ALL
block|}
block|,
comment|/* Trace verbosity level 3 [Threading, I/O, and Interrupts] */
block|{
literal|"ACPI_LV_MUTEX"
block|,
name|ACPI_LV_MUTEX
block|}
block|,
block|{
literal|"ACPI_LV_THREADS"
block|,
name|ACPI_LV_THREADS
block|}
block|,
block|{
literal|"ACPI_LV_IO"
block|,
name|ACPI_LV_IO
block|}
block|,
block|{
literal|"ACPI_LV_INTERRUPTS"
block|,
name|ACPI_LV_INTERRUPTS
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSITY3"
block|,
name|ACPI_LV_VERBOSITY3
block|}
block|,
comment|/* Exceptionally verbose output -- also used in the global "DebugLevel"  */
block|{
literal|"ACPI_LV_AML_DISASSEMBLE"
block|,
name|ACPI_LV_AML_DISASSEMBLE
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSE_INFO"
block|,
name|ACPI_LV_VERBOSE_INFO
block|}
block|,
block|{
literal|"ACPI_LV_FULL_TABLES"
block|,
name|ACPI_LV_FULL_TABLES
block|}
block|,
block|{
literal|"ACPI_LV_EVENTS"
block|,
name|ACPI_LV_EVENTS
block|}
block|,
block|{
literal|"ACPI_LV_VERBOSE"
block|,
name|ACPI_LV_VERBOSE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|acpi_parse_debug
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|struct
name|debugtag
modifier|*
name|tag
parameter_list|,
name|UINT32
modifier|*
name|flag
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|int
name|set
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
name|ep
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|ep
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|ep
argument_list|)
condition|)
name|ep
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'!'
condition|)
block|{
name|set
operator|=
literal|0
expr_stmt|;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|ep
condition|)
continue|continue;
block|}
else|else
block|{
name|set
operator|=
literal|1
expr_stmt|;
block|}
name|l
operator|=
name|ep
operator|-
name|cp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tag
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
name|tag
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|l
argument_list|)
condition|)
block|{
if|if
condition|(
name|set
condition|)
operator|*
name|flag
operator||=
name|tag
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
else|else
operator|*
name|flag
operator|&=
operator|~
name|tag
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
block|}
name|cp
operator|=
name|ep
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_set_debugging
parameter_list|(
name|void
modifier|*
name|junk
parameter_list|)
block|{
name|char
modifier|*
name|layer
decl_stmt|,
modifier|*
name|level
decl_stmt|;
if|if
condition|(
name|cold
condition|)
block|{
name|AcpiDbgLayer
operator|=
literal|0
expr_stmt|;
name|AcpiDbgLevel
operator|=
literal|0
expr_stmt|;
block|}
name|layer
operator|=
name|kern_getenv
argument_list|(
literal|"debug.acpi.layer"
argument_list|)
expr_stmt|;
name|level
operator|=
name|kern_getenv
argument_list|(
literal|"debug.acpi.level"
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|==
name|NULL
operator|&&
name|level
operator|==
name|NULL
condition|)
return|return;
name|printf
argument_list|(
literal|"ACPI set debug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"NONE"
argument_list|,
name|layer
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" layer '%s'"
argument_list|,
name|layer
argument_list|)
expr_stmt|;
name|acpi_parse_debug
argument_list|(
name|layer
argument_list|,
operator|&
name|dbg_layer
index|[
literal|0
index|]
argument_list|,
operator|&
name|AcpiDbgLayer
argument_list|)
expr_stmt|;
name|freeenv
argument_list|(
name|layer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"NONE"
argument_list|,
name|level
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" level '%s'"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|acpi_parse_debug
argument_list|(
name|level
argument_list|,
operator|&
name|dbg_level
index|[
literal|0
index|]
argument_list|,
operator|&
name|AcpiDbgLevel
argument_list|)
expr_stmt|;
name|freeenv
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|acpi_debugging
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|acpi_set_debugging
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|acpi_debug_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
modifier|*
name|dbg
decl_stmt|;
name|struct
name|debugtag
modifier|*
name|tag
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|char
name|temp
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|oidp
operator|->
name|oid_arg1
argument_list|,
literal|"debug.acpi.layer"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tag
operator|=
operator|&
name|dbg_layer
index|[
literal|0
index|]
expr_stmt|;
name|dbg
operator|=
operator|&
name|AcpiDbgLayer
expr_stmt|;
block|}
else|else
block|{
name|tag
operator|=
operator|&
name|dbg_level
index|[
literal|0
index|]
expr_stmt|;
name|dbg
operator|=
operator|&
name|AcpiDbgLevel
expr_stmt|;
block|}
comment|/* Get old values if this is a get request. */
name|ACPI_SERIAL_BEGIN
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dbg
operator|==
literal|0
condition|)
block|{
name|sbuf_cpy
argument_list|(
operator|&
name|sb
argument_list|,
literal|"NONE"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|tag
operator|->
name|name
operator|!=
name|NULL
condition|;
name|tag
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|dbg
operator|&
name|tag
operator|->
name|value
operator|)
operator|==
name|tag
operator|->
name|value
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s "
argument_list|,
name|tag
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|temp
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* Check for error or no change */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|dbg
operator|=
literal|0
expr_stmt|;
name|kern_setenv
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|acpi_set_debugging
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ACPI_SERIAL_END
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_acpi
argument_list|,
name|OID_AUTO
argument_list|,
name|layer
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLTYPE_STRING
argument_list|,
literal|"debug.acpi.layer"
argument_list|,
literal|0
argument_list|,
name|acpi_debug_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_acpi
argument_list|,
name|OID_AUTO
argument_list|,
name|level
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLTYPE_STRING
argument_list|,
literal|"debug.acpi.level"
argument_list|,
literal|0
argument_list|,
name|acpi_debug_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ACPI_DEBUG */
end_comment

begin_function
specifier|static
name|int
name|acpi_debug_objects_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|old
decl_stmt|;
name|old
operator|=
name|acpi_debug_objects
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|acpi_debug_objects
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|old
operator|==
name|acpi_debug_objects
operator|||
operator|(
name|old
operator|&&
name|acpi_debug_objects
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ACPI_SERIAL_BEGIN
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
name|AcpiGbl_EnableAmlDebugObject
operator|=
name|acpi_debug_objects
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|ACPI_SERIAL_END
argument_list|(
name|acpi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_parse_interfaces
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|acpi_interface
modifier|*
name|iface
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|p
operator|=
name|str
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|strdup
argument_list|(
name|p
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|','
condition|)
name|p
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
condition|)
if|if
condition|(
name|isspace
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|||
name|p
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
name|i
operator|++
expr_stmt|;
else|else
block|{
name|i
operator|+=
name|strlen
argument_list|(
name|p
operator|+
name|i
argument_list|)
operator|+
literal|1
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|iface
operator|->
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|iface
operator|->
name|data
argument_list|)
operator|*
name|j
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|iface
operator|->
name|num
operator|=
name|j
expr_stmt|;
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
condition|)
if|if
condition|(
name|isspace
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|||
name|p
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
name|i
operator|++
expr_stmt|;
else|else
block|{
name|iface
operator|->
name|data
index|[
name|j
index|]
operator|=
name|p
operator|+
name|i
expr_stmt|;
name|i
operator|+=
name|strlen
argument_list|(
name|p
operator|+
name|i
argument_list|)
operator|+
literal|1
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|j
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_free_interfaces
parameter_list|(
name|struct
name|acpi_interface
modifier|*
name|iface
parameter_list|)
block|{
name|free
argument_list|(
name|iface
operator|->
name|data
index|[
literal|0
index|]
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iface
operator|->
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_reset_interfaces
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_interface
name|list
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|acpi_parse_interfaces
argument_list|(
name|acpi_install_interface
argument_list|,
operator|&
name|list
argument_list|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|num
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|AcpiInstallInterface
argument_list|(
name|list
operator|.
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to install _OSI(\"%s\"): %s\n"
argument_list|,
name|list
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"installed _OSI(\"%s\")\n"
argument_list|,
name|list
operator|.
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|acpi_free_interfaces
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acpi_parse_interfaces
argument_list|(
name|acpi_remove_interface
argument_list|,
operator|&
name|list
argument_list|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|num
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|AcpiRemoveInterface
argument_list|(
name|list
operator|.
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to remove _OSI(\"%s\"): %s\n"
argument_list|,
name|list
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"removed _OSI(\"%s\")\n"
argument_list|,
name|list
operator|.
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|acpi_free_interfaces
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_pm_func
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|state
decl_stmt|,
name|acpi_state
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|acpi_softc
modifier|*
name|sc
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|POWER_CMD_SUSPEND
case|:
name|sc
operator|=
operator|(
expr|struct
name|acpi_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|state
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|POWER_SLEEP_STATE_STANDBY
case|:
name|acpi_state
operator|=
name|sc
operator|->
name|acpi_standby_sx
expr_stmt|;
break|break;
case|case
name|POWER_SLEEP_STATE_SUSPEND
case|:
name|acpi_state
operator|=
name|sc
operator|->
name|acpi_suspend_sx
expr_stmt|;
break|break;
case|case
name|POWER_SLEEP_STATE_HIBERNATE
case|:
name|acpi_state
operator|=
name|ACPI_STATE_S4
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|acpi_EnterSleepState
argument_list|(
name|sc
argument_list|,
name|acpi_state
argument_list|)
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_pm_register
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cold
operator|||
name|resource_disabled
argument_list|(
literal|"acpi"
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|power_pm_register
argument_list|(
name|POWER_PM_TYPE_ACPI
argument_list|,
name|acpi_pm_func
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|power
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|acpi_pm_register
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

