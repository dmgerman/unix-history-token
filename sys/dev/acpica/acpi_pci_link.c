begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Mitsuru IWASAKI<iwasaki@jp.freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpi_pcibvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/pci_cfgreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_comment
comment|/* Hooks for the ACPI CA debugging infrastructure. */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_BUS
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"PCI_LINK"
argument_list|)
end_macro

begin_expr_stmt
name|ACPI_SERIAL_DECL
argument_list|(
name|pci_link
argument_list|,
literal|"ACPI PCI link"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NUM_ISA_INTERRUPTS
value|16
end_define

begin_define
define|#
directive|define
name|NUM_ACPI_INTERRUPTS
value|256
end_define

begin_comment
comment|/*  * An ACPI PCI link device may contain multiple links.  Each link has its  * own ACPI resource.  _PRT entries specify which link is being used via  * the Source Index.  *  * XXX: A note about Source Indices and DPFs:  Currently we assume that  * the DPF start and end tags are not counted towards the index that  * Source Index corresponds to.  Also, we assume that when DPFs are in use  * they various sets overlap in terms of Indices.  Here's an example  * resource list indicating these assumptions:  *  * Resource		Index  * --------		-----  * I/O Port		0  * Start DPF		-  * IRQ			1  * MemIO		2  * Start DPF		-  * IRQ			1  * MemIO		2  * End DPF		-  * DMA Channel		3  *  * The XXX is because I'm not sure if this is a valid assumption to make.  */
end_comment

begin_comment
comment|/* States during DPF processing. */
end_comment

begin_define
define|#
directive|define
name|DPF_OUTSIDE
value|0
end_define

begin_define
define|#
directive|define
name|DPF_FIRST
value|1
end_define

begin_define
define|#
directive|define
name|DPF_IGNORE
value|2
end_define

begin_struct_decl
struct_decl|struct
name|link
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|acpi_pci_link_softc
block|{
name|int
name|pl_num_links
decl_stmt|;
name|int
name|pl_crs_bad
decl_stmt|;
name|struct
name|link
modifier|*
name|pl_links
decl_stmt|;
name|device_t
name|pl_dev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|link
block|{
name|struct
name|acpi_pci_link_softc
modifier|*
name|l_sc
decl_stmt|;
name|uint8_t
name|l_bios_irq
decl_stmt|;
name|uint8_t
name|l_irq
decl_stmt|;
name|uint8_t
name|l_initial_irq
decl_stmt|;
name|UINT32
name|l_crs_type
decl_stmt|;
name|int
name|l_res_index
decl_stmt|;
name|int
name|l_num_irqs
decl_stmt|;
name|int
modifier|*
name|l_irqs
decl_stmt|;
name|int
name|l_references
decl_stmt|;
name|int
name|l_routed
range|:
literal|1
decl_stmt|;
name|int
name|l_isa_irq
range|:
literal|1
decl_stmt|;
name|ACPI_RESOURCE
name|l_prs_template
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|link_count_request
block|{
name|int
name|in_dpf
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|link_res_request
block|{
name|struct
name|acpi_pci_link_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|in_dpf
decl_stmt|;
name|int
name|res_index
decl_stmt|;
name|int
name|link_index
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_PCI_LINK
argument_list|,
literal|"pci_link"
argument_list|,
literal|"ACPI PCI Link structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_link_interrupt_weights
index|[
name|NUM_ACPI_INTERRUPTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_link_bios_isa_irqs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pci_link_ids
index|[]
init|=
block|{
literal|"PNP0C0F"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Fetch the short name associated with an ACPI handle and save it in the  * passed in buffer.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_short_name
parameter_list|(
name|ACPI_HANDLE
name|handle
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|buf
operator|.
name|Length
operator|=
name|buflen
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|buffer
expr_stmt|;
return|return
operator|(
name|AcpiGetName
argument_list|(
name|handle
argument_list|,
name|ACPI_SINGLE_NAME
argument_list|,
operator|&
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_pci_link_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
name|descr
index|[
literal|28
index|]
decl_stmt|,
name|name
index|[
literal|12
index|]
decl_stmt|;
comment|/* 	 * We explicitly do not check _STA since not all systems set it to 	 * sensible values. 	 */
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"pci_link"
argument_list|)
operator|||
name|ACPI_ID_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|pci_link_ids
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|acpi_short_name
argument_list|(
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|descr
argument_list|,
sizeof|sizeof
argument_list|(
name|descr
argument_list|)
argument_list|,
literal|"ACPI PCI Link %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|descr
argument_list|)
expr_stmt|;
block|}
else|else
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ACPI PCI Link"
argument_list|)
expr_stmt|;
name|device_quiet
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_count_irq_resources
parameter_list|(
name|ACPI_RESOURCE
modifier|*
name|res
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|link_count_request
modifier|*
name|req
decl_stmt|;
name|req
operator|=
operator|(
expr|struct
name|link_count_request
operator|*
operator|)
name|context
expr_stmt|;
switch|switch
condition|(
name|res
operator|->
name|Type
condition|)
block|{
case|case
name|ACPI_RESOURCE_TYPE_START_DEPENDENT
case|:
switch|switch
condition|(
name|req
operator|->
name|in_dpf
condition|)
block|{
case|case
name|DPF_OUTSIDE
case|:
comment|/* We've started the first DPF. */
name|req
operator|->
name|in_dpf
operator|=
name|DPF_FIRST
expr_stmt|;
break|break;
case|case
name|DPF_FIRST
case|:
comment|/* We've started the second DPF. */
name|req
operator|->
name|in_dpf
operator|=
name|DPF_IGNORE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ACPI_RESOURCE_TYPE_END_DEPENDENT
case|:
comment|/* We are finished with DPF parsing. */
name|KASSERT
argument_list|(
name|req
operator|->
name|in_dpf
operator|!=
name|DPF_OUTSIDE
argument_list|,
operator|(
literal|"%s: end dpf when not parsing a dpf"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|in_dpf
operator|=
name|DPF_OUTSIDE
expr_stmt|;
break|break;
case|case
name|ACPI_RESOURCE_TYPE_IRQ
case|:
case|case
name|ACPI_RESOURCE_TYPE_EXTENDED_IRQ
case|:
comment|/* 		 * Don't count resources if we are in a DPF set that we are 		 * ignoring. 		 */
if|if
condition|(
name|req
operator|->
name|in_dpf
operator|!=
name|DPF_IGNORE
condition|)
name|req
operator|->
name|count
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|link_add_crs
parameter_list|(
name|ACPI_RESOURCE
modifier|*
name|res
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|link_res_request
modifier|*
name|req
decl_stmt|;
name|struct
name|link
modifier|*
name|link
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
expr|struct
name|link_res_request
operator|*
operator|)
name|context
expr_stmt|;
switch|switch
condition|(
name|res
operator|->
name|Type
condition|)
block|{
case|case
name|ACPI_RESOURCE_TYPE_START_DEPENDENT
case|:
switch|switch
condition|(
name|req
operator|->
name|in_dpf
condition|)
block|{
case|case
name|DPF_OUTSIDE
case|:
comment|/* We've started the first DPF. */
name|req
operator|->
name|in_dpf
operator|=
name|DPF_FIRST
expr_stmt|;
break|break;
case|case
name|DPF_FIRST
case|:
comment|/* We've started the second DPF. */
name|panic
argument_list|(
literal|"%s: Multiple dependent functions within a current resource"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ACPI_RESOURCE_TYPE_END_DEPENDENT
case|:
comment|/* We are finished with DPF parsing. */
name|KASSERT
argument_list|(
name|req
operator|->
name|in_dpf
operator|!=
name|DPF_OUTSIDE
argument_list|,
operator|(
literal|"%s: end dpf when not parsing a dpf"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|in_dpf
operator|=
name|DPF_OUTSIDE
expr_stmt|;
break|break;
case|case
name|ACPI_RESOURCE_TYPE_IRQ
case|:
case|case
name|ACPI_RESOURCE_TYPE_EXTENDED_IRQ
case|:
name|KASSERT
argument_list|(
name|req
operator|->
name|link_index
operator|<
name|req
operator|->
name|sc
operator|->
name|pl_num_links
argument_list|,
operator|(
literal|"%s: array boundary violation"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|link
operator|=
operator|&
name|req
operator|->
name|sc
operator|->
name|pl_links
index|[
name|req
operator|->
name|link_index
index|]
expr_stmt|;
name|link
operator|->
name|l_res_index
operator|=
name|req
operator|->
name|res_index
expr_stmt|;
name|link
operator|->
name|l_crs_type
operator|=
name|res
operator|->
name|Type
expr_stmt|;
name|req
operator|->
name|link_index
operator|++
expr_stmt|;
name|req
operator|->
name|res_index
operator|++
expr_stmt|;
comment|/* 		 * Only use the current value if there's one IRQ.  Some 		 * systems return multiple IRQs (which is nonsense for _CRS) 		 * when the link hasn't been programmed. 		 */
if|if
condition|(
name|res
operator|->
name|Type
operator|==
name|ACPI_RESOURCE_TYPE_IRQ
condition|)
block|{
if|if
condition|(
name|res
operator|->
name|Data
operator|.
name|Irq
operator|.
name|InterruptCount
operator|==
literal|1
condition|)
name|link
operator|->
name|l_irq
operator|=
name|res
operator|->
name|Data
operator|.
name|Irq
operator|.
name|Interrupts
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res
operator|->
name|Data
operator|.
name|ExtendedIrq
operator|.
name|InterruptCount
operator|==
literal|1
condition|)
name|link
operator|->
name|l_irq
operator|=
name|res
operator|->
name|Data
operator|.
name|ExtendedIrq
operator|.
name|Interrupts
index|[
literal|0
index|]
expr_stmt|;
comment|/* 		 * An IRQ of zero means that the link isn't routed. 		 */
if|if
condition|(
name|link
operator|->
name|l_irq
operator|==
literal|0
condition|)
name|link
operator|->
name|l_irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
break|break;
default|default:
name|req
operator|->
name|res_index
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Populate the set of possible IRQs for each device.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|link_add_prs
parameter_list|(
name|ACPI_RESOURCE
modifier|*
name|res
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ACPI_RESOURCE
modifier|*
name|tmp
decl_stmt|;
name|struct
name|link_res_request
modifier|*
name|req
decl_stmt|;
name|struct
name|link
modifier|*
name|link
decl_stmt|;
name|UINT8
modifier|*
name|irqs
init|=
name|NULL
decl_stmt|;
name|UINT32
modifier|*
name|ext_irqs
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|is_ext_irq
init|=
literal|1
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
expr|struct
name|link_res_request
operator|*
operator|)
name|context
expr_stmt|;
switch|switch
condition|(
name|res
operator|->
name|Type
condition|)
block|{
case|case
name|ACPI_RESOURCE_TYPE_START_DEPENDENT
case|:
switch|switch
condition|(
name|req
operator|->
name|in_dpf
condition|)
block|{
case|case
name|DPF_OUTSIDE
case|:
comment|/* We've started the first DPF. */
name|req
operator|->
name|in_dpf
operator|=
name|DPF_FIRST
expr_stmt|;
break|break;
case|case
name|DPF_FIRST
case|:
comment|/* We've started the second DPF. */
name|req
operator|->
name|in_dpf
operator|=
name|DPF_IGNORE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ACPI_RESOURCE_TYPE_END_DEPENDENT
case|:
comment|/* We are finished with DPF parsing. */
name|KASSERT
argument_list|(
name|req
operator|->
name|in_dpf
operator|!=
name|DPF_OUTSIDE
argument_list|,
operator|(
literal|"%s: end dpf when not parsing a dpf"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|in_dpf
operator|=
name|DPF_OUTSIDE
expr_stmt|;
break|break;
case|case
name|ACPI_RESOURCE_TYPE_IRQ
case|:
name|is_ext_irq
operator|=
literal|0
expr_stmt|;
comment|/* fall through */
case|case
name|ACPI_RESOURCE_TYPE_EXTENDED_IRQ
case|:
comment|/* 		 * Don't parse resources if we are in a DPF set that we are 		 * ignoring. 		 */
if|if
condition|(
name|req
operator|->
name|in_dpf
operator|==
name|DPF_IGNORE
condition|)
break|break;
name|KASSERT
argument_list|(
name|req
operator|->
name|link_index
operator|<
name|req
operator|->
name|sc
operator|->
name|pl_num_links
argument_list|,
operator|(
literal|"%s: array boundary violation"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|link
operator|=
operator|&
name|req
operator|->
name|sc
operator|->
name|pl_links
index|[
name|req
operator|->
name|link_index
index|]
expr_stmt|;
if|if
condition|(
name|link
operator|->
name|l_res_index
operator|==
operator|-
literal|1
condition|)
block|{
name|KASSERT
argument_list|(
name|req
operator|->
name|sc
operator|->
name|pl_crs_bad
argument_list|,
operator|(
literal|"res_index should be set"
operator|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|l_res_index
operator|=
name|req
operator|->
name|res_index
expr_stmt|;
block|}
name|req
operator|->
name|link_index
operator|++
expr_stmt|;
name|req
operator|->
name|res_index
operator|++
expr_stmt|;
comment|/* 		 * Stash a copy of the resource for later use when doing 		 * _SRS. 		 */
name|tmp
operator|=
operator|&
name|link
operator|->
name|l_prs_template
expr_stmt|;
if|if
condition|(
name|is_ext_irq
condition|)
block|{
name|bcopy
argument_list|(
name|res
argument_list|,
name|tmp
argument_list|,
name|ACPI_RS_SIZE
argument_list|(
name|tmp
operator|->
name|Data
operator|.
name|ExtendedIrq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * XXX acpi_AppendBufferResource() cannot handle 			 * optional data. 			 */
name|bzero
argument_list|(
operator|&
name|tmp
operator|->
name|Data
operator|.
name|ExtendedIrq
operator|.
name|ResourceSource
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
operator|->
name|Data
operator|.
name|ExtendedIrq
operator|.
name|ResourceSource
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|Length
operator|=
name|ACPI_RS_SIZE
argument_list|(
name|tmp
operator|->
name|Data
operator|.
name|ExtendedIrq
argument_list|)
expr_stmt|;
name|link
operator|->
name|l_num_irqs
operator|=
name|res
operator|->
name|Data
operator|.
name|ExtendedIrq
operator|.
name|InterruptCount
expr_stmt|;
name|ext_irqs
operator|=
name|res
operator|->
name|Data
operator|.
name|ExtendedIrq
operator|.
name|Interrupts
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|res
argument_list|,
name|tmp
argument_list|,
name|ACPI_RS_SIZE
argument_list|(
name|tmp
operator|->
name|Data
operator|.
name|Irq
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|l_num_irqs
operator|=
name|res
operator|->
name|Data
operator|.
name|Irq
operator|.
name|InterruptCount
expr_stmt|;
name|irqs
operator|=
name|res
operator|->
name|Data
operator|.
name|Irq
operator|.
name|Interrupts
expr_stmt|;
block|}
if|if
condition|(
name|link
operator|->
name|l_num_irqs
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Save a list of the valid IRQs.  Also, if all of the 		 * valid IRQs are ISA IRQs, then mark this link as 		 * routed via an ISA interrupt. 		 */
name|link
operator|->
name|l_isa_irq
operator|=
name|TRUE
expr_stmt|;
name|link
operator|->
name|l_irqs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|link
operator|->
name|l_num_irqs
argument_list|,
name|M_PCI_LINK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|link
operator|->
name|l_num_irqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|is_ext_irq
condition|)
block|{
name|link
operator|->
name|l_irqs
index|[
name|i
index|]
operator|=
name|ext_irqs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ext_irqs
index|[
name|i
index|]
operator|>=
name|NUM_ISA_INTERRUPTS
condition|)
name|link
operator|->
name|l_isa_irq
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|link
operator|->
name|l_irqs
index|[
name|i
index|]
operator|=
name|irqs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|irqs
index|[
name|i
index|]
operator|>=
name|NUM_ISA_INTERRUPTS
condition|)
name|link
operator|->
name|l_isa_irq
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/* 		 * If this is not an ISA IRQ but _CRS used a non-extended 		 * IRQ descriptor, don't use _CRS as a template for _SRS. 		 */
if|if
condition|(
operator|!
name|req
operator|->
name|sc
operator|->
name|pl_crs_bad
operator|&&
operator|!
name|link
operator|->
name|l_isa_irq
operator|&&
name|link
operator|->
name|l_crs_type
operator|==
name|ACPI_RESOURCE_TYPE_IRQ
condition|)
name|req
operator|->
name|sc
operator|->
name|pl_crs_bad
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|req
operator|->
name|in_dpf
operator|==
name|DPF_IGNORE
condition|)
break|break;
if|if
condition|(
name|req
operator|->
name|sc
operator|->
name|pl_crs_bad
condition|)
name|device_printf
argument_list|(
name|req
operator|->
name|sc
operator|->
name|pl_dev
argument_list|,
literal|"Warning: possible resource %d will be lost during _SRS\n"
argument_list|,
name|req
operator|->
name|res_index
argument_list|)
expr_stmt|;
name|req
operator|->
name|res_index
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_valid_irq
parameter_list|(
name|struct
name|link
modifier|*
name|link
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
comment|/* Invalid interrupts are never valid. */
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Any interrupt in the list of possible interrupts is valid. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|link
operator|->
name|l_num_irqs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|link
operator|->
name|l_irqs
index|[
name|i
index|]
operator|==
name|irq
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* 	 * For links routed via an ISA interrupt, if the SCI is routed via 	 * an ISA interrupt, the SCI is always treated as a valid IRQ. 	 */
if|if
condition|(
name|link
operator|->
name|l_isa_irq
operator|&&
name|AcpiGbl_FADT
operator|.
name|SciInterrupt
operator|==
name|irq
operator|&&
name|irq
operator|<
name|NUM_ISA_INTERRUPTS
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* If the interrupt wasn't found in the list it is not valid. */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acpi_pci_link_dump
parameter_list|(
name|struct
name|acpi_pci_link_softc
modifier|*
name|sc
parameter_list|,
name|int
name|header
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|struct
name|link
modifier|*
name|link
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s:"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|pl_dev
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-16.16s  Index  IRQ  Rtd  Ref  IRQs\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|pl_num_links
condition|;
name|i
operator|++
control|)
block|{
name|link
operator|=
operator|&
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"  %-14.14s  %5d  %3d   %c   %3d "
argument_list|,
name|i
operator|==
literal|0
condition|?
name|tag
else|:
literal|""
argument_list|,
name|i
argument_list|,
name|link
operator|->
name|l_irq
argument_list|,
name|link
operator|->
name|l_routed
condition|?
literal|'Y'
else|:
literal|'N'
argument_list|,
name|link
operator|->
name|l_references
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|->
name|l_num_irqs
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" none"
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|link
operator|->
name|l_num_irqs
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|link
operator|->
name|l_irqs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_pci_link_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_pci_link_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|link_count_request
name|creq
decl_stmt|;
name|struct
name|link_res_request
name|rreq
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pl_dev
operator|=
name|dev
expr_stmt|;
name|ACPI_SERIAL_BEGIN
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
comment|/* 	 * Count the number of current resources so we know how big of 	 * a link array to allocate.  On some systems, _CRS is broken, 	 * so for those systems try to derive the count from _PRS instead. 	 */
name|creq
operator|.
name|in_dpf
operator|=
name|DPF_OUTSIDE
expr_stmt|;
name|creq
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|AcpiWalkResources
argument_list|(
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"_CRS"
argument_list|,
name|acpi_count_irq_resources
argument_list|,
operator|&
name|creq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pl_crs_bad
operator|=
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pl_crs_bad
condition|)
block|{
name|creq
operator|.
name|in_dpf
operator|=
name|DPF_OUTSIDE
expr_stmt|;
name|creq
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|AcpiWalkResources
argument_list|(
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"_PRS"
argument_list|,
name|acpi_count_irq_resources
argument_list|,
operator|&
name|creq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to parse _CRS or _PRS: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_END
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|pl_num_links
operator|=
name|creq
operator|.
name|count
expr_stmt|;
if|if
condition|(
name|creq
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|ACPI_SERIAL_END
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|pl_links
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|link
argument_list|)
operator|*
name|sc
operator|->
name|pl_num_links
argument_list|,
name|M_PCI_LINK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Initialize the child links. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|pl_num_links
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_bios_irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_isa_irq
operator|=
name|FALSE
expr_stmt|;
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_res_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Try to read the current settings from _CRS if it is valid. */
if|if
condition|(
operator|!
name|sc
operator|->
name|pl_crs_bad
condition|)
block|{
name|rreq
operator|.
name|in_dpf
operator|=
name|DPF_OUTSIDE
expr_stmt|;
name|rreq
operator|.
name|link_index
operator|=
literal|0
expr_stmt|;
name|rreq
operator|.
name|res_index
operator|=
literal|0
expr_stmt|;
name|rreq
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|status
operator|=
name|AcpiWalkResources
argument_list|(
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"_CRS"
argument_list|,
name|link_add_crs
argument_list|,
operator|&
name|rreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to parse _CRS: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* 	 * Try to read the possible settings from _PRS.  Note that if the 	 * _CRS is toast, we depend on having a working _PRS.  However, if 	 * _CRS works, then it is ok for _PRS to be missing. 	 */
name|rreq
operator|.
name|in_dpf
operator|=
name|DPF_OUTSIDE
expr_stmt|;
name|rreq
operator|.
name|link_index
operator|=
literal|0
expr_stmt|;
name|rreq
operator|.
name|res_index
operator|=
literal|0
expr_stmt|;
name|rreq
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|status
operator|=
name|AcpiWalkResources
argument_list|(
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"_PRS"
argument_list|,
name|link_add_prs
argument_list|,
operator|&
name|rreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
operator|&&
operator|(
name|status
operator|!=
name|AE_NOT_FOUND
operator|||
name|sc
operator|->
name|pl_crs_bad
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to parse _PRS: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|acpi_pci_link_dump
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
literal|"Initial Probe"
argument_list|)
expr_stmt|;
comment|/* Verify initial IRQs if we have _PRS. */
if|if
condition|(
name|status
operator|!=
name|AE_NOT_FOUND
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|pl_num_links
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|link_valid_irq
argument_list|(
operator|&
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_irq
argument_list|)
condition|)
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|acpi_pci_link_dump
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|"Validation"
argument_list|)
expr_stmt|;
comment|/* Save initial IRQs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|pl_num_links
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_initial_irq
operator|=
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_irq
expr_stmt|;
comment|/* 	 * Try to disable this link.  If successful, set the current IRQ to 	 * zero and flags to indicate this link is not routed.  If we can't 	 * run _DIS (i.e., the method doesn't exist), assume the initial 	 * IRQ was routed by the BIOS. 	 */
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiEvaluateObject
argument_list|(
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"_DIS"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|pl_num_links
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|pl_num_links
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_irq
argument_list|)
condition|)
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_routed
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|acpi_pci_link_dump
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|"After Disable"
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_END
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|ACPI_SERIAL_END
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|pl_num_links
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_irqs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_irqs
argument_list|,
name|M_PCI_LINK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|pl_links
argument_list|,
name|M_PCI_LINK
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX: Note that this is identical to pci_pir_search_irq(). */
end_comment

begin_function
specifier|static
name|uint8_t
name|acpi_pci_link_search_irq
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|device
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|uint32_t
name|value
decl_stmt|;
name|uint8_t
name|func
decl_stmt|,
name|maxfunc
decl_stmt|;
comment|/* See if we have a valid device at function 0. */
name|value
operator|=
name|pci_cfgregread
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
literal|0
argument_list|,
name|PCIR_HDRTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
name|PCIM_HDRTYPE
operator|)
operator|>
name|PCI_MAXHDRTYPE
condition|)
return|return
operator|(
name|PCI_INVALID_IRQ
operator|)
return|;
if|if
condition|(
name|value
operator|&
name|PCIM_MFDEV
condition|)
name|maxfunc
operator|=
name|PCI_FUNCMAX
expr_stmt|;
else|else
name|maxfunc
operator|=
literal|0
expr_stmt|;
comment|/* Scan all possible functions at this device. */
for|for
control|(
name|func
operator|=
literal|0
init|;
name|func
operator|<=
name|maxfunc
condition|;
name|func
operator|++
control|)
block|{
name|value
operator|=
name|pci_cfgregread
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
name|func
argument_list|,
name|PCIR_DEVVENDOR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0xffffffff
condition|)
continue|continue;
name|value
operator|=
name|pci_cfgregread
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
name|func
argument_list|,
name|PCIR_INTPIN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * See if it uses the pin in question.  Note that the passed 		 * in pin uses 0 for A, .. 3 for D whereas the intpin 		 * register uses 0 for no interrupt, 1 for A, .. 4 for D. 		 */
if|if
condition|(
name|value
operator|!=
name|pin
operator|+
literal|1
condition|)
continue|continue;
name|value
operator|=
name|pci_cfgregread
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
name|func
argument_list|,
name|PCIR_INTLINE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ACPI: Found matching pin for %d.%d.INT%c at func %d: %d\n"
argument_list|,
name|bus
argument_list|,
name|device
argument_list|,
name|pin
operator|+
literal|'A'
argument_list|,
name|func
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|PCI_INVALID_IRQ
condition|)
return|return
operator|(
name|value
operator|)
return|;
block|}
return|return
operator|(
name|PCI_INVALID_IRQ
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the link structure that corresponds to the resource index passed in  * via 'source_index'.  */
end_comment

begin_function
specifier|static
name|struct
name|link
modifier|*
name|acpi_pci_link_lookup
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|source_index
parameter_list|)
block|{
name|struct
name|acpi_pci_link_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|pl_num_links
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_res_index
operator|==
name|source_index
condition|)
return|return
operator|(
operator|&
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|acpi_pci_link_add_reference
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|index
parameter_list|,
name|device_t
name|pcib
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|struct
name|link
modifier|*
name|link
decl_stmt|;
name|uint8_t
name|bios_irq
decl_stmt|;
name|uintptr_t
name|bus
decl_stmt|;
comment|/* 	 * Look up the PCI bus for the specified PCI bridge device.  Note 	 * that the PCI bridge device might not have any children yet. 	 * However, looking up its bus number doesn't require a valid child 	 * device, so we just pass NULL. 	 */
if|if
condition|(
name|BUS_READ_IVAR
argument_list|(
name|pcib
argument_list|,
name|NULL
argument_list|,
name|PCIB_IVAR_BUS
argument_list|,
operator|&
name|bus
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pcib
argument_list|,
literal|"Unable to read PCI bus number"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"PCI bridge without a bus number"
argument_list|)
expr_stmt|;
block|}
comment|/* Bump the reference count. */
name|ACPI_SERIAL_BEGIN
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
name|link
operator|=
name|acpi_pci_link_lookup
argument_list|(
name|dev
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"apparently invalid index %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_END
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
return|return;
block|}
name|link
operator|->
name|l_references
operator|++
expr_stmt|;
if|if
condition|(
name|link
operator|->
name|l_routed
condition|)
name|pci_link_interrupt_weights
index|[
name|link
operator|->
name|l_irq
index|]
operator|++
expr_stmt|;
comment|/* 	 * The BIOS only routes interrupts via ISA IRQs using the ATPICs 	 * (8259As).  Thus, if this link is routed via an ISA IRQ, go 	 * look to see if the BIOS routed an IRQ for this link at the 	 * indicated (bus, slot, pin).  If so, we prefer that IRQ for 	 * this link and add that IRQ to our list of known-good IRQs. 	 * This provides a good work-around for link devices whose _CRS 	 * method is either broken or bogus.  We only use the value 	 * returned by _CRS if we can't find a valid IRQ via this method 	 * in fact. 	 * 	 * If this link is not routed via an ISA IRQ (because we are using 	 * APIC for example), then don't bother looking up the BIOS IRQ 	 * as if we find one it won't be valid anyway. 	 */
if|if
condition|(
operator|!
name|link
operator|->
name|l_isa_irq
condition|)
block|{
name|ACPI_SERIAL_END
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try to find a BIOS IRQ setting from any matching devices. */
name|bios_irq
operator|=
name|acpi_pci_link_search_irq
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|,
name|pin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|bios_irq
argument_list|)
condition|)
block|{
name|ACPI_SERIAL_END
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Validate the BIOS IRQ. */
if|if
condition|(
operator|!
name|link_valid_irq
argument_list|(
name|link
argument_list|,
name|bios_irq
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"BIOS IRQ %u for %d.%d.INT%c is invalid\n"
argument_list|,
name|bios_irq
argument_list|,
operator|(
name|int
operator|)
name|bus
argument_list|,
name|slot
argument_list|,
name|pin
operator|+
literal|'A'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|link
operator|->
name|l_bios_irq
argument_list|)
condition|)
block|{
name|link
operator|->
name|l_bios_irq
operator|=
name|bios_irq
expr_stmt|;
if|if
condition|(
name|bios_irq
operator|<
name|NUM_ISA_INTERRUPTS
condition|)
name|pci_link_bios_isa_irqs
operator||=
operator|(
literal|1
operator|<<
name|bios_irq
operator|)
expr_stmt|;
if|if
condition|(
name|bios_irq
operator|!=
name|link
operator|->
name|l_initial_irq
operator|&&
name|PCI_INTERRUPT_VALID
argument_list|(
name|link
operator|->
name|l_initial_irq
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"BIOS IRQ %u does not match initial IRQ %u\n"
argument_list|,
name|bios_irq
argument_list|,
name|link
operator|->
name|l_initial_irq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bios_irq
operator|!=
name|link
operator|->
name|l_bios_irq
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"BIOS IRQ %u for %d.%d.INT%c does not match previous BIOS IRQ %u\n"
argument_list|,
name|bios_irq
argument_list|,
operator|(
name|int
operator|)
name|bus
argument_list|,
name|slot
argument_list|,
name|pin
operator|+
literal|'A'
argument_list|,
name|link
operator|->
name|l_bios_irq
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_END
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_pci_link_srs_from_crs
parameter_list|(
name|struct
name|acpi_pci_link_softc
modifier|*
name|sc
parameter_list|,
name|ACPI_BUFFER
modifier|*
name|srsbuf
parameter_list|)
block|{
name|ACPI_RESOURCE
modifier|*
name|end
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|struct
name|link
modifier|*
name|link
decl_stmt|;
name|int
name|i
decl_stmt|,
name|in_dpf
decl_stmt|;
comment|/* Fetch the _CRS. */
name|ACPI_SERIAL_ASSERT
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
name|srsbuf
operator|->
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|srsbuf
operator|->
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|status
operator|=
name|AcpiGetCurrentResources
argument_list|(
name|acpi_get_handle
argument_list|(
name|sc
operator|->
name|pl_dev
argument_list|)
argument_list|,
name|srsbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
operator|&&
name|srsbuf
operator|->
name|Pointer
operator|==
name|NULL
condition|)
name|status
operator|=
name|AE_NO_MEMORY
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|pl_dev
argument_list|,
literal|"Unable to fetch current resources: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* Fill in IRQ resources via link structures. */
name|link
operator|=
name|sc
operator|->
name|pl_links
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|in_dpf
operator|=
name|DPF_OUTSIDE
expr_stmt|;
name|res
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
name|srsbuf
operator|->
name|Pointer
expr_stmt|;
name|end
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|srsbuf
operator|->
name|Pointer
operator|+
name|srsbuf
operator|->
name|Length
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|res
operator|->
name|Type
condition|)
block|{
case|case
name|ACPI_RESOURCE_TYPE_START_DEPENDENT
case|:
switch|switch
condition|(
name|in_dpf
condition|)
block|{
case|case
name|DPF_OUTSIDE
case|:
comment|/* We've started the first DPF. */
name|in_dpf
operator|=
name|DPF_FIRST
expr_stmt|;
break|break;
case|case
name|DPF_FIRST
case|:
comment|/* We've started the second DPF. */
name|panic
argument_list|(
literal|"%s: Multiple dependent functions within a current resource"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ACPI_RESOURCE_TYPE_END_DEPENDENT
case|:
comment|/* We are finished with DPF parsing. */
name|KASSERT
argument_list|(
name|in_dpf
operator|!=
name|DPF_OUTSIDE
argument_list|,
operator|(
literal|"%s: end dpf when not parsing a dpf"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|in_dpf
operator|=
name|DPF_OUTSIDE
expr_stmt|;
break|break;
case|case
name|ACPI_RESOURCE_TYPE_IRQ
case|:
name|MPASS
argument_list|(
name|i
operator|<
name|sc
operator|->
name|pl_num_links
argument_list|)
expr_stmt|;
name|res
operator|->
name|Data
operator|.
name|Irq
operator|.
name|InterruptCount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|link
operator|->
name|l_irq
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|link
operator|->
name|l_irq
operator|<
name|NUM_ISA_INTERRUPTS
argument_list|,
operator|(
literal|"%s: can't put non-ISA IRQ %d in legacy IRQ resource type"
operator|,
name|__func__
operator|,
name|link
operator|->
name|l_irq
operator|)
argument_list|)
expr_stmt|;
name|res
operator|->
name|Data
operator|.
name|Irq
operator|.
name|Interrupts
index|[
literal|0
index|]
operator|=
name|link
operator|->
name|l_irq
expr_stmt|;
block|}
else|else
name|res
operator|->
name|Data
operator|.
name|Irq
operator|.
name|Interrupts
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|link
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
case|case
name|ACPI_RESOURCE_TYPE_EXTENDED_IRQ
case|:
name|MPASS
argument_list|(
name|i
operator|<
name|sc
operator|->
name|pl_num_links
argument_list|)
expr_stmt|;
name|res
operator|->
name|Data
operator|.
name|ExtendedIrq
operator|.
name|InterruptCount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|link
operator|->
name|l_irq
argument_list|)
condition|)
name|res
operator|->
name|Data
operator|.
name|ExtendedIrq
operator|.
name|Interrupts
index|[
literal|0
index|]
operator|=
name|link
operator|->
name|l_irq
expr_stmt|;
else|else
name|res
operator|->
name|Data
operator|.
name|ExtendedIrq
operator|.
name|Interrupts
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|link
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|res
operator|->
name|Type
operator|==
name|ACPI_RESOURCE_TYPE_END_TAG
condition|)
break|break;
name|res
operator|=
name|ACPI_NEXT_RESOURCE
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|>=
name|end
condition|)
break|break;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_pci_link_srs_from_links
parameter_list|(
name|struct
name|acpi_pci_link_softc
modifier|*
name|sc
parameter_list|,
name|ACPI_BUFFER
modifier|*
name|srsbuf
parameter_list|)
block|{
name|ACPI_RESOURCE
name|newres
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|struct
name|link
modifier|*
name|link
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Start off with an empty buffer. */
name|srsbuf
operator|->
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|link
operator|=
name|sc
operator|->
name|pl_links
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|pl_num_links
condition|;
name|i
operator|++
control|)
block|{
comment|/* Add a new IRQ resource from each link. */
name|link
operator|=
operator|&
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|link
operator|->
name|l_prs_template
operator|.
name|Type
operator|==
name|ACPI_RESOURCE_TYPE_IRQ
condition|)
block|{
comment|/* Build an IRQ resource. */
name|bcopy
argument_list|(
operator|&
name|link
operator|->
name|l_prs_template
argument_list|,
operator|&
name|newres
argument_list|,
name|ACPI_RS_SIZE
argument_list|(
name|newres
operator|.
name|Data
operator|.
name|Irq
argument_list|)
argument_list|)
expr_stmt|;
name|newres
operator|.
name|Data
operator|.
name|Irq
operator|.
name|InterruptCount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|link
operator|->
name|l_irq
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|link
operator|->
name|l_irq
operator|<
name|NUM_ISA_INTERRUPTS
argument_list|,
operator|(
literal|"%s: can't put non-ISA IRQ %d in legacy IRQ resource type"
operator|,
name|__func__
operator|,
name|link
operator|->
name|l_irq
operator|)
argument_list|)
expr_stmt|;
name|newres
operator|.
name|Data
operator|.
name|Irq
operator|.
name|Interrupts
index|[
literal|0
index|]
operator|=
name|link
operator|->
name|l_irq
expr_stmt|;
block|}
else|else
name|newres
operator|.
name|Data
operator|.
name|Irq
operator|.
name|Interrupts
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Build an ExtIRQ resuorce. */
name|bcopy
argument_list|(
operator|&
name|link
operator|->
name|l_prs_template
argument_list|,
operator|&
name|newres
argument_list|,
name|ACPI_RS_SIZE
argument_list|(
name|newres
operator|.
name|Data
operator|.
name|ExtendedIrq
argument_list|)
argument_list|)
expr_stmt|;
name|newres
operator|.
name|Data
operator|.
name|ExtendedIrq
operator|.
name|InterruptCount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|link
operator|->
name|l_irq
argument_list|)
condition|)
name|newres
operator|.
name|Data
operator|.
name|ExtendedIrq
operator|.
name|Interrupts
index|[
literal|0
index|]
operator|=
name|link
operator|->
name|l_irq
expr_stmt|;
else|else
name|newres
operator|.
name|Data
operator|.
name|ExtendedIrq
operator|.
name|Interrupts
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Add the new resource to the end of the _SRS buffer. */
name|status
operator|=
name|acpi_AppendBufferResource
argument_list|(
name|srsbuf
argument_list|,
operator|&
name|newres
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|pl_dev
argument_list|,
literal|"Unable to build resources: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|srsbuf
operator|->
name|Pointer
operator|!=
name|NULL
condition|)
name|AcpiOsFree
argument_list|(
name|srsbuf
operator|->
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|acpi_pci_link_route_irqs
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_pci_link_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_RESOURCE
modifier|*
name|resource
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|ACPI_BUFFER
name|srsbuf
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|struct
name|link
modifier|*
name|link
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pl_crs_bad
condition|)
name|status
operator|=
name|acpi_pci_link_srs_from_links
argument_list|(
name|sc
argument_list|,
operator|&
name|srsbuf
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|acpi_pci_link_srs_from_crs
argument_list|(
name|sc
argument_list|,
operator|&
name|srsbuf
argument_list|)
expr_stmt|;
comment|/* Write out new resources via _SRS. */
name|status
operator|=
name|AcpiSetCurrentResources
argument_list|(
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|srsbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to route IRQs: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|srsbuf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* 	 * Perform acpi_config_intr() on each IRQ resource if it was just 	 * routed for the first time. 	 */
name|link
operator|=
name|sc
operator|->
name|pl_links
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|resource
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
name|srsbuf
operator|.
name|Pointer
expr_stmt|;
name|end
operator|=
operator|(
name|ACPI_RESOURCE
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|srsbuf
operator|.
name|Pointer
operator|+
name|srsbuf
operator|.
name|Length
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|resource
operator|->
name|Type
operator|==
name|ACPI_RESOURCE_TYPE_END_TAG
condition|)
break|break;
switch|switch
condition|(
name|resource
operator|->
name|Type
condition|)
block|{
case|case
name|ACPI_RESOURCE_TYPE_IRQ
case|:
case|case
name|ACPI_RESOURCE_TYPE_EXTENDED_IRQ
case|:
name|MPASS
argument_list|(
name|i
operator|<
name|sc
operator|->
name|pl_num_links
argument_list|)
expr_stmt|;
comment|/* 			 * Only configure the interrupt and update the 			 * weights if this link has a valid IRQ and was 			 * previously unrouted. 			 */
if|if
condition|(
operator|!
name|link
operator|->
name|l_routed
operator|&&
name|PCI_INTERRUPT_VALID
argument_list|(
name|link
operator|->
name|l_irq
argument_list|)
condition|)
block|{
name|link
operator|->
name|l_routed
operator|=
name|TRUE
expr_stmt|;
name|acpi_config_intr
argument_list|(
name|dev
argument_list|,
name|resource
argument_list|)
expr_stmt|;
name|pci_link_interrupt_weights
index|[
name|link
operator|->
name|l_irq
index|]
operator|+=
name|link
operator|->
name|l_references
expr_stmt|;
block|}
name|link
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
block|}
name|resource
operator|=
name|ACPI_NEXT_RESOURCE
argument_list|(
name|resource
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource
operator|>=
name|end
condition|)
break|break;
block|}
name|AcpiOsFree
argument_list|(
name|srsbuf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_pci_link_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_pci_link_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|i
decl_stmt|,
name|routed
decl_stmt|;
comment|/* 	 * If all of our links are routed, then restore the link via _SRS, 	 * otherwise, disable the link via _DIS. 	 */
name|ACPI_SERIAL_BEGIN
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|routed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|pl_num_links
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|pl_links
index|[
name|i
index|]
operator|.
name|l_routed
condition|)
name|routed
operator|++
expr_stmt|;
if|if
condition|(
name|routed
operator|==
name|sc
operator|->
name|pl_num_links
condition|)
name|status
operator|=
name|acpi_pci_link_route_irqs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|else
block|{
name|AcpiEvaluateObject
argument_list|(
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"_DIS"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|status
operator|=
name|AE_OK
expr_stmt|;
block|}
name|ACPI_SERIAL_END
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pick an IRQ to use for this unrouted link.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|acpi_pci_link_choose_irq
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|link
modifier|*
name|link
parameter_list|)
block|{
name|char
name|tunable_buffer
index|[
literal|64
index|]
decl_stmt|,
name|link_name
index|[
literal|5
index|]
decl_stmt|;
name|u_int8_t
name|best_irq
decl_stmt|,
name|pos_irq
decl_stmt|;
name|int
name|best_weight
decl_stmt|,
name|pos_weight
decl_stmt|,
name|i
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|link
operator|->
name|l_routed
argument_list|,
operator|(
literal|"%s: link already routed"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|link
operator|->
name|l_irq
argument_list|)
argument_list|,
operator|(
literal|"%s: link already has an IRQ"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Check for a tunable override. */
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|acpi_short_name
argument_list|(
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
argument_list|,
name|link_name
argument_list|,
sizeof|sizeof
argument_list|(
name|link_name
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|tunable_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|tunable_buffer
argument_list|)
argument_list|,
literal|"hw.pci.link.%s.%d.irq"
argument_list|,
name|link_name
argument_list|,
name|link
operator|->
name|l_res_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv_int
argument_list|(
name|tunable_buffer
argument_list|,
operator|&
name|i
argument_list|)
operator|&&
name|PCI_INTERRUPT_VALID
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|link_valid_irq
argument_list|(
name|link
argument_list|,
name|i
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Warning, IRQ %d is not listed as valid\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|tunable_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|tunable_buffer
argument_list|)
argument_list|,
literal|"hw.pci.link.%s.irq"
argument_list|,
name|link_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv_int
argument_list|(
name|tunable_buffer
argument_list|,
operator|&
name|i
argument_list|)
operator|&&
name|PCI_INTERRUPT_VALID
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|link_valid_irq
argument_list|(
name|link
argument_list|,
name|i
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Warning, IRQ %d is not listed as valid\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
comment|/* 	 * If we have a valid BIOS IRQ, use that.  We trust what the BIOS 	 * says it routed over what _CRS says the link thinks is routed. 	 */
if|if
condition|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|link
operator|->
name|l_bios_irq
argument_list|)
condition|)
return|return
operator|(
name|link
operator|->
name|l_bios_irq
operator|)
return|;
comment|/* 	 * If we don't have a BIOS IRQ but do have a valid IRQ from _CRS, 	 * then use that. 	 */
if|if
condition|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|link
operator|->
name|l_initial_irq
argument_list|)
condition|)
return|return
operator|(
name|link
operator|->
name|l_initial_irq
operator|)
return|;
comment|/* 	 * Ok, we have no useful hints, so we have to pick from the 	 * possible IRQs.  For ISA IRQs we only use interrupts that 	 * have already been used by the BIOS. 	 */
name|best_irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
name|best_weight
operator|=
name|INT_MAX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|link
operator|->
name|l_num_irqs
condition|;
name|i
operator|++
control|)
block|{
name|pos_irq
operator|=
name|link
operator|->
name|l_irqs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pos_irq
operator|<
name|NUM_ISA_INTERRUPTS
operator|&&
operator|(
name|pci_link_bios_isa_irqs
operator|&
literal|1
operator|<<
name|pos_irq
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|pos_weight
operator|=
name|pci_link_interrupt_weights
index|[
name|pos_irq
index|]
expr_stmt|;
if|if
condition|(
name|pos_weight
operator|<
name|best_weight
condition|)
block|{
name|best_weight
operator|=
name|pos_weight
expr_stmt|;
name|best_irq
operator|=
name|pos_irq
expr_stmt|;
block|}
block|}
comment|/* 	 * If this is an ISA IRQ, try using the SCI if it is also an ISA 	 * interrupt as a fallback. 	 */
if|if
condition|(
name|link
operator|->
name|l_isa_irq
condition|)
block|{
name|pos_irq
operator|=
name|AcpiGbl_FADT
operator|.
name|SciInterrupt
expr_stmt|;
name|pos_weight
operator|=
name|pci_link_interrupt_weights
index|[
name|pos_irq
index|]
expr_stmt|;
if|if
condition|(
name|pos_weight
operator|<
name|best_weight
condition|)
block|{
name|best_weight
operator|=
name|pos_weight
expr_stmt|;
name|best_irq
operator|=
name|pos_irq
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|best_irq
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Picked IRQ %u with weight %d\n"
argument_list|,
name|best_irq
argument_list|,
name|best_weight
argument_list|)
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to choose an IRQ\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|best_irq
operator|)
return|;
block|}
end_function

begin_function
name|int
name|acpi_pci_link_route_interrupt
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|link
modifier|*
name|link
decl_stmt|;
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"pci_link"
argument_list|)
condition|)
return|return
operator|(
name|PCI_INVALID_IRQ
operator|)
return|;
name|ACPI_SERIAL_BEGIN
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
name|link
operator|=
name|acpi_pci_link_lookup
argument_list|(
name|dev
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: apparently invalid index %d"
argument_list|,
name|__func__
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* 	 * If this link device is already routed to an interrupt, just return 	 * the interrupt it is routed to. 	 */
if|if
condition|(
name|link
operator|->
name|l_routed
condition|)
block|{
name|KASSERT
argument_list|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|link
operator|->
name|l_irq
argument_list|)
argument_list|,
operator|(
literal|"%s: link is routed but has an invalid IRQ"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_END
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
return|return
operator|(
name|link
operator|->
name|l_irq
operator|)
return|;
block|}
comment|/* Choose an IRQ if we need one. */
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|link
operator|->
name|l_irq
argument_list|)
condition|)
block|{
name|link
operator|->
name|l_irq
operator|=
name|acpi_pci_link_choose_irq
argument_list|(
name|dev
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 		 * Try to route the interrupt we picked.  If it fails, then 		 * assume the interrupt is not routed. 		 */
if|if
condition|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|link
operator|->
name|l_irq
argument_list|)
condition|)
block|{
name|acpi_pci_link_route_irqs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link
operator|->
name|l_routed
condition|)
name|link
operator|->
name|l_irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
block|}
block|}
name|ACPI_SERIAL_END
argument_list|(
name|pci_link
argument_list|)
expr_stmt|;
return|return
operator|(
name|link
operator|->
name|l_irq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is gross, but we abuse the identify routine to perform one-time  * SYSINIT() style initialization for the driver.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_pci_link_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
comment|/* 	 * If the SCI is an ISA IRQ, add it to the bitmask of known good 	 * ISA IRQs. 	 * 	 * XXX: If we are using the APIC, the SCI might have been 	 * rerouted to an APIC pin in which case this is invalid.  However, 	 * if we are using the APIC, we also shouldn't be having any PCI 	 * interrupts routed via ISA IRQs, so this is probably ok. 	 */
if|if
condition|(
name|AcpiGbl_FADT
operator|.
name|SciInterrupt
operator|<
name|NUM_ISA_INTERRUPTS
condition|)
name|pci_link_bios_isa_irqs
operator||=
operator|(
literal|1
operator|<<
name|AcpiGbl_FADT
operator|.
name|SciInterrupt
operator|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|acpi_pci_link_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|acpi_pci_link_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|acpi_pci_link_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|acpi_pci_link_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|acpi_pci_link_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|acpi_pci_link_driver
init|=
block|{
literal|"pci_link"
block|,
name|acpi_pci_link_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_pci_link_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|pci_link_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|acpi_pci_link
argument_list|,
name|acpi
argument_list|,
name|acpi_pci_link_driver
argument_list|,
name|pci_link_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|acpi_pci_link
argument_list|,
name|acpi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

