begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Nate Lawson  * Copyright (c) 2000 Michael Smith  * Copyright (c) 2000 BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  ******************************************************************************  *  * 1. Copyright Notice  *  * Some or all of this work - Copyright (c) 1999, Intel Corp.  All rights  * reserved.  *  * 2. License  *  * 2.1. This is your license from Intel Corp. under its intellectual property  * rights.  You may have additional license terms from the party that provided  * you this software, covering your right to use that party's intellectual  * property rights.  *  * 2.2. Intel grants, free of charge, to any person ("Licensee") obtaining a  * copy of the source code appearing in this file ("Covered Code") an  * irrevocable, perpetual, worldwide license under Intel's copyrights in the  * base code distributed originally by Intel ("Original Intel Code") to copy,  * make derivatives, distribute, use and display any portion of the Covered  * Code in any form, with the right to sublicense such rights; and  *  * 2.3. Intel grants Licensee a non-exclusive and non-transferable patent  * license (with the right to sublicense), under only those claims of Intel  * patents that are infringed by the Original Intel Code, to make, use, sell,  * offer to sell, and import the Covered Code and derivative works thereof  * solely to the minimum extent necessary to exercise the above copyright  * license, and in no event shall the patent license extend to any additions  * to or modifications of the Original Intel Code.  No other license or right  * is granted directly or by implication, estoppel or otherwise;  *  * The above copyright and patent license is granted only if the following  * conditions are met:  *  * 3. Conditions   *  * 3.1. Redistribution of Source with Rights to Further Distribute Source.    * Redistribution of source code of any substantial portion of the Covered  * Code or modification with rights to further distribute source must include  * the above Copyright Notice, the above License, this list of Conditions,  * and the following Disclaimer and Export Compliance provision.  In addition,  * Licensee must cause all Covered Code to which Licensee contributes to  * contain a file documenting the changes Licensee made to create that Covered  * Code and the date of any change.  Licensee must include in that file the  * documentation of any changes made by any predecessor Licensee.  Licensee   * must include a prominent statement that the modification is derived,  * directly or indirectly, from Original Intel Code.  *  * 3.2. Redistribution of Source with no Rights to Further Distribute Source.    * Redistribution of source code of any substantial portion of the Covered  * Code or modification without rights to further distribute source must  * include the following Disclaimer and Export Compliance provision in the  * documentation and/or other materials provided with distribution.  In  * addition, Licensee may not authorize further sublicense of source of any  * portion of the Covered Code, and must include terms to the effect that the  * license from Licensee to its licensee is limited to the intellectual  * property embodied in the software Licensee provides to its licensee, and  * not to intellectual property embodied in modifications its licensee may  * make.  *  * 3.3. Redistribution of Executable. Redistribution in executable form of any  * substantial portion of the Covered Code or modification must reproduce the  * above Copyright Notice, and the following Disclaimer and Export Compliance  * provision in the documentation and/or other materials provided with the  * distribution.  *  * 3.4. Intel retains all right, title, and interest in and to the Original  * Intel Code.  *  * 3.5. Neither the name Intel nor any other trademark owned or controlled by  * Intel shall be used in advertising or otherwise to promote the sale, use or  * other dealings in products derived from or relating to the Covered Code  * without prior written authorization from Intel.  *  * 4. Disclaimer and Export Compliance  *  * 4.1. INTEL MAKES NO WARRANTY OF ANY KIND REGARDING ANY SOFTWARE PROVIDED  * HERE.  ANY SOFTWARE ORIGINATING FROM INTEL OR DERIVED FROM INTEL SOFTWARE  * IS PROVIDED "AS IS," AND INTEL WILL NOT PROVIDE ANY SUPPORT,  ASSISTANCE,  * INSTALLATION, TRAINING OR OTHER SERVICES.  INTEL WILL NOT PROVIDE ANY  * UPDATES, ENHANCEMENTS OR EXTENSIONS.  INTEL SPECIFICALLY DISCLAIMS ANY  * IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT AND FITNESS FOR A  * PARTICULAR PURPOSE.   *  * 4.2. IN NO EVENT SHALL INTEL HAVE ANY LIABILITY TO LICENSEE, ITS LICENSEES  * OR ANY OTHER THIRD PARTY, FOR ANY LOST PROFITS, LOST DATA, LOSS OF USE OR  * COSTS OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, OR FOR ANY INDIRECT,  * SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THIS AGREEMENT, UNDER ANY  * CAUSE OF ACTION OR THEORY OF LIABILITY, AND IRRESPECTIVE OF WHETHER INTEL  * HAS ADVANCE NOTICE OF THE POSSIBILITY OF SUCH DAMAGES.  THESE LIMITATIONS  * SHALL APPLY NOTWITHSTANDING THE FAILURE OF THE ESSENTIAL PURPOSE OF ANY  * LIMITED REMEDY.  *  * 4.3. Licensee shall not export, either directly or indirectly, any of this  * software or system incorporating such software without first obtaining any  * required license or other approval from the U. S. Department of Commerce or  * any other agency or department of the United States Government.  In the  * event Licensee exports any such software from the United States or  * re-exports any such software from a foreign destination, Licensee shall  * ensure that the distribution and export/re-export of the software is in  * compliance with all laws, regulations, orders, or other restrictions of the  * U.S. Export Administration Regulations. Licensee agrees that neither it nor  * any of its subsidiaries will export/re-export any technical data, process,  * software, or service, directly or indirectly, to any country for which the  * United States government or any agency thereof requires an export license,  * other governmental approval, or letter of assurance, without first obtaining  * such license, approval or letter.  *  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/acpi.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_comment
comment|/* Hooks for the ACPI CA debugging infrastructure */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_EC
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"EC"
argument_list|)
end_macro

begin_comment
comment|/*  * EC_COMMAND:  * -----------  */
end_comment

begin_typedef
typedef|typedef
name|UINT8
name|EC_COMMAND
typedef|;
end_typedef

begin_define
define|#
directive|define
name|EC_COMMAND_UNKNOWN
value|((EC_COMMAND) 0x00)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_READ
value|((EC_COMMAND) 0x80)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_WRITE
value|((EC_COMMAND) 0x81)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_BURST_ENABLE
value|((EC_COMMAND) 0x82)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_BURST_DISABLE
value|((EC_COMMAND) 0x83)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_QUERY
value|((EC_COMMAND) 0x84)
end_define

begin_comment
comment|/*   * EC_STATUS:  * ----------  * The encoding of the EC status register is illustrated below.  * Note that a set bit (1) indicates the property is TRUE  * (e.g. if bit 0 is set then the output buffer is full).  * +-+-+-+-+-+-+-+-+  * |7|6|5|4|3|2|1|0|  * +-+-+-+-+-+-+-+-+  *  | | | | | | | |  *  | | | | | | | +- Output Buffer Full?  *  | | | | | | +--- Input Buffer Full?  *  | | | | | +-----<reserved>  *  | | | | +------- Data Register is Command Byte?  *  | | | +--------- Burst Mode Enabled?  *  | | +----------- SCI Event?  *  | +------------- SMI Event?  *  +---------------<reserved>  *  */
end_comment

begin_typedef
typedef|typedef
name|UINT8
name|EC_STATUS
typedef|;
end_typedef

begin_define
define|#
directive|define
name|EC_FLAG_OUTPUT_BUFFER
value|((EC_STATUS) 0x01)
end_define

begin_define
define|#
directive|define
name|EC_FLAG_INPUT_BUFFER
value|((EC_STATUS) 0x02)
end_define

begin_define
define|#
directive|define
name|EC_FLAG_DATA_IS_CMD
value|((EC_STATUS) 0x08)
end_define

begin_define
define|#
directive|define
name|EC_FLAG_BURST_MODE
value|((EC_STATUS) 0x10)
end_define

begin_comment
comment|/*  * EC_EVENT:  * ---------  */
end_comment

begin_typedef
typedef|typedef
name|UINT8
name|EC_EVENT
typedef|;
end_typedef

begin_define
define|#
directive|define
name|EC_EVENT_UNKNOWN
value|((EC_EVENT) 0x00)
end_define

begin_define
define|#
directive|define
name|EC_EVENT_OUTPUT_BUFFER_FULL
value|((EC_EVENT) 0x01)
end_define

begin_define
define|#
directive|define
name|EC_EVENT_INPUT_BUFFER_EMPTY
value|((EC_EVENT) 0x02)
end_define

begin_define
define|#
directive|define
name|EC_EVENT_SCI
value|((EC_EVENT) 0x20)
end_define

begin_define
define|#
directive|define
name|EC_EVENT_SMI
value|((EC_EVENT) 0x40)
end_define

begin_comment
comment|/* Data byte returned after burst enable indicating it was successful. */
end_comment

begin_define
define|#
directive|define
name|EC_BURST_ACK
value|0x90
end_define

begin_comment
comment|/*  * Register access primitives  */
end_comment

begin_define
define|#
directive|define
name|EC_GET_DATA
parameter_list|(
name|sc
parameter_list|)
define|\
value|bus_space_read_1((sc)->ec_data_tag, (sc)->ec_data_handle, 0)
end_define

begin_define
define|#
directive|define
name|EC_SET_DATA
parameter_list|(
name|sc
parameter_list|,
name|v
parameter_list|)
define|\
value|bus_space_write_1((sc)->ec_data_tag, (sc)->ec_data_handle, 0, (v))
end_define

begin_define
define|#
directive|define
name|EC_GET_CSR
parameter_list|(
name|sc
parameter_list|)
define|\
value|bus_space_read_1((sc)->ec_csr_tag, (sc)->ec_csr_handle, 0)
end_define

begin_define
define|#
directive|define
name|EC_SET_CSR
parameter_list|(
name|sc
parameter_list|,
name|v
parameter_list|)
define|\
value|bus_space_write_1((sc)->ec_csr_tag, (sc)->ec_csr_handle, 0, (v))
end_define

begin_comment
comment|/* Embedded Controller Boot Resources Table (ECDT) */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|ACPI_TABLE_HEADER
name|header
decl_stmt|;
name|ACPI_GENERIC_ADDRESS
name|control
decl_stmt|;
name|ACPI_GENERIC_ADDRESS
name|data
decl_stmt|;
name|UINT32
name|uid
decl_stmt|;
name|UINT8
name|gpe_bit
decl_stmt|;
name|char
name|ec_id
index|[
literal|0
index|]
decl_stmt|;
block|}
name|ACPI_TABLE_ECDT
typedef|;
end_typedef

begin_comment
comment|/* Additional params to pass from the probe routine */
end_comment

begin_struct
struct|struct
name|acpi_ec_params
block|{
name|int
name|glk
decl_stmt|;
name|int
name|gpe_bit
decl_stmt|;
name|ACPI_HANDLE
name|gpe_handle
decl_stmt|;
name|int
name|uid
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Indicate that this device has already been probed via ECDT. */
end_comment

begin_define
define|#
directive|define
name|DEV_ECDT
parameter_list|(
name|x
parameter_list|)
value|(acpi_get_magic(x) == (int)&acpi_ec_devclass)
end_define

begin_comment
comment|/*  * Driver softc.  */
end_comment

begin_struct
struct|struct
name|acpi_ec_softc
block|{
name|device_t
name|ec_dev
decl_stmt|;
name|ACPI_HANDLE
name|ec_handle
decl_stmt|;
name|int
name|ec_uid
decl_stmt|;
name|ACPI_HANDLE
name|ec_gpehandle
decl_stmt|;
name|UINT8
name|ec_gpebit
decl_stmt|;
name|UINT8
name|ec_csrvalue
decl_stmt|;
name|int
name|ec_data_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|ec_data_res
decl_stmt|;
name|bus_space_tag_t
name|ec_data_tag
decl_stmt|;
name|bus_space_handle_t
name|ec_data_handle
decl_stmt|;
name|int
name|ec_csr_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|ec_csr_res
decl_stmt|;
name|bus_space_tag_t
name|ec_csr_tag
decl_stmt|;
name|bus_space_handle_t
name|ec_csr_handle
decl_stmt|;
name|struct
name|mtx
name|ec_mtx
decl_stmt|;
name|int
name|ec_glk
decl_stmt|;
name|int
name|ec_glkhandle
decl_stmt|;
name|int
name|ec_burstactive
decl_stmt|;
name|int
name|ec_sci_pend
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * XXX njl  * I couldn't find it in the spec but other implementations also use a  * value of 1 ms for the time to acquire global lock.  */
end_comment

begin_define
define|#
directive|define
name|EC_LOCK_TIMEOUT
value|1000
end_define

begin_comment
comment|/* Default delay in microseconds between each run of the status polling loop. */
end_comment

begin_define
define|#
directive|define
name|EC_POLL_DELAY
value|10
end_define

begin_comment
comment|/* Default time in microseconds spent polling before sleep waiting. */
end_comment

begin_define
define|#
directive|define
name|EC_POLL_TIME
value|500
end_define

begin_comment
comment|/* Total time in ms spent waiting for a response from EC. */
end_comment

begin_define
define|#
directive|define
name|EC_TIMEOUT
value|500
end_define

begin_define
define|#
directive|define
name|EVENT_READY
parameter_list|(
name|event
parameter_list|,
name|status
parameter_list|)
define|\
value|(((event) == EC_EVENT_OUTPUT_BUFFER_FULL&&	\ 	 ((status)& EC_FLAG_OUTPUT_BUFFER) != 0) ||	\ 	 ((event) == EC_EVENT_INPUT_BUFFER_EMPTY&& 	\ 	 ((status)& EC_FLAG_INPUT_BUFFER) == 0))
end_define

begin_expr_stmt
name|ACPI_SERIAL_DECL
argument_list|(
name|ec
argument_list|,
literal|"ACPI embedded controller"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_debug_acpi
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug_acpi
argument_list|,
name|OID_AUTO
argument_list|,
name|ec
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"EC debugging"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ec_burst_mode
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.acpi.ec.burst"
argument_list|,
operator|&
name|ec_burst_mode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_acpi_ec
argument_list|,
name|OID_AUTO
argument_list|,
name|burst
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ec_burst_mode
argument_list|,
name|TRUE
argument_list|,
literal|"Enable use of burst mode (faster for nearly all systems)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ec_poll_time
init|=
name|EC_POLL_TIME
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.acpi.ec.poll_time"
argument_list|,
operator|&
name|ec_poll_time
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_acpi_ec
argument_list|,
name|OID_AUTO
argument_list|,
name|poll_time
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ec_poll_time
argument_list|,
name|EC_POLL_TIME
argument_list|,
literal|"Time spent polling vs. sleeping (CPU intensive)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ec_timeout
init|=
name|EC_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.acpi.ec.timeout"
argument_list|,
operator|&
name|ec_timeout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_acpi_ec
argument_list|,
name|OID_AUTO
argument_list|,
name|timeout
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ec_timeout
argument_list|,
name|EC_TIMEOUT
argument_list|,
literal|"Total time spent waiting for a response (poll+sleep)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|__inline
name|ACPI_STATUS
name|EcLock
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|int
name|serialize
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
comment|/*      * If caller is executing a series of commands, acquire the exclusive lock      * to serialize with other users.      * To sync with bottom-half interrupt handler, always acquire the mutex.      */
name|status
operator|=
name|AE_OK
expr_stmt|;
if|if
condition|(
name|serialize
condition|)
name|ACPI_SERIAL_BEGIN
argument_list|(
name|ec
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|ec_mtx
argument_list|)
expr_stmt|;
comment|/* If _GLK is non-zero, also acquire the global lock. */
if|if
condition|(
name|sc
operator|->
name|ec_glk
condition|)
block|{
name|status
operator|=
name|AcpiAcquireGlobalLock
argument_list|(
name|EC_LOCK_TIMEOUT
argument_list|,
operator|&
name|sc
operator|->
name|ec_glkhandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|ec_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|serialize
condition|)
name|ACPI_SERIAL_END
argument_list|(
name|ec
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|EcUnlock
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|ec_glk
condition|)
name|AcpiReleaseGlobalLock
argument_list|(
name|sc
operator|->
name|ec_glkhandle
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|ec_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx_xlocked
argument_list|(
operator|&
name|ec_sxlock
argument_list|)
condition|)
name|ACPI_SERIAL_END
argument_list|(
name|ec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|uint32_t
name|EcGpeHandler
parameter_list|(
name|void
modifier|*
name|Context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcSpaceSetup
parameter_list|(
name|ACPI_HANDLE
name|Region
parameter_list|,
name|UINT32
name|Function
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|return_Context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcSpaceHandler
parameter_list|(
name|UINT32
name|Function
parameter_list|,
name|ACPI_PHYSICAL_ADDRESS
name|Address
parameter_list|,
name|UINT32
name|width
parameter_list|,
name|ACPI_INTEGER
modifier|*
name|Value
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
name|RegionContext
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcWaitEvent
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|EC_EVENT
name|Event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcCommand
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|EC_COMMAND
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcRead
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|UINT8
name|Address
parameter_list|,
name|UINT8
modifier|*
name|Data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcWrite
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|UINT8
name|Address
parameter_list|,
name|UINT8
modifier|*
name|Data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_ec_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_ec_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_ec_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_ec_read_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|ACPI_INTEGER
modifier|*
name|val
parameter_list|,
name|int
name|width
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_ec_write_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|ACPI_INTEGER
name|val
parameter_list|,
name|int
name|width
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|acpi_ec_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|acpi_ec_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|acpi_ec_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|acpi_ec_shutdown
argument_list|)
block|,
comment|/* Embedded controller interface */
name|DEVMETHOD
argument_list|(
name|acpi_ec_read
argument_list|,
name|acpi_ec_read_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|acpi_ec_write
argument_list|,
name|acpi_ec_write_method
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|acpi_ec_driver
init|=
block|{
literal|"acpi_ec"
block|,
name|acpi_ec_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_ec_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|acpi_ec_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|acpi_ec
argument_list|,
name|acpi
argument_list|,
name|acpi_ec_driver
argument_list|,
name|acpi_ec_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|acpi_ec
argument_list|,
name|acpi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Look for an ECDT and if we find one, set up default GPE and   * space handlers to catch attempts to access EC space before  * we have a real driver instance in place.  * TODO: if people report invalid ECDTs, add a tunable to disable them.  */
end_comment

begin_function
name|void
name|acpi_ec_ecdt_probe
parameter_list|(
name|device_t
name|parent
parameter_list|)
block|{
name|ACPI_TABLE_ECDT
modifier|*
name|ecdt
decl_stmt|;
name|ACPI_TABLE_HEADER
modifier|*
name|hdr
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|struct
name|acpi_ec_params
modifier|*
name|params
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* Find and validate the ECDT. */
name|status
operator|=
name|AcpiGetFirmwareTable
argument_list|(
literal|"ECDT"
argument_list|,
literal|1
argument_list|,
name|ACPI_LOGICAL_ADDRESSING
argument_list|,
operator|&
name|hdr
argument_list|)
expr_stmt|;
name|ecdt
operator|=
operator|(
name|ACPI_TABLE_ECDT
operator|*
operator|)
name|hdr
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
operator|||
name|ecdt
operator|->
name|control
operator|.
name|RegisterBitWidth
operator|!=
literal|8
operator|||
name|ecdt
operator|->
name|data
operator|.
name|RegisterBitWidth
operator|!=
literal|8
condition|)
block|{
return|return;
block|}
comment|/* Create the child device with the given unit number. */
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"acpi_ec"
argument_list|,
name|ecdt
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't add child\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find and save the ACPI handle for this device. */
name|status
operator|=
name|AcpiGetHandle
argument_list|(
name|NULL
argument_list|,
name|ecdt
operator|->
name|ec_id
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_delete_child
argument_list|(
name|parent
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: can't get handle\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|acpi_set_handle
argument_list|(
name|child
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Set the data and CSR register addresses. */
name|bus_set_resource
argument_list|(
name|child
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|ecdt
operator|->
name|data
operator|.
name|Address
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|bus_set_resource
argument_list|(
name|child
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|1
argument_list|,
name|ecdt
operator|->
name|control
operator|.
name|Address
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Store values for the probe/attach routines to use.  Store the      * ECDT GPE bit and set the global lock flag according to _GLK.      * Note that it is not perfectly correct to be evaluating a method      * before initializing devices, but in practice this function      * should be safe to call at this point.      */
name|params
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_ec_params
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|params
operator|->
name|gpe_handle
operator|=
name|NULL
expr_stmt|;
name|params
operator|->
name|gpe_bit
operator|=
name|ecdt
operator|->
name|gpe_bit
expr_stmt|;
name|params
operator|->
name|uid
operator|=
name|ecdt
operator|->
name|uid
expr_stmt|;
name|acpi_GetInteger
argument_list|(
name|h
argument_list|,
literal|"_GLK"
argument_list|,
operator|&
name|params
operator|->
name|glk
argument_list|)
expr_stmt|;
name|acpi_set_private
argument_list|(
name|child
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|acpi_set_magic
argument_list|(
name|child
argument_list|,
operator|(
name|int
operator|)
operator|&
name|acpi_ec_devclass
argument_list|)
expr_stmt|;
comment|/* Finish the attach process. */
if|if
condition|(
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
operator|!=
literal|0
condition|)
name|device_delete_child
argument_list|(
name|parent
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_ec_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|obj
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|device_t
name|peer
decl_stmt|;
name|char
name|desc
index|[
literal|64
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|acpi_ec_params
modifier|*
name|params
decl_stmt|;
specifier|static
name|char
modifier|*
name|ec_ids
index|[]
init|=
block|{
literal|"PNP0C09"
block|,
name|NULL
block|}
decl_stmt|;
comment|/* Check that this is a device and that EC is not disabled. */
if|if
condition|(
name|acpi_get_type
argument_list|(
name|dev
argument_list|)
operator|!=
name|ACPI_TYPE_DEVICE
operator|||
name|acpi_disabled
argument_list|(
literal|"ec"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*      * If probed via ECDT, set description and continue.  Otherwise,      * we can access the namespace and make sure this is not a      * duplicate probe.      */
name|ret
operator|=
name|ENXIO
expr_stmt|;
name|params
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
if|if
condition|(
name|DEV_ECDT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|params
operator|=
name|acpi_get_private
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|acpi_disabled
argument_list|(
literal|"ec"
argument_list|)
operator|&&
name|ACPI_ID_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|ec_ids
argument_list|)
condition|)
block|{
name|params
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_ec_params
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Read the unit ID to check for duplicate attach and the 	 * global lock value to see if we should acquire it when 	 * accessing the EC. 	 */
name|status
operator|=
name|acpi_GetInteger
argument_list|(
name|h
argument_list|,
literal|"_UID"
argument_list|,
operator|&
name|params
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
name|params
operator|->
name|uid
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|acpi_GetInteger
argument_list|(
name|h
argument_list|,
literal|"_GLK"
argument_list|,
operator|&
name|params
operator|->
name|glk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
name|params
operator|->
name|glk
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Evaluate the _GPE method to find the GPE bit used by the EC to 	 * signal status (SCI).  If it's a package, it contains a reference 	 * and GPE bit, similar to _PRW. 	 */
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|h
argument_list|,
literal|"_GPE"
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't evaluate _GPE - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|obj
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|buf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|obj
operator|->
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_INTEGER
case|:
name|params
operator|->
name|gpe_handle
operator|=
name|NULL
expr_stmt|;
name|params
operator|->
name|gpe_bit
operator|=
name|obj
operator|->
name|Integer
operator|.
name|Value
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_PACKAGE
case|:
if|if
condition|(
operator|!
name|ACPI_PKG_VALID
argument_list|(
name|obj
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|params
operator|->
name|gpe_handle
operator|=
name|acpi_GetReference
argument_list|(
name|NULL
argument_list|,
operator|&
name|obj
operator|->
name|Package
operator|.
name|Elements
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|gpe_handle
operator|==
name|NULL
operator|||
name|acpi_PkgInt32
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|,
operator|&
name|params
operator|->
name|gpe_bit
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"_GPE has invalid type %d\n"
argument_list|,
name|obj
operator|->
name|Type
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Store the values we got from the namespace for attach. */
name|acpi_set_private
argument_list|(
name|dev
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* 	 * Check for a duplicate probe.  This can happen when a probe 	 * via ECDT succeeded already.  If this is a duplicate, disable 	 * this device. 	 */
name|peer
operator|=
name|devclass_get_device
argument_list|(
name|acpi_ec_devclass
argument_list|,
name|params
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|NULL
operator|||
operator|!
name|device_is_alive
argument_list|(
name|peer
argument_list|)
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
name|device_disable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
literal|"Embedded Controller: GPE %#x%s%s"
argument_list|,
name|params
operator|->
name|gpe_bit
argument_list|,
operator|(
name|params
operator|->
name|glk
operator|)
condition|?
literal|", GLK"
else|:
literal|""
argument_list|,
name|DEV_ECDT
argument_list|(
name|dev
argument_list|)
condition|?
literal|", ECDT"
else|:
literal|""
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|>
literal|0
operator|&&
name|params
condition|)
name|free
argument_list|(
name|params
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|Pointer
condition|)
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_ec_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|acpi_ec_params
modifier|*
name|params
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* Fetch/initialize softc (assumes softc is pre-zeroed). */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|params
operator|=
name|acpi_get_private
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|ec_handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|ec_mtx
argument_list|,
literal|"ACPI EC lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Retrieve previously probed values via device ivars. */
name|sc
operator|->
name|ec_glk
operator|=
name|params
operator|->
name|glk
expr_stmt|;
name|sc
operator|->
name|ec_gpebit
operator|=
name|params
operator|->
name|gpe_bit
expr_stmt|;
name|sc
operator|->
name|ec_gpehandle
operator|=
name|params
operator|->
name|gpe_handle
expr_stmt|;
name|sc
operator|->
name|ec_uid
operator|=
name|params
operator|->
name|uid
expr_stmt|;
name|free
argument_list|(
name|params
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
comment|/* Attach bus resources for data and command/status ports. */
name|sc
operator|->
name|ec_data_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ec_data_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|ec_data_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_data_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't allocate data port\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|sc
operator|->
name|ec_data_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|ec_data_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_data_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|ec_data_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_csr_rid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|ec_csr_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|ec_csr_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_csr_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't allocate command/status port\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|sc
operator|->
name|ec_csr_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|ec_csr_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_csr_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|ec_csr_res
argument_list|)
expr_stmt|;
comment|/*      * Install a handler for this EC's GPE bit.  We want edge-triggered      * behavior.      */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_RESOURCES
operator|,
literal|"attaching GPE handler\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiInstallGpeHandler
argument_list|(
name|sc
operator|->
name|ec_gpehandle
argument_list|,
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_GPE_EDGE_TRIGGERED
argument_list|,
operator|&
name|EcGpeHandler
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't install GPE handler for %s - %s\n"
argument_list|,
name|acpi_name
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|)
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/*       * Install address space handler      */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_RESOURCES
operator|,
literal|"attaching address space handler\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiInstallAddressSpaceHandler
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|,
name|ACPI_ADR_SPACE_EC
argument_list|,
operator|&
name|EcSpaceHandler
argument_list|,
operator|&
name|EcSpaceSetup
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't install address space handler for %s - %s\n"
argument_list|,
name|acpi_name
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|)
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Enable runtime GPEs for the handler. */
name|Status
operator|=
name|AcpiSetGpeType
argument_list|(
name|sc
operator|->
name|ec_gpehandle
argument_list|,
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_GPE_TYPE_RUNTIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AcpiSetGpeType failed: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|Status
operator|=
name|AcpiEnableGpe
argument_list|(
name|sc
operator|->
name|ec_gpehandle
argument_list|,
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_NOT_ISR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AcpiEnableGpe failed: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_RESOURCES
operator|,
literal|"acpi_ec_attach complete\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|AcpiRemoveGpeHandler
argument_list|(
name|sc
operator|->
name|ec_gpehandle
argument_list|,
name|sc
operator|->
name|ec_gpebit
argument_list|,
operator|&
name|EcGpeHandler
argument_list|)
expr_stmt|;
name|AcpiRemoveAddressSpaceHandler
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|,
name|ACPI_ADR_SPACE_EC
argument_list|,
name|EcSpaceHandler
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_csr_res
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|ec_csr_rid
argument_list|,
name|sc
operator|->
name|ec_csr_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_data_res
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|ec_data_rid
argument_list|,
name|sc
operator|->
name|ec_data_res
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|ec_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_ec_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
decl_stmt|;
comment|/* Disable the GPE so we don't get EC events during shutdown. */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|AcpiDisableGpe
argument_list|(
name|sc
operator|->
name|ec_gpehandle
argument_list|,
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_NOT_ISR
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Methods to allow other devices (e.g., smbat) to read/write EC space. */
end_comment

begin_function
specifier|static
name|int
name|acpi_ec_read_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|ACPI_INTEGER
modifier|*
name|val
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|status
operator|=
name|EcSpaceHandler
argument_list|(
name|ACPI_READ
argument_list|,
name|addr
argument_list|,
name|width
operator|*
literal|8
argument_list|,
name|val
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_ec_write_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|ACPI_INTEGER
name|val
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|status
operator|=
name|EcSpaceHandler
argument_list|(
name|ACPI_WRITE
argument_list|,
name|addr
argument_list|,
name|width
operator|*
literal|8
argument_list|,
operator|&
name|val
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|EcGpeQueryHandler
parameter_list|(
name|void
modifier|*
name|Context
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_ec_softc
operator|*
operator|)
name|Context
decl_stmt|;
name|UINT8
name|Data
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|char
name|qxx
index|[
literal|5
index|]
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|Context
operator|!=
name|NULL
argument_list|,
operator|(
literal|"EcGpeQueryHandler called with NULL"
operator|)
argument_list|)
expr_stmt|;
comment|/* Serialize user access with EcSpaceHandler(). */
name|Status
operator|=
name|EcLock
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"GpeQuery lock error: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Send a query command to the EC to find out which _Qxx call it      * wants to make.  This command clears the SCI bit and also the      * interrupt source since we are edge-triggered.      */
name|Status
operator|=
name|EcCommand
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_QUERY
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|EcUnlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"GPE query failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|re_enable
goto|;
block|}
name|Data
operator|=
name|EC_GET_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_sci_pend
operator|=
name|FALSE
expr_stmt|;
comment|/* Drop locks before evaluating _Qxx method since it may trigger GPEs. */
name|EcUnlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Ignore the value for "no outstanding event". (13.3.5) */
name|CTR2
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec query ok,%s running _Q%02x"
argument_list|,
name|Data
condition|?
literal|""
else|:
literal|" not"
argument_list|,
name|Data
argument_list|)
expr_stmt|;
if|if
condition|(
name|Data
operator|==
literal|0
condition|)
goto|goto
name|re_enable
goto|;
comment|/* Evaluate _Qxx to respond to the controller. */
name|snprintf
argument_list|(
name|qxx
argument_list|,
sizeof|sizeof
argument_list|(
name|qxx
argument_list|)
argument_list|,
literal|"_Q%02x"
argument_list|,
name|Data
argument_list|)
expr_stmt|;
name|AcpiUtStrupr
argument_list|(
name|qxx
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|,
name|qxx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
operator|&&
name|Status
operator|!=
name|AE_NOT_FOUND
condition|)
block|{
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"evaluation of GPE query method %s failed - %s\n"
argument_list|,
name|qxx
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|re_enable
label|:
comment|/* Re-enable the GPE event so we'll get future requests. */
name|Status
operator|=
name|AcpiEnableGpe
argument_list|(
name|sc
operator|->
name|ec_gpehandle
argument_list|,
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_ISR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
name|printf
argument_list|(
literal|"EcGpeQueryHandler: AcpiEnableEvent failed\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a GPE.  Currently we only handle SCI events as others must  * be handled by polling in EcWaitEvent().  This is because some ECs  * treat events as level when they should be edge-triggered.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|EcGpeHandler
parameter_list|(
name|void
modifier|*
name|Context
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
init|=
name|Context
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|EC_STATUS
name|EcStatus
decl_stmt|;
name|KASSERT
argument_list|(
name|Context
operator|!=
name|NULL
argument_list|,
operator|(
literal|"EcGpeHandler called with NULL"
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Disable further GPEs while we handle this one.  Since we are directly      * called by ACPI-CA and it may have unknown locks held, we specify the      * ACPI_ISR flag to keep it from acquiring any more mutexes (although      * sleeping would be ok since we're in an ithread.)      */
name|AcpiDisableGpe
argument_list|(
name|sc
operator|->
name|ec_gpehandle
argument_list|,
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_ISR
argument_list|)
expr_stmt|;
comment|/* For interrupt (GPE) handler, don't acquire serialization lock. */
name|Status
operator|=
name|EcLock
argument_list|(
name|sc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"GpeQuery lock error: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*      * If burst was active, but the status bit was cleared, the EC had to      * exit burst mode for some reason.  Record this for later.      */
name|EcStatus
operator|=
name|EC_GET_CSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_burstactive
operator|&&
operator|(
name|EcStatus
operator|&
name|EC_FLAG_BURST_MODE
operator|)
operator|==
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec burst disabled in query handler"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_burstactive
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*      * If the EC_SCI bit of the status register is not set, then pass      * it along to any potential waiters as it may be an IBE/OBF event.      * If it is set, queue a query handler.      */
if|if
condition|(
operator|(
name|EcStatus
operator|&
name|EC_EVENT_SCI
operator|)
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec event was IBE/OBF, status %#x"
argument_list|,
name|EcStatus
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_csrvalue
operator|=
name|EcStatus
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|ec_csrvalue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sc
operator|->
name|ec_sci_pend
condition|)
block|{
comment|/* SCI bit set and no pending query handler, so schedule one. */
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec queueing gpe handler"
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiOsQueueForExecution
argument_list|(
name|OSD_PRIORITY_GPE
argument_list|,
name|EcGpeQueryHandler
argument_list|,
name|Context
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|sc
operator|->
name|ec_sci_pend
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Queuing GPE query handler failed.\n"
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiEnableGpe
argument_list|(
name|sc
operator|->
name|ec_gpehandle
argument_list|,
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_ISR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
name|printf
argument_list|(
literal|"EcGpeHandler: AcpiEnableEvent failed\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|EcUnlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcSpaceSetup
parameter_list|(
name|ACPI_HANDLE
name|Region
parameter_list|,
name|UINT32
name|Function
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|RegionContext
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/*      * If deactivating a region, always set the output to NULL.  Otherwise,      * just pass the context through.      */
if|if
condition|(
name|Function
operator|==
name|ACPI_REGION_DEACTIVATE
condition|)
operator|*
name|RegionContext
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|RegionContext
operator|=
name|Context
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcSpaceHandler
parameter_list|(
name|UINT32
name|Function
parameter_list|,
name|ACPI_PHYSICAL_ADDRESS
name|Address
parameter_list|,
name|UINT32
name|width
parameter_list|,
name|ACPI_INTEGER
modifier|*
name|Value
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
name|RegionContext
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_ec_softc
operator|*
operator|)
name|Context
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|UINT8
name|EcAddr
decl_stmt|,
name|EcData
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ACPI_FUNCTION_TRACE_U32
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|,
operator|(
name|UINT32
operator|)
name|Address
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|%
literal|8
operator|!=
literal|0
operator|||
name|Value
operator|==
name|NULL
operator|||
name|Context
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
if|if
condition|(
name|Address
operator|+
operator|(
name|width
operator|/
literal|8
operator|)
operator|-
literal|1
operator|>
literal|0xFF
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|Function
operator|==
name|ACPI_READ
condition|)
operator|*
name|Value
operator|=
literal|0
expr_stmt|;
name|EcAddr
operator|=
name|Address
expr_stmt|;
name|Status
operator|=
name|AE_ERROR
expr_stmt|;
comment|/* Grab serialization lock to hold across command sequence. */
name|Status
operator|=
name|EcLock
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
comment|/* Perform the transaction(s), based on width. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|+=
literal|8
operator|,
name|EcAddr
operator|++
control|)
block|{
switch|switch
condition|(
name|Function
condition|)
block|{
case|case
name|ACPI_READ
case|:
name|Status
operator|=
name|EcRead
argument_list|(
name|sc
argument_list|,
name|EcAddr
argument_list|,
operator|&
name|EcData
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|Status
argument_list|)
condition|)
operator|*
name|Value
operator||=
operator|(
operator|(
name|ACPI_INTEGER
operator|)
name|EcData
operator|)
operator|<<
name|i
expr_stmt|;
break|break;
case|case
name|ACPI_WRITE
case|:
name|EcData
operator|=
call|(
name|UINT8
call|)
argument_list|(
operator|(
operator|*
name|Value
operator|)
operator|>>
name|i
argument_list|)
expr_stmt|;
name|Status
operator|=
name|EcWrite
argument_list|(
name|sc
argument_list|,
name|EcAddr
argument_list|,
operator|&
name|EcData
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
literal|"invalid EcSpaceHandler function %d\n"
argument_list|,
name|Function
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AE_BAD_PARAMETER
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
break|break;
block|}
name|EcUnlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcWaitEvent
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|EC_EVENT
name|Event
parameter_list|)
block|{
name|EC_STATUS
name|EcStatus
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|retval
decl_stmt|,
name|slp_ival
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|ec
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AE_NO_HARDWARE_RESPONSE
expr_stmt|;
name|EcStatus
operator|=
literal|0
expr_stmt|;
comment|/*      * Poll for up to ec_poll_time microseconds since many ECs complete      * the command quickly, especially if in burst mode.      */
if|#
directive|if
literal|0
comment|/* Enable this as a possible workaround if EC times out. */
block|AcpiOsStall(EC_POLL_DELAY);
endif|#
directive|endif
name|count
operator|=
name|ec_poll_time
operator|/
name|EC_POLL_DELAY
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|EcStatus
operator|=
name|EC_GET_CSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_burstactive
operator|&&
operator|(
name|EcStatus
operator|&
name|EC_FLAG_BURST_MODE
operator|)
operator|==
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec burst disabled in waitevent (poll)"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_burstactive
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|EVENT_READY
argument_list|(
name|Event
argument_list|,
name|EcStatus
argument_list|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec poll wait ready, status %#x"
argument_list|,
name|EcStatus
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AE_OK
expr_stmt|;
break|break;
block|}
name|AcpiOsStall
argument_list|(
name|EC_POLL_DELAY
argument_list|)
expr_stmt|;
block|}
comment|/*      * If we still don't have a response and we're up and running, wait up      * to ec_timeout ms for completion, sleeping for chunks of 1 ms or the      * smallest resolution hz supports.      */
name|slp_ival
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|AE_OK
condition|)
block|{
name|retval
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
operator|!
name|cold
condition|)
block|{
name|slp_ival
operator|=
name|hz
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|slp_ival
operator|!=
literal|0
condition|)
block|{
name|count
operator|=
name|ec_timeout
operator|/
name|slp_ival
expr_stmt|;
block|}
else|else
block|{
comment|/* hz has less than 1000 Hz resolution so scale timeout. */
name|slp_ival
operator|=
literal|1
expr_stmt|;
name|count
operator|=
name|ec_timeout
operator|/
operator|(
literal|1000
operator|/
name|hz
operator|)
expr_stmt|;
block|}
block|}
else|else
name|count
operator|=
name|ec_timeout
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|EcStatus
operator|=
name|EC_GET_CSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|EcStatus
operator|=
name|sc
operator|->
name|ec_csrvalue
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_burstactive
operator|&&
operator|(
name|EcStatus
operator|&
name|EC_FLAG_BURST_MODE
operator|)
operator|==
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec burst disabled in waitevent (slp)"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_burstactive
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|EVENT_READY
argument_list|(
name|Event
argument_list|,
name|EcStatus
argument_list|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec sleep wait ready, status %#x"
argument_list|,
name|EcStatus
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AE_OK
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|cold
condition|)
block|{
name|retval
operator|=
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|ec_csrvalue
argument_list|,
operator|&
name|sc
operator|->
name|ec_mtx
argument_list|,
name|PZERO
argument_list|,
literal|"ecpoll"
argument_list|,
name|slp_ival
argument_list|)
expr_stmt|;
block|}
else|else
name|AcpiOsStall
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcCommand
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|EC_COMMAND
name|cmd
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|EC_EVENT
name|event
decl_stmt|;
name|EC_STATUS
name|ec_status
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|ec
argument_list|)
expr_stmt|;
comment|/* Don't use burst mode if user disabled it. */
if|if
condition|(
operator|!
name|ec_burst_mode
operator|&&
name|cmd
operator|==
name|EC_COMMAND_BURST_ENABLE
condition|)
return|return
operator|(
name|AE_ERROR
operator|)
return|;
comment|/* Decide what to wait for based on command type. */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|EC_COMMAND_READ
case|:
case|case
name|EC_COMMAND_WRITE
case|:
case|case
name|EC_COMMAND_BURST_DISABLE
case|:
name|event
operator|=
name|EC_EVENT_INPUT_BUFFER_EMPTY
expr_stmt|;
break|break;
case|case
name|EC_COMMAND_QUERY
case|:
case|case
name|EC_COMMAND_BURST_ENABLE
case|:
name|event
operator|=
name|EC_EVENT_OUTPUT_BUFFER_FULL
expr_stmt|;
break|break;
default|default:
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcCommand: Invalid command %#x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
block|}
comment|/* Run the command and wait for the chosen event. */
name|CTR1
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec running command %#x"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|EC_SET_CSR
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|status
operator|=
name|EcWaitEvent
argument_list|(
name|sc
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* If we succeeded, burst flag should now be present. */
if|if
condition|(
name|cmd
operator|==
name|EC_COMMAND_BURST_ENABLE
condition|)
block|{
name|ec_status
operator|=
name|EC_GET_CSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ec_status
operator|&
name|EC_FLAG_BURST_MODE
operator|)
operator|==
literal|0
condition|)
name|status
operator|=
name|AE_ERROR
expr_stmt|;
block|}
block|}
else|else
block|{
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcCommand: no response to %#x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcRead
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|UINT8
name|Address
parameter_list|,
name|UINT8
modifier|*
name|Data
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|UINT8
name|data
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|ec
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec read from %#x"
argument_list|,
name|Address
argument_list|)
expr_stmt|;
comment|/* If we can't start burst mode, continue anyway. */
name|status
operator|=
name|EcCommand
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_BURST_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|AE_OK
condition|)
block|{
name|data
operator|=
name|EC_GET_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|EC_BURST_ACK
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec burst enabled"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_burstactive
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|status
operator|=
name|EcCommand
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|EC_SET_DATA
argument_list|(
name|sc
argument_list|,
name|Address
argument_list|)
expr_stmt|;
name|status
operator|=
name|EcWaitEvent
argument_list|(
name|sc
argument_list|,
name|EC_EVENT_OUTPUT_BUFFER_FULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcRead: Failed waiting for EC to send data.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
operator|*
name|Data
operator|=
name|EC_GET_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_burstactive
condition|)
block|{
name|status
operator|=
name|EcCommand
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_BURST_DISABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|sc
operator|->
name|ec_burstactive
operator|=
name|FALSE
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec disabled burst ok"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcWrite
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|UINT8
name|Address
parameter_list|,
name|UINT8
modifier|*
name|Data
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|UINT8
name|data
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|ec
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec write to %#x, data %#x"
argument_list|,
name|Address
argument_list|,
operator|*
name|Data
argument_list|)
expr_stmt|;
comment|/* If we can't start burst mode, continue anyway. */
name|status
operator|=
name|EcCommand
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_BURST_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|AE_OK
condition|)
block|{
name|data
operator|=
name|EC_GET_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|EC_BURST_ACK
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec burst enabled"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_burstactive
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|status
operator|=
name|EcCommand
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|EC_SET_DATA
argument_list|(
name|sc
argument_list|,
name|Address
argument_list|)
expr_stmt|;
name|status
operator|=
name|EcWaitEvent
argument_list|(
name|sc
argument_list|,
name|EC_EVENT_INPUT_BUFFER_EMPTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcRead: Failed waiting for EC to process address\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|EC_SET_DATA
argument_list|(
name|sc
argument_list|,
operator|*
name|Data
argument_list|)
expr_stmt|;
name|status
operator|=
name|EcWaitEvent
argument_list|(
name|sc
argument_list|,
name|EC_EVENT_INPUT_BUFFER_EMPTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcWrite: Failed waiting for EC to process data\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|ec_burstactive
condition|)
block|{
name|status
operator|=
name|EcCommand
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_BURST_DISABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|sc
operator|->
name|ec_burstactive
operator|=
name|FALSE
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec disabled burst ok"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

end_unit

