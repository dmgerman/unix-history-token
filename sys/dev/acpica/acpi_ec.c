begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Michael Smith  * Copyright (c) 2000 BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_comment
comment|/******************************************************************************  *  * 1. Copyright Notice  *  * Some or all of this work - Copyright (c) 1999, Intel Corp.  All rights  * reserved.  *  * 2. License  *  * 2.1. This is your license from Intel Corp. under its intellectual property  * rights.  You may have additional license terms from the party that provided  * you this software, covering your right to use that party's intellectual  * property rights.  *  * 2.2. Intel grants, free of charge, to any person ("Licensee") obtaining a  * copy of the source code appearing in this file ("Covered Code") an  * irrevocable, perpetual, worldwide license under Intel's copyrights in the  * base code distributed originally by Intel ("Original Intel Code") to copy,  * make derivatives, distribute, use and display any portion of the Covered  * Code in any form, with the right to sublicense such rights; and  *  * 2.3. Intel grants Licensee a non-exclusive and non-transferable patent  * license (with the right to sublicense), under only those claims of Intel  * patents that are infringed by the Original Intel Code, to make, use, sell,  * offer to sell, and import the Covered Code and derivative works thereof  * solely to the minimum extent necessary to exercise the above copyright  * license, and in no event shall the patent license extend to any additions  * to or modifications of the Original Intel Code.  No other license or right  * is granted directly or by implication, estoppel or otherwise;  *  * The above copyright and patent license is granted only if the following  * conditions are met:  *  * 3. Conditions   *  * 3.1. Redistribution of Source with Rights to Further Distribute Source.    * Redistribution of source code of any substantial portion of the Covered  * Code or modification with rights to further distribute source must include  * the above Copyright Notice, the above License, this list of Conditions,  * and the following Disclaimer and Export Compliance provision.  In addition,  * Licensee must cause all Covered Code to which Licensee contributes to  * contain a file documenting the changes Licensee made to create that Covered  * Code and the date of any change.  Licensee must include in that file the  * documentation of any changes made by any predecessor Licensee.  Licensee   * must include a prominent statement that the modification is derived,  * directly or indirectly, from Original Intel Code.  *  * 3.2. Redistribution of Source with no Rights to Further Distribute Source.    * Redistribution of source code of any substantial portion of the Covered  * Code or modification without rights to further distribute source must  * include the following Disclaimer and Export Compliance provision in the  * documentation and/or other materials provided with distribution.  In  * addition, Licensee may not authorize further sublicense of source of any  * portion of the Covered Code, and must include terms to the effect that the  * license from Licensee to its licensee is limited to the intellectual  * property embodied in the software Licensee provides to its licensee, and  * not to intellectual property embodied in modifications its licensee may  * make.  *  * 3.3. Redistribution of Executable. Redistribution in executable form of any  * substantial portion of the Covered Code or modification must reproduce the  * above Copyright Notice, and the following Disclaimer and Export Compliance  * provision in the documentation and/or other materials provided with the  * distribution.  *  * 3.4. Intel retains all right, title, and interest in and to the Original  * Intel Code.  *  * 3.5. Neither the name Intel nor any other trademark owned or controlled by  * Intel shall be used in advertising or otherwise to promote the sale, use or  * other dealings in products derived from or relating to the Covered Code  * without prior written authorization from Intel.  *  * 4. Disclaimer and Export Compliance  *  * 4.1. INTEL MAKES NO WARRANTY OF ANY KIND REGARDING ANY SOFTWARE PROVIDED  * HERE.  ANY SOFTWARE ORIGINATING FROM INTEL OR DERIVED FROM INTEL SOFTWARE  * IS PROVIDED "AS IS," AND INTEL WILL NOT PROVIDE ANY SUPPORT,  ASSISTANCE,  * INSTALLATION, TRAINING OR OTHER SERVICES.  INTEL WILL NOT PROVIDE ANY  * UPDATES, ENHANCEMENTS OR EXTENSIONS.  INTEL SPECIFICALLY DISCLAIMS ANY  * IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT AND FITNESS FOR A  * PARTICULAR PURPOSE.   *  * 4.2. IN NO EVENT SHALL INTEL HAVE ANY LIABILITY TO LICENSEE, ITS LICENSEES  * OR ANY OTHER THIRD PARTY, FOR ANY LOST PROFITS, LOST DATA, LOSS OF USE OR  * COSTS OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, OR FOR ANY INDIRECT,  * SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THIS AGREEMENT, UNDER ANY  * CAUSE OF ACTION OR THEORY OF LIABILITY, AND IRRESPECTIVE OF WHETHER INTEL  * HAS ADVANCE NOTICE OF THE POSSIBILITY OF SUCH DAMAGES.  THESE LIMITATIONS  * SHALL APPLY NOTWITHSTANDING THE FAILURE OF THE ESSENTIAL PURPOSE OF ANY  * LIMITED REMEDY.  *  * 4.3. Licensee shall not export, either directly or indirectly, any of this  * software or system incorporating such software without first obtaining any  * required license or other approval from the U. S. Department of Commerce or  * any other agency or department of the United States Government.  In the  * event Licensee exports any such software from the United States or  * re-exports any such software from a foreign destination, Licensee shall  * ensure that the distribution and export/re-export of the software is in  * compliance with all laws, regulations, orders, or other restrictions of the  * U.S. Export Administration Regulations. Licensee agrees that neither it nor  * any of its subsidiaries will export/re-export any technical data, process,  * software, or service, directly or indirectly, to any country for which the  * United States government or any agency thereof requires an export license,  * other governmental approval, or letter of assurance, without first obtaining  * such license, approval or letter.  *  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|"acpi.h"
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_comment
comment|/*  * Hooks for the ACPI CA debugging infrastructure  */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_EC
end_define

begin_macro
name|MODULE_NAME
argument_list|(
literal|"EC"
argument_list|)
end_macro

begin_comment
comment|/*  * EC_COMMAND:  * -----------  */
end_comment

begin_typedef
typedef|typedef
name|UINT8
name|EC_COMMAND
typedef|;
end_typedef

begin_define
define|#
directive|define
name|EC_COMMAND_UNKNOWN
value|((EC_COMMAND) 0x00)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_READ
value|((EC_COMMAND) 0x80)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_WRITE
value|((EC_COMMAND) 0x81)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_BURST_ENABLE
value|((EC_COMMAND) 0x82)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_BURST_DISABLE
value|((EC_COMMAND) 0x83)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_QUERY
value|((EC_COMMAND) 0x84)
end_define

begin_comment
comment|/*   * EC_STATUS:  * ----------  * The encoding of the EC status register is illustrated below.  * Note that a set bit (1) indicates the property is TRUE  * (e.g. if bit 0 is set then the output buffer is full).  * +-+-+-+-+-+-+-+-+  * |7|6|5|4|3|2|1|0|	  * +-+-+-+-+-+-+-+-+  *  | | | | | | | |  *  | | | | | | | +- Output Buffer Full?  *  | | | | | | +--- Input Buffer Full?  *  | | | | | +-----<reserved>  *  | | | | +------- Data Register is Command Byte?  *  | | | +--------- Burst Mode Enabled?  *  | | +----------- SCI Event?  *  | +------------- SMI Event?  *  +---------------<Reserved>  *  */
end_comment

begin_typedef
typedef|typedef
name|UINT8
name|EC_STATUS
typedef|;
end_typedef

begin_define
define|#
directive|define
name|EC_FLAG_OUTPUT_BUFFER
value|((EC_STATUS) 0x01)
end_define

begin_define
define|#
directive|define
name|EC_FLAG_INPUT_BUFFER
value|((EC_STATUS) 0x02)
end_define

begin_define
define|#
directive|define
name|EC_FLAG_BURST_MODE
value|((EC_STATUS) 0x10)
end_define

begin_define
define|#
directive|define
name|EC_FLAG_SCI
value|((EC_STATUS) 0x20)
end_define

begin_comment
comment|/*  * EC_EVENT:  * ---------  */
end_comment

begin_typedef
typedef|typedef
name|UINT8
name|EC_EVENT
typedef|;
end_typedef

begin_define
define|#
directive|define
name|EC_EVENT_UNKNOWN
value|((EC_EVENT) 0x00)
end_define

begin_define
define|#
directive|define
name|EC_EVENT_OUTPUT_BUFFER_FULL
value|((EC_EVENT) 0x01)
end_define

begin_define
define|#
directive|define
name|EC_EVENT_INPUT_BUFFER_EMPTY
value|((EC_EVENT) 0x02)
end_define

begin_define
define|#
directive|define
name|EC_EVENT_SCI
value|((EC_EVENT) 0x20)
end_define

begin_comment
comment|/*  * Register access primitives  */
end_comment

begin_define
define|#
directive|define
name|EC_GET_DATA
parameter_list|(
name|sc
parameter_list|)
define|\
value|bus_space_read_1((sc)->ec_data_tag, (sc)->ec_data_handle, 0)
end_define

begin_define
define|#
directive|define
name|EC_SET_DATA
parameter_list|(
name|sc
parameter_list|,
name|v
parameter_list|)
define|\
value|bus_space_write_1((sc)->ec_data_tag, (sc)->ec_data_handle, 0, (v))
end_define

begin_define
define|#
directive|define
name|EC_GET_CSR
parameter_list|(
name|sc
parameter_list|)
define|\
value|bus_space_read_1((sc)->ec_csr_tag, (sc)->ec_csr_handle, 0)
end_define

begin_define
define|#
directive|define
name|EC_SET_CSR
parameter_list|(
name|sc
parameter_list|,
name|v
parameter_list|)
define|\
value|bus_space_write_1((sc)->ec_csr_tag, (sc)->ec_csr_handle, 0, (v))
end_define

begin_comment
comment|/*  * Driver softc.  */
end_comment

begin_struct
struct|struct
name|acpi_ec_softc
block|{
name|device_t
name|ec_dev
decl_stmt|;
name|ACPI_HANDLE
name|ec_handle
decl_stmt|;
name|UINT32
name|ec_gpebit
decl_stmt|;
name|int
name|ec_data_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|ec_data_res
decl_stmt|;
name|bus_space_tag_t
name|ec_data_tag
decl_stmt|;
name|bus_space_handle_t
name|ec_data_handle
decl_stmt|;
name|int
name|ec_csr_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|ec_csr_res
decl_stmt|;
name|bus_space_tag_t
name|ec_csr_tag
decl_stmt|;
name|bus_space_handle_t
name|ec_csr_handle
decl_stmt|;
name|int
name|ec_locked
decl_stmt|;
name|int
name|ec_pendquery
decl_stmt|;
name|int
name|ec_csrvalue
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|EC_LOCK_TIMEOUT
value|1000
end_define

begin_comment
comment|/* 1ms */
end_comment

begin_function
specifier|static
name|__inline
name|ACPI_STATUS
name|EcLock
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|status
operator|=
name|AcpiAcquireGlobalLock
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|AE_OK
condition|)
operator|(
name|sc
operator|)
operator|->
name|ec_locked
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|EcUnlock
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|)
block|{
operator|(
name|sc
operator|)
operator|->
name|ec_locked
operator|=
literal|0
expr_stmt|;
name|AcpiReleaseGlobalLock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|EcIsLocked
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|sc
operator|)
operator|->
name|ec_locked
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|EC_COMMAND
name|Command
decl_stmt|;
name|UINT8
name|Address
decl_stmt|;
name|UINT8
name|Data
decl_stmt|;
block|}
name|EC_REQUEST
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|EcGpeHandler
parameter_list|(
name|void
modifier|*
name|Context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcSpaceSetup
parameter_list|(
name|ACPI_HANDLE
name|Region
parameter_list|,
name|UINT32
name|Function
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|return_Context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcSpaceHandler
parameter_list|(
name|UINT32
name|Function
parameter_list|,
name|ACPI_PHYSICAL_ADDRESS
name|Address
parameter_list|,
name|UINT32
name|width
parameter_list|,
name|ACPI_INTEGER
modifier|*
name|Value
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
name|RegionContext
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcWaitEvent
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|EC_EVENT
name|Event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcQuery
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|UINT8
modifier|*
name|Data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcTransaction
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|EC_REQUEST
modifier|*
name|EcRequest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcRead
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|UINT8
name|Address
parameter_list|,
name|UINT8
modifier|*
name|Data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcWrite
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|UINT8
name|Address
parameter_list|,
name|UINT8
modifier|*
name|Data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acpi_ec_identify
parameter_list|(
name|driver_t
name|driver
parameter_list|,
name|device_t
name|bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_ec_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_ec_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|acpi_ec_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|acpi_ec_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|acpi_ec_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|acpi_ec_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|acpi_ec_driver
init|=
block|{
literal|"acpi_ec"
block|,
name|acpi_ec_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_ec_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|acpi_ec_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|acpi_ec
argument_list|,
name|acpi
argument_list|,
name|acpi_ec_driver
argument_list|,
name|acpi_ec_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Look for an ECDT table and if we find one, set up a default EC   * space handler to catch possible attempts to access EC space before  * we have a real driver instance in place.  * We're not really an identify routine, but because we get called   * before most other things, this works out OK.  */
end_comment

begin_function
specifier|static
name|void
name|acpi_ec_identify
parameter_list|(
name|driver_t
name|driver
parameter_list|,
name|device_t
name|bus
parameter_list|)
block|{
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX implement - need an ACPI 2.0 system to test this */
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We could setup resources in the probe routine in order to have them printed   * when the device is attached.  */
end_comment

begin_function
specifier|static
name|int
name|acpi_ec_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|(
name|acpi_get_type
argument_list|(
name|dev
argument_list|)
operator|==
name|ACPI_TYPE_DEVICE
operator|)
operator|&&
operator|!
name|acpi_disabled
argument_list|(
literal|"ec"
argument_list|)
operator|&&
name|acpi_MatchHid
argument_list|(
name|dev
argument_list|,
literal|"PNP0C09"
argument_list|)
condition|)
block|{
comment|/* 	 * Set device description  	 */
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"embedded controller"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_ec_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|int
name|errval
init|=
literal|0
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
comment|/*      * Fetch/initialise softc      */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|ec_handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/*       * Attach bus resources      */
name|sc
operator|->
name|ec_data_rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ec_data_res
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|ec_data_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't allocate data port\n"
argument_list|)
expr_stmt|;
name|errval
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|ec_data_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|ec_data_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_data_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|ec_data_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_csr_rid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ec_csr_res
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|ec_csr_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't allocate command/status port\n"
argument_list|)
expr_stmt|;
name|errval
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|ec_csr_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|ec_csr_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_csr_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|ec_csr_res
argument_list|)
expr_stmt|;
comment|/*      * Install GPE handler      *      * Evaluate the _GPE method to find the GPE bit used by the EC to signal      * status (SCI).      */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_RESOURCES
operator|,
literal|"attaching GPE\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Status
operator|=
name|acpi_EvaluateInteger
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|,
literal|"_GPE"
argument_list|,
operator|&
name|sc
operator|->
name|ec_gpebit
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't evaluate _GPE - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
name|errval
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Install a handler for this EC's GPE bit.  Note that EC SCIs are       * treated as both edge- and level-triggered interrupts; in other words      * we clear the status bit immediately after getting an EC-SCI, then      * again after we're done processing the event.  This guarantees that      * events we cause while performing a transaction (e.g. IBE/OBF) get       * cleared before re-enabling the GPE.      */
if|if
condition|(
operator|(
name|Status
operator|=
name|AcpiInstallGpeHandler
argument_list|(
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_EVENT_LEVEL_TRIGGERED
operator||
name|ACPI_EVENT_EDGE_TRIGGERED
argument_list|,
name|EcGpeHandler
argument_list|,
name|sc
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't install GPE handler for %s - %s\n"
argument_list|,
name|acpi_name
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|)
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
name|errval
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*       * Install address space handler      */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_RESOURCES
operator|,
literal|"attaching address space handler\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Status
operator|=
name|AcpiInstallAddressSpaceHandler
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|,
name|ACPI_ADR_SPACE_EC
argument_list|,
name|EcSpaceHandler
argument_list|,
name|EcSpaceSetup
argument_list|,
name|sc
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't install address space handler for %s - %s\n"
argument_list|,
name|acpi_name
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|)
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"very suck"
argument_list|)
expr_stmt|;
name|errval
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_RESOURCES
operator|,
literal|"attach complete\n"
operator|)
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|sc
operator|->
name|ec_csr_res
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|ec_csr_rid
argument_list|,
name|sc
operator|->
name|ec_csr_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_data_res
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|ec_data_rid
argument_list|,
name|sc
operator|->
name|ec_data_res
argument_list|)
expr_stmt|;
name|return_VALUE
argument_list|(
name|errval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|EcGpeQueryHandler
parameter_list|(
name|void
modifier|*
name|Context
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_ec_softc
operator|*
operator|)
name|Context
decl_stmt|;
name|UINT8
name|Data
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|char
name|qxx
index|[
literal|5
index|]
decl_stmt|;
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	 * Check EC_SCI. 	 *  	 * Bail out if the EC_SCI bit of the status register is not set. 	 * Note that this function should only be called when 	 * this bit is set (polling is used to detect IBE/OBF events). 	 * 	 * It is safe to do this without locking the controller, as it's 	 * OK to call EcQuery when there's no data ready; in the worst 	 * case we should just find nothing waiting for us and bail. 	 */
if|if
condition|(
operator|!
operator|(
name|EC_GET_CSR
argument_list|(
name|sc
argument_list|)
operator|&
name|EC_EVENT_SCI
operator|)
condition|)
break|break;
comment|/* 	 * Find out why the EC is signalling us 	 */
name|Status
operator|=
name|EcQuery
argument_list|(
name|sc
argument_list|,
operator|&
name|Data
argument_list|)
expr_stmt|;
comment|/* 	 * If we failed to get anything from the EC, give up 	 */
if|if
condition|(
name|Status
operator|!=
name|AE_OK
condition|)
block|{
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"GPE query failed - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Evaluate _Qxx to respond to the controller. 	 */
name|sprintf
argument_list|(
name|qxx
argument_list|,
literal|"_Q%02x"
argument_list|,
name|Data
argument_list|)
expr_stmt|;
name|strupr
argument_list|(
name|qxx
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|,
name|qxx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Ignore spurious query requests. 	 */
if|if
condition|(
name|Status
operator|!=
name|AE_OK
operator|&&
operator|(
name|Data
operator|!=
literal|0
operator|||
name|Status
operator|!=
name|AE_NOT_FOUND
operator|)
condition|)
block|{
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"evaluation of GPE query method %s failed - %s\n"
argument_list|,
name|qxx
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* I know I request Level trigger cleanup */
if|if
condition|(
name|AcpiClearEvent
argument_list|(
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_EVENT_GPE
argument_list|)
operator|!=
name|AE_OK
condition|)
name|printf
argument_list|(
literal|"EcGpeQueryHandler:ClearEvent Failed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AcpiEnableEvent
argument_list|(
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_EVENT_GPE
argument_list|,
literal|0
argument_list|)
operator|!=
name|AE_OK
condition|)
name|printf
argument_list|(
literal|"EcGpeQueryHandler:EnableEvent Failed\n"
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a GPE sent to us.  */
end_comment

begin_function
specifier|static
name|void
name|EcGpeHandler
parameter_list|(
name|void
modifier|*
name|Context
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
init|=
name|Context
decl_stmt|;
name|int
name|csrvalue
decl_stmt|;
comment|/*       * If EC is locked, the intr must process EcRead/Write wait only.      * Query request must be pending.      */
if|if
condition|(
name|EcIsLocked
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|csrvalue
operator|=
name|EC_GET_CSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|csrvalue
operator|&
name|EC_EVENT_SCI
condition|)
name|sc
operator|->
name|ec_pendquery
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|csrvalue
operator|&
name|EC_FLAG_OUTPUT_BUFFER
operator|)
operator|||
operator|!
operator|(
name|csrvalue
operator|&
name|EC_FLAG_INPUT_BUFFER
operator|)
condition|)
block|{
name|sc
operator|->
name|ec_csrvalue
operator|=
name|csrvalue
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|ec_csrvalue
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Queue GpeQuery Handler */
if|if
condition|(
name|AcpiOsQueueForExecution
argument_list|(
name|OSD_PRIORITY_HIGH
argument_list|,
name|EcGpeQueryHandler
argument_list|,
name|Context
argument_list|)
operator|!=
name|AE_OK
condition|)
block|{
name|printf
argument_list|(
literal|"QueryHandler Queuing Failed\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcSpaceSetup
parameter_list|(
name|ACPI_HANDLE
name|Region
parameter_list|,
name|UINT32
name|Function
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|RegionContext
parameter_list|)
block|{
name|FUNCTION_TRACE
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
comment|/*      * Just pass the context through, there's nothing to do here.      */
operator|*
name|RegionContext
operator|=
name|Context
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcSpaceHandler
parameter_list|(
name|UINT32
name|Function
parameter_list|,
name|ACPI_PHYSICAL_ADDRESS
name|Address
parameter_list|,
name|UINT32
name|width
parameter_list|,
name|ACPI_INTEGER
modifier|*
name|Value
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
name|RegionContext
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_ec_softc
operator|*
operator|)
name|Context
decl_stmt|;
name|ACPI_STATUS
name|Status
init|=
name|AE_OK
decl_stmt|;
name|EC_REQUEST
name|EcRequest
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FUNCTION_TRACE_U32
argument_list|(
name|__func__
argument_list|,
operator|(
name|UINT32
operator|)
name|Address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Address
operator|>
literal|0xFF
operator|)
operator|||
operator|(
name|width
operator|%
literal|8
operator|!=
literal|0
operator|)
operator|||
operator|(
name|Value
operator|==
name|NULL
operator|)
operator|||
operator|(
name|Context
operator|==
name|NULL
operator|)
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Function
condition|)
block|{
case|case
name|ACPI_READ
case|:
name|EcRequest
operator|.
name|Command
operator|=
name|EC_COMMAND_READ
expr_stmt|;
name|EcRequest
operator|.
name|Address
operator|=
name|Address
expr_stmt|;
operator|(
operator|*
name|Value
operator|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ACPI_WRITE
case|:
name|EcRequest
operator|.
name|Command
operator|=
name|EC_COMMAND_WRITE
expr_stmt|;
name|EcRequest
operator|.
name|Address
operator|=
name|Address
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
literal|"invalid Address Space function %d\n"
argument_list|,
name|Function
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|/*      * Perform the transaction.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|+=
literal|8
control|)
block|{
if|if
condition|(
name|Function
operator|==
name|ACPI_READ
condition|)
name|EcRequest
operator|.
name|Data
operator|=
literal|0
expr_stmt|;
else|else
name|EcRequest
operator|.
name|Data
operator|=
call|(
name|UINT8
call|)
argument_list|(
operator|(
operator|*
name|Value
operator|)
operator|>>
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Status
operator|=
name|EcTransaction
argument_list|(
name|sc
argument_list|,
operator|&
name|EcRequest
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
break|break;
operator|(
operator|*
name|Value
operator|)
operator||=
operator|(
name|ACPI_INTEGER
operator|)
name|EcRequest
operator|.
name|Data
operator|<<
name|i
expr_stmt|;
if|if
condition|(
operator|++
name|EcRequest
operator|.
name|Address
operator|==
literal|0
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
block|}
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for an event interrupt for a specific condition.  */
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|EcWaitEventIntr
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|EC_EVENT
name|Event
parameter_list|)
block|{
name|EC_STATUS
name|EcStatus
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FUNCTION_TRACE_U32
argument_list|(
name|__func__
argument_list|,
operator|(
name|UINT32
operator|)
name|Event
argument_list|)
expr_stmt|;
comment|/* XXX this should test whether interrupts are available some other way */
if|if
condition|(
name|cold
condition|)
name|return_ACPI_STATUS
argument_list|(
name|EcWaitEvent
argument_list|(
name|sc
argument_list|,
name|Event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EcIsLocked
argument_list|(
name|sc
argument_list|)
condition|)
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcWaitEventIntr called without EC lock!\n"
argument_list|)
expr_stmt|;
name|EcStatus
operator|=
name|EC_GET_CSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX waiting too long? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
comment|/* 	 * Check EC status against the desired event. 	 */
if|if
condition|(
operator|(
name|Event
operator|==
name|EC_EVENT_OUTPUT_BUFFER_FULL
operator|)
operator|&&
operator|(
name|EcStatus
operator|&
name|EC_FLAG_OUTPUT_BUFFER
operator|)
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Event
operator|==
name|EC_EVENT_INPUT_BUFFER_EMPTY
operator|)
operator|&&
operator|!
operator|(
name|EcStatus
operator|&
name|EC_FLAG_INPUT_BUFFER
operator|)
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_csrvalue
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ACPI_MSLEEP
argument_list|(
operator|&
name|sc
operator|->
name|ec_csrvalue
argument_list|,
operator|&
name|acpi_mutex
argument_list|,
name|PZERO
argument_list|,
literal|"EcWait"
argument_list|,
literal|1
argument_list|)
operator|!=
name|EWOULDBLOCK
condition|)
block|{
name|EcStatus
operator|=
name|sc
operator|->
name|ec_csrvalue
expr_stmt|;
block|}
else|else
block|{
name|EcStatus
operator|=
name|EC_GET_CSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|return_ACPI_STATUS
argument_list|(
name|AE_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcWaitEvent
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|EC_EVENT
name|Event
parameter_list|)
block|{
name|EC_STATUS
name|EcStatus
decl_stmt|;
name|UINT32
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|EcIsLocked
argument_list|(
name|sc
argument_list|)
condition|)
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcWaitEvent called without EC lock!\n"
argument_list|)
expr_stmt|;
comment|/*      * Stall 1us:      * ----------      * Stall for 1 microsecond before reading the status register      * for the first time.  This allows the EC to set the IBF/OBF      * bit to its proper state.      *      * XXX it is not clear why we read the CSR twice.      */
name|AcpiOsStall
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|EcStatus
operator|=
name|EC_GET_CSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Wait For Event:      * ---------------      * Poll the EC status register to detect completion of the last      * command.  Wait up to 10ms (in 10us chunks) for this to occur.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|EcStatus
operator|=
name|EC_GET_CSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Event
operator|==
name|EC_EVENT_OUTPUT_BUFFER_FULL
operator|)
operator|&&
operator|(
name|EcStatus
operator|&
name|EC_FLAG_OUTPUT_BUFFER
operator|)
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
if|if
condition|(
operator|(
name|Event
operator|==
name|EC_EVENT_INPUT_BUFFER_EMPTY
operator|)
operator|&&
operator|!
operator|(
name|EcStatus
operator|&
name|EC_FLAG_INPUT_BUFFER
operator|)
condition|)
return|return
operator|(
name|AE_OK
operator|)
return|;
name|AcpiOsStall
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|AE_ERROR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcQuery
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|UINT8
modifier|*
name|Data
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
if|if
condition|(
operator|(
name|Status
operator|=
name|EcLock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
return|return
operator|(
name|Status
operator|)
return|;
name|EC_SET_CSR
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_QUERY
argument_list|)
expr_stmt|;
name|Status
operator|=
name|EcWaitEvent
argument_list|(
name|sc
argument_list|,
name|EC_EVENT_OUTPUT_BUFFER_FULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|==
name|AE_OK
condition|)
operator|*
name|Data
operator|=
name|EC_GET_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|EcUnlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|AE_OK
condition|)
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"timeout waiting for EC to respond to EC_COMMAND_QUERY\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcTransaction
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|EC_REQUEST
modifier|*
name|EcRequest
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
comment|/*      * Lock the EC      */
if|if
condition|(
operator|(
name|Status
operator|=
name|EcLock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
return|return
operator|(
name|Status
operator|)
return|;
comment|/*      * Perform the transaction.      */
switch|switch
condition|(
name|EcRequest
operator|->
name|Command
condition|)
block|{
case|case
name|EC_COMMAND_READ
case|:
name|Status
operator|=
name|EcRead
argument_list|(
name|sc
argument_list|,
name|EcRequest
operator|->
name|Address
argument_list|,
operator|&
operator|(
name|EcRequest
operator|->
name|Data
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EC_COMMAND_WRITE
case|:
name|Status
operator|=
name|EcWrite
argument_list|(
name|sc
argument_list|,
name|EcRequest
operator|->
name|Address
argument_list|,
operator|&
operator|(
name|EcRequest
operator|->
name|Data
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Status
operator|=
name|AE_SUPPORT
expr_stmt|;
break|break;
block|}
comment|/*      * Unlock the EC      */
name|EcUnlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Clear& Re-Enable the EC GPE:      * -----------------------------      * 'Consume' any EC GPE events that we generated while performing      * the transaction (e.g. IBF/OBF).	Clearing the GPE here shouldn't      * have an adverse affect on outstanding EC-SCI's, as the source      * (EC-SCI) will still be high and thus should trigger the GPE      * immediately after we re-enabling it.      */
if|if
condition|(
name|sc
operator|->
name|ec_pendquery
condition|)
block|{
if|if
condition|(
name|AcpiOsQueueForExecution
argument_list|(
name|OSD_PRIORITY_HIGH
argument_list|,
name|EcGpeQueryHandler
argument_list|,
name|sc
argument_list|)
operator|!=
name|AE_OK
condition|)
name|printf
argument_list|(
literal|"Pend Query Queuing Failed\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_pendquery
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|AcpiClearEvent
argument_list|(
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_EVENT_GPE
argument_list|)
operator|!=
name|AE_OK
condition|)
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcRequest: Unable to clear the EC GPE.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AcpiEnableEvent
argument_list|(
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_EVENT_GPE
argument_list|,
literal|0
argument_list|)
operator|!=
name|AE_OK
condition|)
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcRequest: Unable to re-enable the EC GPE.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcRead
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|UINT8
name|Address
parameter_list|,
name|UINT8
modifier|*
name|Data
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
if|if
condition|(
operator|!
name|EcIsLocked
argument_list|(
name|sc
argument_list|)
condition|)
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcRead called without EC lock!\n"
argument_list|)
expr_stmt|;
comment|/*EcBurstEnable(EmbeddedController);*/
name|EC_SET_CSR
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_READ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Status
operator|=
name|EcWaitEventIntr
argument_list|(
name|sc
argument_list|,
name|EC_EVENT_INPUT_BUFFER_EMPTY
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcRead: Failed waiting for EC to process read command.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
name|EC_SET_DATA
argument_list|(
name|sc
argument_list|,
name|Address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Status
operator|=
name|EcWaitEventIntr
argument_list|(
name|sc
argument_list|,
name|EC_EVENT_OUTPUT_BUFFER_FULL
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcRead: Failed waiting for EC to send data.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
operator|(
operator|*
name|Data
operator|)
operator|=
name|EC_GET_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*EcBurstDisable(EmbeddedController);*/
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcWrite
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|UINT8
name|Address
parameter_list|,
name|UINT8
modifier|*
name|Data
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
if|if
condition|(
operator|!
name|EcIsLocked
argument_list|(
name|sc
argument_list|)
condition|)
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcWrite called without EC lock!\n"
argument_list|)
expr_stmt|;
comment|/*EcBurstEnable(EmbeddedController);*/
name|EC_SET_CSR
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Status
operator|=
name|EcWaitEventIntr
argument_list|(
name|sc
argument_list|,
name|EC_EVENT_INPUT_BUFFER_EMPTY
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcWrite: Failed waiting for EC to process write command.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
name|EC_SET_DATA
argument_list|(
name|sc
argument_list|,
name|Address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Status
operator|=
name|EcWaitEventIntr
argument_list|(
name|sc
argument_list|,
name|EC_EVENT_INPUT_BUFFER_EMPTY
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcRead: Failed waiting for EC to process address.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
name|EC_SET_DATA
argument_list|(
name|sc
argument_list|,
operator|*
name|Data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Status
operator|=
name|EcWaitEventIntr
argument_list|(
name|sc
argument_list|,
name|EC_EVENT_INPUT_BUFFER_EMPTY
argument_list|)
operator|)
operator|!=
name|AE_OK
condition|)
block|{
name|ACPI_VPRINT
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|acpi_device_get_parent_softc
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|)
argument_list|,
literal|"EcWrite: Failed waiting for EC to process data.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
comment|/*EcBurstDisable(EmbeddedController);*/
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

end_unit

