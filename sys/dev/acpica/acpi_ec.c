begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2007 Nate Lawson  * Copyright (c) 2000 Michael Smith  * Copyright (c) 2000 BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/acpi.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_comment
comment|/* Hooks for the ACPI CA debugging infrastructure */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_EC
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"EC"
argument_list|)
end_macro

begin_comment
comment|/*  * EC_COMMAND:  * -----------  */
end_comment

begin_typedef
typedef|typedef
name|UINT8
name|EC_COMMAND
typedef|;
end_typedef

begin_define
define|#
directive|define
name|EC_COMMAND_UNKNOWN
value|((EC_COMMAND) 0x00)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_READ
value|((EC_COMMAND) 0x80)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_WRITE
value|((EC_COMMAND) 0x81)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_BURST_ENABLE
value|((EC_COMMAND) 0x82)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_BURST_DISABLE
value|((EC_COMMAND) 0x83)
end_define

begin_define
define|#
directive|define
name|EC_COMMAND_QUERY
value|((EC_COMMAND) 0x84)
end_define

begin_comment
comment|/*  * EC_STATUS:  * ----------  * The encoding of the EC status register is illustrated below.  * Note that a set bit (1) indicates the property is TRUE  * (e.g. if bit 0 is set then the output buffer is full).  * +-+-+-+-+-+-+-+-+  * |7|6|5|4|3|2|1|0|  * +-+-+-+-+-+-+-+-+  *  | | | | | | | |  *  | | | | | | | +- Output Buffer Full?  *  | | | | | | +--- Input Buffer Full?  *  | | | | | +-----<reserved>  *  | | | | +------- Data Register is Command Byte?  *  | | | +--------- Burst Mode Enabled?  *  | | +----------- SCI Event?  *  | +------------- SMI Event?  *  +---------------<reserved>  *  */
end_comment

begin_typedef
typedef|typedef
name|UINT8
name|EC_STATUS
typedef|;
end_typedef

begin_define
define|#
directive|define
name|EC_FLAG_OUTPUT_BUFFER
value|((EC_STATUS) 0x01)
end_define

begin_define
define|#
directive|define
name|EC_FLAG_INPUT_BUFFER
value|((EC_STATUS) 0x02)
end_define

begin_define
define|#
directive|define
name|EC_FLAG_DATA_IS_CMD
value|((EC_STATUS) 0x08)
end_define

begin_define
define|#
directive|define
name|EC_FLAG_BURST_MODE
value|((EC_STATUS) 0x10)
end_define

begin_comment
comment|/*  * EC_EVENT:  * ---------  */
end_comment

begin_typedef
typedef|typedef
name|UINT8
name|EC_EVENT
typedef|;
end_typedef

begin_define
define|#
directive|define
name|EC_EVENT_UNKNOWN
value|((EC_EVENT) 0x00)
end_define

begin_define
define|#
directive|define
name|EC_EVENT_OUTPUT_BUFFER_FULL
value|((EC_EVENT) 0x01)
end_define

begin_define
define|#
directive|define
name|EC_EVENT_INPUT_BUFFER_EMPTY
value|((EC_EVENT) 0x02)
end_define

begin_define
define|#
directive|define
name|EC_EVENT_SCI
value|((EC_EVENT) 0x20)
end_define

begin_define
define|#
directive|define
name|EC_EVENT_SMI
value|((EC_EVENT) 0x40)
end_define

begin_comment
comment|/* Data byte returned after burst enable indicating it was successful. */
end_comment

begin_define
define|#
directive|define
name|EC_BURST_ACK
value|0x90
end_define

begin_comment
comment|/*  * Register access primitives  */
end_comment

begin_define
define|#
directive|define
name|EC_GET_DATA
parameter_list|(
name|sc
parameter_list|)
define|\
value|bus_space_read_1((sc)->ec_data_tag, (sc)->ec_data_handle, 0)
end_define

begin_define
define|#
directive|define
name|EC_SET_DATA
parameter_list|(
name|sc
parameter_list|,
name|v
parameter_list|)
define|\
value|bus_space_write_1((sc)->ec_data_tag, (sc)->ec_data_handle, 0, (v))
end_define

begin_define
define|#
directive|define
name|EC_GET_CSR
parameter_list|(
name|sc
parameter_list|)
define|\
value|bus_space_read_1((sc)->ec_csr_tag, (sc)->ec_csr_handle, 0)
end_define

begin_define
define|#
directive|define
name|EC_SET_CSR
parameter_list|(
name|sc
parameter_list|,
name|v
parameter_list|)
define|\
value|bus_space_write_1((sc)->ec_csr_tag, (sc)->ec_csr_handle, 0, (v))
end_define

begin_comment
comment|/* Additional params to pass from the probe routine */
end_comment

begin_struct
struct|struct
name|acpi_ec_params
block|{
name|int
name|glk
decl_stmt|;
name|int
name|gpe_bit
decl_stmt|;
name|ACPI_HANDLE
name|gpe_handle
decl_stmt|;
name|int
name|uid
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Driver softc.  */
end_comment

begin_struct
struct|struct
name|acpi_ec_softc
block|{
name|device_t
name|ec_dev
decl_stmt|;
name|ACPI_HANDLE
name|ec_handle
decl_stmt|;
name|int
name|ec_uid
decl_stmt|;
name|ACPI_HANDLE
name|ec_gpehandle
decl_stmt|;
name|UINT8
name|ec_gpebit
decl_stmt|;
name|int
name|ec_data_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|ec_data_res
decl_stmt|;
name|bus_space_tag_t
name|ec_data_tag
decl_stmt|;
name|bus_space_handle_t
name|ec_data_handle
decl_stmt|;
name|int
name|ec_csr_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|ec_csr_res
decl_stmt|;
name|bus_space_tag_t
name|ec_csr_tag
decl_stmt|;
name|bus_space_handle_t
name|ec_csr_handle
decl_stmt|;
name|int
name|ec_glk
decl_stmt|;
name|int
name|ec_glkhandle
decl_stmt|;
name|int
name|ec_burstactive
decl_stmt|;
name|int
name|ec_sci_pend
decl_stmt|;
name|u_int
name|ec_gencount
decl_stmt|;
name|int
name|ec_suspending
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * XXX njl  * I couldn't find it in the spec but other implementations also use a  * value of 1 ms for the time to acquire global lock.  */
end_comment

begin_define
define|#
directive|define
name|EC_LOCK_TIMEOUT
value|1000
end_define

begin_comment
comment|/* Default delay in microseconds between each run of the status polling loop. */
end_comment

begin_define
define|#
directive|define
name|EC_POLL_DELAY
value|5
end_define

begin_comment
comment|/* Total time in ms spent waiting for a response from EC. */
end_comment

begin_define
define|#
directive|define
name|EC_TIMEOUT
value|750
end_define

begin_define
define|#
directive|define
name|EVENT_READY
parameter_list|(
name|event
parameter_list|,
name|status
parameter_list|)
define|\
value|(((event) == EC_EVENT_OUTPUT_BUFFER_FULL&&	\ 	 ((status)& EC_FLAG_OUTPUT_BUFFER) != 0) ||	\ 	 ((event) == EC_EVENT_INPUT_BUFFER_EMPTY&& 	\ 	 ((status)& EC_FLAG_INPUT_BUFFER) == 0))
end_define

begin_expr_stmt
name|ACPI_SERIAL_DECL
argument_list|(
name|ec
argument_list|,
literal|"ACPI embedded controller"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_debug_acpi
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug_acpi
argument_list|,
name|OID_AUTO
argument_list|,
name|ec
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"EC debugging"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ec_burst_mode
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.acpi.ec.burst"
argument_list|,
operator|&
name|ec_burst_mode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_acpi_ec
argument_list|,
name|OID_AUTO
argument_list|,
name|burst
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ec_burst_mode
argument_list|,
literal|0
argument_list|,
literal|"Enable use of burst mode (faster for nearly all systems)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ec_polled_mode
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.acpi.ec.polled"
argument_list|,
operator|&
name|ec_polled_mode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_acpi_ec
argument_list|,
name|OID_AUTO
argument_list|,
name|polled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ec_polled_mode
argument_list|,
literal|0
argument_list|,
literal|"Force use of polled mode (only if interrupt mode doesn't work)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ec_timeout
init|=
name|EC_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.acpi.ec.timeout"
argument_list|,
operator|&
name|ec_timeout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_acpi_ec
argument_list|,
name|OID_AUTO
argument_list|,
name|timeout
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ec_timeout
argument_list|,
name|EC_TIMEOUT
argument_list|,
literal|"Total time spent waiting for a response (poll+sleep)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|ACPI_STATUS
name|EcLock
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
comment|/* If _GLK is non-zero, acquire the global lock. */
name|status
operator|=
name|AE_OK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_glk
condition|)
block|{
name|status
operator|=
name|AcpiAcquireGlobalLock
argument_list|(
name|EC_LOCK_TIMEOUT
argument_list|,
operator|&
name|sc
operator|->
name|ec_glkhandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|status
operator|)
return|;
block|}
name|ACPI_SERIAL_BEGIN
argument_list|(
name|ec
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|EcUnlock
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ACPI_SERIAL_END
argument_list|(
name|ec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_glk
condition|)
name|AcpiReleaseGlobalLock
argument_list|(
name|sc
operator|->
name|ec_glkhandle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|uint32_t
name|EcGpeHandler
parameter_list|(
name|void
modifier|*
name|Context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcSpaceSetup
parameter_list|(
name|ACPI_HANDLE
name|Region
parameter_list|,
name|UINT32
name|Function
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|return_Context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcSpaceHandler
parameter_list|(
name|UINT32
name|Function
parameter_list|,
name|ACPI_PHYSICAL_ADDRESS
name|Address
parameter_list|,
name|UINT32
name|width
parameter_list|,
name|ACPI_INTEGER
modifier|*
name|Value
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
name|RegionContext
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcWaitEvent
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|EC_EVENT
name|Event
parameter_list|,
name|u_int
name|gen_count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcCommand
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|EC_COMMAND
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcRead
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|UINT8
name|Address
parameter_list|,
name|UINT8
modifier|*
name|Data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|EcWrite
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|UINT8
name|Address
parameter_list|,
name|UINT8
modifier|*
name|Data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_ec_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_ec_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_ec_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_ec_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_ec_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_ec_read_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|ACPI_INTEGER
modifier|*
name|val
parameter_list|,
name|int
name|width
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acpi_ec_write_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|ACPI_INTEGER
name|val
parameter_list|,
name|int
name|width
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|acpi_ec_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|acpi_ec_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|acpi_ec_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|acpi_ec_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|acpi_ec_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|acpi_ec_shutdown
argument_list|)
block|,
comment|/* Embedded controller interface */
name|DEVMETHOD
argument_list|(
name|acpi_ec_read
argument_list|,
name|acpi_ec_read_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|acpi_ec_write
argument_list|,
name|acpi_ec_write_method
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|acpi_ec_driver
init|=
block|{
literal|"acpi_ec"
block|,
name|acpi_ec_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_ec_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|acpi_ec_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|acpi_ec
argument_list|,
name|acpi
argument_list|,
name|acpi_ec_driver
argument_list|,
name|acpi_ec_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|acpi_ec
argument_list|,
name|acpi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Look for an ECDT and if we find one, set up default GPE and  * space handlers to catch attempts to access EC space before  * we have a real driver instance in place.  *  * TODO: Some old Gateway laptops need us to fake up an ECDT or  * otherwise attach early so that _REG methods can run.  */
end_comment

begin_function
name|void
name|acpi_ec_ecdt_probe
parameter_list|(
name|device_t
name|parent
parameter_list|)
block|{
name|ACPI_TABLE_ECDT
modifier|*
name|ecdt
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|struct
name|acpi_ec_params
modifier|*
name|params
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* Find and validate the ECDT. */
name|status
operator|=
name|AcpiGetTable
argument_list|(
name|ACPI_SIG_ECDT
argument_list|,
literal|1
argument_list|,
operator|(
name|ACPI_TABLE_HEADER
operator|*
operator|*
operator|)
operator|&
name|ecdt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
operator|||
name|ecdt
operator|->
name|Control
operator|.
name|BitWidth
operator|!=
literal|8
operator|||
name|ecdt
operator|->
name|Data
operator|.
name|BitWidth
operator|!=
literal|8
condition|)
block|{
return|return;
block|}
comment|/* Create the child device with the given unit number. */
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"acpi_ec"
argument_list|,
name|ecdt
operator|->
name|Uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't add child\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find and save the ACPI handle for this device. */
name|status
operator|=
name|AcpiGetHandle
argument_list|(
name|NULL
argument_list|,
name|ecdt
operator|->
name|Id
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_delete_child
argument_list|(
name|parent
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: can't get handle\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|acpi_set_handle
argument_list|(
name|child
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Set the data and CSR register addresses. */
name|bus_set_resource
argument_list|(
name|child
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|ecdt
operator|->
name|Data
operator|.
name|Address
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|bus_set_resource
argument_list|(
name|child
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|1
argument_list|,
name|ecdt
operator|->
name|Control
operator|.
name|Address
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Store values for the probe/attach routines to use.  Store the      * ECDT GPE bit and set the global lock flag according to _GLK.      * Note that it is not perfectly correct to be evaluating a method      * before initializing devices, but in practice this function      * should be safe to call at this point.      */
name|params
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_ec_params
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|params
operator|->
name|gpe_handle
operator|=
name|NULL
expr_stmt|;
name|params
operator|->
name|gpe_bit
operator|=
name|ecdt
operator|->
name|Gpe
expr_stmt|;
name|params
operator|->
name|uid
operator|=
name|ecdt
operator|->
name|Uid
expr_stmt|;
name|acpi_GetInteger
argument_list|(
name|h
argument_list|,
literal|"_GLK"
argument_list|,
operator|&
name|params
operator|->
name|glk
argument_list|)
expr_stmt|;
name|acpi_set_private
argument_list|(
name|child
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Finish the attach process. */
if|if
condition|(
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
operator|!=
literal|0
condition|)
name|device_delete_child
argument_list|(
name|parent
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_ec_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|obj
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|device_t
name|peer
decl_stmt|;
name|char
name|desc
index|[
literal|64
index|]
decl_stmt|;
name|int
name|ecdt
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|acpi_ec_params
modifier|*
name|params
decl_stmt|;
specifier|static
name|char
modifier|*
name|ec_ids
index|[]
init|=
block|{
literal|"PNP0C09"
block|,
name|NULL
block|}
decl_stmt|;
comment|/* Check that this is a device and that EC is not disabled. */
if|if
condition|(
name|acpi_get_type
argument_list|(
name|dev
argument_list|)
operator|!=
name|ACPI_TYPE_DEVICE
operator|||
name|acpi_disabled
argument_list|(
literal|"ec"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*      * If probed via ECDT, set description and continue.  Otherwise,      * we can access the namespace and make sure this is not a      * duplicate probe.      */
name|ret
operator|=
name|ENXIO
expr_stmt|;
name|ecdt
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|params
operator|=
name|acpi_get_private
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|!=
name|NULL
condition|)
block|{
name|ecdt
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|acpi_disabled
argument_list|(
literal|"ec"
argument_list|)
operator|&&
name|ACPI_ID_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|ec_ids
argument_list|)
condition|)
block|{
name|params
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|acpi_ec_params
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|h
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Read the unit ID to check for duplicate attach and the 	 * global lock value to see if we should acquire it when 	 * accessing the EC. 	 */
name|status
operator|=
name|acpi_GetInteger
argument_list|(
name|h
argument_list|,
literal|"_UID"
argument_list|,
operator|&
name|params
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
name|params
operator|->
name|uid
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|acpi_GetInteger
argument_list|(
name|h
argument_list|,
literal|"_GLK"
argument_list|,
operator|&
name|params
operator|->
name|glk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
name|params
operator|->
name|glk
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Evaluate the _GPE method to find the GPE bit used by the EC to 	 * signal status (SCI).  If it's a package, it contains a reference 	 * and GPE bit, similar to _PRW. 	 */
name|status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|h
argument_list|,
literal|"_GPE"
argument_list|,
name|NULL
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't evaluate _GPE - %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|obj
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|buf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|obj
operator|->
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_INTEGER
case|:
name|params
operator|->
name|gpe_handle
operator|=
name|NULL
expr_stmt|;
name|params
operator|->
name|gpe_bit
operator|=
name|obj
operator|->
name|Integer
operator|.
name|Value
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_PACKAGE
case|:
if|if
condition|(
operator|!
name|ACPI_PKG_VALID
argument_list|(
name|obj
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|params
operator|->
name|gpe_handle
operator|=
name|acpi_GetReference
argument_list|(
name|NULL
argument_list|,
operator|&
name|obj
operator|->
name|Package
operator|.
name|Elements
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|gpe_handle
operator|==
name|NULL
operator|||
name|acpi_PkgInt32
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|,
operator|&
name|params
operator|->
name|gpe_bit
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"_GPE has invalid type %d\n"
argument_list|,
name|obj
operator|->
name|Type
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Store the values we got from the namespace for attach. */
name|acpi_set_private
argument_list|(
name|dev
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* 	 * Check for a duplicate probe.  This can happen when a probe 	 * via ECDT succeeded already.  If this is a duplicate, disable 	 * this device. 	 */
name|peer
operator|=
name|devclass_get_device
argument_list|(
name|acpi_ec_devclass
argument_list|,
name|params
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|NULL
operator|||
operator|!
name|device_is_alive
argument_list|(
name|peer
argument_list|)
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
name|device_disable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
literal|"Embedded Controller: GPE %#x%s%s"
argument_list|,
name|params
operator|->
name|gpe_bit
argument_list|,
operator|(
name|params
operator|->
name|glk
operator|)
condition|?
literal|", GLK"
else|:
literal|""
argument_list|,
name|ecdt
condition|?
literal|", ECDT"
else|:
literal|""
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|>
literal|0
operator|&&
name|params
condition|)
name|free
argument_list|(
name|params
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|Pointer
condition|)
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_ec_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|acpi_ec_params
modifier|*
name|params
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/* Fetch/initialize softc (assumes softc is pre-zeroed). */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|params
operator|=
name|acpi_get_private
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|ec_handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Retrieve previously probed values via device ivars. */
name|sc
operator|->
name|ec_glk
operator|=
name|params
operator|->
name|glk
expr_stmt|;
name|sc
operator|->
name|ec_gpebit
operator|=
name|params
operator|->
name|gpe_bit
expr_stmt|;
name|sc
operator|->
name|ec_gpehandle
operator|=
name|params
operator|->
name|gpe_handle
expr_stmt|;
name|sc
operator|->
name|ec_uid
operator|=
name|params
operator|->
name|uid
expr_stmt|;
name|sc
operator|->
name|ec_suspending
operator|=
name|FALSE
expr_stmt|;
name|free
argument_list|(
name|params
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
comment|/* Attach bus resources for data and command/status ports. */
name|sc
operator|->
name|ec_data_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ec_data_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|ec_data_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_data_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't allocate data port\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|sc
operator|->
name|ec_data_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|ec_data_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_data_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|ec_data_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_csr_rid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|ec_csr_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|ec_csr_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_csr_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't allocate command/status port\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|sc
operator|->
name|ec_csr_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|ec_csr_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_csr_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|ec_csr_res
argument_list|)
expr_stmt|;
comment|/*      * Install a handler for this EC's GPE bit.  We want edge-triggered      * behavior.      */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_RESOURCES
operator|,
literal|"attaching GPE handler\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiInstallGpeHandler
argument_list|(
name|sc
operator|->
name|ec_gpehandle
argument_list|,
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_GPE_EDGE_TRIGGERED
argument_list|,
operator|&
name|EcGpeHandler
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't install GPE handler for %s - %s\n"
argument_list|,
name|acpi_name
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|)
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/*      * Install address space handler      */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_RESOURCES
operator|,
literal|"attaching address space handler\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiInstallAddressSpaceHandler
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|,
name|ACPI_ADR_SPACE_EC
argument_list|,
operator|&
name|EcSpaceHandler
argument_list|,
operator|&
name|EcSpaceSetup
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't install address space handler for %s - %s\n"
argument_list|,
name|acpi_name
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|)
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Enable runtime GPEs for the handler. */
name|Status
operator|=
name|AcpiSetGpeType
argument_list|(
name|sc
operator|->
name|ec_gpehandle
argument_list|,
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_GPE_TYPE_RUNTIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AcpiSetGpeType failed: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|Status
operator|=
name|AcpiEnableGpe
argument_list|(
name|sc
operator|->
name|ec_gpehandle
argument_list|,
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_NOT_ISR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AcpiEnableGpe failed: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_RESOURCES
operator|,
literal|"acpi_ec_attach complete\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|AcpiRemoveGpeHandler
argument_list|(
name|sc
operator|->
name|ec_gpehandle
argument_list|,
name|sc
operator|->
name|ec_gpebit
argument_list|,
operator|&
name|EcGpeHandler
argument_list|)
expr_stmt|;
name|AcpiRemoveAddressSpaceHandler
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|,
name|ACPI_ADR_SPACE_EC
argument_list|,
name|EcSpaceHandler
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_csr_res
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|ec_csr_rid
argument_list|,
name|sc
operator|->
name|ec_csr_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_data_res
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|ec_data_rid
argument_list|,
name|sc
operator|->
name|ec_data_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_ec_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_suspending
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_ec_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_suspending
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_ec_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
decl_stmt|;
comment|/* Disable the GPE so we don't get EC events during shutdown. */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|AcpiDisableGpe
argument_list|(
name|sc
operator|->
name|ec_gpehandle
argument_list|,
name|sc
operator|->
name|ec_gpebit
argument_list|,
name|ACPI_NOT_ISR
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Methods to allow other devices (e.g., smbat) to read/write EC space. */
end_comment

begin_function
specifier|static
name|int
name|acpi_ec_read_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|ACPI_INTEGER
modifier|*
name|val
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|status
operator|=
name|EcSpaceHandler
argument_list|(
name|ACPI_READ
argument_list|,
name|addr
argument_list|,
name|width
operator|*
literal|8
argument_list|,
name|val
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acpi_ec_write_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|ACPI_INTEGER
name|val
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|status
operator|=
name|EcSpaceHandler
argument_list|(
name|ACPI_WRITE
argument_list|,
name|addr
argument_list|,
name|width
operator|*
literal|8
argument_list|,
operator|&
name|val
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|EcGpeQueryHandler
parameter_list|(
name|void
modifier|*
name|Context
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_ec_softc
operator|*
operator|)
name|Context
decl_stmt|;
name|UINT8
name|Data
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|char
name|qxx
index|[
literal|5
index|]
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|Context
operator|!=
name|NULL
argument_list|,
operator|(
literal|"EcGpeQueryHandler called with NULL"
operator|)
argument_list|)
expr_stmt|;
comment|/* Serialize user access with EcSpaceHandler(). */
name|Status
operator|=
name|EcLock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
literal|"GpeQuery lock error: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Send a query command to the EC to find out which _Qxx call it      * wants to make.  This command clears the SCI bit and also the      * interrupt source since we are edge-triggered.  To prevent the GPE      * that may arise from running the query from causing another query      * to be queued, we clear the pending flag only after running it.      */
name|Status
operator|=
name|EcCommand
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_QUERY
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_sci_pend
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|EcUnlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
literal|"GPE query failed: %s\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|Data
operator|=
name|EC_GET_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * We have to unlock before running the _Qxx method below since that      * method may attempt to read/write from EC address space, causing      * recursive acquisition of the lock.      */
name|EcUnlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Ignore the value for "no outstanding event". (13.3.5) */
name|CTR2
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec query ok,%s running _Q%02X"
argument_list|,
name|Data
condition|?
literal|""
else|:
literal|" not"
argument_list|,
name|Data
argument_list|)
expr_stmt|;
if|if
condition|(
name|Data
operator|==
literal|0
condition|)
return|return;
comment|/* Evaluate _Qxx to respond to the controller. */
name|snprintf
argument_list|(
name|qxx
argument_list|,
sizeof|sizeof
argument_list|(
name|qxx
argument_list|)
argument_list|,
literal|"_Q%02X"
argument_list|,
name|Data
argument_list|)
expr_stmt|;
name|AcpiUtStrupr
argument_list|(
name|qxx
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|sc
operator|->
name|ec_handle
argument_list|,
name|qxx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
operator|&&
name|Status
operator|!=
name|AE_NOT_FOUND
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
literal|"evaluation of query method %s failed: %s\n"
argument_list|,
name|qxx
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The GPE handler is called when IBE/OBF or SCI events occur.  We are  * called from an unknown lock context.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|EcGpeHandler
parameter_list|(
name|void
modifier|*
name|Context
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
init|=
name|Context
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|EC_STATUS
name|EcStatus
decl_stmt|;
name|KASSERT
argument_list|(
name|Context
operator|!=
name|NULL
argument_list|,
operator|(
literal|"EcGpeHandler called with NULL"
operator|)
argument_list|)
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec gpe handler start"
argument_list|)
expr_stmt|;
comment|/*      * Notify EcWaitEvent() that the status register is now fresh.  If we      * didn't do this, it wouldn't be possible to distinguish an old IBE      * from a new one, for example when doing a write transaction (writing      * address and then data values.)      */
name|atomic_add_int
argument_list|(
operator|&
name|sc
operator|->
name|ec_gencount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|ec_gencount
argument_list|)
expr_stmt|;
comment|/*      * If the EC_SCI bit of the status register is set, queue a query handler.      * It will run the query and _Qxx method later, under the lock.      */
name|EcStatus
operator|=
name|EC_GET_CSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|EcStatus
operator|&
name|EC_EVENT_SCI
operator|)
operator|&&
operator|!
name|sc
operator|->
name|ec_sci_pend
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec gpe queueing query handler"
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiOsExecute
argument_list|(
name|OSL_GPE_HANDLER
argument_list|,
name|EcGpeQueryHandler
argument_list|,
name|Context
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|Status
argument_list|)
condition|)
name|sc
operator|->
name|ec_sci_pend
operator|=
name|TRUE
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"EcGpeHandler: queuing GPE query handler failed\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcSpaceSetup
parameter_list|(
name|ACPI_HANDLE
name|Region
parameter_list|,
name|UINT32
name|Function
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|RegionContext
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
comment|/*      * If deactivating a region, always set the output to NULL.  Otherwise,      * just pass the context through.      */
if|if
condition|(
name|Function
operator|==
name|ACPI_REGION_DEACTIVATE
condition|)
operator|*
name|RegionContext
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|RegionContext
operator|=
name|Context
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcSpaceHandler
parameter_list|(
name|UINT32
name|Function
parameter_list|,
name|ACPI_PHYSICAL_ADDRESS
name|Address
parameter_list|,
name|UINT32
name|width
parameter_list|,
name|ACPI_INTEGER
modifier|*
name|Value
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
name|RegionContext
parameter_list|)
block|{
name|struct
name|acpi_ec_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|acpi_ec_softc
operator|*
operator|)
name|Context
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|UINT8
name|EcAddr
decl_stmt|,
name|EcData
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ACPI_FUNCTION_TRACE_U32
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|,
operator|(
name|UINT32
operator|)
name|Address
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|%
literal|8
operator|!=
literal|0
operator|||
name|Value
operator|==
name|NULL
operator|||
name|Context
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
if|if
condition|(
name|Address
operator|+
operator|(
name|width
operator|/
literal|8
operator|)
operator|-
literal|1
operator|>
literal|0xFF
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|Function
operator|==
name|ACPI_READ
condition|)
operator|*
name|Value
operator|=
literal|0
expr_stmt|;
name|EcAddr
operator|=
name|Address
expr_stmt|;
name|Status
operator|=
name|AE_ERROR
expr_stmt|;
comment|/*      * If booting, check if we need to run the query handler.  If so, we      * we call it directly here since our thread taskq is not active yet.      */
if|if
condition|(
name|cold
operator|||
name|rebooting
condition|)
block|{
if|if
condition|(
operator|(
name|EC_GET_CSR
argument_list|(
name|sc
argument_list|)
operator|&
name|EC_EVENT_SCI
operator|)
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec running gpe handler directly"
argument_list|)
expr_stmt|;
name|EcGpeQueryHandler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Serialize with EcGpeQueryHandler() at transaction granularity. */
name|Status
operator|=
name|EcLock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
comment|/* Perform the transaction(s), based on width. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|+=
literal|8
operator|,
name|EcAddr
operator|++
control|)
block|{
switch|switch
condition|(
name|Function
condition|)
block|{
case|case
name|ACPI_READ
case|:
name|Status
operator|=
name|EcRead
argument_list|(
name|sc
argument_list|,
name|EcAddr
argument_list|,
operator|&
name|EcData
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|Status
argument_list|)
condition|)
operator|*
name|Value
operator||=
operator|(
operator|(
name|ACPI_INTEGER
operator|)
name|EcData
operator|)
operator|<<
name|i
expr_stmt|;
break|break;
case|case
name|ACPI_WRITE
case|:
name|EcData
operator|=
call|(
name|UINT8
call|)
argument_list|(
operator|(
operator|*
name|Value
operator|)
operator|>>
name|i
argument_list|)
expr_stmt|;
name|Status
operator|=
name|EcWrite
argument_list|(
name|sc
argument_list|,
name|EcAddr
argument_list|,
operator|&
name|EcData
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
literal|"invalid EcSpaceHandler function %d\n"
argument_list|,
name|Function
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AE_BAD_PARAMETER
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
break|break;
block|}
name|EcUnlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcCheckStatus
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|EC_EVENT
name|event
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|EC_STATUS
name|ec_status
decl_stmt|;
name|status
operator|=
name|AE_NO_HARDWARE_RESPONSE
expr_stmt|;
name|ec_status
operator|=
name|EC_GET_CSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_burstactive
operator|&&
operator|!
operator|(
name|ec_status
operator|&
name|EC_FLAG_BURST_MODE
operator|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec burst disabled in waitevent (%s)"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_burstactive
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|EVENT_READY
argument_list|(
name|event
argument_list|,
name|ec_status
argument_list|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec %s wait ready, status %#x"
argument_list|,
name|msg
argument_list|,
name|ec_status
argument_list|)
expr_stmt|;
name|status
operator|=
name|AE_OK
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcWaitEvent
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|EC_EVENT
name|Event
parameter_list|,
name|u_int
name|gen_count
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|slp_ival
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|ec
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AE_NO_HARDWARE_RESPONSE
expr_stmt|;
name|int
name|need_poll
init|=
name|cold
operator|||
name|rebooting
operator|||
name|ec_polled_mode
operator|||
name|sc
operator|->
name|ec_suspending
decl_stmt|;
comment|/*      * The main CPU should be much faster than the EC.  So the status should      * be "not ready" when we start waiting.  But if the main CPU is really      * slow, it's possible we see the current "ready" response.  Since that      * can't be distinguished from the previous response in polled mode,      * this is a potential issue.  We really should have interrupts enabled      * during boot so there is no ambiguity in polled mode.      *      * If this occurs, we add an additional delay before actually entering      * the status checking loop, hopefully to allow the EC to go to work      * and produce a non-stale status.      */
if|if
condition|(
name|need_poll
condition|)
block|{
specifier|static
name|int
name|once
decl_stmt|;
if|if
condition|(
name|EcCheckStatus
argument_list|(
name|sc
argument_list|,
literal|"pre-check"
argument_list|,
name|Event
argument_list|)
operator|==
name|AE_OK
condition|)
block|{
if|if
condition|(
operator|!
name|once
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
literal|"warning: EC done before starting event wait\n"
argument_list|)
expr_stmt|;
name|once
operator|=
literal|1
expr_stmt|;
block|}
name|AcpiOsStall
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Wait for event by polling or GPE (interrupt). */
if|if
condition|(
name|need_poll
condition|)
block|{
name|count
operator|=
operator|(
name|ec_timeout
operator|*
literal|1000
operator|)
operator|/
name|EC_POLL_DELAY
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|Status
operator|=
name|EcCheckStatus
argument_list|(
name|sc
argument_list|,
literal|"poll"
argument_list|,
name|Event
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|==
name|AE_OK
condition|)
break|break;
name|AcpiOsStall
argument_list|(
name|EC_POLL_DELAY
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|slp_ival
operator|=
name|hz
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|slp_ival
operator|!=
literal|0
condition|)
block|{
name|count
operator|=
name|ec_timeout
expr_stmt|;
block|}
else|else
block|{
comment|/* hz has less than 1 ms resolution so scale timeout. */
name|slp_ival
operator|=
literal|1
expr_stmt|;
name|count
operator|=
name|ec_timeout
operator|/
operator|(
literal|1000
operator|/
name|hz
operator|)
expr_stmt|;
block|}
comment|/* 	 * Wait for the GPE to signal the status changed, checking the 	 * status register each time we get one.  It's possible to get a 	 * GPE for an event we're not interested in here (i.e., SCI for 	 * EC query). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gen_count
operator|!=
name|sc
operator|->
name|ec_gencount
condition|)
block|{
comment|/* 		 * Record new generation count.  It's possible the GPE was 		 * just to notify us that a query is needed and we need to 		 * wait for a second GPE to signal the completion of the 		 * event we are actually waiting for. 		 */
name|gen_count
operator|=
name|sc
operator|->
name|ec_gencount
expr_stmt|;
name|Status
operator|=
name|EcCheckStatus
argument_list|(
name|sc
argument_list|,
literal|"sleep"
argument_list|,
name|Event
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|==
name|AE_OK
condition|)
break|break;
block|}
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|ec_gencount
argument_list|,
name|PZERO
argument_list|,
literal|"ecgpe"
argument_list|,
name|slp_ival
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We finished waiting for the GPE and it never arrived.  Try to 	 * read the register once and trust whatever value we got.  This is 	 * the best we can do at this point.  Then, force polled mode on 	 * since this system doesn't appear to generate GPEs. 	 */
if|if
condition|(
name|Status
operator|!=
name|AE_OK
condition|)
block|{
name|Status
operator|=
name|EcCheckStatus
argument_list|(
name|sc
argument_list|,
literal|"sleep_end"
argument_list|,
name|Event
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
literal|"wait timed out (%sresponse), forcing polled mode\n"
argument_list|,
name|Status
operator|==
name|AE_OK
condition|?
literal|""
else|:
literal|"no "
argument_list|)
expr_stmt|;
name|ec_polled_mode
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Status
operator|!=
name|AE_OK
condition|)
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"error: ec wait timed out"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcCommand
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|EC_COMMAND
name|cmd
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|EC_EVENT
name|event
decl_stmt|;
name|EC_STATUS
name|ec_status
decl_stmt|;
name|u_int
name|gen_count
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|ec
argument_list|)
expr_stmt|;
comment|/* Don't use burst mode if user disabled it. */
if|if
condition|(
operator|!
name|ec_burst_mode
operator|&&
name|cmd
operator|==
name|EC_COMMAND_BURST_ENABLE
condition|)
return|return
operator|(
name|AE_ERROR
operator|)
return|;
comment|/* Decide what to wait for based on command type. */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|EC_COMMAND_READ
case|:
case|case
name|EC_COMMAND_WRITE
case|:
case|case
name|EC_COMMAND_BURST_DISABLE
case|:
name|event
operator|=
name|EC_EVENT_INPUT_BUFFER_EMPTY
expr_stmt|;
break|break;
case|case
name|EC_COMMAND_QUERY
case|:
case|case
name|EC_COMMAND_BURST_ENABLE
case|:
name|event
operator|=
name|EC_EVENT_OUTPUT_BUFFER_FULL
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
literal|"EcCommand: invalid command %#x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
block|}
comment|/* Run the command and wait for the chosen event. */
name|CTR1
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec running command %#x"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|gen_count
operator|=
name|sc
operator|->
name|ec_gencount
expr_stmt|;
name|EC_SET_CSR
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|status
operator|=
name|EcWaitEvent
argument_list|(
name|sc
argument_list|,
name|event
argument_list|,
name|gen_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* If we succeeded, burst flag should now be present. */
if|if
condition|(
name|cmd
operator|==
name|EC_COMMAND_BURST_ENABLE
condition|)
block|{
name|ec_status
operator|=
name|EC_GET_CSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ec_status
operator|&
name|EC_FLAG_BURST_MODE
operator|)
operator|==
literal|0
condition|)
name|status
operator|=
name|AE_ERROR
expr_stmt|;
block|}
block|}
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
literal|"EcCommand: no response to %#x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcRead
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|UINT8
name|Address
parameter_list|,
name|UINT8
modifier|*
name|Data
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|UINT8
name|data
decl_stmt|;
name|u_int
name|gen_count
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|ec
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec read from %#x"
argument_list|,
name|Address
argument_list|)
expr_stmt|;
comment|/* If we can't start burst mode, continue anyway. */
name|status
operator|=
name|EcCommand
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_BURST_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|AE_OK
condition|)
block|{
name|data
operator|=
name|EC_GET_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|EC_BURST_ACK
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec burst enabled"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_burstactive
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|status
operator|=
name|EcCommand
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|gen_count
operator|=
name|sc
operator|->
name|ec_gencount
expr_stmt|;
name|EC_SET_DATA
argument_list|(
name|sc
argument_list|,
name|Address
argument_list|)
expr_stmt|;
name|status
operator|=
name|EcWaitEvent
argument_list|(
name|sc
argument_list|,
name|EC_EVENT_OUTPUT_BUFFER_FULL
argument_list|,
name|gen_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
literal|"EcRead: failed waiting to get data\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
operator|*
name|Data
operator|=
name|EC_GET_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ec_burstactive
condition|)
block|{
name|sc
operator|->
name|ec_burstactive
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|EcCommand
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_BURST_DISABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec disabled burst ok"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|EcWrite
parameter_list|(
name|struct
name|acpi_ec_softc
modifier|*
name|sc
parameter_list|,
name|UINT8
name|Address
parameter_list|,
name|UINT8
modifier|*
name|Data
parameter_list|)
block|{
name|ACPI_STATUS
name|status
decl_stmt|;
name|UINT8
name|data
decl_stmt|;
name|u_int
name|gen_count
decl_stmt|;
name|ACPI_SERIAL_ASSERT
argument_list|(
name|ec
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec write to %#x, data %#x"
argument_list|,
name|Address
argument_list|,
operator|*
name|Data
argument_list|)
expr_stmt|;
comment|/* If we can't start burst mode, continue anyway. */
name|status
operator|=
name|EcCommand
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_BURST_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|AE_OK
condition|)
block|{
name|data
operator|=
name|EC_GET_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|EC_BURST_ACK
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec burst enabled"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ec_burstactive
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|status
operator|=
name|EcCommand
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|gen_count
operator|=
name|sc
operator|->
name|ec_gencount
expr_stmt|;
name|EC_SET_DATA
argument_list|(
name|sc
argument_list|,
name|Address
argument_list|)
expr_stmt|;
name|status
operator|=
name|EcWaitEvent
argument_list|(
name|sc
argument_list|,
name|EC_EVENT_INPUT_BUFFER_EMPTY
argument_list|,
name|gen_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
literal|"EcRead: failed waiting for sent address\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|gen_count
operator|=
name|sc
operator|->
name|ec_gencount
expr_stmt|;
name|EC_SET_DATA
argument_list|(
name|sc
argument_list|,
operator|*
name|Data
argument_list|)
expr_stmt|;
name|status
operator|=
name|EcWaitEvent
argument_list|(
name|sc
argument_list|,
name|EC_EVENT_INPUT_BUFFER_EMPTY
argument_list|,
name|gen_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|ec_dev
argument_list|,
literal|"EcWrite: failed waiting for sent data\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|ec_burstactive
condition|)
block|{
name|sc
operator|->
name|ec_burstactive
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|EcCommand
argument_list|(
name|sc
argument_list|,
name|EC_COMMAND_BURST_DISABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|CTR0
argument_list|(
name|KTR_ACPI
argument_list|,
literal|"ec disabled burst ok"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

end_unit

