begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Michael Smith  * Copyright (c) 2000 BSDi  * Copyright (c) 2007-2009 Jung-uk Kim<jkim@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * 6.1 : Mutual Exclusion and Synchronisation  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_OS_SERVICES
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"SYNCH"
argument_list|)
end_macro

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_ACPISEM
argument_list|,
literal|"acpisem"
argument_list|,
literal|"ACPI semaphore"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Convert milliseconds to ticks.  */
end_comment

begin_function
specifier|static
name|int
name|timeout2hz
parameter_list|(
name|UINT16
name|Timeout
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
call|(
name|time_t
call|)
argument_list|(
name|Timeout
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
call|(
name|suseconds_t
call|)
argument_list|(
name|Timeout
operator|%
literal|1000
argument_list|)
operator|*
literal|1000
expr_stmt|;
return|return
operator|(
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ACPI_SEMAPHORE  */
end_comment

begin_struct
struct|struct
name|acpi_sema
block|{
name|struct
name|mtx
name|as_lock
decl_stmt|;
name|char
name|as_name
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|cv
name|as_cv
decl_stmt|;
name|UINT32
name|as_maxunits
decl_stmt|;
name|UINT32
name|as_units
decl_stmt|;
name|int
name|as_waiters
decl_stmt|;
name|int
name|as_reset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|ACPI_STATUS
name|AcpiOsCreateSemaphore
parameter_list|(
name|UINT32
name|MaxUnits
parameter_list|,
name|UINT32
name|InitialUnits
parameter_list|,
name|ACPI_SEMAPHORE
modifier|*
name|OutHandle
parameter_list|)
block|{
name|struct
name|acpi_sema
modifier|*
name|as
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|OutHandle
operator|==
name|NULL
operator|||
name|MaxUnits
operator|==
literal|0
operator|||
name|InitialUnits
operator|>
name|MaxUnits
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|as
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|as
argument_list|)
argument_list|,
name|M_ACPISEM
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_NO_MEMORY
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|as
operator|->
name|as_name
argument_list|,
sizeof|sizeof
argument_list|(
name|as
operator|->
name|as_name
argument_list|)
argument_list|,
literal|"ACPI sema (%p)"
argument_list|,
name|as
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|as
operator|->
name|as_lock
argument_list|,
name|as
operator|->
name|as_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|as
operator|->
name|as_cv
argument_list|,
name|as
operator|->
name|as_name
argument_list|)
expr_stmt|;
name|as
operator|->
name|as_maxunits
operator|=
name|MaxUnits
expr_stmt|;
name|as
operator|->
name|as_units
operator|=
name|InitialUnits
expr_stmt|;
operator|*
name|OutHandle
operator|=
operator|(
name|ACPI_SEMAPHORE
operator|)
name|as
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"created %s, max %u, initial %u\n"
operator|,
name|as
operator|->
name|as_name
operator|,
name|MaxUnits
operator|,
name|InitialUnits
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ACPI_STATUS
name|AcpiOsDeleteSemaphore
parameter_list|(
name|ACPI_SEMAPHORE
name|Handle
parameter_list|)
block|{
name|struct
name|acpi_sema
modifier|*
name|as
init|=
operator|(
expr|struct
name|acpi_sema
operator|*
operator|)
name|Handle
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|as
operator|->
name|as_lock
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"delete %s\n"
operator|,
name|as
operator|->
name|as_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|as_waiters
operator|>
literal|0
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"reset %s, units %u, waiters %d\n"
operator|,
name|as
operator|->
name|as_name
operator|,
name|as
operator|->
name|as_units
operator|,
name|as
operator|->
name|as_waiters
operator|)
argument_list|)
expr_stmt|;
name|as
operator|->
name|as_reset
operator|=
literal|1
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|as
operator|->
name|as_cv
argument_list|)
expr_stmt|;
while|while
condition|(
name|as
operator|->
name|as_waiters
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mtx_sleep
argument_list|(
operator|&
name|as
operator|->
name|as_reset
argument_list|,
operator|&
name|as
operator|->
name|as_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"acsrst"
argument_list|,
name|hz
argument_list|)
operator|==
name|EINTR
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"failed to reset %s, waiters %d\n"
operator|,
name|as
operator|->
name|as_name
operator|,
name|as
operator|->
name|as_waiters
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|as
operator|->
name|as_lock
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_ERROR
argument_list|)
expr_stmt|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"wait %s, units %u, waiters %d\n"
operator|,
name|as
operator|->
name|as_name
operator|,
name|as
operator|->
name|as_units
operator|,
name|as
operator|->
name|as_waiters
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|as
operator|->
name|as_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|as
operator|->
name|as_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|as
operator|->
name|as_cv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|as
argument_list|,
name|M_ACPISEM
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ACPISEM_AVAIL
parameter_list|(
name|s
parameter_list|,
name|u
parameter_list|)
value|((s)->as_units>= (u))
end_define

begin_function
name|ACPI_STATUS
name|AcpiOsWaitSemaphore
parameter_list|(
name|ACPI_SEMAPHORE
name|Handle
parameter_list|,
name|UINT32
name|Units
parameter_list|,
name|UINT16
name|Timeout
parameter_list|)
block|{
name|struct
name|acpi_sema
modifier|*
name|as
init|=
operator|(
expr|struct
name|acpi_sema
operator|*
operator|)
name|Handle
decl_stmt|;
name|int
name|error
decl_stmt|,
name|prevtick
decl_stmt|,
name|slptick
decl_stmt|,
name|tmo
decl_stmt|;
name|ACPI_STATUS
name|status
init|=
name|AE_OK
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|==
name|NULL
operator|||
name|Units
operator|==
literal|0
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|as
operator|->
name|as_lock
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"get %u unit(s) from %s, units %u, waiters %d, timeout %u\n"
operator|,
name|Units
operator|,
name|as
operator|->
name|as_name
operator|,
name|as
operator|->
name|as_units
operator|,
name|as
operator|->
name|as_waiters
operator|,
name|Timeout
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|as_maxunits
operator|!=
name|ACPI_NO_UNIT_LIMIT
operator|&&
name|as
operator|->
name|as_maxunits
operator|<
name|Units
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|as
operator|->
name|as_lock
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_LIMIT
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|Timeout
condition|)
block|{
case|case
name|ACPI_DO_NOT_WAIT
case|:
if|if
condition|(
operator|!
name|ACPISEM_AVAIL
argument_list|(
name|as
argument_list|,
name|Units
argument_list|)
condition|)
name|status
operator|=
name|AE_TIME
expr_stmt|;
break|break;
case|case
name|ACPI_WAIT_FOREVER
case|:
while|while
condition|(
operator|!
name|ACPISEM_AVAIL
argument_list|(
name|as
argument_list|,
name|Units
argument_list|)
condition|)
block|{
name|as
operator|->
name|as_waiters
operator|++
expr_stmt|;
name|error
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|as
operator|->
name|as_cv
argument_list|,
operator|&
name|as
operator|->
name|as_lock
argument_list|)
expr_stmt|;
name|as
operator|->
name|as_waiters
operator|--
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|as
operator|->
name|as_reset
condition|)
block|{
name|status
operator|=
name|AE_ERROR
expr_stmt|;
break|break;
block|}
block|}
break|break;
default|default:
name|tmo
operator|=
name|timeout2hz
argument_list|(
name|Timeout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ACPISEM_AVAIL
argument_list|(
name|as
argument_list|,
name|Units
argument_list|)
condition|)
block|{
name|prevtick
operator|=
name|ticks
expr_stmt|;
name|as
operator|->
name|as_waiters
operator|++
expr_stmt|;
name|error
operator|=
name|cv_timedwait_sig
argument_list|(
operator|&
name|as
operator|->
name|as_cv
argument_list|,
operator|&
name|as
operator|->
name|as_lock
argument_list|,
name|tmo
argument_list|)
expr_stmt|;
name|as
operator|->
name|as_waiters
operator|--
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|as
operator|->
name|as_reset
condition|)
block|{
name|status
operator|=
name|AE_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ACPISEM_AVAIL
argument_list|(
name|as
argument_list|,
name|Units
argument_list|)
condition|)
break|break;
name|slptick
operator|=
name|ticks
operator|-
name|prevtick
expr_stmt|;
if|if
condition|(
name|slptick
operator|>=
name|tmo
operator|||
name|slptick
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|AE_TIME
expr_stmt|;
break|break;
block|}
name|tmo
operator|-=
name|slptick
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
name|as
operator|->
name|as_units
operator|-=
name|Units
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|as
operator|->
name|as_lock
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ACPI_STATUS
name|AcpiOsSignalSemaphore
parameter_list|(
name|ACPI_SEMAPHORE
name|Handle
parameter_list|,
name|UINT32
name|Units
parameter_list|)
block|{
name|struct
name|acpi_sema
modifier|*
name|as
init|=
operator|(
expr|struct
name|acpi_sema
operator|*
operator|)
name|Handle
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|==
name|NULL
operator|||
name|Units
operator|==
literal|0
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|as
operator|->
name|as_lock
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"return %u units to %s, units %u, waiters %d\n"
operator|,
name|Units
operator|,
name|as
operator|->
name|as_name
operator|,
name|as
operator|->
name|as_units
operator|,
name|as
operator|->
name|as_waiters
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|as_maxunits
operator|!=
name|ACPI_NO_UNIT_LIMIT
operator|&&
operator|(
name|as
operator|->
name|as_maxunits
operator|<
name|Units
operator|||
name|as
operator|->
name|as_maxunits
operator|-
name|Units
operator|<
name|as
operator|->
name|as_units
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"exceeded max units %u\n"
operator|,
name|as
operator|->
name|as_maxunits
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|as
operator|->
name|as_lock
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_LIMIT
argument_list|)
expr_stmt|;
block|}
name|as
operator|->
name|as_units
operator|+=
name|Units
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|as_waiters
operator|>
literal|0
operator|&&
name|ACPISEM_AVAIL
argument_list|(
name|as
argument_list|,
name|Units
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Units
condition|;
name|i
operator|++
control|)
name|cv_signal
argument_list|(
operator|&
name|as
operator|->
name|as_cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|as
operator|->
name|as_lock
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|ACPISEM_AVAIL
end_undef

begin_comment
comment|/*  * ACPI_MUTEX  */
end_comment

begin_struct
struct|struct
name|acpi_mutex
block|{
name|struct
name|mtx
name|am_lock
decl_stmt|;
name|char
name|am_name
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|thread
modifier|*
name|am_owner
decl_stmt|;
name|int
name|am_nested
decl_stmt|;
name|int
name|am_waiters
decl_stmt|;
name|int
name|am_reset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|ACPI_STATUS
name|AcpiOsCreateMutex
parameter_list|(
name|ACPI_MUTEX
modifier|*
name|OutHandle
parameter_list|)
block|{
name|struct
name|acpi_mutex
modifier|*
name|am
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|OutHandle
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|am
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|am
argument_list|)
argument_list|,
name|M_ACPISEM
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_NO_MEMORY
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|am
operator|->
name|am_name
argument_list|,
sizeof|sizeof
argument_list|(
name|am
operator|->
name|am_name
argument_list|)
argument_list|,
literal|"ACPI mutex (%p)"
argument_list|,
name|am
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|am
operator|->
name|am_lock
argument_list|,
name|am
operator|->
name|am_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"created %s\n"
operator|,
name|am
operator|->
name|am_name
operator|)
argument_list|)
expr_stmt|;
operator|*
name|OutHandle
operator|=
operator|(
name|ACPI_MUTEX
operator|)
name|am
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ACPIMTX_AVAIL
parameter_list|(
name|m
parameter_list|)
value|((m)->am_owner == NULL)
end_define

begin_define
define|#
directive|define
name|ACPIMTX_OWNED
parameter_list|(
name|m
parameter_list|)
value|((m)->am_owner == curthread)
end_define

begin_function
name|void
name|AcpiOsDeleteMutex
parameter_list|(
name|ACPI_MUTEX
name|Handle
parameter_list|)
block|{
name|struct
name|acpi_mutex
modifier|*
name|am
init|=
operator|(
expr|struct
name|acpi_mutex
operator|*
operator|)
name|Handle
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|==
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"cannot delete null mutex\n"
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|am
operator|->
name|am_lock
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"delete %s\n"
operator|,
name|am
operator|->
name|am_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|->
name|am_waiters
operator|>
literal|0
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"reset %s, owner %p\n"
operator|,
name|am
operator|->
name|am_name
operator|,
name|am
operator|->
name|am_owner
operator|)
argument_list|)
expr_stmt|;
name|am
operator|->
name|am_reset
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
name|am
argument_list|)
expr_stmt|;
while|while
condition|(
name|am
operator|->
name|am_waiters
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mtx_sleep
argument_list|(
operator|&
name|am
operator|->
name|am_reset
argument_list|,
operator|&
name|am
operator|->
name|am_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"acmrst"
argument_list|,
name|hz
argument_list|)
operator|==
name|EINTR
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"failed to reset %s, waiters %d\n"
operator|,
name|am
operator|->
name|am_name
operator|,
name|am
operator|->
name|am_waiters
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|am
operator|->
name|am_lock
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
if|if
condition|(
name|ACPIMTX_AVAIL
argument_list|(
name|am
argument_list|)
condition|)
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"wait %s, waiters %d\n"
operator|,
name|am
operator|->
name|am_name
operator|,
name|am
operator|->
name|am_waiters
operator|)
argument_list|)
expr_stmt|;
else|else
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"wait %s, owner %p, waiters %d\n"
operator|,
name|am
operator|->
name|am_name
operator|,
name|am
operator|->
name|am_owner
operator|,
name|am
operator|->
name|am_waiters
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|am
operator|->
name|am_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|am
operator|->
name|am_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|am
argument_list|,
name|M_ACPISEM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ACPI_STATUS
name|AcpiOsAcquireMutex
parameter_list|(
name|ACPI_MUTEX
name|Handle
parameter_list|,
name|UINT16
name|Timeout
parameter_list|)
block|{
name|struct
name|acpi_mutex
modifier|*
name|am
init|=
operator|(
expr|struct
name|acpi_mutex
operator|*
operator|)
name|Handle
decl_stmt|;
name|int
name|error
decl_stmt|,
name|prevtick
decl_stmt|,
name|slptick
decl_stmt|,
name|tmo
decl_stmt|;
name|ACPI_STATUS
name|status
init|=
name|AE_OK
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|am
operator|->
name|am_lock
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"acquire %s\n"
operator|,
name|am
operator|->
name|am_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPIMTX_OWNED
argument_list|(
name|am
argument_list|)
condition|)
block|{
name|am
operator|->
name|am_nested
operator|++
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"acquire nested %s, depth %d\n"
operator|,
name|am
operator|->
name|am_name
operator|,
name|am
operator|->
name|am_nested
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|am
operator|->
name|am_lock
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|Timeout
condition|)
block|{
case|case
name|ACPI_DO_NOT_WAIT
case|:
if|if
condition|(
operator|!
name|ACPIMTX_AVAIL
argument_list|(
name|am
argument_list|)
condition|)
name|status
operator|=
name|AE_TIME
expr_stmt|;
break|break;
case|case
name|ACPI_WAIT_FOREVER
case|:
while|while
condition|(
operator|!
name|ACPIMTX_AVAIL
argument_list|(
name|am
argument_list|)
condition|)
block|{
name|am
operator|->
name|am_waiters
operator|++
expr_stmt|;
name|error
operator|=
name|mtx_sleep
argument_list|(
name|am
argument_list|,
operator|&
name|am
operator|->
name|am_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"acmtx"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|am
operator|->
name|am_waiters
operator|--
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|am
operator|->
name|am_reset
condition|)
block|{
name|status
operator|=
name|AE_ERROR
expr_stmt|;
break|break;
block|}
block|}
break|break;
default|default:
name|tmo
operator|=
name|timeout2hz
argument_list|(
name|Timeout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ACPIMTX_AVAIL
argument_list|(
name|am
argument_list|)
condition|)
block|{
name|prevtick
operator|=
name|ticks
expr_stmt|;
name|am
operator|->
name|am_waiters
operator|++
expr_stmt|;
name|error
operator|=
name|mtx_sleep
argument_list|(
name|am
argument_list|,
operator|&
name|am
operator|->
name|am_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"acmtx"
argument_list|,
name|tmo
argument_list|)
expr_stmt|;
name|am
operator|->
name|am_waiters
operator|--
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|am
operator|->
name|am_reset
condition|)
block|{
name|status
operator|=
name|AE_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ACPIMTX_AVAIL
argument_list|(
name|am
argument_list|)
condition|)
break|break;
name|slptick
operator|=
name|ticks
operator|-
name|prevtick
expr_stmt|;
if|if
condition|(
name|slptick
operator|>=
name|tmo
operator|||
name|slptick
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|AE_TIME
expr_stmt|;
break|break;
block|}
name|tmo
operator|-=
name|slptick
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|status
argument_list|)
condition|)
name|am
operator|->
name|am_owner
operator|=
name|curthread
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|am
operator|->
name|am_lock
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|AcpiOsReleaseMutex
parameter_list|(
name|ACPI_MUTEX
name|Handle
parameter_list|)
block|{
name|struct
name|acpi_mutex
modifier|*
name|am
init|=
operator|(
expr|struct
name|acpi_mutex
operator|*
operator|)
name|Handle
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|==
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"cannot release null mutex\n"
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|am
operator|->
name|am_lock
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"release %s\n"
operator|,
name|am
operator|->
name|am_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPIMTX_OWNED
argument_list|(
name|am
argument_list|)
condition|)
block|{
if|if
condition|(
name|am
operator|->
name|am_nested
operator|>
literal|0
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"release nested %s, depth %d\n"
operator|,
name|am
operator|->
name|am_name
operator|,
name|am
operator|->
name|am_nested
operator|)
argument_list|)
expr_stmt|;
name|am
operator|->
name|am_nested
operator|--
expr_stmt|;
block|}
else|else
name|am
operator|->
name|am_owner
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ACPIMTX_AVAIL
argument_list|(
name|am
argument_list|)
condition|)
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"release already available %s\n"
operator|,
name|am
operator|->
name|am_name
operator|)
argument_list|)
expr_stmt|;
else|else
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"release unowned %s from %p, depth %d\n"
operator|,
name|am
operator|->
name|am_name
operator|,
name|am
operator|->
name|am_owner
operator|,
name|am
operator|->
name|am_nested
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|am
operator|->
name|am_waiters
operator|>
literal|0
operator|&&
name|ACPIMTX_AVAIL
argument_list|(
name|am
argument_list|)
condition|)
name|wakeup_one
argument_list|(
name|am
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|am
operator|->
name|am_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|ACPIMTX_AVAIL
end_undef

begin_undef
undef|#
directive|undef
name|ACPIMTX_OWNED
end_undef

begin_comment
comment|/*  * ACPI_SPINLOCK  */
end_comment

begin_struct
struct|struct
name|acpi_spinlock
block|{
name|struct
name|mtx
name|al_lock
decl_stmt|;
name|char
name|al_name
index|[
literal|32
index|]
decl_stmt|;
name|int
name|al_nested
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|ACPI_STATUS
name|AcpiOsCreateLock
parameter_list|(
name|ACPI_SPINLOCK
modifier|*
name|OutHandle
parameter_list|)
block|{
name|struct
name|acpi_spinlock
modifier|*
name|al
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|OutHandle
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|al
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|al
argument_list|)
argument_list|,
name|M_ACPISEM
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|return_ACPI_STATUS
argument_list|(
name|AE_NO_MEMORY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACPI_DEBUG
if|if
condition|(
name|OutHandle
operator|==
operator|&
name|AcpiGbl_GpeLock
condition|)
name|snprintf
argument_list|(
name|al
operator|->
name|al_name
argument_list|,
sizeof|sizeof
argument_list|(
name|al
operator|->
name|al_name
argument_list|)
argument_list|,
literal|"ACPI lock (GPE)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|OutHandle
operator|==
operator|&
name|AcpiGbl_HardwareLock
condition|)
name|snprintf
argument_list|(
name|al
operator|->
name|al_name
argument_list|,
sizeof|sizeof
argument_list|(
name|al
operator|->
name|al_name
argument_list|)
argument_list|,
literal|"ACPI lock (HW)"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|snprintf
argument_list|(
name|al
operator|->
name|al_name
argument_list|,
sizeof|sizeof
argument_list|(
name|al
operator|->
name|al_name
argument_list|)
argument_list|,
literal|"ACPI lock (%p)"
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|al
operator|->
name|al_lock
argument_list|,
name|al
operator|->
name|al_name
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"created %s\n"
operator|,
name|al
operator|->
name|al_name
operator|)
argument_list|)
expr_stmt|;
operator|*
name|OutHandle
operator|=
operator|(
name|ACPI_SPINLOCK
operator|)
name|al
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|AcpiOsDeleteLock
parameter_list|(
name|ACPI_SPINLOCK
name|Handle
parameter_list|)
block|{
name|struct
name|acpi_spinlock
modifier|*
name|al
init|=
operator|(
expr|struct
name|acpi_spinlock
operator|*
operator|)
name|Handle
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"cannot delete null spinlock\n"
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"delete %s\n"
operator|,
name|al
operator|->
name|al_name
operator|)
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|al
operator|->
name|al_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|al
argument_list|,
name|M_ACPISEM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ACPI_CPU_FLAGS
name|AcpiOsAcquireLock
parameter_list|(
name|ACPI_SPINLOCK
name|Handle
parameter_list|)
block|{
name|struct
name|acpi_spinlock
modifier|*
name|al
init|=
operator|(
expr|struct
name|acpi_spinlock
operator|*
operator|)
name|Handle
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"cannot acquire null spinlock\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"acquire %s\n"
operator|,
name|al
operator|->
name|al_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|al
operator|->
name|al_lock
argument_list|)
condition|)
block|{
name|al
operator|->
name|al_nested
operator|++
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"acquire nested %s, depth %d\n"
operator|,
name|al
operator|->
name|al_name
operator|,
name|al
operator|->
name|al_nested
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_lock_spin
argument_list|(
operator|&
name|al
operator|->
name|al_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|AcpiOsReleaseLock
parameter_list|(
name|ACPI_SPINLOCK
name|Handle
parameter_list|,
name|ACPI_CPU_FLAGS
name|Flags
parameter_list|)
block|{
name|struct
name|acpi_spinlock
modifier|*
name|al
init|=
operator|(
expr|struct
name|acpi_spinlock
operator|*
operator|)
name|Handle
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
name|NULL
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"cannot release null spinlock\n"
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"release %s\n"
operator|,
name|al
operator|->
name|al_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|al
operator|->
name|al_lock
argument_list|)
condition|)
block|{
if|if
condition|(
name|al
operator|->
name|al_nested
operator|>
literal|0
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"release nested %s, depth %d\n"
operator|,
name|al
operator|->
name|al_name
operator|,
name|al
operator|->
name|al_nested
operator|)
argument_list|)
expr_stmt|;
name|al
operator|->
name|al_nested
operator|--
expr_stmt|;
block|}
else|else
name|mtx_unlock_spin
argument_list|(
operator|&
name|al
operator|->
name|al_lock
argument_list|)
expr_stmt|;
block|}
else|else
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_MUTEX
operator|,
literal|"cannot release unowned %s\n"
operator|,
name|al
operator|->
name|al_name
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Section 5.2.10.1: global lock acquire/release functions */
end_comment

begin_define
define|#
directive|define
name|GL_BIT_PENDING
value|0x01
end_define

begin_define
define|#
directive|define
name|GL_BIT_OWNED
value|0x02
end_define

begin_comment
comment|/*  * Acquire the global lock.  If busy, set the pending bit.  The caller  * will wait for notification from the BIOS that the lock is available  * and then attempt to acquire it again.  */
end_comment

begin_function
name|int
name|acpi_acquire_global_lock
parameter_list|(
name|uint32_t
modifier|*
name|lock
parameter_list|)
block|{
name|uint32_t
name|new
decl_stmt|,
name|old
decl_stmt|;
do|do
block|{
name|old
operator|=
operator|*
name|lock
expr_stmt|;
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|GL_BIT_PENDING
operator|)
operator||
name|GL_BIT_OWNED
expr_stmt|;
if|if
condition|(
operator|(
name|old
operator|&
name|GL_BIT_OWNED
operator|)
operator|!=
literal|0
condition|)
name|new
operator||=
name|GL_BIT_PENDING
expr_stmt|;
block|}
do|while
condition|(
name|atomic_cmpset_acq_int
argument_list|(
name|lock
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
operator|==
literal|0
condition|)
do|;
return|return
operator|(
operator|(
name|new
operator|&
name|GL_BIT_PENDING
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release the global lock, returning whether there is a waiter pending.  * If the BIOS set the pending bit, OSPM must notify the BIOS when it  * releases the lock.  */
end_comment

begin_function
name|int
name|acpi_release_global_lock
parameter_list|(
name|uint32_t
modifier|*
name|lock
parameter_list|)
block|{
name|uint32_t
name|new
decl_stmt|,
name|old
decl_stmt|;
do|do
block|{
name|old
operator|=
operator|*
name|lock
expr_stmt|;
name|new
operator|=
name|old
operator|&
operator|~
operator|(
name|GL_BIT_PENDING
operator||
name|GL_BIT_OWNED
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|atomic_cmpset_rel_int
argument_list|(
name|lock
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
operator|==
literal|0
condition|)
do|;
return|return
operator|(
operator|(
name|old
operator|&
name|GL_BIT_PENDING
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

end_unit

