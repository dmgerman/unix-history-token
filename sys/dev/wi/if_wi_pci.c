begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 1998, 1999  *	Bill Paul<wpaul@ctr.columbia.edu>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Lucent WaveLAN/IEEE 802.11 PCMCIA driver for FreeBSD.  *  * Written by Bill Paul<wpaul@ctr.columbia.edu>  * Electrical Engineering Department  * Columbia University, New York City  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_ieee80211.h>
end_include

begin_include
include|#
directive|include
file|<dev/wi/if_wavelan_ieee.h>
end_include

begin_include
include|#
directive|include
file|<dev/wi/wi_hostap.h>
end_include

begin_include
include|#
directive|include
file|<dev/wi/if_wivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/wi/if_wireg.h>
end_include

begin_function_decl
specifier|static
name|int
name|wi_pci_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wi_pci_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|wi_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|wi_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|wi_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|wi_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|wi_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|wi_pci_driver
init|=
block|{
literal|"wi"
block|,
name|wi_pci_methods
block|,
expr|sizeof
operator|(
expr|struct
name|wi_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|unsigned
name|int
name|vendor
decl_stmt|,
name|device
decl_stmt|;
name|int
name|bus_type
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|pci_ids
index|[]
init|=
block|{
comment|/* Sorted by description */
block|{
literal|0x10b7
block|,
literal|0x7770
block|,
name|WI_BUS_PCI_PLX
block|,
literal|"3Com Airconnect"
block|}
block|,
block|{
literal|0x16ab
block|,
literal|0x1101
block|,
name|WI_BUS_PCI_PLX
block|,
literal|"GLPRISM2 WaveLAN"
block|}
block|,
block|{
literal|0x1260
block|,
literal|0x3873
block|,
name|WI_BUS_PCI_NATIVE
block|,
literal|"Intersil Prism2.5"
block|}
block|,
block|{
literal|0x16ab
block|,
literal|0x1102
block|,
name|WI_BUS_PCI_PLX
block|,
literal|"Linksys WDT11"
block|}
block|,
block|{
literal|0x1385
block|,
literal|0x4100
block|,
name|WI_BUS_PCI_PLX
block|,
literal|"Netgear MA301"
block|}
block|,
block|{
literal|0x1638
block|,
literal|0x1100
block|,
name|WI_BUS_PCI_PLX
block|,
literal|"PRISM2STA WaveLAN"
block|}
block|,
block|{
literal|0x111a
block|,
literal|0x1023
block|,
name|WI_BUS_PCI_PLX
block|,
literal|"Siemens SpeedStream"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_wi
argument_list|,
name|pci
argument_list|,
name|wi_pci_driver
argument_list|,
name|wi_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|wi_pci_probe
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pci_ids
index|[
name|i
index|]
operator|.
name|vendor
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|pci_ids
index|[
name|i
index|]
operator|.
name|vendor
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|pci_ids
index|[
name|i
index|]
operator|.
name|device
operator|)
condition|)
block|{
name|sc
operator|->
name|wi_bus_type
operator|=
name|pci_ids
index|[
name|i
index|]
operator|.
name|bus_type
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|pci_ids
index|[
name|i
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|command
decl_stmt|,
name|wanted
decl_stmt|;
name|u_int16_t
name|reg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wanted
operator|=
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_MEMEN
expr_stmt|;
name|command
operator||=
name|wanted
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|wanted
operator|)
operator|!=
name|wanted
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"wi_pci_attach() failed to enable pci!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|wi_bus_type
operator|!=
name|WI_BUS_PCI_NATIVE
condition|)
block|{
name|error
operator|=
name|wi_alloc
argument_list|(
name|dev
argument_list|,
name|WI_PCI_IORES
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Make sure interrupts are disabled. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
comment|/* We have to do a magic PLX poke to enable interrupts */
name|sc
operator|->
name|local_rid
operator|=
name|WI_PCI_LOCALRES
expr_stmt|;
name|sc
operator|->
name|local
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|local_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_localtag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|local
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_localhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|local
argument_list|)
expr_stmt|;
name|command
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|wi_localtag
argument_list|,
name|sc
operator|->
name|wi_localhandle
argument_list|,
name|WI_LOCAL_INTCSR
argument_list|)
expr_stmt|;
name|command
operator||=
name|WI_LOCAL_INTEN
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|wi_localtag
argument_list|,
name|sc
operator|->
name|wi_localhandle
argument_list|,
name|WI_LOCAL_INTCSR
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|local_rid
argument_list|,
name|sc
operator|->
name|local
argument_list|)
expr_stmt|;
name|sc
operator|->
name|local
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|mem_rid
operator|=
name|WI_PCI_MEMRES
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|mem_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't allocate memory\n"
argument_list|)
expr_stmt|;
name|wi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|wi_bmemtag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_bmemhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
comment|/* 		 * From Linux driver: 		 * Write COR to enable PC card 		 * This is a subset of the protocol that the pccard bus code 		 * would do. 		 */
name|CSM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|WI_COR_OFFSET
argument_list|,
name|WI_COR_VALUE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|CSM_READ_1
argument_list|(
name|sc
argument_list|,
name|WI_COR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|WI_COR_VALUE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CSM_READ_1(WI_COR_OFFSET) "
literal|"wanted %d, got %d\n"
argument_list|,
name|WI_COR_VALUE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|wi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|wi_alloc
argument_list|(
name|dev
argument_list|,
name|WI_PCI_LMEMRES
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_HFA384X_PCICOR_OFF
argument_list|,
literal|0x0080
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|250000
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_HFA384X_PCICOR_OFF
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|2000000
expr_stmt|;
while|while
condition|(
operator|(
operator|--
name|timeout
operator|>
literal|0
operator|)
operator|&&
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_COMMAND
argument_list|)
operator|&
name|WI_CMD_BUSY
operator|)
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't reset prism2.5 core.\n"
argument_list|)
expr_stmt|;
name|wi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_HFA384X_SWSUPPORT0_OFF
argument_list|,
name|WI_PRISM2STA_MAGIC
argument_list|)
expr_stmt|;
name|reg
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_HFA384X_SWSUPPORT0_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|WI_PRISM2STA_MAGIC
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CSR_READ_2(WI_HFA384X_SWSUPPORT0_OFF) "
literal|"wanted %d, got %d\n"
argument_list|,
name|WI_PRISM2STA_MAGIC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|wi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|wi_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

