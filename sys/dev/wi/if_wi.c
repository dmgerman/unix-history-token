begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 1998, 1999  *	Bill Paul<wpaul@ctr.columbia.edu>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Lucent WaveLAN/IEEE 802.11 PCMCIA driver for FreeBSD.  *  * Written by Bill Paul<wpaul@ctr.columbia.edu>  * Electrical Engineering Department  * Columbia University, New York City  */
end_comment

begin_comment
comment|/*  * The WaveLAN/IEEE adapter is the second generation of the WaveLAN  * from Lucent. Unlike the older cards, the new ones are programmed  * entirely via a firmware-driven controller called the Hermes.  * Unfortunately, Lucent will not release the Hermes programming manual  * without an NDA (if at all). What they do release is an API library  * called the HCF (Hardware Control Functions) which is supposed to  * do the device-specific operations of a device driver for you. The  * publically available version of the HCF library (the 'HCF Light') is   * a) extremely gross, b) lacks certain features, particularly support  * for 802.11 frames, and c) is contaminated by the GNU Public License.  *  * This driver does not use the HCF or HCF Light at all. Instead, it  * programs the Hermes controller directly, using information gleaned  * from the HCF Light code and corresponding documentation.  *  * This driver supports both the PCMCIA and ISA versions of the  * WaveLAN/IEEE cards. Note however that the ISA card isn't really  * anything of the sort: it's actually a PCMCIA bridge adapter  * that fits into an ISA slot, into which a PCMCIA WaveLAN card is  * inserted. Consequently, you need to use the pccard support for  * both the ISA and PCMCIA adapters.  */
end_comment

begin_define
define|#
directive|define
name|WI_HERMES_AUTOINC_WAR
end_define

begin_comment
comment|/* Work around data write autoinc bug. */
end_comment

begin_define
define|#
directive|define
name|WI_HERMES_STATS_WAR
end_define

begin_comment
comment|/* Work around stats counter bug. */
end_comment

begin_define
define|#
directive|define
name|WICACHE
end_define

begin_comment
comment|/* turn on signal strength cache code */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccardvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccarddevs.h>
end_include

begin_include
include|#
directive|include
file|<dev/wi/if_wavelan_ieee.h>
end_include

begin_include
include|#
directive|include
file|<dev/wi/if_wireg.h>
end_include

begin_include
include|#
directive|include
file|"card_if.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|foo
end_ifdef

begin_decl_stmt
specifier|static
name|u_int8_t
name|wi_mcast_addr
index|[
literal|6
index|]
init|=
block|{
literal|0x01
block|,
literal|0x60
block|,
literal|0x1D
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|wi_intr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_reset
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|u_long
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_init
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_stop
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_rxeof
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_txeof
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_update_stats
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_setmulti
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_read_record
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
expr|struct
name|wi_ltv_gen
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_write_record
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
expr|struct
name|wi_ltv_gen
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_read_data
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_write_data
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_seek
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_alloc_nicmem
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_inquire
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_setdef
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
expr|struct
name|wi_req
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_mgmt_xmit
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|WICACHE
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|wi_cache_store
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
expr|struct
name|ether_header
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|unsigned
name|short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|wi_generic_attach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_pccard_match
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_pccard_probe
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_pci_probe
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_pccard_attach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_pci_attach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_pccard_detach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_shutdown
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_alloc
name|__P
argument_list|(
operator|(
name|device_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_free
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|wi_pccard_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|pccard_compat_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|pccard_compat_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|wi_pccard_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|wi_shutdown
argument_list|)
block|,
comment|/* Card interface */
name|DEVMETHOD
argument_list|(
name|card_compat_match
argument_list|,
name|wi_pccard_match
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|card_compat_probe
argument_list|,
name|wi_pccard_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|card_compat_attach
argument_list|,
name|wi_pccard_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|wi_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|wi_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|wi_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|wi_pccard_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|wi_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|wi_pccard_driver
init|=
block|{
literal|"wi"
block|,
name|wi_pccard_methods
block|,
expr|sizeof
operator|(
expr|struct
name|wi_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|wi_pci_driver
init|=
block|{
literal|"wi"
block|,
name|wi_pci_methods
block|,
expr|sizeof
operator|(
expr|struct
name|wi_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|wi_pccard_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|wi_pci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_wi
argument_list|,
name|pccard
argument_list|,
name|wi_pccard_driver
argument_list|,
name|wi_pccard_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_wi
argument_list|,
name|pci
argument_list|,
name|wi_pci_driver
argument_list|,
name|wi_pci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pccard_product
name|wi_pccard_products
index|[]
init|=
block|{
block|{
name|PCCARD_STR_LUCENT_WAVELAN_IEEE
block|,
name|PCCARD_VENDOR_LUCENT
block|,
name|PCCARD_PRODUCT_LUCENT_WAVELAN_IEEE
block|,
literal|0
block|,
name|PCCARD_CIS_LUCENT_WAVELAN_IEEE
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|wi_device_desc
index|[]
init|=
literal|"WaveLAN/IEEE 802.11"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|wi_pccard_match
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
specifier|const
name|struct
name|pccard_product
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|pccard_product_lookup
argument_list|(
name|dev
argument_list|,
name|wi_pccard_products
argument_list|,
sizeof|sizeof
argument_list|(
name|wi_pccard_products
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|pp
operator|->
name|pp_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_pccard_probe
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_gone
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|wi_alloc
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|wi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Make sure interrupts are disabled. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_pci_probe
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|WI_PCI_VENDOR_EUMITCOM
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|WI_PCI_DEVICE_PRISM2STA
operator|)
condition|)
block|{
name|sc
operator|->
name|wi_prism2
operator|=
literal|1
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PRISM2STA PCI WaveLAN/IEEE 802.11"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_pccard_detach
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"already unloaded\n"
argument_list|)
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|wi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|wi_intrhand
argument_list|)
expr_stmt|;
name|wi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_gone
operator|=
literal|1
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|wi_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_pccard_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 *	XXX: quick hack to support Prism II chip. 	 *	Currently, we need to set a flags in pccard.conf to specify 	 *	which type chip is used. 	 * 	 *	We need to replace this code in a future. 	 *	It is better to use CIS than using a flag. 	 */
name|flags
operator|=
name|device_get_flags
argument_list|(
name|dev
argument_list|)
expr_stmt|;
define|#
directive|define
name|WI_FLAGS_PRISM2
value|0x10000
if|if
condition|(
name|flags
operator|&
name|WI_FLAGS_PRISM2
condition|)
block|{
name|sc
operator|->
name|wi_prism2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"found PrismII chip\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|wi_prism2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"found Lucent chip\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|wi_alloc
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"wi_alloc() failed! (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|wi_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|command
decl_stmt|,
name|wanted
decl_stmt|;
name|u_int16_t
name|reg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wanted
operator|=
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_MEMEN
expr_stmt|;
name|command
operator||=
name|wanted
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|wanted
operator|)
operator|!=
name|wanted
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"wi_pci_attach() failed to enable pci!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|wi_alloc
argument_list|(
name|dev
argument_list|,
name|WI_PCI_IORES
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|wi_device_desc
argument_list|)
expr_stmt|;
comment|/* Make sure interrupts are disabled. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_rid
operator|=
name|WI_PCI_MEMRES
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|mem_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't allocate memory\n"
argument_list|)
expr_stmt|;
name|wi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|wi_bmemtag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_bmemhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
comment|/* 	 * From Linux driver: 	 * Write COR to enable PC card 	 * This is a subset of the protocol that the pccard bus code 	 * would do. 	 */
name|CSM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|WI_COR_OFFSET
argument_list|,
name|WI_COR_VALUE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|CSM_READ_1
argument_list|(
name|sc
argument_list|,
name|WI_COR_OFFSET
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_HFA384X_SWSUPPORT0_OFF
argument_list|,
name|WI_PRISM2STA_MAGIC
argument_list|)
expr_stmt|;
name|reg
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_HFA384X_SWSUPPORT0_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|WI_PRISM2STA_MAGIC
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CSR_READ_2(WI_HFA384X_SWSUPPORT0_OFF) "
literal|"wanted %d, got %d\n"
argument_list|,
name|WI_PRISM2STA_MAGIC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|wi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|wi_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_generic_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_ltv_macaddr
name|mac
decl_stmt|;
name|struct
name|wi_ltv_gen
name|gen
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|wi_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|wi_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_setup_intr() failed! (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|wi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|wi_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset the NIC. */
name|wi_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Read the station address. */
name|mac
operator|.
name|wi_type
operator|=
name|WI_RID_MAC_NODE
expr_stmt|;
name|mac
operator|.
name|wi_len
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|mac
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"mac read failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|wi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mac
operator|.
name|wi_mac_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Ethernet address: %6D\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|sc
operator|->
name|wi_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"wi"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|wi_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|wi_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|wi_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|wi_init
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|wi_node_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_node_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|WI_DEFAULT_NODENAME
argument_list|,
name|sc
operator|->
name|wi_node_name
argument_list|,
sizeof|sizeof
argument_list|(
name|WI_DEFAULT_NODENAME
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|WI_DEFAULT_NETNAME
argument_list|,
name|sc
operator|->
name|wi_net_name
argument_list|,
sizeof|sizeof
argument_list|(
name|WI_DEFAULT_NETNAME
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|wi_ibss_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_ibss_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|WI_DEFAULT_IBSS
argument_list|,
name|sc
operator|->
name|wi_ibss_name
argument_list|,
sizeof|sizeof
argument_list|(
name|WI_DEFAULT_IBSS
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_portnum
operator|=
name|WI_DEFAULT_PORT
expr_stmt|;
name|sc
operator|->
name|wi_ptype
operator|=
name|WI_PORTTYPE_BSS
expr_stmt|;
name|sc
operator|->
name|wi_ap_density
operator|=
name|WI_DEFAULT_AP_DENSITY
expr_stmt|;
name|sc
operator|->
name|wi_rts_thresh
operator|=
name|WI_DEFAULT_RTS_THRESH
expr_stmt|;
name|sc
operator|->
name|wi_tx_rate
operator|=
name|WI_DEFAULT_TX_RATE
expr_stmt|;
name|sc
operator|->
name|wi_max_data_len
operator|=
name|WI_DEFAULT_DATALEN
expr_stmt|;
name|sc
operator|->
name|wi_create_ibss
operator|=
name|WI_DEFAULT_CREATE_IBSS
expr_stmt|;
name|sc
operator|->
name|wi_pm_enabled
operator|=
name|WI_DEFAULT_PM_ENABLED
expr_stmt|;
name|sc
operator|->
name|wi_max_sleep
operator|=
name|WI_DEFAULT_MAX_SLEEP
expr_stmt|;
comment|/* 	 * Read the default channel from the NIC. This may vary 	 * depending on the country where the NIC was purchased, so 	 * we can't hard-code a default and expect it to work for 	 * everyone. 	 */
name|gen
operator|.
name|wi_type
operator|=
name|WI_RID_OWN_CHNL
expr_stmt|;
name|gen
operator|.
name|wi_len
operator|=
literal|2
expr_stmt|;
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|&
name|gen
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_channel
operator|=
name|gen
operator|.
name|wi_val
expr_stmt|;
comment|/* 	 * Find out if we support WEP on this card. 	 */
name|gen
operator|.
name|wi_type
operator|=
name|WI_RID_WEP_AVAIL
expr_stmt|;
name|gen
operator|.
name|wi_len
operator|=
literal|2
expr_stmt|;
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|&
name|gen
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_has_wep
operator|=
name|gen
operator|.
name|wi_val
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|__FUNCTION__
literal|":wi_has_wep = %d\n"
argument_list|,
name|sc
operator|->
name|wi_has_wep
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_stats
argument_list|)
argument_list|)
expr_stmt|;
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Call MI attach routine. 	 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|wi_stat_ch
argument_list|)
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_rxeof
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|wi_frame
name|rx_frame
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|id
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_RX_FID
argument_list|)
expr_stmt|;
comment|/* First read in the frame header */
if|if
condition|(
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rx_frame
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_frame
argument_list|)
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rx_frame
operator|.
name|wi_status
operator|&
name|WI_STAT_ERRSTAT
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|rx_frame
operator|.
name|wi_status
operator|==
name|WI_STAT_1042
operator|||
name|rx_frame
operator|.
name|wi_status
operator|==
name|WI_STAT_TUNNEL
operator|||
name|rx_frame
operator|.
name|wi_status
operator|==
name|WI_STAT_WMP_MSG
condition|)
block|{
if|if
condition|(
operator|(
name|rx_frame
operator|.
name|wi_dat_len
operator|+
name|WI_SNAPHDR_LEN
operator|)
operator|>
name|MCLBYTES
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"oversized packet received "
literal|"(wi_dat_len=%d, wi_status=0x%x)\n"
argument_list|,
name|rx_frame
operator|.
name|wi_dat_len
argument_list|,
name|rx_frame
operator|.
name|wi_status
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|rx_frame
operator|.
name|wi_dat_len
operator|+
name|WI_SNAPHDR_LEN
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame
operator|.
name|wi_addr1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_ptype
operator|==
name|WI_PORTTYPE_ADHOC
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame
operator|.
name|wi_addr2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame
operator|.
name|wi_addr3
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame
operator|.
name|wi_type
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_type
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|WI_802_11_OFFSET
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|+
literal|2
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rx_frame
operator|.
name|wi_dat_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
operator|>
name|MCLBYTES
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"oversized packet received "
literal|"(wi_dat_len=%d, wi_status=0x%x)\n"
argument_list|,
name|rx_frame
operator|.
name|wi_dat_len
argument_list|,
name|rx_frame
operator|.
name|wi_status
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|rx_frame
operator|.
name|wi_dat_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|WI_802_3_OFFSET
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|+
literal|2
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* Receive packet. */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WICACHE
name|wi_cache_store
argument_list|(
name|sc
argument_list|,
name|eh
argument_list|,
name|m
argument_list|,
name|rx_frame
operator|.
name|wi_q_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_txeof
parameter_list|(
name|sc
parameter_list|,
name|status
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|WI_EV_TX_EXC
condition|)
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
else|else
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|wi_inquire
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|sc
operator|->
name|wi_stat_ch
operator|=
name|timeout
argument_list|(
name|wi_inquire
argument_list|,
name|sc
argument_list|,
name|hz
operator|*
literal|60
argument_list|)
expr_stmt|;
comment|/* Don't do this while we're transmitting */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
return|return;
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_INQUIRE
argument_list|,
name|WI_INFO_COUNTERS
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|wi_update_stats
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|wi_ltv_gen
name|gen
decl_stmt|;
name|u_int16_t
name|id
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int32_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int16_t
name|t
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_INFO_FID
argument_list|)
expr_stmt|;
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gen
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
operator|.
name|wi_type
operator|!=
name|WI_INFO_COUNTERS
operator|||
name|gen
operator|.
name|wi_len
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_stats
argument_list|)
operator|/
literal|4
operator|)
operator|+
literal|1
condition|)
return|return;
name|ptr
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_stats
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gen
operator|.
name|wi_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WI_HERMES_STATS_WAR
if|if
condition|(
name|t
operator|>
literal|0xF000
condition|)
name|t
operator|=
operator|~
name|t
operator|&
literal|0xFFFF
expr_stmt|;
endif|#
directive|endif
name|ptr
index|[
name|i
index|]
operator|+=
name|t
expr_stmt|;
block|}
name|ifp
operator|->
name|if_collisions
operator|=
name|sc
operator|->
name|wi_stats
operator|.
name|wi_tx_single_retries
operator|+
name|sc
operator|->
name|wi_stats
operator|.
name|wi_tx_multi_retries
operator|+
name|sc
operator|->
name|wi_stats
operator|.
name|wi_tx_retry_limit
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_intr
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int16_t
name|status
decl_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Disable interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_STAT
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
operator|~
name|WI_INTRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|WI_EV_RX
condition|)
block|{
name|wi_rxeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_RX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_TX
condition|)
block|{
name|wi_txeof
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_TX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_ALLOC
condition|)
block|{
name|int
name|id
decl_stmt|;
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_ALLOC_FID
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|sc
operator|->
name|wi_tx_data_id
condition|)
name|wi_txeof
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_INFO
condition|)
block|{
name|wi_update_stats
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_INFO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_TX_EXC
condition|)
block|{
name|wi_txeof
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_TX_EXC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_INFO_DROP
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_INFO_DROP
argument_list|)
expr_stmt|;
block|}
comment|/* Re-enable interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
name|WI_INTRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|wi_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_cmd
parameter_list|(
name|sc
parameter_list|,
name|cmd
parameter_list|,
name|val
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|s
init|=
literal|0
decl_stmt|;
comment|/* wait for the busy bit to clear */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WI_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_COMMAND
argument_list|)
operator|&
name|WI_CMD_BUSY
operator|)
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* 10 m sec */
block|}
if|if
condition|(
name|i
operator|==
name|WI_TIMEOUT
condition|)
block|{
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_PARAM0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_PARAM1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_PARAM2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WI_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Wait for 'command complete' bit to be 		 * set in the event status register. 		 */
name|s
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_STAT
argument_list|)
operator|&
name|WI_EV_CMD
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
comment|/* Ack the event and read result code. */
name|s
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_STATUS
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_CMD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|foo
if|if
condition|(
operator|(
name|s
operator|&
name|WI_CMD_CODE_MASK
operator|)
operator|!=
operator|(
name|cmd
operator|&
name|WI_CMD_CODE_MASK
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|s
operator|&
name|WI_STAT_CMD_RESULT
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|WI_TIMEOUT
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_INI
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|5
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"init failed\n"
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
comment|/* Calibrate timer. */
name|WI_SETVAL
argument_list|(
name|WI_RID_TICK_TIME
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Read an LTV record from the NIC.  */
end_comment

begin_function
specifier|static
name|int
name|wi_read_record
parameter_list|(
name|sc
parameter_list|,
name|ltv
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_ltv_gen
modifier|*
name|ltv
decl_stmt|;
block|{
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|code
decl_stmt|;
name|struct
name|wi_ltv_gen
modifier|*
name|oltv
decl_stmt|,
name|p2ltv
decl_stmt|;
name|oltv
operator|=
name|ltv
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_prism2
condition|)
block|{
switch|switch
condition|(
name|ltv
operator|->
name|wi_type
condition|)
block|{
case|case
name|WI_RID_ENCRYPTION
case|:
name|p2ltv
operator|.
name|wi_type
operator|=
name|WI_RID_P2_ENCRYPTION
expr_stmt|;
name|p2ltv
operator|.
name|wi_len
operator|=
literal|2
expr_stmt|;
name|ltv
operator|=
operator|&
name|p2ltv
expr_stmt|;
break|break;
case|case
name|WI_RID_TX_CRYPT_KEY
case|:
name|p2ltv
operator|.
name|wi_type
operator|=
name|WI_RID_P2_TX_CRYPT_KEY
expr_stmt|;
name|p2ltv
operator|.
name|wi_len
operator|=
literal|2
expr_stmt|;
name|ltv
operator|=
operator|&
name|p2ltv
expr_stmt|;
break|break;
block|}
block|}
comment|/* Tell the NIC to enter record read mode. */
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_ACCESS
operator||
name|WI_ACCESS_READ
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Seek to the record. */
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|,
literal|0
argument_list|,
name|WI_BAP1
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* 	 * Read the length and record type and make sure they 	 * match what we expect (this verifies that we have enough 	 * room to hold all of the returned data). 	 */
name|len
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|ltv
operator|->
name|wi_len
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|code
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|ltv
operator|->
name|wi_type
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|ltv
operator|->
name|wi_len
operator|=
name|len
expr_stmt|;
name|ltv
operator|->
name|wi_type
operator|=
name|code
expr_stmt|;
comment|/* Now read the data. */
name|ptr
operator|=
operator|&
name|ltv
operator|->
name|wi_val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ltv
operator|->
name|wi_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|ptr
index|[
name|i
index|]
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_prism2
condition|)
block|{
switch|switch
condition|(
name|oltv
operator|->
name|wi_type
condition|)
block|{
case|case
name|WI_RID_TX_RATE
case|:
case|case
name|WI_RID_CUR_TX_RATE
case|:
switch|switch
condition|(
name|ltv
operator|->
name|wi_val
condition|)
block|{
case|case
literal|1
case|:
name|oltv
operator|->
name|wi_val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|oltv
operator|->
name|wi_val
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|oltv
operator|->
name|wi_val
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|oltv
operator|->
name|wi_val
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|oltv
operator|->
name|wi_val
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|oltv
operator|->
name|wi_val
operator|=
literal|11
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|oltv
operator|->
name|wi_val
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|oltv
operator|->
name|wi_val
operator|=
literal|0x100
operator|+
name|ltv
operator|->
name|wi_val
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|WI_RID_ENCRYPTION
case|:
name|oltv
operator|->
name|wi_len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|ltv
operator|->
name|wi_val
operator|&
literal|0x01
condition|)
name|oltv
operator|->
name|wi_val
operator|=
literal|1
expr_stmt|;
else|else
name|oltv
operator|->
name|wi_val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|WI_RID_TX_CRYPT_KEY
case|:
name|oltv
operator|->
name|wi_len
operator|=
literal|2
expr_stmt|;
name|oltv
operator|->
name|wi_val
operator|=
name|ltv
operator|->
name|wi_val
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Same as read, except we inject data instead of reading it.  */
end_comment

begin_function
specifier|static
name|int
name|wi_write_record
parameter_list|(
name|sc
parameter_list|,
name|ltv
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_ltv_gen
modifier|*
name|ltv
decl_stmt|;
block|{
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|wi_ltv_gen
name|p2ltv
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_prism2
condition|)
block|{
switch|switch
condition|(
name|ltv
operator|->
name|wi_type
condition|)
block|{
case|case
name|WI_RID_TX_RATE
case|:
name|p2ltv
operator|.
name|wi_type
operator|=
name|WI_RID_TX_RATE
expr_stmt|;
name|p2ltv
operator|.
name|wi_len
operator|=
literal|2
expr_stmt|;
switch|switch
condition|(
name|ltv
operator|->
name|wi_val
condition|)
block|{
case|case
literal|1
case|:
name|p2ltv
operator|.
name|wi_val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|p2ltv
operator|.
name|wi_val
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|p2ltv
operator|.
name|wi_val
operator|=
literal|15
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|p2ltv
operator|.
name|wi_val
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|p2ltv
operator|.
name|wi_val
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|p2ltv
operator|.
name|wi_val
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|p2ltv
operator|.
name|wi_val
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
name|ltv
operator|=
operator|&
name|p2ltv
expr_stmt|;
break|break;
case|case
name|WI_RID_ENCRYPTION
case|:
name|p2ltv
operator|.
name|wi_type
operator|=
name|WI_RID_P2_ENCRYPTION
expr_stmt|;
name|p2ltv
operator|.
name|wi_len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|ltv
operator|->
name|wi_val
condition|)
name|p2ltv
operator|.
name|wi_val
operator|=
literal|0x03
expr_stmt|;
else|else
name|p2ltv
operator|.
name|wi_val
operator|=
literal|0x90
expr_stmt|;
name|ltv
operator|=
operator|&
name|p2ltv
expr_stmt|;
break|break;
case|case
name|WI_RID_TX_CRYPT_KEY
case|:
name|p2ltv
operator|.
name|wi_type
operator|=
name|WI_RID_P2_TX_CRYPT_KEY
expr_stmt|;
name|p2ltv
operator|.
name|wi_len
operator|=
literal|2
expr_stmt|;
name|p2ltv
operator|.
name|wi_val
operator|=
name|ltv
operator|->
name|wi_val
expr_stmt|;
name|ltv
operator|=
operator|&
name|p2ltv
expr_stmt|;
break|break;
case|case
name|WI_RID_DEFLT_CRYPT_KEYS
case|:
block|{
name|int
name|error
decl_stmt|;
name|struct
name|wi_ltv_str
name|ws
decl_stmt|;
name|struct
name|wi_ltv_keys
modifier|*
name|wk
init|=
operator|(
expr|struct
name|wi_ltv_keys
operator|*
operator|)
name|ltv
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|ws
operator|.
name|wi_len
operator|=
literal|4
expr_stmt|;
name|ws
operator|.
name|wi_type
operator|=
name|WI_RID_P2_CRYPT_KEY0
operator|+
name|i
expr_stmt|;
name|memcpy
argument_list|(
name|ws
operator|.
name|wi_str
argument_list|,
operator|&
name|wk
operator|->
name|wi_keys
index|[
name|i
index|]
operator|.
name|wi_keydat
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ws
operator|.
name|wi_str
index|[
literal|5
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|ws
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
block|}
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|,
literal|0
argument_list|,
name|WI_BAP1
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|,
name|ltv
operator|->
name|wi_len
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|&
name|ltv
operator|->
name|wi_val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ltv
operator|->
name|wi_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_ACCESS
operator||
name|WI_ACCESS_WRITE
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_seek
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|chan
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|,
name|chan
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|selreg
decl_stmt|,
name|offreg
decl_stmt|;
switch|switch
condition|(
name|chan
condition|)
block|{
case|case
name|WI_BAP0
case|:
name|selreg
operator|=
name|WI_SEL0
expr_stmt|;
name|offreg
operator|=
name|WI_OFF0
expr_stmt|;
break|break;
case|case
name|WI_BAP1
case|:
name|selreg
operator|=
name|WI_SEL1
expr_stmt|;
name|offreg
operator|=
name|WI_OFF1
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"invalid data path: %x\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|selreg
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|offreg
argument_list|,
name|off
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WI_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|offreg
argument_list|)
operator|&
operator|(
name|WI_OFF_BUSY
operator||
name|WI_OFF_ERR
operator|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|WI_TIMEOUT
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_read_data
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|off
argument_list|,
name|WI_BAP1
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|ptr
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|ptr
index|[
name|i
index|]
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * According to the comments in the HCF Light code, there is a bug in  * the Hermes (or possibly in certain Hermes firmware revisions) where  * the chip's internal autoincrement counter gets thrown off during  * data writes: the autoincrement is missed, causing one data word to  * be overwritten and subsequent words to be written to the wrong memory  * locations. The end result is that we could end up transmitting bogus  * frames without realizing it. The workaround for this is to write a  * couple of extra guard words after the end of the transfer, then  * attempt to read then back. If we fail to locate the guard words where  * we expect them, we preform the transfer over again.  */
end_comment

begin_function
specifier|static
name|int
name|wi_write_data
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|WI_HERMES_AUTOINC_WAR
name|int
name|retries
decl_stmt|;
name|retries
operator|=
name|WI_TIMEOUT
operator|>>
literal|4
expr_stmt|;
name|again
label|:
endif|#
directive|endif
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|off
argument_list|,
name|WI_BAP0
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|ptr
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|len
operator|/
literal|2
operator|)
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WI_HERMES_AUTOINC_WAR
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|,
literal|0x1234
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|,
literal|0x5678
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|off
operator|+
name|len
argument_list|,
name|WI_BAP0
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|)
operator|!=
literal|0x1234
operator|||
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|)
operator|!=
literal|0x5678
condition|)
block|{
if|if
condition|(
operator|--
name|retries
operator|>=
literal|0
condition|)
goto|goto
name|again
goto|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"wi_write_data device timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a region of memory inside the NIC and zero  * it out.  */
end_comment

begin_function
specifier|static
name|int
name|wi_alloc_nicmem
parameter_list|(
name|sc
parameter_list|,
name|len
parameter_list|,
name|id
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
modifier|*
name|id
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_ALLOC_MEM
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate %d bytes on NIC\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WI_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_STAT
argument_list|)
operator|&
name|WI_EV_ALLOC
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|WI_TIMEOUT
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_ALLOC
argument_list|)
expr_stmt|;
operator|*
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_ALLOC_FID
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
operator|*
name|id
argument_list|,
literal|0
argument_list|,
name|WI_BAP0
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_setmulti
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|wi_ltv_mcast
name|mcast
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mcast
argument_list|,
sizeof|sizeof
argument_list|(
name|mcast
argument_list|)
argument_list|)
expr_stmt|;
name|mcast
operator|.
name|wi_type
operator|=
name|WI_RID_MCAST
expr_stmt|;
name|mcast
operator|.
name|wi_len
operator|=
operator|(
literal|3
operator|*
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|||
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|mcast
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|i
operator|<
literal|16
condition|)
block|{
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mcast
operator|.
name|wi_mcast
index|[
name|i
index|]
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mcast
argument_list|,
sizeof|sizeof
argument_list|(
name|mcast
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mcast
operator|.
name|wi_len
operator|=
operator|(
name|i
operator|*
literal|3
operator|)
operator|+
literal|1
expr_stmt|;
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|mcast
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_setdef
parameter_list|(
name|sc
parameter_list|,
name|wreq
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_req
modifier|*
name|wreq
decl_stmt|;
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
switch|switch
condition|(
name|wreq
operator|->
name|wi_type
condition|)
block|{
case|case
name|WI_RID_MAC_NODE
case|:
name|ifa
operator|=
name|ifnet_addrs
index|[
name|ifp
operator|->
name|if_index
operator|-
literal|1
index|]
expr_stmt|;
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_PORTTYPE
case|:
name|sc
operator|->
name|wi_ptype
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_TX_RATE
case|:
name|sc
operator|->
name|wi_tx_rate
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_MAX_DATALEN
case|:
name|sc
operator|->
name|wi_max_data_len
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_RTS_THRESH
case|:
name|sc
operator|->
name|wi_rts_thresh
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_SYSTEM_SCALE
case|:
name|sc
operator|->
name|wi_ap_density
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_CREATE_IBSS
case|:
name|sc
operator|->
name|wi_create_ibss
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_OWN_CHNL
case|:
name|sc
operator|->
name|wi_channel
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_NODENAME
case|:
name|bzero
argument_list|(
name|sc
operator|->
name|wi_node_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_node_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|wi_node_name
argument_list|,
literal|30
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_DESIRED_SSID
case|:
name|bzero
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|wi_net_name
argument_list|,
literal|30
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_OWN_SSID
case|:
name|bzero
argument_list|(
name|sc
operator|->
name|wi_ibss_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_ibss_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|wi_ibss_name
argument_list|,
literal|30
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_PM_ENABLED
case|:
name|sc
operator|->
name|wi_pm_enabled
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_MAX_SLEEP
case|:
name|sc
operator|->
name|wi_max_sleep
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_ENCRYPTION
case|:
name|sc
operator|->
name|wi_use_wep
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_TX_CRYPT_KEY
case|:
name|sc
operator|->
name|wi_tx_key
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_DEFLT_CRYPT_KEYS
case|:
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wreq
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_keys
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_ltv_keys
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Reinitialize WaveLAN. */
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_req
name|wreq
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|&&
operator|!
operator|(
name|sc
operator|->
name|wi_if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
name|WI_SETVAL
argument_list|(
name|WI_RID_PROMISC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|sc
operator|->
name|wi_if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|WI_SETVAL
argument_list|(
name|WI_RID_PROMISC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|wi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|wi_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|wi_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCGWAVELAN
case|:
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|wreq
argument_list|,
sizeof|sizeof
argument_list|(
name|wreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* Don't show WEP keys to non-root users. */
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_DEFLT_CRYPT_KEYS
operator|&&
name|suser
argument_list|(
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_IFACE_STATS
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_stats
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|.
name|wi_val
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_stats
argument_list|)
argument_list|)
expr_stmt|;
name|wreq
operator|.
name|wi_len
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_stats
argument_list|)
operator|/
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_DEFLT_CRYPT_KEYS
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_keys
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_ltv_keys
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WICACHE
elseif|else
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_ZERO_CACHE
condition|)
block|{
name|sc
operator|->
name|wi_sigitems
operator|=
name|sc
operator|->
name|wi_nextitem
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_READ_CACHE
condition|)
block|{
name|char
modifier|*
name|pt
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|.
name|wi_val
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_sigitems
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
name|wreq
operator|.
name|wi_len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|/
literal|2
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_sigcache
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_sigcache
argument_list|)
operator|*
name|sc
operator|->
name|wi_sigitems
argument_list|)
expr_stmt|;
name|wreq
operator|.
name|wi_len
operator|+=
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|wi_sigcache
argument_list|)
operator|*
name|sc
operator|->
name|wi_sigitems
operator|)
operator|/
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
if|if
condition|(
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|wreq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|wreq
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|wreq
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSWAVELAN
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|wreq
argument_list|,
sizeof|sizeof
argument_list|(
name|wreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_IFACE_STATS
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_MGMT_XMIT
condition|)
block|{
name|error
operator|=
name|wi_mgmt_xmit
argument_list|(
name|sc
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|wreq
operator|.
name|wi_val
argument_list|,
name|wreq
operator|.
name|wi_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|wreq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|wi_setdef
argument_list|(
name|sc
argument_list|,
operator|&
name|wreq
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|out
label|:
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|wi_ltv_macaddr
name|mac
decl_stmt|;
name|int
name|id
init|=
literal|0
decl_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
block|{
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|wi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wi_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Program max data length. */
name|WI_SETVAL
argument_list|(
name|WI_RID_MAX_DATALEN
argument_list|,
name|sc
operator|->
name|wi_max_data_len
argument_list|)
expr_stmt|;
comment|/* Enable/disable IBSS creation. */
name|WI_SETVAL
argument_list|(
name|WI_RID_CREATE_IBSS
argument_list|,
name|sc
operator|->
name|wi_create_ibss
argument_list|)
expr_stmt|;
comment|/* Set the port type. */
name|WI_SETVAL
argument_list|(
name|WI_RID_PORTTYPE
argument_list|,
name|sc
operator|->
name|wi_ptype
argument_list|)
expr_stmt|;
comment|/* Program the RTS/CTS threshold. */
name|WI_SETVAL
argument_list|(
name|WI_RID_RTS_THRESH
argument_list|,
name|sc
operator|->
name|wi_rts_thresh
argument_list|)
expr_stmt|;
comment|/* Program the TX rate */
name|WI_SETVAL
argument_list|(
name|WI_RID_TX_RATE
argument_list|,
name|sc
operator|->
name|wi_tx_rate
argument_list|)
expr_stmt|;
comment|/* Access point density */
name|WI_SETVAL
argument_list|(
name|WI_RID_SYSTEM_SCALE
argument_list|,
name|sc
operator|->
name|wi_ap_density
argument_list|)
expr_stmt|;
comment|/* Power Management Enabled */
name|WI_SETVAL
argument_list|(
name|WI_RID_PM_ENABLED
argument_list|,
name|sc
operator|->
name|wi_pm_enabled
argument_list|)
expr_stmt|;
comment|/* Power Managment Max Sleep */
name|WI_SETVAL
argument_list|(
name|WI_RID_MAX_SLEEP
argument_list|,
name|sc
operator|->
name|wi_max_sleep
argument_list|)
expr_stmt|;
comment|/* Specify the IBSS name */
name|WI_SETSTR
argument_list|(
name|WI_RID_OWN_SSID
argument_list|,
name|sc
operator|->
name|wi_ibss_name
argument_list|)
expr_stmt|;
comment|/* Specify the network name */
name|WI_SETSTR
argument_list|(
name|WI_RID_DESIRED_SSID
argument_list|,
name|sc
operator|->
name|wi_net_name
argument_list|)
expr_stmt|;
comment|/* Specify the frequency to use */
name|WI_SETVAL
argument_list|(
name|WI_RID_OWN_CHNL
argument_list|,
name|sc
operator|->
name|wi_channel
argument_list|)
expr_stmt|;
comment|/* Program the nodename. */
name|WI_SETSTR
argument_list|(
name|WI_RID_NODENAME
argument_list|,
name|sc
operator|->
name|wi_node_name
argument_list|)
expr_stmt|;
comment|/* Set our MAC address. */
name|mac
operator|.
name|wi_len
operator|=
literal|4
expr_stmt|;
name|mac
operator|.
name|wi_type
operator|=
name|WI_RID_MAC_NODE
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mac
operator|.
name|wi_mac_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|mac
argument_list|)
expr_stmt|;
comment|/* Configure WEP. */
if|if
condition|(
name|sc
operator|->
name|wi_has_wep
condition|)
block|{
name|WI_SETVAL
argument_list|(
name|WI_RID_ENCRYPTION
argument_list|,
name|sc
operator|->
name|wi_use_wep
argument_list|)
expr_stmt|;
name|WI_SETVAL
argument_list|(
name|WI_RID_TX_CRYPT_KEY
argument_list|,
name|sc
operator|->
name|wi_tx_key
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_keys
operator|.
name|wi_len
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|wi_ltv_keys
argument_list|)
operator|/
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|wi_keys
operator|.
name|wi_type
operator|=
name|WI_RID_DEFLT_CRYPT_KEYS
expr_stmt|;
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_keys
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize promisc mode. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|WI_SETVAL
argument_list|(
name|WI_RID_PROMISC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WI_SETVAL
argument_list|(
name|WI_RID_PROMISC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set multicast filter. */
name|wi_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable desired port */
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_ENABLE
operator||
name|sc
operator|->
name|wi_portnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_alloc_nicmem
argument_list|(
name|sc
argument_list|,
literal|1518
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
operator|+
literal|8
argument_list|,
operator|&
name|id
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"tx buffer allocation failed\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_tx_data_id
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|wi_alloc_nicmem
argument_list|(
name|sc
argument_list|,
literal|1518
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
operator|+
literal|8
argument_list|,
operator|&
name|id
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"mgmt. buffer allocation failed\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_tx_mgmt_id
operator|=
name|id
expr_stmt|;
comment|/* enable interrupts */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
name|WI_INTRS
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|wi_stat_ch
operator|=
name|timeout
argument_list|(
name|wi_inquire
argument_list|,
name|sc
argument_list|,
name|hz
operator|*
literal|60
argument_list|)
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|wi_frame
name|tx_frame
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|id
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
block|{
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
block|{
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_frame
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|sc
operator|->
name|wi_tx_data_id
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Use RFC1042 encoding for IP and ARP datagrams, 	 * 802.3 for anything else. 	 */
if|if
condition|(
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|>
literal|1518
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
operator|.
name|wi_addr1
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
operator|.
name|wi_addr2
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
operator|.
name|wi_dst_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
operator|.
name|wi_src_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_dat_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|WI_SNAPHDR_LEN
expr_stmt|;
name|tx_frame
operator|.
name|wi_frame_ctl
operator|=
name|WI_FTYPE_DATA
expr_stmt|;
name|tx_frame
operator|.
name|wi_dat
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
name|WI_SNAP_WORD0
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_dat
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|WI_SNAP_WORD1
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_len
operator|=
name|htons
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|WI_SNAPHDR_LEN
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_type
operator|=
name|eh
operator|->
name|ether_type
expr_stmt|;
name|m_copydata
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|wi_txbuf
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tx_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|WI_802_11_OFFSET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|wi_txbuf
argument_list|,
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tx_frame
operator|.
name|wi_dat_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|htons
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|WI_SNAPHDR_LEN
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|wi_txbuf
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tx_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|WI_802_3_OFFSET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|wi_txbuf
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there's a BPF listner, bounce a copy of 	 * this frame to him. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_TX
operator||
name|WI_RECLAIM
argument_list|,
name|id
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"xmit failed\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
comment|/* 	 * Set a timeout in case the chip goes out to lunch. 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_mgmt_xmit
parameter_list|(
name|sc
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|wi_frame
name|tx_frame
decl_stmt|;
name|int
name|id
decl_stmt|;
name|struct
name|wi_80211_hdr
modifier|*
name|hdr
decl_stmt|;
name|caddr_t
name|dptr
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|hdr
operator|=
operator|(
expr|struct
name|wi_80211_hdr
operator|*
operator|)
name|data
expr_stmt|;
name|dptr
operator|=
name|data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|wi_80211_hdr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_frame
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|sc
operator|->
name|wi_tx_mgmt_id
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
operator|.
name|wi_frame_ctl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_80211_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_dat_len
operator|=
name|len
operator|-
name|WI_SNAPHDR_LEN
expr_stmt|;
name|tx_frame
operator|.
name|wi_len
operator|=
name|htons
argument_list|(
name|len
operator|-
name|WI_SNAPHDR_LEN
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tx_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|WI_802_11_OFFSET_RAW
argument_list|,
name|dptr
argument_list|,
operator|(
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|wi_80211_hdr
argument_list|)
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_TX
operator||
name|WI_RECLAIM
argument_list|,
name|id
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"xmit failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
block|{
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/* 	 * If the card is gone and the memory port isn't mapped, we will 	 * (hopefully) get 0xffff back from the status read, which is not 	 * a valid status value. 	 */
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_STATUS
argument_list|)
operator|!=
literal|0xffff
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_DISABLE
operator||
name|sc
operator|->
name|wi_portnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|untimeout
argument_list|(
name|wi_inquire
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|wi_stat_ch
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_watchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_alloc
parameter_list|(
name|dev
parameter_list|,
name|io_rid
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|io_rid
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|iobase_rid
operator|=
name|io_rid
expr_stmt|;
name|sc
operator|->
name|iobase
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|iobase_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
operator|(
literal|1
operator|<<
literal|6
operator|)
argument_list|,
name|rman_make_alignment_flags
argument_list|(
literal|1
operator|<<
literal|6
argument_list|)
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|iobase
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No I/O space?!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No irq?!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|wi_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_io_addr
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|iobase
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_free
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|iobase
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_rid
argument_list|,
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_shutdown
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|wi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WICACHE
end_ifdef

begin_comment
comment|/* wavelan signal strength cache code.  * store signal/noise/quality on per MAC src basis in  * a small fixed cache.  The cache wraps if> MAX slots  * used.  The cache may be zeroed out to start over.  * Two simple filters exist to reduce computation:  * 1. ip only (literally 0x800) which may be used  * to ignore some packets.  It defaults to ip only.  * it could be used to focus on broadcast, non-IP 802.11 beacons.  * 2. multicast/broadcast only.  This may be used to  * ignore unicast packets and only cache signal strength  * for multicast/broadcast packets (beacons); e.g., Mobile-IP  * beacons and not unicast traffic.  *  * The cache stores (MAC src(index), IP src (major clue), signal,  *	quality, noise)  *  * No apologies for storing IP src here.  It's easy and saves much  * trouble elsewhere.  The cache is assumed to be INET dependent,   * although it need not be.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|documentation
end_ifdef

begin_decl_stmt
name|int
name|wi_sigitems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of cached entries */
end_comment

begin_decl_stmt
name|struct
name|wi_sigcache
name|wi_sigcache
index|[
name|MAXWICACHE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  array of cache entries */
end_comment

begin_decl_stmt
name|int
name|wi_nextitem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  index/# of entries */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* control variables for cache filtering.  Basic idea is  * to reduce cost (e.g., to only Mobile-IP agent beacons  * which are broadcast or multicast).  Still you might  * want to measure signal strength with unicast ping packets  * on a pt. to pt. ant. setup.  */
end_comment

begin_comment
comment|/* set true if you want to limit cache items to broadcast/mcast   * only packets (not unicast).  Useful for mobile-ip beacons which  * are broadcast/multicast at network layer.  Default is all packets  * so ping/unicast will work say with pt. to pt. antennae setup.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wi_cache_mcastonly
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|wi_cache_mcastonly
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|wi_cache_mcastonly
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* set true if you want to limit cache items to IP packets only */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wi_cache_iponly
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|wi_cache_iponly
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|wi_cache_iponly
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Original comments:  * -----------------  * wi_cache_store, per rx packet store signal  * strength in MAC (src) indexed cache.  *  * follows linux driver in how signal strength is computed.  * In ad hoc mode, we use the rx_quality field.   * signal and noise are trimmed to fit in the range from 47..138.  * rx_quality field MSB is signal strength.  * rx_quality field LSB is noise.  * "quality" is (signal - noise) as is log value.  * note: quality CAN be negative.  *   * In BSS mode, we use the RID for communication quality.  * TBD:  BSS mode is currently untested.  *  * Bill's comments:  * ---------------  * Actually, we use the rx_quality field all the time for both "ad-hoc"  * and BSS modes. Why? Because reading an RID is really, really expensive:  * there's a bunch of PIO operations that have to be done to read a record  * from the NIC, and reading the comms quality RID each time a packet is  * received can really hurt performance. We don't have to do this anyway:  * the comms quality field only reflects the values in the rx_quality field  * anyway. The comms quality RID is only meaningful in infrastructure mode,  * but the values it contains are updated based on the rx_quality from  * frames received from the access point.  *  * Also, according to Lucent, the signal strength and noise level values  * can be converted to dBms by subtracting 149, so I've modified the code  * to do that instead of the scaling it did originally.  */
end_comment

begin_function
specifier|static
name|void
name|wi_cache_store
parameter_list|(
name|struct
name|wi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ether_header
modifier|*
name|eh
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|short
name|rx_quality
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|cache_slot
init|=
literal|0
decl_stmt|;
comment|/* use this cache entry */
specifier|static
name|int
name|wrapindex
init|=
literal|0
decl_stmt|;
comment|/* next "free" cache entry */
name|int
name|sig
decl_stmt|,
name|noise
decl_stmt|;
name|int
name|sawip
init|=
literal|0
decl_stmt|;
comment|/* filters: 	 * 1. ip only 	 * 2. configurable filter to throw out unicast packets, 	 * keep multicast only. 	 */
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|==
literal|0x800
operator|)
condition|)
block|{
name|sawip
operator|=
literal|1
expr_stmt|;
block|}
comment|/* filter for ip packets only  	*/
if|if
condition|(
name|wi_cache_iponly
operator|&&
operator|!
name|sawip
condition|)
block|{
return|return;
block|}
comment|/* filter for broadcast/multicast only 	 */
if|if
condition|(
name|wi_cache_mcastonly
operator|&&
operator|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return;
block|}
ifdef|#
directive|ifdef
name|SIGDEBUG
name|printf
argument_list|(
literal|"wi%d: q value %x (MSB=0x%x, LSB=0x%x) \n"
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|,
name|rx_quality
operator|&
literal|0xffff
argument_list|,
name|rx_quality
operator|>>
literal|8
argument_list|,
name|rx_quality
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* find the ip header.  we want to store the ip_src 	 * address.   	 */
if|if
condition|(
name|sawip
condition|)
block|{
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* do a linear search for a matching MAC address  	 * in the cache table 	 * . MAC address is 6 bytes, 	 * . var w_nextitem holds total number of entries already cached 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|wi_nextitem
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|wi_sigcache
index|[
name|i
index|]
operator|.
name|macsrc
argument_list|,
literal|6
argument_list|)
condition|)
block|{
comment|/* Match!, 			 * so we already have this entry, 			 * update the data 			 */
break|break;
block|}
block|}
comment|/* did we find a matching mac address? 	 * if yes, then overwrite a previously existing cache entry 	 */
if|if
condition|(
name|i
operator|<
name|sc
operator|->
name|wi_nextitem
condition|)
block|{
name|cache_slot
operator|=
name|i
expr_stmt|;
block|}
comment|/* else, have a new address entry,so 	 * add this new entry, 	 * if table full, then we need to replace LRU entry 	 */
else|else
block|{
comment|/* check for space in cache table  		 * note: wi_nextitem also holds number of entries 		 * added in the cache table  		 */
if|if
condition|(
name|sc
operator|->
name|wi_nextitem
operator|<
name|MAXWICACHE
condition|)
block|{
name|cache_slot
operator|=
name|sc
operator|->
name|wi_nextitem
expr_stmt|;
name|sc
operator|->
name|wi_nextitem
operator|++
expr_stmt|;
name|sc
operator|->
name|wi_sigitems
operator|=
name|sc
operator|->
name|wi_nextitem
expr_stmt|;
block|}
comment|/* no space found, so simply wrap with wrap index 		 * and "zap" the next entry 		 */
else|else
block|{
if|if
condition|(
name|wrapindex
operator|==
name|MAXWICACHE
condition|)
block|{
name|wrapindex
operator|=
literal|0
expr_stmt|;
block|}
name|cache_slot
operator|=
name|wrapindex
operator|++
expr_stmt|;
block|}
block|}
comment|/* invariant: cache_slot now points at some slot 	 * in cache. 	 */
if|if
condition|(
name|cache_slot
operator|<
literal|0
operator|||
name|cache_slot
operator|>=
name|MAXWICACHE
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"wi_cache_store, bad index: %d of "
literal|"[0..%d], gross cache error\n"
argument_list|,
name|cache_slot
argument_list|,
name|MAXWICACHE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  store items in cache 	 *  .ip source address 	 *  .mac src 	 *  .signal, etc. 	 */
if|if
condition|(
name|sawip
condition|)
block|{
name|sc
operator|->
name|wi_sigcache
index|[
name|cache_slot
index|]
operator|.
name|ipsrc
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|wi_sigcache
index|[
name|cache_slot
index|]
operator|.
name|macsrc
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|sig
operator|=
operator|(
name|rx_quality
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|noise
operator|=
name|rx_quality
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|wi_sigcache
index|[
name|cache_slot
index|]
operator|.
name|signal
operator|=
name|sig
operator|-
literal|149
expr_stmt|;
name|sc
operator|->
name|wi_sigcache
index|[
name|cache_slot
index|]
operator|.
name|noise
operator|=
name|noise
operator|-
literal|149
expr_stmt|;
name|sc
operator|->
name|wi_sigcache
index|[
name|cache_slot
index|]
operator|.
name|quality
operator|=
name|sig
operator|-
name|noise
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

