begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 Herb Peyerl<hpeyerl@novatel.ca>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	From: if_ep.c,v 1.9 1994/01/25 10:46:29 deraadt Exp $  *	$Id: if_ep.c,v 1.7 1994/02/03 11:51:06 davidg Exp $  */
end_comment

begin_comment
comment|/*  * TODO:  *	Multi-509 configs.  *	don't pass unit into epstop.  *	epintr returns an int for magnum. 0=not for me. 1=for me. -1=whoknows?  *	deallocate mbufs when ifconfig'd down.  */
end_comment

begin_include
include|#
directive|include
file|"ep.h"
end_include

begin_if
if|#
directive|if
name|NEP
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_include
include|#
directive|include
file|"sys/param.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"sys/systm.h"
end_include

begin_include
include|#
directive|include
file|"sys/kernel.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sys/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"sys/socket.h"
end_include

begin_include
include|#
directive|include
file|"sys/ioctl.h"
end_include

begin_include
include|#
directive|include
file|"sys/errno.h"
end_include

begin_include
include|#
directive|include
file|"sys/syslog.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"sys/select.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"net/if.h"
end_include

begin_include
include|#
directive|include
file|"net/if_dl.h"
end_include

begin_include
include|#
directive|include
file|"net/if_types.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|"netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip.h"
end_include

begin_include
include|#
directive|include
file|"netinet/if_ether.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|"netns/ns.h"
end_include

begin_include
include|#
directive|include
file|"netns/ns_if.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"net/bpf.h"
end_include

begin_include
include|#
directive|include
file|"net/bpfdesc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"machine/pio.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/icu.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/if_epreg.h"
end_include

begin_define
define|#
directive|define
name|ETHER_MIN_LEN
value|64
end_define

begin_define
define|#
directive|define
name|ETHER_MAX_LEN
value|1518
end_define

begin_define
define|#
directive|define
name|ETHER_ADDR_LEN
value|6
end_define

begin_comment
comment|/*  * Ethernet software status per interface.  */
end_comment

begin_struct
struct|struct
name|ep_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common part		*/
name|short
name|ep_io_addr
decl_stmt|;
comment|/* i/o bus address		*/
name|char
name|ep_connectors
decl_stmt|;
comment|/* Connectors on this card.	*/
define|#
directive|define
name|MAX_MBS
value|4
comment|/* # of mbufs we keep around	*/
name|struct
name|mbuf
modifier|*
name|mb
index|[
name|MAX_MBS
index|]
decl_stmt|;
comment|/* spare mbuf storage.		*/
name|int
name|next_mb
decl_stmt|;
comment|/* Which mbuf to use next. 	*/
name|int
name|last_mb
decl_stmt|;
comment|/* Last mbuf.			*/
name|int
name|tx_start_thresh
decl_stmt|;
comment|/* Current TX_start_thresh.	*/
name|caddr_t
name|bpf
decl_stmt|;
comment|/* BPF  "magic cookie"		*/
block|}
name|ep_softc
index|[
name|NEP
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|epprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|int
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|epinit
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|epintr
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|epmbufqueue
name|__P
argument_list|(
operator|(
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|epread
name|__P
argument_list|(
operator|(
expr|struct
name|ep_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|epreset
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|epstart
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|epstop
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|epwatchdog
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|epdriver
init|=
block|{
name|epprobe
block|,
name|epattach
block|,
literal|"ep"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|send_ID_sequence
name|__P
argument_list|(
operator|(
name|u_short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|get_eeprom_data
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_eeprom_busy
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Rudimentary support for multiple cards is here but is not  * currently handled.  In the future we will have to add code  * for tagging the cards for later activation.  We wanna do something  * about the id_port.  We're limited due to current config procedure.  * Magnum config holds promise of a fix but we'll have to wait a bit.  */
end_comment

begin_function
name|int
name|epprobe
parameter_list|(
name|is
parameter_list|)
name|struct
name|isa_device
modifier|*
name|is
decl_stmt|;
block|{
name|struct
name|ep_softc
modifier|*
name|sc
init|=
operator|&
name|ep_softc
index|[
name|is
operator|->
name|id_unit
index|]
decl_stmt|;
name|u_short
name|k
decl_stmt|;
name|int
name|id_port
init|=
literal|0x100
decl_stmt|;
comment|/* XXX */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|GLOBAL_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|id_port
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
comment|/* Global reset to id_port. */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|send_ID_sequence
argument_list|(
name|id_port
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 	 * MFG_ID should have 0x6d50. 	 * PROD_ID should be 0x9[0-f]50 	 */
name|k
operator|=
name|get_eeprom_data
argument_list|(
name|id_port
argument_list|,
name|EEPROM_MFG_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|MFG_ID
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|k
operator|=
name|get_eeprom_data
argument_list|(
name|id_port
argument_list|,
name|EEPROM_PROD_ID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|&
literal|0xf0ff
operator|)
operator|!=
operator|(
name|PROD_ID
operator|&
literal|0xf0ff
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|k
operator|=
name|get_eeprom_data
argument_list|(
name|id_port
argument_list|,
name|EEPROM_ADDR_CFG
argument_list|)
expr_stmt|;
comment|/* get addr cfg */
name|k
operator|=
operator|(
name|k
operator|&
literal|0x1f
operator|)
operator|*
literal|0x10
operator|+
literal|0x200
expr_stmt|;
comment|/* decode base addr. */
if|if
condition|(
name|k
operator|!=
operator|(
name|u_short
operator|)
name|is
operator|->
name|id_iobase
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|k
operator|=
name|get_eeprom_data
argument_list|(
name|id_port
argument_list|,
name|EEPROM_RESOURCE_CFG
argument_list|)
expr_stmt|;
name|k
operator|>>=
literal|12
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|id_irq
operator|!=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|k
operator|==
literal|2
operator|)
condition|?
literal|9
else|:
name|k
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|outb
argument_list|(
name|id_port
argument_list|,
name|ACTIVATE_ADAPTER_TO_CONFIG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0x10
operator|)
return|;
comment|/* 16 bytes of I/O space used. */
block|}
end_function

begin_function
specifier|static
name|int
name|epattach
parameter_list|(
name|is
parameter_list|)
name|struct
name|isa_device
modifier|*
name|is
decl_stmt|;
block|{
name|struct
name|ep_softc
modifier|*
name|sc
init|=
operator|&
name|ep_softc
index|[
name|is
operator|->
name|id_unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|u_short
name|i
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|sc
operator|->
name|ep_io_addr
operator|=
name|is
operator|->
name|id_iobase
expr_stmt|;
name|printf
argument_list|(
literal|"ep%d: "
argument_list|,
name|is
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ep_connectors
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|inw
argument_list|(
name|is
operator|->
name|id_iobase
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|IS_AUI
condition|)
block|{
name|printf
argument_list|(
literal|"aui"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ep_connectors
operator||=
name|AUI
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
name|IS_BNC
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ep_connectors
condition|)
name|printf
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bnc"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ep_connectors
operator||=
name|BNC
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
name|IS_UTP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ep_connectors
condition|)
name|printf
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"utp"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ep_connectors
operator||=
name|UTP
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|ep_connectors
condition|)
name|printf
argument_list|(
literal|"no connectors!"
argument_list|)
expr_stmt|;
comment|/* 	 * Read the station address from the eeprom 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|u_short
modifier|*
name|p
decl_stmt|;
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_eeprom_busy
argument_list|(
name|is
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W0_EEPROM_COMMAND
argument_list|,
name|READ_EEPROM
operator||
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_eeprom_busy
argument_list|(
name|is
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
operator|*
name|p
operator|=
name|htons
argument_list|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W0_EEPROM_DATA
argument_list|)
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W2_ADDR_0
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
name|ntohs
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" address %s\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|is
operator|->
name|id_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ep"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_NOTRAILERS
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|epinit
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|epstart
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|epioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|epwatchdog
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Fill the hardware address into ifa_addr if we find an 	 * AF_LINK entry. We need to do this so bpf's can get the hardware 	 * addr of this card. netstat likes this too! 	 */
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
expr_stmt|;
while|while
condition|(
operator|(
name|ifa
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
operator|)
condition|)
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
expr_stmt|;
if|if
condition|(
operator|(
name|ifa
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|!=
literal|0
operator|)
condition|)
block|{
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ETHER_ADDR_LEN
expr_stmt|;
name|sdl
operator|->
name|sdl_slen
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * The order in here seems important. Otherwise we may not receive  * interrupts. ?!  */
end_comment

begin_function
name|void
name|epinit
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|ep_softc
modifier|*
name|sc
init|=
operator|&
name|ep_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable the card */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable the card */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|,
name|ENABLE_DRQ_IRQ
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Reload the ether_addr. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W2_ADDR_0
operator|+
name|i
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
comment|/* Window 1 is operating window */
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|)
expr_stmt|;
comment|/* get rid of stray intr's */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|ACK_INTR
operator||
literal|0xff
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RD_0_MASK
operator||
name|S_CARD_FAILURE
operator||
name|S_RX_COMPLETE
operator||
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_INTR_MASK
operator||
name|S_CARD_FAILURE
operator||
name|S_RX_COMPLETE
operator||
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RX_FILTER
operator||
name|FIL_INDIVIDUAL
operator||
name|FIL_GROUP
operator||
name|FIL_BRDCST
argument_list|)
expr_stmt|;
comment|/* 	 * you can `ifconfig (link0|-link0) ep0' to get the following 	 * behaviour: 	 *	-link0	disable AUI/UTP. enable BNC. 	 *	link0	disable BNC. enable AUI. if the card has a UTP 	 *		connector, that is enabled too. not sure, but it 	 * 		seems you have to be careful to not plug things 	 *		into both AUI& UTP. 	 */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|ep_connectors
operator|&
name|BNC
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
operator|)
operator|&&
operator|(
name|sc
operator|->
name|ep_connectors
operator|&
name|BNC
operator|)
condition|)
block|{
endif|#
directive|endif
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|START_TRANSCEIVER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|ep_connectors
operator|&
name|UTP
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
operator|)
operator|&&
operator|(
name|sc
operator|->
name|ep_connectors
operator|&
name|UTP
operator|)
condition|)
block|{
endif|#
directive|endif
name|GO_WINDOW
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W4_MEDIA_TYPE
argument_list|,
name|ENABLE_UTP
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_ENABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_ENABLE
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* just in case */
name|sc
operator|->
name|tx_start_thresh
operator|=
literal|20
expr_stmt|;
comment|/* probably a good starting point. */
comment|/* 	 * Store up a bunch of mbuf's for use later. (MAX_MBS). First we 	 * free up any that we had in case we're being called from intr or 	 * somewhere else. 	 */
name|sc
operator|->
name|last_mb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|next_mb
operator|=
literal|0
expr_stmt|;
name|epmbufqueue
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|epstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|const
name|char
name|padmap
index|[]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
name|void
name|epstart
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|register
name|struct
name|ep_softc
modifier|*
name|sc
init|=
operator|&
name|ep_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|top
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|,
name|pad
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|startagain
label|:
comment|/* Sneak a peek at the next packet */
name|m
operator|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
operator|.
name|ifq_head
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|len = m->m_pkthdr.len;
else|#
directive|else
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|top
operator|=
name|m
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
endif|#
directive|endif
name|pad
operator|=
name|padmap
index|[
name|len
operator|&
literal|3
index|]
expr_stmt|;
comment|/* 	 * The 3c509 automatically pads short packets to minimum ethernet 	 * length, but we drop packets that are too large. Perhaps we should 	 * truncate them instead? 	 */
if|if
condition|(
name|len
operator|+
name|pad
operator|>
name|ETHER_MAX_LEN
condition|)
block|{
comment|/* packet is obviously too large: toss it */
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|readcheck
goto|;
block|}
if|if
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_FREE_TX
argument_list|)
operator|<
name|len
operator|+
name|pad
operator|+
literal|4
condition|)
block|{
comment|/* no room in FIFO */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_TX_AVAIL_THRESH
operator||
operator|(
name|len
operator|+
name|pad
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
comment|/* not really needed */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_TX_START_THRESH
operator||
operator|(
name|len
operator|/
literal|4
operator|+
name|sc
operator|->
name|tx_start_thresh
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* Second dword meaningless */
for|for
control|(
name|top
operator|=
name|m
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|outsw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|&
literal|1
condition|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|pad
operator|--
condition|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Padding */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|bpf
condition|)
block|{
name|u_short
name|etype
decl_stmt|;
name|int
name|off
decl_stmt|,
name|datasize
decl_stmt|,
name|resid
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
struct|struct
name|trailer_header
block|{
name|u_short
name|ether_type
decl_stmt|;
name|u_short
name|ether_residual
decl_stmt|;
block|}
name|trailer_header
struct|;
name|char
name|ether_packet
index|[
name|ETHER_MAX_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|ether_packet
expr_stmt|;
comment|/* 		 * We handle trailers below: 		 * Copy ether header first, then residual data, 		 * then data. Put all this in a temporary buffer 		 * 'ether_packet' and send off to bpf. Since the 		 * system has generated this packet, we assume 		 * that all of the offsets in the packet are 		 * correct; if they're not, the system will almost 		 * certainly crash in m_copydata. 		 * We make no assumptions about how the data is 		 * arranged in the mbuf chain (i.e. how much 		 * data is in each mbuf, if mbuf clusters are 		 * used, etc.), which is why we use m_copydata 		 * to get the ether header rather than assume 		 * that this is located in the first mbuf. 		 */
comment|/* copy ether header */
name|m_copydata
argument_list|(
name|top
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|ep
expr_stmt|;
name|ep
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|etype
operator|>=
name|ETHERTYPE_TRAIL
operator|&&
name|etype
operator|<
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
condition|)
block|{
name|datasize
operator|=
operator|(
operator|(
name|etype
operator|-
name|ETHERTYPE_TRAIL
operator|)
operator|<<
literal|9
operator|)
expr_stmt|;
name|off
operator|=
name|datasize
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* copy trailer_header into a data structure */
name|m_copydata
argument_list|(
name|top
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trailer_header
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|trailer_header
operator|.
name|ether_type
argument_list|)
expr_stmt|;
comment|/* copy residual data */
name|resid
operator|=
name|trailer_header
operator|.
name|ether_residual
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|trailer_header
argument_list|)
expr_stmt|;
name|resid
operator|=
name|ntohs
argument_list|(
name|resid
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|top
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|trailer_header
argument_list|)
argument_list|,
name|resid
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|+=
name|resid
expr_stmt|;
comment|/* copy data */
name|m_copydata
argument_list|(
name|top
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|datasize
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|+=
name|datasize
expr_stmt|;
comment|/* restore original ether packet type */
name|eh
operator|->
name|ether_type
operator|=
name|trailer_header
operator|.
name|ether_type
expr_stmt|;
name|bpf_tap
argument_list|(
name|sc
operator|->
name|bpf
argument_list|,
name|ether_packet
argument_list|,
name|ep
operator|-
name|ether_packet
argument_list|)
expr_stmt|;
block|}
else|else
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|bpf
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_opackets
expr_stmt|;
comment|/* 	 * Is another packet coming in? We don't want to overflow the 	 * tiny RX fifo. 	 */
name|readcheck
label|:
if|if
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_STATUS
argument_list|)
operator|&
name|RX_BYTES_MASK
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|startagain
goto|;
block|}
name|void
name|epintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|status
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|struct
name|ep_softc
modifier|*
name|sc
init|=
operator|&
name|ep_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|checkintr
label|:
name|status
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
operator|(
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
operator||
name|S_RX_COMPLETE
operator||
name|S_CARD_FAILURE
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* No interrupts. */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* important that we do this first. */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|ACK_INTR
operator||
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|S_TX_AVAIL
condition|)
block|{
name|status
operator|&=
operator|~
name|S_TX_AVAIL
expr_stmt|;
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_FREE_TX
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|epstart
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|S_RX_COMPLETE
condition|)
block|{
name|status
operator|&=
operator|~
name|S_RX_COMPLETE
expr_stmt|;
name|epread
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|S_CARD_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"ep%d: reset (status: %x)\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
name|epinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|status
operator|&
name|S_TX_COMPLETE
condition|)
block|{
name|status
operator|&=
operator|~
name|S_TX_COMPLETE
expr_stmt|;
comment|/* 		 * We need to read TX_STATUS until we get a 0 status in 		 * order to turn off the interrupt flag. 		 */
while|while
condition|(
operator|(
name|i
operator|=
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|)
operator|)
operator|&
name|TXS_COMPLETE
condition|)
block|{
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|TXS_MAX_COLLISION
operator||
name|TXS_JABBER
operator||
name|TXS_UNDERRUN
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|&
name|TXS_MAX_COLLISION
condition|)
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|TXS_JABBER
operator||
name|TXS_UNDERRUN
operator|)
condition|)
block|{
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|TXS_UNDERRUN
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_start_thresh
operator|<
name|ETHER_MAX_LEN
condition|)
block|{
name|sc
operator|->
name|tx_start_thresh
operator|+=
literal|20
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_TX_START_THRESH
operator||
name|sc
operator|->
name|tx_start_thresh
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_ENABLE
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
expr_stmt|;
block|}
block|}
name|epstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
goto|goto
name|checkintr
goto|;
block|}
name|void
name|epread
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|ep_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mcur
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
name|top
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|lenthisone
decl_stmt|;
name|int
name|save_totlen
decl_stmt|;
name|u_short
name|etype
decl_stmt|;
name|int
name|off
decl_stmt|,
name|resid
decl_stmt|;
name|int
name|count
decl_stmt|,
name|spinwait
decl_stmt|;
name|int
name|i
decl_stmt|;
name|totlen
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_STATUS
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|totlen
operator|&
name|ERR_RX
condition|)
block|{
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|save_totlen
operator|=
name|totlen
operator|&=
name|RX_BYTES_MASK
expr_stmt|;
comment|/* Lower 11 bits = RX bytes. */
name|m
operator|=
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
expr_stmt|;
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* Convert one of our saved mbuf's */
name|sc
operator|->
name|next_mb
operator|=
operator|(
name|sc
operator|->
name|next_mb
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_pktdat
expr_stmt|;
name|m
operator|->
name|m_flags
operator|=
name|M_PKTHDR
expr_stmt|;
block|}
name|top
operator|=
name|m0
operator|=
name|m
expr_stmt|;
comment|/* We assign top so we can "goto out" */
define|#
directive|define
name|EROUND
value|((sizeof(struct ether_header) + 3)& ~3)
define|#
directive|define
name|EOFF
value|(EROUND - sizeof(struct ether_header))
name|m0
operator|->
name|m_data
operator|+=
name|EOFF
expr_stmt|;
comment|/* Read what should be the header. */
name|insw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|totlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/*  	 * mostly deal with trailer here.  (untested) 	 * We do this in a couple of parts.  First we check for a trailer, if 	 * we have one we convert the mbuf back to a regular mbuf and set the offset and 	 * subtract sizeof(struct ether_header) from the pktlen. 	 * After we've read the packet off the interface (all except for the trailer 	 * header, we then get a header mbuf, read the trailer into it, and fix up 	 * the mbuf pointer chain. 	 */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|etype
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|etype
operator|>=
name|ETHERTYPE_TRAIL
operator|&&
name|etype
operator|<
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
condition|)
block|{
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_dat
expr_stmt|;
comment|/* Convert back to regular mbuf.  */
name|m
operator|->
name|m_flags
operator|=
literal|0
expr_stmt|;
comment|/* This sucks but non-trailers are the norm */
name|off
operator|=
operator|(
name|etype
operator|-
name|ETHERTYPE_TRAIL
operator|)
operator|*
literal|512
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|ETHERMTU
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
comment|/* sanity */
block|}
name|totlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* We don't read the trailer */
name|m
operator|->
name|m_data
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
comment|/* Get rid of type& len */
block|}
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
name|lenthisone
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lenthisone
operator|==
literal|0
condition|)
block|{
comment|/* no room in this one */
name|mcur
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
expr_stmt|;
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|timeout
argument_list|(
name|epmbufqueue
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|next_mb
operator|=
operator|(
name|sc
operator|->
name|next_mb
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
block|}
if|if
condition|(
name|totlen
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|mcur
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|lenthisone
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|lenthisone
operator|/
literal|2
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|lenthisone
expr_stmt|;
if|if
condition|(
name|lenthisone
operator|&
literal|1
condition|)
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
operator|=
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|)
expr_stmt|;
name|totlen
operator|-=
name|lenthisone
expr_stmt|;
block|}
if|if
condition|(
name|off
condition|)
block|{
name|top
operator|=
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
expr_stmt|;
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|top
operator|==
literal|0
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* Convert one of our saved mbuf's */
name|sc
operator|->
name|next_mb
operator|=
operator|(
name|sc
operator|->
name|next_mb
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
name|top
operator|->
name|m_data
operator|=
name|top
operator|->
name|m_pktdat
expr_stmt|;
name|top
operator|->
name|m_flags
operator|=
name|M_PKTHDR
expr_stmt|;
block|}
name|insw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|top
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|top
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* XXX Accomodate for type and len from beginning of trailer */
name|top
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|save_totlen
operator|-
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|top
operator|=
name|m0
expr_stmt|;
name|top
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|save_totlen
expr_stmt|;
block|}
name|top
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ipackets
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|bpf
argument_list|,
name|top
argument_list|)
expr_stmt|;
comment|/* 		 * Note that the interface cannot be in promiscuous mode if 		 * there are no BPF listeners.  And if we are in promiscuous 		 * mode, we have to check if this packet is really ours. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|etherbroadcastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|m_adj
argument_list|(
name|top
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|eh
argument_list|,
name|top
argument_list|)
expr_stmt|;
return|return;
name|out
label|:
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
if|if
condition|(
name|top
condition|)
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * Look familiar?  */
specifier|static
name|int
name|epioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ep_softc
modifier|*
name|sc
init|=
operator|&
name|ep_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|epinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|epinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|epinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|epstop
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|epinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|notdef
case|case
name|SIOCGHWADDR
case|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
name|void
name|epreset
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|epstop
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|epinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|void
name|epwatchdog
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ep_softc
modifier|*
name|sc
init|=
operator|&
name|ep_softc
index|[
name|unit
index|]
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ep%d: watchdog\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
expr_stmt|;
name|epreset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
name|void
name|epstop
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ep_softc
modifier|*
name|sc
init|=
operator|&
name|ep_softc
index|[
name|unit
index|]
decl_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_DISABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|STOP_TRANSCEIVER
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RD_0_MASK
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_INTR_MASK
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RX_FILTER
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * This is adapted straight from the book. There's probably a better way.  */
specifier|static
name|int
name|send_ID_sequence
parameter_list|(
name|port
parameter_list|)
name|u_short
name|port
decl_stmt|;
block|{
name|char
name|cx
decl_stmt|,
name|al
decl_stmt|;
name|cx
operator|=
literal|0x0ff
expr_stmt|;
name|al
operator|=
literal|0x0ff
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|loop1
label|:
name|cx
operator|--
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|al
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|al
operator|&
literal|0x80
operator|)
condition|)
block|{
name|al
operator|=
name|al
operator|<<
literal|1
expr_stmt|;
goto|goto
name|loop1
goto|;
block|}
name|al
operator|=
name|al
operator|<<
literal|1
expr_stmt|;
name|al
operator|^=
literal|0xcf
expr_stmt|;
if|if
condition|(
name|cx
condition|)
goto|goto
name|loop1
goto|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * We get eeprom data from the id_port given an offset into the  * eeprom.  Basically; after the ID_sequence is sent to all of  * the cards; they enter the ID_CMD state where they will accept  * command requests. 0x80-0xbf loads the eeprom data.  We then  * read the port 16 times and with every read; the cards check  * for contention (ie: if one card writes a 0 bit and another  * writes a 1 bit then the host sees a 0. At the end of the cycle;  * each card compares the data on the bus; if there is a difference  * then that card goes into ID_WAIT state again). In the meantime;  * one bit of data is returned in the AX register which is conveniently  * returned to us by inb().  Hence; we read 16 times getting one  * bit of data with each read.  */
specifier|static
name|u_short
name|get_eeprom_data
parameter_list|(
name|id_port
parameter_list|,
name|offset
parameter_list|)
name|int
name|id_port
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|data
init|=
literal|0
decl_stmt|;
name|outb
argument_list|(
name|id_port
argument_list|,
literal|0x80
operator|+
name|offset
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|data
operator|=
operator|(
name|data
operator|<<
literal|1
operator|)
operator||
operator|(
name|inw
argument_list|(
name|id_port
argument_list|)
operator|&
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
specifier|static
name|int
name|is_eeprom_busy
parameter_list|(
name|is
parameter_list|)
name|struct
name|isa_device
modifier|*
name|is
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|ep_softc
modifier|*
name|sc
init|=
operator|&
name|ep_softc
index|[
name|is
operator|->
name|id_unit
index|]
decl_stmt|;
while|while
condition|(
name|i
operator|++
operator|<
literal|100
condition|)
block|{
name|j
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W0_EEPROM_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|EEPROM_BUSY
condition|)
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|100
condition|)
block|{
name|printf
argument_list|(
literal|"\nep%d: eeprom failed to come ready.\n"
argument_list|,
name|is
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|j
operator|&
name|EEPROM_TST_MODE
condition|)
block|{
name|printf
argument_list|(
literal|"\nep%d: 3c509 in test mode. Erase pencil mark!\n"
argument_list|,
name|is
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|void
name|epmbufqueue
parameter_list|(
name|sp
parameter_list|,
name|dummy_arg
parameter_list|)
name|caddr_t
name|sp
decl_stmt|;
name|int
name|dummy_arg
decl_stmt|;
block|{
name|struct
name|ep_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ep_softc
operator|*
operator|)
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|last_mb
index|]
condition|)
return|return;
name|i
operator|=
name|sc
operator|->
name|last_mb
expr_stmt|;
do|do
block|{
name|MGET
argument_list|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mb
index|[
name|i
index|]
condition|)
break|break;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|sc
operator|->
name|next_mb
condition|)
do|;
name|sc
operator|->
name|last_mb
operator|=
name|i
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEP> 0 */
end_comment

end_unit

