begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ****************************************************************************************** **        O.S   : FreeBSD **   FILE NAME  : arcmsr.c **        BY    : Erich Chen    **   Description: SCSI RAID Device Driver for  **                ARECA (ARC1110/1120/1160/1210/1220/1260) SATA RAID HOST Adapter **                ARCMSR RAID Host adapter[RAID controller:INTEL 331(PCI-X) 341(PCI-EXPRESS) chip set] ****************************************************************************************** ************************************************************************ ** ** Copyright (c) 2004-2006 ARECA Co. Ltd. **        Erich Chen, Taipei Taiwan All rights reserved. ** ** Redistribution and use in source and binary forms,with or without ** modification,are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice,this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice,this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** 3. The name of the author may not be used to endorse or promote products **    derived from this software without specific prior written permission. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR ** IMPLIED WARRANTIES,INCLUDING,BUT NOT LIMITED TO,THE IMPLIED WARRANTIES ** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,INDIRECT, ** INCIDENTAL,SPECIAL,EXEMPLARY,OR CONSEQUENTIAL DAMAGES(INCLUDING,BUT ** NOT LIMITED TO,PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ** DATA,OR PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY,WHETHER IN CONTRACT,STRICT LIABILITY,OR TORT **(INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF ** THIS SOFTWARE,EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ************************************************************************** ** History ** **        REV#         DATE	            NAME	         DESCRIPTION **     1.00.00.00    3/31/2004	       Erich Chen	     First release **     1.20.00.02   11/29/2004         Erich Chen        bug fix with arcmsr_bus_reset when PHY error ****************************************************************************************** ** $FreeBSD$ */
end_comment

begin_define
define|#
directive|define
name|ARCMSR_DEBUG0
value|0
end_define

begin_comment
comment|/* ********************************** */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<isa/rtc.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_comment
comment|/*  ************************************************************************** ** Define the OS version specific locks  ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500005
end_if

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_define
define|#
directive|define
name|ARCMSR_LOCK_INIT
parameter_list|(
name|l
parameter_list|,
name|s
parameter_list|)
value|mtx_init(l, s,NULL, MTX_DEF|MTX_RECURSE)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_ACQUIRE
parameter_list|(
name|l
parameter_list|)
value|mtx_lock(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_RELEASE
parameter_list|(
name|l
parameter_list|)
value|mtx_unlock(l)
end_define

begin_typedef
typedef|typedef
name|struct
name|mtx
name|arcmsr_lock_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_define
define|#
directive|define
name|ARCMSR_LOCK_INIT
parameter_list|(
name|l
parameter_list|,
name|s
parameter_list|)
value|simple_lock_init(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_ACQUIRE
parameter_list|(
name|l
parameter_list|)
value|simple_lock(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_RELEASE
parameter_list|(
name|l
parameter_list|)
value|simple_unlock(l)
end_define

begin_typedef
typedef|typedef
name|struct
name|simplelock
name|arcmsr_lock_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/arcmsr/arcmsr.h>
end_include

begin_comment
comment|/* ************************************************************************** ** __FreeBSD_version 502010 ************************************************************************** */
end_comment

begin_function_decl
specifier|static
name|VOID
name|arcmsr_interrupt
parameter_list|(
name|VOID
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LONG
name|arcmsr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LONG
name|arcmsr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LONG
name|arcmsr_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|VOID
name|arcmsr_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|ULONG arcmsr_make_timespec(ULONG year,ULONG mon,ULONG day,ULONG hour,ULONG min,ULONG sec); ULONG arcmsr_getcmos_time(VOID);
endif|#
directive|endif
end_endif

begin_function_decl
name|LONG
name|arcmsr_queue_dpc
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|DPCFUN
name|dpcfun
parameter_list|,
name|VOID
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|LONG
name|arcmsr_iop_ioctlcmd
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|ULONG
name|ioctl_cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|BOOLEAN
name|arcmsr_seek_cmd2abort
parameter_list|(
name|union
name|ccb
modifier|*
name|pabortccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|BOOLEAN
name|arcmsr_wait_msgint_ready
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|PSRB
name|arcmsr_get_freesrb
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_free_resource
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_bus_reset
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_stop_adapter_bgrb
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_start_adapter_bgrb
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_iop_init
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_do_dpcQ
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_flush_adapter_cache
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_do_thread_works
parameter_list|(
name|VOID
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_queue_wait2go_srb
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_post_wait2go_srb
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_post_Qbuffer
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_abort_allcmd
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_srb_complete
parameter_list|(
name|PSRB
name|pSRB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_iop_reset
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_report_SenseInfoBuffer
parameter_list|(
name|PSRB
name|pSRB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|VOID
name|arcmsr_build_srb
parameter_list|(
name|PSRB
name|pSRB
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|LONG
name|nseg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ***************************************************************************************** ** Character device switch table **struct cdevsw { **	d_open_t		*d_open; **	d_close_t		*d_close; **	d_read_t		*d_read; **	d_write_t		*d_write; **	d_ioctl_t		*d_ioctl; **	d_poll_t		*d_poll; **	d_mmap_t		*d_mmap; **	d_strategy_t	*d_strategy; **	const char	    *d_name;	   "" base device name, e.g. 'vn'  **	int		         d_maj; **	d_dump_t	    *d_dump; **	d_psize_t	    *d_psize; **	u_int		     d_flags; **	int		         d_bmaj; **	d_kqfilter_t	*d_kqfilter;   "" additions below are not binary compatible with 4.2 and below  **}; ****************************************************************************************** */
end_comment

begin_comment
comment|/* ************************************************************************** ** Insert a delay in micro-seconds and milli-seconds. ** static void MDELAY(LONG ms) { while (ms--) UDELAY(1000); } ************************************************************************** */
end_comment

begin_function
specifier|static
name|VOID
name|UDELAY
parameter_list|(
name|LONG
name|us
parameter_list|)
block|{
name|DELAY
argument_list|(
name|us
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** **  ************************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|arcmsr_map_freesrb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|arcmsr_executesrb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ************************************************************************** **  ************************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|arcmsr_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|arcmsr_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|arcmsr_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|arcmsr_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|arcmsr_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|arcmsr_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|arcmsr_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|arcmsr_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|arcmsr_driver
init|=
block|{
literal|"arcmsr"
block|,
name|arcmsr_methods
block|,
expr|sizeof
operator|(
expr|struct
name|_ACB
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|arcmsr_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|arcmsr
argument_list|,
name|pci
argument_list|,
name|arcmsr_driver
argument_list|,
name|arcmsr_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|arcmsr
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|arcmsr
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502010
end_if

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|arcmsr_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|arcmsr_open
block|,
comment|/* open     */
operator|.
name|d_close
operator|=
name|arcmsr_close
block|,
comment|/* close    */
operator|.
name|d_ioctl
operator|=
name|arcmsr_ioctl
block|,
comment|/* ioctl    */
operator|.
name|d_name
operator|=
literal|"arcmsr"
block|,
comment|/* name     */
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ARCMSR_CDEV_MAJOR
value|180
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|arcmsr_cdevsw
init|=
block|{
name|arcmsr_open
block|,
comment|/* open     */
name|arcmsr_close
block|,
comment|/* close    */
name|noread
block|,
comment|/* read     */
name|nowrite
block|,
comment|/* write    */
name|arcmsr_ioctl
block|,
comment|/* ioctl    */
name|nopoll
block|,
comment|/* poll     */
name|nommap
block|,
comment|/* mmap     */
name|nostrategy
block|,
comment|/* strategy */
literal|"arcmsr"
block|,
comment|/* name     */
name|ARCMSR_CDEV_MAJOR
block|,
comment|/* major    */
name|nodump
block|,
comment|/* dump     */
name|nopsize
block|,
comment|/* psize    */
literal|0
comment|/* flags    */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_open
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_open
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_open
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
name|d_thread_t
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|PACB
name|pACB
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|PACB
name|pACB
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pACB
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
comment|/* Check to make sure the device isn't already open */
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_IOCTL_OPEN
condition|)
block|{
return|return
name|EBUSY
return|;
block|}
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_IOCTL_OPEN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_close
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
name|d_thread_t
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|PACB
name|pACB
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|PACB
name|pACB
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pACB
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOCTL_OPEN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ************************************************************************** **ENOENT **ENOIOCTL **ENOMEM **EINVAL ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_ioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_ioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_ioctl
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
name|d_thread_t
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|PACB
name|pACB
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|PACB
name|pACB
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pACB
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
return|return
operator|(
name|arcmsr_iop_ioctlcmd
argument_list|(
name|pACB
argument_list|,
name|ioctl_cmd
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
name|LONG
name|arcmsr_queue_dpc
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|DPCFUN
name|dpcfun
parameter_list|,
name|VOID
modifier|*
name|arg
parameter_list|)
block|{
name|ULONG
name|s
decl_stmt|;
name|UCHAR
name|index_pointer
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_queue_dpc................. \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|index_pointer
operator|=
operator|(
name|pACB
operator|->
name|dpcQ_tail
operator|+
literal|1
operator|)
operator|%
name|ARCMSR_MAX_DPC
expr_stmt|;
if|if
condition|(
name|index_pointer
operator|==
name|pACB
operator|->
name|dpcQ_head
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DPC Queue full!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pACB
operator|->
name|dpcQ
index|[
name|pACB
operator|->
name|dpcQ_tail
index|]
operator|.
name|dpcfun
operator|=
name|dpcfun
expr_stmt|;
name|pACB
operator|->
name|dpcQ
index|[
name|pACB
operator|->
name|dpcQ_tail
index|]
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|pACB
operator|->
name|dpcQ_tail
operator|=
name|index_pointer
expr_stmt|;
comment|/*  	********************************************************* 	********************************************************* 	*/
name|wakeup
argument_list|(
name|pACB
operator|->
name|kthread_proc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** **         arcmsr_do_dpcQ **    execute dpc routine by kernel thread  *************************************************************************** */
end_comment

begin_function
name|VOID
name|arcmsr_do_dpcQ
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_do_dpcQ................. \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	****************************************** 	****************************************** 	*/
while|while
condition|(
name|pACB
operator|->
name|dpcQ_head
operator|!=
name|pACB
operator|->
name|dpcQ_tail
condition|)
block|{
name|ULONG
name|s
decl_stmt|;
name|DPC
name|dpc
decl_stmt|;
comment|/* got a "dpc routine" */
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|dpc
operator|=
name|pACB
operator|->
name|dpcQ
index|[
name|pACB
operator|->
name|dpcQ_head
index|]
expr_stmt|;
name|pACB
operator|->
name|dpcQ_head
operator|++
expr_stmt|;
name|pACB
operator|->
name|dpcQ_head
operator|%=
name|ARCMSR_MAX_DPC
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* execute this "dpc routine" */
name|dpc
operator|.
name|dpcfun
argument_list|(
name|dpc
operator|.
name|arg
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* ********************************************************************** **<second> bit 05,04,03,02,01,00: 0 - 59  **<minute> bit 11,10,09,08,07,06: 0 - 59  **<month>  bit       15,14,13,12: 1 - 12  **<hour>   bit 21,20,19,18,17,16: 0 - 59  **<day>    bit    26,25,24,23,22: 1 - 31  **<year>   bit    31,30,29,28,27: 0=2000,31=2031  ********************************************************************** */
end_comment

begin_comment
unit|ULONG arcmsr_make_timespec(ULONG year,ULONG mon,ULONG day,ULONG hour,ULONG min,ULONG sec) {     return((year<<27)|(day<<22)|(hour<<16)|(mon<<12)|(min<<6)|(sec)); }
comment|/* ******************************************************************** ******************************************************************** */
end_comment

begin_if
unit|ULONG arcmsr_getcmos_time(VOID) { 	ULONG year,mon,day,hour,min,sec;
if|#
directive|if
name|ARCMSR_DEBUG0
end_if

begin_endif
unit|printf("arcmsr_getcmos_time \n");
endif|#
directive|endif
end_endif

begin_endif
unit|sec=bcd2bin(rtcin(RTC_SEC)); 	min=bcd2bin(rtcin(RTC_MIN)); 	hour=bcd2bin(rtcin(RTC_HRS)); 	day=bcd2bin(rtcin(RTC_DAY)); 	mon=bcd2bin(rtcin(RTC_MONTH)); 	year=bcd2bin(rtcin(RTC_YEAR)); 	if((year +=1900)< 1970) 		year +=100; 	return arcmsr_make_timespec(year,mon,day,hour,min,sec); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* ********************************************************************************* **  Asynchronous notification handler. ********************************************************************************* */
end_comment

begin_function
specifier|static
name|VOID
name|arcmsr_async
parameter_list|(
name|VOID
modifier|*
name|cb_arg
parameter_list|,
name|ULONG
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|VOID
modifier|*
name|arg
parameter_list|)
block|{
name|PACB
name|pACB
decl_stmt|;
name|UCHAR
name|target_id
decl_stmt|,
name|target_lun
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|ULONG
name|s
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_async.......................................... \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|cb_arg
expr_stmt|;
name|pACB
operator|=
operator|(
name|PACB
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_LOST_DEVICE
case|:
name|target_id
operator|=
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|target_lun
operator|=
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target_id
operator|>
name|ARCMSR_MAX_TARGETID
operator|)
operator|||
operator|(
name|target_lun
operator|>
name|ARCMSR_MAX_TARGETLUN
operator|)
condition|)
block|{
break|break;
block|}
name|printf
argument_list|(
literal|"%s:scsi id%d lun%d device lost \n"
argument_list|,
name|device_get_name
argument_list|(
name|pACB
operator|->
name|pci_dev
argument_list|)
argument_list|,
name|target_id
argument_list|,
name|target_lun
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** *         arcmsr_do_thread_works *    execute programs schedule by kernel thread *    execute programs schedule by kernel thread *      :do background rebuilding  * * tsleep(void *ident,int priority,const char *wmesg,int timo) * tsleep() * General sleep call.  Suspends the current process until a wakeup is * performed on the specified identifier.  The process will then be made * runnable with the specified priority.  Sleeps at most timo/hz seconds * (0 means no timeout).  If pri includes PCATCH flag, signals are checked * before and after sleeping, else signals are not checked.  Returns 0 if * awakened, EWOULDBLOCK if the timeout expires.  If PCATCH is set and a * signal needs to be delivered, ERESTART is returned if the current system * call should be restarted if possible, and EINTR is returned if the system * call should be interrupted by the signal (return EINTR). * * await(int priority, int timo) * await() - wait for async condition to occur.   The process blocks until * wakeup() is called on the most recent asleep() address.  If wakeup is called * priority to await(), await() winds up being a NOP. * * If await() is called more then once (without an intervening asleep() call), * await() is still effectively a NOP but it calls mi_switch() to give other * processes some cpu before returning.  The process is left runnable. * *<<<<<<<< EXPERIMENTAL, UNTESTED>>>>>>>>>> * asleep(void *ident, int priority, const char *wmesg, int timo) * asleep() - async sleep call.  Place process on wait queue and return  * immediately without blocking.  The process stays runnable until await()  * is called.  If ident is NULL, remove process from wait queue if it is still * on one. * * Only the most recent sleep condition is effective when making successive * calls to asleep() or when calling tsleep(). * * The timeout, if any, is not initiated until await() is called.  The sleep * priority, signal, and timeout is specified in the asleep() call but may be * overriden in the await() call. * *<<<<<<<< EXPERIMENTAL, UNTESTED>>>>>>>>>> *      :do background rebuilding  *************************************************************************** */
end_comment

begin_function
name|VOID
name|arcmsr_do_thread_works
parameter_list|(
name|VOID
modifier|*
name|arg
parameter_list|)
block|{
name|PACB
name|pACB
init|=
operator|(
name|PACB
operator|)
name|arg
decl_stmt|;
name|ARCMSR_LOCK_INIT
argument_list|(
operator|&
name|pACB
operator|->
name|arcmsr_kthread_lock
argument_list|,
literal|"arcmsr kthread lock"
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_do_thread_works................. \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|pACB
operator|->
name|arcmsr_kthread_lock
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|pACB
operator|->
name|kthread_proc
argument_list|,
name|PRIBIO
operator||
name|PWAIT
argument_list|,
literal|"arcmsr"
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
comment|/*.25 sec*/
comment|/* 		** if do_dpcQ_semaphore is signal 		** do following works 		*/
name|arcmsr_do_dpcQ
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
comment|/*see if there were some dpc routine need to execute*/
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_STOP_THREAD
condition|)
block|{
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|pACB
operator|->
name|arcmsr_kthread_lock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** ** ************************************************************************ */
end_comment

begin_function
name|VOID
name|arcmsr_flush_adapter_cache
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_flush_adapter_cache..............\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_FLUSH_CACHE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  **   ** ********************************************************************** */
end_comment

begin_function
name|BOOLEAN
name|arcmsr_wait_msgint_ready
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|ULONG
name|Index
decl_stmt|;
name|UCHAR
name|Retries
init|=
literal|0x00
decl_stmt|;
do|do
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
literal|500000
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
name|CHIP_REG_READ32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intstatus
argument_list|)
operator|&
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INT
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intstatus
argument_list|,
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INT
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
return|return
name|TRUE
return|;
block|}
comment|/* one us delay	*/
name|UDELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/*max 5 seconds*/
block|}
do|while
condition|(
name|Retries
operator|++
operator|<
literal|24
condition|)
do|;
comment|/*max 2 minutes*/
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ** **  Q back this SRB into ACB ArraySRB ** ********************************************************************** */
end_comment

begin_function
name|VOID
name|arcmsr_srb_complete
parameter_list|(
name|PSRB
name|pSRB
parameter_list|)
block|{
name|ULONG
name|s
decl_stmt|;
name|PACB
name|pACB
init|=
name|pSRB
operator|->
name|pACB
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
init|=
name|pSRB
operator|->
name|pccb
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_srb_complete: pSRB=%p srb_doneindex=%x srb_startindex=%x\n"
argument_list|,
name|pSRB
argument_list|,
name|pACB
operator|->
name|srb_doneindex
argument_list|,
name|pACB
operator|->
name|srb_startindex
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|pACB
operator|->
name|srboutstandingcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_DONE
expr_stmt|;
name|pSRB
operator|->
name|srb_flags
operator|=
literal|0
expr_stmt|;
name|pACB
operator|->
name|psrbringQ
index|[
name|pACB
operator|->
name|srb_doneindex
index|]
operator|=
name|pSRB
expr_stmt|;
name|pACB
operator|->
name|srb_doneindex
operator|++
expr_stmt|;
name|pACB
operator|->
name|srb_doneindex
operator|%=
name|ARCMSR_MAX_FREESRB_NUM
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **       if scsi error do auto request sense ********************************************************************** */
end_comment

begin_function
name|VOID
name|arcmsr_report_SenseInfoBuffer
parameter_list|(
name|PSRB
name|pSRB
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|pccb
init|=
name|pSRB
operator|->
name|pccb
decl_stmt|;
name|PSENSE_DATA
name|psenseBuffer
init|=
operator|(
name|PSENSE_DATA
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_report_SenseInfoBuffer...........\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
if|if
condition|(
name|psenseBuffer
condition|)
block|{
name|memset
argument_list|(
name|psenseBuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|psenseBuffer
argument_list|,
name|pSRB
operator|->
name|arcmsr_cdb
operator|.
name|SenseData
argument_list|,
name|get_min
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_SENSE_DATA
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|psenseBuffer
operator|->
name|ErrorCode
operator|=
literal|0x70
expr_stmt|;
name|psenseBuffer
operator|->
name|Valid
operator|=
literal|1
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************* ** to insert pSRB into tail of pACB wait exec srbQ  ********************************************************************* */
end_comment

begin_function
name|VOID
name|arcmsr_queue_wait2go_srb
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
block|{
name|ULONG
name|s
decl_stmt|;
name|LONG
name|i
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_qtail_wait2go_srb:......................................... \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
operator|=
name|pSRB
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|pACB
operator|->
name|srbwait2gocount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|++
expr_stmt|;
name|i
operator|%=
name|ARCMSR_MAX_OUTSTANDING_CMD
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************* **  ********************************************************************* */
end_comment

begin_function
name|VOID
name|arcmsr_abort_allcmd
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_ABORT_CMD
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* **************************************************************************** ** Routine Description: Reset 80331 iop. **           Arguments:  **        Return Value: Nothing. **************************************************************************** */
end_comment

begin_function
name|VOID
name|arcmsr_iop_reset
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|PSRB
name|pSRB
decl_stmt|,
name|pfreesrb
decl_stmt|;
name|ULONG
name|intmask_org
decl_stmt|,
name|mask
decl_stmt|;
name|LONG
name|i
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_iop_reset: reset iop controller......................................\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pACB
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
comment|/* Q back all outstanding srb into wait exec psrb Q*/
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_iop_reset: srboutstandingcount=%d ...\n"
argument_list|,
name|pACB
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
argument_list|)
expr_stmt|;
comment|/* talk to iop 331 outstanding command aborted*/
name|arcmsr_abort_allcmd
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr_iop_reset: wait 'abort all outstanding command' timeout.................in \n"
argument_list|)
expr_stmt|;
block|}
comment|/*clear all outbound posted Q*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|;
name|i
operator|++
control|)
block|{
name|CHIP_REG_READ32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_queueport
argument_list|)
expr_stmt|;
block|}
name|pfreesrb
operator|=
name|pACB
operator|->
name|pfreesrb
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|pSRB
operator|=
operator|&
name|pfreesrb
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
name|pSRB
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* enable all outbound interrupt */
name|mask
operator|=
operator|~
operator|(
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE
operator|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
name|intmask_org
operator|&
name|mask
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|pACB
operator|->
name|srboutstandingcount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* post abort all outstanding command message to RAID controller */
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pACB
operator|->
name|srbwait2gocount
operator|>
literal|0
condition|)
block|{
name|pSRB
operator|=
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_iop_reset:abort command... srbwait2gocount=%d ...\n"
argument_list|,
name|pACB
operator|->
name|srbwait2gocount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pSRB
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|pACB
operator|->
name|srbwait2gocount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|i
operator|%=
name|ARCMSR_MAX_OUTSTANDING_CMD
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  ** PAGE_SIZE=4096 or 8192,PAGE_SHIFT=12 ********************************************************************** */
end_comment

begin_function
name|VOID
name|arcmsr_build_srb
parameter_list|(
name|PSRB
name|pSRB
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|LONG
name|nseg
parameter_list|)
block|{
name|PARCMSR_CDB
name|pARCMSR_CDB
init|=
operator|&
name|pSRB
operator|->
name|arcmsr_cdb
decl_stmt|;
name|PCHAR
name|psge
init|=
operator|(
name|PCHAR
operator|)
operator|&
name|pARCMSR_CDB
operator|->
name|u
decl_stmt|;
name|ULONG
name|address_lo
decl_stmt|,
name|address_hi
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
init|=
name|pSRB
operator|->
name|pccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|pcsio
init|=
operator|&
name|pccb
operator|->
name|csio
decl_stmt|;
name|LONG
name|arccdbsize
init|=
literal|0x30
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_build_srb........................... \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|pARCMSR_CDB
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_ARCMSR_CDB
argument_list|)
argument_list|)
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|Bus
operator|=
literal|0
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|TargetID
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|LUN
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|Function
operator|=
literal|1
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|CdbLength
operator|=
operator|(
name|UCHAR
operator|)
name|pcsio
operator|->
name|cdb_len
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|Context
operator|=
operator|(
name|CPT2INT
operator|)
name|pARCMSR_CDB
expr_stmt|;
name|bcopy
argument_list|(
name|pcsio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|pARCMSR_CDB
operator|->
name|Cdb
argument_list|,
name|pcsio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|PACB
name|pACB
init|=
name|pSRB
operator|->
name|pACB
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|LONG
name|length
decl_stmt|,
name|i
decl_stmt|,
name|cdb_sgcount
init|=
literal|0
decl_stmt|;
comment|/* map stor port SG list to our iop SG List.*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get the physical address of the current data pointer */
name|length
operator|=
operator|(
name|ULONG
operator|)
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
name|address_lo
operator|=
name|dma_addr_lo32
argument_list|(
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|address_hi
operator|=
name|dma_addr_hi32
argument_list|(
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_hi
operator|==
literal|0
condition|)
block|{
name|PSG32ENTRY
name|pdma_sg
init|=
operator|(
name|PSG32ENTRY
operator|)
name|psge
decl_stmt|;
name|pdma_sg
operator|->
name|address
operator|=
name|address_lo
expr_stmt|;
name|pdma_sg
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
name|SG32ENTRY
argument_list|)
expr_stmt|;
name|arccdbsize
operator|+=
sizeof|sizeof
argument_list|(
name|SG32ENTRY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LONG
name|sg64s_size
init|=
literal|0
decl_stmt|,
name|tmplength
init|=
name|length
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_build_srb: !!!!!!!!!!!......address_hi=%x.... \n"
argument_list|,
name|address_hi
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
name|LONG64
name|span4G
decl_stmt|,
name|length0
decl_stmt|;
name|PSG64ENTRY
name|pdma_sg
init|=
operator|(
name|PSG64ENTRY
operator|)
name|psge
decl_stmt|;
name|span4G
operator|=
operator|(
name|LONG64
operator|)
name|address_lo
operator|+
name|tmplength
expr_stmt|;
name|pdma_sg
operator|->
name|addresshigh
operator|=
name|address_hi
expr_stmt|;
name|pdma_sg
operator|->
name|address
operator|=
name|address_lo
expr_stmt|;
if|if
condition|(
name|span4G
operator|>
literal|0x100000000
condition|)
block|{
comment|/*see if cross 4G boundary*/
name|length0
operator|=
literal|0x100000000
operator|-
name|address_lo
expr_stmt|;
name|pdma_sg
operator|->
name|length
operator|=
operator|(
name|ULONG
operator|)
name|length0
operator||
name|IS_SG64_ADDR
expr_stmt|;
name|address_hi
operator|=
name|address_hi
operator|+
literal|1
expr_stmt|;
name|address_lo
operator|=
literal|0
expr_stmt|;
name|tmplength
operator|=
name|tmplength
operator|-
operator|(
name|LONG
operator|)
name|length0
expr_stmt|;
name|sg64s_size
operator|+=
sizeof|sizeof
argument_list|(
name|SG64ENTRY
argument_list|)
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
name|SG64ENTRY
argument_list|)
expr_stmt|;
name|cdb_sgcount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pdma_sg
operator|->
name|length
operator|=
name|tmplength
operator||
name|IS_SG64_ADDR
expr_stmt|;
name|sg64s_size
operator|+=
sizeof|sizeof
argument_list|(
name|SG64ENTRY
argument_list|)
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
name|SG64ENTRY
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|arccdbsize
operator|+=
name|sg64s_size
expr_stmt|;
block|}
name|cdb_sgcount
operator|++
expr_stmt|;
block|}
name|pARCMSR_CDB
operator|->
name|sgcount
operator|=
operator|(
name|UCHAR
operator|)
name|cdb_sgcount
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|DataLength
operator|=
name|pcsio
operator|->
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|arccdbsize
operator|>
literal|256
condition|)
block|{
name|pARCMSR_CDB
operator|->
name|Flags
operator||=
name|ARCMSR_CDB_FLAG_SGL_BSIZE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|Flags
operator||=
name|ARCMSR_CDB_FLAG_WRITE
expr_stmt|;
name|pSRB
operator|->
name|srb_flags
operator||=
name|SRB_FLAG_WRITE
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_build_srb: pSRB=%p cmd=%x xferlength=%d arccdbsize=%d sgcount=%d\n"
argument_list|,
name|pSRB
argument_list|,
name|pcsio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
name|pARCMSR_CDB
operator|->
name|DataLength
argument_list|,
name|arccdbsize
argument_list|,
name|pARCMSR_CDB
operator|->
name|sgcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ** **	arcmsr_post_srb - Send a protocol specific ARC send postcard to a AIOC . **	handle: Handle of registered ARC protocol driver **	adapter_id: AIOC unique identifier(integer) **	pPOSTCARD_SEND: Pointer to ARC send postcard ** **	This routine posts a ARC send postcard to the request post FIFO of a **	specific ARC adapter. **                              ************************************************************************** */
end_comment

begin_function
specifier|static
name|VOID
name|arcmsr_post_srb
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
block|{
name|ULONG
name|cdb_shifted_phyaddr
init|=
operator|(
name|ULONG
operator|)
name|pSRB
operator|->
name|cdb_shifted_phyaddr
decl_stmt|;
name|PARCMSR_CDB
name|pARCMSR_CDB
init|=
operator|(
name|PARCMSR_CDB
operator|)
operator|&
name|pSRB
operator|->
name|arcmsr_cdb
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_post_srb: pSRB=%p  cdb_shifted_phyaddr=%x\n"
argument_list|,
name|pSRB
argument_list|,
name|cdb_shifted_phyaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|atomic_add_int
argument_list|(
operator|&
name|pACB
operator|->
name|srboutstandingcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_START
expr_stmt|;
if|if
condition|(
name|pARCMSR_CDB
operator|->
name|Flags
operator|&
name|ARCMSR_CDB_FLAG_SGL_BSIZE
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_queueport
argument_list|,
name|cdb_shifted_phyaddr
operator||
name|ARCMSR_SRBPOST_FLAG_SGL_BSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_queueport
argument_list|,
name|cdb_shifted_phyaddr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ** ** ************************************************************************** */
end_comment

begin_function
name|VOID
name|arcmsr_post_wait2go_srb
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|ULONG
name|s
decl_stmt|;
name|PSRB
name|pSRB
decl_stmt|;
name|LONG
name|i
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_post_wait2go_srb:srbwait2gocount=%d srboutstandingcount=%d\n"
argument_list|,
name|pACB
operator|->
name|srbwait2gocount
argument_list|,
name|pACB
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pACB
operator|->
name|srbwait2gocount
operator|>
literal|0
operator|)
operator|&&
operator|(
name|pACB
operator|->
name|srboutstandingcount
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
operator|)
condition|)
block|{
name|pSRB
operator|=
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|!=
name|NULL
condition|)
block|{
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|arcmsr_post_srb
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|pACB
operator|->
name|srbwait2gocount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|i
operator|%=
name|ARCMSR_MAX_OUTSTANDING_CMD
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **   Function: arcmsr_post_Qbuffer **     Output:  ********************************************************************** */
end_comment

begin_function
name|VOID
name|arcmsr_post_Qbuffer
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|ULONG
name|s
decl_stmt|;
name|PUCHAR
name|pQbuffer
decl_stmt|;
name|PQBUFFER
name|pwbuffer
init|=
operator|(
name|PQBUFFER
operator|)
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|ioctl_wbuffer
decl_stmt|;
name|PUCHAR
name|iop_data
init|=
operator|(
name|PUCHAR
operator|)
name|pwbuffer
operator|->
name|data
decl_stmt|;
name|LONG
name|allxfer_len
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pACB
operator|->
name|wqbuf_firstindex
operator|!=
name|pACB
operator|->
name|wqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|124
operator|)
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|pACB
operator|->
name|wqbuffer
index|[
name|pACB
operator|->
name|wqbuf_firstindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|iop_data
argument_list|,
name|pQbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|wqbuf_firstindex
operator|++
expr_stmt|;
name|pACB
operator|->
name|wqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
name|pwbuffer
operator|->
name|data_len
operator|=
name|allxfer_len
expr_stmt|;
comment|/* 	** push inbound doorbell and wait reply at hwinterrupt routine for next Qbuffer post 	*/
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** ** ************************************************************************ */
end_comment

begin_function
name|VOID
name|arcmsr_stop_adapter_bgrb
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_stop_adapter_bgrb..............\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_MSG_STOP_BGRB
expr_stmt|;
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_STOP_BGRB
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ **   **                   ************************************************************************ */
end_comment

begin_function
specifier|static
name|VOID
name|arcmsr_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|psim
parameter_list|)
block|{
name|arcmsr_interrupt
argument_list|(
name|cam_sim_softc
argument_list|(
name|psim
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **   Function:  arcmsr_interrupt **     Output:  VOID **   CAM  Status field values    **typedef enum { **	CAM_REQ_INPROG,		   CCB request is in progress    **	CAM_REQ_CMP,		   CCB request completed without error    **	CAM_REQ_ABORTED,	   CCB request aborted by the host    **	CAM_UA_ABORT,		   Unable to abort CCB request    **	CAM_REQ_CMP_ERR,	   CCB request completed with an error    **	CAM_BUSY,		       CAM subsytem is busy    **	CAM_REQ_INVALID,	   CCB request was invalid    **	CAM_PATH_INVALID,	   Supplied Path ID is invalid    **	CAM_DEV_NOT_THERE,	   SCSI Device Not Installed/there    **	CAM_UA_TERMIO,		   Unable to terminate I/O CCB request    **	CAM_SEL_TIMEOUT,	   Target Selection Timeout    **	CAM_CMD_TIMEOUT,	   Command timeout    **	CAM_SCSI_STATUS_ERROR,	   SCSI error, look at error code in CCB    **	CAM_MSG_REJECT_REC,	   Message Reject Received    **	CAM_SCSI_BUS_RESET,	   SCSI Bus Reset Sent/Received    **	CAM_UNCOR_PARITY,	   Uncorrectable parity error occurred    **	CAM_AUTOSENSE_FAIL=0x10,   Autosense: request sense cmd fail    **	CAM_NO_HBA,		   No HBA Detected error    **	CAM_DATA_RUN_ERR,	   Data Overrun error    **	CAM_UNEXP_BUSFREE,	   Unexpected Bus Free    **	CAM_SEQUENCE_FAIL,	   Target Bus Phase Sequence Failure    **	CAM_CCB_LEN_ERR,	   CCB length supplied is inadequate    **	CAM_PROVIDE_FAIL,	   Unable to provide requested capability    **	CAM_BDR_SENT,		   A SCSI BDR msg was sent to target    **	CAM_REQ_TERMIO,		   CCB request terminated by the host    **	CAM_UNREC_HBA_ERROR,	   Unrecoverable Host Bus Adapter Error    **	CAM_REQ_TOO_BIG,	   The request was too large for this host    **	CAM_REQUEUE_REQ,	   **				 * This request should be requeued to preserve **				 * transaction ordering.  This typically occurs **				 * when the SIM recognizes an error that should **				 * freeze the queue and must place additional **				 * requests for the target at the sim level **				 * back into the XPT queue. **				    **	CAM_IDE=0x33,		   Initiator Detected Error    **	CAM_RESRC_UNAVAIL,	   Resource Unavailable    **	CAM_UNACKED_EVENT,	   Unacknowledged Event by Host    **	CAM_MESSAGE_RECV,	   Message Received in Host Target Mode    **	CAM_INVALID_CDB,	   Invalid CDB received in Host Target Mode    **	CAM_LUN_INVALID,	   Lun supplied is invalid    **	CAM_TID_INVALID,	   Target ID supplied is invalid    **	CAM_FUNC_NOTAVAIL,	   The requested function is not available    **	CAM_NO_NEXUS,		   Nexus is not established    **	CAM_IID_INVALID,	   The initiator ID is invalid    **	CAM_CDB_RECVD,		   The SCSI CDB has been received    **	CAM_LUN_ALRDY_ENA,	   The LUN is already eanbeld for target mode    **	CAM_SCSI_BUSY,		   SCSI Bus Busy    ** **	CAM_DEV_QFRZN=0x40,	   The DEV queue is frozen w/this err    ** **				   Autosense data valid for target    **	CAM_AUTOSNS_VALID=0x80, **	CAM_RELEASE_SIMQ=0x100,   SIM ready to take more commands    **	CAM_SIM_QUEUED  =0x200,   SIM has this command in it's queue    ** **	CAM_STATUS_MASK=0x3F,	   Mask bits for just the status #    ** **				   Target Specific Adjunct Status    **	CAM_SENT_SENSE=0x40000000	   sent sense with status    **} cam_status; ********************************************************************** */
end_comment

begin_function
specifier|static
name|VOID
name|arcmsr_interrupt
parameter_list|(
name|VOID
modifier|*
name|arg
parameter_list|)
block|{
name|PACB
name|pACB
init|=
operator|(
name|PACB
operator|)
name|arg
decl_stmt|;
name|PSRB
name|pSRB
decl_stmt|;
name|ULONG
name|flagpsrb
decl_stmt|,
name|outbound_intstatus
decl_stmt|,
name|outbound_doorbell
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_interrupt..............\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	********************************************* 	**   check outbound intstatus Llta 	********************************************* 	*/
name|outbound_intstatus
operator|=
name|CHIP_REG_READ32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intstatus
argument_list|)
operator|&
name|pACB
operator|->
name|outbound_int_enable
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intstatus
argument_list|,
name|outbound_intstatus
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
if|if
condition|(
name|outbound_intstatus
operator|&
name|ARCMSR_MU_OUTBOUND_DOORBELL_INT
condition|)
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_interrupt:..........ARCMSR_MU_OUTBOUND_DOORBELL_INT\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		********************************************* 		**  DOORBELL m! O_ln 		********************************************* 		*/
name|outbound_doorbell
operator|=
name|CHIP_REG_READ32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_doorbell
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_doorbell
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
comment|/*clear interrupt */
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK
condition|)
block|{
name|PQBUFFER
name|prbuffer
init|=
operator|(
name|PQBUFFER
operator|)
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|ioctl_rbuffer
decl_stmt|;
name|PUCHAR
name|iop_data
init|=
operator|(
name|PUCHAR
operator|)
name|prbuffer
operator|->
name|data
decl_stmt|;
name|PUCHAR
name|pQbuffer
decl_stmt|;
name|LONG
name|my_empty_len
decl_stmt|,
name|iop_len
decl_stmt|,
name|rqbuf_firstindex
decl_stmt|,
name|rqbuf_lastindex
decl_stmt|;
name|ULONG
name|s
decl_stmt|;
comment|/*check this iop data if overflow my rqbuffer*/
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|rqbuf_lastindex
operator|=
name|pACB
operator|->
name|rqbuf_lastindex
expr_stmt|;
name|rqbuf_firstindex
operator|=
name|pACB
operator|->
name|rqbuf_firstindex
expr_stmt|;
name|iop_len
operator|=
name|prbuffer
operator|->
name|data_len
expr_stmt|;
name|my_empty_len
operator|=
operator|(
name|rqbuf_firstindex
operator|-
name|rqbuf_lastindex
operator|-
literal|1
operator|)
operator|&
operator|(
name|ARCMSR_MAX_QBUFFER
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|my_empty_len
operator|>=
name|iop_len
condition|)
block|{
while|while
condition|(
name|iop_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|pACB
operator|->
name|rqbuffer
index|[
name|pACB
operator|->
name|rqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|iop_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|rqbuf_lastindex
operator|++
expr_stmt|;
name|pACB
operator|->
name|rqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|iop_len
operator|--
expr_stmt|;
block|}
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
else|else
block|{
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_OUTBOUND_IOP331_DATA_READ_OK
condition|)
block|{
name|ULONG
name|s
decl_stmt|;
comment|/* 			********************************************* 			**           O_lnDHX 			********************************************* 			*/
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|wqbuf_firstindex
operator|!=
name|pACB
operator|->
name|wqbuf_lastindex
condition|)
block|{
name|PUCHAR
name|pQbuffer
decl_stmt|;
name|PQBUFFER
name|pwbuffer
init|=
operator|(
name|PQBUFFER
operator|)
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|ioctl_wbuffer
decl_stmt|;
name|PUCHAR
name|iop_data
init|=
operator|(
name|PUCHAR
operator|)
name|pwbuffer
operator|->
name|data
decl_stmt|;
name|LONG
name|allxfer_len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|pACB
operator|->
name|wqbuf_firstindex
operator|!=
name|pACB
operator|->
name|wqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|124
operator|)
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|pACB
operator|->
name|wqbuffer
index|[
name|pACB
operator|->
name|wqbuf_firstindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|iop_data
argument_list|,
name|pQbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|wqbuf_firstindex
operator|++
expr_stmt|;
name|pACB
operator|->
name|wqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
name|pwbuffer
operator|->
name|data_len
operator|=
name|allxfer_len
expr_stmt|;
comment|/* 				** push inbound doorbell tell iop driver data write ok and wait reply on next hwinterrupt for next Qbuffer post 				*/
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_IOCTL_WQBUFFER_CLEARED
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outbound_intstatus
operator|&
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
condition|)
block|{
comment|/* 		***************************************************************************** 		**               areca cdb command done 		***************************************************************************** 		*/
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|flagpsrb
operator|=
name|CHIP_REG_READ32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_queueport
argument_list|)
operator|)
operator|==
literal|0xFFFFFFFF
condition|)
block|{
break|break;
comment|/*chip FIFO no srb for completion already*/
block|}
comment|/* check if command done with no error*/
name|pSRB
operator|=
call|(
name|PSRB
call|)
argument_list|(
name|CINT2P
argument_list|)
argument_list|(
name|pACB
operator|->
name|vir2phy_offset
operator|+
operator|(
name|flagpsrb
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
comment|/*frame must be 32 bytes aligned*/
if|if
condition|(
operator|(
name|pSRB
operator|->
name|pACB
operator|!=
name|pACB
operator|)
operator|||
operator|(
name|pSRB
operator|->
name|startdone
operator|!=
name|ARCMSR_SRB_START
operator|)
condition|)
block|{
if|if
condition|(
name|pSRB
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_ABORTED
condition|)
block|{
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"arcmsr_interrupt:got an illegal srb command done ...pACB=%p pSRB=%p srboutstandingcount=%d .....\n"
argument_list|,
name|pACB
argument_list|,
name|pSRB
argument_list|,
name|pACB
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|flagpsrb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|pSRB
operator|->
name|arcmsr_cdb
operator|.
name|DeviceStatus
condition|)
block|{
case|case
name|ARCMSR_DEV_SELECT_TIMEOUT
case|:
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"pSRB=%p ......ARCMSR_DEV_SELECT_TIMEOUT\n"
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_DEV_ABORTED
case|:
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"pSRB=%p ......ARCMSR_DEV_ABORTED\n"
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_DEV_INIT_FAIL
case|:
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"pSRB=%p .....ARCMSR_DEV_INIT_FAIL\n"
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCSISTAT_CHECK_CONDITION
case|:
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"pSRB=%p .....SCSISTAT_CHECK_CONDITION\n"
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arcmsr_report_SenseInfoBuffer
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* error occur Q all error srb to errorsrbpending Q*/
name|printf
argument_list|(
literal|"arcmsr_interrupt:command error done ......but got unknow DeviceStatus=%x....\n"
argument_list|,
name|pSRB
operator|->
name|arcmsr_cdb
operator|.
name|DeviceStatus
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNCOR_PARITY
expr_stmt|;
comment|/*unknow error or crc error just for retry*/
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*drain reply FIFO*/
block|}
if|if
condition|(
name|pACB
operator|->
name|srbwait2gocount
operator|!=
literal|0
condition|)
block|{
name|arcmsr_post_wait2go_srb
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
comment|/*try to post all pending srb*/
block|}
return|return;
block|}
end_function

begin_comment
comment|/* *********************************************************************** ** **int	copyin __P((const void *udaddr, void *kaddr, size_t len)); **int	copyout __P((const void *kaddr, void *udaddr, size_t len)); ** **ENOENT     "" No such file or directory "" **ENOIOCTL   "" ioctl not handled by this layer "" **ENOMEM     "" Cannot allocate memory "" **EINVAL     "" Invalid argument "" ************************************************************************ */
end_comment

begin_function
name|LONG
name|arcmsr_iop_ioctlcmd
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|ULONG
name|ioctl_cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|PCMD_IO_CONTROL
name|pccbioctl
init|=
operator|(
name|PCMD_IO_CONTROL
operator|)
name|arg
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_iop_ioctlcmd................. \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|memcmp
argument_list|(
name|pccbioctl
operator|->
name|Signature
argument_list|,
literal|"ARCMSR"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|ioctl_cmd
condition|)
block|{
case|case
name|ARCMSR_IOCTL_READ_RQBUFFER
case|:
block|{
name|ULONG
name|s
decl_stmt|;
name|PCMD_IOCTL_FIELD
name|pccbioctlfld
init|=
operator|(
name|PCMD_IOCTL_FIELD
operator|)
name|arg
decl_stmt|;
name|PUCHAR
name|pQbuffer
decl_stmt|,
name|ptmpQbuffer
init|=
name|pccbioctlfld
operator|->
name|ioctldatabuffer
decl_stmt|;
name|LONG
name|allxfer_len
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pACB
operator|->
name|rqbuf_firstindex
operator|!=
name|pACB
operator|->
name|rqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|1031
operator|)
condition|)
block|{
comment|/*copy READ QBUFFER to srb*/
name|pQbuffer
operator|=
operator|&
name|pACB
operator|->
name|rqbuffer
index|[
name|pACB
operator|->
name|rqbuf_firstindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|ptmpQbuffer
argument_list|,
name|pQbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|rqbuf_firstindex
operator|++
expr_stmt|;
name|pACB
operator|->
name|rqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|ptmpQbuffer
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|PQBUFFER
name|prbuffer
init|=
operator|(
name|PQBUFFER
operator|)
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|ioctl_rbuffer
decl_stmt|;
name|PUCHAR
name|pQbuffer
decl_stmt|;
name|PUCHAR
name|iop_data
init|=
operator|(
name|PUCHAR
operator|)
name|prbuffer
operator|->
name|data
decl_stmt|;
name|LONG
name|iop_len
decl_stmt|;
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|iop_len
operator|=
operator|(
name|LONG
operator|)
name|prbuffer
operator|->
name|data_len
expr_stmt|;
comment|/*this iop data does no chance to make me overflow again here, so just do it*/
while|while
condition|(
name|iop_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|pACB
operator|->
name|rqbuffer
index|[
name|pACB
operator|->
name|rqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|iop_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|rqbuf_lastindex
operator|++
expr_stmt|;
name|pACB
operator|->
name|rqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|iop_len
operator|--
expr_stmt|;
block|}
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
name|pccbioctl
operator|->
name|Length
operator|=
name|allxfer_len
expr_stmt|;
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_OK
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
case|case
name|ARCMSR_IOCTL_WRITE_WQBUFFER
case|:
block|{
name|ULONG
name|s
decl_stmt|;
name|PCMD_IOCTL_FIELD
name|pccbioctlfld
init|=
operator|(
name|PCMD_IOCTL_FIELD
operator|)
name|arg
decl_stmt|;
name|LONG
name|my_empty_len
decl_stmt|,
name|user_len
decl_stmt|,
name|wqbuf_firstindex
decl_stmt|,
name|wqbuf_lastindex
decl_stmt|;
name|PUCHAR
name|pQbuffer
decl_stmt|,
name|ptmpuserbuffer
init|=
name|pccbioctlfld
operator|->
name|ioctldatabuffer
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|user_len
operator|=
name|pccbioctl
operator|->
name|Length
expr_stmt|;
comment|/*check if data xfer length of this request will overflow my array qbuffer */
name|wqbuf_lastindex
operator|=
name|pACB
operator|->
name|wqbuf_lastindex
expr_stmt|;
name|wqbuf_firstindex
operator|=
name|pACB
operator|->
name|wqbuf_firstindex
expr_stmt|;
name|my_empty_len
operator|=
operator|(
name|wqbuf_firstindex
operator|-
name|wqbuf_lastindex
operator|-
literal|1
operator|)
operator|&
operator|(
name|ARCMSR_MAX_QBUFFER
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|my_empty_len
operator|>=
name|user_len
condition|)
block|{
while|while
condition|(
name|user_len
operator|>
literal|0
condition|)
block|{
comment|/*copy srb data to wqbuffer*/
name|pQbuffer
operator|=
operator|&
name|pACB
operator|->
name|wqbuffer
index|[
name|pACB
operator|->
name|wqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|ptmpuserbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|wqbuf_lastindex
operator|++
expr_stmt|;
name|pACB
operator|->
name|wqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|ptmpuserbuffer
operator|++
expr_stmt|;
name|user_len
operator|--
expr_stmt|;
block|}
comment|/*post fist Qbuffer*/
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_IOCTL_WQBUFFER_CLEARED
condition|)
block|{
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOCTL_WQBUFFER_CLEARED
expr_stmt|;
name|arcmsr_post_Qbuffer
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
block|}
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_OK
expr_stmt|;
block|}
else|else
block|{
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_ERROR
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
case|case
name|ARCMSR_IOCTL_CLEAR_RQBUFFER
case|:
block|{
name|ULONG
name|s
decl_stmt|;
name|PUCHAR
name|pQbuffer
init|=
name|pACB
operator|->
name|rqbuffer
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_IOCTL_RQBUFFER_CLEARED
expr_stmt|;
name|pACB
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|pACB
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_OK
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
case|case
name|ARCMSR_IOCTL_CLEAR_WQBUFFER
case|:
block|{
name|ULONG
name|s
decl_stmt|;
name|PUCHAR
name|pQbuffer
init|=
name|pACB
operator|->
name|wqbuffer
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_IOCTL_WQBUFFER_CLEARED
expr_stmt|;
name|pACB
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|pACB
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_OK
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
case|case
name|ARCMSR_IOCTL_CLEAR_ALLQBUFFER
case|:
block|{
name|ULONG
name|s
decl_stmt|;
name|PUCHAR
name|pQbuffer
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
name|pACB
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_IOCTL_WQBUFFER_CLEARED
operator||
name|ACB_F_IOCTL_RQBUFFER_CLEARED
operator|)
expr_stmt|;
name|pACB
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|pACB
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|pACB
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|pACB
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|pQbuffer
operator|=
name|pACB
operator|->
name|rqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pQbuffer
operator|=
name|pACB
operator|->
name|wqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_OK
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
case|case
name|ARCMSR_IOCTL_RETURN_CODE_3F
case|:
block|{
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_3F
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
case|case
name|ARCMSR_IOCTL_SAY_HELLO
case|:
block|{
name|PCMD_IOCTL_FIELD
name|pccbioctlfld
init|=
operator|(
name|PCMD_IOCTL_FIELD
operator|)
name|arg
decl_stmt|;
name|PCHAR
name|hello_string
init|=
literal|"Hello! I am ARCMSR"
decl_stmt|;
name|PCHAR
name|puserbuffer
init|=
operator|(
name|PUCHAR
operator|)
name|pccbioctlfld
operator|->
name|ioctldatabuffer
decl_stmt|;
if|if
condition|(
name|memcpy
argument_list|(
name|puserbuffer
argument_list|,
name|hello_string
argument_list|,
operator|(
name|SHORT
operator|)
name|strlen
argument_list|(
name|hello_string
argument_list|)
argument_list|)
condition|)
block|{
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_ERROR
expr_stmt|;
return|return
name|ENOIOCTL
return|;
block|}
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_OK
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ** ************************************************************************** */
end_comment

begin_function
name|PSRB
name|arcmsr_get_freesrb
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|PSRB
name|pSRB
init|=
name|NULL
decl_stmt|;
name|ULONG
name|s
decl_stmt|;
name|LONG
name|srb_startindex
decl_stmt|,
name|srb_doneindex
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_get_freesrb: srb_startindex=%d srb_doneindex=%d\n"
argument_list|,
name|pACB
operator|->
name|srb_startindex
argument_list|,
name|pACB
operator|->
name|srb_doneindex
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|srb_doneindex
operator|=
name|pACB
operator|->
name|srb_doneindex
expr_stmt|;
name|srb_startindex
operator|=
name|pACB
operator|->
name|srb_startindex
expr_stmt|;
name|pSRB
operator|=
name|pACB
operator|->
name|psrbringQ
index|[
name|srb_startindex
index|]
expr_stmt|;
name|srb_startindex
operator|++
expr_stmt|;
name|srb_startindex
operator|%=
name|ARCMSR_MAX_FREESRB_NUM
expr_stmt|;
if|if
condition|(
name|srb_doneindex
operator|!=
name|srb_startindex
condition|)
block|{
name|pACB
operator|->
name|srb_startindex
operator|=
name|srb_startindex
expr_stmt|;
block|}
else|else
block|{
name|pSRB
operator|=
name|NULL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|pSRB
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************* ** ** ** ********************************************************************* */
end_comment

begin_function
specifier|static
name|VOID
name|arcmsr_executesrb
parameter_list|(
name|VOID
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|LONG
name|nseg
parameter_list|,
name|LONG
name|error
parameter_list|)
block|{
name|PSRB
name|pSRB
init|=
operator|(
name|PSRB
operator|)
name|arg
decl_stmt|;
name|PACB
name|pACB
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_executesrb........................................ \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pccb
operator|=
name|pSRB
operator|->
name|pccb
expr_stmt|;
name|pACB
operator|=
operator|(
name|PACB
operator|)
name|pSRB
operator|->
name|pACB
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr_executesrb:%d Unexepected error %x returned from "
literal|"bus_dmamap_load\n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|pccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_TOO_BIG
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|arcmsr_build_srb
argument_list|(
name|pSRB
argument_list|,
name|dm_segs
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|srboutstandingcount
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|)
block|{
comment|/* 		****************************************************************** 		** and we can make sure there were no pending srb in this duration 		****************************************************************** 		*/
name|arcmsr_post_srb
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		****************************************************************** 		** Q of srbwaitexec will be post out when any outstanding command complete 		****************************************************************** 		*/
name|arcmsr_queue_wait2go_srb
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ***************************************************************************************** ** ***************************************************************************************** */
end_comment

begin_function
name|BOOLEAN
name|arcmsr_seek_cmd2abort
parameter_list|(
name|union
name|ccb
modifier|*
name|pabortccb
parameter_list|)
block|{
name|PSRB
name|pSRB
decl_stmt|,
name|pfreesrb
decl_stmt|;
name|PACB
name|pACB
init|=
operator|(
name|PACB
operator|)
name|pabortccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbacb_ptr
decl_stmt|;
name|ULONG
name|s
decl_stmt|,
name|intmask_org
decl_stmt|,
name|mask
decl_stmt|;
name|LONG
name|i
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_seek_cmd2abort.................. \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/*  	** It is the upper layer do abort command this lock just prior to calling us. 	** First determine if we currently own this command. 	** Start by searching the device queue. If not found 	** at all,and the system wanted us to just abort the 	** command return success. 	*/
if|if
condition|(
name|pACB
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
comment|/* Q back all outstanding srb into wait exec psrb Q*/
name|pfreesrb
operator|=
name|pACB
operator|->
name|pfreesrb
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|pSRB
operator|=
operator|&
name|pfreesrb
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
if|if
condition|(
name|pSRB
operator|->
name|pccb
operator|==
name|pabortccb
condition|)
block|{
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
argument_list|)
expr_stmt|;
comment|/* talk to iop 331 outstanding command aborted*/
name|arcmsr_abort_allcmd
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr_seek_cmd2abort: wait 'abort all outstanding command' timeout.................in \n"
argument_list|)
expr_stmt|;
block|}
comment|/*clear all outbound posted Q*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|;
name|i
operator|++
control|)
block|{
name|CHIP_REG_READ32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_queueport
argument_list|)
expr_stmt|;
block|}
name|pfreesrb
operator|=
name|pACB
operator|->
name|pfreesrb
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|pSRB
operator|=
operator|&
name|pfreesrb
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
name|pSRB
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* enable all outbound interrupt */
name|mask
operator|=
operator|~
operator|(
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE
operator|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
name|intmask_org
operator|&
name|mask
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
block|}
block|}
comment|/* 	** seek this command at our command list  	** if command found then remove,abort it and free this SRB 	*/
if|if
condition|(
name|pACB
operator|->
name|srbwait2gocount
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|;
name|i
operator|++
control|)
block|{
name|pSRB
operator|=
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pSRB
operator|->
name|pccb
operator|==
name|pabortccb
condition|)
block|{
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pSRB
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|pACB
operator|->
name|srbwait2gocount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************************** **  **************************************************************************** */
end_comment

begin_function
name|VOID
name|arcmsr_bus_reset
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_bus_reset.......................... \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arcmsr_iop_reset
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************* ** **   CAM  Status field values    **typedef enum { **	CAM_REQ_INPROG,		   CCB request is in progress    **	CAM_REQ_CMP,		   CCB request completed without error    **	CAM_REQ_ABORTED,	   CCB request aborted by the host    **	CAM_UA_ABORT,		   Unable to abort CCB request    **	CAM_REQ_CMP_ERR,	   CCB request completed with an error    **	CAM_BUSY,		       CAM subsytem is busy    **	CAM_REQ_INVALID,	   CCB request was invalid    **	CAM_PATH_INVALID,	   Supplied Path ID is invalid    **	CAM_DEV_NOT_THERE,	   SCSI Device Not Installed/there    **	CAM_UA_TERMIO,		   Unable to terminate I/O CCB request    **	CAM_SEL_TIMEOUT,	   Target Selection Timeout    **	CAM_CMD_TIMEOUT,	   Command timeout    **	CAM_SCSI_STATUS_ERROR,	   SCSI error, look at error code in CCB    **	CAM_MSG_REJECT_REC,	   Message Reject Received    **	CAM_SCSI_BUS_RESET,	   SCSI Bus Reset Sent/Received    **	CAM_UNCOR_PARITY,	   Uncorrectable parity error occurred    **	CAM_AUTOSENSE_FAIL=0x10,   Autosense: request sense cmd fail    **	CAM_NO_HBA,		   No HBA Detected error    **	CAM_DATA_RUN_ERR,	   Data Overrun error    **	CAM_UNEXP_BUSFREE,	   Unexpected Bus Free    **	CAM_SEQUENCE_FAIL,	   Target Bus Phase Sequence Failure    **	CAM_CCB_LEN_ERR,	   CCB length supplied is inadequate    **	CAM_PROVIDE_FAIL,	   Unable to provide requested capability    **	CAM_BDR_SENT,		   A SCSI BDR msg was sent to target    **	CAM_REQ_TERMIO,		   CCB request terminated by the host    **	CAM_UNREC_HBA_ERROR,	   Unrecoverable Host Bus Adapter Error    **	CAM_REQ_TOO_BIG,	   The request was too large for this host    **	CAM_REQUEUE_REQ,	   **				 * This request should be requeued to preserve **				 * transaction ordering.  This typically occurs **				 * when the SIM recognizes an error that should **				 * freeze the queue and must place additional **				 * requests for the target at the sim level **				 * back into the XPT queue. **				    **	CAM_IDE=0x33,		   Initiator Detected Error    **	CAM_RESRC_UNAVAIL,	   Resource Unavailable    **	CAM_UNACKED_EVENT,	   Unacknowledged Event by Host    **	CAM_MESSAGE_RECV,	   Message Received in Host Target Mode    **	CAM_INVALID_CDB,	   Invalid CDB received in Host Target Mode    **	CAM_LUN_INVALID,	   Lun supplied is invalid    **	CAM_TID_INVALID,	   Target ID supplied is invalid    **	CAM_FUNC_NOTAVAIL,	   The requested function is not available    **	CAM_NO_NEXUS,		   Nexus is not established    **	CAM_IID_INVALID,	   The initiator ID is invalid    **	CAM_CDB_RECVD,		   The SCSI CDB has been received    **	CAM_LUN_ALRDY_ENA,	   The LUN is already eanbeld for target mode    **	CAM_SCSI_BUSY,		   SCSI Bus Busy    ** **	CAM_DEV_QFRZN=0x40,	   The DEV queue is frozen w/this err    ** **				   Autosense data valid for target    **	CAM_AUTOSNS_VALID=0x80, **	CAM_RELEASE_SIMQ=0x100,   SIM ready to take more commands    **	CAM_SIM_QUEUED  =0x200,   SIM has this command in it's queue    ** **	CAM_STATUS_MASK=0x3F,	   Mask bits for just the status #    ** **				   Target Specific Adjunct Status    **	CAM_SENT_SENSE=0x40000000	   sent sense with status    **} cam_status; ** **union ccb { **			struct	ccb_hdr			ccb_h;	 For convenience  **			struct	ccb_scsiio		csio; **			struct	ccb_getdev		cgd; **			struct	ccb_getdevlist		cgdl; **			struct	ccb_pathinq		cpi; **			struct	ccb_relsim		crs; **			struct	ccb_setasync		csa; **			struct	ccb_setdev		csd; **			struct	ccb_pathstats		cpis; **			struct	ccb_getdevstats		cgds; **			struct	ccb_dev_match		cdm; **			struct	ccb_trans_settings	cts; **			struct	ccb_calc_geometry	ccg;	 **			struct	ccb_abort		cab; **			struct	ccb_resetbus		crb; **			struct	ccb_resetdev		crd; **			struct	ccb_termio		tio; **			struct	ccb_accept_tio		atio; **			struct	ccb_scsiio		ctio; **			struct	ccb_en_lun		cel; **			struct	ccb_immed_notify	cin; **			struct	ccb_notify_ack		cna; **			struct	ccb_eng_inq		cei; **			struct	ccb_eng_exec		cee; **			struct 	ccb_rescan		crcn; **			struct  ccb_debug		cdbg; **          } ** **struct ccb_hdr { **	cam_pinfo	    pinfo;	                                    "" Info for priority scheduling  **	camq_entry	    xpt_links;	                                "" For chaining in the XPT layer 	 **	camq_entry	    sim_links;	                                "" For chaining in the SIM layer 	 **	camq_entry	    periph_links;                               "" For chaining in the type driver  **	u_int32_t	    retry_count; **	void		    (*cbfcnp)(struct cam_periph *, union ccb *);"" Callback on completion function  **	xpt_opcode	    func_code;	                                "" XPT function code  **	u_int32_t	    status;	                                    "" Status returned by CAM subsystem  **	struct		    cam_path *path;                             "" Compiled path for this ccb  **	path_id_t	    path_id;	                                "" Path ID for the request  **	target_id_t	    target_id;	                                "" Target device ID  **	lun_id_t	    target_lun;                              	"" Target LUN number  **	u_int32_t	    flags; **	ccb_ppriv_area	periph_priv; **	ccb_spriv_area	sim_priv; **	u_int32_t	    timeout;	                                "" Timeout value  **	struct		    callout_handle timeout_ch;                  "" Callout handle used for timeouts  **}; ** **typedef union { **	u_int8_t  *cdb_ptr;		               "" Pointer to the CDB bytes to send  **	u_int8_t  cdb_bytes[IOCDBLEN];         "" Area for the CDB send  **} cdb_t; ** ** SCSI I/O Request CCB used for the XPT_SCSI_IO and XPT_CONT_TARGET_IO ** function codes. ** **struct ccb_scsiio { **	struct	   ccb_hdr ccb_h; **	union	   ccb *next_ccb;	           "" Ptr for next CCB for action  **	u_int8_t   *req_map;		           "" Ptr to mapping info  **	u_int8_t   *data_ptr;		           "" Ptr to the data buf/SG list  **	u_int32_t  dxfer_len;		           "" Data transfer length  **	struct     scsi_sense_data sense_data; "" Autosense storage **	u_int8_t   sense_len;		           "" Number of bytes to autosense **	u_int8_t   cdb_len;		               "" Number of bytes for the CDB  **	u_int16_t  sglist_cnt;		           "" Number of SG list entries **	u_int8_t   scsi_status;		           "" Returned SCSI status  **	u_int8_t   sense_resid;		           "" Autosense resid length: 2's comp  **	u_int32_t  resid;		               "" Transfer residual length: 2's comp **	cdb_t	   cdb_io;		               "" Union for CDB bytes/pointer  **	u_int8_t   *msg_ptr;		           "" Pointer to the message buffer **	u_int16_t  msg_len;		               "" Number of bytes for the Message  **	u_int8_t   tag_action;		           "" What to do for tag queueing  **#define	CAM_TAG_ACTION_NONE	0x00       "" The tag action should be either the define below (to send a non-tagged transaction) or one of the defined scsi tag messages from scsi_message.h. **	u_int	   tag_id;		               "" tag id from initator (target mode)  **	u_int	   init_id;		               "" initiator id of who selected **} ********************************************************************* */
end_comment

begin_function
specifier|static
name|VOID
name|arcmsr_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|psim
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
block|{
name|PACB
name|pACB
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_action ..................................\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pACB
operator|=
operator|(
name|PACB
operator|)
name|cam_sim_softc
argument_list|(
name|psim
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|==
name|NULL
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
block|{
name|PSRB
name|pSRB
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_action: XPT_SCSI_IO......................\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|pSRB
operator|=
name|arcmsr_get_freesrb
argument_list|(
name|pACB
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbsrb_ptr
operator|=
name|pSRB
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbacb_ptr
operator|=
name|pACB
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|=
name|pccb
expr_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|LONG
name|error
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|,
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|pccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|arcmsr_executesrb
argument_list|,
name|pSRB
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|pACB
operator|->
name|psim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"arcmsr: CAM_DATA_PHYS not supported"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
operator|||
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pSRB
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|arcmsr_executesrb
argument_list|(
name|pSRB
argument_list|,
name|segs
argument_list|,
name|pccb
operator|->
name|csio
operator|.
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|arcmsr_executesrb
argument_list|(
name|pSRB
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_TARGET_IO
case|:
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_action: XPT_TARGET_IO\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			** target mode not yet support vendor specific commands. 			*/
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|pccb
operator|->
name|cpi
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_action: XPT_PATH_INQ\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|ARCMSR_MAX_TARGETID
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|ARCMSR_MAX_TARGETLUN
expr_stmt|;
comment|/* 7 or 0 */
name|cpi
operator|->
name|initiator_id
operator|=
name|ARCMSR_SCSI_INITIATOR_ID
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|psim
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"ARCMSR"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|psim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|psim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_ABORT
case|:
block|{
name|union
name|ccb
modifier|*
name|pabort_ccb
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_action: XPT_ABORT\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pabort_ccb
operator|=
name|pccb
operator|->
name|cab
operator|.
name|abort_ccb
expr_stmt|;
switch|switch
condition|(
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
if|if
condition|(
name|arcmsr_seek_cmd2abort
argument_list|(
name|pabort_ccb
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|xpt_done
argument_list|(
name|pabort_ccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|xpt_print_path
argument_list|(
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Not found\n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
block|}
break|break;
case|case
name|XPT_SCSI_IO
case|:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
break|break;
default|default:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
case|case
name|XPT_RESET_DEV
case|:
block|{
name|LONG
name|i
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_action: XPT_RESET_BUS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arcmsr_bus_reset
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|500
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_action: XPT_TERM_IO\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|pccb
operator|->
name|cts
decl_stmt|;
name|ULONG
name|s
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_action: XPT_GET_TRAN_SETTINGS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|spi
operator|->
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
literal|3
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
literal|32
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
name|scsi
operator|->
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_action: XPT_SET_TRAN_SETTINGS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|ULONG
name|size_mb
decl_stmt|;
name|ULONG
name|secs_per_cylinder
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_action: XPT_CALC_GEOMETRY\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ccg
operator|=
operator|&
name|pccb
operator|->
name|ccg
expr_stmt|;
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|1024
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_action: invalid XPT function CAM_REQ_INVALID\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  **  start background rebuild ** ********************************************************************** */
end_comment

begin_function
name|VOID
name|arcmsr_start_adapter_bgrb
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_start_adapter_bgrb.................................. \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MSG_STOP_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_START_BGRB
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  **  start background rebuild ** ********************************************************************** */
end_comment

begin_function
name|VOID
name|arcmsr_iop_init
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|ULONG
name|intmask_org
decl_stmt|,
name|mask
decl_stmt|,
name|outbound_doorbell
decl_stmt|,
name|firmware_state
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_iop_init.................................. \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|firmware_state
operator|=
name|CHIP_REG_READ32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_msgaddr1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|firmware_state
operator|&
name|ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK
operator|)
operator|==
literal|0
condition|)
do|;
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
argument_list|)
expr_stmt|;
comment|/*start background rebuild*/
name|arcmsr_start_adapter_bgrb
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr_HwInitialize: wait 'start adapter background rebuild' timeout................. \n"
argument_list|)
expr_stmt|;
block|}
comment|/* clear Qbuffer if door bell ringed */
name|outbound_doorbell
operator|=
name|CHIP_REG_READ32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_doorbell
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_doorbell
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
comment|/*clear interrupt */
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
block|}
comment|/* enable outbound Post Queue,outbound message0,outbell doorbell Interrupt */
name|mask
operator|=
operator|~
operator|(
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE
operator|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
name|intmask_org
operator|&
name|mask
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|outbound_int_enable
operator|=
operator|~
operator|(
name|intmask_org
operator|&
name|mask
operator|)
operator|&
literal|0x000000ff
expr_stmt|;
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_IOP_INITED
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  **  map freesrb ** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_map_freesrb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|PACB
name|pACB
init|=
name|arg
decl_stmt|;
name|PSRB
name|psrb_tmp
decl_stmt|,
name|pfreesrb
decl_stmt|;
name|ULONG
name|cdb_phyaddr
decl_stmt|;
name|LONG
name|i
decl_stmt|;
name|pfreesrb
operator|=
operator|(
name|PSRB
operator|)
name|pACB
operator|->
name|uncacheptr
expr_stmt|;
name|cdb_phyaddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
comment|/* We suppose bus_addr_t high part always 0 here*/
if|if
condition|(
operator|(
operator|(
name|CPT2INT
operator|)
name|pACB
operator|->
name|uncacheptr
operator|&
literal|0x1F
operator|)
operator|!=
literal|0
condition|)
block|{
name|pfreesrb
operator|=
name|pfreesrb
operator|+
operator|(
literal|0x20
operator|-
operator|(
operator|(
name|CPT2INT
operator|)
name|pfreesrb
operator|&
literal|0x1F
operator|)
operator|)
expr_stmt|;
name|cdb_phyaddr
operator|=
name|cdb_phyaddr
operator|+
operator|(
literal|0x20
operator|-
operator|(
operator|(
name|CPT2INT
operator|)
name|cdb_phyaddr
operator|&
literal|0x1F
operator|)
operator|)
expr_stmt|;
block|}
comment|/* 	******************************************************************** 	** here we need to tell iop 331 our freesrb.HighPart  	** if freesrb.HighPart is not zero 	******************************************************************** 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|psrb_tmp
operator|=
operator|&
name|pfreesrb
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|CPT2INT
operator|)
name|psrb_tmp
operator|&
literal|0x1F
operator|)
operator|==
literal|0
condition|)
comment|/*srb address must 32 (0x20) boundary*/
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|psrb_tmp
operator|->
name|dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_MAPFREESRB_FAILD
expr_stmt|;
name|printf
argument_list|(
literal|" arcmsr_map_freesrb: (pSRB->dmamap) bus_dmamap_create ..............error\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|psrb_tmp
operator|->
name|cdb_shifted_phyaddr
operator|=
name|cdb_phyaddr
operator|>>
literal|5
expr_stmt|;
name|psrb_tmp
operator|->
name|pACB
operator|=
name|pACB
expr_stmt|;
name|pACB
operator|->
name|psrbringQ
index|[
name|i
index|]
operator|=
name|psrb_tmp
expr_stmt|;
name|cdb_phyaddr
operator|=
name|cdb_phyaddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|_SRB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_MAPFREESRB_FAILD
expr_stmt|;
name|printf
argument_list|(
literal|" arcmsr_map_freesrb:pfreesrb=%p i=%d this srb cross 32 bytes boundary ignored ......psrb_tmp=%p \n"
argument_list|,
name|pfreesrb
argument_list|,
name|i
argument_list|,
name|psrb_tmp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|pACB
operator|->
name|pfreesrb
operator|=
name|pfreesrb
expr_stmt|;
name|pACB
operator|->
name|vir2phy_offset
operator|=
operator|(
name|CPT2INT
operator|)
name|psrb_tmp
operator|-
operator|(
name|cdb_phyaddr
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|_SRB
argument_list|)
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** ** ************************************************************************ */
end_comment

begin_function
name|VOID
name|arcmsr_free_resource
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
comment|/* remove the control device */
if|if
condition|(
name|pACB
operator|->
name|ioctl_dev
operator|!=
name|NULL
condition|)
block|{
name|destroy_dev
argument_list|(
name|pACB
operator|->
name|ioctl_dev
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** PCI config header registers for all devices  ** ** #define PCIR_COMMAND	        0x04 ** #define PCIM_CMD_PORTEN		0x0001 ** #define PCIM_CMD_MEMEN		0x0002 ** #define PCIM_CMD_BUSMASTEREN	0x0004 ** #define PCIM_CMD_MWRICEN	    0x0010 ** #define PCIM_CMD_PERRESPEN	0x0040     **         ** Function      : arcmsr_initialize  ** Purpose       : initialize the internal structures for a given SCSI host ** Inputs        : host - pointer to this host adapter's structure ** Preconditions : when this function is called,the chip_type **	               field of the pACB structure MUST have been set. ** ** 10h Base Address register #0 ** 14h Base Address register #1 ** 18h Base Address register #2 ** 1Ch Base Address register #3 ** 20h Base Address register #4 ** 24h Base Address register #5 ************************************************************************ */
end_comment

begin_function
specifier|static
name|LONG
name|arcmsr_initialize
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|PACB
name|pACB
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|LONG
name|rid
init|=
name|PCI_BASE_ADDR0
decl_stmt|;
name|vm_offset_t
name|mem_base
decl_stmt|;
name|USHORT
name|pci_command
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_initialize..............................\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502010
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignemnt*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*nsegments*/
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|NULL
argument_list|,
comment|/*lockarg*/
name|NULL
argument_list|,
operator|&
name|pACB
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignemnt*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*nsegments*/
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|pACB
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|printf
argument_list|(
literal|"arcmsr_initialize: bus_dma_tag_create .......................failure!\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* Create a single tag describing a region large enough to hold all of the s/g lists we will need. */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502010
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|pACB
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|MAXBSIZE
argument_list|,
comment|/*nsegments*/
name|ARCMSR_MAX_SG_ENTRIES
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
operator|&
name|pACB
operator|->
name|buffer_dmat
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|pACB
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|MAXBSIZE
argument_list|,
comment|/*nsegments*/
name|ARCMSR_MAX_SG_ENTRIES
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
operator|&
name|pACB
operator|->
name|buffer_dmat
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr_initialize: bus_dma_tag_create ............................failure!\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* DMA tag for our srb structures.... Allocate the pfreesrb memory */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502010
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|pACB
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|_SRB
argument_list|)
operator|*
name|ARCMSR_MAX_FREESRB_NUM
operator|)
operator|+
literal|0x20
operator|)
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|NULL
argument_list|,
comment|/*lockarg*/
name|NULL
argument_list|,
operator|&
name|pACB
operator|->
name|srb_dmat
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|pACB
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|_SRB
argument_list|)
operator|*
name|ARCMSR_MAX_FREESRB_NUM
operator|)
operator|+
literal|0x20
operator|)
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|pACB
operator|->
name|srb_dmat
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr_initialize: pACB->srb_dmat bus_dma_tag_create .....................failure!\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Allocation for our srbs */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pACB
operator|->
name|uncacheptr
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|pACB
operator|->
name|srb_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr_initialize: pACB->srb_dmat bus_dma_tag_create ...............failure!\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* And permanently map them */
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|,
name|pACB
operator|->
name|uncacheptr
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|_SRB
argument_list|)
operator|*
name|ARCMSR_MAX_FREESRB_NUM
operator|)
operator|+
literal|0x20
argument_list|,
name|arcmsr_map_freesrb
argument_list|,
name|pACB
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr_initialize: bus_dmamap_load................... failure!\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|pci_command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_command
operator||=
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_command
operator||=
name|PCIM_CMD_PERRESPEN
expr_stmt|;
name|pci_command
operator||=
name|PCIM_CMD_MWRICEN
expr_stmt|;
comment|/* Enable Busmaster/Mem */
name|pci_command
operator||=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|pci_command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|sys_res_arcmsr
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|0x1000
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|sys_res_arcmsr
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr_initialize: bus_alloc_resource .....................failure!\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
name|rman_get_start
argument_list|(
name|pACB
operator|->
name|sys_res_arcmsr
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr_initialize: rman_get_start ...........................failure!\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|mem_base
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|pACB
operator|->
name|sys_res_arcmsr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_base
operator|==
literal|0
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr_initialize: rman_get_virtual ..........................failure!\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_MAPFREESRB_FAILD
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr_initialize: arman_get_virtual ..........................failure!\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|pACB
operator|->
name|btag
operator|=
name|rman_get_bustag
argument_list|(
name|pACB
operator|->
name|sys_res_arcmsr
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|pACB
operator|->
name|sys_res_arcmsr
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|pmu
operator|=
operator|(
name|PMU
operator|)
name|mem_base
expr_stmt|;
name|pACB
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_IOCTL_WQBUFFER_CLEARED
operator||
name|ACB_F_IOCTL_RQBUFFER_CLEARED
operator|)
expr_stmt|;
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_SCSISTOPADAPTER
expr_stmt|;
name|arcmsr_iop_init
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** **        attach and init a host adapter                ** ************************************************************************ */
end_comment

begin_function
specifier|static
name|LONG
name|arcmsr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|PACB
name|pACB
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|LONG
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
comment|/* Device Queue to use for this SIM */
name|struct
name|resource
modifier|*
name|irqres
decl_stmt|;
name|int
name|rid
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_attach .............................\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|arcmsr_initialize
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr_attach: arcmsr_initialize failure!\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* After setting up the adapter,map our interrupt */
name|rid
operator|=
literal|0
expr_stmt|;
name|irqres
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|irqres
operator|==
name|NULL
operator|||
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|irqres
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
name|arcmsr_interrupt
argument_list|,
name|pACB
argument_list|,
operator|&
name|pACB
operator|->
name|ih
argument_list|)
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: unable to register interrupt handler!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|pACB
operator|->
name|irqres
operator|=
name|irqres
expr_stmt|;
name|pACB
operator|->
name|pci_dev
operator|=
name|dev
expr_stmt|;
name|pACB
operator|->
name|pci_unit
operator|=
name|unit
expr_stmt|;
comment|/* 	 * Now let the CAM generic SCSI layer find the SCSI devices on 	 * the bus *  start queue to reset to the idle loop. * 	 * Create device queue of SIM(s) *  (MAX_START_JOB - 1) : 	 * max_sim_transactions 	*/
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|ARCMSR_MAX_START_JOB
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|pACB
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr_attach: cam_simq_alloc failure!\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|pACB
operator|->
name|psim
operator|=
name|cam_sim_alloc
argument_list|(
name|arcmsr_action
argument_list|,
name|arcmsr_poll
argument_list|,
literal|"arcmsr"
argument_list|,
name|pACB
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
literal|1
argument_list|,
name|ARCMSR_MAX_OUTSTANDING_CMD
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|psim
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|pACB
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr_attach: cam_sim_alloc ..................failure!\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|pACB
operator|->
name|psim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|pACB
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|pACB
operator|->
name|psim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr_attach: xpt_bus_register .......................failure!\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|pACB
operator|->
name|ppath
argument_list|,
comment|/* periph */
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|pACB
operator|->
name|psim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|pACB
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|pACB
operator|->
name|psim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|pACB
operator|->
name|psim
argument_list|,
comment|/* free_simq */
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr_attach: xpt_create_path .....................failure!\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* 	**************************************************** 	*/
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|pACB
operator|->
name|ppath
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
operator||
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|arcmsr_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|pACB
operator|->
name|psim
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
comment|/* Create the control device.  */
name|pACB
operator|->
name|ioctl_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|arcmsr_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
comment|/* GID_OPERATOR */
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|,
literal|"arcmsr%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|pACB
operator|->
name|ioctl_dev
operator|->
name|si_drv1
operator|=
name|pACB
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500005
operator|(
name|void
operator|)
name|make_dev_alias
argument_list|(
name|pACB
operator|->
name|ioctl_dev
argument_list|,
literal|"arc%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500005
block|if(kthread_create(arcmsr_do_thread_works, pACB,&pACB->kthread_proc,0,"arcmsr%d: kthread",pACB->pci_unit)) 		{ 			device_printf(pACB->pci_dev,"cannot create kernel thread for this host adapetr\n"); 			xpt_bus_deregister(cam_sim_path(pACB->psim)); 			cam_sim_free(pACB->psim,
comment|/* free_simq */
block|TRUE); 			panic("arcmsr plunge kernel thread fail"); 		}
else|#
directive|else
block|if(kthread_create(arcmsr_do_thread_works, pACB,&pACB->kthread_proc,"arcmsr%d: kthread", pACB->pci_unit)) 		{ 			device_printf(pACB->pci_dev,"cannot create kernel thread for this host adapetr\n"); 			xpt_bus_deregister(cam_sim_path(pACB->psim)); 			cam_sim_free(pACB->psim,
comment|/* free_simq */
block|TRUE); 			panic("arcmsr plunge kernel thread fail"); 		}
endif|#
directive|endif
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** **                      ** ************************************************************************ */
end_comment

begin_function
specifier|static
name|LONG
name|arcmsr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ULONG
name|id
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_probe................. \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|id
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|PCIDevVenIDARC1110
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1110 PCI-X 4 PORTS SATA RAID CONTROLLER \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1120
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1120 PCI-X 8 PORTS SATA RAID CONTROLLER (RAID6-ENGINE Inside) \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1130
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1130 PCI-X 12 PORTS SATA RAID CONTROLLER (RAID6-ENGINE Inside) \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1160
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1160 PCI-X 16 PORTS SATA RAID CONTROLLER (RAID6-ENGINE Inside) \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1210
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1210 PCI-EXPRESS 4 PORTS SATA RAID CONTROLLER \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1220
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1220 PCI-EXPRESS 8 PORTS SATA RAID CONTROLLER (RAID6-ENGINE Inside) \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1230
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1230 PCI-EXPRESS 12 PORTS SATA RAID CONTROLLER (RAID6-ENGINE Inside) \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1260
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1260 PCI-EXPRESS 16 PORTS SATA RAID CONTROLLER (RAID6-ENGINE Inside) \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** **                      ** ************************************************************************ */
end_comment

begin_function
specifier|static
name|VOID
name|arcmsr_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|LONG
name|i
decl_stmt|,
name|abort_cmd_cnt
init|=
literal|0
decl_stmt|;
name|ULONG
name|s
decl_stmt|,
name|intmask_org
decl_stmt|;
name|PSRB
name|pSRB
decl_stmt|;
name|PACB
name|pACB
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_shutdown................. \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
operator|(
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
operator|)
argument_list|)
expr_stmt|;
comment|/* stop adapter background rebuild */
name|arcmsr_stop_adapter_bgrb
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr_pcidev_disattach: wait 'stop adapter rebuild' timeout.... \n"
argument_list|)
expr_stmt|;
block|}
name|arcmsr_flush_adapter_cache
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr_pcidev_disattach: wait 'flush adapter cache' timeout.... \n"
argument_list|)
expr_stmt|;
block|}
comment|/* abort all outstanding command */
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_SCSISTOPADAPTER
expr_stmt|;
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOP_INITED
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
name|PSRB
name|pfreesrb
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_pcidev_disattach: .....pACB->srboutstandingcount!=0 \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Q back all outstanding srb into wait exec psrb Q*/
name|pfreesrb
operator|=
name|pACB
operator|->
name|pfreesrb
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|pSRB
operator|=
operator|&
name|pfreesrb
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
name|pSRB
operator|->
name|srb_flags
operator||=
name|SRB_FLAG_MASTER_ABORTED
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|abort_cmd_cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|abort_cmd_cnt
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|ARCMSR_DEBUG0
name|printf
argument_list|(
literal|"arcmsr_pcidev_disattach: .....abort_cmd_cnt!=0 \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arcmsr_abort_allcmd
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr_pcidev_disattach: wait 'abort all outstanding command' timeout.................in \n"
argument_list|)
expr_stmt|;
block|}
block|}
name|atomic_set_int
argument_list|(
operator|&
name|pACB
operator|->
name|srboutstandingcount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pACB
operator|->
name|srbwait2gocount
operator|!=
literal|0
condition|)
block|{
comment|/*remove first wait2go srb and abort it*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|;
name|i
operator|++
control|)
block|{
name|pSRB
operator|=
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|!=
name|NULL
condition|)
block|{
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|pACB
operator|->
name|srbwait2gocount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|pACB->acb_flags |= ACB_F_STOP_THREAD; 	wakeup(pACB->kthread_proc);
comment|/* signal to kernel thread do_dpcQ: "stop thread" */
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** **                      ** ************************************************************************ */
end_comment

begin_function
specifier|static
name|LONG
name|arcmsr_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|PACB
name|pACB
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|arcmsr_shutdown
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCI_BASE_ADDR0
argument_list|,
name|pACB
operator|->
name|sys_res_arcmsr
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|pACB
operator|->
name|irqres
argument_list|,
name|pACB
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|pACB
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|pACB
operator|->
name|ppath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|pACB
operator|->
name|ppath
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|pACB
operator|->
name|psim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|pACB
operator|->
name|psim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

