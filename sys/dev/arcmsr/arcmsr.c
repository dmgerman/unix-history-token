begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ****************************************************************************************** **        O.S   : FreeBSD **   FILE NAME  : arcmsr.c **        BY    : Erich Chen    **   Description: SCSI RAID Device Driver for  **                ARECA (ARC11XX/ARC12XX/ARC13XX/ARC16XX) SATA/SAS RAID HOST Adapter **                ARCMSR RAID Host adapter **                [RAID controller:INTEL 331(PCI-X) 341(PCI-EXPRESS) chip set] ****************************************************************************************** ************************************************************************ ** ** Copyright (c) 2004-2006 ARECA Co. Ltd. **        Erich Chen, Taipei Taiwan All rights reserved. ** ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** 3. The name of the author may not be used to endorse or promote products **    derived from this software without specific prior written permission. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR ** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  ** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT ** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT **(INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF ** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ************************************************************************** ** History ** **        REV#         DATE	            NAME	         DESCRIPTION **     1.00.00.00    3/31/2004	       Erich Chen	     First release **     1.20.00.02   11/29/2004         Erich Chen        bug fix with arcmsr_bus_reset when PHY error **     1.20.00.03    4/19/2005         Erich Chen        add SATA 24 Ports adapter type support **                                                       clean unused function **     1.20.00.12    9/12/2005         Erich Chen        bug fix with abort command handling,  **                                                       firmware version check  **                                                       and firmware update notify for hardware bug fix **                                                       handling if none zero high part physical address  **                                                       of srb resource  **     1.20.00.13    8/18/2006         Erich Chen        remove pending srb and report busy **                                                       add iop message xfer  **                                                       with scsi pass-through command **                                                       add new device id of sas raid adapters  **                                                       code fit for SPARC64& PPC  **     1.20.00.14   02/05/2007         Erich Chen        bug fix for incorrect ccb_h.status report **                                                       and cause g_vfs_done() read write error  ****************************************************************************************** * $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<isa/rtc.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500005
end_if

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_define
define|#
directive|define
name|ARCMSR_LOCK_INIT
parameter_list|(
name|l
parameter_list|,
name|s
parameter_list|)
value|mtx_init(l, s, NULL, MTX_DEF|MTX_RECURSE)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_ACQUIRE
parameter_list|(
name|l
parameter_list|)
value|mtx_lock(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_RELEASE
parameter_list|(
name|l
parameter_list|)
value|mtx_unlock(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_TRY
parameter_list|(
name|l
parameter_list|)
value|mtx_trylock(l)
end_define

begin_define
define|#
directive|define
name|arcmsr_htole32
parameter_list|(
name|x
parameter_list|)
value|htole32(x)
end_define

begin_typedef
typedef|typedef
name|struct
name|mtx
name|arcmsr_lock_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_define
define|#
directive|define
name|ARCMSR_LOCK_INIT
parameter_list|(
name|l
parameter_list|,
name|s
parameter_list|)
value|simple_lock_init(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_ACQUIRE
parameter_list|(
name|l
parameter_list|)
value|simple_lock(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_RELEASE
parameter_list|(
name|l
parameter_list|)
value|simple_unlock(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_TRY
parameter_list|(
name|l
parameter_list|)
value|simple_lock_try(l)
end_define

begin_define
define|#
directive|define
name|arcmsr_htole32
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_typedef
typedef|typedef
name|struct
name|simplelock
name|arcmsr_lock_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/arcmsr/arcmsr.h>
end_include

begin_define
define|#
directive|define
name|ARCMSR_SRBS_POOL_SIZE
value|((sizeof(struct CommandControlBlock) * ARCMSR_MAX_FREESRB_NUM)+0x20)
end_define

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_define
define|#
directive|define
name|CHIP_REG_READ32
parameter_list|(
name|r
parameter_list|)
value|bus_space_read_4(acb->btag, acb->bhandle, offsetof(struct MessageUnit,r))
end_define

begin_define
define|#
directive|define
name|CHIP_REG_WRITE32
parameter_list|(
name|r
parameter_list|,
name|d
parameter_list|)
value|bus_space_write_4(acb->btag, acb->bhandle, offsetof(struct MessageUnit,r), d)
end_define

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function_decl
specifier|static
name|struct
name|CommandControlBlock
modifier|*
name|arcmsr_get_freesrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|arcmsr_seek_cmd2abort
parameter_list|(
name|union
name|ccb
modifier|*
name|abortccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|arcmsr_wait_msgint_ready
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|arcmsr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|arcmsr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|arcmsr_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|arcmsr_iop_ioctlcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|u_int32_t
name|ioctl_cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_iop_parking
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_interrupt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_polling_srbdone
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|poll_srb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_free_resource
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_bus_reset
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_stop_adapter_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_start_adapter_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_iop_init
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_flush_adapter_cache
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_post_Qbuffer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_abort_allcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_srb_complete
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|,
name|int
name|stand_flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_iop_reset
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_report_sense_info
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_build_srb
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|u_int32_t
name|nseg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_iop_message_xfer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|UDELAY
parameter_list|(
name|u_int32_t
name|us
parameter_list|)
block|{
name|DELAY
argument_list|(
name|us
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|arcmsr_map_freesrb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|arcmsr_executesrb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|arcmsr_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|arcmsr_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|arcmsr_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|arcmsr_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|arcmsr_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|arcmsr_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|arcmsr_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|arcmsr_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|arcmsr_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|arcmsr_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|arcmsr_driver
init|=
block|{
literal|"arcmsr"
block|,
name|arcmsr_methods
block|,
expr|sizeof
operator|(
expr|struct
name|AdapterControlBlock
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|arcmsr_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|arcmsr
argument_list|,
name|pci
argument_list|,
name|arcmsr_driver
argument_list|,
name|arcmsr_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BUS_DMA_COHERENT
end_ifndef

begin_define
define|#
directive|define
name|BUS_DMA_COHERENT
value|0x04
end_define

begin_comment
comment|/* hint: map memory in a coherent way */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|501000
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|D_NEEDGIANT
end_ifndef

begin_define
define|#
directive|define
name|D_NEEDGIANT
value|0x00400000
end_define

begin_comment
comment|/* driver want Giant */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|D_VERSION
end_ifndef

begin_define
define|#
directive|define
name|D_VERSION
value|0x20011966
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|arcmsr_cdevsw
init|=
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|502010
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
endif|#
directive|endif
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|arcmsr_open
block|,
comment|/* open     */
operator|.
name|d_close
operator|=
name|arcmsr_close
block|,
comment|/* close    */
operator|.
name|d_ioctl
operator|=
name|arcmsr_ioctl
block|,
comment|/* ioctl    */
operator|.
name|d_name
operator|=
literal|"arcmsr"
block|,
comment|/* name     */
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ARCMSR_CDEV_MAJOR
value|180
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|arcmsr_cdevsw
init|=
block|{
name|arcmsr_open
block|,
comment|/* open     */
name|arcmsr_close
block|,
comment|/* close    */
name|noread
block|,
comment|/* read     */
name|nowrite
block|,
comment|/* write    */
name|arcmsr_ioctl
block|,
comment|/* ioctl    */
name|nopoll
block|,
comment|/* poll     */
name|nommap
block|,
comment|/* mmap     */
name|nostrategy
block|,
comment|/* strategy */
literal|"arcmsr"
block|,
comment|/* name     */
name|ARCMSR_CDEV_MAJOR
block|,
comment|/* major    */
name|nodump
block|,
comment|/* dump     */
name|nopsize
block|,
comment|/* psize    */
literal|0
comment|/* flags    */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_open
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_open
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_open
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
name|d_thread_t
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_close
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
name|d_thread_t
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_ioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_ioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_ioctl
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
name|d_thread_t
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
return|return
operator|(
name|arcmsr_iop_ioctlcmd
argument_list|(
name|acb
argument_list|,
name|ioctl_cmd
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ******************************************************************************* ******************************************************************************* */
end_comment

begin_function
specifier|static
name|int
name|arcmsr_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|;
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
name|outbound_intmask
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|outbound_intmask
argument_list|,
operator|(
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
operator|)
argument_list|)
expr_stmt|;
comment|/* flush controller */
name|arcmsr_iop_parking
argument_list|(
name|acb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ******************************************************************************* ******************************************************************************* */
end_comment

begin_function
specifier|static
name|int
name|arcmsr_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|arcmsr_iop_init
argument_list|(
name|acb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************************* ********************************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_async
parameter_list|(
name|void
modifier|*
name|cb_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
decl_stmt|;
name|u_int8_t
name|target_id
decl_stmt|,
name|target_lun
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|cb_arg
expr_stmt|;
name|acb
operator|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_LOST_DEVICE
case|:
name|target_id
operator|=
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|target_lun
operator|=
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target_id
operator|>
name|ARCMSR_MAX_TARGETID
operator|)
operator|||
operator|(
name|target_lun
operator|>
name|ARCMSR_MAX_TARGETLUN
operator|)
condition|)
block|{
break|break;
block|}
name|printf
argument_list|(
literal|"%s:scsi id%d lun%d device lost \n"
argument_list|,
name|device_get_name
argument_list|(
name|acb
operator|->
name|pci_dev
argument_list|)
argument_list|,
name|target_id
argument_list|,
name|target_lun
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_flush_adapter_cache
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_FLUSH_CACHE
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'flush adapter cache' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|u_int8_t
name|arcmsr_wait_msgint_ready
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|Index
decl_stmt|;
name|u_int8_t
name|Retries
init|=
literal|0x00
decl_stmt|;
do|do
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
literal|100
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
name|CHIP_REG_READ32
argument_list|(
name|outbound_intstatus
argument_list|)
operator|&
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INT
condition|)
block|{
comment|/*clear interrupt*/
name|CHIP_REG_WRITE32
argument_list|(
name|outbound_intstatus
argument_list|,
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INT
argument_list|)
expr_stmt|;
return|return
literal|0x00
return|;
block|}
comment|/* one us delay	*/
name|UDELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
comment|/*max 1 seconds*/
block|}
do|while
condition|(
name|Retries
operator|++
operator|<
literal|20
condition|)
do|;
comment|/*max 20 sec*/
return|return
literal|0xff
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_srb_complete
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|,
name|int
name|stand_flag
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|srb
operator|->
name|acb
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
init|=
name|srb
operator|->
name|pccb
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|)
expr_stmt|;
block|}
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|workingQ_done_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|stand_flag
operator|==
literal|1
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|acb
operator|->
name|srboutstandingcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|srb
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_DONE
expr_stmt|;
name|srb
operator|->
name|srb_flags
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|srbworkingQ
index|[
name|acb
operator|->
name|workingsrb_doneindex
index|]
operator|=
name|srb
expr_stmt|;
name|acb
operator|->
name|workingsrb_doneindex
operator|++
expr_stmt|;
name|acb
operator|->
name|workingsrb_doneindex
operator|%=
name|ARCMSR_MAX_FREESRB_NUM
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|workingQ_done_lock
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_report_sense_info
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|pccb
init|=
name|srb
operator|->
name|pccb
decl_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|pccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
condition|)
block|{
name|memset
argument_list|(
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|srb
operator|->
name|arcmsr_cdb
operator|.
name|SenseData
argument_list|,
name|get_min
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|SENSE_DATA
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|0
index|]
operator|=
operator|(
literal|0x1
operator|<<
literal|7
operator||
literal|0x70
operator|)
expr_stmt|;
comment|/* Valid,ErrorCode */
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************* **  ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_abort_allcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_ABORT_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'abort all outstanding command' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* **************************************************************************** **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_reset
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|,
name|mask
decl_stmt|;
name|u_int32_t
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
comment|/* talk to iop 331 outstanding command aborted*/
name|arcmsr_abort_allcmd
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|3000
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/*wait for 3 sec for all command aborted*/
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
name|outbound_intmask
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|outbound_intmask
argument_list|,
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
argument_list|)
expr_stmt|;
comment|/*clear all outbound posted Q*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|;
name|i
operator|++
control|)
block|{
name|CHIP_REG_READ32
argument_list|(
name|outbound_queueport
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|srb
operator|=
name|acb
operator|->
name|psrb_pool
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|srb
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
name|srb
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* enable all outbound interrupt */
name|mask
operator|=
operator|~
operator|(
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE
operator|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|outbound_intmask
argument_list|,
name|intmask_org
operator|&
name|mask
argument_list|)
expr_stmt|;
comment|/* post abort all outstanding command message to RAID controller */
block|}
name|atomic_set_int
argument_list|(
operator|&
name|acb
operator|->
name|srboutstandingcount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|acb
operator|->
name|workingsrb_doneindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|workingsrb_startindex
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_build_srb
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|u_int32_t
name|nseg
parameter_list|)
block|{
name|struct
name|ARCMSR_CDB
modifier|*
name|arcmsr_cdb
init|=
operator|&
name|srb
operator|->
name|arcmsr_cdb
decl_stmt|;
name|u_int8_t
modifier|*
name|psge
init|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|arcmsr_cdb
operator|->
name|u
decl_stmt|;
name|u_int32_t
name|address_lo
decl_stmt|,
name|address_hi
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
init|=
name|srb
operator|->
name|pccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|pcsio
init|=
operator|&
name|pccb
operator|->
name|csio
decl_stmt|;
name|u_int32_t
name|arccdbsize
init|=
literal|0x30
decl_stmt|;
name|memset
argument_list|(
name|arcmsr_cdb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ARCMSR_CDB
argument_list|)
argument_list|)
expr_stmt|;
name|arcmsr_cdb
operator|->
name|Bus
operator|=
literal|0
expr_stmt|;
name|arcmsr_cdb
operator|->
name|TargetID
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|arcmsr_cdb
operator|->
name|LUN
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|arcmsr_cdb
operator|->
name|Function
operator|=
literal|1
expr_stmt|;
name|arcmsr_cdb
operator|->
name|CdbLength
operator|=
operator|(
name|u_int8_t
operator|)
name|pcsio
operator|->
name|cdb_len
expr_stmt|;
name|arcmsr_cdb
operator|->
name|Context
operator|=
operator|(
name|unsigned
name|long
operator|)
name|arcmsr_cdb
expr_stmt|;
name|bcopy
argument_list|(
name|pcsio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|arcmsr_cdb
operator|->
name|Cdb
argument_list|,
name|pcsio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|srb
operator|->
name|acb
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|u_int32_t
name|length
decl_stmt|,
name|i
decl_stmt|,
name|cdb_sgcount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|arcmsr_cdb
operator|->
name|Flags
operator||=
name|ARCMSR_CDB_FLAG_WRITE
expr_stmt|;
name|srb
operator|->
name|srb_flags
operator||=
name|SRB_FLAG_WRITE
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get the physical address of the current data pointer */
name|length
operator|=
name|arcmsr_htole32
argument_list|(
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|address_lo
operator|=
name|arcmsr_htole32
argument_list|(
name|dma_addr_lo32
argument_list|(
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|address_hi
operator|=
name|arcmsr_htole32
argument_list|(
name|dma_addr_hi32
argument_list|(
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_hi
operator|==
literal|0
condition|)
block|{
name|struct
name|SG32ENTRY
modifier|*
name|pdma_sg
init|=
operator|(
expr|struct
name|SG32ENTRY
operator|*
operator|)
name|psge
decl_stmt|;
name|pdma_sg
operator|->
name|address
operator|=
name|address_lo
expr_stmt|;
name|pdma_sg
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG32ENTRY
argument_list|)
expr_stmt|;
name|arccdbsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG32ENTRY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|sg64s_size
init|=
literal|0
decl_stmt|,
name|tmplength
init|=
name|length
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|u_int64_t
name|span4G
decl_stmt|,
name|length0
decl_stmt|;
name|struct
name|SG64ENTRY
modifier|*
name|pdma_sg
init|=
operator|(
expr|struct
name|SG64ENTRY
operator|*
operator|)
name|psge
decl_stmt|;
name|span4G
operator|=
operator|(
name|u_int64_t
operator|)
name|address_lo
operator|+
name|tmplength
expr_stmt|;
name|pdma_sg
operator|->
name|addresshigh
operator|=
name|address_hi
expr_stmt|;
name|pdma_sg
operator|->
name|address
operator|=
name|address_lo
expr_stmt|;
if|if
condition|(
name|span4G
operator|>
literal|0x100000000
condition|)
block|{
comment|/*see if cross 4G boundary*/
name|length0
operator|=
literal|0x100000000
operator|-
name|address_lo
expr_stmt|;
name|pdma_sg
operator|->
name|length
operator|=
operator|(
name|u_int32_t
operator|)
name|length0
operator||
name|IS_SG64_ADDR
expr_stmt|;
name|address_hi
operator|=
name|address_hi
operator|+
literal|1
expr_stmt|;
name|address_lo
operator|=
literal|0
expr_stmt|;
name|tmplength
operator|=
name|tmplength
operator|-
operator|(
name|u_int32_t
operator|)
name|length0
expr_stmt|;
name|sg64s_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG64ENTRY
argument_list|)
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG64ENTRY
argument_list|)
expr_stmt|;
name|cdb_sgcount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pdma_sg
operator|->
name|length
operator|=
name|tmplength
operator||
name|IS_SG64_ADDR
expr_stmt|;
name|sg64s_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG64ENTRY
argument_list|)
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG64ENTRY
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|arccdbsize
operator|+=
name|sg64s_size
expr_stmt|;
block|}
name|cdb_sgcount
operator|++
expr_stmt|;
block|}
name|arcmsr_cdb
operator|->
name|sgcount
operator|=
operator|(
name|u_int8_t
operator|)
name|cdb_sgcount
expr_stmt|;
name|arcmsr_cdb
operator|->
name|DataLength
operator|=
name|pcsio
operator|->
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|arccdbsize
operator|>
literal|256
condition|)
block|{
name|arcmsr_cdb
operator|->
name|Flags
operator||=
name|ARCMSR_CDB_FLAG_SGL_BSIZE
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_post_srb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|)
block|{
name|u_int32_t
name|cdb_shifted_phyaddr
init|=
operator|(
name|u_int32_t
operator|)
name|srb
operator|->
name|cdb_shifted_phyaddr
decl_stmt|;
name|struct
name|ARCMSR_CDB
modifier|*
name|arcmsr_cdb
init|=
operator|(
expr|struct
name|ARCMSR_CDB
operator|*
operator|)
operator|&
name|srb
operator|->
name|arcmsr_cdb
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
operator|(
name|srb
operator|->
name|srb_flags
operator|&
name|SRB_FLAG_WRITE
operator|)
condition|?
name|BUS_DMASYNC_POSTWRITE
else|:
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|acb
operator|->
name|srboutstandingcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|srb
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_START
expr_stmt|;
if|if
condition|(
name|arcmsr_cdb
operator|->
name|Flags
operator|&
name|ARCMSR_CDB_FLAG_SGL_BSIZE
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_queueport
argument_list|,
name|cdb_shifted_phyaddr
operator||
name|ARCMSR_SRBPOST_FLAG_SGL_BSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_queueport
argument_list|,
name|cdb_shifted_phyaddr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_post_Qbuffer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|struct
name|QBUFFER
modifier|*
name|pwbuffer
init|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|acb
operator|->
name|pmu
operator|->
name|message_wbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pwbuffer
operator|->
name|data
decl_stmt|;
name|u_int32_t
name|allxfer_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MESSAGE_WQBUFFER_READED
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|(
operator|~
name|ACB_F_MESSAGE_WQBUFFER_READED
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|acb
operator|->
name|wqbuf_firstindex
operator|!=
name|acb
operator|->
name|wqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|124
operator|)
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|wqbuffer
index|[
name|acb
operator|->
name|wqbuf_firstindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|iop_data
argument_list|,
name|pQbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|++
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
name|pwbuffer
operator|->
name|data_len
operator|=
name|allxfer_len
expr_stmt|;
comment|/* 		** push inbound doorbell and wait reply at hwinterrupt routine for next Qbuffer post 		*/
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_stop_adapter_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_STOP_BGRB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'stop adapter rebulid' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|psim
parameter_list|)
block|{
name|arcmsr_interrupt
argument_list|(
name|cam_sim_softc
argument_list|(
name|psim
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_interrupt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|u_int32_t
name|flag_srb
decl_stmt|,
name|outbound_intstatus
decl_stmt|,
name|outbound_doorbell
decl_stmt|;
comment|/* 	********************************************* 	**   check outbound intstatus  	********************************************* 	*/
name|outbound_intstatus
operator|=
name|CHIP_REG_READ32
argument_list|(
name|outbound_intstatus
argument_list|)
operator|&
name|acb
operator|->
name|outbound_int_enable
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|outbound_intstatus
argument_list|,
name|outbound_intstatus
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
if|if
condition|(
name|outbound_intstatus
operator|&
name|ARCMSR_MU_OUTBOUND_DOORBELL_INT
condition|)
block|{
comment|/* 		********************************************* 		**  DOORBELL  		********************************************* 		*/
name|outbound_doorbell
operator|=
name|CHIP_REG_READ32
argument_list|(
name|outbound_doorbell
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|outbound_doorbell
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
comment|/*clear interrupt */
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK
condition|)
block|{
name|struct
name|QBUFFER
modifier|*
name|prbuffer
init|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|acb
operator|->
name|pmu
operator|->
name|message_rbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|prbuffer
operator|->
name|data
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int32_t
name|my_empty_len
decl_stmt|,
name|iop_len
decl_stmt|,
name|rqbuf_firstindex
decl_stmt|,
name|rqbuf_lastindex
decl_stmt|;
comment|/*check this iop data if overflow my rqbuffer*/
name|rqbuf_lastindex
operator|=
name|acb
operator|->
name|rqbuf_lastindex
expr_stmt|;
name|rqbuf_firstindex
operator|=
name|acb
operator|->
name|rqbuf_firstindex
expr_stmt|;
name|iop_len
operator|=
name|prbuffer
operator|->
name|data_len
expr_stmt|;
name|my_empty_len
operator|=
operator|(
name|rqbuf_firstindex
operator|-
name|rqbuf_lastindex
operator|-
literal|1
operator|)
operator|&
operator|(
name|ARCMSR_MAX_QBUFFER
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|my_empty_len
operator|>=
name|iop_len
condition|)
block|{
while|while
condition|(
name|iop_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|rqbuffer
index|[
name|acb
operator|->
name|rqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|iop_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|++
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|iop_len
operator|--
expr_stmt|;
block|}
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
else|else
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_OUTBOUND_IOP331_DATA_READ_OK
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MESSAGE_WQBUFFER_READED
expr_stmt|;
comment|/* 			********************************************* 			********************************************* 			*/
if|if
condition|(
name|acb
operator|->
name|wqbuf_firstindex
operator|!=
name|acb
operator|->
name|wqbuf_lastindex
condition|)
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|struct
name|QBUFFER
modifier|*
name|pwbuffer
init|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|acb
operator|->
name|pmu
operator|->
name|message_wbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pwbuffer
operator|->
name|data
decl_stmt|;
name|u_int32_t
name|allxfer_len
init|=
literal|0
decl_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|(
operator|~
name|ACB_F_MESSAGE_WQBUFFER_READED
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|acb
operator|->
name|wqbuf_firstindex
operator|!=
name|acb
operator|->
name|wqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|124
operator|)
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|wqbuffer
index|[
name|acb
operator|->
name|wqbuf_firstindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|iop_data
argument_list|,
name|pQbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|++
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
name|pwbuffer
operator|->
name|data_len
operator|=
name|allxfer_len
expr_stmt|;
comment|/* 				** push inbound doorbell tell iop driver data write ok 				** and wait reply on next hwinterrupt for next Qbuffer post 				*/
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acb
operator|->
name|wqbuf_firstindex
operator|==
name|acb
operator|->
name|wqbuf_lastindex
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|outbound_intstatus
operator|&
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
condition|)
block|{
name|int
name|target
decl_stmt|,
name|lun
decl_stmt|;
comment|/* 		***************************************************************************** 		**               areca cdb command done 		***************************************************************************** 		*/
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|flag_srb
operator|=
name|CHIP_REG_READ32
argument_list|(
name|outbound_queueport
argument_list|)
operator|)
operator|==
literal|0xFFFFFFFF
condition|)
block|{
break|break;
comment|/*chip FIFO no srb for completion already*/
block|}
comment|/* check if command done with no error*/
name|srb
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
operator|(
name|acb
operator|->
name|vir2phy_offset
operator|+
operator|(
name|flag_srb
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
comment|/*frame must be 32 bytes aligned*/
if|if
condition|(
operator|(
name|srb
operator|->
name|acb
operator|!=
name|acb
operator|)
operator|||
operator|(
name|srb
operator|->
name|startdone
operator|!=
name|ARCMSR_SRB_START
operator|)
condition|)
block|{
if|if
condition|(
name|srb
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: srb='%p' isr got aborted command \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
argument_list|)
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"arcmsr%d: isr get an illegal srb command done"
literal|"acb='%p' srb='%p' srbacb='%p' startdone=0x%x"
literal|"srboutstandingcount=%d \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|acb
argument_list|,
name|srb
argument_list|,
name|srb
operator|->
name|acb
argument_list|,
name|srb
operator|->
name|startdone
argument_list|,
name|acb
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|target
operator|=
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|ARECA_RAID_GONE
condition|)
block|{
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
block|}
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|srb
operator|->
name|arcmsr_cdb
operator|.
name|DeviceStatus
condition|)
block|{
case|case
name|ARCMSR_DEV_SELECT_TIMEOUT
case|:
block|{
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_DEV_ABORTED
case|:
case|case
name|ARCMSR_DEV_INIT_FAIL
case|:
block|{
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCSISTAT_CHECK_CONDITION
case|:
block|{
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
name|arcmsr_report_sense_info
argument_list|(
name|srb
argument_list|)
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d"
literal|"isr get command error done,"
literal|"but got unknow DeviceStatus=0x%x \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|srb
operator|->
name|arcmsr_cdb
operator|.
name|DeviceStatus
argument_list|)
expr_stmt|;
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_UNCOR_PARITY
expr_stmt|;
comment|/*unknow error or crc error just for retry*/
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*drain reply FIFO*/
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ******************************************************************************* ** ******************************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_parking
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
if|if
condition|(
name|acb
operator|!=
name|NULL
condition|)
block|{
comment|/* stop adapter background rebuild */
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MSG_START_BGRB
condition|)
block|{
name|arcmsr_stop_adapter_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_flush_adapter_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* *********************************************************************** ** ************************************************************************ */
end_comment

begin_function
name|u_int32_t
name|arcmsr_iop_ioctlcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|u_int32_t
name|ioctl_cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|CMD_MESSAGE_FIELD
modifier|*
name|pcmdmessagefld
decl_stmt|;
name|u_int32_t
name|retvalue
init|=
name|EINVAL
decl_stmt|;
name|pcmdmessagefld
operator|=
operator|(
expr|struct
name|CMD_MESSAGE_FIELD
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Signature
argument_list|,
literal|"ARCMSR"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|retvalue
return|;
block|}
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ioctl_cmd
condition|)
block|{
case|case
name|ARCMSR_MESSAGE_READ_RQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|ptmpQbuffer
init|=
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
name|u_int32_t
name|allxfer_len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|acb
operator|->
name|rqbuf_firstindex
operator|!=
name|acb
operator|->
name|rqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|1031
operator|)
condition|)
block|{
comment|/*copy READ QBUFFER to srb*/
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|rqbuffer
index|[
name|acb
operator|->
name|rqbuf_firstindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|ptmpQbuffer
argument_list|,
name|pQbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|++
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|ptmpQbuffer
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|struct
name|QBUFFER
modifier|*
name|prbuffer
init|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|acb
operator|->
name|pmu
operator|->
name|message_rbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|prbuffer
operator|->
name|data
decl_stmt|;
name|u_int32_t
name|iop_len
decl_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|iop_len
operator|=
operator|(
name|u_int32_t
operator|)
name|prbuffer
operator|->
name|data_len
expr_stmt|;
comment|/*this iop data does no chance to make me overflow again here, so just do it*/
while|while
condition|(
name|iop_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|rqbuffer
index|[
name|acb
operator|->
name|rqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|iop_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|++
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|iop_len
operator|--
expr_stmt|;
block|}
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Length
operator|=
name|allxfer_len
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_WRITE_WQBUFFER
case|:
block|{
name|u_int32_t
name|my_empty_len
decl_stmt|,
name|user_len
decl_stmt|,
name|wqbuf_firstindex
decl_stmt|,
name|wqbuf_lastindex
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|ptmpuserbuffer
init|=
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
name|user_len
operator|=
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Length
expr_stmt|;
comment|/*check if data xfer length of this request will overflow my array qbuffer */
name|wqbuf_lastindex
operator|=
name|acb
operator|->
name|wqbuf_lastindex
expr_stmt|;
name|wqbuf_firstindex
operator|=
name|acb
operator|->
name|wqbuf_firstindex
expr_stmt|;
if|if
condition|(
name|wqbuf_lastindex
operator|!=
name|wqbuf_firstindex
condition|)
block|{
name|arcmsr_post_Qbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_ERROR
expr_stmt|;
block|}
else|else
block|{
name|my_empty_len
operator|=
operator|(
name|wqbuf_firstindex
operator|-
name|wqbuf_lastindex
operator|-
literal|1
operator|)
operator|&
operator|(
name|ARCMSR_MAX_QBUFFER
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|my_empty_len
operator|>=
name|user_len
condition|)
block|{
while|while
condition|(
name|user_len
operator|>
literal|0
condition|)
block|{
comment|/*copy srb data to wqbuffer*/
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|wqbuffer
index|[
name|acb
operator|->
name|wqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|ptmpuserbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|++
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|ptmpuserbuffer
operator|++
expr_stmt|;
name|user_len
operator|--
expr_stmt|;
block|}
comment|/*post fist Qbuffer*/
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
expr_stmt|;
name|arcmsr_post_Qbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
block|}
else|else
block|{
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_ERROR
expr_stmt|;
block|}
block|}
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_RQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
init|=
name|acb
operator|->
name|rqbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MESSAGE_RQBUFFER_CLEARED
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_WQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
init|=
name|acb
operator|->
name|wqbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
name|acb
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_WQBUFFER_READED
operator|)
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_ALLQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
name|acb
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_RQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_WQBUFFER_READED
operator|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|pQbuffer
operator|=
name|acb
operator|->
name|rqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pQbuffer
operator|=
name|acb
operator|->
name|wqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_REQUEST_RETURNCODE_3F
case|:
block|{
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_3F
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_SAY_HELLO
case|:
block|{
name|u_int8_t
modifier|*
name|hello_string
init|=
literal|"Hello! I am ARCMSR"
decl_stmt|;
name|u_int8_t
modifier|*
name|puserbuffer
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
if|if
condition|(
name|memcpy
argument_list|(
name|puserbuffer
argument_list|,
name|hello_string
argument_list|,
operator|(
name|int16_t
operator|)
name|strlen
argument_list|(
name|hello_string
argument_list|)
argument_list|)
condition|)
block|{
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_ERROR
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
return|return
name|ENOIOCTL
return|;
block|}
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_SAY_GOODBYE
case|:
block|{
name|arcmsr_iop_parking
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE
case|:
block|{
name|arcmsr_flush_adapter_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
block|}
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
return|return
name|retvalue
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
name|struct
name|CommandControlBlock
modifier|*
name|arcmsr_get_freesrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|workingsrb_startindex
decl_stmt|,
name|workingsrb_doneindex
decl_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|workingQ_start_lock
argument_list|)
expr_stmt|;
name|workingsrb_doneindex
operator|=
name|acb
operator|->
name|workingsrb_doneindex
expr_stmt|;
name|workingsrb_startindex
operator|=
name|acb
operator|->
name|workingsrb_startindex
expr_stmt|;
name|srb
operator|=
name|acb
operator|->
name|srbworkingQ
index|[
name|workingsrb_startindex
index|]
expr_stmt|;
name|workingsrb_startindex
operator|++
expr_stmt|;
name|workingsrb_startindex
operator|%=
name|ARCMSR_MAX_FREESRB_NUM
expr_stmt|;
if|if
condition|(
name|workingsrb_doneindex
operator|!=
name|workingsrb_startindex
condition|)
block|{
name|acb
operator|->
name|workingsrb_startindex
operator|=
name|workingsrb_startindex
expr_stmt|;
block|}
else|else
block|{
name|srb
operator|=
name|NULL
expr_stmt|;
block|}
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|workingQ_start_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|srb
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|int
name|arcmsr_iop_message_xfer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
block|{
name|struct
name|CMD_MESSAGE_FIELD
modifier|*
name|pcmdmessagefld
decl_stmt|;
name|int
name|retvalue
init|=
literal|0
decl_stmt|,
name|transfer_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|uint32_t
name|controlcode
init|=
operator|(
name|uint32_t
operator|)
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|5
index|]
operator|<<
literal|24
operator||
operator|(
name|uint32_t
operator|)
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|6
index|]
operator|<<
literal|16
operator||
operator|(
name|uint32_t
operator|)
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|7
index|]
operator|<<
literal|8
operator||
operator|(
name|uint32_t
operator|)
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
decl_stmt|;
comment|/* 4 bytes: Areca io control code */
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|buffer
operator|=
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|transfer_len
operator|=
name|pccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
block|}
else|else
block|{
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
goto|goto
name|message_out
goto|;
block|}
if|if
condition|(
name|transfer_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|CMD_MESSAGE_FIELD
argument_list|)
condition|)
block|{
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
goto|goto
name|message_out
goto|;
block|}
name|pcmdmessagefld
operator|=
operator|(
expr|struct
name|CMD_MESSAGE_FIELD
operator|*
operator|)
name|buffer
expr_stmt|;
switch|switch
condition|(
name|controlcode
condition|)
block|{
case|case
name|ARCMSR_MESSAGE_READ_RQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|ptmpQbuffer
init|=
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
name|int32_t
name|allxfer_len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|acb
operator|->
name|rqbuf_firstindex
operator|!=
name|acb
operator|->
name|rqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|1031
operator|)
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|rqbuffer
index|[
name|acb
operator|->
name|rqbuf_firstindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|ptmpQbuffer
argument_list|,
name|pQbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|++
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
name|ptmpQbuffer
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|struct
name|QBUFFER
modifier|*
name|prbuffer
init|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|acb
operator|->
name|pmu
operator|->
name|message_rbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|prbuffer
operator|->
name|data
decl_stmt|;
name|int32_t
name|iop_len
decl_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|iop_len
operator|=
operator|(
name|u_int32_t
operator|)
name|prbuffer
operator|->
name|data_len
expr_stmt|;
while|while
condition|(
name|iop_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|rqbuffer
index|[
name|acb
operator|->
name|rqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|iop_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|++
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
name|iop_data
operator|++
expr_stmt|;
name|iop_len
operator|--
expr_stmt|;
block|}
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
block|}
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Length
operator|=
name|allxfer_len
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_WRITE_WQBUFFER
case|:
block|{
name|int32_t
name|my_empty_len
decl_stmt|,
name|user_len
decl_stmt|,
name|wqbuf_firstindex
decl_stmt|,
name|wqbuf_lastindex
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|ptmpuserbuffer
init|=
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
name|user_len
operator|=
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Length
expr_stmt|;
name|wqbuf_lastindex
operator|=
name|acb
operator|->
name|wqbuf_lastindex
expr_stmt|;
name|wqbuf_firstindex
operator|=
name|acb
operator|->
name|wqbuf_firstindex
expr_stmt|;
if|if
condition|(
name|wqbuf_lastindex
operator|!=
name|wqbuf_firstindex
condition|)
block|{
name|arcmsr_post_Qbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* has error report sensedata */
if|if
condition|(
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
condition|)
block|{
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|0
index|]
operator|=
operator|(
literal|0x1
operator|<<
literal|7
operator||
literal|0x70
operator|)
expr_stmt|;
comment|/* Valid,ErrorCode */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|2
index|]
operator|=
literal|0x05
expr_stmt|;
comment|/* FileMark,EndOfMedia,IncorrectLength,Reserved,SenseKey */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|7
index|]
operator|=
literal|0x0A
expr_stmt|;
comment|/* AdditionalSenseLength */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|12
index|]
operator|=
literal|0x20
expr_stmt|;
comment|/* AdditionalSenseCode */
block|}
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
block|}
else|else
block|{
name|my_empty_len
operator|=
operator|(
name|wqbuf_firstindex
operator|-
name|wqbuf_lastindex
operator|-
literal|1
operator|)
operator|&
operator|(
name|ARCMSR_MAX_QBUFFER
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|my_empty_len
operator|>=
name|user_len
condition|)
block|{
while|while
condition|(
name|user_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|wqbuffer
index|[
name|acb
operator|->
name|wqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|ptmpuserbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|++
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
name|ptmpuserbuffer
operator|++
expr_stmt|;
name|user_len
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
expr_stmt|;
name|arcmsr_post_Qbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* has error report sensedata */
if|if
condition|(
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
condition|)
block|{
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|0
index|]
operator|=
operator|(
literal|0x1
operator|<<
literal|7
operator||
literal|0x70
operator|)
expr_stmt|;
comment|/* Valid,ErrorCode */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|2
index|]
operator|=
literal|0x05
expr_stmt|;
comment|/* FileMark,EndOfMedia,IncorrectLength,Reserved,SenseKey */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|7
index|]
operator|=
literal|0x0A
expr_stmt|;
comment|/* AdditionalSenseLength */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|12
index|]
operator|=
literal|0x20
expr_stmt|;
comment|/* AdditionalSenseCode */
block|}
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_RQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
init|=
name|acb
operator|->
name|rqbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
block|}
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MESSAGE_RQBUFFER_CLEARED
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_WQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
init|=
name|acb
operator|->
name|wqbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
block|}
name|acb
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_WQBUFFER_READED
operator|)
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_ALLQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
block|}
name|acb
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_RQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_WQBUFFER_READED
operator|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|pQbuffer
operator|=
name|acb
operator|->
name|rqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pQbuffer
operator|=
name|acb
operator|->
name|wqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_REQUEST_RETURNCODE_3F
case|:
block|{
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_3F
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_SAY_HELLO
case|:
block|{
name|int8_t
modifier|*
name|hello_string
init|=
literal|"Hello! I am ARCMSR"
decl_stmt|;
name|memcpy
argument_list|(
name|pcmdmessagefld
operator|->
name|messagedatabuffer
argument_list|,
name|hello_string
argument_list|,
operator|(
name|int16_t
operator|)
name|strlen
argument_list|(
name|hello_string
argument_list|)
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_SAY_GOODBYE
case|:
name|arcmsr_iop_parking
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE
case|:
name|arcmsr_flush_adapter_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
block|}
name|message_out
label|:
return|return
name|retvalue
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************* ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_executesrb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
init|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|srb
operator|->
name|acb
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
decl_stmt|;
name|int
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|pccb
operator|=
name|srb
operator|->
name|pccb
expr_stmt|;
name|target
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: unexpected error %x returned from 'bus_dmamap_load' \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|pccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
operator|(
name|CAM_REQ_TOO_BIG
operator||
name|CAM_DEV_QFRZN
operator|)
expr_stmt|;
block|}
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nseg
operator|>
name|ARCMSR_MAX_SG_ENTRIES
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_TOO_BIG
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_BUS_RESET
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: bus reset and return busy \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|ARECA_RAID_GONE
condition|)
block|{
name|u_int8_t
name|block_cmd
decl_stmt|;
name|block_cmd
operator|=
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|block_cmd
operator|==
literal|0x08
operator|||
name|block_cmd
operator|==
literal|0x0a
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d:block 'read/write' command"
literal|"with gone raid volume Cmd=%2x, TargetId=%d, Lun=%d \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|block_cmd
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|)
expr_stmt|;
block|}
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|>=
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|arcmsr_build_srb
argument_list|(
name|srb
argument_list|,
name|dm_segs
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
name|arcmsr_post_srb
argument_list|(
name|acb
argument_list|,
name|srb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ***************************************************************************************** ***************************************************************************************** */
end_comment

begin_function
specifier|static
name|u_int8_t
name|arcmsr_seek_cmd2abort
parameter_list|(
name|union
name|ccb
modifier|*
name|abortccb
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|abortccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbacb_ptr
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|acb
operator|->
name|num_aborts
operator|++
expr_stmt|;
comment|/* 	*************************************************************************** 	** It is the upper layer do abort command this lock just prior to calling us. 	** First determine if we currently own this command. 	** Start by searching the device queue. If not found 	** at all, and the system wanted us to just abort the 	** command return success. 	*************************************************************************** 	*/
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|srb
operator|=
name|acb
operator|->
name|psrb_pool
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|srb
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
if|if
condition|(
name|srb
operator|->
name|pccb
operator|==
name|abortccb
condition|)
block|{
name|srb
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d:scsi id=%d lun=%d abort srb '%p'"
literal|"outstanding command \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|abortccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|abortccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|srb
argument_list|)
expr_stmt|;
goto|goto
name|abort_outstanding_cmd
goto|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
name|abort_outstanding_cmd
label|:
comment|/* do not talk to iop 331 abort command */
name|UDELAY
argument_list|(
literal|3000
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/*wait for 3 sec for all command done*/
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
name|outbound_intmask
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|outbound_intmask
argument_list|,
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
argument_list|)
expr_stmt|;
name|arcmsr_polling_srbdone
argument_list|(
name|acb
argument_list|,
name|srb
argument_list|)
expr_stmt|;
comment|/* enable all outbound interrupt */
name|mask
operator|=
operator|~
operator|(
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE
operator|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|outbound_intmask
argument_list|,
name|intmask_org
operator|&
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************************** **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_bus_reset
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|int
name|retry
init|=
literal|0
decl_stmt|;
name|acb
operator|->
name|num_resets
operator|++
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_BUS_RESET
expr_stmt|;
while|while
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|!=
literal|0
operator|&&
name|retry
operator|<
literal|400
condition|)
block|{
name|arcmsr_interrupt
argument_list|(
operator|(
name|void
operator|*
operator|)
name|acb
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|25000
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
block|}
name|arcmsr_iop_reset
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_BUS_RESET
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_handle_virtual_command
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
switch|switch
condition|(
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
condition|)
block|{
case|case
name|INQUIRY
case|:
block|{
name|unsigned
name|char
name|inqdata
index|[
literal|36
index|]
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|inqdata
index|[
literal|0
index|]
operator|=
name|T_PROCESSOR
expr_stmt|;
comment|/* Periph Qualifier& Periph Dev Type */
name|inqdata
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* rem media bit& Dev Type Modifier */
name|inqdata
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* ISO, ECMA,& ANSI versions */
name|inqdata
index|[
literal|4
index|]
operator|=
literal|31
expr_stmt|;
comment|/* length of additional data */
name|strncpy
argument_list|(
operator|&
name|inqdata
index|[
literal|8
index|]
argument_list|,
literal|"Areca   "
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Vendor Identification */
name|strncpy
argument_list|(
operator|&
name|inqdata
index|[
literal|16
index|]
argument_list|,
literal|"RAID controller "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Product Identification */
name|strncpy
argument_list|(
operator|&
name|inqdata
index|[
literal|32
index|]
argument_list|,
literal|"R001"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Product Revision */
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|inqdata
argument_list|,
sizeof|sizeof
argument_list|(
name|inqdata
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|WRITE_BUFFER
case|:
case|case
name|READ_BUFFER
case|:
block|{
if|if
condition|(
name|arcmsr_iop_message_xfer
argument_list|(
name|acb
argument_list|,
name|pccb
argument_list|)
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|pccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************* ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|psim
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
decl_stmt|;
name|acb
operator|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|psim
argument_list|)
expr_stmt|;
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|int
name|target
init|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|16
condition|)
block|{
comment|/* virtual device for iop message transfer */
name|arcmsr_handle_virtual_command
argument_list|(
name|acb
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|srb
operator|=
name|arcmsr_get_freesrb
argument_list|(
name|acb
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbsrb_ptr
operator|=
name|srb
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbacb_ptr
operator|=
name|acb
expr_stmt|;
name|srb
operator|->
name|pccb
operator|=
name|pccb
expr_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
condition|)
block|{
comment|/* Single buffer */
if|if
condition|(
operator|!
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
condition|)
block|{
comment|/* Buffer is virtual */
name|u_int32_t
name|error
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|,
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|pccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|arcmsr_executesrb
argument_list|,
name|srb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Buffer is physical */
name|panic
argument_list|(
literal|"arcmsr: CAM_DATA_PHYS not supported"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Scatter/gather list */
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
operator|||
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|srb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|arcmsr_executesrb
argument_list|(
name|srb
argument_list|,
name|segs
argument_list|,
name|pccb
operator|->
name|csio
operator|.
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|arcmsr_executesrb
argument_list|(
name|srb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_TARGET_IO
case|:
block|{
comment|/* target mode not yet support vendor specific commands. */
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|pccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|ARCMSR_MAX_TARGETID
expr_stmt|;
comment|/* 0-16 */
name|cpi
operator|->
name|max_lun
operator|=
name|ARCMSR_MAX_TARGETLUN
expr_stmt|;
comment|/* 0-7 */
name|cpi
operator|->
name|initiator_id
operator|=
name|ARCMSR_SCSI_INITIATOR_ID
expr_stmt|;
comment|/* 255 */
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|psim
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"ARCMSR"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|psim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|psim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_ABORT
case|:
block|{
name|union
name|ccb
modifier|*
name|pabort_ccb
decl_stmt|;
name|pabort_ccb
operator|=
name|pccb
operator|->
name|cab
operator|.
name|abort_ccb
expr_stmt|;
switch|switch
condition|(
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
if|if
condition|(
name|arcmsr_seek_cmd2abort
argument_list|(
name|pabort_ccb
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|xpt_done
argument_list|(
name|pabort_ccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|xpt_print_path
argument_list|(
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Not found\n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_PATH_INVALID
expr_stmt|;
block|}
break|break;
case|case
name|XPT_SCSI_IO
case|:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_UA_ABORT
expr_stmt|;
break|break;
default|default:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
case|case
name|XPT_RESET_DEV
case|:
block|{
name|u_int32_t
name|i
decl_stmt|;
name|arcmsr_bus_reset
argument_list|(
name|acb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|500
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
if|if
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
literal|16
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|cts
operator|=
operator|&
name|pccb
operator|->
name|cts
expr_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|spi
operator|->
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
literal|3
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
literal|32
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
name|scsi
operator|->
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|u_int32_t
name|size_mb
decl_stmt|;
name|u_int32_t
name|secs_per_cylinder
decl_stmt|;
if|if
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
literal|16
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|ccg
operator|=
operator|&
name|pccb
operator|->
name|ccg
expr_stmt|;
if|if
condition|(
name|ccg
operator|->
name|block_size
operator|==
literal|0
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
operator|<
literal|0
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|1024
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_start_adapter_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_START_BGRB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'start adapter background rebulid' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_polling_srbdone
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|poll_srb
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|uint32_t
name|flag_srb
decl_stmt|,
name|outbound_intstatus
decl_stmt|,
name|poll_srb_done
init|=
literal|0
decl_stmt|,
name|poll_count
init|=
literal|0
decl_stmt|;
name|int
name|id
decl_stmt|,
name|lun
decl_stmt|;
name|polling_srb_retry
label|:
name|poll_count
operator|++
expr_stmt|;
name|outbound_intstatus
operator|=
name|CHIP_REG_READ32
argument_list|(
name|outbound_intstatus
argument_list|)
operator|&
name|acb
operator|->
name|outbound_int_enable
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|outbound_intstatus
argument_list|,
name|outbound_intstatus
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|flag_srb
operator|=
name|CHIP_REG_READ32
argument_list|(
name|outbound_queueport
argument_list|)
operator|)
operator|==
literal|0xFFFFFFFF
condition|)
block|{
if|if
condition|(
name|poll_srb_done
condition|)
block|{
break|break;
comment|/*chip FIFO no ccb for completion already*/
block|}
else|else
block|{
name|UDELAY
argument_list|(
literal|25000
argument_list|)
expr_stmt|;
if|if
condition|(
name|poll_count
operator|>
literal|100
condition|)
block|{
break|break;
block|}
goto|goto
name|polling_srb_retry
goto|;
block|}
block|}
comment|/* check ifcommand done with no error*/
name|srb
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
operator|(
name|acb
operator|->
name|vir2phy_offset
operator|+
operator|(
name|flag_srb
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
comment|/*frame must be 32 bytes aligned*/
if|if
condition|(
operator|(
name|srb
operator|->
name|acb
operator|!=
name|acb
operator|)
operator|||
operator|(
name|srb
operator|->
name|startdone
operator|!=
name|ARCMSR_SRB_START
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|srb
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_ABORTED
operator|)
operator|&&
operator|(
name|srb
operator|==
name|poll_srb
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d srb='%p'"
literal|"poll command abort successfully \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|srb
argument_list|)
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|poll_srb_done
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"arcmsr%d: polling get an illegal srb command done srb='%p'"
literal|"srboutstandingcount=%d \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
argument_list|,
name|acb
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|id
operator|=
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|acb
operator|->
name|devstate
index|[
name|id
index|]
index|[
name|lun
index|]
operator|==
name|ARECA_RAID_GONE
condition|)
block|{
name|acb
operator|->
name|devstate
index|[
name|id
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
block|}
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|srb
operator|->
name|arcmsr_cdb
operator|.
name|DeviceStatus
condition|)
block|{
case|case
name|ARCMSR_DEV_SELECT_TIMEOUT
case|:
block|{
name|acb
operator|->
name|devstate
index|[
name|id
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_DEV_ABORTED
case|:
case|case
name|ARCMSR_DEV_INIT_FAIL
case|:
block|{
name|acb
operator|->
name|devstate
index|[
name|id
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCSISTAT_CHECK_CONDITION
case|:
block|{
name|acb
operator|->
name|devstate
index|[
name|id
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
name|arcmsr_report_sense_info
argument_list|(
name|srb
argument_list|)
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d"
literal|"polling and getting command error done"
literal|", but got unknow DeviceStatus=0x%x \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|id
argument_list|,
name|lun
argument_list|,
name|srb
operator|->
name|arcmsr_cdb
operator|.
name|DeviceStatus
argument_list|)
expr_stmt|;
name|acb
operator|->
name|devstate
index|[
name|id
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_UNCOR_PARITY
expr_stmt|;
comment|/*unknow error or crc error just for retry*/
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*drain reply FIFO*/
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  get firmware miscellaneous data ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_get_firmware_spec
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|char
modifier|*
name|acb_firm_model
init|=
name|acb
operator|->
name|firm_model
decl_stmt|;
name|char
modifier|*
name|acb_firm_version
init|=
name|acb
operator|->
name|firm_version
decl_stmt|;
name|size_t
name|iop_firm_model
init|=
name|offsetof
argument_list|(
expr|struct
name|MessageUnit
argument_list|,
name|message_rwbuffer
index|[
literal|15
index|]
argument_list|)
decl_stmt|;
comment|/*firm_model,15,60-67*/
name|size_t
name|iop_firm_version
init|=
name|offsetof
argument_list|(
expr|struct
name|MessageUnit
argument_list|,
name|message_rwbuffer
index|[
literal|17
index|]
argument_list|)
decl_stmt|;
comment|/*firm_version,17,68-83*/
name|int
name|i
decl_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_GET_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'get adapter firmware miscellaneous data' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|8
condition|)
block|{
operator|*
name|acb_firm_model
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
argument_list|,
name|acb
operator|->
name|bhandle
argument_list|,
name|iop_firm_model
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 8 bytes firm_model, 15, 60-67*/
name|acb_firm_model
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|16
condition|)
block|{
operator|*
name|acb_firm_version
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
argument_list|,
name|acb
operator|->
name|bhandle
argument_list|,
name|iop_firm_version
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 16 bytes firm_version, 17, 68-83*/
name|acb_firm_version
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: %s \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: FIRMWARE VERSION %s \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|acb
operator|->
name|firm_version
argument_list|)
expr_stmt|;
name|acb
operator|->
name|firm_request_len
operator|=
name|CHIP_REG_READ32
argument_list|(
name|message_rwbuffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*firm_request_len, 1, 04-07*/
name|acb
operator|->
name|firm_numbers_queue
operator|=
name|CHIP_REG_READ32
argument_list|(
name|message_rwbuffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/*firm_numbers_queue, 2, 08-11*/
name|acb
operator|->
name|firm_sdram_size
operator|=
name|CHIP_REG_READ32
argument_list|(
name|message_rwbuffer
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/*firm_sdram_size, 3, 12-15*/
name|acb
operator|->
name|firm_ide_channels
operator|=
name|CHIP_REG_READ32
argument_list|(
name|message_rwbuffer
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/*firm_ide_channels, 4, 16-19*/
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  start background rebulid ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_init
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|intmask_org
decl_stmt|,
name|mask
decl_stmt|,
name|outbound_doorbell
decl_stmt|,
name|firmware_state
init|=
literal|0
decl_stmt|;
do|do
block|{
name|firmware_state
operator|=
name|CHIP_REG_READ32
argument_list|(
name|outbound_msgaddr1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|firmware_state
operator|&
name|ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK
operator|)
operator|==
literal|0
condition|)
do|;
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
name|outbound_intmask
argument_list|)
operator||
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|outbound_intmask
argument_list|,
name|intmask_org
argument_list|)
expr_stmt|;
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
name|outbound_intmask
argument_list|)
operator||
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE
expr_stmt|;
name|arcmsr_get_firmware_spec
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_start_adapter_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* clear Qbuffer if door bell ringed */
name|outbound_doorbell
operator|=
name|CHIP_REG_READ32
argument_list|(
name|outbound_doorbell
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|outbound_doorbell
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
comment|/*clear interrupt */
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/* enable outbound Post Queue, outbound message0, outbell doorbell Interrupt */
name|mask
operator|=
operator|~
operator|(
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE
operator|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|outbound_intmask
argument_list|,
name|intmask_org
operator|&
name|mask
argument_list|)
expr_stmt|;
name|acb
operator|->
name|outbound_int_enable
operator|=
operator|~
operator|(
name|intmask_org
operator|&
name|mask
operator|)
operator|&
literal|0x000000ff
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_IOP_INITED
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_map_freesrb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|arg
decl_stmt|;
name|struct
name|CommandControlBlock
modifier|*
name|srb_tmp
decl_stmt|;
name|u_int8_t
modifier|*
name|dma_memptr
decl_stmt|;
name|u_int32_t
name|i
decl_stmt|,
name|srb_phyaddr_hi32
decl_stmt|;
name|unsigned
name|long
name|srb_phyaddr
init|=
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_addr
decl_stmt|;
name|dma_memptr
operator|=
name|acb
operator|->
name|uncacheptr
expr_stmt|;
name|srb_phyaddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
comment|/* We suppose bus_addr_t high part always 0 here*/
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|dma_memptr
operator|&
literal|0x1F
operator|)
operator|!=
literal|0
condition|)
block|{
name|dma_memptr
operator|=
name|dma_memptr
operator|+
operator|(
literal|0x20
operator|-
operator|(
operator|(
name|unsigned
name|long
operator|)
name|dma_memptr
operator|&
literal|0x1F
operator|)
operator|)
expr_stmt|;
name|srb_phyaddr
operator|=
name|srb_phyaddr
operator|+
operator|(
literal|0x20
operator|-
operator|(
operator|(
name|unsigned
name|long
operator|)
name|srb_phyaddr
operator|&
literal|0x1F
operator|)
operator|)
expr_stmt|;
block|}
name|srb_tmp
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
name|dma_memptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
comment|/*srb address must 32 (0x20) boundary*/
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|srb_tmp
operator|&
literal|0x1F
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|srb_tmp
operator|->
name|dm_segs_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MAPFREESRB_FAILD
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: srb dmamap bus_dmamap_create error\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|srb_tmp
operator|->
name|cdb_shifted_phyaddr
operator|=
name|srb_phyaddr
operator|>>
literal|5
expr_stmt|;
name|srb_tmp
operator|->
name|acb
operator|=
name|acb
expr_stmt|;
name|acb
operator|->
name|srbworkingQ
index|[
name|i
index|]
operator|=
name|acb
operator|->
name|psrb_pool
index|[
name|i
index|]
operator|=
name|srb_tmp
expr_stmt|;
name|srb_phyaddr
operator|=
name|srb_phyaddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|CommandControlBlock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MAPFREESRB_FAILD
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: dma_memptr=%p i=%d"
literal|"this srb cross 32 bytes boundary ignored srb_tmp=%p \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|dma_memptr
argument_list|,
name|i
argument_list|,
name|srb_tmp
argument_list|)
expr_stmt|;
return|return;
block|}
name|srb_tmp
operator|++
expr_stmt|;
block|}
name|acb
operator|->
name|vir2phy_offset
operator|=
operator|(
name|unsigned
name|long
operator|)
name|srb_tmp
operator|-
operator|(
name|unsigned
name|long
operator|)
name|srb_phyaddr
expr_stmt|;
comment|/* 	******************************************************************** 	** here we need to tell iop 331 our freesrb.HighPart  	** if freesrb.HighPart is not zero 	******************************************************************** 	*/
name|srb_phyaddr_hi32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|srb_phyaddr
operator|>>
literal|16
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|srb_phyaddr_hi32
operator|!=
literal|0
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|message_rwbuffer
index|[
literal|0
index|]
argument_list|,
name|ARCMSR_SIGNATURE_SET_CONFIG
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|message_rwbuffer
index|[
literal|1
index|]
argument_list|,
name|srb_phyaddr_hi32
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_SET_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: 'set srb high part physical address' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** ** ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_free_resource
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
comment|/* remove the control device */
if|if
condition|(
name|acb
operator|->
name|ioctl_dev
operator|!=
name|NULL
condition|)
block|{
name|destroy_dev
argument_list|(
name|acb
operator|->
name|ioctl_dev
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_initialize
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|,
name|rid
init|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|vm_offset_t
name|mem_base
decl_stmt|;
name|u_int16_t
name|pci_command
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502010
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignemnt*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*nsegments*/
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|NULL
argument_list|,
comment|/*lockarg*/
name|NULL
argument_list|,
operator|&
name|acb
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignemnt*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*nsegments*/
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|acb
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|printf
argument_list|(
literal|"arcmsr%d: parent_dmat bus_dma_tag_create failure!\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* Create a single tag describing a region large enough to hold all of the s/g lists we will need. */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502010
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|acb
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|MAXBSIZE
argument_list|,
comment|/*nsegments*/
name|ARCMSR_MAX_SG_ENTRIES
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
operator|&
name|acb
operator|->
name|dm_segs_dmat
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|acb
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|MAXBSIZE
argument_list|,
comment|/*nsegments*/
name|ARCMSR_MAX_SG_ENTRIES
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|acb
operator|->
name|dm_segs_dmat
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: dm_segs_dmat bus_dma_tag_create failure!\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* DMA tag for our srb structures.... Allocate the freesrb memory */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502010
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|acb
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|ARCMSR_SRBS_POOL_SIZE
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|NULL
argument_list|,
comment|/*lockarg*/
name|NULL
argument_list|,
operator|&
name|acb
operator|->
name|srb_dmat
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|acb
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|ARCMSR_SRBS_POOL_SIZE
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|acb
operator|->
name|srb_dmat
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: srb_dmat bus_dma_tag_create failure!\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Allocation for our srbs */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|acb
operator|->
name|uncacheptr
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|acb
operator|->
name|srb_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: srb_dmat bus_dmamem_alloc failure!\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* And permanently map them */
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|acb
operator|->
name|uncacheptr
argument_list|,
name|ARCMSR_SRBS_POOL_SIZE
argument_list|,
name|arcmsr_map_freesrb
argument_list|,
name|acb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: srb_dmat bus_dmamap_load failure!\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|pci_command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_command
operator||=
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_command
operator||=
name|PCIM_CMD_PERRESPEN
expr_stmt|;
name|pci_command
operator||=
name|PCIM_CMD_MWRICEN
expr_stmt|;
comment|/* Enable Busmaster/Mem */
name|pci_command
operator||=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|pci_command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|acb
operator|->
name|sys_res_arcmsr
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|0x1000
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|acb
operator|->
name|sys_res_arcmsr
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: bus_alloc_resource failure!\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
name|rman_get_start
argument_list|(
name|acb
operator|->
name|sys_res_arcmsr
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: rman_get_start failure!\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|mem_base
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|acb
operator|->
name|sys_res_arcmsr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_base
operator|==
literal|0
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: rman_get_virtual failure!\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MAPFREESRB_FAILD
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: map free srb failure!\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|acb
operator|->
name|btag
operator|=
name|rman_get_bustag
argument_list|(
name|acb
operator|->
name|sys_res_arcmsr
argument_list|)
expr_stmt|;
name|acb
operator|->
name|bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|acb
operator|->
name|sys_res_arcmsr
argument_list|)
expr_stmt|;
name|acb
operator|->
name|pmu
operator|=
operator|(
expr|struct
name|MessageUnit
operator|*
operator|)
name|mem_base
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_RQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_WQBUFFER_READED
operator|)
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_SCSISTOPADAPTER
expr_stmt|;
comment|/* 	******************************************************************** 	** init raid volume state 	******************************************************************** 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_TARGETID
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARCMSR_MAX_TARGETLUN
condition|;
name|j
operator|++
control|)
block|{
name|acb
operator|->
name|devstate
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
block|}
block|}
comment|/* disable iop all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
name|outbound_intmask
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|outbound_intmask
argument_list|,
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
argument_list|)
expr_stmt|;
name|arcmsr_iop_init
argument_list|(
name|acb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
comment|/* Device Queue to use for this SIM */
name|struct
name|resource
modifier|*
name|irqres
decl_stmt|;
name|int
name|rid
decl_stmt|;
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: cannot allocate softc\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|acb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|AdapterControlBlock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_initialize
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: initialize failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* After setting up the adapter, map our interrupt */
name|rid
operator|=
literal|0
expr_stmt|;
name|irqres
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|irqres
operator|==
name|NULL
operator|||
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|irqres
argument_list|,
name|INTR_TYPE_CAM
operator||
name|INTR_ENTROPY
operator||
name|INTR_MPSAFE
argument_list|,
name|arcmsr_interrupt
argument_list|,
name|acb
argument_list|,
operator|&
name|acb
operator|->
name|ih
argument_list|)
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: unable to register interrupt handler!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|acb
operator|->
name|irqres
operator|=
name|irqres
expr_stmt|;
name|acb
operator|->
name|pci_dev
operator|=
name|dev
expr_stmt|;
name|acb
operator|->
name|pci_unit
operator|=
name|unit
expr_stmt|;
comment|/* 	 * Now let the CAM generic SCSI layer find the SCSI devices on 	 * the bus *  start queue to reset to the idle loop. * 	 * Create device queue of SIM(s) *  (MAX_START_JOB - 1) : 	 * max_sim_transactions 	*/
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|ARCMSR_MAX_START_JOB
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: cam_simq_alloc failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|acb
operator|->
name|psim
operator|=
name|cam_sim_alloc
argument_list|(
name|arcmsr_action
argument_list|,
name|arcmsr_poll
argument_list|,
literal|"arcmsr"
argument_list|,
name|acb
argument_list|,
name|unit
argument_list|,
literal|1
argument_list|,
name|ARCMSR_MAX_OUTSTANDING_CMD
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|acb
operator|->
name|psim
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: cam_sim_alloc failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: xpt_bus_register failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|acb
operator|->
name|ppath
argument_list|,
comment|/* periph */
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|acb
operator|->
name|psim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|acb
operator|->
name|psim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
comment|/* free_simq */
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: xpt_create_path failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|ARCMSR_LOCK_INIT
argument_list|(
operator|&
name|acb
operator|->
name|workingQ_done_lock
argument_list|,
literal|"arcmsr done working Q lock"
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_INIT
argument_list|(
operator|&
name|acb
operator|->
name|workingQ_start_lock
argument_list|,
literal|"arcmsr start working Q lock"
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_INIT
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|,
literal|"arcmsr Q buffer lock"
argument_list|)
expr_stmt|;
comment|/* 	**************************************************** 	*/
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|acb
operator|->
name|ppath
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
operator||
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|arcmsr_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|acb
operator|->
name|psim
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
comment|/* Create the control device.  */
name|acb
operator|->
name|ioctl_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|arcmsr_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
comment|/* GID_OPERATOR */
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|,
literal|"arcmsr%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|acb
operator|->
name|ioctl_dev
operator|->
name|si_drv1
operator|=
name|acb
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500005
operator|(
name|void
operator|)
name|make_dev_alias
argument_list|(
name|acb
operator|->
name|ioctl_dev
argument_list|,
literal|"arc%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|id
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|raid6
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_VENDOR_ID_ARECA
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
switch|switch
condition|(
name|id
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|PCIDevVenIDARC1110
case|:
case|case
name|PCIDevVenIDARC1210
case|:
name|raid6
operator|=
literal|0
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|PCIDevVenIDARC1120
case|:
case|case
name|PCIDevVenIDARC1130
case|:
case|case
name|PCIDevVenIDARC1160
case|:
case|case
name|PCIDevVenIDARC1170
case|:
case|case
name|PCIDevVenIDARC1220
case|:
case|case
name|PCIDevVenIDARC1230
case|:
case|case
name|PCIDevVenIDARC1260
case|:
case|case
name|PCIDevVenIDARC1270
case|:
case|case
name|PCIDevVenIDARC1280
case|:
name|type
operator|=
literal|"SATA"
expr_stmt|;
break|break;
case|case
name|PCIDevVenIDARC1380
case|:
case|case
name|PCIDevVenIDARC1381
case|:
case|case
name|PCIDevVenIDARC1680
case|:
case|case
name|PCIDevVenIDARC1681
case|:
name|type
operator|=
literal|"SAS"
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"X-TYPE"
expr_stmt|;
break|break;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Areca %s Host Adapter RAID Controller %s\n"
argument_list|,
name|type
argument_list|,
name|raid6
condition|?
literal|"(RAID6 capable)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|i
decl_stmt|,
name|poll_count
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|;
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* stop adapter background rebuild */
name|arcmsr_stop_adapter_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_flush_adapter_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
name|outbound_intmask
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|outbound_intmask
argument_list|,
operator|(
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
operator|)
argument_list|)
expr_stmt|;
comment|/* abort all outstanding command */
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_SCSISTOPADAPTER
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOP_INITED
expr_stmt|;
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|acb
operator|->
name|srboutstandingcount
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|poll_count
operator|<
literal|256
operator|)
condition|)
block|{
name|arcmsr_interrupt
argument_list|(
operator|(
name|void
operator|*
operator|)
name|acb
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|25000
argument_list|)
expr_stmt|;
name|poll_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
name|arcmsr_abort_allcmd
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/*clear all outbound posted Q*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|;
name|i
operator|++
control|)
block|{
name|CHIP_REG_READ32
argument_list|(
name|outbound_queueport
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|srb
operator|=
name|acb
operator|->
name|psrb_pool
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|srb
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
name|srb
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|atomic_set_int
argument_list|(
operator|&
name|acb
operator|->
name|srboutstandingcount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|acb
operator|->
name|workingsrb_doneindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|workingsrb_startindex
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|arcmsr_shutdown
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|acb
operator|->
name|sys_res_arcmsr
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|acb
operator|->
name|irqres
argument_list|,
name|acb
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|acb
operator|->
name|ppath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|acb
operator|->
name|ppath
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|acb
operator|->
name|psim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

