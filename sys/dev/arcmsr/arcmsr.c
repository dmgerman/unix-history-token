begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ***************************************************************************************** **        O.S   : FreeBSD **   FILE NAME  : arcmsr.c **        BY    : Erich Chen    **   Description: SCSI RAID Device Driver for  **                ARECA (ARC11XX/ARC12XX/ARC13XX/ARC16XX) SATA/SAS RAID HOST Adapter **                ARCMSR RAID Host adapter **                [RAID controller:INTEL 331(PCI-X) 341(PCI-EXPRESS) chip set] ****************************************************************************************** ************************************************************************ ** ** Copyright (c) 2004-2006 ARECA Co. Ltd. **        Erich Chen, Taipei Taiwan All rights reserved. ** ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** 3. The name of the author may not be used to endorse or promote products **    derived from this software without specific prior written permission. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR ** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  ** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT ** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT **(INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF ** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ************************************************************************** ** History ** **        REV#         DATE	            NAME	         DESCRIPTION **     1.00.00.00    3/31/2004	       Erich Chen	     First release **     1.20.00.02   11/29/2004         Erich Chen        bug fix with arcmsr_bus_reset when PHY error **     1.20.00.03    4/19/2005         Erich Chen        add SATA 24 Ports adapter type support **                                                       clean unused function **     1.20.00.12    9/12/2005         Erich Chen        bug fix with abort command handling,  **                                                       firmware version check  **                                                       and firmware update notify for hardware bug fix **                                                       handling if none zero high part physical address  **                                                       of srb resource  **     1.20.00.13    8/18/2006         Erich Chen        remove pending srb and report busy **                                                       add iop message xfer  **                                                       with scsi pass-through command **                                                       add new device id of sas raid adapters  **                                                       code fit for SPARC64& PPC  **     1.20.00.14   02/05/2007         Erich Chen        bug fix for incorrect ccb_h.status report **                                                       and cause g_vfs_done() read write error **     1.20.00.15   10/10/2007         Erich Chen        support new RAID adapter type ARC120x ****************************************************************************************** * $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<isa/rtc.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500005
end_if

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_define
define|#
directive|define
name|ARCMSR_LOCK_INIT
parameter_list|(
name|l
parameter_list|,
name|s
parameter_list|)
value|mtx_init(l, s, NULL, MTX_DEF|MTX_RECURSE)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_DESTROY
parameter_list|(
name|l
parameter_list|)
value|mtx_destroy(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_ACQUIRE
parameter_list|(
name|l
parameter_list|)
value|mtx_lock(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_RELEASE
parameter_list|(
name|l
parameter_list|)
value|mtx_unlock(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_TRY
parameter_list|(
name|l
parameter_list|)
value|mtx_trylock(l)
end_define

begin_define
define|#
directive|define
name|arcmsr_htole32
parameter_list|(
name|x
parameter_list|)
value|htole32(x)
end_define

begin_typedef
typedef|typedef
name|struct
name|mtx
name|arcmsr_lock_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_define
define|#
directive|define
name|ARCMSR_LOCK_INIT
parameter_list|(
name|l
parameter_list|,
name|s
parameter_list|)
value|simple_lock_init(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_DESTROY
parameter_list|(
name|l
parameter_list|)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_ACQUIRE
parameter_list|(
name|l
parameter_list|)
value|simple_lock(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_RELEASE
parameter_list|(
name|l
parameter_list|)
value|simple_unlock(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_TRY
parameter_list|(
name|l
parameter_list|)
value|simple_lock_try(l)
end_define

begin_define
define|#
directive|define
name|arcmsr_htole32
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_typedef
typedef|typedef
name|struct
name|simplelock
name|arcmsr_lock_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CAM_NEW_TRAN_CODE
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|700025
end_if

begin_define
define|#
directive|define
name|CAM_NEW_TRAN_CODE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/arcmsr/arcmsr.h>
end_include

begin_define
define|#
directive|define
name|ARCMSR_SRBS_POOL_SIZE
value|((sizeof(struct CommandControlBlock) * ARCMSR_MAX_FREESRB_NUM))
end_define

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_define
define|#
directive|define
name|CHIP_REG_READ32
parameter_list|(
name|s
parameter_list|,
name|b
parameter_list|,
name|r
parameter_list|)
value|bus_space_read_4(acb->btag[b], acb->bhandle[b], offsetof(struct s, r))
end_define

begin_define
define|#
directive|define
name|CHIP_REG_WRITE32
parameter_list|(
name|s
parameter_list|,
name|b
parameter_list|,
name|r
parameter_list|,
name|d
parameter_list|)
value|bus_space_write_4(acb->btag[b], acb->bhandle[b], offsetof(struct s, r), d)
end_define

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function_decl
specifier|static
name|struct
name|CommandControlBlock
modifier|*
name|arcmsr_get_freesrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|arcmsr_seek_cmd2abort
parameter_list|(
name|union
name|ccb
modifier|*
name|abortccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|arcmsr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|arcmsr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|arcmsr_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|arcmsr_iop_ioctlcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|u_int32_t
name|ioctl_cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_iop_parking
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_interrupt
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_polling_srbdone
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|poll_srb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_free_resource
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_bus_reset
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_stop_adapter_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_start_adapter_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_iop_init
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_flush_adapter_cache
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_post_ioctldata2iop
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_abort_allcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_srb_complete
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|,
name|int
name|stand_flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_iop_reset
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_report_sense_info
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_build_srb
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|u_int32_t
name|nseg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_iop_message_xfer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|UDELAY
parameter_list|(
name|u_int32_t
name|us
parameter_list|)
block|{
name|DELAY
argument_list|(
name|us
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|arcmsr_map_freesrb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|arcmsr_executesrb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|arcmsr_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|arcmsr_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|arcmsr_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|arcmsr_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|arcmsr_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|arcmsr_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|arcmsr_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|arcmsr_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|arcmsr_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|arcmsr_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|arcmsr_driver
init|=
block|{
literal|"arcmsr"
block|,
name|arcmsr_methods
block|,
expr|sizeof
operator|(
expr|struct
name|AdapterControlBlock
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|arcmsr_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|arcmsr
argument_list|,
name|pci
argument_list|,
name|arcmsr_driver
argument_list|,
name|arcmsr_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|arcmsr
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|arcmsr
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BUS_DMA_COHERENT
end_ifndef

begin_define
define|#
directive|define
name|BUS_DMA_COHERENT
value|0x04
end_define

begin_comment
comment|/* hint: map memory in a coherent way */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|501000
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|D_NEEDGIANT
end_ifndef

begin_define
define|#
directive|define
name|D_NEEDGIANT
value|0x00400000
end_define

begin_comment
comment|/* driver want Giant */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|D_VERSION
end_ifndef

begin_define
define|#
directive|define
name|D_VERSION
value|0x20011966
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|arcmsr_cdevsw
init|=
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|502010
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
endif|#
directive|endif
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|arcmsr_open
block|,
comment|/* open     */
operator|.
name|d_close
operator|=
name|arcmsr_close
block|,
comment|/* close    */
operator|.
name|d_ioctl
operator|=
name|arcmsr_ioctl
block|,
comment|/* ioctl    */
operator|.
name|d_name
operator|=
literal|"arcmsr"
block|,
comment|/* name     */
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ARCMSR_CDEV_MAJOR
value|180
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|arcmsr_cdevsw
init|=
block|{
name|arcmsr_open
block|,
comment|/* open     */
name|arcmsr_close
block|,
comment|/* close    */
name|noread
block|,
comment|/* read     */
name|nowrite
block|,
comment|/* write    */
name|arcmsr_ioctl
block|,
comment|/* ioctl    */
name|nopoll
block|,
comment|/* poll     */
name|nommap
block|,
comment|/* mmap     */
name|nostrategy
block|,
comment|/* strategy */
literal|"arcmsr"
block|,
comment|/* name     */
name|ARCMSR_CDEV_MAJOR
block|,
comment|/* major    */
name|nodump
block|,
comment|/* dump     */
name|nopsize
block|,
comment|/* psize    */
literal|0
comment|/* flags    */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_open
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_open
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_open
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
name|d_thread_t
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_close
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
name|d_thread_t
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_ioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_ioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_ioctl
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
name|d_thread_t
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
return|return
operator|(
name|arcmsr_iop_ioctlcmd
argument_list|(
name|acb
argument_list|,
name|ioctl_cmd
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_disable_allintr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|intmask_org
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intmask
argument_list|)
operator||
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE
expr_stmt|;
comment|/* disable outbound message0 int */
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intmask
argument_list|,
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell_mask
argument_list|)
operator|&
operator|(
operator|~
name|ARCMSR_IOP2DRV_MESSAGE_CMD_DONE
operator|)
expr_stmt|;
comment|/* disable outbound message0 int */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable all interrupt */
block|}
break|break;
block|}
return|return
operator|(
name|intmask_org
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_enable_allintr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|u_int32_t
name|intmask_org
parameter_list|)
block|{
name|u_int32_t
name|mask
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
comment|/* enable outbound Post Queue, outbound doorbell Interrupt */
name|mask
operator|=
operator|~
operator|(
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE
operator|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intmask
argument_list|,
name|intmask_org
operator|&
name|mask
argument_list|)
expr_stmt|;
name|acb
operator|->
name|outbound_int_enable
operator|=
operator|~
operator|(
name|intmask_org
operator|&
name|mask
operator|)
operator|&
literal|0x000000ff
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
comment|/* disable ARCMSR_IOP2DRV_MESSAGE_CMD_DONE */
name|mask
operator|=
operator|(
name|ARCMSR_IOP2DRV_DATA_WRITE_OK
operator||
name|ARCMSR_IOP2DRV_DATA_READ_OK
operator||
name|ARCMSR_IOP2DRV_CDB_DONE
operator|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell_mask
argument_list|,
name|intmask_org
operator||
name|mask
argument_list|)
expr_stmt|;
comment|/*1=interrupt enable, 0=interrupt disable*/
name|acb
operator|->
name|outbound_int_enable
operator|=
operator|(
name|intmask_org
operator||
name|mask
operator|)
operator|&
literal|0x0000000f
expr_stmt|;
block|}
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|u_int8_t
name|arcmsr_hba_wait_msgint_ready
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|Index
decl_stmt|;
name|u_int8_t
name|Retries
init|=
literal|0x00
decl_stmt|;
do|do
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
literal|100
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|)
operator|&
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INT
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|,
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INT
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
return|return
name|TRUE
return|;
block|}
name|UDELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
comment|/*max 1 seconds*/
block|}
do|while
condition|(
name|Retries
operator|++
operator|<
literal|20
condition|)
do|;
comment|/*max 20 sec*/
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|u_int8_t
name|arcmsr_hbb_wait_msgint_ready
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|Index
decl_stmt|;
name|u_int8_t
name|Retries
init|=
literal|0x00
decl_stmt|;
do|do
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
literal|100
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
name|CHIP_REG_READ32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|)
operator|&
name|ARCMSR_IOP2DRV_MESSAGE_CMD_DONE
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|,
name|ARCMSR_MESSAGE_INT_CLEAR_PATTERN
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_DRV2IOP_END_OF_INTERRUPT
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|UDELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
comment|/*max 1 seconds*/
block|}
do|while
condition|(
name|Retries
operator|++
operator|<
literal|20
condition|)
do|;
comment|/*max 20 sec*/
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_flush_hba_cache
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|int
name|retry_count
init|=
literal|30
decl_stmt|;
comment|/* enlarge wait flush adapter cache time: 10 minute */
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_FLUSH_CACHE
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|arcmsr_hba_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|retry_count
operator|--
expr_stmt|;
block|}
block|}
do|while
condition|(
name|retry_count
operator|!=
literal|0
condition|)
do|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_flush_hbb_cache
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|int
name|retry_count
init|=
literal|30
decl_stmt|;
comment|/* enlarge wait flush adapter cache time: 10 minute */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_FLUSH_CACHE
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|retry_count
operator|--
expr_stmt|;
block|}
block|}
do|while
condition|(
name|retry_count
operator|!=
literal|0
condition|)
do|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_flush_adapter_cache
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|arcmsr_flush_hba_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|arcmsr_flush_hbb_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ******************************************************************************* ******************************************************************************* */
end_comment

begin_function
specifier|static
name|int
name|arcmsr_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* disable all outbound interrupt */
name|arcmsr_disable_allintr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* flush controller */
name|arcmsr_iop_parking
argument_list|(
name|acb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ******************************************************************************* ******************************************************************************* */
end_comment

begin_function
specifier|static
name|int
name|arcmsr_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|arcmsr_iop_init
argument_list|(
name|acb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************************* ********************************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_async
parameter_list|(
name|void
modifier|*
name|cb_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
decl_stmt|;
name|u_int8_t
name|target_id
decl_stmt|,
name|target_lun
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|cb_arg
expr_stmt|;
name|acb
operator|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_LOST_DEVICE
case|:
name|target_id
operator|=
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|target_lun
operator|=
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target_id
operator|>
name|ARCMSR_MAX_TARGETID
operator|)
operator|||
operator|(
name|target_lun
operator|>
name|ARCMSR_MAX_TARGETLUN
operator|)
condition|)
block|{
break|break;
block|}
name|printf
argument_list|(
literal|"%s:scsi id%d lun%d device lost \n"
argument_list|,
name|device_get_name
argument_list|(
name|acb
operator|->
name|pci_dev
argument_list|)
argument_list|,
name|target_id
argument_list|,
name|target_lun
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_srb_complete
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|,
name|int
name|stand_flag
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|srb
operator|->
name|acb
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
init|=
name|srb
operator|->
name|pccb
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stand_flag
operator|==
literal|1
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|acb
operator|->
name|srboutstandingcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_CAM_DEV_QFRZN
operator|)
operator|&&
operator|(
name|acb
operator|->
name|srboutstandingcount
operator|<
name|ARCMSR_RELEASE_SIMQ_LEVEL
operator|)
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_CAM_DEV_QFRZN
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
block|}
name|srb
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_DONE
expr_stmt|;
name|srb
operator|->
name|srb_flags
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|srbworkingQ
index|[
name|acb
operator|->
name|workingsrb_doneindex
index|]
operator|=
name|srb
expr_stmt|;
name|acb
operator|->
name|workingsrb_doneindex
operator|++
expr_stmt|;
name|acb
operator|->
name|workingsrb_doneindex
operator|%=
name|ARCMSR_MAX_FREESRB_NUM
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_report_sense_info
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|pccb
init|=
name|srb
operator|->
name|pccb
decl_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|pccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
condition|)
block|{
name|memset
argument_list|(
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|srb
operator|->
name|arcmsr_cdb
operator|.
name|SenseData
argument_list|,
name|get_min
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|SENSE_DATA
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|0
index|]
operator|=
operator|(
literal|0x1
operator|<<
literal|7
operator||
literal|0x70
operator|)
expr_stmt|;
comment|/* Valid,ErrorCode */
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************* ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_abort_hba_allcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_ABORT_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hba_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'abort all outstanding command' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************* ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_abort_hbb_allcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_ABORT_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'abort all outstanding command' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************* ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_abort_allcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|arcmsr_abort_hba_allcmd
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|arcmsr_abort_hbb_allcmd
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_report_srb_state
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|,
name|u_int32_t
name|flag_srb
parameter_list|)
block|{
name|int
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|target
operator|=
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|ARECA_RAID_GONE
condition|)
block|{
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
block|}
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|srb
operator|->
name|arcmsr_cdb
operator|.
name|DeviceStatus
condition|)
block|{
case|case
name|ARCMSR_DEV_SELECT_TIMEOUT
case|:
block|{
if|if
condition|(
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|ARECA_RAID_GOOD
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: select timeout"
literal|", raid volume was kicked out \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_DEV_ABORTED
case|:
case|case
name|ARCMSR_DEV_INIT_FAIL
case|:
block|{
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCSISTAT_CHECK_CONDITION
case|:
block|{
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
name|arcmsr_report_sense_info
argument_list|(
name|srb
argument_list|)
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d"
literal|"isr get command error done,"
literal|"but got unknow DeviceStatus=0x%x \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|srb
operator|->
name|arcmsr_cdb
operator|.
name|DeviceStatus
argument_list|)
expr_stmt|;
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_UNCOR_PARITY
expr_stmt|;
comment|/*unknow error or crc error just for retry*/
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_drain_donequeue
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|u_int32_t
name|flag_srb
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
comment|/* check if command done with no error*/
name|srb
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
operator|(
name|acb
operator|->
name|vir2phy_offset
operator|+
operator|(
name|flag_srb
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
comment|/*frame must be 32 bytes aligned*/
if|if
condition|(
operator|(
name|srb
operator|->
name|acb
operator|!=
name|acb
operator|)
operator|||
operator|(
name|srb
operator|->
name|startdone
operator|!=
name|ARCMSR_SRB_START
operator|)
condition|)
block|{
if|if
condition|(
name|srb
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: srb='%p' isr got aborted command \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
argument_list|)
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"arcmsr%d: isr get an illegal srb command done"
literal|"acb='%p' srb='%p' srbacb='%p' startdone=0x%x"
literal|"srboutstandingcount=%d \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|acb
argument_list|,
name|srb
argument_list|,
name|srb
operator|->
name|acb
argument_list|,
name|srb
operator|->
name|startdone
argument_list|,
name|acb
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
return|return;
block|}
name|arcmsr_report_srb_state
argument_list|(
name|acb
argument_list|,
name|srb
argument_list|,
name|flag_srb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_done4abort_postqueue
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|flag_srb
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|u_int32_t
name|outbound_intstatus
decl_stmt|;
comment|/*clear and abort all outbound posted Q*/
name|outbound_intstatus
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|)
operator|&
name|acb
operator|->
name|outbound_int_enable
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|,
name|outbound_intstatus
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
while|while
condition|(
operator|(
operator|(
name|flag_srb
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_queueport
argument_list|)
operator|)
operator|!=
literal|0xFFFFFFFF
operator|)
operator|&&
operator|(
name|i
operator|++
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
operator|)
condition|)
block|{
name|arcmsr_drain_donequeue
argument_list|(
name|acb
argument_list|,
name|flag_srb
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
init|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
comment|/*clear all outbound posted Q*/
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|,
name|ARCMSR_DOORBELL_INT_CLEAR_PATTERN
argument_list|)
expr_stmt|;
comment|/* clear doorbell interrupt */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_HBB_POSTQUEUE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|flag_srb
operator|=
name|phbbmu
operator|->
name|done_qbuffer
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|phbbmu
operator|->
name|done_qbuffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|arcmsr_drain_donequeue
argument_list|(
name|acb
argument_list|,
name|flag_srb
argument_list|)
expr_stmt|;
block|}
name|phbbmu
operator|->
name|post_qbuffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/*drain reply FIFO*/
name|phbbmu
operator|->
name|doneq_index
operator|=
literal|0
expr_stmt|;
name|phbbmu
operator|->
name|postq_index
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* **************************************************************************** **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_reset
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|;
name|u_int32_t
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|>
literal|0
condition|)
block|{
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|arcmsr_disable_allintr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/*clear and abort all outbound posted Q*/
name|arcmsr_done4abort_postqueue
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* talk to iop 331 outstanding command aborted*/
name|arcmsr_abort_allcmd
argument_list|(
name|acb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|srb
operator|=
name|acb
operator|->
name|psrb_pool
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|srb
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
name|srb
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* enable all outbound interrupt */
name|arcmsr_enable_allintr
argument_list|(
name|acb
argument_list|,
name|intmask_org
argument_list|)
expr_stmt|;
block|}
name|atomic_set_int
argument_list|(
operator|&
name|acb
operator|->
name|srboutstandingcount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|acb
operator|->
name|workingsrb_doneindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|workingsrb_startindex
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_build_srb
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|u_int32_t
name|nseg
parameter_list|)
block|{
name|struct
name|ARCMSR_CDB
modifier|*
name|arcmsr_cdb
init|=
operator|&
name|srb
operator|->
name|arcmsr_cdb
decl_stmt|;
name|u_int8_t
modifier|*
name|psge
init|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|arcmsr_cdb
operator|->
name|u
decl_stmt|;
name|u_int32_t
name|address_lo
decl_stmt|,
name|address_hi
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
init|=
name|srb
operator|->
name|pccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|pcsio
init|=
operator|&
name|pccb
operator|->
name|csio
decl_stmt|;
name|u_int32_t
name|arccdbsize
init|=
literal|0x30
decl_stmt|;
name|memset
argument_list|(
name|arcmsr_cdb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ARCMSR_CDB
argument_list|)
argument_list|)
expr_stmt|;
name|arcmsr_cdb
operator|->
name|Bus
operator|=
literal|0
expr_stmt|;
name|arcmsr_cdb
operator|->
name|TargetID
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|arcmsr_cdb
operator|->
name|LUN
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|arcmsr_cdb
operator|->
name|Function
operator|=
literal|1
expr_stmt|;
name|arcmsr_cdb
operator|->
name|CdbLength
operator|=
operator|(
name|u_int8_t
operator|)
name|pcsio
operator|->
name|cdb_len
expr_stmt|;
name|arcmsr_cdb
operator|->
name|Context
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|pcsio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|arcmsr_cdb
operator|->
name|Cdb
argument_list|,
name|pcsio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|srb
operator|->
name|acb
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|u_int32_t
name|length
decl_stmt|,
name|i
decl_stmt|,
name|cdb_sgcount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|arcmsr_cdb
operator|->
name|Flags
operator||=
name|ARCMSR_CDB_FLAG_WRITE
expr_stmt|;
name|srb
operator|->
name|srb_flags
operator||=
name|SRB_FLAG_WRITE
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get the physical address of the current data pointer */
name|length
operator|=
name|arcmsr_htole32
argument_list|(
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|address_lo
operator|=
name|arcmsr_htole32
argument_list|(
name|dma_addr_lo32
argument_list|(
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|address_hi
operator|=
name|arcmsr_htole32
argument_list|(
name|dma_addr_hi32
argument_list|(
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_hi
operator|==
literal|0
condition|)
block|{
name|struct
name|SG32ENTRY
modifier|*
name|pdma_sg
init|=
operator|(
expr|struct
name|SG32ENTRY
operator|*
operator|)
name|psge
decl_stmt|;
name|pdma_sg
operator|->
name|address
operator|=
name|address_lo
expr_stmt|;
name|pdma_sg
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG32ENTRY
argument_list|)
expr_stmt|;
name|arccdbsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG32ENTRY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|sg64s_size
init|=
literal|0
decl_stmt|,
name|tmplength
init|=
name|length
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|u_int64_t
name|span4G
decl_stmt|,
name|length0
decl_stmt|;
name|struct
name|SG64ENTRY
modifier|*
name|pdma_sg
init|=
operator|(
expr|struct
name|SG64ENTRY
operator|*
operator|)
name|psge
decl_stmt|;
name|span4G
operator|=
operator|(
name|u_int64_t
operator|)
name|address_lo
operator|+
name|tmplength
expr_stmt|;
name|pdma_sg
operator|->
name|addresshigh
operator|=
name|address_hi
expr_stmt|;
name|pdma_sg
operator|->
name|address
operator|=
name|address_lo
expr_stmt|;
if|if
condition|(
name|span4G
operator|>
literal|0x100000000
condition|)
block|{
comment|/*see if cross 4G boundary*/
name|length0
operator|=
literal|0x100000000
operator|-
name|address_lo
expr_stmt|;
name|pdma_sg
operator|->
name|length
operator|=
operator|(
name|u_int32_t
operator|)
name|length0
operator||
name|IS_SG64_ADDR
expr_stmt|;
name|address_hi
operator|=
name|address_hi
operator|+
literal|1
expr_stmt|;
name|address_lo
operator|=
literal|0
expr_stmt|;
name|tmplength
operator|=
name|tmplength
operator|-
operator|(
name|u_int32_t
operator|)
name|length0
expr_stmt|;
name|sg64s_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG64ENTRY
argument_list|)
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG64ENTRY
argument_list|)
expr_stmt|;
name|cdb_sgcount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pdma_sg
operator|->
name|length
operator|=
name|tmplength
operator||
name|IS_SG64_ADDR
expr_stmt|;
name|sg64s_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG64ENTRY
argument_list|)
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG64ENTRY
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|arccdbsize
operator|+=
name|sg64s_size
expr_stmt|;
block|}
name|cdb_sgcount
operator|++
expr_stmt|;
block|}
name|arcmsr_cdb
operator|->
name|sgcount
operator|=
operator|(
name|u_int8_t
operator|)
name|cdb_sgcount
expr_stmt|;
name|arcmsr_cdb
operator|->
name|DataLength
operator|=
name|pcsio
operator|->
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|arccdbsize
operator|>
literal|256
condition|)
block|{
name|arcmsr_cdb
operator|->
name|Flags
operator||=
name|ARCMSR_CDB_FLAG_SGL_BSIZE
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_post_srb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|)
block|{
name|u_int32_t
name|cdb_shifted_phyaddr
init|=
operator|(
name|u_int32_t
operator|)
name|srb
operator|->
name|cdb_shifted_phyaddr
decl_stmt|;
name|struct
name|ARCMSR_CDB
modifier|*
name|arcmsr_cdb
init|=
operator|(
expr|struct
name|ARCMSR_CDB
operator|*
operator|)
operator|&
name|srb
operator|->
name|arcmsr_cdb
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
operator|(
name|srb
operator|->
name|srb_flags
operator|&
name|SRB_FLAG_WRITE
operator|)
condition|?
name|BUS_DMASYNC_POSTWRITE
else|:
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|acb
operator|->
name|srboutstandingcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|srb
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_START
expr_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
if|if
condition|(
name|arcmsr_cdb
operator|->
name|Flags
operator|&
name|ARCMSR_CDB_FLAG_SGL_BSIZE
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_queueport
argument_list|,
name|cdb_shifted_phyaddr
operator||
name|ARCMSR_SRBPOST_FLAG_SGL_BSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_queueport
argument_list|,
name|cdb_shifted_phyaddr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
init|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|int
name|ending_index
decl_stmt|,
name|index
decl_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
name|index
operator|=
name|phbbmu
operator|->
name|postq_index
expr_stmt|;
name|ending_index
operator|=
operator|(
operator|(
name|index
operator|+
literal|1
operator|)
operator|%
name|ARCMSR_MAX_HBB_POSTQUEUE
operator|)
expr_stmt|;
name|phbbmu
operator|->
name|post_qbuffer
index|[
name|ending_index
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arcmsr_cdb
operator|->
name|Flags
operator|&
name|ARCMSR_CDB_FLAG_SGL_BSIZE
condition|)
block|{
name|phbbmu
operator|->
name|post_qbuffer
index|[
name|index
index|]
operator|=
name|cdb_shifted_phyaddr
operator||
name|ARCMSR_SRBPOST_FLAG_SGL_BSIZE
expr_stmt|;
block|}
else|else
block|{
name|phbbmu
operator|->
name|post_qbuffer
index|[
name|index
index|]
operator|=
name|cdb_shifted_phyaddr
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
name|index
operator|%=
name|ARCMSR_MAX_HBB_POSTQUEUE
expr_stmt|;
comment|/*if last index number set it to 0 */
name|phbbmu
operator|->
name|postq_index
operator|=
name|index
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_DRV2IOP_CDB_POSTED
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|struct
name|QBUFFER
modifier|*
name|arcmsr_get_iop_rqbuffer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|QBUFFER
modifier|*
name|qbuffer
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|struct
name|HBA_MessageUnit
modifier|*
name|phbamu
init|=
operator|(
expr|struct
name|HBA_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|qbuffer
operator|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|phbamu
operator|->
name|message_rbuffer
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
init|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|qbuffer
operator|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|phbbmu
operator|->
name|hbb_rwbuffer
operator|->
name|message_rbuffer
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|qbuffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|struct
name|QBUFFER
modifier|*
name|arcmsr_get_iop_wqbuffer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|QBUFFER
modifier|*
name|qbuffer
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|struct
name|HBA_MessageUnit
modifier|*
name|phbamu
init|=
operator|(
expr|struct
name|HBA_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|qbuffer
operator|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|phbamu
operator|->
name|message_wbuffer
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
init|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|qbuffer
operator|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|phbbmu
operator|->
name|hbb_rwbuffer
operator|->
name|message_wbuffer
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|qbuffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_message_read
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
comment|/* let IOP know data has been read */
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
comment|/* let IOP know data has been read */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_DRV2IOP_DATA_READ_OK
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_message_wrote
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
comment|/* 			** push inbound doorbell tell iop, driver data write ok  			** and wait reply on next hwinterrupt for next Qbuffer post 			*/
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
comment|/* 			** push inbound doorbell tell iop, driver data write ok  			** and wait reply on next hwinterrupt for next Qbuffer post 			*/
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_DRV2IOP_DATA_WRITE_OK
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_post_ioctldata2iop
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|struct
name|QBUFFER
modifier|*
name|pwbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
decl_stmt|;
name|int32_t
name|allxfer_len
init|=
literal|0
decl_stmt|;
name|pwbuffer
operator|=
name|arcmsr_get_iop_wqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|iop_data
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pwbuffer
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MESSAGE_WQBUFFER_READ
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|(
operator|~
name|ACB_F_MESSAGE_WQBUFFER_READ
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|acb
operator|->
name|wqbuf_firstindex
operator|!=
name|acb
operator|->
name|wqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|124
operator|)
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|wqbuffer
index|[
name|acb
operator|->
name|wqbuf_firstindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|iop_data
argument_list|,
name|pQbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|++
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
name|pwbuffer
operator|->
name|data_len
operator|=
name|allxfer_len
expr_stmt|;
comment|/* 		** push inbound doorbell and wait reply at hwinterrupt routine for next Qbuffer post 		*/
name|arcmsr_iop_message_wrote
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_stop_hba_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_STOP_BGRB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hba_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'stop adapter rebulid' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_stop_hbb_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_STOP_BGRB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'stop adapter rebulid' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_stop_adapter_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|arcmsr_stop_hba_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|arcmsr_stop_hbb_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|psim
parameter_list|)
block|{
name|arcmsr_interrupt
argument_list|(
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|psim
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_intr_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|arg
decl_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
name|arcmsr_interrupt
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop2drv_data_wrote_handle
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|QBUFFER
modifier|*
name|prbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
decl_stmt|;
name|int
name|my_empty_len
decl_stmt|,
name|iop_len
decl_stmt|,
name|rqbuf_firstindex
decl_stmt|,
name|rqbuf_lastindex
decl_stmt|;
comment|/*check this iop data if overflow my rqbuffer*/
name|rqbuf_lastindex
operator|=
name|acb
operator|->
name|rqbuf_lastindex
expr_stmt|;
name|rqbuf_firstindex
operator|=
name|acb
operator|->
name|rqbuf_firstindex
expr_stmt|;
name|prbuffer
operator|=
name|arcmsr_get_iop_rqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|iop_data
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|prbuffer
operator|->
name|data
expr_stmt|;
name|iop_len
operator|=
name|prbuffer
operator|->
name|data_len
expr_stmt|;
name|my_empty_len
operator|=
operator|(
name|rqbuf_firstindex
operator|-
name|rqbuf_lastindex
operator|-
literal|1
operator|)
operator|&
operator|(
name|ARCMSR_MAX_QBUFFER
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|my_empty_len
operator|>=
name|iop_len
condition|)
block|{
while|while
condition|(
name|iop_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|rqbuffer
index|[
name|rqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|iop_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rqbuf_lastindex
operator|++
expr_stmt|;
name|rqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|iop_len
operator|--
expr_stmt|;
block|}
name|acb
operator|->
name|rqbuf_lastindex
operator|=
name|rqbuf_lastindex
expr_stmt|;
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/*signature, let IOP know data has been read */
block|}
else|else
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop2drv_data_read_handle
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MESSAGE_WQBUFFER_READ
expr_stmt|;
comment|/* 	***************************************************************** 	**   check if there are any mail packages from user space program 	**   in my post bag, now is the time to send them into Areca's firmware 	***************************************************************** 	*/
if|if
condition|(
name|acb
operator|->
name|wqbuf_firstindex
operator|!=
name|acb
operator|->
name|wqbuf_lastindex
condition|)
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|struct
name|QBUFFER
modifier|*
name|pwbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
decl_stmt|;
name|int
name|allxfer_len
init|=
literal|0
decl_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|(
operator|~
name|ACB_F_MESSAGE_WQBUFFER_READ
operator|)
expr_stmt|;
name|pwbuffer
operator|=
name|arcmsr_get_iop_wqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|iop_data
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pwbuffer
operator|->
name|data
expr_stmt|;
while|while
condition|(
operator|(
name|acb
operator|->
name|wqbuf_firstindex
operator|!=
name|acb
operator|->
name|wqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|124
operator|)
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|wqbuffer
index|[
name|acb
operator|->
name|wqbuf_firstindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|iop_data
argument_list|,
name|pQbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|++
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
name|pwbuffer
operator|->
name|data_len
operator|=
name|allxfer_len
expr_stmt|;
comment|/* 		** push inbound doorbell tell iop driver data write ok  		** and wait reply on next hwinterrupt for next Qbuffer post 		*/
name|arcmsr_iop_message_wrote
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acb
operator|->
name|wqbuf_firstindex
operator|==
name|acb
operator|->
name|wqbuf_lastindex
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_hba_doorbell_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|outbound_doorbell
decl_stmt|;
comment|/* 	******************************************************************* 	**  Maybe here we need to check wrqbuffer_lock is lock or not 	**  DOORBELL: din! don!  	**  check if there are any mail need to pack from firmware 	******************************************************************* 	*/
name|outbound_doorbell
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
comment|/* clear doorbell interrupt */
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK
condition|)
block|{
name|arcmsr_iop2drv_data_wrote_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_OUTBOUND_IOP331_DATA_READ_OK
condition|)
block|{
name|arcmsr_iop2drv_data_read_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_hba_postqueue_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|flag_srb
decl_stmt|;
comment|/* 	***************************************************************************** 	**               areca cdb command done 	***************************************************************************** 	*/
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|flag_srb
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_queueport
argument_list|)
operator|)
operator|!=
literal|0xFFFFFFFF
condition|)
block|{
comment|/* check if command done with no error*/
name|arcmsr_drain_donequeue
argument_list|(
name|acb
argument_list|,
name|flag_srb
argument_list|)
expr_stmt|;
block|}
comment|/*drain reply FIFO*/
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_hbb_postqueue_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
init|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|u_int32_t
name|flag_srb
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* 	***************************************************************************** 	**               areca cdb command done 	***************************************************************************** 	*/
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|index
operator|=
name|phbbmu
operator|->
name|doneq_index
expr_stmt|;
while|while
condition|(
operator|(
name|flag_srb
operator|=
name|phbbmu
operator|->
name|done_qbuffer
index|[
name|index
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|phbbmu
operator|->
name|done_qbuffer
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|index
operator|++
expr_stmt|;
name|index
operator|%=
name|ARCMSR_MAX_HBB_POSTQUEUE
expr_stmt|;
comment|/*if last index number set it to 0 */
name|phbbmu
operator|->
name|doneq_index
operator|=
name|index
expr_stmt|;
comment|/* check if command done with no error*/
name|arcmsr_drain_donequeue
argument_list|(
name|acb
argument_list|,
name|flag_srb
argument_list|)
expr_stmt|;
block|}
comment|/*drain reply FIFO*/
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_handle_hba_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|outbound_intstatus
decl_stmt|;
comment|/* 	********************************************* 	**   check outbound intstatus  	********************************************* 	*/
name|outbound_intstatus
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|)
operator|&
name|acb
operator|->
name|outbound_int_enable
expr_stmt|;
if|if
condition|(
operator|!
name|outbound_intstatus
condition|)
block|{
comment|/*it must be share irq*/
return|return;
block|}
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|,
name|outbound_intstatus
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
comment|/* MU doorbell interrupts*/
if|if
condition|(
name|outbound_intstatus
operator|&
name|ARCMSR_MU_OUTBOUND_DOORBELL_INT
condition|)
block|{
name|arcmsr_hba_doorbell_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
comment|/* MU post queue interrupts*/
if|if
condition|(
name|outbound_intstatus
operator|&
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
condition|)
block|{
name|arcmsr_hba_postqueue_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_handle_hbb_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|outbound_doorbell
decl_stmt|;
comment|/* 	********************************************* 	**   check outbound intstatus  	********************************************* 	*/
name|outbound_doorbell
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|)
operator|&
name|acb
operator|->
name|outbound_int_enable
expr_stmt|;
if|if
condition|(
operator|!
name|outbound_doorbell
condition|)
block|{
comment|/*it must be share irq*/
return|return;
block|}
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|,
operator|~
name|outbound_doorbell
argument_list|)
expr_stmt|;
comment|/* clear doorbell interrupt */
name|CHIP_REG_READ32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_DRV2IOP_END_OF_INTERRUPT
argument_list|)
expr_stmt|;
comment|/* MU ioctl transfer doorbell interrupts*/
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_IOP2DRV_DATA_WRITE_OK
condition|)
block|{
name|arcmsr_iop2drv_data_wrote_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_IOP2DRV_DATA_READ_OK
condition|)
block|{
name|arcmsr_iop2drv_data_read_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
comment|/* MU post queue interrupts*/
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_IOP2DRV_CDB_DONE
condition|)
block|{
name|arcmsr_hbb_postqueue_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ****************************************************************************** ****************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_interrupt
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
name|arcmsr_handle_hba_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
name|arcmsr_handle_hbb_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"arcmsr%d: interrupt service,"
literal|" unknow adapter type =%d\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|acb
operator|->
name|adapter_type
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ******************************************************************************* ** ******************************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_parking
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
if|if
condition|(
name|acb
operator|!=
name|NULL
condition|)
block|{
comment|/* stop adapter background rebuild */
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MSG_START_BGRB
condition|)
block|{
name|arcmsr_stop_adapter_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_flush_adapter_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* *********************************************************************** ** ************************************************************************ */
end_comment

begin_function
name|u_int32_t
name|arcmsr_iop_ioctlcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|u_int32_t
name|ioctl_cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|CMD_MESSAGE_FIELD
modifier|*
name|pcmdmessagefld
decl_stmt|;
name|u_int32_t
name|retvalue
init|=
name|EINVAL
decl_stmt|;
name|pcmdmessagefld
operator|=
operator|(
expr|struct
name|CMD_MESSAGE_FIELD
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Signature
argument_list|,
literal|"ARCMSR"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|retvalue
return|;
block|}
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ioctl_cmd
condition|)
block|{
case|case
name|ARCMSR_MESSAGE_READ_RQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|ptmpQbuffer
init|=
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
name|u_int32_t
name|allxfer_len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|acb
operator|->
name|rqbuf_firstindex
operator|!=
name|acb
operator|->
name|rqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|1031
operator|)
condition|)
block|{
comment|/*copy READ QBUFFER to srb*/
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|rqbuffer
index|[
name|acb
operator|->
name|rqbuf_firstindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|ptmpQbuffer
argument_list|,
name|pQbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|++
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|ptmpQbuffer
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|struct
name|QBUFFER
modifier|*
name|prbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
decl_stmt|;
name|u_int32_t
name|iop_len
decl_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|prbuffer
operator|=
name|arcmsr_get_iop_rqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|iop_data
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|prbuffer
operator|->
name|data
expr_stmt|;
name|iop_len
operator|=
operator|(
name|u_int32_t
operator|)
name|prbuffer
operator|->
name|data_len
expr_stmt|;
comment|/*this iop data does no chance to make me overflow again here, so just do it*/
while|while
condition|(
name|iop_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|rqbuffer
index|[
name|acb
operator|->
name|rqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|iop_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|++
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|iop_len
operator|--
expr_stmt|;
block|}
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/*signature, let IOP know data has been readed */
block|}
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Length
operator|=
name|allxfer_len
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_WRITE_WQBUFFER
case|:
block|{
name|u_int32_t
name|my_empty_len
decl_stmt|,
name|user_len
decl_stmt|,
name|wqbuf_firstindex
decl_stmt|,
name|wqbuf_lastindex
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|ptmpuserbuffer
init|=
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
name|user_len
operator|=
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Length
expr_stmt|;
comment|/*check if data xfer length of this request will overflow my array qbuffer */
name|wqbuf_lastindex
operator|=
name|acb
operator|->
name|wqbuf_lastindex
expr_stmt|;
name|wqbuf_firstindex
operator|=
name|acb
operator|->
name|wqbuf_firstindex
expr_stmt|;
if|if
condition|(
name|wqbuf_lastindex
operator|!=
name|wqbuf_firstindex
condition|)
block|{
name|arcmsr_post_ioctldata2iop
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_ERROR
expr_stmt|;
block|}
else|else
block|{
name|my_empty_len
operator|=
operator|(
name|wqbuf_firstindex
operator|-
name|wqbuf_lastindex
operator|-
literal|1
operator|)
operator|&
operator|(
name|ARCMSR_MAX_QBUFFER
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|my_empty_len
operator|>=
name|user_len
condition|)
block|{
while|while
condition|(
name|user_len
operator|>
literal|0
condition|)
block|{
comment|/*copy srb data to wqbuffer*/
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|wqbuffer
index|[
name|acb
operator|->
name|wqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|ptmpuserbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|++
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|ptmpuserbuffer
operator|++
expr_stmt|;
name|user_len
operator|--
expr_stmt|;
block|}
comment|/*post fist Qbuffer*/
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
expr_stmt|;
name|arcmsr_post_ioctldata2iop
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
block|}
else|else
block|{
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_ERROR
expr_stmt|;
block|}
block|}
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_RQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
init|=
name|acb
operator|->
name|rqbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/*signature, let IOP know data has been readed */
block|}
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MESSAGE_RQBUFFER_CLEARED
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_WQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
init|=
name|acb
operator|->
name|wqbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/*signature, let IOP know data has been readed */
block|}
name|acb
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_WQBUFFER_READ
operator|)
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_ALLQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/*signature, let IOP know data has been readed */
block|}
name|acb
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_RQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_WQBUFFER_READ
operator|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|pQbuffer
operator|=
name|acb
operator|->
name|rqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pQbuffer
operator|=
name|acb
operator|->
name|wqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_REQUEST_RETURNCODE_3F
case|:
block|{
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_3F
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_SAY_HELLO
case|:
block|{
name|u_int8_t
modifier|*
name|hello_string
init|=
literal|"Hello! I am ARCMSR"
decl_stmt|;
name|u_int8_t
modifier|*
name|puserbuffer
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
if|if
condition|(
name|memcpy
argument_list|(
name|puserbuffer
argument_list|,
name|hello_string
argument_list|,
operator|(
name|int16_t
operator|)
name|strlen
argument_list|(
name|hello_string
argument_list|)
argument_list|)
condition|)
block|{
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_ERROR
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
return|return
name|ENOIOCTL
return|;
block|}
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_SAY_GOODBYE
case|:
block|{
name|arcmsr_iop_parking
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE
case|:
block|{
name|arcmsr_flush_adapter_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
block|}
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
return|return
name|retvalue
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
name|struct
name|CommandControlBlock
modifier|*
name|arcmsr_get_freesrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|workingsrb_startindex
decl_stmt|,
name|workingsrb_doneindex
decl_stmt|;
name|workingsrb_doneindex
operator|=
name|acb
operator|->
name|workingsrb_doneindex
expr_stmt|;
name|workingsrb_startindex
operator|=
name|acb
operator|->
name|workingsrb_startindex
expr_stmt|;
name|srb
operator|=
name|acb
operator|->
name|srbworkingQ
index|[
name|workingsrb_startindex
index|]
expr_stmt|;
name|workingsrb_startindex
operator|++
expr_stmt|;
name|workingsrb_startindex
operator|%=
name|ARCMSR_MAX_FREESRB_NUM
expr_stmt|;
if|if
condition|(
name|workingsrb_doneindex
operator|!=
name|workingsrb_startindex
condition|)
block|{
name|acb
operator|->
name|workingsrb_startindex
operator|=
name|workingsrb_startindex
expr_stmt|;
block|}
else|else
block|{
name|srb
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|srb
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|int
name|arcmsr_iop_message_xfer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
block|{
name|struct
name|CMD_MESSAGE_FIELD
modifier|*
name|pcmdmessagefld
decl_stmt|;
name|int
name|retvalue
init|=
literal|0
decl_stmt|,
name|transfer_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|u_int32_t
name|controlcode
init|=
operator|(
name|u_int32_t
operator|)
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|5
index|]
operator|<<
literal|24
operator||
operator|(
name|u_int32_t
operator|)
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|6
index|]
operator|<<
literal|16
operator||
operator|(
name|u_int32_t
operator|)
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|7
index|]
operator|<<
literal|8
operator||
operator|(
name|u_int32_t
operator|)
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
decl_stmt|;
comment|/* 4 bytes: Areca io control code */
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|buffer
operator|=
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|transfer_len
operator|=
name|pccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
block|}
else|else
block|{
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
goto|goto
name|message_out
goto|;
block|}
if|if
condition|(
name|transfer_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|CMD_MESSAGE_FIELD
argument_list|)
condition|)
block|{
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
goto|goto
name|message_out
goto|;
block|}
name|pcmdmessagefld
operator|=
operator|(
expr|struct
name|CMD_MESSAGE_FIELD
operator|*
operator|)
name|buffer
expr_stmt|;
switch|switch
condition|(
name|controlcode
condition|)
block|{
case|case
name|ARCMSR_MESSAGE_READ_RQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|ptmpQbuffer
init|=
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
name|int32_t
name|allxfer_len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|acb
operator|->
name|rqbuf_firstindex
operator|!=
name|acb
operator|->
name|rqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|1031
operator|)
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|rqbuffer
index|[
name|acb
operator|->
name|rqbuf_firstindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|ptmpQbuffer
argument_list|,
name|pQbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|++
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
name|ptmpQbuffer
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|struct
name|QBUFFER
modifier|*
name|prbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
decl_stmt|;
name|int32_t
name|iop_len
decl_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|prbuffer
operator|=
name|arcmsr_get_iop_rqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|iop_data
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|prbuffer
operator|->
name|data
expr_stmt|;
name|iop_len
operator|=
operator|(
name|u_int32_t
operator|)
name|prbuffer
operator|->
name|data_len
expr_stmt|;
while|while
condition|(
name|iop_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|rqbuffer
index|[
name|acb
operator|->
name|rqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|iop_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|++
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
name|iop_data
operator|++
expr_stmt|;
name|iop_len
operator|--
expr_stmt|;
block|}
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Length
operator|=
name|allxfer_len
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_WRITE_WQBUFFER
case|:
block|{
name|int32_t
name|my_empty_len
decl_stmt|,
name|user_len
decl_stmt|,
name|wqbuf_firstindex
decl_stmt|,
name|wqbuf_lastindex
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|ptmpuserbuffer
init|=
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
name|user_len
operator|=
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Length
expr_stmt|;
name|wqbuf_lastindex
operator|=
name|acb
operator|->
name|wqbuf_lastindex
expr_stmt|;
name|wqbuf_firstindex
operator|=
name|acb
operator|->
name|wqbuf_firstindex
expr_stmt|;
if|if
condition|(
name|wqbuf_lastindex
operator|!=
name|wqbuf_firstindex
condition|)
block|{
name|arcmsr_post_ioctldata2iop
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* has error report sensedata */
if|if
condition|(
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
condition|)
block|{
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|0
index|]
operator|=
operator|(
literal|0x1
operator|<<
literal|7
operator||
literal|0x70
operator|)
expr_stmt|;
comment|/* Valid,ErrorCode */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|2
index|]
operator|=
literal|0x05
expr_stmt|;
comment|/* FileMark,EndOfMedia,IncorrectLength,Reserved,SenseKey */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|7
index|]
operator|=
literal|0x0A
expr_stmt|;
comment|/* AdditionalSenseLength */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|12
index|]
operator|=
literal|0x20
expr_stmt|;
comment|/* AdditionalSenseCode */
block|}
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
block|}
else|else
block|{
name|my_empty_len
operator|=
operator|(
name|wqbuf_firstindex
operator|-
name|wqbuf_lastindex
operator|-
literal|1
operator|)
operator|&
operator|(
name|ARCMSR_MAX_QBUFFER
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|my_empty_len
operator|>=
name|user_len
condition|)
block|{
while|while
condition|(
name|user_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|wqbuffer
index|[
name|acb
operator|->
name|wqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|ptmpuserbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|++
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
name|ptmpuserbuffer
operator|++
expr_stmt|;
name|user_len
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
expr_stmt|;
name|arcmsr_post_ioctldata2iop
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* has error report sensedata */
if|if
condition|(
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
condition|)
block|{
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|0
index|]
operator|=
operator|(
literal|0x1
operator|<<
literal|7
operator||
literal|0x70
operator|)
expr_stmt|;
comment|/* Valid,ErrorCode */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|2
index|]
operator|=
literal|0x05
expr_stmt|;
comment|/* FileMark,EndOfMedia,IncorrectLength,Reserved,SenseKey */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|7
index|]
operator|=
literal|0x0A
expr_stmt|;
comment|/* AdditionalSenseLength */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|12
index|]
operator|=
literal|0x20
expr_stmt|;
comment|/* AdditionalSenseCode */
block|}
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_RQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
init|=
name|acb
operator|->
name|rqbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MESSAGE_RQBUFFER_CLEARED
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_WQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
init|=
name|acb
operator|->
name|wqbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
name|acb
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_WQBUFFER_READ
operator|)
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_ALLQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
name|acb
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_RQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_WQBUFFER_READ
operator|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|pQbuffer
operator|=
name|acb
operator|->
name|rqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pQbuffer
operator|=
name|acb
operator|->
name|wqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_REQUEST_RETURNCODE_3F
case|:
block|{
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_3F
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_SAY_HELLO
case|:
block|{
name|int8_t
modifier|*
name|hello_string
init|=
literal|"Hello! I am ARCMSR"
decl_stmt|;
name|memcpy
argument_list|(
name|pcmdmessagefld
operator|->
name|messagedatabuffer
argument_list|,
name|hello_string
argument_list|,
operator|(
name|int16_t
operator|)
name|strlen
argument_list|(
name|hello_string
argument_list|)
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_SAY_GOODBYE
case|:
name|arcmsr_iop_parking
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE
case|:
name|arcmsr_flush_adapter_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
block|}
name|message_out
label|:
return|return
name|retvalue
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************* ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_executesrb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
init|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|srb
operator|->
name|acb
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
decl_stmt|;
name|int
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|pccb
operator|=
name|srb
operator|->
name|pccb
expr_stmt|;
name|target
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: unexpected error %x"
literal|" returned from 'bus_dmamap_load' \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_TOO_BIG
expr_stmt|;
block|}
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nseg
operator|>
name|ARCMSR_MAX_SG_ENTRIES
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_TOO_BIG
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_BUS_RESET
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: bus reset and return busy \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|ARECA_RAID_GONE
condition|)
block|{
name|u_int8_t
name|block_cmd
decl_stmt|;
name|block_cmd
operator|=
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|block_cmd
operator|==
literal|0x08
operator|||
name|block_cmd
operator|==
literal|0x0a
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d:block 'read/write' command"
literal|"with gone raid volume Cmd=%2x, TargetId=%d, Lun=%d \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|block_cmd
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|)
expr_stmt|;
block|}
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|>=
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_CAM_DEV_QFRZN
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|arcmsr_build_srb
argument_list|(
name|srb
argument_list|,
name|dm_segs
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
name|arcmsr_post_srb
argument_list|(
name|acb
argument_list|,
name|srb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ***************************************************************************************** ***************************************************************************************** */
end_comment

begin_function
specifier|static
name|u_int8_t
name|arcmsr_seek_cmd2abort
parameter_list|(
name|union
name|ccb
modifier|*
name|abortccb
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|abortccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbacb_ptr
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|acb
operator|->
name|num_aborts
operator|++
expr_stmt|;
comment|/* 	*************************************************************************** 	** It is the upper layer do abort command this lock just prior to calling us. 	** First determine if we currently own this command. 	** Start by searching the device queue. If not found 	** at all, and the system wanted us to just abort the 	** command return success. 	*************************************************************************** 	*/
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|srb
operator|=
name|acb
operator|->
name|psrb_pool
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|srb
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
if|if
condition|(
name|srb
operator|->
name|pccb
operator|==
name|abortccb
condition|)
block|{
name|srb
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d:scsi id=%d lun=%d abort srb '%p'"
literal|"outstanding command \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|abortccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|abortccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|srb
argument_list|)
expr_stmt|;
goto|goto
name|abort_outstanding_cmd
goto|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
name|abort_outstanding_cmd
label|:
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|arcmsr_disable_allintr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_polling_srbdone
argument_list|(
name|acb
argument_list|,
name|srb
argument_list|)
expr_stmt|;
comment|/* enable outbound Post Queue, outbound doorbell Interrupt */
name|arcmsr_enable_allintr
argument_list|(
name|acb
argument_list|,
name|intmask_org
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************************** **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_bus_reset
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|int
name|retry
init|=
literal|0
decl_stmt|;
name|acb
operator|->
name|num_resets
operator|++
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_BUS_RESET
expr_stmt|;
while|while
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|!=
literal|0
operator|&&
name|retry
operator|<
literal|400
condition|)
block|{
name|arcmsr_interrupt
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|25000
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
block|}
name|arcmsr_iop_reset
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_BUS_RESET
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_handle_virtual_command
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
switch|switch
condition|(
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
condition|)
block|{
case|case
name|INQUIRY
case|:
block|{
name|unsigned
name|char
name|inqdata
index|[
literal|36
index|]
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|inqdata
index|[
literal|0
index|]
operator|=
name|T_PROCESSOR
expr_stmt|;
comment|/* Periph Qualifier& Periph Dev Type */
name|inqdata
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* rem media bit& Dev Type Modifier */
name|inqdata
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* ISO, ECMA,& ANSI versions */
name|inqdata
index|[
literal|4
index|]
operator|=
literal|31
expr_stmt|;
comment|/* length of additional data */
name|strncpy
argument_list|(
operator|&
name|inqdata
index|[
literal|8
index|]
argument_list|,
literal|"Areca   "
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Vendor Identification */
name|strncpy
argument_list|(
operator|&
name|inqdata
index|[
literal|16
index|]
argument_list|,
literal|"RAID controller "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Product Identification */
name|strncpy
argument_list|(
operator|&
name|inqdata
index|[
literal|32
index|]
argument_list|,
literal|"R001"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Product Revision */
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|inqdata
argument_list|,
sizeof|sizeof
argument_list|(
name|inqdata
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|WRITE_BUFFER
case|:
case|case
name|READ_BUFFER
case|:
block|{
if|if
condition|(
name|arcmsr_iop_message_xfer
argument_list|(
name|acb
argument_list|,
name|pccb
argument_list|)
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|pccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************* ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|psim
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
decl_stmt|;
name|acb
operator|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|psim
argument_list|)
expr_stmt|;
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|int
name|target
init|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|16
condition|)
block|{
comment|/* virtual device for iop message transfer */
name|arcmsr_handle_virtual_command
argument_list|(
name|acb
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|srb
operator|=
name|arcmsr_get_freesrb
argument_list|(
name|acb
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbsrb_ptr
operator|=
name|srb
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbacb_ptr
operator|=
name|acb
expr_stmt|;
name|srb
operator|->
name|pccb
operator|=
name|pccb
expr_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
condition|)
block|{
comment|/* Single buffer */
if|if
condition|(
operator|!
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
condition|)
block|{
comment|/* Buffer is virtual */
name|u_int32_t
name|error
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|,
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|pccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|arcmsr_executesrb
argument_list|,
name|srb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Buffer is physical */
name|panic
argument_list|(
literal|"arcmsr: CAM_DATA_PHYS not supported"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Scatter/gather list */
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
operator|||
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|srb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|arcmsr_executesrb
argument_list|(
name|srb
argument_list|,
name|segs
argument_list|,
name|pccb
operator|->
name|csio
operator|.
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|arcmsr_executesrb
argument_list|(
name|srb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_TARGET_IO
case|:
block|{
comment|/* target mode not yet support vendor specific commands. */
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|pccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|ARCMSR_MAX_TARGETID
expr_stmt|;
comment|/* 0-16 */
name|cpi
operator|->
name|max_lun
operator|=
name|ARCMSR_MAX_TARGETLUN
expr_stmt|;
comment|/* 0-7 */
name|cpi
operator|->
name|initiator_id
operator|=
name|ARCMSR_SCSI_INITIATOR_ID
expr_stmt|;
comment|/* 255 */
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|psim
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"ARCMSR"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|psim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|psim
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAM_NEW_TRAN_CODE
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
endif|#
directive|endif
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_ABORT
case|:
block|{
name|union
name|ccb
modifier|*
name|pabort_ccb
decl_stmt|;
name|pabort_ccb
operator|=
name|pccb
operator|->
name|cab
operator|.
name|abort_ccb
expr_stmt|;
switch|switch
condition|(
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
if|if
condition|(
name|arcmsr_seek_cmd2abort
argument_list|(
name|pabort_ccb
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|xpt_done
argument_list|(
name|pabort_ccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|xpt_print_path
argument_list|(
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Not found\n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_PATH_INVALID
expr_stmt|;
block|}
break|break;
case|case
name|XPT_SCSI_IO
case|:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_UA_ABORT
expr_stmt|;
break|break;
default|default:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
case|case
name|XPT_RESET_DEV
case|:
block|{
name|u_int32_t
name|i
decl_stmt|;
name|arcmsr_bus_reset
argument_list|(
name|acb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|500
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
if|if
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
literal|16
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|cts
operator|=
operator|&
name|pccb
operator|->
name|cts
expr_stmt|;
ifdef|#
directive|ifdef
name|CAM_NEW_TRAN_CODE
block|{
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|spi
operator|->
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
literal|3
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
literal|32
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
name|scsi
operator|->
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
block|}
else|#
directive|else
block|{
name|cts
operator|->
name|flags
operator|=
operator|(
name|CCB_TRANS_DISC_ENB
operator||
name|CCB_TRANS_TAG_ENB
operator|)
expr_stmt|;
name|cts
operator|->
name|sync_period
operator|=
literal|3
expr_stmt|;
name|cts
operator|->
name|sync_offset
operator|=
literal|32
expr_stmt|;
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
operator||
name|CCB_TRANS_BUS_WIDTH_VALID
operator||
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
block|}
endif|#
directive|endif
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|u_int32_t
name|size_mb
decl_stmt|;
name|u_int32_t
name|secs_per_cylinder
decl_stmt|;
if|if
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
literal|16
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|ccg
operator|=
operator|&
name|pccb
operator|->
name|ccg
expr_stmt|;
if|if
condition|(
name|ccg
operator|->
name|block_size
operator|==
literal|0
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
operator|<
literal|0
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|1024
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_start_hba_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_START_BGRB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hba_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'start adapter background rebulid' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_start_hbb_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_START_BGRB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'start adapter background rebulid' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_start_adapter_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
name|arcmsr_start_hba_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
name|arcmsr_start_hbb_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_polling_hba_srbdone
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|poll_srb
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|u_int32_t
name|flag_srb
decl_stmt|,
name|outbound_intstatus
decl_stmt|,
name|poll_srb_done
init|=
literal|0
decl_stmt|,
name|poll_count
init|=
literal|0
decl_stmt|;
name|polling_ccb_retry
label|:
name|poll_count
operator|++
expr_stmt|;
name|outbound_intstatus
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|)
operator|&
name|acb
operator|->
name|outbound_int_enable
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|,
name|outbound_intstatus
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|flag_srb
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_queueport
argument_list|)
operator|)
operator|==
literal|0xFFFFFFFF
condition|)
block|{
if|if
condition|(
name|poll_srb_done
condition|)
block|{
break|break;
comment|/*chip FIFO no ccb for completion already*/
block|}
else|else
block|{
name|UDELAY
argument_list|(
literal|25000
argument_list|)
expr_stmt|;
if|if
condition|(
name|poll_count
operator|>
literal|100
condition|)
block|{
break|break;
block|}
goto|goto
name|polling_ccb_retry
goto|;
block|}
block|}
comment|/* check ifcommand done with no error*/
name|srb
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
operator|(
name|acb
operator|->
name|vir2phy_offset
operator|+
operator|(
name|flag_srb
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
comment|/*frame must be 32 bytes aligned*/
name|poll_srb_done
operator|=
operator|(
name|srb
operator|==
name|poll_srb
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|srb
operator|->
name|acb
operator|!=
name|acb
operator|)
operator|||
operator|(
name|srb
operator|->
name|startdone
operator|!=
name|ARCMSR_SRB_START
operator|)
condition|)
block|{
if|if
condition|(
name|srb
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d srb='%p'"
literal|"poll command abort successfully \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|srb
argument_list|)
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"arcmsr%d: polling get an illegal srb command done srb='%p'"
literal|"srboutstandingcount=%d \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
argument_list|,
name|acb
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|arcmsr_report_srb_state
argument_list|(
name|acb
argument_list|,
name|srb
argument_list|,
name|flag_srb
argument_list|)
expr_stmt|;
block|}
comment|/*drain reply FIFO*/
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_polling_hbb_srbdone
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|poll_srb
parameter_list|)
block|{
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
init|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|u_int32_t
name|flag_srb
decl_stmt|,
name|poll_srb_done
init|=
literal|0
decl_stmt|,
name|poll_count
init|=
literal|0
decl_stmt|;
name|int
name|index
decl_stmt|;
name|polling_ccb_retry
label|:
name|poll_count
operator|++
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|,
name|ARCMSR_DOORBELL_INT_CLEAR_PATTERN
argument_list|)
expr_stmt|;
comment|/* clear doorbell interrupt */
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|index
operator|=
name|phbbmu
operator|->
name|doneq_index
expr_stmt|;
if|if
condition|(
operator|(
name|flag_srb
operator|=
name|phbbmu
operator|->
name|done_qbuffer
index|[
name|index
index|]
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|poll_srb_done
condition|)
block|{
break|break;
comment|/*chip FIFO no ccb for completion already*/
block|}
else|else
block|{
name|UDELAY
argument_list|(
literal|25000
argument_list|)
expr_stmt|;
if|if
condition|(
name|poll_count
operator|>
literal|100
condition|)
block|{
break|break;
block|}
goto|goto
name|polling_ccb_retry
goto|;
block|}
block|}
name|phbbmu
operator|->
name|done_qbuffer
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|index
operator|++
expr_stmt|;
name|index
operator|%=
name|ARCMSR_MAX_HBB_POSTQUEUE
expr_stmt|;
comment|/*if last index number set it to 0 */
name|phbbmu
operator|->
name|doneq_index
operator|=
name|index
expr_stmt|;
comment|/* check if command done with no error*/
name|srb
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
operator|(
name|acb
operator|->
name|vir2phy_offset
operator|+
operator|(
name|flag_srb
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
comment|/*frame must be 32 bytes aligned*/
name|poll_srb_done
operator|=
operator|(
name|srb
operator|==
name|poll_srb
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|srb
operator|->
name|acb
operator|!=
name|acb
operator|)
operator|||
operator|(
name|srb
operator|->
name|startdone
operator|!=
name|ARCMSR_SRB_START
operator|)
condition|)
block|{
if|if
condition|(
name|srb
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d srb='%p'"
literal|"poll command abort successfully \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|srb
argument_list|)
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"arcmsr%d: polling get an illegal srb command done srb='%p'"
literal|"srboutstandingcount=%d \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
argument_list|,
name|acb
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|arcmsr_report_srb_state
argument_list|(
name|acb
argument_list|,
name|srb
argument_list|,
name|flag_srb
argument_list|)
expr_stmt|;
block|}
comment|/*drain reply FIFO*/
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_polling_srbdone
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|poll_srb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|arcmsr_polling_hba_srbdone
argument_list|(
name|acb
argument_list|,
name|poll_srb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|arcmsr_polling_hbb_srbdone
argument_list|(
name|acb
argument_list|,
name|poll_srb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_get_hba_config
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|char
modifier|*
name|acb_firm_model
init|=
name|acb
operator|->
name|firm_model
decl_stmt|;
name|char
modifier|*
name|acb_firm_version
init|=
name|acb
operator|->
name|firm_version
decl_stmt|;
name|size_t
name|iop_firm_model
init|=
name|offsetof
argument_list|(
expr|struct
name|HBA_MessageUnit
argument_list|,
name|msgcode_rwbuffer
index|[
literal|15
index|]
argument_list|)
decl_stmt|;
comment|/*firm_model,15,60-67*/
name|size_t
name|iop_firm_version
init|=
name|offsetof
argument_list|(
expr|struct
name|HBA_MessageUnit
argument_list|,
name|msgcode_rwbuffer
index|[
literal|17
index|]
argument_list|)
decl_stmt|;
comment|/*firm_version,17,68-83*/
name|int
name|i
decl_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_GET_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hba_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'get adapter firmware miscellaneous data' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|8
condition|)
block|{
operator|*
name|acb_firm_model
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|0
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
argument_list|,
name|iop_firm_model
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 8 bytes firm_model, 15, 60-67*/
name|acb_firm_model
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|16
condition|)
block|{
operator|*
name|acb_firm_version
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|0
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
argument_list|,
name|iop_firm_version
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 16 bytes firm_version, 17, 68-83*/
name|acb_firm_version
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: %s \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: FIRMWARE VERSION %s \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|acb
operator|->
name|firm_version
argument_list|)
expr_stmt|;
name|acb
operator|->
name|firm_request_len
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*firm_request_len, 1, 04-07*/
name|acb
operator|->
name|firm_numbers_queue
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/*firm_numbers_queue, 2, 08-11*/
name|acb
operator|->
name|firm_sdram_size
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/*firm_sdram_size, 3, 12-15*/
name|acb
operator|->
name|firm_ide_channels
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/*firm_ide_channels, 4, 16-19*/
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_get_hbb_config
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|char
modifier|*
name|acb_firm_model
init|=
name|acb
operator|->
name|firm_model
decl_stmt|;
name|char
modifier|*
name|acb_firm_version
init|=
name|acb
operator|->
name|firm_version
decl_stmt|;
name|size_t
name|iop_firm_model
init|=
name|offsetof
argument_list|(
expr|struct
name|HBB_RWBUFFER
argument_list|,
name|msgcode_rwbuffer
index|[
literal|15
index|]
argument_list|)
decl_stmt|;
comment|/*firm_model,15,60-67*/
name|size_t
name|iop_firm_version
init|=
name|offsetof
argument_list|(
expr|struct
name|HBB_RWBUFFER
argument_list|,
name|msgcode_rwbuffer
index|[
literal|17
index|]
argument_list|)
decl_stmt|;
comment|/*firm_version,17,68-83*/
name|int
name|i
decl_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_GET_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait"
literal|"'get adapter firmware miscellaneous data' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|8
condition|)
block|{
operator|*
name|acb_firm_model
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|1
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|1
index|]
argument_list|,
name|iop_firm_model
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 8 bytes firm_model, 15, 60-67*/
name|acb_firm_model
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|16
condition|)
block|{
operator|*
name|acb_firm_version
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|1
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|1
index|]
argument_list|,
name|iop_firm_version
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 16 bytes firm_version, 17, 68-83*/
name|acb_firm_version
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: %s \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: FIRMWARE VERSION %s \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|acb
operator|->
name|firm_version
argument_list|)
expr_stmt|;
name|acb
operator|->
name|firm_request_len
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*firm_request_len, 1, 04-07*/
name|acb
operator|->
name|firm_numbers_queue
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/*firm_numbers_queue, 2, 08-11*/
name|acb
operator|->
name|firm_sdram_size
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/*firm_sdram_size, 3, 12-15*/
name|acb
operator|->
name|firm_ide_channels
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/*firm_ide_channels, 4, 16-19*/
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_get_firmware_spec
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|arcmsr_get_hba_config
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|arcmsr_get_hbb_config
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_wait_firmware_ready
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|int
name|timeout
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
while|while
condition|(
operator|(
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_msgaddr1
argument_list|)
operator|&
name|ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timeout
operator|++
operator|>
literal|2000
condition|)
comment|/* (2000*15)/1000 = 30 sec */
block|{
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|"timed out waiting for firmware \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|UDELAY
argument_list|(
literal|15000
argument_list|)
expr_stmt|;
comment|/* wait 15 milli-seconds */
block|}
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
while|while
condition|(
operator|(
name|CHIP_REG_READ32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|)
operator|&
name|ARCMSR_MESSAGE_FIRMWARE_OK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timeout
operator|++
operator|>
literal|2000
condition|)
comment|/* (2000*15)/1000 = 30 sec */
block|{
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|" timed out waiting for firmware \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|UDELAY
argument_list|(
literal|15000
argument_list|)
expr_stmt|;
comment|/* wait 15 milli-seconds */
block|}
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_DRV2IOP_END_OF_INTERRUPT
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_clear_doorbell_queue_buffer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
comment|/* empty doorbell Qbuffer if door bell ringed */
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|,
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|)
argument_list|)
expr_stmt|;
comment|/*clear doorbell interrupt */
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|,
name|ARCMSR_MESSAGE_INT_CLEAR_PATTERN
argument_list|)
expr_stmt|;
comment|/*clear interrupt and message state*/
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_DRV2IOP_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/* let IOP know data has been read */
block|}
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_iop_confirm
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|unsigned
name|long
name|srb_phyaddr
decl_stmt|;
name|u_int32_t
name|srb_phyaddr_hi32
decl_stmt|;
comment|/* 	******************************************************************** 	** here we need to tell iop 331 our freesrb.HighPart  	** if freesrb.HighPart is not zero 	******************************************************************** 	*/
name|srb_phyaddr
operator|=
operator|(
name|unsigned
name|long
operator|)
name|acb
operator|->
name|srb_phyaddr
expr_stmt|;
name|srb_phyaddr_hi32
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
operator|(
name|srb_phyaddr
operator|>>
literal|16
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
if|if
condition|(
name|srb_phyaddr_hi32
operator|!=
literal|0
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|0
index|]
argument_list|,
name|ARCMSR_SIGNATURE_SET_CONFIG
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|1
index|]
argument_list|,
name|srb_phyaddr_hi32
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_SET_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hba_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|" 'set srb high part physical address' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
break|break;
comment|/* 		*********************************************************************** 		**    if adapter type B, set window of "post command Q"  		*********************************************************************** 		*/
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|u_int32_t
name|post_queue_phyaddr
decl_stmt|;
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
decl_stmt|;
name|phbbmu
operator|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
expr_stmt|;
name|phbbmu
operator|->
name|postq_index
operator|=
literal|0
expr_stmt|;
name|phbbmu
operator|->
name|doneq_index
operator|=
literal|0
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_SET_POST_WINDOW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|" 'set window of post command Q' timeout\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|post_queue_phyaddr
operator|=
name|srb_phyaddr
operator|+
name|ARCMSR_MAX_FREESRB_NUM
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|CommandControlBlock
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|HBB_MessageUnit
argument_list|,
name|post_qbuffer
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|0
index|]
argument_list|,
name|ARCMSR_SIGNATURE_SET_CONFIG
argument_list|)
expr_stmt|;
comment|/* driver "set config" signature */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|1
index|]
argument_list|,
name|srb_phyaddr_hi32
argument_list|)
expr_stmt|;
comment|/* normal should be zero */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|2
index|]
argument_list|,
name|post_queue_phyaddr
argument_list|)
expr_stmt|;
comment|/* postQ size (256+8)*4 */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|3
index|]
argument_list|,
name|post_queue_phyaddr
operator|+
literal|1056
argument_list|)
expr_stmt|;
comment|/* doneQ size (256+8)*4 */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|4
index|]
argument_list|,
literal|1056
argument_list|)
expr_stmt|;
comment|/* srb maxQ size must be --> [(256+8)*4] */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_SET_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: 'set command Q window' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_START_DRIVER_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: 'start diver mode' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_enable_eoi_mode
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
return|return;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_ACTIVE_EOI_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|" 'iop enable eoi mode' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_init
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|intmask_org
decl_stmt|;
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|arcmsr_disable_allintr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_wait_firmware_ready
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_iop_confirm
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_get_firmware_spec
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/*start background rebuild*/
name|arcmsr_start_adapter_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* empty doorbell Qbuffer if door bell ringed */
name|arcmsr_clear_doorbell_queue_buffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_enable_eoi_mode
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* enable outbound Post Queue, outbound doorbell Interrupt */
name|arcmsr_enable_allintr
argument_list|(
name|acb
argument_list|,
name|intmask_org
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_IOP_INITED
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_map_freesrb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|arg
decl_stmt|;
name|struct
name|CommandControlBlock
modifier|*
name|srb_tmp
decl_stmt|;
name|u_int8_t
modifier|*
name|dma_memptr
decl_stmt|;
name|u_int32_t
name|i
decl_stmt|;
name|unsigned
name|long
name|srb_phyaddr
init|=
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_addr
decl_stmt|;
name|dma_memptr
operator|=
name|acb
operator|->
name|uncacheptr
expr_stmt|;
name|acb
operator|->
name|srb_phyaddr
operator|=
name|srb_phyaddr
expr_stmt|;
name|srb_tmp
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
name|dma_memptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|srb_tmp
operator|->
name|dm_segs_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MAPFREESRB_FAILD
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|" srb dmamap bus_dmamap_create error\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|srb_tmp
operator|->
name|cdb_shifted_phyaddr
operator|=
name|srb_phyaddr
operator|>>
literal|5
expr_stmt|;
name|srb_tmp
operator|->
name|acb
operator|=
name|acb
expr_stmt|;
name|acb
operator|->
name|srbworkingQ
index|[
name|i
index|]
operator|=
name|acb
operator|->
name|psrb_pool
index|[
name|i
index|]
operator|=
name|srb_tmp
expr_stmt|;
name|srb_phyaddr
operator|=
name|srb_phyaddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|CommandControlBlock
argument_list|)
expr_stmt|;
name|srb_tmp
operator|++
expr_stmt|;
block|}
name|acb
operator|->
name|vir2phy_offset
operator|=
operator|(
name|unsigned
name|long
operator|)
name|srb_tmp
operator|-
operator|(
name|unsigned
name|long
operator|)
name|srb_phyaddr
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** ** ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_free_resource
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
comment|/* remove the control device */
if|if
condition|(
name|acb
operator|->
name|ioctl_dev
operator|!=
name|NULL
condition|)
block|{
name|destroy_dev
argument_list|(
name|acb
operator|->
name|ioctl_dev
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_initialize
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int16_t
name|pci_command
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|max_coherent_size
decl_stmt|;
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|PCIDevVenIDARC1201
case|:
block|{
name|acb
operator|->
name|adapter_type
operator|=
name|ACB_ADAPTER_TYPE_B
expr_stmt|;
name|max_coherent_size
operator|=
name|ARCMSR_SRBS_POOL_SIZE
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|HBB_MessageUnit
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|PCIDevVenIDARC1110
case|:
case|case
name|PCIDevVenIDARC1120
case|:
case|case
name|PCIDevVenIDARC1130
case|:
case|case
name|PCIDevVenIDARC1160
case|:
case|case
name|PCIDevVenIDARC1170
case|:
case|case
name|PCIDevVenIDARC1210
case|:
case|case
name|PCIDevVenIDARC1220
case|:
case|case
name|PCIDevVenIDARC1230
case|:
case|case
name|PCIDevVenIDARC1260
case|:
case|case
name|PCIDevVenIDARC1270
case|:
case|case
name|PCIDevVenIDARC1280
case|:
case|case
name|PCIDevVenIDARC1380
case|:
case|case
name|PCIDevVenIDARC1381
case|:
case|case
name|PCIDevVenIDARC1680
case|:
case|case
name|PCIDevVenIDARC1681
case|:
block|{
name|acb
operator|->
name|adapter_type
operator|=
name|ACB_ADAPTER_TYPE_A
expr_stmt|;
name|max_coherent_size
operator|=
name|ARCMSR_SRBS_POOL_SIZE
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|" unknown RAID adapter type \n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502010
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignemnt*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*nsegments*/
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|NULL
argument_list|,
comment|/*lockarg*/
name|NULL
argument_list|,
operator|&
name|acb
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignemnt*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*nsegments*/
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|acb
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|printf
argument_list|(
literal|"arcmsr%d: parent_dmat bus_dma_tag_create failure!\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* Create a single tag describing a region large enough to hold all of the s/g lists we will need. */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502010
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|acb
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|MAXBSIZE
argument_list|,
comment|/*nsegments*/
name|ARCMSR_MAX_SG_ENTRIES
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|,
operator|&
name|acb
operator|->
name|dm_segs_dmat
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|acb
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|MAXBSIZE
argument_list|,
comment|/*nsegments*/
name|ARCMSR_MAX_SG_ENTRIES
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|acb
operator|->
name|dm_segs_dmat
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: dm_segs_dmat bus_dma_tag_create failure!\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* DMA tag for our srb structures.... Allocate the freesrb memory */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502010
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|acb
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|0x20
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|max_coherent_size
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|NULL
argument_list|,
comment|/*lockarg*/
name|NULL
argument_list|,
operator|&
name|acb
operator|->
name|srb_dmat
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|acb
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|0x20
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|max_coherent_size
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|acb
operator|->
name|srb_dmat
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: srb_dmat bus_dma_tag_create failure!\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Allocation for our srbs */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|acb
operator|->
name|uncacheptr
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|acb
operator|->
name|srb_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: srb_dmat bus_dmamem_alloc failure!\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* And permanently map them */
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|acb
operator|->
name|uncacheptr
argument_list|,
name|max_coherent_size
argument_list|,
name|arcmsr_map_freesrb
argument_list|,
name|acb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: srb_dmat bus_dmamap_load failure!\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|pci_command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_command
operator||=
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_command
operator||=
name|PCIM_CMD_PERRESPEN
expr_stmt|;
name|pci_command
operator||=
name|PCIM_CMD_MWRICEN
expr_stmt|;
comment|/* Enable Busmaster/Mem */
name|pci_command
operator||=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|pci_command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|u_int32_t
name|rid0
init|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|vm_offset_t
name|mem_base0
decl_stmt|;
name|acb
operator|->
name|sys_res_arcmsr
index|[
literal|0
index|]
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid0
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|0x1000
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|acb
operator|->
name|sys_res_arcmsr
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|" bus_alloc_resource failure!\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
name|rman_get_start
argument_list|(
name|acb
operator|->
name|sys_res_arcmsr
index|[
literal|0
index|]
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|" rman_get_start failure!\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|mem_base0
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|acb
operator|->
name|sys_res_arcmsr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_base0
operator|==
literal|0
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|" rman_get_virtual failure!\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|acb
operator|->
name|btag
index|[
literal|0
index|]
operator|=
name|rman_get_bustag
argument_list|(
name|acb
operator|->
name|sys_res_arcmsr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
operator|=
name|rman_get_bushandle
argument_list|(
name|acb
operator|->
name|sys_res_arcmsr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|acb
operator|->
name|pmu
operator|=
operator|(
expr|struct
name|MessageUnit_UNION
operator|*
operator|)
name|mem_base0
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
decl_stmt|;
name|struct
name|CommandControlBlock
modifier|*
name|freesrb
decl_stmt|;
name|u_int32_t
name|rid
index|[]
init|=
block|{
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
block|,
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
block|}
decl_stmt|;
name|vm_offset_t
name|mem_base
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|acb
operator|->
name|sys_res_arcmsr
index|[
name|i
index|]
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
index|[
name|i
index|]
argument_list|,
literal|0x20400
argument_list|,
literal|0x20400
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|HBB_DOORBELL
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|HBB_DOORBELL
argument_list|)
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|acb
operator|->
name|sys_res_arcmsr
index|[
name|i
index|]
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
index|[
name|i
index|]
argument_list|,
literal|0x0fa00
argument_list|,
literal|0x0fa00
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|HBB_RWBUFFER
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|HBB_RWBUFFER
argument_list|)
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acb
operator|->
name|sys_res_arcmsr
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|" bus_alloc_resource %d failure!\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
name|rman_get_start
argument_list|(
name|acb
operator|->
name|sys_res_arcmsr
index|[
name|i
index|]
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|" rman_get_start %d failure!\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|mem_base
index|[
name|i
index|]
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|acb
operator|->
name|sys_res_arcmsr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_base
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|" rman_get_virtual %d failure!\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|acb
operator|->
name|btag
index|[
name|i
index|]
operator|=
name|rman_get_bustag
argument_list|(
name|acb
operator|->
name|sys_res_arcmsr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|acb
operator|->
name|bhandle
index|[
name|i
index|]
operator|=
name|rman_get_bushandle
argument_list|(
name|acb
operator|->
name|sys_res_arcmsr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|freesrb
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
name|acb
operator|->
name|uncacheptr
expr_stmt|;
name|acb
operator|->
name|pmu
operator|=
operator|(
expr|struct
name|MessageUnit_UNION
operator|*
operator|)
operator|&
name|freesrb
index|[
name|ARCMSR_MAX_FREESRB_NUM
index|]
expr_stmt|;
name|phbbmu
operator|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
expr_stmt|;
name|phbbmu
operator|->
name|hbb_doorbell
operator|=
operator|(
expr|struct
name|HBB_DOORBELL
operator|*
operator|)
name|mem_base
index|[
literal|0
index|]
expr_stmt|;
name|phbbmu
operator|->
name|hbb_rwbuffer
operator|=
operator|(
expr|struct
name|HBB_RWBUFFER
operator|*
operator|)
name|mem_base
index|[
literal|1
index|]
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MAPFREESRB_FAILD
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: map free srb failure!\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|acb
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_RQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_WQBUFFER_READ
operator|)
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_SCSISTOPADAPTER
expr_stmt|;
comment|/* 	******************************************************************** 	** init raid volume state 	******************************************************************** 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_TARGETID
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARCMSR_MAX_TARGETLUN
condition|;
name|j
operator|++
control|)
block|{
name|acb
operator|->
name|devstate
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
block|}
block|}
name|arcmsr_iop_init
argument_list|(
name|acb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
comment|/* Device Queue to use for this SIM */
name|struct
name|resource
modifier|*
name|irqres
decl_stmt|;
name|int
name|rid
decl_stmt|;
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: cannot allocate softc\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ARCMSR_LOCK_INIT
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|,
literal|"arcmsr Q buffer lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_initialize
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: initialize failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_DESTROY
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* After setting up the adapter, map our interrupt */
name|rid
operator|=
literal|0
expr_stmt|;
name|irqres
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|irqres
operator|==
name|NULL
operator|||
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700025
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|irqres
argument_list|,
name|INTR_TYPE_CAM
operator||
name|INTR_ENTROPY
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|arcmsr_intr_handler
argument_list|,
name|acb
argument_list|,
operator|&
name|acb
operator|->
name|ih
argument_list|)
condition|)
block|{
else|#
directive|else
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|irqres
argument_list|,
name|INTR_TYPE_CAM
operator||
name|INTR_ENTROPY
operator||
name|INTR_MPSAFE
argument_list|,
name|arcmsr_intr_handler
argument_list|,
name|acb
argument_list|,
operator|&
name|acb
operator|->
name|ih
argument_list|)
block|)
block|{
endif|#
directive|endif
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_DESTROY
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: unable to register interrupt handler!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|acb
operator|->
name|irqres
operator|=
name|irqres
expr_stmt|;
name|acb
operator|->
name|pci_dev
operator|=
name|dev
expr_stmt|;
name|acb
operator|->
name|pci_unit
operator|=
name|unit
expr_stmt|;
comment|/* 	 * Now let the CAM generic SCSI layer find the SCSI devices on 	 * the bus *  start queue to reset to the idle loop. * 	 * Create device queue of SIM(s) *  (MAX_START_JOB - 1) : 	 * max_sim_transactions 	*/
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|ARCMSR_MAX_START_JOB
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_DESTROY
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: cam_simq_alloc failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700025
name|acb
operator|->
name|psim
operator|=
name|cam_sim_alloc
argument_list|(
name|arcmsr_action
argument_list|,
name|arcmsr_poll
argument_list|,
literal|"arcmsr"
argument_list|,
name|acb
argument_list|,
name|unit
argument_list|,
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|,
literal|1
argument_list|,
name|ARCMSR_MAX_OUTSTANDING_CMD
argument_list|,
name|devq
argument_list|)
expr_stmt|;
else|#
directive|else
name|acb
operator|->
name|psim
operator|=
name|cam_sim_alloc
argument_list|(
name|arcmsr_action
argument_list|,
name|arcmsr_poll
argument_list|,
literal|"arcmsr"
argument_list|,
name|acb
argument_list|,
name|unit
argument_list|,
literal|1
argument_list|,
name|ARCMSR_MAX_OUTSTANDING_CMD
argument_list|,
name|devq
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|acb
operator|->
name|psim
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_DESTROY
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: cam_sim_alloc failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700044
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
endif|#
directive|endif
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_DESTROY
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: xpt_bus_register failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|acb
operator|->
name|ppath
argument_list|,
comment|/* periph */
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|acb
operator|->
name|psim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|acb
operator|->
name|psim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
comment|/* free_simq */
name|TRUE
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_DESTROY
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: xpt_create_path failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* 	**************************************************** 	*/
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|acb
operator|->
name|ppath
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
operator||
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|arcmsr_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|acb
operator|->
name|psim
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
comment|/* Create the control device.  */
name|acb
operator|->
name|ioctl_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|arcmsr_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
comment|/* GID_OPERATOR */
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|,
literal|"arcmsr%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|acb
operator|->
name|ioctl_dev
operator|->
name|si_drv1
operator|=
name|acb
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500005
operator|(
name|void
operator|)
name|make_dev_alias
argument_list|(
name|acb
operator|->
name|ioctl_dev
argument_list|,
literal|"arc%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* ************************************************************************ ************************************************************************ */
specifier|static
name|u_int32_t
name|arcmsr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|id
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|raid6
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_VENDOR_ID_ARECA
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
switch|switch
condition|(
name|id
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|PCIDevVenIDARC1110
case|:
case|case
name|PCIDevVenIDARC1210
case|:
case|case
name|PCIDevVenIDARC1201
case|:
name|raid6
operator|=
literal|0
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|PCIDevVenIDARC1120
case|:
case|case
name|PCIDevVenIDARC1130
case|:
case|case
name|PCIDevVenIDARC1160
case|:
case|case
name|PCIDevVenIDARC1170
case|:
case|case
name|PCIDevVenIDARC1220
case|:
case|case
name|PCIDevVenIDARC1230
case|:
case|case
name|PCIDevVenIDARC1260
case|:
case|case
name|PCIDevVenIDARC1270
case|:
case|case
name|PCIDevVenIDARC1280
case|:
name|type
operator|=
literal|"SATA"
expr_stmt|;
break|break;
case|case
name|PCIDevVenIDARC1380
case|:
case|case
name|PCIDevVenIDARC1381
case|:
case|case
name|PCIDevVenIDARC1680
case|:
case|case
name|PCIDevVenIDARC1681
case|:
name|type
operator|=
literal|"SAS"
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"X-TYPE"
expr_stmt|;
break|break;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Areca %s Host Adapter RAID Controller %s\n"
argument_list|,
name|type
argument_list|,
name|raid6
condition|?
literal|"(RAID6 capable)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ************************************************************************ ************************************************************************ */
specifier|static
name|void
name|arcmsr_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|i
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|;
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* stop adapter background rebuild */
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|arcmsr_disable_allintr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_stop_adapter_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_flush_adapter_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* abort all outstanding command */
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_SCSISTOPADAPTER
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOP_INITED
expr_stmt|;
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
comment|/*clear and abort all outbound posted Q*/
name|arcmsr_done4abort_postqueue
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* talk to iop 331 outstanding command aborted*/
name|arcmsr_abort_allcmd
argument_list|(
name|acb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|srb
operator|=
name|acb
operator|->
name|psrb_pool
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|srb
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
name|srb
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|atomic_set_int
argument_list|(
operator|&
name|acb
operator|->
name|srboutstandingcount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|acb
operator|->
name|workingsrb_doneindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|workingsrb_startindex
operator|=
literal|0
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ************************************************************************ ************************************************************************ */
specifier|static
name|u_int32_t
name|arcmsr_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|acb
operator|->
name|irqres
argument_list|,
name|acb
operator|->
name|ih
argument_list|)
expr_stmt|;
name|arcmsr_shutdown
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|acb
operator|->
name|sys_res_arcmsr
index|[
name|i
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|i
operator|<
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
argument_list|,
name|acb
operator|->
name|sys_res_arcmsr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|acb
operator|->
name|ppath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|acb
operator|->
name|ppath
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|acb
operator|->
name|psim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_DESTROY
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

