begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ******************************************************************************** **        OS    : FreeBSD **   FILE NAME  : arcmsr.c **        BY    : Erich Chen, Ching Huang **   Description: SCSI RAID Device Driver for  **                ARECA (ARC11XX/ARC12XX/ARC13XX/ARC16XX/ARC188x) **                SATA/SAS RAID HOST Adapter ******************************************************************************** ******************************************************************************** ** ** Copyright (C) 2002 - 2012, Areca Technology Corporation All rights reserved. ** ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** 3. The name of the author may not be used to endorse or promote products **    derived from this software without specific prior written permission. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR ** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  ** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT ** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT **(INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF ** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************** ** History ** **    REV#         DATE         NAME        DESCRIPTION ** 1.00.00.00   03/31/2004  Erich Chen      First release ** 1.20.00.02   11/29/2004  Erich Chen      bug fix with arcmsr_bus_reset when PHY error ** 1.20.00.03   04/19/2005  Erich Chen      add SATA 24 Ports adapter type support **                                          clean unused function ** 1.20.00.12   09/12/2005  Erich Chen      bug fix with abort command handling,  **                                          firmware version check  **                                          and firmware update notify for hardware bug fix **                                          handling if none zero high part physical address  **                                          of srb resource  ** 1.20.00.13   08/18/2006  Erich Chen      remove pending srb and report busy **                                          add iop message xfer  **                                          with scsi pass-through command **                                          add new device id of sas raid adapters  **                                          code fit for SPARC64& PPC  ** 1.20.00.14   02/05/2007  Erich Chen      bug fix for incorrect ccb_h.status report **                                          and cause g_vfs_done() read write error ** 1.20.00.15   10/10/2007  Erich Chen      support new RAID adapter type ARC120x ** 1.20.00.16   10/10/2009  Erich Chen      Bug fix for RAID adapter type ARC120x **                                          bus_dmamem_alloc() with BUS_DMA_ZERO ** 1.20.00.17   07/15/2010  Ching Huang     Added support ARC1880 **                                          report CAM_DEV_NOT_THERE instead of CAM_SEL_TIMEOUT when device failed, **                                          prevent cam_periph_error removing all LUN devices of one Target id **                                          for any one LUN device failed ** 1.20.00.18   10/14/2010  Ching Huang     Fixed "inquiry data fails comparion at DV1 step" **              10/25/2010  Ching Huang     Fixed bad range input in bus_alloc_resource for ADAPTER_TYPE_B ** 1.20.00.19   11/11/2010  Ching Huang     Fixed arcmsr driver prevent arcsas support for Areca SAS HBA ARC13x0 ** 1.20.00.20   12/08/2010  Ching Huang     Avoid calling atomic_set_int function ** 1.20.00.21   02/08/2011  Ching Huang     Implement I/O request timeout **              02/14/2011  Ching Huang     Modified pktRequestCount ** 1.20.00.21   03/03/2011  Ching Huang     if a command timeout, then wait its ccb back before free it ** 1.20.00.22   07/04/2011  Ching Huang     Fixed multiple MTX panic ** 1.20.00.23   10/28/2011  Ching Huang     Added TIMEOUT_DELAY in case of too many HDDs need to start  ** 1.20.00.23   11/08/2011  Ching Huang     Added report device transfer speed  ** 1.20.00.23   01/30/2012  Ching Huang     Fixed Request requeued and Retrying command ** 1.20.00.24   06/11/2012  Ching Huang     Fixed return sense data condition ** 1.20.00.25   08/17/2012  Ching Huang     Fixed hotplug device no function on type A adapter ** 1.20.00.26   12/14/2012  Ching Huang     Added support ARC1214,1224,1264,1284 ** 1.20.00.27   05/06/2013  Ching Huang     Fixed out standing cmd full on ARC-12x4 ****************************************************************************************** */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|ARCMSR_DEBUG1
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<isa/rtc.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500005
end_if

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CAM_NEW_TRAN_CODE
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|700025
end_if

begin_define
define|#
directive|define
name|CAM_NEW_TRAN_CODE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500000
end_if

begin_define
define|#
directive|define
name|arcmsr_callout_init
parameter_list|(
name|a
parameter_list|)
value|callout_init(a,
comment|/*mpsafe*/
value|1);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|arcmsr_callout_init
parameter_list|(
name|a
parameter_list|)
value|callout_init(a);
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ARCMSR_DRIVER_VERSION
value|"Driver Version 1.20.00.27 2013-05-06"
end_define

begin_include
include|#
directive|include
file|<dev/arcmsr/arcmsr.h>
end_include

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function_decl
specifier|static
name|void
name|arcmsr_free_srb
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|CommandControlBlock
modifier|*
name|arcmsr_get_freesrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|arcmsr_seek_cmd2abort
parameter_list|(
name|union
name|ccb
modifier|*
name|abortccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|arcmsr_iop_ioctlcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|u_int32_t
name|ioctl_cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_iop_parking
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_interrupt
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_polling_srbdone
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|poll_srb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_free_resource
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_bus_reset
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_stop_adapter_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_start_adapter_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_iop_init
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_flush_adapter_cache
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|arcmsr_Read_iop_rqbuffer_data
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|QBUFFER
modifier|*
name|prbuffer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_Write_data_2iop_wqbuffer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_abort_allcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_srb_complete
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|,
name|int
name|stand_flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_iop_reset
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_report_sense_info
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_build_srb
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|u_int32_t
name|nseg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_iop_message_xfer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_rescanLun_cb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_polling_devmap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_srb_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_hbd_postqueue_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ARCMSR_DEBUG1
end_ifdef

begin_function_decl
specifier|static
name|void
name|arcmsr_dump_data
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|UDELAY
parameter_list|(
name|u_int32_t
name|us
parameter_list|)
block|{
name|DELAY
argument_list|(
name|us
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|arcmsr_map_free_srb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|arcmsr_execute_srb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|arcmsr_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|arcmsr_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|arcmsr_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|arcmsr_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|arcmsr_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|arcmsr_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|arcmsr_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|arcmsr_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|arcmsr_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|arcmsr_resume
argument_list|)
block|,
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|803000
name|DEVMETHOD_END
else|#
directive|else
block|{
literal|0
block|,
literal|0
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|arcmsr_driver
init|=
block|{
literal|"arcmsr"
block|,
name|arcmsr_methods
block|,
expr|sizeof
operator|(
expr|struct
name|AdapterControlBlock
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|arcmsr_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|arcmsr
argument_list|,
name|pci
argument_list|,
name|arcmsr_driver
argument_list|,
name|arcmsr_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|arcmsr
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|arcmsr
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BUS_DMA_COHERENT
end_ifndef

begin_define
define|#
directive|define
name|BUS_DMA_COHERENT
value|0x04
end_define

begin_comment
comment|/* hint: map memory in a coherent way */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|501000
end_if

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|arcmsr_cdevsw
init|=
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|503000
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
endif|#
directive|endif
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|503000
operator|&&
name|__FreeBSD_version
operator|<
literal|600034
operator|)
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
endif|#
directive|endif
operator|.
name|d_open
operator|=
name|arcmsr_open
block|,
comment|/* open     */
operator|.
name|d_close
operator|=
name|arcmsr_close
block|,
comment|/* close    */
operator|.
name|d_ioctl
operator|=
name|arcmsr_ioctl
block|,
comment|/* ioctl    */
operator|.
name|d_name
operator|=
literal|"arcmsr"
block|,
comment|/* name     */
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ARCMSR_CDEV_MAJOR
value|180
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|arcmsr_cdevsw
init|=
block|{
name|arcmsr_open
block|,
comment|/* open     */
name|arcmsr_close
block|,
comment|/* close    */
name|noread
block|,
comment|/* read     */
name|nowrite
block|,
comment|/* write    */
name|arcmsr_ioctl
block|,
comment|/* ioctl    */
name|nopoll
block|,
comment|/* poll     */
name|nommap
block|,
comment|/* mmap     */
name|nostrategy
block|,
comment|/* strategy */
literal|"arcmsr"
block|,
comment|/* name     */
name|ARCMSR_CDEV_MAJOR
block|,
comment|/* major    */
name|nodump
block|,
comment|/* dump     */
name|nopsize
block|,
comment|/* psize    */
literal|0
comment|/* flags    */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_open
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_open
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_open
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|dev2unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_close
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|dev2unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_ioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_ioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_ioctl
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|dev2unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
return|return
operator|(
name|arcmsr_iop_ioctlcmd
argument_list|(
name|acb
argument_list|,
name|ioctl_cmd
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_disable_allintr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|intmask_org
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intmask
argument_list|)
expr_stmt|;
comment|/* disable outbound message0 int */
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intmask
argument_list|,
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell_mask
argument_list|)
operator|&
operator|(
operator|~
name|ARCMSR_IOP2DRV_MESSAGE_CMD_DONE
operator|)
expr_stmt|;
comment|/* disable outbound message0 int */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable all interrupt */
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|host_int_mask
argument_list|)
expr_stmt|;
comment|/* disable outbound message0 int */
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|host_int_mask
argument_list|,
name|intmask_org
operator||
name|ARCMSR_HBCMU_ALL_INTMASKENABLE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|pcief0_int_enable
argument_list|)
expr_stmt|;
comment|/* disable outbound message0 int */
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|pcief0_int_enable
argument_list|,
name|ARCMSR_HBDMU_ALL_INT_DISABLE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|intmask_org
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_enable_allintr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|u_int32_t
name|intmask_org
parameter_list|)
block|{
name|u_int32_t
name|mask
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
comment|/* enable outbound Post Queue, outbound doorbell Interrupt */
name|mask
operator|=
operator|~
operator|(
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE
operator|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intmask
argument_list|,
name|intmask_org
operator|&
name|mask
argument_list|)
expr_stmt|;
name|acb
operator|->
name|outbound_int_enable
operator|=
operator|~
operator|(
name|intmask_org
operator|&
name|mask
operator|)
operator|&
literal|0x000000ff
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
comment|/* enable ARCMSR_IOP2DRV_MESSAGE_CMD_DONE */
name|mask
operator|=
operator|(
name|ARCMSR_IOP2DRV_DATA_WRITE_OK
operator||
name|ARCMSR_IOP2DRV_DATA_READ_OK
operator||
name|ARCMSR_IOP2DRV_CDB_DONE
operator||
name|ARCMSR_IOP2DRV_MESSAGE_CMD_DONE
operator|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell_mask
argument_list|,
name|intmask_org
operator||
name|mask
argument_list|)
expr_stmt|;
comment|/*1=interrupt enable, 0=interrupt disable*/
name|acb
operator|->
name|outbound_int_enable
operator|=
operator|(
name|intmask_org
operator||
name|mask
operator|)
operator|&
literal|0x0000000f
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
comment|/* enable outbound Post Queue, outbound doorbell Interrupt */
name|mask
operator|=
operator|~
operator|(
name|ARCMSR_HBCMU_UTILITY_A_ISR_MASK
operator||
name|ARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR_MASK
operator||
name|ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR_MASK
operator|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|host_int_mask
argument_list|,
name|intmask_org
operator|&
name|mask
argument_list|)
expr_stmt|;
name|acb
operator|->
name|outbound_int_enable
operator|=
operator|~
operator|(
name|intmask_org
operator|&
name|mask
operator|)
operator|&
literal|0x0000000f
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
comment|/* enable outbound Post Queue, outbound doorbell Interrupt */
name|mask
operator|=
name|ARCMSR_HBDMU_ALL_INT_ENABLE
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|pcief0_int_enable
argument_list|,
name|intmask_org
operator||
name|mask
argument_list|)
expr_stmt|;
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|pcief0_int_enable
argument_list|)
expr_stmt|;
name|acb
operator|->
name|outbound_int_enable
operator|=
name|mask
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|u_int8_t
name|arcmsr_hba_wait_msgint_ready
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|Index
decl_stmt|;
name|u_int8_t
name|Retries
init|=
literal|0x00
decl_stmt|;
do|do
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
literal|100
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|)
operator|&
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INT
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|,
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INT
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
return|return
name|TRUE
return|;
block|}
name|UDELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
comment|/*max 1 seconds*/
block|}
do|while
condition|(
name|Retries
operator|++
operator|<
literal|20
condition|)
do|;
comment|/*max 20 sec*/
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|u_int8_t
name|arcmsr_hbb_wait_msgint_ready
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|Index
decl_stmt|;
name|u_int8_t
name|Retries
init|=
literal|0x00
decl_stmt|;
do|do
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
literal|100
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
name|CHIP_REG_READ32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|)
operator|&
name|ARCMSR_IOP2DRV_MESSAGE_CMD_DONE
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|,
name|ARCMSR_MESSAGE_INT_CLEAR_PATTERN
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_DRV2IOP_END_OF_INTERRUPT
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|UDELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
comment|/*max 1 seconds*/
block|}
do|while
condition|(
name|Retries
operator|++
operator|<
literal|20
condition|)
do|;
comment|/*max 20 sec*/
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|u_int8_t
name|arcmsr_hbc_wait_msgint_ready
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|Index
decl_stmt|;
name|u_int8_t
name|Retries
init|=
literal|0x00
decl_stmt|;
do|do
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
literal|100
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|)
operator|&
name|ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell_clear
argument_list|,
name|ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
return|return
name|TRUE
return|;
block|}
name|UDELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
comment|/*max 1 seconds*/
block|}
do|while
condition|(
name|Retries
operator|++
operator|<
literal|20
condition|)
do|;
comment|/*max 20 sec*/
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|u_int8_t
name|arcmsr_hbd_wait_msgint_ready
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|Index
decl_stmt|;
name|u_int8_t
name|Retries
init|=
literal|0x00
decl_stmt|;
do|do
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
literal|100
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|)
operator|&
name|ARCMSR_HBDMU_IOP2DRV_MESSAGE_CMD_DONE
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|,
name|ARCMSR_HBDMU_IOP2DRV_MESSAGE_CMD_DONE_CLEAR
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
return|return
name|TRUE
return|;
block|}
name|UDELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
comment|/*max 1 seconds*/
block|}
do|while
condition|(
name|Retries
operator|++
operator|<
literal|20
condition|)
do|;
comment|/*max 20 sec*/
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_flush_hba_cache
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|int
name|retry_count
init|=
literal|30
decl_stmt|;
comment|/* enlarge wait flush adapter cache time: 10 minute */
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_FLUSH_CACHE
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|arcmsr_hba_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|retry_count
operator|--
expr_stmt|;
block|}
block|}
do|while
condition|(
name|retry_count
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_flush_hbb_cache
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|int
name|retry_count
init|=
literal|30
decl_stmt|;
comment|/* enlarge wait flush adapter cache time: 10 minute */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_FLUSH_CACHE
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|retry_count
operator|--
expr_stmt|;
block|}
block|}
do|while
condition|(
name|retry_count
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_flush_hbc_cache
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|int
name|retry_count
init|=
literal|30
decl_stmt|;
comment|/* enlarge wait flush adapter cache time: 10 minute */
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_FLUSH_CACHE
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|arcmsr_hbc_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|retry_count
operator|--
expr_stmt|;
block|}
block|}
do|while
condition|(
name|retry_count
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_flush_hbd_cache
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|int
name|retry_count
init|=
literal|30
decl_stmt|;
comment|/* enlarge wait flush adapter cache time: 10 minute */
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_FLUSH_CACHE
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|arcmsr_hbd_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|retry_count
operator|--
expr_stmt|;
block|}
block|}
do|while
condition|(
name|retry_count
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_flush_adapter_cache
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|arcmsr_flush_hba_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|arcmsr_flush_hbb_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
name|arcmsr_flush_hbc_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
name|arcmsr_flush_hbd_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ******************************************************************************* ******************************************************************************* */
end_comment

begin_function
specifier|static
name|int
name|arcmsr_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* flush controller */
name|arcmsr_iop_parking
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* disable all outbound interrupt */
name|arcmsr_disable_allintr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ******************************************************************************* ******************************************************************************* */
end_comment

begin_function
specifier|static
name|int
name|arcmsr_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|arcmsr_iop_init
argument_list|(
name|acb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************************* ********************************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_async
parameter_list|(
name|void
modifier|*
name|cb_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
decl_stmt|;
name|u_int8_t
name|target_id
decl_stmt|,
name|target_lun
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|cb_arg
expr_stmt|;
name|acb
operator|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_LOST_DEVICE
case|:
name|target_id
operator|=
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|target_lun
operator|=
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target_id
operator|>
name|ARCMSR_MAX_TARGETID
operator|)
operator|||
operator|(
name|target_lun
operator|>
name|ARCMSR_MAX_TARGETLUN
operator|)
condition|)
block|{
break|break;
block|}
comment|//	printf("%s:scsi id=%d lun=%d device lost \n", device_get_name(acb->pci_dev), target_id, target_lun);
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_report_sense_info
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|pccb
init|=
name|srb
operator|->
name|pccb
decl_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|pccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
if|if
condition|(
name|pccb
operator|->
name|csio
operator|.
name|sense_len
condition|)
block|{
name|memset
argument_list|(
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|srb
operator|->
name|arcmsr_cdb
operator|.
name|SenseData
argument_list|,
name|get_min
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|SENSE_DATA
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|0
index|]
operator|=
operator|(
literal|0x1
operator|<<
literal|7
operator||
literal|0x70
operator|)
expr_stmt|;
comment|/* Valid,ErrorCode */
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************* ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_abort_hba_allcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_ABORT_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hba_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'abort all outstanding command' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************* ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_abort_hbb_allcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_ABORT_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'abort all outstanding command' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************* ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_abort_hbc_allcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_ABORT_CMD
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbc_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'abort all outstanding command' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************* ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_abort_hbd_allcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_ABORT_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbd_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'abort all outstanding command' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************* ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_abort_allcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|arcmsr_abort_hba_allcmd
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|arcmsr_abort_hbb_allcmd
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
name|arcmsr_abort_hbc_allcmd
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
name|arcmsr_abort_hbd_allcmd
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_srb_complete
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|,
name|int
name|stand_flag
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|srb
operator|->
name|acb
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
init|=
name|srb
operator|->
name|pccb
decl_stmt|;
if|if
condition|(
name|srb
operator|->
name|srb_flags
operator|&
name|SRB_FLAG_TIMER_START
condition|)
name|callout_stop
argument_list|(
operator|&
name|srb
operator|->
name|ccb_callout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stand_flag
operator|==
literal|1
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|acb
operator|->
name|srboutstandingcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_CAM_DEV_QFRZN
operator|)
operator|&&
operator|(
name|acb
operator|->
name|srboutstandingcount
operator|<
operator|(
name|acb
operator|->
name|maxOutstanding
operator|-
literal|10
operator|)
operator|)
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_CAM_DEV_QFRZN
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
block|}
if|if
condition|(
name|srb
operator|->
name|srb_state
operator|!=
name|ARCMSR_SRB_TIMEOUT
condition|)
name|arcmsr_free_srb
argument_list|(
name|srb
argument_list|)
expr_stmt|;
name|acb
operator|->
name|pktReturnCount
operator|++
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_report_srb_state
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|,
name|u_int16_t
name|error
parameter_list|)
block|{
name|int
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|target
operator|=
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|ARECA_RAID_GONE
condition|)
block|{
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
block|}
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|srb
operator|->
name|arcmsr_cdb
operator|.
name|DeviceStatus
condition|)
block|{
case|case
name|ARCMSR_DEV_SELECT_TIMEOUT
case|:
block|{
if|if
condition|(
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|ARECA_RAID_GOOD
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: Target=%x, Lun=%x, selection timeout, raid volume was lost\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
block|}
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_DEV_ABORTED
case|:
case|case
name|ARCMSR_DEV_INIT_FAIL
case|:
block|{
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCSISTAT_CHECK_CONDITION
case|:
block|{
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
name|arcmsr_report_sense_info
argument_list|(
name|srb
argument_list|)
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d isr got command error done,but got unknow DeviceStatus=0x%x \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|srb
operator|->
name|arcmsr_cdb
operator|.
name|DeviceStatus
argument_list|)
expr_stmt|;
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_UNCOR_PARITY
expr_stmt|;
comment|/*unknow error or crc error just for retry*/
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_drain_donequeue
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|u_int32_t
name|flag_srb
parameter_list|,
name|u_int16_t
name|error
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
comment|/* check if command done with no error*/
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_C
case|:
case|case
name|ACB_ADAPTER_TYPE_D
case|:
name|srb
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
operator|(
name|acb
operator|->
name|vir2phy_offset
operator|+
operator|(
name|flag_srb
operator|&
literal|0xFFFFFFE0
operator|)
operator|)
expr_stmt|;
comment|/*frame must be 32 bytes aligned*/
break|break;
case|case
name|ACB_ADAPTER_TYPE_A
case|:
case|case
name|ACB_ADAPTER_TYPE_B
case|:
default|default:
name|srb
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
operator|(
name|acb
operator|->
name|vir2phy_offset
operator|+
operator|(
name|flag_srb
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
comment|/*frame must be 32 bytes aligned*/
break|break;
block|}
if|if
condition|(
operator|(
name|srb
operator|->
name|acb
operator|!=
name|acb
operator|)
operator|||
operator|(
name|srb
operator|->
name|srb_state
operator|!=
name|ARCMSR_SRB_START
operator|)
condition|)
block|{
if|if
condition|(
name|srb
operator|->
name|srb_state
operator|==
name|ARCMSR_SRB_TIMEOUT
condition|)
block|{
name|arcmsr_free_srb
argument_list|(
name|srb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: srb='%p' return srb has been timeouted\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"arcmsr%d: return srb has been completed\n"
literal|"srb='%p' srb_state=0x%x outstanding srb count=%d \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
argument_list|,
name|srb
operator|->
name|srb_state
argument_list|,
name|acb
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
return|return;
block|}
name|arcmsr_report_srb_state
argument_list|(
name|acb
argument_list|,
name|srb
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_srb_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
init|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
decl_stmt|;
name|int
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|u_int8_t
name|cmd
decl_stmt|;
name|target
operator|=
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|acb
operator|=
name|srb
operator|->
name|acb
expr_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|srb
operator|->
name|srb_state
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
name|cmd
operator|=
name|srb
operator|->
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
expr_stmt|;
name|srb
operator|->
name|srb_state
operator|=
name|ARCMSR_SRB_TIMEOUT
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: scsi id %d lun %d cmd=0x%x srb='%p' ccb command time out!\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|cmd
argument_list|,
name|srb
argument_list|)
expr_stmt|;
block|}
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARCMSR_DEBUG1
name|arcmsr_dump_data
argument_list|(
name|acb
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_done4abort_postqueue
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|flag_srb
decl_stmt|;
name|u_int16_t
name|error
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|u_int32_t
name|outbound_intstatus
decl_stmt|;
comment|/*clear and abort all outbound posted Q*/
name|outbound_intstatus
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|)
operator|&
name|acb
operator|->
name|outbound_int_enable
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|,
name|outbound_intstatus
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
while|while
condition|(
operator|(
operator|(
name|flag_srb
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_queueport
argument_list|)
operator|)
operator|!=
literal|0xFFFFFFFF
operator|)
operator|&&
operator|(
name|i
operator|++
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
operator|)
condition|)
block|{
name|error
operator|=
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR_MODE0
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|arcmsr_drain_donequeue
argument_list|(
name|acb
argument_list|,
name|flag_srb
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
init|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
comment|/*clear all outbound posted Q*/
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|,
name|ARCMSR_DOORBELL_INT_CLEAR_PATTERN
argument_list|)
expr_stmt|;
comment|/* clear doorbell interrupt */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_HBB_POSTQUEUE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|flag_srb
operator|=
name|phbbmu
operator|->
name|done_qbuffer
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|phbbmu
operator|->
name|done_qbuffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|error
operator|=
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR_MODE0
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|arcmsr_drain_donequeue
argument_list|(
name|acb
argument_list|,
name|flag_srb
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|phbbmu
operator|->
name|post_qbuffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/*drain reply FIFO*/
name|phbbmu
operator|->
name|doneq_index
operator|=
literal|0
expr_stmt|;
name|phbbmu
operator|->
name|postq_index
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
while|while
condition|(
operator|(
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|host_int_status
argument_list|)
operator|&
name|ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR
operator|)
operator|&&
operator|(
name|i
operator|++
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
operator|)
condition|)
block|{
name|flag_srb
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_queueport_low
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR_MODE1
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|arcmsr_drain_donequeue
argument_list|(
name|acb
argument_list|,
name|flag_srb
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
name|arcmsr_hbd_postqueue_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* **************************************************************************** **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_reset
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|;
name|u_int32_t
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|>
literal|0
condition|)
block|{
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|arcmsr_disable_allintr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/*clear and abort all outbound posted Q*/
name|arcmsr_done4abort_postqueue
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* talk to iop 331 outstanding command aborted*/
name|arcmsr_abort_allcmd
argument_list|(
name|acb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|srb
operator|=
name|acb
operator|->
name|psrb_pool
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|srb
operator|->
name|srb_state
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
name|srb
operator|->
name|srb_state
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d srb='%p' aborted\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|srb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* enable all outbound interrupt */
name|arcmsr_enable_allintr
argument_list|(
name|acb
argument_list|,
name|intmask_org
argument_list|)
expr_stmt|;
block|}
name|acb
operator|->
name|srboutstandingcount
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|workingsrb_doneindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|workingsrb_startindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|pktRequestCount
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|pktReturnCount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_build_srb
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|u_int32_t
name|nseg
parameter_list|)
block|{
name|struct
name|ARCMSR_CDB
modifier|*
name|arcmsr_cdb
init|=
operator|&
name|srb
operator|->
name|arcmsr_cdb
decl_stmt|;
name|u_int8_t
modifier|*
name|psge
init|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|arcmsr_cdb
operator|->
name|u
decl_stmt|;
name|u_int32_t
name|address_lo
decl_stmt|,
name|address_hi
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
init|=
name|srb
operator|->
name|pccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|pcsio
init|=
operator|&
name|pccb
operator|->
name|csio
decl_stmt|;
name|u_int32_t
name|arccdbsize
init|=
literal|0x30
decl_stmt|;
name|memset
argument_list|(
name|arcmsr_cdb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ARCMSR_CDB
argument_list|)
argument_list|)
expr_stmt|;
name|arcmsr_cdb
operator|->
name|Bus
operator|=
literal|0
expr_stmt|;
name|arcmsr_cdb
operator|->
name|TargetID
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|arcmsr_cdb
operator|->
name|LUN
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|arcmsr_cdb
operator|->
name|Function
operator|=
literal|1
expr_stmt|;
name|arcmsr_cdb
operator|->
name|CdbLength
operator|=
operator|(
name|u_int8_t
operator|)
name|pcsio
operator|->
name|cdb_len
expr_stmt|;
name|bcopy
argument_list|(
name|pcsio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|arcmsr_cdb
operator|->
name|Cdb
argument_list|,
name|pcsio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|srb
operator|->
name|acb
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|u_int32_t
name|length
decl_stmt|,
name|i
decl_stmt|,
name|cdb_sgcount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|arcmsr_cdb
operator|->
name|Flags
operator||=
name|ARCMSR_CDB_FLAG_WRITE
expr_stmt|;
name|srb
operator|->
name|srb_flags
operator||=
name|SRB_FLAG_WRITE
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get the physical address of the current data pointer */
name|length
operator|=
name|arcmsr_htole32
argument_list|(
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|address_lo
operator|=
name|arcmsr_htole32
argument_list|(
name|dma_addr_lo32
argument_list|(
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|address_hi
operator|=
name|arcmsr_htole32
argument_list|(
name|dma_addr_hi32
argument_list|(
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_hi
operator|==
literal|0
condition|)
block|{
name|struct
name|SG32ENTRY
modifier|*
name|pdma_sg
init|=
operator|(
expr|struct
name|SG32ENTRY
operator|*
operator|)
name|psge
decl_stmt|;
name|pdma_sg
operator|->
name|address
operator|=
name|address_lo
expr_stmt|;
name|pdma_sg
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG32ENTRY
argument_list|)
expr_stmt|;
name|arccdbsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG32ENTRY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|sg64s_size
init|=
literal|0
decl_stmt|,
name|tmplength
init|=
name|length
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|u_int64_t
name|span4G
decl_stmt|,
name|length0
decl_stmt|;
name|struct
name|SG64ENTRY
modifier|*
name|pdma_sg
init|=
operator|(
expr|struct
name|SG64ENTRY
operator|*
operator|)
name|psge
decl_stmt|;
name|span4G
operator|=
operator|(
name|u_int64_t
operator|)
name|address_lo
operator|+
name|tmplength
expr_stmt|;
name|pdma_sg
operator|->
name|addresshigh
operator|=
name|address_hi
expr_stmt|;
name|pdma_sg
operator|->
name|address
operator|=
name|address_lo
expr_stmt|;
if|if
condition|(
name|span4G
operator|>
literal|0x100000000
condition|)
block|{
comment|/*see if cross 4G boundary*/
name|length0
operator|=
literal|0x100000000
operator|-
name|address_lo
expr_stmt|;
name|pdma_sg
operator|->
name|length
operator|=
operator|(
name|u_int32_t
operator|)
name|length0
operator||
name|IS_SG64_ADDR
expr_stmt|;
name|address_hi
operator|=
name|address_hi
operator|+
literal|1
expr_stmt|;
name|address_lo
operator|=
literal|0
expr_stmt|;
name|tmplength
operator|=
name|tmplength
operator|-
operator|(
name|u_int32_t
operator|)
name|length0
expr_stmt|;
name|sg64s_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG64ENTRY
argument_list|)
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG64ENTRY
argument_list|)
expr_stmt|;
name|cdb_sgcount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pdma_sg
operator|->
name|length
operator|=
name|tmplength
operator||
name|IS_SG64_ADDR
expr_stmt|;
name|sg64s_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG64ENTRY
argument_list|)
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|SG64ENTRY
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|arccdbsize
operator|+=
name|sg64s_size
expr_stmt|;
block|}
name|cdb_sgcount
operator|++
expr_stmt|;
block|}
name|arcmsr_cdb
operator|->
name|sgcount
operator|=
operator|(
name|u_int8_t
operator|)
name|cdb_sgcount
expr_stmt|;
name|arcmsr_cdb
operator|->
name|DataLength
operator|=
name|pcsio
operator|->
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|arccdbsize
operator|>
literal|256
condition|)
block|{
name|arcmsr_cdb
operator|->
name|Flags
operator||=
name|ARCMSR_CDB_FLAG_SGL_BSIZE
expr_stmt|;
block|}
block|}
else|else
block|{
name|arcmsr_cdb
operator|->
name|DataLength
operator|=
literal|0
expr_stmt|;
block|}
name|srb
operator|->
name|arc_cdb_size
operator|=
name|arccdbsize
expr_stmt|;
name|arcmsr_cdb
operator|->
name|msgPages
operator|=
operator|(
name|arccdbsize
operator|/
literal|256
operator|)
operator|+
operator|(
operator|(
name|arccdbsize
operator|%
literal|256
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_post_srb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|)
block|{
name|u_int32_t
name|cdb_phyaddr_low
init|=
operator|(
name|u_int32_t
operator|)
name|srb
operator|->
name|cdb_phyaddr_low
decl_stmt|;
name|struct
name|ARCMSR_CDB
modifier|*
name|arcmsr_cdb
init|=
operator|(
expr|struct
name|ARCMSR_CDB
operator|*
operator|)
operator|&
name|srb
operator|->
name|arcmsr_cdb
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
operator|(
name|srb
operator|->
name|srb_flags
operator|&
name|SRB_FLAG_WRITE
operator|)
condition|?
name|BUS_DMASYNC_POSTWRITE
else|:
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|acb
operator|->
name|srboutstandingcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|srb
operator|->
name|srb_state
operator|=
name|ARCMSR_SRB_START
expr_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
if|if
condition|(
name|arcmsr_cdb
operator|->
name|Flags
operator|&
name|ARCMSR_CDB_FLAG_SGL_BSIZE
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_queueport
argument_list|,
name|cdb_phyaddr_low
operator||
name|ARCMSR_SRBPOST_FLAG_SGL_BSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_queueport
argument_list|,
name|cdb_phyaddr_low
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
init|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|int
name|ending_index
decl_stmt|,
name|index
decl_stmt|;
name|index
operator|=
name|phbbmu
operator|->
name|postq_index
expr_stmt|;
name|ending_index
operator|=
operator|(
operator|(
name|index
operator|+
literal|1
operator|)
operator|%
name|ARCMSR_MAX_HBB_POSTQUEUE
operator|)
expr_stmt|;
name|phbbmu
operator|->
name|post_qbuffer
index|[
name|ending_index
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arcmsr_cdb
operator|->
name|Flags
operator|&
name|ARCMSR_CDB_FLAG_SGL_BSIZE
condition|)
block|{
name|phbbmu
operator|->
name|post_qbuffer
index|[
name|index
index|]
operator|=
name|cdb_phyaddr_low
operator||
name|ARCMSR_SRBPOST_FLAG_SGL_BSIZE
expr_stmt|;
block|}
else|else
block|{
name|phbbmu
operator|->
name|post_qbuffer
index|[
name|index
index|]
operator|=
name|cdb_phyaddr_low
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
name|index
operator|%=
name|ARCMSR_MAX_HBB_POSTQUEUE
expr_stmt|;
comment|/*if last index number set it to 0 */
name|phbbmu
operator|->
name|postq_index
operator|=
name|index
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_DRV2IOP_CDB_POSTED
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
name|u_int32_t
name|ccb_post_stamp
decl_stmt|,
name|arc_cdb_size
decl_stmt|,
name|cdb_phyaddr_hi32
decl_stmt|;
name|arc_cdb_size
operator|=
operator|(
name|srb
operator|->
name|arc_cdb_size
operator|>
literal|0x300
operator|)
condition|?
literal|0x300
else|:
name|srb
operator|->
name|arc_cdb_size
expr_stmt|;
name|ccb_post_stamp
operator|=
operator|(
name|cdb_phyaddr_low
operator||
operator|(
operator|(
name|arc_cdb_size
operator|-
literal|1
operator|)
operator|>>
literal|6
operator|)
operator||
literal|1
operator|)
expr_stmt|;
name|cdb_phyaddr_hi32
operator|=
name|acb
operator|->
name|srb_phyaddr
operator|.
name|B
operator|.
name|phyadd_high
expr_stmt|;
if|if
condition|(
name|cdb_phyaddr_hi32
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_queueport_high
argument_list|,
name|cdb_phyaddr_hi32
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_queueport_low
argument_list|,
name|ccb_post_stamp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_queueport_low
argument_list|,
name|ccb_post_stamp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
name|struct
name|HBD_MessageUnit0
modifier|*
name|phbdmu
init|=
operator|(
expr|struct
name|HBD_MessageUnit0
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|u_int16_t
name|index_stripped
decl_stmt|;
name|u_int16_t
name|postq_index
decl_stmt|;
name|struct
name|InBound_SRB
modifier|*
name|pinbound_srb
decl_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|postDone_lock
argument_list|)
expr_stmt|;
name|postq_index
operator|=
name|phbdmu
operator|->
name|postq_index
expr_stmt|;
name|pinbound_srb
operator|=
operator|(
expr|struct
name|InBound_SRB
operator|*
operator|)
operator|&
name|phbdmu
operator|->
name|post_qbuffer
index|[
name|postq_index
operator|&
literal|0xFF
index|]
expr_stmt|;
name|pinbound_srb
operator|->
name|addressHigh
operator|=
name|srb
operator|->
name|cdb_phyaddr_high
expr_stmt|;
name|pinbound_srb
operator|->
name|addressLow
operator|=
name|srb
operator|->
name|cdb_phyaddr_low
expr_stmt|;
name|pinbound_srb
operator|->
name|length
operator|=
name|srb
operator|->
name|arc_cdb_size
operator|>>
literal|2
expr_stmt|;
name|arcmsr_cdb
operator|->
name|Context
operator|=
name|srb
operator|->
name|cdb_phyaddr_low
expr_stmt|;
if|if
condition|(
name|postq_index
operator|&
literal|0x4000
condition|)
block|{
name|index_stripped
operator|=
name|postq_index
operator|&
literal|0xFF
expr_stmt|;
name|index_stripped
operator|+=
literal|1
expr_stmt|;
name|index_stripped
operator|%=
name|ARCMSR_MAX_HBD_POSTQUEUE
expr_stmt|;
name|phbdmu
operator|->
name|postq_index
operator|=
name|index_stripped
condition|?
operator|(
name|index_stripped
operator||
literal|0x4000
operator|)
else|:
name|index_stripped
expr_stmt|;
block|}
else|else
block|{
name|index_stripped
operator|=
name|postq_index
expr_stmt|;
name|index_stripped
operator|+=
literal|1
expr_stmt|;
name|index_stripped
operator|%=
name|ARCMSR_MAX_HBD_POSTQUEUE
expr_stmt|;
name|phbdmu
operator|->
name|postq_index
operator|=
name|index_stripped
condition|?
name|index_stripped
else|:
operator|(
name|index_stripped
operator||
literal|0x4000
operator|)
expr_stmt|;
block|}
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inboundlist_write_pointer
argument_list|,
name|postq_index
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|postDone_lock
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|struct
name|QBUFFER
modifier|*
name|arcmsr_get_iop_rqbuffer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|QBUFFER
modifier|*
name|qbuffer
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|struct
name|HBA_MessageUnit
modifier|*
name|phbamu
init|=
operator|(
expr|struct
name|HBA_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|qbuffer
operator|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|phbamu
operator|->
name|message_rbuffer
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
init|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|qbuffer
operator|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|phbbmu
operator|->
name|hbb_rwbuffer
operator|->
name|message_rbuffer
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
name|struct
name|HBC_MessageUnit
modifier|*
name|phbcmu
init|=
operator|(
expr|struct
name|HBC_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|qbuffer
operator|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|phbcmu
operator|->
name|message_rbuffer
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
name|struct
name|HBD_MessageUnit0
modifier|*
name|phbdmu
init|=
operator|(
expr|struct
name|HBD_MessageUnit0
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|qbuffer
operator|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|phbdmu
operator|->
name|phbdmu
operator|->
name|message_rbuffer
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|qbuffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|struct
name|QBUFFER
modifier|*
name|arcmsr_get_iop_wqbuffer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|QBUFFER
modifier|*
name|qbuffer
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|struct
name|HBA_MessageUnit
modifier|*
name|phbamu
init|=
operator|(
expr|struct
name|HBA_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|qbuffer
operator|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|phbamu
operator|->
name|message_wbuffer
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
init|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|qbuffer
operator|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|phbbmu
operator|->
name|hbb_rwbuffer
operator|->
name|message_wbuffer
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
name|struct
name|HBC_MessageUnit
modifier|*
name|phbcmu
init|=
operator|(
expr|struct
name|HBC_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|qbuffer
operator|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|phbcmu
operator|->
name|message_wbuffer
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
name|struct
name|HBD_MessageUnit0
modifier|*
name|phbdmu
init|=
operator|(
expr|struct
name|HBD_MessageUnit0
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|qbuffer
operator|=
operator|(
expr|struct
name|QBUFFER
operator|*
operator|)
operator|&
name|phbdmu
operator|->
name|phbdmu
operator|->
name|message_wbuffer
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|qbuffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_message_read
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
comment|/* let IOP know data has been read */
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
comment|/* let IOP know data has been read */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_DRV2IOP_DATA_READ_OK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
comment|/* let IOP know data has been read */
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
comment|/* let IOP know data has been read */
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_HBDMU_DRV2IOP_DATA_OUT_READ
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_message_wrote
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
comment|/* 			** push inbound doorbell tell iop, driver data write ok  			** and wait reply on next hwinterrupt for next Qbuffer post 			*/
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
comment|/* 			** push inbound doorbell tell iop, driver data write ok  			** and wait reply on next hwinterrupt for next Qbuffer post 			*/
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_DRV2IOP_DATA_WRITE_OK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
comment|/* 			** push inbound doorbell tell iop, driver data write ok  			** and wait reply on next hwinterrupt for next Qbuffer post 			*/
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_HBCMU_DRV2IOP_DATA_WRITE_OK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
comment|/* 			** push inbound doorbell tell iop, driver data write ok  			** and wait reply on next hwinterrupt for next Qbuffer post 			*/
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_HBDMU_DRV2IOP_DATA_IN_READY
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_stop_hba_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_STOP_BGRB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hba_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'stop adapter background rebulid' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_stop_hbb_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_STOP_BGRB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'stop adapter background rebulid' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_stop_hbc_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_STOP_BGRB
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbc_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'stop adapter background rebulid' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_stop_hbd_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_STOP_BGRB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbd_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'stop adapter background rebulid' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_stop_adapter_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|arcmsr_stop_hba_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|arcmsr_stop_hbb_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
name|arcmsr_stop_hbc_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
name|arcmsr_stop_hbd_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|psim
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
decl_stmt|;
name|int
name|mutex
decl_stmt|;
name|acb
operator|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|psim
argument_list|)
expr_stmt|;
name|mutex
operator|=
name|mtx_owned
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mutex
operator|==
literal|0
condition|)
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
name|arcmsr_interrupt
argument_list|(
name|acb
argument_list|)
expr_stmt|;
if|if
condition|(
name|mutex
operator|==
literal|0
condition|)
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_Read_iop_rqbuffer_data_D
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|QBUFFER
modifier|*
name|prbuffer
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|buf1
init|=
literal|0
decl_stmt|;
name|u_int32_t
modifier|*
name|iop_data
decl_stmt|,
modifier|*
name|buf2
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|iop_len
decl_stmt|,
name|data_len
decl_stmt|;
name|iop_data
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|prbuffer
operator|->
name|data
expr_stmt|;
name|iop_len
operator|=
operator|(
name|u_int32_t
operator|)
name|prbuffer
operator|->
name|data_len
expr_stmt|;
if|if
condition|(
name|iop_len
operator|>
literal|0
condition|)
block|{
name|buf1
operator|=
name|malloc
argument_list|(
literal|128
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|buf2
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|buf1
expr_stmt|;
if|if
condition|(
name|buf1
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|data_len
operator|=
name|iop_len
expr_stmt|;
while|while
condition|(
name|data_len
operator|>=
literal|4
condition|)
block|{
operator|*
name|buf2
operator|++
operator|=
operator|*
name|iop_data
operator|++
expr_stmt|;
name|data_len
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|data_len
condition|)
operator|*
name|buf2
operator|=
operator|*
name|iop_data
expr_stmt|;
name|buf2
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|buf1
expr_stmt|;
block|}
while|while
condition|(
name|iop_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|rqbuffer
index|[
name|acb
operator|->
name|rqbuf_lastindex
index|]
expr_stmt|;
operator|*
name|pQbuffer
operator|=
operator|*
name|buf1
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|++
expr_stmt|;
comment|/* if last, index number set it to 0 */
name|acb
operator|->
name|rqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
name|buf1
operator|++
expr_stmt|;
name|iop_len
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|buf2
condition|)
name|free
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|buf2
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* let IOP know data has been read */
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_Read_iop_rqbuffer_data
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|QBUFFER
modifier|*
name|prbuffer
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
decl_stmt|;
name|u_int32_t
name|iop_len
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|adapter_type
operator|==
name|ACB_ADAPTER_TYPE_D
condition|)
block|{
return|return
operator|(
name|arcmsr_Read_iop_rqbuffer_data_D
argument_list|(
name|acb
argument_list|,
name|prbuffer
argument_list|)
operator|)
return|;
block|}
name|iop_data
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|prbuffer
operator|->
name|data
expr_stmt|;
name|iop_len
operator|=
operator|(
name|u_int32_t
operator|)
name|prbuffer
operator|->
name|data_len
expr_stmt|;
while|while
condition|(
name|iop_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|rqbuffer
index|[
name|acb
operator|->
name|rqbuf_lastindex
index|]
expr_stmt|;
operator|*
name|pQbuffer
operator|=
operator|*
name|iop_data
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|++
expr_stmt|;
comment|/* if last, index number set it to 0 */
name|acb
operator|->
name|rqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
name|iop_data
operator|++
expr_stmt|;
name|iop_len
operator|--
expr_stmt|;
block|}
comment|/* let IOP know data has been read */
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop2drv_data_wrote_handle
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|QBUFFER
modifier|*
name|prbuffer
decl_stmt|;
name|int
name|my_empty_len
decl_stmt|;
comment|/*check this iop data if overflow my rqbuffer*/
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
name|prbuffer
operator|=
name|arcmsr_get_iop_rqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|my_empty_len
operator|=
operator|(
name|acb
operator|->
name|rqbuf_lastindex
operator|-
name|acb
operator|->
name|rqbuf_firstindex
operator|-
literal|1
operator|)
operator|&
operator|(
name|ARCMSR_MAX_QBUFFER
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|my_empty_len
operator|>=
name|prbuffer
operator|->
name|data_len
condition|)
block|{
if|if
condition|(
name|arcmsr_Read_iop_rqbuffer_data
argument_list|(
name|acb
argument_list|,
name|prbuffer
argument_list|)
operator|==
literal|0
condition|)
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
block|}
else|else
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
block|}
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_Write_data_2iop_wqbuffer_D
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|struct
name|QBUFFER
modifier|*
name|pwbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|buf1
init|=
literal|0
decl_stmt|;
name|u_int32_t
modifier|*
name|iop_data
decl_stmt|,
modifier|*
name|buf2
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|allxfer_len
init|=
literal|0
decl_stmt|,
name|data_len
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MESSAGE_WQBUFFER_READ
condition|)
block|{
name|buf1
operator|=
name|malloc
argument_list|(
literal|128
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|buf2
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|buf1
expr_stmt|;
if|if
condition|(
name|buf1
operator|==
name|NULL
condition|)
return|return;
name|acb
operator|->
name|acb_flags
operator|&=
operator|(
operator|~
name|ACB_F_MESSAGE_WQBUFFER_READ
operator|)
expr_stmt|;
name|pwbuffer
operator|=
name|arcmsr_get_iop_wqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|iop_data
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|pwbuffer
operator|->
name|data
expr_stmt|;
while|while
condition|(
operator|(
name|acb
operator|->
name|wqbuf_firstindex
operator|!=
name|acb
operator|->
name|wqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|124
operator|)
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|wqbuffer
index|[
name|acb
operator|->
name|wqbuf_firstindex
index|]
expr_stmt|;
operator|*
name|buf1
operator|=
operator|*
name|pQbuffer
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|++
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
name|buf1
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
name|pwbuffer
operator|->
name|data_len
operator|=
name|allxfer_len
expr_stmt|;
name|data_len
operator|=
name|allxfer_len
expr_stmt|;
name|buf1
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|buf2
expr_stmt|;
while|while
condition|(
name|data_len
operator|>=
literal|4
condition|)
block|{
operator|*
name|iop_data
operator|++
operator|=
operator|*
name|buf2
operator|++
expr_stmt|;
name|data_len
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|data_len
condition|)
operator|*
name|iop_data
operator|=
operator|*
name|buf2
expr_stmt|;
name|free
argument_list|(
name|buf1
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|arcmsr_iop_message_wrote
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_Write_data_2iop_wqbuffer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|struct
name|QBUFFER
modifier|*
name|pwbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
decl_stmt|;
name|int32_t
name|allxfer_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|adapter_type
operator|==
name|ACB_ADAPTER_TYPE_D
condition|)
block|{
name|arcmsr_Write_data_2iop_wqbuffer_D
argument_list|(
name|acb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MESSAGE_WQBUFFER_READ
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|(
operator|~
name|ACB_F_MESSAGE_WQBUFFER_READ
operator|)
expr_stmt|;
name|pwbuffer
operator|=
name|arcmsr_get_iop_wqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|iop_data
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pwbuffer
operator|->
name|data
expr_stmt|;
while|while
condition|(
operator|(
name|acb
operator|->
name|wqbuf_firstindex
operator|!=
name|acb
operator|->
name|wqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|124
operator|)
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|wqbuffer
index|[
name|acb
operator|->
name|wqbuf_firstindex
index|]
expr_stmt|;
operator|*
name|iop_data
operator|=
operator|*
name|pQbuffer
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|++
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
name|iop_data
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
name|pwbuffer
operator|->
name|data_len
operator|=
name|allxfer_len
expr_stmt|;
name|arcmsr_iop_message_wrote
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop2drv_data_read_handle
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MESSAGE_WQBUFFER_READ
expr_stmt|;
comment|/* 	***************************************************************** 	**   check if there are any mail packages from user space program 	**   in my post bag, now is the time to send them into Areca's firmware 	***************************************************************** 	*/
if|if
condition|(
name|acb
operator|->
name|wqbuf_firstindex
operator|!=
name|acb
operator|->
name|wqbuf_lastindex
condition|)
block|{
name|arcmsr_Write_data_2iop_wqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acb
operator|->
name|wqbuf_firstindex
operator|==
name|acb
operator|->
name|wqbuf_lastindex
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
expr_stmt|;
block|}
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_rescanLun_cb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
comment|/* 	if (ccb->ccb_h.status != CAM_REQ_CMP) 		printf("arcmsr_rescanLun_cb: Rescan Target=%x, lun=%x," 		    "failure status=%x\n", ccb->ccb_h.target_id, 		    ccb->ccb_h.target_lun, ccb->ccb_h.status); 	else 		printf("arcmsr_rescanLun_cb: Rescan lun successfully!\n"); */
name|xpt_free_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arcmsr_rescan_lun
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|xpt_alloc_ccb_nowait
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|cam_sim_path
argument_list|(
name|acb
operator|->
name|psim
argument_list|)
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*	printf("arcmsr_rescan_lun: Rescan Target=%x, Lun=%x\n", target, lun); */
name|bzero
argument_list|(
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|path
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_LUN
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|arcmsr_rescanLun_cb
expr_stmt|;
name|ccb
operator|->
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arcmsr_abort_dr_ccbs
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
comment|/* disable all outbound interrupts */
name|intmask_org
operator|=
name|arcmsr_disable_allintr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|srb
operator|=
name|acb
operator|->
name|psrb_pool
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|srb
operator|->
name|srb_state
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
if|if
condition|(
operator|(
name|target
operator|==
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|)
operator|&&
operator|(
name|lun
operator|==
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|)
condition|)
block|{
name|srb
operator|->
name|srb_state
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: abort scsi id %d lun %d srb=%p \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|srb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* enable outbound Post Queue, outbound doorbell Interrupt */
name|arcmsr_enable_allintr
argument_list|(
name|acb
argument_list|,
name|intmask_org
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_dr_handle
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|devicemap
decl_stmt|;
name|u_int32_t
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|u_int32_t
name|deviceMapCurrent
index|[
literal|4
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|u_int8_t
modifier|*
name|pDevMap
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
name|devicemap
operator|=
name|offsetof
argument_list|(
expr|struct
name|HBA_MessageUnit
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_DEVMAP_OFFSET
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<
literal|4
condition|;
name|target
operator|++
control|)
block|{
name|deviceMapCurrent
index|[
name|target
index|]
operator|=
name|bus_space_read_4
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|0
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
argument_list|,
name|devicemap
argument_list|)
expr_stmt|;
name|devicemap
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
name|devicemap
operator|=
name|offsetof
argument_list|(
expr|struct
name|HBB_RWBUFFER
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_DEVMAP_OFFSET
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<
literal|4
condition|;
name|target
operator|++
control|)
block|{
name|deviceMapCurrent
index|[
name|target
index|]
operator|=
name|bus_space_read_4
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|1
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|1
index|]
argument_list|,
name|devicemap
argument_list|)
expr_stmt|;
name|devicemap
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
name|devicemap
operator|=
name|offsetof
argument_list|(
expr|struct
name|HBC_MessageUnit
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_DEVMAP_OFFSET
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<
literal|4
condition|;
name|target
operator|++
control|)
block|{
name|deviceMapCurrent
index|[
name|target
index|]
operator|=
name|bus_space_read_4
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|0
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
argument_list|,
name|devicemap
argument_list|)
expr_stmt|;
name|devicemap
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
name|devicemap
operator|=
name|offsetof
argument_list|(
expr|struct
name|HBD_MessageUnit
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_DEVMAP_OFFSET
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<
literal|4
condition|;
name|target
operator|++
control|)
block|{
name|deviceMapCurrent
index|[
name|target
index|]
operator|=
name|bus_space_read_4
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|0
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
argument_list|,
name|devicemap
argument_list|)
expr_stmt|;
name|devicemap
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_BUS_HANG_ON
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_BUS_HANG_ON
expr_stmt|;
block|}
comment|/*  		** adapter posted CONFIG message  		** copy the new map, note if there are differences with the current map 		*/
name|pDevMap
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|deviceMapCurrent
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<
name|ARCMSR_MAX_TARGETID
operator|-
literal|1
condition|;
name|target
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|pDevMap
operator|!=
name|acb
operator|->
name|device_map
index|[
name|target
index|]
condition|)
block|{
name|u_int8_t
name|difference
decl_stmt|,
name|bit_check
decl_stmt|;
name|difference
operator|=
operator|*
name|pDevMap
operator|^
name|acb
operator|->
name|device_map
index|[
name|target
index|]
expr_stmt|;
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|ARCMSR_MAX_TARGETLUN
condition|;
name|lun
operator|++
control|)
block|{
name|bit_check
operator|=
operator|(
literal|1
operator|<<
name|lun
operator|)
expr_stmt|;
comment|/*check bit from 0....31*/
if|if
condition|(
name|difference
operator|&
name|bit_check
condition|)
block|{
if|if
condition|(
name|acb
operator|->
name|device_map
index|[
name|target
index|]
operator|&
name|bit_check
condition|)
block|{
comment|/* unit departed */
name|printf
argument_list|(
literal|"arcmsr_dr_handle: Target=%x, lun=%x, GONE!!!\n"
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|arcmsr_abort_dr_ccbs
argument_list|(
name|acb
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|arcmsr_rescan_lun
argument_list|(
name|acb
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
block|}
else|else
block|{
comment|/* unit arrived */
name|printf
argument_list|(
literal|"arcmsr_dr_handle: Target=%x, lun=%x, Plug-IN!!!\n"
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|arcmsr_rescan_lun
argument_list|(
name|acb
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
block|}
block|}
block|}
comment|/*				printf("arcmsr_dr_handle: acb->device_map[%x]=0x%x, deviceMapCurrent[%x]=%x\n",target,acb->device_map[target],target,*pDevMap); */
name|acb
operator|->
name|device_map
index|[
name|target
index|]
operator|=
operator|*
name|pDevMap
expr_stmt|;
block|}
name|pDevMap
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_hba_message_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|outbound_message
decl_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|,
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INT
argument_list|)
expr_stmt|;
name|outbound_message
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbound_message
operator|==
name|ARCMSR_SIGNATURE_GET_CONFIG
condition|)
name|arcmsr_dr_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_hbb_message_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|outbound_message
decl_stmt|;
comment|/* clear interrupts */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|,
name|ARCMSR_MESSAGE_INT_CLEAR_PATTERN
argument_list|)
expr_stmt|;
name|outbound_message
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbound_message
operator|==
name|ARCMSR_SIGNATURE_GET_CONFIG
condition|)
name|arcmsr_dr_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_hbc_message_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|outbound_message
decl_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell_clear
argument_list|,
name|ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR
argument_list|)
expr_stmt|;
name|outbound_message
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbound_message
operator|==
name|ARCMSR_SIGNATURE_GET_CONFIG
condition|)
name|arcmsr_dr_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_hbd_message_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|outbound_message
decl_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|,
name|ARCMSR_HBDMU_IOP2DRV_MESSAGE_CMD_DONE_CLEAR
argument_list|)
expr_stmt|;
name|outbound_message
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbound_message
operator|==
name|ARCMSR_SIGNATURE_GET_CONFIG
condition|)
name|arcmsr_dr_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_hba_doorbell_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|outbound_doorbell
decl_stmt|;
comment|/* 	******************************************************************* 	**  Maybe here we need to check wrqbuffer_lock is lock or not 	**  DOORBELL: din! don!  	**  check if there are any mail need to pack from firmware 	******************************************************************* 	*/
name|outbound_doorbell
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
comment|/* clear doorbell interrupt */
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK
condition|)
block|{
name|arcmsr_iop2drv_data_wrote_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_OUTBOUND_IOP331_DATA_READ_OK
condition|)
block|{
name|arcmsr_iop2drv_data_read_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_hbc_doorbell_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|outbound_doorbell
decl_stmt|;
comment|/* 	******************************************************************* 	**  Maybe here we need to check wrqbuffer_lock is lock or not 	**  DOORBELL: din! don!  	**  check if there are any mail need to pack from firmware 	******************************************************************* 	*/
name|outbound_doorbell
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell_clear
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
comment|/* clear doorbell interrupt */
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_HBCMU_IOP2DRV_DATA_WRITE_OK
condition|)
block|{
name|arcmsr_iop2drv_data_wrote_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_HBCMU_IOP2DRV_DATA_READ_OK
condition|)
block|{
name|arcmsr_iop2drv_data_read_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE
condition|)
block|{
name|arcmsr_hbc_message_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* messenger of "driver to iop commands" */
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_hbd_doorbell_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|outbound_Doorbell
decl_stmt|;
comment|/* 	******************************************************************* 	**  Maybe here we need to check wrqbuffer_lock is lock or not 	**  DOORBELL: din! don!  	**  check if there are any mail need to pack from firmware 	******************************************************************* 	*/
name|outbound_Doorbell
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|)
operator|&
name|ARCMSR_HBDMU_F0_DOORBELL_CAUSE
expr_stmt|;
if|if
condition|(
name|outbound_Doorbell
condition|)
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|,
name|outbound_Doorbell
argument_list|)
expr_stmt|;
comment|/* clear doorbell interrupt */
while|while
condition|(
name|outbound_Doorbell
operator|&
name|ARCMSR_HBDMU_F0_DOORBELL_CAUSE
condition|)
block|{
if|if
condition|(
name|outbound_Doorbell
operator|&
name|ARCMSR_HBDMU_IOP2DRV_DATA_WRITE_OK
condition|)
block|{
name|arcmsr_iop2drv_data_wrote_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outbound_Doorbell
operator|&
name|ARCMSR_HBDMU_IOP2DRV_DATA_READ_OK
condition|)
block|{
name|arcmsr_iop2drv_data_read_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outbound_Doorbell
operator|&
name|ARCMSR_HBDMU_IOP2DRV_MESSAGE_CMD_DONE
condition|)
block|{
name|arcmsr_hbd_message_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* messenger of "driver to iop commands" */
block|}
name|outbound_Doorbell
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|)
operator|&
name|ARCMSR_HBDMU_F0_DOORBELL_CAUSE
expr_stmt|;
if|if
condition|(
name|outbound_Doorbell
condition|)
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|,
name|outbound_Doorbell
argument_list|)
expr_stmt|;
comment|/* clear doorbell interrupt */
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_hba_postqueue_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|flag_srb
decl_stmt|;
name|u_int16_t
name|error
decl_stmt|;
comment|/* 	***************************************************************************** 	**               areca cdb command done 	***************************************************************************** 	*/
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|flag_srb
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_queueport
argument_list|)
operator|)
operator|!=
literal|0xFFFFFFFF
condition|)
block|{
comment|/* check if command done with no error*/
name|error
operator|=
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR_MODE0
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|arcmsr_drain_donequeue
argument_list|(
name|acb
argument_list|,
name|flag_srb
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/*drain reply FIFO*/
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_hbb_postqueue_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
init|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|u_int32_t
name|flag_srb
decl_stmt|;
name|int
name|index
decl_stmt|;
name|u_int16_t
name|error
decl_stmt|;
comment|/* 	***************************************************************************** 	**               areca cdb command done 	***************************************************************************** 	*/
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|index
operator|=
name|phbbmu
operator|->
name|doneq_index
expr_stmt|;
while|while
condition|(
operator|(
name|flag_srb
operator|=
name|phbbmu
operator|->
name|done_qbuffer
index|[
name|index
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|phbbmu
operator|->
name|done_qbuffer
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|index
operator|++
expr_stmt|;
name|index
operator|%=
name|ARCMSR_MAX_HBB_POSTQUEUE
expr_stmt|;
comment|/*if last index number set it to 0 */
name|phbbmu
operator|->
name|doneq_index
operator|=
name|index
expr_stmt|;
comment|/* check if command done with no error*/
name|error
operator|=
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR_MODE0
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|arcmsr_drain_donequeue
argument_list|(
name|acb
argument_list|,
name|flag_srb
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/*drain reply FIFO*/
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_hbc_postqueue_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|flag_srb
decl_stmt|,
name|throttling
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|error
decl_stmt|;
comment|/* 	***************************************************************************** 	**               areca cdb command done 	***************************************************************************** 	*/
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
while|while
condition|(
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|host_int_status
argument_list|)
operator|&
name|ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR
condition|)
block|{
name|flag_srb
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_queueport_low
argument_list|)
expr_stmt|;
comment|/* check if command done with no error*/
name|error
operator|=
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR_MODE1
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|arcmsr_drain_donequeue
argument_list|(
name|acb
argument_list|,
name|flag_srb
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|throttling
operator|++
expr_stmt|;
if|if
condition|(
name|throttling
operator|==
name|ARCMSR_HBC_ISR_THROTTLING_LEVEL
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_HBCMU_DRV2IOP_POSTQUEUE_THROTTLING
argument_list|)
expr_stmt|;
name|throttling
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*drain reply FIFO*/
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  ********************************************************************** */
end_comment

begin_function
specifier|static
name|uint16_t
name|arcmsr_get_doneq_index
parameter_list|(
name|struct
name|HBD_MessageUnit0
modifier|*
name|phbdmu
parameter_list|)
block|{
name|uint16_t
name|doneq_index
decl_stmt|,
name|index_stripped
decl_stmt|;
name|doneq_index
operator|=
name|phbdmu
operator|->
name|doneq_index
expr_stmt|;
if|if
condition|(
name|doneq_index
operator|&
literal|0x4000
condition|)
block|{
name|index_stripped
operator|=
name|doneq_index
operator|&
literal|0xFF
expr_stmt|;
name|index_stripped
operator|+=
literal|1
expr_stmt|;
name|index_stripped
operator|%=
name|ARCMSR_MAX_HBD_POSTQUEUE
expr_stmt|;
name|phbdmu
operator|->
name|doneq_index
operator|=
name|index_stripped
condition|?
operator|(
name|index_stripped
operator||
literal|0x4000
operator|)
else|:
name|index_stripped
expr_stmt|;
block|}
else|else
block|{
name|index_stripped
operator|=
name|doneq_index
expr_stmt|;
name|index_stripped
operator|+=
literal|1
expr_stmt|;
name|index_stripped
operator|%=
name|ARCMSR_MAX_HBD_POSTQUEUE
expr_stmt|;
name|phbdmu
operator|->
name|doneq_index
operator|=
name|index_stripped
condition|?
name|index_stripped
else|:
operator|(
name|index_stripped
operator||
literal|0x4000
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|phbdmu
operator|->
name|doneq_index
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_hbd_postqueue_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|HBD_MessageUnit0
modifier|*
name|phbdmu
init|=
operator|(
expr|struct
name|HBD_MessageUnit0
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|u_int32_t
name|outbound_write_pointer
decl_stmt|;
name|u_int32_t
name|addressLow
decl_stmt|;
name|uint16_t
name|doneq_index
decl_stmt|;
name|u_int16_t
name|error
decl_stmt|;
comment|/* 	***************************************************************************** 	**               areca cdb command done 	***************************************************************************** 	*/
if|if
condition|(
operator|(
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outboundlist_interrupt_cause
argument_list|)
operator|&
name|ARCMSR_HBDMU_OUTBOUND_LIST_INTERRUPT
operator|)
operator|==
literal|0
condition|)
return|return;
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|outbound_write_pointer
operator|=
name|phbdmu
operator|->
name|done_qbuffer
index|[
literal|0
index|]
operator|.
name|addressLow
expr_stmt|;
name|doneq_index
operator|=
name|phbdmu
operator|->
name|doneq_index
expr_stmt|;
while|while
condition|(
operator|(
name|doneq_index
operator|&
literal|0xFF
operator|)
operator|!=
operator|(
name|outbound_write_pointer
operator|&
literal|0xFF
operator|)
condition|)
block|{
name|doneq_index
operator|=
name|arcmsr_get_doneq_index
argument_list|(
name|phbdmu
argument_list|)
expr_stmt|;
name|addressLow
operator|=
name|phbdmu
operator|->
name|done_qbuffer
index|[
operator|(
name|doneq_index
operator|&
literal|0xFF
operator|)
operator|+
literal|1
index|]
operator|.
name|addressLow
expr_stmt|;
name|error
operator|=
operator|(
name|addressLow
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR_MODE1
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|arcmsr_drain_donequeue
argument_list|(
name|acb
argument_list|,
name|addressLow
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/*Check if command done with no error */
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outboundlist_read_pointer
argument_list|,
name|doneq_index
argument_list|)
expr_stmt|;
name|outbound_write_pointer
operator|=
name|phbdmu
operator|->
name|done_qbuffer
index|[
literal|0
index|]
operator|.
name|addressLow
expr_stmt|;
block|}
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outboundlist_interrupt_cause
argument_list|,
name|ARCMSR_HBDMU_OUTBOUND_LIST_INTERRUPT_CLEAR
argument_list|)
expr_stmt|;
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outboundlist_interrupt_cause
argument_list|)
expr_stmt|;
comment|/*Dummy ioread32 to force pci flush */
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_handle_hba_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|outbound_intStatus
decl_stmt|;
comment|/* 	********************************************* 	**   check outbound intstatus  	********************************************* 	*/
name|outbound_intStatus
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|)
operator|&
name|acb
operator|->
name|outbound_int_enable
expr_stmt|;
if|if
condition|(
operator|!
name|outbound_intStatus
condition|)
block|{
comment|/*it must be share irq*/
return|return;
block|}
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|,
name|outbound_intStatus
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
comment|/* MU doorbell interrupts*/
if|if
condition|(
name|outbound_intStatus
operator|&
name|ARCMSR_MU_OUTBOUND_DOORBELL_INT
condition|)
block|{
name|arcmsr_hba_doorbell_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
comment|/* MU post queue interrupts*/
if|if
condition|(
name|outbound_intStatus
operator|&
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
condition|)
block|{
name|arcmsr_hba_postqueue_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outbound_intStatus
operator|&
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INT
condition|)
block|{
name|arcmsr_hba_message_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_handle_hbb_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|outbound_doorbell
decl_stmt|;
comment|/* 	********************************************* 	**   check outbound intstatus  	********************************************* 	*/
name|outbound_doorbell
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|)
operator|&
name|acb
operator|->
name|outbound_int_enable
expr_stmt|;
if|if
condition|(
operator|!
name|outbound_doorbell
condition|)
block|{
comment|/*it must be share irq*/
return|return;
block|}
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|,
operator|~
name|outbound_doorbell
argument_list|)
expr_stmt|;
comment|/* clear doorbell interrupt */
name|CHIP_REG_READ32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_DRV2IOP_END_OF_INTERRUPT
argument_list|)
expr_stmt|;
comment|/* MU ioctl transfer doorbell interrupts*/
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_IOP2DRV_DATA_WRITE_OK
condition|)
block|{
name|arcmsr_iop2drv_data_wrote_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_IOP2DRV_DATA_READ_OK
condition|)
block|{
name|arcmsr_iop2drv_data_read_handle
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
comment|/* MU post queue interrupts*/
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_IOP2DRV_CDB_DONE
condition|)
block|{
name|arcmsr_hbb_postqueue_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_IOP2DRV_MESSAGE_CMD_DONE
condition|)
block|{
name|arcmsr_hbb_message_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_handle_hbc_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|host_interrupt_status
decl_stmt|;
comment|/* 	********************************************* 	**   check outbound intstatus  	********************************************* 	*/
name|host_interrupt_status
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|host_int_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host_interrupt_status
condition|)
block|{
comment|/*it must be share irq*/
return|return;
block|}
comment|/* MU doorbell interrupts*/
if|if
condition|(
name|host_interrupt_status
operator|&
name|ARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR
condition|)
block|{
name|arcmsr_hbc_doorbell_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
comment|/* MU post queue interrupts*/
if|if
condition|(
name|host_interrupt_status
operator|&
name|ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR
condition|)
block|{
name|arcmsr_hbc_postqueue_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_handle_hbd_isr
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|host_interrupt_status
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|;
comment|/* 	********************************************* 	**   check outbound intstatus  	********************************************* 	*/
name|host_interrupt_status
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|host_int_status
argument_list|)
operator|&
name|acb
operator|->
name|outbound_int_enable
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|host_interrupt_status
operator|&
name|ARCMSR_HBDMU_OUTBOUND_INT
operator|)
condition|)
block|{
comment|/*it must be share irq*/
return|return;
block|}
comment|/* disable outbound interrupt */
name|intmask_org
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|pcief0_int_enable
argument_list|)
expr_stmt|;
comment|/* disable outbound message0 int */
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|pcief0_int_enable
argument_list|,
name|ARCMSR_HBDMU_ALL_INT_DISABLE
argument_list|)
expr_stmt|;
comment|/* MU doorbell interrupts*/
if|if
condition|(
name|host_interrupt_status
operator|&
name|ARCMSR_HBDMU_OUTBOUND_DOORBELL_INT
condition|)
block|{
name|arcmsr_hbd_doorbell_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
comment|/* MU post queue interrupts*/
if|if
condition|(
name|host_interrupt_status
operator|&
name|ARCMSR_HBDMU_OUTBOUND_POSTQUEUE_INT
condition|)
block|{
name|arcmsr_hbd_postqueue_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
comment|/* enable all outbound interrupt */
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|pcief0_int_enable
argument_list|,
name|intmask_org
operator||
name|ARCMSR_HBDMU_ALL_INT_ENABLE
argument_list|)
expr_stmt|;
comment|//	CHIP_REG_READ32(HBD_MessageUnit, 0, pcief0_int_enable);
block|}
end_function

begin_comment
comment|/* ****************************************************************************** ****************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_interrupt
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
name|arcmsr_handle_hba_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
name|arcmsr_handle_hbb_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
name|arcmsr_handle_hbc_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
name|arcmsr_handle_hbd_isr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"arcmsr%d: interrupt service,"
literal|" unknow adapter type =%d\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|acb
operator|->
name|adapter_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_intr_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|arg
decl_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
name|arcmsr_interrupt
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ****************************************************************************** ****************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_polling_devmap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|arg
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_GET_CONFIG
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_GET_CONFIG
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_GET_CONFIG
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_GET_CONFIG
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_SCSISTOPADAPTER
operator|)
operator|==
literal|0
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|acb
operator|->
name|devmap_callout
argument_list|,
literal|5
operator|*
name|hz
argument_list|,
name|arcmsr_polling_devmap
argument_list|,
name|acb
argument_list|)
expr_stmt|;
comment|/* polling per 5 seconds */
block|}
block|}
end_function

begin_comment
comment|/* ******************************************************************************* ** ******************************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_parking
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|intmask_org
decl_stmt|;
if|if
condition|(
name|acb
operator|!=
name|NULL
condition|)
block|{
comment|/* stop adapter background rebuild */
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MSG_START_BGRB
condition|)
block|{
name|intmask_org
operator|=
name|arcmsr_disable_allintr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_stop_adapter_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_flush_adapter_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_enable_allintr
argument_list|(
name|acb
argument_list|,
name|intmask_org
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* *********************************************************************** ** ************************************************************************ */
end_comment

begin_function
name|u_int32_t
name|arcmsr_iop_ioctlcmd
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|u_int32_t
name|ioctl_cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|CMD_MESSAGE_FIELD
modifier|*
name|pcmdmessagefld
decl_stmt|;
name|u_int32_t
name|retvalue
init|=
name|EINVAL
decl_stmt|;
name|pcmdmessagefld
operator|=
operator|(
expr|struct
name|CMD_MESSAGE_FIELD
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Signature
argument_list|,
literal|"ARCMSR"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|retvalue
return|;
block|}
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ioctl_cmd
condition|)
block|{
case|case
name|ARCMSR_MESSAGE_READ_RQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|ptmpQbuffer
init|=
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
name|u_int32_t
name|allxfer_len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|acb
operator|->
name|rqbuf_firstindex
operator|!=
name|acb
operator|->
name|rqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|1031
operator|)
condition|)
block|{
comment|/*copy READ QBUFFER to srb*/
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|rqbuffer
index|[
name|acb
operator|->
name|rqbuf_firstindex
index|]
expr_stmt|;
operator|*
name|ptmpQbuffer
operator|=
operator|*
name|pQbuffer
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|++
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|ptmpQbuffer
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|struct
name|QBUFFER
modifier|*
name|prbuffer
decl_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|prbuffer
operator|=
name|arcmsr_get_iop_rqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_Read_iop_rqbuffer_data
argument_list|(
name|acb
argument_list|,
name|prbuffer
argument_list|)
operator|==
literal|0
condition|)
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
block|}
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Length
operator|=
name|allxfer_len
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_WRITE_WQBUFFER
case|:
block|{
name|u_int32_t
name|my_empty_len
decl_stmt|,
name|user_len
decl_stmt|,
name|wqbuf_firstindex
decl_stmt|,
name|wqbuf_lastindex
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|ptmpuserbuffer
init|=
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
name|user_len
operator|=
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Length
expr_stmt|;
comment|/*check if data xfer length of this request will overflow my array qbuffer */
name|wqbuf_lastindex
operator|=
name|acb
operator|->
name|wqbuf_lastindex
expr_stmt|;
name|wqbuf_firstindex
operator|=
name|acb
operator|->
name|wqbuf_firstindex
expr_stmt|;
if|if
condition|(
name|wqbuf_lastindex
operator|!=
name|wqbuf_firstindex
condition|)
block|{
name|arcmsr_Write_data_2iop_wqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_ERROR
expr_stmt|;
block|}
else|else
block|{
name|my_empty_len
operator|=
operator|(
name|wqbuf_firstindex
operator|-
name|wqbuf_lastindex
operator|-
literal|1
operator|)
operator|&
operator|(
name|ARCMSR_MAX_QBUFFER
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|my_empty_len
operator|>=
name|user_len
condition|)
block|{
while|while
condition|(
name|user_len
operator|>
literal|0
condition|)
block|{
comment|/*copy srb data to wqbuffer*/
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|wqbuffer
index|[
name|acb
operator|->
name|wqbuf_lastindex
index|]
expr_stmt|;
operator|*
name|pQbuffer
operator|=
operator|*
name|ptmpuserbuffer
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|++
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|ptmpuserbuffer
operator|++
expr_stmt|;
name|user_len
operator|--
expr_stmt|;
block|}
comment|/*post fist Qbuffer*/
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
expr_stmt|;
name|arcmsr_Write_data_2iop_wqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
block|}
else|else
block|{
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_ERROR
expr_stmt|;
block|}
block|}
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_RQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
init|=
name|acb
operator|->
name|rqbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/*signature, let IOP know data has been readed */
block|}
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MESSAGE_RQBUFFER_CLEARED
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_WQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
init|=
name|acb
operator|->
name|wqbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/*signature, let IOP know data has been readed */
block|}
name|acb
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_WQBUFFER_READ
operator|)
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_ALLQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/*signature, let IOP know data has been readed */
block|}
name|acb
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_RQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_WQBUFFER_READ
operator|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|pQbuffer
operator|=
name|acb
operator|->
name|rqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pQbuffer
operator|=
name|acb
operator|->
name|wqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_REQUEST_RETURNCODE_3F
case|:
block|{
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_3F
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_SAY_HELLO
case|:
block|{
name|u_int8_t
modifier|*
name|hello_string
init|=
literal|"Hello! I am ARCMSR"
decl_stmt|;
name|u_int8_t
modifier|*
name|puserbuffer
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
if|if
condition|(
name|memcpy
argument_list|(
name|puserbuffer
argument_list|,
name|hello_string
argument_list|,
operator|(
name|int16_t
operator|)
name|strlen
argument_list|(
name|hello_string
argument_list|)
argument_list|)
condition|)
block|{
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_ERROR
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
return|return
name|ENOIOCTL
return|;
block|}
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_SAY_GOODBYE
case|:
block|{
name|arcmsr_iop_parking
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE
case|:
block|{
name|arcmsr_flush_adapter_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
block|}
break|break;
block|}
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retvalue
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_free_srb
parameter_list|(
name|struct
name|CommandControlBlock
modifier|*
name|srb
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
decl_stmt|;
name|acb
operator|=
name|srb
operator|->
name|acb
expr_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|srb_lock
argument_list|)
expr_stmt|;
name|srb
operator|->
name|srb_state
operator|=
name|ARCMSR_SRB_DONE
expr_stmt|;
name|srb
operator|->
name|srb_flags
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|srbworkingQ
index|[
name|acb
operator|->
name|workingsrb_doneindex
index|]
operator|=
name|srb
expr_stmt|;
name|acb
operator|->
name|workingsrb_doneindex
operator|++
expr_stmt|;
name|acb
operator|->
name|workingsrb_doneindex
operator|%=
name|ARCMSR_MAX_FREESRB_NUM
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|srb_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
name|struct
name|CommandControlBlock
modifier|*
name|arcmsr_get_freesrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|workingsrb_startindex
decl_stmt|,
name|workingsrb_doneindex
decl_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|srb_lock
argument_list|)
expr_stmt|;
name|workingsrb_doneindex
operator|=
name|acb
operator|->
name|workingsrb_doneindex
expr_stmt|;
name|workingsrb_startindex
operator|=
name|acb
operator|->
name|workingsrb_startindex
expr_stmt|;
name|srb
operator|=
name|acb
operator|->
name|srbworkingQ
index|[
name|workingsrb_startindex
index|]
expr_stmt|;
name|workingsrb_startindex
operator|++
expr_stmt|;
name|workingsrb_startindex
operator|%=
name|ARCMSR_MAX_FREESRB_NUM
expr_stmt|;
if|if
condition|(
name|workingsrb_doneindex
operator|!=
name|workingsrb_startindex
condition|)
block|{
name|acb
operator|->
name|workingsrb_startindex
operator|=
name|workingsrb_startindex
expr_stmt|;
block|}
else|else
block|{
name|srb
operator|=
name|NULL
expr_stmt|;
block|}
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|srb_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|srb
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|int
name|arcmsr_iop_message_xfer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
block|{
name|struct
name|CMD_MESSAGE_FIELD
modifier|*
name|pcmdmessagefld
decl_stmt|;
name|int
name|retvalue
init|=
literal|0
decl_stmt|,
name|transfer_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|u_int32_t
name|controlcode
init|=
operator|(
name|u_int32_t
operator|)
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|5
index|]
operator|<<
literal|24
operator||
operator|(
name|u_int32_t
operator|)
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|6
index|]
operator|<<
literal|16
operator||
operator|(
name|u_int32_t
operator|)
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|7
index|]
operator|<<
literal|8
operator||
operator|(
name|u_int32_t
operator|)
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
decl_stmt|;
comment|/* 4 bytes: Areca io control code */
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_MASK
operator|)
operator|==
name|CAM_DATA_VADDR
condition|)
block|{
name|buffer
operator|=
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|transfer_len
operator|=
name|pccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
block|}
else|else
block|{
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
goto|goto
name|message_out
goto|;
block|}
if|if
condition|(
name|transfer_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|CMD_MESSAGE_FIELD
argument_list|)
condition|)
block|{
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
goto|goto
name|message_out
goto|;
block|}
name|pcmdmessagefld
operator|=
operator|(
expr|struct
name|CMD_MESSAGE_FIELD
operator|*
operator|)
name|buffer
expr_stmt|;
switch|switch
condition|(
name|controlcode
condition|)
block|{
case|case
name|ARCMSR_MESSAGE_READ_RQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|ptmpQbuffer
init|=
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
name|int32_t
name|allxfer_len
init|=
literal|0
decl_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|acb
operator|->
name|rqbuf_firstindex
operator|!=
name|acb
operator|->
name|rqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|1031
operator|)
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|rqbuffer
index|[
name|acb
operator|->
name|rqbuf_firstindex
index|]
expr_stmt|;
operator|*
name|ptmpQbuffer
operator|=
operator|*
name|pQbuffer
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|++
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
name|ptmpQbuffer
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|struct
name|QBUFFER
modifier|*
name|prbuffer
decl_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|prbuffer
operator|=
name|arcmsr_get_iop_rqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_Read_iop_rqbuffer_data
argument_list|(
name|acb
argument_list|,
name|prbuffer
argument_list|)
operator|==
literal|0
condition|)
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
block|}
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Length
operator|=
name|allxfer_len
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|retvalue
operator|=
name|ARCMSR_MESSAGE_SUCCESS
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_WRITE_WQBUFFER
case|:
block|{
name|int32_t
name|my_empty_len
decl_stmt|,
name|user_len
decl_stmt|,
name|wqbuf_firstindex
decl_stmt|,
name|wqbuf_lastindex
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|ptmpuserbuffer
init|=
name|pcmdmessagefld
operator|->
name|messagedatabuffer
decl_stmt|;
name|user_len
operator|=
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|Length
expr_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
name|wqbuf_lastindex
operator|=
name|acb
operator|->
name|wqbuf_lastindex
expr_stmt|;
name|wqbuf_firstindex
operator|=
name|acb
operator|->
name|wqbuf_firstindex
expr_stmt|;
if|if
condition|(
name|wqbuf_lastindex
operator|!=
name|wqbuf_firstindex
condition|)
block|{
name|arcmsr_Write_data_2iop_wqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* has error report sensedata */
if|if
condition|(
name|pccb
operator|->
name|csio
operator|.
name|sense_len
condition|)
block|{
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|0
index|]
operator|=
operator|(
literal|0x1
operator|<<
literal|7
operator||
literal|0x70
operator|)
expr_stmt|;
comment|/* Valid,ErrorCode */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|2
index|]
operator|=
literal|0x05
expr_stmt|;
comment|/* FileMark,EndOfMedia,IncorrectLength,Reserved,SenseKey */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|7
index|]
operator|=
literal|0x0A
expr_stmt|;
comment|/* AdditionalSenseLength */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|12
index|]
operator|=
literal|0x20
expr_stmt|;
comment|/* AdditionalSenseCode */
block|}
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
block|}
else|else
block|{
name|my_empty_len
operator|=
operator|(
name|wqbuf_firstindex
operator|-
name|wqbuf_lastindex
operator|-
literal|1
operator|)
operator|&
operator|(
name|ARCMSR_MAX_QBUFFER
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|my_empty_len
operator|>=
name|user_len
condition|)
block|{
while|while
condition|(
name|user_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|acb
operator|->
name|wqbuffer
index|[
name|acb
operator|->
name|wqbuf_lastindex
index|]
expr_stmt|;
operator|*
name|pQbuffer
operator|=
operator|*
name|ptmpuserbuffer
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|++
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
name|ptmpuserbuffer
operator|++
expr_stmt|;
name|user_len
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
expr_stmt|;
name|arcmsr_Write_data_2iop_wqbuffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* has error report sensedata */
if|if
condition|(
name|pccb
operator|->
name|csio
operator|.
name|sense_len
condition|)
block|{
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|0
index|]
operator|=
operator|(
literal|0x1
operator|<<
literal|7
operator||
literal|0x70
operator|)
expr_stmt|;
comment|/* Valid,ErrorCode */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|2
index|]
operator|=
literal|0x05
expr_stmt|;
comment|/* FileMark,EndOfMedia,IncorrectLength,Reserved,SenseKey */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|7
index|]
operator|=
literal|0x0A
expr_stmt|;
comment|/* AdditionalSenseLength */
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
literal|12
index|]
operator|=
literal|0x20
expr_stmt|;
comment|/* AdditionalSenseCode */
block|}
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
block|}
block|}
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_RQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
init|=
name|acb
operator|->
name|rqbuffer
decl_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MESSAGE_RQBUFFER_CLEARED
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_WQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
init|=
name|acb
operator|->
name|wqbuffer
decl_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
name|acb
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_WQBUFFER_READ
operator|)
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_CLEAR_ALLQBUFFER
case|:
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|arcmsr_iop_message_read
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
name|acb
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_MESSAGE_WQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_RQBUFFER_CLEARED
operator||
name|ACB_F_MESSAGE_WQBUFFER_READ
operator|)
expr_stmt|;
name|acb
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|pQbuffer
operator|=
name|acb
operator|->
name|rqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pQbuffer
operator|=
name|acb
operator|->
name|wqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_REQUEST_RETURNCODE_3F
case|:
block|{
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_3F
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_SAY_HELLO
case|:
block|{
name|int8_t
modifier|*
name|hello_string
init|=
literal|"Hello! I am ARCMSR"
decl_stmt|;
name|memcpy
argument_list|(
name|pcmdmessagefld
operator|->
name|messagedatabuffer
argument_list|,
name|hello_string
argument_list|,
operator|(
name|int16_t
operator|)
name|strlen
argument_list|(
name|hello_string
argument_list|)
argument_list|)
expr_stmt|;
name|pcmdmessagefld
operator|->
name|cmdmessage
operator|.
name|ReturnCode
operator|=
name|ARCMSR_MESSAGE_RETURNCODE_OK
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_MESSAGE_SAY_GOODBYE
case|:
name|arcmsr_iop_parking
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE
case|:
name|arcmsr_flush_adapter_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|retvalue
operator|=
name|ARCMSR_MESSAGE_FAIL
expr_stmt|;
block|}
name|message_out
label|:
return|return
operator|(
name|retvalue
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************* ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_execute_srb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
init|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|srb
operator|->
name|acb
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
decl_stmt|;
name|int
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|pccb
operator|=
name|srb
operator|->
name|pccb
expr_stmt|;
name|target
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|acb
operator|->
name|pktRequestCount
operator|++
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: unexpected error %x"
literal|" returned from 'bus_dmamap_load' \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_TOO_BIG
expr_stmt|;
block|}
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nseg
operator|>
name|ARCMSR_MAX_SG_ENTRIES
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_TOO_BIG
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_BUS_RESET
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: bus reset and return busy \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|acb
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|ARECA_RAID_GONE
condition|)
block|{
name|u_int8_t
name|block_cmd
decl_stmt|,
name|cmd
decl_stmt|;
name|cmd
operator|=
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
expr_stmt|;
name|block_cmd
operator|=
name|cmd
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|block_cmd
operator|==
literal|0x08
operator|||
name|block_cmd
operator|==
literal|0x0a
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d:block 'read/write' command "
literal|"with gone raid volume Cmd=0x%2x, TargetId=%d, Lun=%d \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|cmd
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|)
expr_stmt|;
block|}
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|>=
name|acb
operator|->
name|maxOutstanding
condition|)
block|{
if|if
condition|(
operator|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_F_CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_CAM_DEV_QFRZN
expr_stmt|;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|arcmsr_build_srb
argument_list|(
name|srb
argument_list|,
name|dm_segs
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
name|arcmsr_post_srb
argument_list|(
name|acb
argument_list|,
name|srb
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
block|{
name|arcmsr_callout_init
argument_list|(
operator|&
name|srb
operator|->
name|ccb_callout
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|srb
operator|->
name|ccb_callout
argument_list|,
operator|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|+
operator|(
name|ARCMSR_TIMEOUT_DELAY
operator|*
literal|1000
operator|)
operator|)
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|,
name|arcmsr_srb_timeout
argument_list|,
name|srb
argument_list|)
expr_stmt|;
name|srb
operator|->
name|srb_flags
operator||=
name|SRB_FLAG_TIMER_START
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ***************************************************************************************** ***************************************************************************************** */
end_comment

begin_function
specifier|static
name|u_int8_t
name|arcmsr_seek_cmd2abort
parameter_list|(
name|union
name|ccb
modifier|*
name|abortccb
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|abortccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbacb_ptr
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|acb
operator|->
name|num_aborts
operator|++
expr_stmt|;
comment|/* 	*************************************************************************** 	** It is the upper layer do abort command this lock just prior to calling us. 	** First determine if we currently own this command. 	** Start by searching the device queue. If not found 	** at all, and the system wanted us to just abort the 	** command return success. 	*************************************************************************** 	*/
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|arcmsr_disable_allintr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|srb
operator|=
name|acb
operator|->
name|psrb_pool
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|srb
operator|->
name|srb_state
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
if|if
condition|(
name|srb
operator|->
name|pccb
operator|==
name|abortccb
condition|)
block|{
name|srb
operator|->
name|srb_state
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d:scsi id=%d lun=%d abort srb '%p'"
literal|"outstanding command \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|abortccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|abortccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|srb
argument_list|)
expr_stmt|;
name|arcmsr_polling_srbdone
argument_list|(
name|acb
argument_list|,
name|srb
argument_list|)
expr_stmt|;
comment|/* enable outbound Post Queue, outbound doorbell Interrupt */
name|arcmsr_enable_allintr
argument_list|(
name|acb
argument_list|,
name|intmask_org
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
block|}
comment|/* enable outbound Post Queue, outbound doorbell Interrupt */
name|arcmsr_enable_allintr
argument_list|(
name|acb
argument_list|,
name|intmask_org
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************************** **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_bus_reset
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|int
name|retry
init|=
literal|0
decl_stmt|;
name|acb
operator|->
name|num_resets
operator|++
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_BUS_RESET
expr_stmt|;
while|while
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|!=
literal|0
operator|&&
name|retry
operator|<
literal|400
condition|)
block|{
name|arcmsr_interrupt
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|25000
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
block|}
name|arcmsr_iop_reset
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_BUS_RESET
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_handle_virtual_command
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
block|{
if|if
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
switch|switch
condition|(
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
condition|)
block|{
case|case
name|INQUIRY
case|:
block|{
name|unsigned
name|char
name|inqdata
index|[
literal|36
index|]
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
name|inqdata
index|[
literal|0
index|]
operator|=
name|T_PROCESSOR
expr_stmt|;
comment|/* Periph Qualifier& Periph Dev Type */
name|inqdata
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* rem media bit& Dev Type Modifier */
name|inqdata
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* ISO, ECMA,& ANSI versions */
name|inqdata
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|inqdata
index|[
literal|4
index|]
operator|=
literal|31
expr_stmt|;
comment|/* length of additional data */
name|inqdata
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|inqdata
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|inqdata
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|inqdata
index|[
literal|8
index|]
argument_list|,
literal|"Areca   "
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Vendor Identification */
name|strncpy
argument_list|(
operator|&
name|inqdata
index|[
literal|16
index|]
argument_list|,
literal|"RAID controller "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Product Identification */
name|strncpy
argument_list|(
operator|&
name|inqdata
index|[
literal|32
index|]
argument_list|,
literal|"R001"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Product Revision */
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|inqdata
argument_list|,
sizeof|sizeof
argument_list|(
name|inqdata
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|WRITE_BUFFER
case|:
case|case
name|READ_BUFFER
case|:
block|{
if|if
condition|(
name|arcmsr_iop_message_xfer
argument_list|(
name|acb
argument_list|,
name|pccb
argument_list|)
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|pccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************* ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|psim
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
decl_stmt|;
name|acb
operator|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|psim
argument_list|)
expr_stmt|;
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|int
name|target
init|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|16
condition|)
block|{
comment|/* virtual device for iop message transfer */
name|arcmsr_handle_virtual_command
argument_list|(
name|acb
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|srb
operator|=
name|arcmsr_get_freesrb
argument_list|(
name|acb
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbsrb_ptr
operator|=
name|srb
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbacb_ptr
operator|=
name|acb
expr_stmt|;
name|srb
operator|->
name|pccb
operator|=
name|pccb
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_ccb
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
name|srb
operator|->
name|dm_segs_dmamap
argument_list|,
name|pccb
argument_list|,
name|arcmsr_execute_srb
argument_list|,
name|srb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_TARGET_IO
case|:
block|{
comment|/* target mode not yet support vendor specific commands. */
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|pccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|ARCMSR_MAX_TARGETID
expr_stmt|;
comment|/* 0-16 */
name|cpi
operator|->
name|max_lun
operator|=
name|ARCMSR_MAX_TARGETLUN
expr_stmt|;
comment|/* 0-7 */
name|cpi
operator|->
name|initiator_id
operator|=
name|ARCMSR_SCSI_INITIATOR_ID
expr_stmt|;
comment|/* 255 */
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|psim
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"ARCMSR"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|psim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|psim
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAM_NEW_TRAN_CODE
if|if
condition|(
name|acb
operator|->
name|adapter_bus_speed
operator|==
name|ACB_BUS_SPEED_6G
condition|)
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|600000
expr_stmt|;
else|else
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|300000
expr_stmt|;
if|if
condition|(
operator|(
name|acb
operator|->
name|vendor_device_id
operator|==
name|PCIDevVenIDARC1880
operator|)
operator|||
operator|(
name|acb
operator|->
name|vendor_device_id
operator|==
name|PCIDevVenIDARC1680
operator|)
operator|||
operator|(
name|acb
operator|->
name|vendor_device_id
operator|==
name|PCIDevVenIDARC1214
operator|)
condition|)
block|{
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SAS
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC2
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
block|}
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
endif|#
directive|endif
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_ABORT
case|:
block|{
name|union
name|ccb
modifier|*
name|pabort_ccb
decl_stmt|;
name|pabort_ccb
operator|=
name|pccb
operator|->
name|cab
operator|.
name|abort_ccb
expr_stmt|;
switch|switch
condition|(
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
if|if
condition|(
name|arcmsr_seek_cmd2abort
argument_list|(
name|pabort_ccb
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|xpt_done
argument_list|(
name|pabort_ccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|xpt_print_path
argument_list|(
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Not found\n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_PATH_INVALID
expr_stmt|;
block|}
break|break;
case|case
name|XPT_SCSI_IO
case|:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_UA_ABORT
expr_stmt|;
break|break;
default|default:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
case|case
name|XPT_RESET_DEV
case|:
block|{
name|u_int32_t
name|i
decl_stmt|;
name|arcmsr_bus_reset
argument_list|(
name|acb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|500
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
if|if
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
literal|16
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|cts
operator|=
operator|&
name|pccb
operator|->
name|cts
expr_stmt|;
ifdef|#
directive|ifdef
name|CAM_NEW_TRAN_CODE
block|{
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
name|struct
name|ccb_trans_settings_sas
modifier|*
name|sas
decl_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|scsi
operator|->
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
if|if
condition|(
operator|(
name|acb
operator|->
name|vendor_device_id
operator|==
name|PCIDevVenIDARC1880
operator|)
operator|||
operator|(
name|acb
operator|->
name|vendor_device_id
operator|==
name|PCIDevVenIDARC1680
operator|)
operator|||
operator|(
name|acb
operator|->
name|vendor_device_id
operator|==
name|PCIDevVenIDARC1214
operator|)
condition|)
block|{
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC2
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SAS
expr_stmt|;
name|sas
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|sas
expr_stmt|;
name|sas
operator|->
name|valid
operator|=
name|CTS_SAS_VALID_SPEED
expr_stmt|;
if|if
condition|(
operator|(
name|acb
operator|->
name|vendor_device_id
operator|==
name|PCIDevVenIDARC1880
operator|)
operator|||
operator|(
name|acb
operator|->
name|vendor_device_id
operator|==
name|PCIDevVenIDARC1214
operator|)
condition|)
name|sas
operator|->
name|bitrate
operator|=
literal|600000
expr_stmt|;
elseif|else
if|if
condition|(
name|acb
operator|->
name|vendor_device_id
operator|==
name|PCIDevVenIDARC1680
condition|)
name|sas
operator|->
name|bitrate
operator|=
literal|300000
expr_stmt|;
block|}
else|else
block|{
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
expr_stmt|;
name|spi
operator|->
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
literal|2
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
literal|32
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_DISC
operator||
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
expr_stmt|;
block|}
block|}
else|#
directive|else
block|{
name|cts
operator|->
name|flags
operator|=
operator|(
name|CCB_TRANS_DISC_ENB
operator||
name|CCB_TRANS_TAG_ENB
operator|)
expr_stmt|;
name|cts
operator|->
name|sync_period
operator|=
literal|2
expr_stmt|;
name|cts
operator|->
name|sync_offset
operator|=
literal|32
expr_stmt|;
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
operator||
name|CCB_TRANS_BUS_WIDTH_VALID
operator||
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
block|}
endif|#
directive|endif
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
if|if
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
literal|16
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|cam_calc_geometry
argument_list|(
operator|&
name|pccb
operator|->
name|ccg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|u_int32_t
name|size_mb
decl_stmt|;
name|u_int32_t
name|secs_per_cylinder
decl_stmt|;
name|ccg
operator|=
operator|&
name|pccb
operator|->
name|ccg
expr_stmt|;
if|if
condition|(
name|ccg
operator|->
name|block_size
operator|==
literal|0
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
operator|<
literal|0
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|1024
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
block|}
endif|#
directive|endif
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_start_hba_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_START_BGRB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hba_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'start adapter background rebulid' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_start_hbb_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_START_BGRB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'start adapter background rebulid' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_start_hbc_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_START_BGRB
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbc_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'start adapter background rebulid' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_start_hbd_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_START_BGRB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbd_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'start adapter background rebulid' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_start_adapter_bgrb
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
name|arcmsr_start_hba_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
name|arcmsr_start_hbb_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
name|arcmsr_start_hbc_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
name|arcmsr_start_hbd_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_polling_hba_srbdone
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|poll_srb
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|u_int32_t
name|flag_srb
decl_stmt|,
name|outbound_intstatus
decl_stmt|,
name|poll_srb_done
init|=
literal|0
decl_stmt|,
name|poll_count
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|error
decl_stmt|;
name|polling_ccb_retry
label|:
name|poll_count
operator|++
expr_stmt|;
name|outbound_intstatus
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|)
operator|&
name|acb
operator|->
name|outbound_int_enable
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_intstatus
argument_list|,
name|outbound_intstatus
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|flag_srb
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_queueport
argument_list|)
operator|)
operator|==
literal|0xFFFFFFFF
condition|)
block|{
if|if
condition|(
name|poll_srb_done
condition|)
block|{
break|break;
comment|/*chip FIFO no ccb for completion already*/
block|}
else|else
block|{
name|UDELAY
argument_list|(
literal|25000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|poll_count
operator|>
literal|100
operator|)
operator|&&
operator|(
name|poll_srb
operator|!=
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
goto|goto
name|polling_ccb_retry
goto|;
block|}
block|}
comment|/* check if command done with no error*/
name|srb
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
operator|(
name|acb
operator|->
name|vir2phy_offset
operator|+
operator|(
name|flag_srb
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
comment|/*frame must be 32 bytes aligned*/
name|error
operator|=
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR_MODE0
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|poll_srb_done
operator|=
operator|(
name|srb
operator|==
name|poll_srb
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|srb
operator|->
name|acb
operator|!=
name|acb
operator|)
operator|||
operator|(
name|srb
operator|->
name|srb_state
operator|!=
name|ARCMSR_SRB_START
operator|)
condition|)
block|{
if|if
condition|(
name|srb
operator|->
name|srb_state
operator|==
name|ARCMSR_SRB_ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d srb='%p'"
literal|"poll command abort successfully \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|srb
argument_list|)
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"arcmsr%d: polling get an illegal srb command done srb='%p'"
literal|"srboutstandingcount=%d \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
argument_list|,
name|acb
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|arcmsr_report_srb_state
argument_list|(
name|acb
argument_list|,
name|srb
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/*drain reply FIFO*/
block|}
end_function

begin_comment
comment|/* ********************************************************************** ** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_polling_hbb_srbdone
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|poll_srb
parameter_list|)
block|{
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
init|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|u_int32_t
name|flag_srb
decl_stmt|,
name|poll_srb_done
init|=
literal|0
decl_stmt|,
name|poll_count
init|=
literal|0
decl_stmt|;
name|int
name|index
decl_stmt|;
name|u_int16_t
name|error
decl_stmt|;
name|polling_ccb_retry
label|:
name|poll_count
operator|++
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|,
name|ARCMSR_DOORBELL_INT_CLEAR_PATTERN
argument_list|)
expr_stmt|;
comment|/* clear doorbell interrupt */
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|index
operator|=
name|phbbmu
operator|->
name|doneq_index
expr_stmt|;
if|if
condition|(
operator|(
name|flag_srb
operator|=
name|phbbmu
operator|->
name|done_qbuffer
index|[
name|index
index|]
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|poll_srb_done
condition|)
block|{
break|break;
comment|/*chip FIFO no ccb for completion already*/
block|}
else|else
block|{
name|UDELAY
argument_list|(
literal|25000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|poll_count
operator|>
literal|100
operator|)
operator|&&
operator|(
name|poll_srb
operator|!=
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
goto|goto
name|polling_ccb_retry
goto|;
block|}
block|}
name|phbbmu
operator|->
name|done_qbuffer
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|index
operator|++
expr_stmt|;
name|index
operator|%=
name|ARCMSR_MAX_HBB_POSTQUEUE
expr_stmt|;
comment|/*if last index number set it to 0 */
name|phbbmu
operator|->
name|doneq_index
operator|=
name|index
expr_stmt|;
comment|/* check if command done with no error*/
name|srb
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
operator|(
name|acb
operator|->
name|vir2phy_offset
operator|+
operator|(
name|flag_srb
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
comment|/*frame must be 32 bytes aligned*/
name|error
operator|=
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR_MODE0
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|poll_srb_done
operator|=
operator|(
name|srb
operator|==
name|poll_srb
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|srb
operator|->
name|acb
operator|!=
name|acb
operator|)
operator|||
operator|(
name|srb
operator|->
name|srb_state
operator|!=
name|ARCMSR_SRB_START
operator|)
condition|)
block|{
if|if
condition|(
name|srb
operator|->
name|srb_state
operator|==
name|ARCMSR_SRB_ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d srb='%p'"
literal|"poll command abort successfully \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|srb
argument_list|)
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"arcmsr%d: polling get an illegal srb command done srb='%p'"
literal|"srboutstandingcount=%d \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
argument_list|,
name|acb
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|arcmsr_report_srb_state
argument_list|(
name|acb
argument_list|,
name|srb
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/*drain reply FIFO*/
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_polling_hbc_srbdone
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|poll_srb
parameter_list|)
block|{
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|u_int32_t
name|flag_srb
decl_stmt|,
name|poll_srb_done
init|=
literal|0
decl_stmt|,
name|poll_count
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|error
decl_stmt|;
name|polling_ccb_retry
label|:
name|poll_count
operator|++
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|host_int_status
argument_list|)
operator|&
name|ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR
operator|)
condition|)
block|{
if|if
condition|(
name|poll_srb_done
condition|)
block|{
break|break;
comment|/*chip FIFO no ccb for completion already*/
block|}
else|else
block|{
name|UDELAY
argument_list|(
literal|25000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|poll_count
operator|>
literal|100
operator|)
operator|&&
operator|(
name|poll_srb
operator|!=
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|==
literal|0
condition|)
block|{
break|break;
block|}
goto|goto
name|polling_ccb_retry
goto|;
block|}
block|}
name|flag_srb
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_queueport_low
argument_list|)
expr_stmt|;
comment|/* check if command done with no error*/
name|srb
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
operator|(
name|acb
operator|->
name|vir2phy_offset
operator|+
operator|(
name|flag_srb
operator|&
literal|0xFFFFFFE0
operator|)
operator|)
expr_stmt|;
comment|/*frame must be 32 bytes aligned*/
name|error
operator|=
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR_MODE1
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|poll_srb
operator|!=
name|NULL
condition|)
name|poll_srb_done
operator|=
operator|(
name|srb
operator|==
name|poll_srb
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|srb
operator|->
name|acb
operator|!=
name|acb
operator|)
operator|||
operator|(
name|srb
operator|->
name|srb_state
operator|!=
name|ARCMSR_SRB_START
operator|)
condition|)
block|{
if|if
condition|(
name|srb
operator|->
name|srb_state
operator|==
name|ARCMSR_SRB_ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d srb='%p'poll command abort successfully \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|srb
argument_list|)
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"arcmsr%d: polling get an illegal srb command done srb='%p'srboutstandingcount=%d \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
argument_list|,
name|acb
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|arcmsr_report_srb_state
argument_list|(
name|acb
argument_list|,
name|srb
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/*drain reply FIFO*/
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_polling_hbd_srbdone
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|poll_srb
parameter_list|)
block|{
name|struct
name|HBD_MessageUnit0
modifier|*
name|phbdmu
init|=
operator|(
expr|struct
name|HBD_MessageUnit0
operator|*
operator|)
name|acb
operator|->
name|pmu
decl_stmt|;
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|u_int32_t
name|flag_srb
decl_stmt|,
name|poll_srb_done
init|=
literal|0
decl_stmt|,
name|poll_count
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|outbound_write_pointer
decl_stmt|;
name|u_int16_t
name|error
decl_stmt|,
name|doneq_index
decl_stmt|;
name|polling_ccb_retry
label|:
name|poll_count
operator|++
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|outbound_write_pointer
operator|=
name|phbdmu
operator|->
name|done_qbuffer
index|[
literal|0
index|]
operator|.
name|addressLow
expr_stmt|;
name|doneq_index
operator|=
name|phbdmu
operator|->
name|doneq_index
expr_stmt|;
if|if
condition|(
operator|(
name|outbound_write_pointer
operator|&
literal|0xFF
operator|)
operator|==
operator|(
name|doneq_index
operator|&
literal|0xFF
operator|)
condition|)
block|{
if|if
condition|(
name|poll_srb_done
condition|)
block|{
break|break;
comment|/*chip FIFO no ccb for completion already*/
block|}
else|else
block|{
name|UDELAY
argument_list|(
literal|25000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|poll_count
operator|>
literal|100
operator|)
operator|&&
operator|(
name|poll_srb
operator|!=
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|==
literal|0
condition|)
block|{
break|break;
block|}
goto|goto
name|polling_ccb_retry
goto|;
block|}
block|}
name|doneq_index
operator|=
name|arcmsr_get_doneq_index
argument_list|(
name|phbdmu
argument_list|)
expr_stmt|;
name|flag_srb
operator|=
name|phbdmu
operator|->
name|done_qbuffer
index|[
operator|(
name|doneq_index
operator|&
literal|0xFF
operator|)
operator|+
literal|1
index|]
operator|.
name|addressLow
expr_stmt|;
comment|/* check if command done with no error*/
name|srb
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
operator|(
name|acb
operator|->
name|vir2phy_offset
operator|+
operator|(
name|flag_srb
operator|&
literal|0xFFFFFFE0
operator|)
operator|)
expr_stmt|;
comment|/*frame must be 32 bytes aligned*/
name|error
operator|=
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR_MODE1
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outboundlist_read_pointer
argument_list|,
name|doneq_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|poll_srb
operator|!=
name|NULL
condition|)
name|poll_srb_done
operator|=
operator|(
name|srb
operator|==
name|poll_srb
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|srb
operator|->
name|acb
operator|!=
name|acb
operator|)
operator|||
operator|(
name|srb
operator|->
name|srb_state
operator|!=
name|ARCMSR_SRB_START
operator|)
condition|)
block|{
if|if
condition|(
name|srb
operator|->
name|srb_state
operator|==
name|ARCMSR_SRB_ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d srb='%p'poll command abort successfully \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|srb
argument_list|)
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"arcmsr%d: polling get an illegal srb command done srb='%p'srboutstandingcount=%d \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|srb
argument_list|,
name|acb
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|arcmsr_report_srb_state
argument_list|(
name|acb
argument_list|,
name|srb
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/*drain reply FIFO*/
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_polling_srbdone
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|,
name|struct
name|CommandControlBlock
modifier|*
name|poll_srb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|arcmsr_polling_hba_srbdone
argument_list|(
name|acb
argument_list|,
name|poll_srb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|arcmsr_polling_hbb_srbdone
argument_list|(
name|acb
argument_list|,
name|poll_srb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
name|arcmsr_polling_hbc_srbdone
argument_list|(
name|acb
argument_list|,
name|poll_srb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
name|arcmsr_polling_hbd_srbdone
argument_list|(
name|acb
argument_list|,
name|poll_srb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_get_hba_config
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|char
modifier|*
name|acb_firm_model
init|=
name|acb
operator|->
name|firm_model
decl_stmt|;
name|char
modifier|*
name|acb_firm_version
init|=
name|acb
operator|->
name|firm_version
decl_stmt|;
name|char
modifier|*
name|acb_device_map
init|=
name|acb
operator|->
name|device_map
decl_stmt|;
name|size_t
name|iop_firm_model
init|=
name|offsetof
argument_list|(
expr|struct
name|HBA_MessageUnit
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_MODEL_OFFSET
index|]
argument_list|)
decl_stmt|;
comment|/*firm_model,15,60-67*/
name|size_t
name|iop_firm_version
init|=
name|offsetof
argument_list|(
expr|struct
name|HBA_MessageUnit
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_VERS_OFFSET
index|]
argument_list|)
decl_stmt|;
comment|/*firm_version,17,68-83*/
name|size_t
name|iop_device_map
init|=
name|offsetof
argument_list|(
expr|struct
name|HBA_MessageUnit
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_DEVMAP_OFFSET
index|]
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_GET_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hba_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'get adapter firmware miscellaneous data' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|8
condition|)
block|{
operator|*
name|acb_firm_model
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|0
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
argument_list|,
name|iop_firm_model
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 8 bytes firm_model, 15, 60-67*/
name|acb_firm_model
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|16
condition|)
block|{
operator|*
name|acb_firm_version
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|0
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
argument_list|,
name|iop_firm_version
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 16 bytes firm_version, 17, 68-83*/
name|acb_firm_version
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|16
condition|)
block|{
operator|*
name|acb_device_map
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|0
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
argument_list|,
name|iop_device_map
operator|+
name|i
argument_list|)
expr_stmt|;
name|acb_device_map
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: %s \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: FIRMWARE VERSION %s \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|acb
operator|->
name|firm_version
argument_list|)
expr_stmt|;
name|acb
operator|->
name|firm_request_len
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*firm_request_len, 1, 04-07*/
name|acb
operator|->
name|firm_numbers_queue
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/*firm_numbers_queue, 2, 08-11*/
name|acb
operator|->
name|firm_sdram_size
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/*firm_sdram_size, 3, 12-15*/
name|acb
operator|->
name|firm_ide_channels
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/*firm_ide_channels, 4, 16-19*/
name|acb
operator|->
name|firm_cfg_version
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_CFGVER_OFFSET
index|]
argument_list|)
expr_stmt|;
comment|/*firm_cfg_version,  25, 	  */
if|if
condition|(
name|acb
operator|->
name|firm_numbers_queue
operator|>
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|)
name|acb
operator|->
name|maxOutstanding
operator|=
name|ARCMSR_MAX_OUTSTANDING_CMD
operator|-
literal|1
expr_stmt|;
else|else
name|acb
operator|->
name|maxOutstanding
operator|=
name|acb
operator|->
name|firm_numbers_queue
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_get_hbb_config
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|char
modifier|*
name|acb_firm_model
init|=
name|acb
operator|->
name|firm_model
decl_stmt|;
name|char
modifier|*
name|acb_firm_version
init|=
name|acb
operator|->
name|firm_version
decl_stmt|;
name|char
modifier|*
name|acb_device_map
init|=
name|acb
operator|->
name|device_map
decl_stmt|;
name|size_t
name|iop_firm_model
init|=
name|offsetof
argument_list|(
expr|struct
name|HBB_RWBUFFER
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_MODEL_OFFSET
index|]
argument_list|)
decl_stmt|;
comment|/*firm_model,15,60-67*/
name|size_t
name|iop_firm_version
init|=
name|offsetof
argument_list|(
expr|struct
name|HBB_RWBUFFER
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_VERS_OFFSET
index|]
argument_list|)
decl_stmt|;
comment|/*firm_version,17,68-83*/
name|size_t
name|iop_device_map
init|=
name|offsetof
argument_list|(
expr|struct
name|HBB_RWBUFFER
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_DEVMAP_OFFSET
index|]
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_GET_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait"
literal|"'get adapter firmware miscellaneous data' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|8
condition|)
block|{
operator|*
name|acb_firm_model
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|1
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|1
index|]
argument_list|,
name|iop_firm_model
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 8 bytes firm_model, 15, 60-67*/
name|acb_firm_model
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|16
condition|)
block|{
operator|*
name|acb_firm_version
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|1
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|1
index|]
argument_list|,
name|iop_firm_version
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 16 bytes firm_version, 17, 68-83*/
name|acb_firm_version
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|16
condition|)
block|{
operator|*
name|acb_device_map
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|1
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|1
index|]
argument_list|,
name|iop_device_map
operator|+
name|i
argument_list|)
expr_stmt|;
name|acb_device_map
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: %s \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: FIRMWARE VERSION %s \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|acb
operator|->
name|firm_version
argument_list|)
expr_stmt|;
name|acb
operator|->
name|firm_request_len
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*firm_request_len, 1, 04-07*/
name|acb
operator|->
name|firm_numbers_queue
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/*firm_numbers_queue, 2, 08-11*/
name|acb
operator|->
name|firm_sdram_size
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/*firm_sdram_size, 3, 12-15*/
name|acb
operator|->
name|firm_ide_channels
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/*firm_ide_channels, 4, 16-19*/
name|acb
operator|->
name|firm_cfg_version
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_CFGVER_OFFSET
index|]
argument_list|)
expr_stmt|;
comment|/*firm_cfg_version,  25, 	  */
if|if
condition|(
name|acb
operator|->
name|firm_numbers_queue
operator|>
name|ARCMSR_MAX_HBB_POSTQUEUE
condition|)
name|acb
operator|->
name|maxOutstanding
operator|=
name|ARCMSR_MAX_HBB_POSTQUEUE
operator|-
literal|1
expr_stmt|;
else|else
name|acb
operator|->
name|maxOutstanding
operator|=
name|acb
operator|->
name|firm_numbers_queue
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_get_hbc_config
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|char
modifier|*
name|acb_firm_model
init|=
name|acb
operator|->
name|firm_model
decl_stmt|;
name|char
modifier|*
name|acb_firm_version
init|=
name|acb
operator|->
name|firm_version
decl_stmt|;
name|char
modifier|*
name|acb_device_map
init|=
name|acb
operator|->
name|device_map
decl_stmt|;
name|size_t
name|iop_firm_model
init|=
name|offsetof
argument_list|(
expr|struct
name|HBC_MessageUnit
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_MODEL_OFFSET
index|]
argument_list|)
decl_stmt|;
comment|/*firm_model,15,60-67*/
name|size_t
name|iop_firm_version
init|=
name|offsetof
argument_list|(
expr|struct
name|HBC_MessageUnit
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_VERS_OFFSET
index|]
argument_list|)
decl_stmt|;
comment|/*firm_version,17,68-83*/
name|size_t
name|iop_device_map
init|=
name|offsetof
argument_list|(
expr|struct
name|HBC_MessageUnit
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_DEVMAP_OFFSET
index|]
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_GET_CONFIG
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbc_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'get adapter firmware miscellaneous data' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|8
condition|)
block|{
operator|*
name|acb_firm_model
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|0
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
argument_list|,
name|iop_firm_model
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 8 bytes firm_model, 15, 60-67*/
name|acb_firm_model
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|16
condition|)
block|{
operator|*
name|acb_firm_version
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|0
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
argument_list|,
name|iop_firm_version
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 16 bytes firm_version, 17, 68-83*/
name|acb_firm_version
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|16
condition|)
block|{
operator|*
name|acb_device_map
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|0
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
argument_list|,
name|iop_device_map
operator|+
name|i
argument_list|)
expr_stmt|;
name|acb_device_map
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: %s \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: FIRMWARE VERSION %s \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|acb
operator|->
name|firm_version
argument_list|)
expr_stmt|;
name|acb
operator|->
name|firm_request_len
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*firm_request_len,   1, 04-07*/
name|acb
operator|->
name|firm_numbers_queue
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/*firm_numbers_queue, 2, 08-11*/
name|acb
operator|->
name|firm_sdram_size
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/*firm_sdram_size,    3, 12-15*/
name|acb
operator|->
name|firm_ide_channels
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/*firm_ide_channels,  4, 16-19*/
name|acb
operator|->
name|firm_cfg_version
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_CFGVER_OFFSET
index|]
argument_list|)
expr_stmt|;
comment|/*firm_cfg_version,  25, 	  */
if|if
condition|(
name|acb
operator|->
name|firm_numbers_queue
operator|>
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|)
name|acb
operator|->
name|maxOutstanding
operator|=
name|ARCMSR_MAX_OUTSTANDING_CMD
operator|-
literal|1
expr_stmt|;
else|else
name|acb
operator|->
name|maxOutstanding
operator|=
name|acb
operator|->
name|firm_numbers_queue
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_get_hbd_config
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|char
modifier|*
name|acb_firm_model
init|=
name|acb
operator|->
name|firm_model
decl_stmt|;
name|char
modifier|*
name|acb_firm_version
init|=
name|acb
operator|->
name|firm_version
decl_stmt|;
name|char
modifier|*
name|acb_device_map
init|=
name|acb
operator|->
name|device_map
decl_stmt|;
name|size_t
name|iop_firm_model
init|=
name|offsetof
argument_list|(
expr|struct
name|HBD_MessageUnit
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_MODEL_OFFSET
index|]
argument_list|)
decl_stmt|;
comment|/*firm_model,15,60-67*/
name|size_t
name|iop_firm_version
init|=
name|offsetof
argument_list|(
expr|struct
name|HBD_MessageUnit
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_VERS_OFFSET
index|]
argument_list|)
decl_stmt|;
comment|/*firm_version,17,68-83*/
name|size_t
name|iop_device_map
init|=
name|offsetof
argument_list|(
expr|struct
name|HBD_MessageUnit
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_DEVMAP_OFFSET
index|]
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|)
operator|&
name|ARCMSR_HBDMU_IOP2DRV_MESSAGE_CMD_DONE
condition|)
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|,
name|ARCMSR_HBDMU_IOP2DRV_MESSAGE_CMD_DONE_CLEAR
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_GET_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbd_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'get adapter firmware miscellaneous data' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|8
condition|)
block|{
operator|*
name|acb_firm_model
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|0
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
argument_list|,
name|iop_firm_model
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 8 bytes firm_model, 15, 60-67*/
name|acb_firm_model
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|16
condition|)
block|{
operator|*
name|acb_firm_version
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|0
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
argument_list|,
name|iop_firm_version
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 16 bytes firm_version, 17, 68-83*/
name|acb_firm_version
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|16
condition|)
block|{
operator|*
name|acb_device_map
operator|=
name|bus_space_read_1
argument_list|(
name|acb
operator|->
name|btag
index|[
literal|0
index|]
argument_list|,
name|acb
operator|->
name|bhandle
index|[
literal|0
index|]
argument_list|,
name|iop_device_map
operator|+
name|i
argument_list|)
expr_stmt|;
name|acb_device_map
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: %s \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: FIRMWARE VERSION %s \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|,
name|acb
operator|->
name|firm_version
argument_list|)
expr_stmt|;
name|acb
operator|->
name|firm_request_len
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/*firm_request_len,   1, 04-07*/
name|acb
operator|->
name|firm_numbers_queue
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/*firm_numbers_queue, 2, 08-11*/
name|acb
operator|->
name|firm_sdram_size
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/*firm_sdram_size,    3, 12-15*/
name|acb
operator|->
name|firm_ide_channels
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/*firm_ide_channels,  4, 16-19*/
name|acb
operator|->
name|firm_cfg_version
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
name|ARCMSR_FW_CFGVER_OFFSET
index|]
argument_list|)
expr_stmt|;
comment|/*firm_cfg_version,  25, 	  */
if|if
condition|(
name|acb
operator|->
name|firm_numbers_queue
operator|>
name|ARCMSR_MAX_HBD_POSTQUEUE
condition|)
name|acb
operator|->
name|maxOutstanding
operator|=
name|ARCMSR_MAX_HBD_POSTQUEUE
operator|-
literal|1
expr_stmt|;
else|else
name|acb
operator|->
name|maxOutstanding
operator|=
name|acb
operator|->
name|firm_numbers_queue
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_get_firmware_spec
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
name|arcmsr_get_hba_config
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|arcmsr_get_hbb_config
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
name|arcmsr_get_hbc_config
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
name|arcmsr_get_hbd_config
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_wait_firmware_ready
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|int
name|timeout
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
while|while
condition|(
operator|(
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_msgaddr1
argument_list|)
operator|&
name|ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timeout
operator|++
operator|>
literal|2000
condition|)
comment|/* (2000*15)/1000 = 30 sec */
block|{
name|printf
argument_list|(
literal|"arcmsr%d:timed out waiting for firmware \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|UDELAY
argument_list|(
literal|15000
argument_list|)
expr_stmt|;
comment|/* wait 15 milli-seconds */
block|}
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
while|while
condition|(
operator|(
name|CHIP_REG_READ32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|)
operator|&
name|ARCMSR_MESSAGE_FIRMWARE_OK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timeout
operator|++
operator|>
literal|2000
condition|)
comment|/* (2000*15)/1000 = 30 sec */
block|{
name|printf
argument_list|(
literal|"arcmsr%d: timed out waiting for firmware \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|UDELAY
argument_list|(
literal|15000
argument_list|)
expr_stmt|;
comment|/* wait 15 milli-seconds */
block|}
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_DRV2IOP_END_OF_INTERRUPT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
while|while
condition|(
operator|(
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_msgaddr1
argument_list|)
operator|&
name|ARCMSR_HBCMU_MESSAGE_FIRMWARE_OK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timeout
operator|++
operator|>
literal|2000
condition|)
comment|/* (2000*15)/1000 = 30 sec */
block|{
name|printf
argument_list|(
literal|"arcmsr%d:timed out waiting for firmware ready\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|UDELAY
argument_list|(
literal|15000
argument_list|)
expr_stmt|;
comment|/* wait 15 milli-seconds */
block|}
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
while|while
condition|(
operator|(
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_msgaddr1
argument_list|)
operator|&
name|ARCMSR_HBDMU_MESSAGE_FIRMWARE_OK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timeout
operator|++
operator|>
literal|2000
condition|)
comment|/* (2000*15)/1000 = 30 sec */
block|{
name|printf
argument_list|(
literal|"arcmsr%d:timed out waiting for firmware ready\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|UDELAY
argument_list|(
literal|15000
argument_list|)
expr_stmt|;
comment|/* wait 15 milli-seconds */
block|}
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_clear_doorbell_queue_buffer
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|outbound_doorbell
decl_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
comment|/* empty doorbell Qbuffer if door bell ringed */
name|outbound_doorbell
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
comment|/*clear doorbell interrupt */
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|iop2drv_doorbell
argument_list|,
name|ARCMSR_MESSAGE_INT_CLEAR_PATTERN
argument_list|)
expr_stmt|;
comment|/*clear interrupt and message state*/
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_DRV2IOP_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/* let IOP know data has been read */
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
comment|/* empty doorbell Qbuffer if door bell ringed */
name|outbound_doorbell
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell_clear
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
comment|/*clear doorbell interrupt */
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK
argument_list|)
expr_stmt|;
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell_clear
argument_list|)
expr_stmt|;
comment|/* Dummy read to force pci flush */
name|CHIP_REG_READ32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|)
expr_stmt|;
comment|/* Dummy read to force pci flush */
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
comment|/* empty doorbell Qbuffer if door bell ringed */
name|outbound_doorbell
operator|=
name|CHIP_REG_READ32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|outbound_doorbell
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
comment|/*clear doorbell interrupt */
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_HBDMU_DRV2IOP_DATA_OUT_READ
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_iop_confirm
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|unsigned
name|long
name|srb_phyaddr
decl_stmt|;
name|u_int32_t
name|srb_phyaddr_hi32
decl_stmt|;
name|u_int32_t
name|srb_phyaddr_lo32
decl_stmt|;
comment|/* 	******************************************************************** 	** here we need to tell iop 331 our freesrb.HighPart  	** if freesrb.HighPart is not zero 	******************************************************************** 	*/
name|srb_phyaddr
operator|=
operator|(
name|unsigned
name|long
operator|)
name|acb
operator|->
name|srb_phyaddr
operator|.
name|phyaddr
expr_stmt|;
name|srb_phyaddr_hi32
operator|=
name|acb
operator|->
name|srb_phyaddr
operator|.
name|B
operator|.
name|phyadd_high
expr_stmt|;
name|srb_phyaddr_lo32
operator|=
name|acb
operator|->
name|srb_phyaddr
operator|.
name|B
operator|.
name|phyadd_low
expr_stmt|;
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
block|{
if|if
condition|(
name|srb_phyaddr_hi32
operator|!=
literal|0
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|0
index|]
argument_list|,
name|ARCMSR_SIGNATURE_SET_CONFIG
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|1
index|]
argument_list|,
name|srb_phyaddr_hi32
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBA_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_SET_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hba_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: 'set srb high part physical address' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
break|break;
comment|/* 		*********************************************************************** 		**    if adapter type B, set window of "post command Q"  		*********************************************************************** 		*/
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|u_int32_t
name|post_queue_phyaddr
decl_stmt|;
name|struct
name|HBB_MessageUnit
modifier|*
name|phbbmu
decl_stmt|;
name|phbbmu
operator|=
operator|(
expr|struct
name|HBB_MessageUnit
operator|*
operator|)
name|acb
operator|->
name|pmu
expr_stmt|;
name|phbbmu
operator|->
name|postq_index
operator|=
literal|0
expr_stmt|;
name|phbbmu
operator|->
name|doneq_index
operator|=
literal|0
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_SET_POST_WINDOW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: 'set window of post command Q' timeout\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|post_queue_phyaddr
operator|=
name|srb_phyaddr
operator|+
name|ARCMSR_SRBS_POOL_SIZE
operator|+
name|offsetof
argument_list|(
expr|struct
name|HBB_MessageUnit
argument_list|,
name|post_qbuffer
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|0
index|]
argument_list|,
name|ARCMSR_SIGNATURE_SET_CONFIG
argument_list|)
expr_stmt|;
comment|/* driver "set config" signature */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|1
index|]
argument_list|,
name|srb_phyaddr_hi32
argument_list|)
expr_stmt|;
comment|/* normal should be zero */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|2
index|]
argument_list|,
name|post_queue_phyaddr
argument_list|)
expr_stmt|;
comment|/* postQ size (256+8)*4 */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|3
index|]
argument_list|,
name|post_queue_phyaddr
operator|+
literal|1056
argument_list|)
expr_stmt|;
comment|/* doneQ size (256+8)*4 */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_RWBUFFER
argument_list|,
literal|1
argument_list|,
name|msgcode_rwbuffer
index|[
literal|4
index|]
argument_list|,
literal|1056
argument_list|)
expr_stmt|;
comment|/* srb maxQ size must be --> [(256+8)*4] */
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_SET_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: 'set command Q window' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_START_DRIVER_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: 'start diver mode' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_C
case|:
block|{
if|if
condition|(
name|srb_phyaddr_hi32
operator|!=
literal|0
condition|)
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|0
index|]
argument_list|,
name|ARCMSR_SIGNATURE_SET_CONFIG
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|1
index|]
argument_list|,
name|srb_phyaddr_hi32
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_SET_CONFIG
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBC_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_doorbell
argument_list|,
name|ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbc_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: 'set srb high part physical address' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
break|break;
case|case
name|ACB_ADAPTER_TYPE_D
case|:
block|{
name|u_int32_t
name|post_queue_phyaddr
decl_stmt|,
name|done_queue_phyaddr
decl_stmt|;
name|struct
name|HBD_MessageUnit0
modifier|*
name|phbdmu
decl_stmt|;
name|phbdmu
operator|=
operator|(
expr|struct
name|HBD_MessageUnit0
operator|*
operator|)
name|acb
operator|->
name|pmu
expr_stmt|;
name|phbdmu
operator|->
name|postq_index
operator|=
literal|0
expr_stmt|;
name|phbdmu
operator|->
name|doneq_index
operator|=
literal|0x40FF
expr_stmt|;
name|post_queue_phyaddr
operator|=
name|srb_phyaddr_lo32
operator|+
name|ARCMSR_SRBS_POOL_SIZE
operator|+
name|offsetof
argument_list|(
expr|struct
name|HBD_MessageUnit0
argument_list|,
name|post_qbuffer
argument_list|)
expr_stmt|;
name|done_queue_phyaddr
operator|=
name|srb_phyaddr_lo32
operator|+
name|ARCMSR_SRBS_POOL_SIZE
operator|+
name|offsetof
argument_list|(
expr|struct
name|HBD_MessageUnit0
argument_list|,
name|done_qbuffer
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|0
index|]
argument_list|,
name|ARCMSR_SIGNATURE_SET_CONFIG
argument_list|)
expr_stmt|;
comment|/* driver "set config" signature */
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|1
index|]
argument_list|,
name|srb_phyaddr_hi32
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|2
index|]
argument_list|,
name|post_queue_phyaddr
argument_list|)
expr_stmt|;
comment|/* postQ base */
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|3
index|]
argument_list|,
name|done_queue_phyaddr
argument_list|)
expr_stmt|;
comment|/* doneQ base */
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|msgcode_rwbuffer
index|[
literal|4
index|]
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
name|CHIP_REG_WRITE32
argument_list|(
name|HBD_MessageUnit
argument_list|,
literal|0
argument_list|,
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_SET_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbd_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: 'set srb high part physical address' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
break|break;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_enable_eoi_mode
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
switch|switch
condition|(
name|acb
operator|->
name|adapter_type
condition|)
block|{
case|case
name|ACB_ADAPTER_TYPE_A
case|:
case|case
name|ACB_ADAPTER_TYPE_C
case|:
case|case
name|ACB_ADAPTER_TYPE_D
case|:
break|break;
case|case
name|ACB_ADAPTER_TYPE_B
case|:
block|{
name|CHIP_REG_WRITE32
argument_list|(
name|HBB_DOORBELL
argument_list|,
literal|0
argument_list|,
name|drv2iop_doorbell
argument_list|,
name|ARCMSR_MESSAGE_ACTIVE_EOI_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arcmsr_hbb_wait_msgint_ready
argument_list|(
name|acb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: 'iop enable eoi mode' timeout \n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_init
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|u_int32_t
name|intmask_org
decl_stmt|;
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|arcmsr_disable_allintr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_wait_firmware_ready
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_iop_confirm
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_get_firmware_spec
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/*start background rebuild*/
name|arcmsr_start_adapter_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* empty doorbell Qbuffer if door bell ringed */
name|arcmsr_clear_doorbell_queue_buffer
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_enable_eoi_mode
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* enable outbound Post Queue, outbound doorbell Interrupt */
name|arcmsr_enable_allintr
argument_list|(
name|acb
argument_list|,
name|intmask_org
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_IOP_INITED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_map_free_srb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|arg
decl_stmt|;
name|struct
name|CommandControlBlock
modifier|*
name|srb_tmp
decl_stmt|;
name|u_int32_t
name|i
decl_stmt|;
name|unsigned
name|long
name|srb_phyaddr
init|=
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_addr
decl_stmt|;
name|acb
operator|->
name|srb_phyaddr
operator|.
name|phyaddr
operator|=
name|srb_phyaddr
expr_stmt|;
name|srb_tmp
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
name|acb
operator|->
name|uncacheptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|srb_tmp
operator|->
name|dm_segs_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_MAPFREESRB_FAILD
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|" srb dmamap bus_dmamap_create error\n"
argument_list|,
name|acb
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|acb
operator|->
name|adapter_type
operator|==
name|ACB_ADAPTER_TYPE_C
operator|)
operator|||
operator|(
name|acb
operator|->
name|adapter_type
operator|==
name|ACB_ADAPTER_TYPE_D
operator|)
condition|)
block|{
name|srb_tmp
operator|->
name|cdb_phyaddr_low
operator|=
name|srb_phyaddr
expr_stmt|;
name|srb_tmp
operator|->
name|cdb_phyaddr_high
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
operator|(
name|srb_phyaddr
operator|>>
literal|16
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
name|srb_tmp
operator|->
name|cdb_phyaddr_low
operator|=
name|srb_phyaddr
operator|>>
literal|5
expr_stmt|;
name|srb_tmp
operator|->
name|acb
operator|=
name|acb
expr_stmt|;
name|acb
operator|->
name|srbworkingQ
index|[
name|i
index|]
operator|=
name|acb
operator|->
name|psrb_pool
index|[
name|i
index|]
operator|=
name|srb_tmp
expr_stmt|;
name|srb_phyaddr
operator|=
name|srb_phyaddr
operator|+
name|SRB_SIZE
expr_stmt|;
name|srb_tmp
operator|=
operator|(
expr|struct
name|CommandControlBlock
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|srb_tmp
operator|+
name|SRB_SIZE
operator|)
expr_stmt|;
block|}
name|acb
operator|->
name|vir2phy_offset
operator|=
operator|(
name|unsigned
name|long
operator|)
name|srb_tmp
operator|-
operator|(
name|unsigned
name|long
operator|)
name|srb_phyaddr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_free_resource
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
comment|/* remove the control device */
if|if
condition|(
name|acb
operator|->
name|ioctl_dev
operator|!=
name|NULL
condition|)
block|{
name|destroy_dev
argument_list|(
name|acb
operator|->
name|ioctl_dev
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|,
name|acb
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|dm_segs_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|acb
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_mutex_init
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|ARCMSR_LOCK_INIT
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|,
literal|"arcmsr isr lock"
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_INIT
argument_list|(
operator|&
name|acb
operator|->
name|srb_lock
argument_list|,
literal|"arcmsr srb lock"
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_INIT
argument_list|(
operator|&
name|acb
operator|->
name|postDone_lock
argument_list|,
literal|"arcmsr postQ lock"
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_INIT
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|,
literal|"arcmsr RW buffer lock"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_mutex_destroy
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
name|ARCMSR_LOCK_DESTROY
argument_list|(
operator|&
name|acb
operator|->
name|qbuffer_lock
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_DESTROY
argument_list|(
operator|&
name|acb
operator|->
name|postDone_lock
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_DESTROY
argument_list|(
operator|&
name|acb
operator|->
name|srb_lock
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_DESTROY
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_initialize
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int16_t
name|pci_command
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|max_coherent_size
decl_stmt|;
name|u_int32_t
name|vendor_dev_id
decl_stmt|;
name|vendor_dev_id
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|acb
operator|->
name|vendor_device_id
operator|=
name|vendor_dev_id
expr_stmt|;
switch|switch
condition|(
name|vendor_dev_id
condition|)
block|{
case|case
name|PCIDevVenIDARC1880
case|:
case|case
name|PCIDevVenIDARC1882
case|:
case|case
name|PCIDevVenIDARC1213
case|:
case|case
name|PCIDevVenIDARC1223
case|:
block|{
name|acb
operator|->
name|adapter_type
operator|=
name|ACB_ADAPTER_TYPE_C
expr_stmt|;
name|acb
operator|->
name|adapter_bus_speed
operator|=
name|ACB_BUS_SPEED_6G
expr_stmt|;
name|max_coherent_size
operator|=
name|ARCMSR_SRBS_POOL_SIZE
expr_stmt|;
block|}
break|break;
case|case
name|PCIDevVenIDARC1214
case|:
block|{
name|acb
operator|->
name|adapter_type
operator|=
name|ACB_ADAPTER_TYPE_D
expr_stmt|;
name|acb
operator|->
name|adapter_bus_speed
operator|=
name|ACB_BUS_SPEED_6G
expr_stmt|;
name|max_coherent_size
operator|=
name|ARCMSR_SRBS_POOL_SIZE
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|HBD_MessageUnit0
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|PCIDevVenIDARC1200
case|:
case|case
name|PCIDevVenIDARC1201
case|:
block|{
name|acb
operator|->
name|adapter_type
operator|=
name|ACB_ADAPTER_TYPE_B
expr_stmt|;
name|acb
operator|->
name|adapter_bus_speed
operator|=
name|ACB_BUS_SPEED_3G
expr_stmt|;
name|max_coherent_size
operator|=
name|ARCMSR_SRBS_POOL_SIZE
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|HBB_MessageUnit
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|PCIDevVenIDARC1110
case|:
case|case
name|PCIDevVenIDARC1120
case|:
case|case
name|PCIDevVenIDARC1130
case|:
case|case
name|PCIDevVenIDARC1160
case|:
case|case
name|PCIDevVenIDARC1170
case|:
case|case
name|PCIDevVenIDARC1210
case|:
case|case
name|PCIDevVenIDARC1220
case|:
case|case
name|PCIDevVenIDARC1230
case|:
case|case
name|PCIDevVenIDARC1231
case|:
case|case
name|PCIDevVenIDARC1260
case|:
case|case
name|PCIDevVenIDARC1261
case|:
case|case
name|PCIDevVenIDARC1270
case|:
case|case
name|PCIDevVenIDARC1280
case|:
case|case
name|PCIDevVenIDARC1212
case|:
case|case
name|PCIDevVenIDARC1222
case|:
case|case
name|PCIDevVenIDARC1380
case|:
case|case
name|PCIDevVenIDARC1381
case|:
case|case
name|PCIDevVenIDARC1680
case|:
case|case
name|PCIDevVenIDARC1681
case|:
block|{
name|acb
operator|->
name|adapter_type
operator|=
name|ACB_ADAPTER_TYPE_A
expr_stmt|;
name|acb
operator|->
name|adapter_bus_speed
operator|=
name|ACB_BUS_SPEED_3G
expr_stmt|;
name|max_coherent_size
operator|=
name|ARCMSR_SRBS_POOL_SIZE
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|printf
argument_list|(
literal|"arcmsr%d:"
literal|" unknown RAID adapter type \n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*PCI parent*/
argument|bus_get_dma_tag(dev)
argument_list|,
else|#
directive|else
argument|if(bus_dma_tag_create(
comment|/*PCI parent*/
argument|NULL,
endif|#
directive|endif
comment|/*alignemnt*/
literal|1
argument|,
comment|/*boundary*/
literal|0
argument|,
comment|/*lowaddr*/
argument|BUS_SPACE_MAXADDR,
comment|/*highaddr*/
argument|BUS_SPACE_MAXADDR,
comment|/*filter*/
argument|NULL,
comment|/*filterarg*/
argument|NULL,
comment|/*maxsize*/
argument|BUS_SPACE_MAXSIZE_32BIT,
comment|/*nsegments*/
argument|BUS_SPACE_UNRESTRICTED,
comment|/*maxsegsz*/
argument|BUS_SPACE_MAXSIZE_32BIT,
comment|/*flags*/
literal|0
argument|,
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|501102
comment|/*lockfunc*/
argument|NULL,
comment|/*lockarg*/
argument|NULL,
endif|#
directive|endif
argument|&acb->parent_dmat) !=
literal|0
argument|) 	{ 		printf(
literal|"arcmsr%d: parent_dmat bus_dma_tag_create failure!\n"
argument|, device_get_unit(dev)); 		return ENOMEM; 	}
comment|/* Create a single tag describing a region large enough to hold all of the s/g lists we will need. */
argument|if(bus_dma_tag_create(
comment|/*parent_dmat*/
argument|acb->parent_dmat,
comment|/*alignment*/
literal|1
argument|,
comment|/*boundary*/
literal|0
argument|,
ifdef|#
directive|ifdef
name|PAE
comment|/*lowaddr*/
argument|BUS_SPACE_MAXADDR_32BIT,
else|#
directive|else
comment|/*lowaddr*/
argument|BUS_SPACE_MAXADDR,
endif|#
directive|endif
comment|/*highaddr*/
argument|BUS_SPACE_MAXADDR,
comment|/*filter*/
argument|NULL,
comment|/*filterarg*/
argument|NULL,
comment|/*maxsize*/
argument|ARCMSR_MAX_SG_ENTRIES * PAGE_SIZE * ARCMSR_MAX_FREESRB_NUM,
comment|/*nsegments*/
argument|ARCMSR_MAX_SG_ENTRIES,
comment|/*maxsegsz*/
argument|BUS_SPACE_MAXSIZE_32BIT,
comment|/*flags*/
literal|0
argument|,
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|501102
comment|/*lockfunc*/
argument|busdma_lock_mutex,
comment|/*lockarg*/
argument|&acb->isr_lock,
endif|#
directive|endif
argument|&acb->dm_segs_dmat) !=
literal|0
argument|) 	{ 		bus_dma_tag_destroy(acb->parent_dmat); 		printf(
literal|"arcmsr%d: dm_segs_dmat bus_dma_tag_create failure!\n"
argument|, device_get_unit(dev)); 		return ENOMEM; 	}
comment|/* DMA tag for our srb structures.... Allocate the freesrb memory */
argument|if(bus_dma_tag_create(
comment|/*parent_dmat*/
argument|acb->parent_dmat,
comment|/*alignment*/
literal|0x20
argument|,
comment|/*boundary*/
literal|0
argument|,
comment|/*lowaddr*/
argument|BUS_SPACE_MAXADDR_32BIT,
comment|/*highaddr*/
argument|BUS_SPACE_MAXADDR,
comment|/*filter*/
argument|NULL,
comment|/*filterarg*/
argument|NULL,
comment|/*maxsize*/
argument|max_coherent_size,
comment|/*nsegments*/
literal|1
argument|,
comment|/*maxsegsz*/
argument|BUS_SPACE_MAXSIZE_32BIT,
comment|/*flags*/
literal|0
argument|,
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|501102
comment|/*lockfunc*/
argument|NULL,
comment|/*lockarg*/
argument|NULL,
endif|#
directive|endif
argument|&acb->srb_dmat) !=
literal|0
argument|) 	{ 		bus_dma_tag_destroy(acb->dm_segs_dmat); 		bus_dma_tag_destroy(acb->parent_dmat); 		printf(
literal|"arcmsr%d: srb_dmat bus_dma_tag_create failure!\n"
argument|, device_get_unit(dev)); 		return ENXIO; 	}
comment|/* Allocation for our srbs */
argument|if(bus_dmamem_alloc(acb->srb_dmat, (void **)&acb->uncacheptr, BUS_DMA_WAITOK | BUS_DMA_COHERENT | BUS_DMA_ZERO,&acb->srb_dmamap) !=
literal|0
argument|) { 		bus_dma_tag_destroy(acb->srb_dmat); 		bus_dma_tag_destroy(acb->dm_segs_dmat); 		bus_dma_tag_destroy(acb->parent_dmat); 		printf(
literal|"arcmsr%d: srb_dmat bus_dmamem_alloc failure!\n"
argument|, device_get_unit(dev)); 		return ENXIO; 	}
comment|/* And permanently map them */
argument|if(bus_dmamap_load(acb->srb_dmat, acb->srb_dmamap, acb->uncacheptr, max_coherent_size, arcmsr_map_free_srb, acb,
comment|/*flags*/
literal|0
argument|)) { 		bus_dma_tag_destroy(acb->srb_dmat); 		bus_dma_tag_destroy(acb->dm_segs_dmat); 		bus_dma_tag_destroy(acb->parent_dmat); 		printf(
literal|"arcmsr%d: srb_dmat bus_dmamap_load failure!\n"
argument|, device_get_unit(dev)); 		return ENXIO; 	} 	pci_command = pci_read_config(dev, PCIR_COMMAND,
literal|2
argument|); 	pci_command |= PCIM_CMD_BUSMASTEREN; 	pci_command |= PCIM_CMD_PERRESPEN; 	pci_command |= PCIM_CMD_MWRICEN;
comment|/* Enable Busmaster/Mem */
argument|pci_command |= PCIM_CMD_MEMEN; 	pci_write_config(dev, PCIR_COMMAND, pci_command,
literal|2
argument|); 	switch(acb->adapter_type) { 	case ACB_ADAPTER_TYPE_A: { 			u_int32_t rid0 = PCIR_BAR(
literal|0
argument|); 			vm_offset_t	mem_base0;  			acb->sys_res_arcmsr[
literal|0
argument|] = bus_alloc_resource(dev,SYS_RES_MEMORY,&rid0,
literal|0ul
argument|, ~
literal|0ul
argument|,
literal|0x1000
argument|, RF_ACTIVE); 			if(acb->sys_res_arcmsr[
literal|0
argument|] == NULL) { 				arcmsr_free_resource(acb); 				printf(
literal|"arcmsr%d: bus_alloc_resource failure!\n"
argument|, device_get_unit(dev)); 				return ENOMEM; 			} 			if(rman_get_start(acb->sys_res_arcmsr[
literal|0
argument|])<=
literal|0
argument|) { 				arcmsr_free_resource(acb); 				printf(
literal|"arcmsr%d: rman_get_start failure!\n"
argument|, device_get_unit(dev)); 				return ENXIO; 			} 			mem_base0 = (vm_offset_t) rman_get_virtual(acb->sys_res_arcmsr[
literal|0
argument|]); 			if(mem_base0 ==
literal|0
argument|) { 				arcmsr_free_resource(acb); 				printf(
literal|"arcmsr%d: rman_get_virtual failure!\n"
argument|, device_get_unit(dev)); 				return ENXIO; 			} 			acb->btag[
literal|0
argument|] = rman_get_bustag(acb->sys_res_arcmsr[
literal|0
argument|]); 			acb->bhandle[
literal|0
argument|] = rman_get_bushandle(acb->sys_res_arcmsr[
literal|0
argument|]); 			acb->pmu = (struct MessageUnit_UNION *)mem_base0; 		} 		break; 	case ACB_ADAPTER_TYPE_B: { 			struct HBB_MessageUnit *phbbmu; 			struct CommandControlBlock *freesrb; 			u_int32_t rid[]={ PCIR_BAR(
literal|0
argument|)
argument_list|,
argument|PCIR_BAR(
literal|2
argument|) }; 			vm_offset_t	mem_base[]={
literal|0
argument_list|,
literal|0
argument|}; 			for(i=
literal|0
argument|; i<
literal|2
argument|; i++) { 				if(i ==
literal|0
argument|) { 					acb->sys_res_arcmsr[i] = bus_alloc_resource(dev,SYS_RES_MEMORY,&rid[i],
literal|0ul
argument|, ~
literal|0ul
argument|, sizeof(struct HBB_DOORBELL), RF_ACTIVE); 				} else { 					acb->sys_res_arcmsr[i] = bus_alloc_resource(dev, SYS_RES_MEMORY,&rid[i],
literal|0ul
argument|, ~
literal|0ul
argument|, sizeof(struct HBB_RWBUFFER), RF_ACTIVE); 				} 				if(acb->sys_res_arcmsr[i] == NULL) { 					arcmsr_free_resource(acb); 					printf(
literal|"arcmsr%d: bus_alloc_resource %d failure!\n"
argument|, device_get_unit(dev), i); 					return ENOMEM; 				} 				if(rman_get_start(acb->sys_res_arcmsr[i])<=
literal|0
argument|) { 					arcmsr_free_resource(acb); 					printf(
literal|"arcmsr%d: rman_get_start %d failure!\n"
argument|, device_get_unit(dev), i); 					return ENXIO; 				} 				mem_base[i] = (vm_offset_t) rman_get_virtual(acb->sys_res_arcmsr[i]); 				if(mem_base[i] ==
literal|0
argument|) { 					arcmsr_free_resource(acb); 					printf(
literal|"arcmsr%d: rman_get_virtual %d failure!\n"
argument|, device_get_unit(dev), i); 					return ENXIO; 				} 				acb->btag[i] = rman_get_bustag(acb->sys_res_arcmsr[i]); 				acb->bhandle[i] = rman_get_bushandle(acb->sys_res_arcmsr[i]); 			} 			freesrb = (struct CommandControlBlock *)acb->uncacheptr; 			acb->pmu = (struct MessageUnit_UNION *)((unsigned long)freesrb+ARCMSR_SRBS_POOL_SIZE); 			phbbmu = (struct HBB_MessageUnit *)acb->pmu; 			phbbmu->hbb_doorbell = (struct HBB_DOORBELL *)mem_base[
literal|0
argument|]; 			phbbmu->hbb_rwbuffer = (struct HBB_RWBUFFER *)mem_base[
literal|1
argument|]; 		} 		break; 	case ACB_ADAPTER_TYPE_C: { 			u_int32_t rid0 = PCIR_BAR(
literal|1
argument|); 			vm_offset_t	mem_base0;  			acb->sys_res_arcmsr[
literal|0
argument|] = bus_alloc_resource(dev,SYS_RES_MEMORY,&rid0,
literal|0ul
argument|, ~
literal|0ul
argument|, sizeof(struct HBC_MessageUnit), RF_ACTIVE); 			if(acb->sys_res_arcmsr[
literal|0
argument|] == NULL) { 				arcmsr_free_resource(acb); 				printf(
literal|"arcmsr%d: bus_alloc_resource failure!\n"
argument|, device_get_unit(dev)); 				return ENOMEM; 			} 			if(rman_get_start(acb->sys_res_arcmsr[
literal|0
argument|])<=
literal|0
argument|) { 				arcmsr_free_resource(acb); 				printf(
literal|"arcmsr%d: rman_get_start failure!\n"
argument|, device_get_unit(dev)); 				return ENXIO; 			} 			mem_base0 = (vm_offset_t) rman_get_virtual(acb->sys_res_arcmsr[
literal|0
argument|]); 			if(mem_base0 ==
literal|0
argument|) { 				arcmsr_free_resource(acb); 				printf(
literal|"arcmsr%d: rman_get_virtual failure!\n"
argument|, device_get_unit(dev)); 				return ENXIO; 			} 			acb->btag[
literal|0
argument|] = rman_get_bustag(acb->sys_res_arcmsr[
literal|0
argument|]); 			acb->bhandle[
literal|0
argument|] = rman_get_bushandle(acb->sys_res_arcmsr[
literal|0
argument|]); 			acb->pmu = (struct MessageUnit_UNION *)mem_base0; 		} 		break; 	case ACB_ADAPTER_TYPE_D: { 			struct HBD_MessageUnit0 *phbdmu; 			u_int32_t rid0 = PCIR_BAR(
literal|0
argument|); 			vm_offset_t	mem_base0;  			acb->sys_res_arcmsr[
literal|0
argument|] = bus_alloc_resource(dev,SYS_RES_MEMORY,&rid0,
literal|0ul
argument|, ~
literal|0ul
argument|, sizeof(struct HBD_MessageUnit), RF_ACTIVE); 			if(acb->sys_res_arcmsr[
literal|0
argument|] == NULL) { 				arcmsr_free_resource(acb); 				printf(
literal|"arcmsr%d: bus_alloc_resource failure!\n"
argument|, device_get_unit(dev)); 				return ENOMEM; 			} 			if(rman_get_start(acb->sys_res_arcmsr[
literal|0
argument|])<=
literal|0
argument|) { 				arcmsr_free_resource(acb); 				printf(
literal|"arcmsr%d: rman_get_start failure!\n"
argument|, device_get_unit(dev)); 				return ENXIO; 			} 			mem_base0 = (vm_offset_t) rman_get_virtual(acb->sys_res_arcmsr[
literal|0
argument|]); 			if(mem_base0 ==
literal|0
argument|) { 				arcmsr_free_resource(acb); 				printf(
literal|"arcmsr%d: rman_get_virtual failure!\n"
argument|, device_get_unit(dev)); 				return ENXIO; 			} 			acb->btag[
literal|0
argument|] = rman_get_bustag(acb->sys_res_arcmsr[
literal|0
argument|]); 			acb->bhandle[
literal|0
argument|] = rman_get_bushandle(acb->sys_res_arcmsr[
literal|0
argument|]); 			acb->pmu = (struct MessageUnit_UNION *)((unsigned long)acb->uncacheptr+ARCMSR_SRBS_POOL_SIZE); 			phbdmu = (struct HBD_MessageUnit0 *)acb->pmu; 			phbdmu->phbdmu = (struct HBD_MessageUnit *)mem_base0; 		} 		break; 	} 	if(acb->acb_flags& ACB_F_MAPFREESRB_FAILD) { 		arcmsr_free_resource(acb); 		printf(
literal|"arcmsr%d: map free srb failure!\n"
argument|, device_get_unit(dev)); 		return ENXIO; 	} 	acb->acb_flags  |= (ACB_F_MESSAGE_WQBUFFER_CLEARED|ACB_F_MESSAGE_RQBUFFER_CLEARED|ACB_F_MESSAGE_WQBUFFER_READ); 	acb->acb_flags&= ~ACB_F_SCSISTOPADAPTER;
comment|/* 	******************************************************************** 	** init raid volume state 	******************************************************************** 	*/
argument|for(i=
literal|0
argument|; i< ARCMSR_MAX_TARGETID; i++) { 		for(j=
literal|0
argument|; j< ARCMSR_MAX_TARGETLUN; j++) { 			acb->devstate[i][j] = ARECA_RAID_GONE; 		} 	} 	arcmsr_iop_init(acb); 	return(
literal|0
argument|); }
comment|/* ************************************************************************ ************************************************************************ */
argument|static int arcmsr_attach(device_t dev) { 	struct AdapterControlBlock *acb=(struct AdapterControlBlock *)device_get_softc(dev); 	u_int32_t unit=device_get_unit(dev); 	struct ccb_setasync csa; 	struct cam_devq	*devq;
comment|/* Device Queue to use for this SIM */
argument|struct resource	*irqres; 	int	rid; 	 	if(acb == NULL) { 		printf(
literal|"arcmsr%d: cannot allocate softc\n"
argument|, unit); 		return (ENOMEM); 	} 	arcmsr_mutex_init(acb); 	if(arcmsr_initialize(dev)) { 		printf(
literal|"arcmsr%d: initialize failure!\n"
argument|, unit); 		arcmsr_mutex_destroy(acb); 		return ENXIO; 	}
comment|/* After setting up the adapter, map our interrupt */
argument|rid =
literal|0
argument|; 	irqres = bus_alloc_resource(dev, SYS_RES_IRQ,&rid,
literal|0ul
argument|, ~
literal|0ul
argument|,
literal|1
argument|, RF_SHAREABLE | RF_ACTIVE); 	if(irqres == NULL ||
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700025
argument|bus_setup_intr(dev, irqres, INTR_TYPE_CAM|INTR_ENTROPY|INTR_MPSAFE, NULL, arcmsr_intr_handler, acb,&acb->ih)) {
else|#
directive|else
argument|bus_setup_intr(dev, irqres, INTR_TYPE_CAM|INTR_ENTROPY|INTR_MPSAFE, arcmsr_intr_handler, acb,&acb->ih)
argument_list|)
block|{
endif|#
directive|endif
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_mutex_destroy
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: unable to register interrupt handler!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|acb
operator|->
name|irqres
operator|=
name|irqres
expr_stmt|;
name|acb
operator|->
name|pci_dev
operator|=
name|dev
expr_stmt|;
name|acb
operator|->
name|pci_unit
operator|=
name|unit
expr_stmt|;
comment|/* 	 * Now let the CAM generic SCSI layer find the SCSI devices on 	 * the bus *  start queue to reset to the idle loop. * 	 * Create device queue of SIM(s) *  (MAX_START_JOB - 1) : 	 * max_sim_transactions 	*/
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|ARCMSR_MAX_START_JOB
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|arcmsr_mutex_destroy
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: cam_simq_alloc failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700025
name|acb
operator|->
name|psim
operator|=
name|cam_sim_alloc
argument_list|(
name|arcmsr_action
argument_list|,
name|arcmsr_poll
argument_list|,
literal|"arcmsr"
argument_list|,
name|acb
argument_list|,
name|unit
argument_list|,
operator|&
name|acb
operator|->
name|isr_lock
argument_list|,
literal|1
argument_list|,
name|ARCMSR_MAX_OUTSTANDING_CMD
argument_list|,
name|devq
argument_list|)
expr_stmt|;
else|#
directive|else
name|acb
operator|->
name|psim
operator|=
name|cam_sim_alloc
argument_list|(
name|arcmsr_action
argument_list|,
name|arcmsr_poll
argument_list|,
literal|"arcmsr"
argument_list|,
name|acb
argument_list|,
name|unit
argument_list|,
literal|1
argument_list|,
name|ARCMSR_MAX_OUTSTANDING_CMD
argument_list|,
name|devq
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|acb
operator|->
name|psim
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|arcmsr_mutex_destroy
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: cam_sim_alloc failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700044
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
endif|#
directive|endif
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|arcmsr_mutex_destroy
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: xpt_bus_register failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|acb
operator|->
name|ppath
argument_list|,
comment|/* periph */
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|acb
operator|->
name|psim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|acb
operator|->
name|psim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
comment|/* free_simq */
name|TRUE
argument_list|)
expr_stmt|;
name|arcmsr_mutex_destroy
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: xpt_create_path failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* 	**************************************************** 	*/
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|acb
operator|->
name|ppath
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
operator||
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|arcmsr_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|acb
operator|->
name|psim
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
comment|/* Create the control device.  */
name|acb
operator|->
name|ioctl_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|arcmsr_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
comment|/* GID_OPERATOR */
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|,
literal|"arcmsr%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|acb
operator|->
name|ioctl_dev
operator|->
name|si_drv1
operator|=
name|acb
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500005
operator|(
name|void
operator|)
name|make_dev_alias
argument_list|(
name|acb
operator|->
name|ioctl_dev
argument_list|,
literal|"arc%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arcmsr_callout_init
argument_list|(
operator|&
name|acb
operator|->
name|devmap_callout
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|acb
operator|->
name|devmap_callout
argument_list|,
literal|60
operator|*
name|hz
argument_list|,
name|arcmsr_polling_devmap
argument_list|,
name|acb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* ************************************************************************ ************************************************************************ */
specifier|static
name|int
name|arcmsr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|id
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|char
name|x_type
index|[]
init|=
block|{
literal|"X-TYPE"
block|}
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|raid6
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_VENDOR_ID_ARECA
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
switch|switch
condition|(
name|id
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|PCIDevVenIDARC1110
case|:
case|case
name|PCIDevVenIDARC1200
case|:
case|case
name|PCIDevVenIDARC1201
case|:
case|case
name|PCIDevVenIDARC1210
case|:
name|raid6
operator|=
literal|0
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|PCIDevVenIDARC1120
case|:
case|case
name|PCIDevVenIDARC1130
case|:
case|case
name|PCIDevVenIDARC1160
case|:
case|case
name|PCIDevVenIDARC1170
case|:
case|case
name|PCIDevVenIDARC1220
case|:
case|case
name|PCIDevVenIDARC1230
case|:
case|case
name|PCIDevVenIDARC1231
case|:
case|case
name|PCIDevVenIDARC1260
case|:
case|case
name|PCIDevVenIDARC1261
case|:
case|case
name|PCIDevVenIDARC1270
case|:
case|case
name|PCIDevVenIDARC1280
case|:
name|type
operator|=
literal|"SATA 3G"
expr_stmt|;
break|break;
case|case
name|PCIDevVenIDARC1212
case|:
case|case
name|PCIDevVenIDARC1222
case|:
case|case
name|PCIDevVenIDARC1380
case|:
case|case
name|PCIDevVenIDARC1381
case|:
case|case
name|PCIDevVenIDARC1680
case|:
case|case
name|PCIDevVenIDARC1681
case|:
name|type
operator|=
literal|"SAS 3G"
expr_stmt|;
break|break;
case|case
name|PCIDevVenIDARC1880
case|:
case|case
name|PCIDevVenIDARC1882
case|:
case|case
name|PCIDevVenIDARC1213
case|:
case|case
name|PCIDevVenIDARC1223
case|:
name|type
operator|=
literal|"SAS 6G"
expr_stmt|;
break|break;
case|case
name|PCIDevVenIDARC1214
case|:
name|type
operator|=
literal|"SATA 6G"
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|x_type
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|==
name|x_type
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Areca %s Host Adapter RAID Controller %s\n"
argument_list|,
name|type
argument_list|,
name|raid6
condition|?
literal|"(RAID6 capable)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ************************************************************************ ************************************************************************ */
specifier|static
name|int
name|arcmsr_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|i
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|;
name|struct
name|CommandControlBlock
modifier|*
name|srb
decl_stmt|;
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* stop adapter background rebuild */
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|arcmsr_disable_allintr
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_stop_adapter_bgrb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|arcmsr_flush_adapter_cache
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* abort all outstanding command */
name|acb
operator|->
name|acb_flags
operator||=
name|ACB_F_SCSISTOPADAPTER
expr_stmt|;
name|acb
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOP_INITED
expr_stmt|;
if|if
condition|(
name|acb
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
comment|/*clear and abort all outbound posted Q*/
name|arcmsr_done4abort_postqueue
argument_list|(
name|acb
argument_list|)
expr_stmt|;
comment|/* talk to iop 331 outstanding command aborted*/
name|arcmsr_abort_allcmd
argument_list|(
name|acb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|srb
operator|=
name|acb
operator|->
name|psrb_pool
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|srb
operator|->
name|srb_state
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
name|srb
operator|->
name|srb_state
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|srb
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|srb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|acb
operator|->
name|srboutstandingcount
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|workingsrb_doneindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|workingsrb_startindex
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|pktRequestCount
operator|=
literal|0
expr_stmt|;
name|acb
operator|->
name|pktReturnCount
operator|=
literal|0
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* ************************************************************************ ************************************************************************ */
specifier|static
name|int
name|arcmsr_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|AdapterControlBlock
modifier|*
name|acb
init|=
operator|(
expr|struct
name|AdapterControlBlock
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|callout_stop
argument_list|(
operator|&
name|acb
operator|->
name|devmap_callout
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|acb
operator|->
name|irqres
argument_list|,
name|acb
operator|->
name|ih
argument_list|)
expr_stmt|;
name|arcmsr_shutdown
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|arcmsr_free_resource
argument_list|(
name|acb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|acb
operator|->
name|sys_res_arcmsr
index|[
name|i
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|i
operator|<
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
argument_list|,
name|acb
operator|->
name|sys_res_arcmsr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|acb
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_ACQUIRE
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|acb
operator|->
name|ppath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|acb
operator|->
name|ppath
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|acb
operator|->
name|psim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|acb
operator|->
name|psim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ARCMSR_LOCK_RELEASE
argument_list|(
operator|&
name|acb
operator|->
name|isr_lock
argument_list|)
expr_stmt|;
name|arcmsr_mutex_destroy
argument_list|(
name|acb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ARCMSR_DEBUG1
specifier|static
name|void
name|arcmsr_dump_data
parameter_list|(
name|struct
name|AdapterControlBlock
modifier|*
name|acb
parameter_list|)
block|{
if|if
condition|(
operator|(
name|acb
operator|->
name|pktRequestCount
operator|-
name|acb
operator|->
name|pktReturnCount
operator|)
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"Command Request Count   =0x%x\n"
argument_list|,
name|acb
operator|->
name|pktRequestCount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Command Return Count    =0x%x\n"
argument_list|,
name|acb
operator|->
name|pktReturnCount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Command (Req-Rtn) Count =0x%x\n"
argument_list|,
operator|(
name|acb
operator|->
name|pktRequestCount
operator|-
name|acb
operator|->
name|pktReturnCount
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Queued Command Count    =0x%x\n"
argument_list|,
name|acb
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

