begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ****************************************************************************************** **        O.S   : FreeBSD **   FILE NAME  : arcmsr.c **        BY    : Erich Chen    **   Description: SCSI RAID Device Driver for  **                ARECA (ARC11XX/ARC12XX) SATA RAID HOST Adapter **                ARCMSR RAID Host adapter[RAID controller:INTEL 331(PCI-X) 341(PCI-EXPRESS) chip set] ****************************************************************************************** ************************************************************************ ** ** Copyright (c) 2004-2006 ARECA Co. Ltd. **        Erich Chen, Taipei Taiwan All rights reserved. ** ** Redistribution and use in source and binary forms,with or without ** modification,are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice,this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice,this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** 3. The name of the author may not be used to endorse or promote products **    derived from this software without specific prior written permission. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR ** IMPLIED WARRANTIES,INCLUDING,BUT NOT LIMITED TO,THE IMPLIED WARRANTIES ** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,INDIRECT, ** INCIDENTAL,SPECIAL,EXEMPLARY,OR CONSEQUENTIAL DAMAGES(INCLUDING,BUT ** NOT LIMITED TO,PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ** DATA,OR PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY,WHETHER IN CONTRACT,STRICT LIABILITY,OR TORT **(INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF ** THIS SOFTWARE,EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ************************************************************************** ** History ** **        REV#         DATE	            NAME	         DESCRIPTION **     1.00.00.00    3/31/2004	       Erich Chen	     First release **     1.20.00.02   11/29/2004         Erich Chen        bug fix with arcmsr_bus_reset when PHY error **     1.20.00.03    4/19/2005         Erich Chen        add SATA 24 Ports adapter type support **                                                       clean unused function **     1.20.00.12    9/12/2005         Erich Chen        bug fix with abort command handling,firmware version check **                                                       and firmware update notify for hardware bug fix **                                                       handling if none zero high part physical address  **                                                       of srb resource  ****************************************************************************************** ** $FreeBSD$ */
end_comment

begin_define
define|#
directive|define
name|ARCMSR_DEBUG
value|0
end_define

begin_comment
comment|/* ********************************** */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<isa/rtc.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_comment
comment|/*  ************************************************************************** ** Define the OS version specific locks  ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500005
end_if

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_define
define|#
directive|define
name|ARCMSR_LOCK_INIT
parameter_list|(
name|l
parameter_list|,
name|s
parameter_list|)
value|mtx_init(l, s,NULL, MTX_DEF|MTX_RECURSE)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_ACQUIRE
parameter_list|(
name|l
parameter_list|)
value|mtx_lock(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_RELEASE
parameter_list|(
name|l
parameter_list|)
value|mtx_unlock(l)
end_define

begin_typedef
typedef|typedef
name|struct
name|mtx
name|arcmsr_lock_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_define
define|#
directive|define
name|ARCMSR_LOCK_INIT
parameter_list|(
name|l
parameter_list|,
name|s
parameter_list|)
value|simple_lock_init(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_ACQUIRE
parameter_list|(
name|l
parameter_list|)
value|simple_lock(l)
end_define

begin_define
define|#
directive|define
name|ARCMSR_LOCK_RELEASE
parameter_list|(
name|l
parameter_list|)
value|simple_unlock(l)
end_define

begin_typedef
typedef|typedef
name|struct
name|simplelock
name|arcmsr_lock_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/arcmsr/arcmsr.h>
end_include

begin_comment
comment|/* ************************************************************************** ** __FreeBSD_version 502010 ************************************************************************** */
end_comment

begin_function_decl
specifier|static
name|struct
name|_SRB
modifier|*
name|arcmsr_get_freesrb
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|arcmsr_seek_cmd2abort
parameter_list|(
name|union
name|ccb
modifier|*
name|pabortccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|arcmsr_wait_msgint_ready
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|arcmsr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|arcmsr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|arcmsr_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|arcmsr_iop_ioctlcmd
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|,
name|u_int32_t
name|ioctl_cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_iop_parking
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_interrupt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_polling_srbdone
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|,
name|struct
name|_SRB
modifier|*
name|poll_srb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_free_resource
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_bus_reset
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_stop_adapter_bgrb
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_start_adapter_bgrb
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_iop_init
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_flush_adapter_cache
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_queue_wait2go_srb
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|,
name|struct
name|_SRB
modifier|*
name|pSRB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_post_wait2go_srb
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_post_Qbuffer
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_abort_allcmd
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_srb_complete
parameter_list|(
name|struct
name|_SRB
modifier|*
name|pSRB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_iop_reset
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_report_sense_info
parameter_list|(
name|struct
name|_SRB
modifier|*
name|pSRB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcmsr_build_srb
parameter_list|(
name|struct
name|_SRB
modifier|*
name|pSRB
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|u_int32_t
name|nseg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arcmsr_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ***************************************************************************************** ** Character device switch table **struct cdevsw { **	d_open_t		*d_open; **	d_close_t		*d_close; **	d_read_t		*d_read; **	d_write_t		*d_write; **	d_ioctl_t		*d_ioctl; **	d_poll_t		*d_poll; **	d_mmap_t		*d_mmap; **	d_strategy_t	*d_strategy; **	const char	    *d_name;	   "" base device name, e.g. 'vn'  **	int		         d_maj; **	d_dump_t	    *d_dump; **	d_psize_t	    *d_psize; **	u_int		     d_flags; **	int		         d_bmaj; **	d_kqfilter_t	*d_kqfilter;   "" additions below are not binary compatible with 4.2 and below  **}; ****************************************************************************************** */
end_comment

begin_comment
comment|/* ************************************************************************** ** Insert a delay in micro-seconds and milli-seconds. ** static void MDELAY(u_int32_t ms) { while (ms--) UDELAY(1000); } ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|UDELAY
parameter_list|(
name|u_int32_t
name|us
parameter_list|)
block|{
name|DELAY
argument_list|(
name|us
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** **  ************************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|arcmsr_map_freesrb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|arcmsr_executesrb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ************************************************************************** **  ************************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|arcmsr_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|arcmsr_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|arcmsr_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|arcmsr_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|arcmsr_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|arcmsr_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|arcmsr_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|arcmsr_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|arcmsr_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|arcmsr_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|arcmsr_driver
init|=
block|{
literal|"arcmsr"
block|,
name|arcmsr_methods
block|,
expr|sizeof
operator|(
expr|struct
name|_ACB
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|arcmsr_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|arcmsr
argument_list|,
name|pci
argument_list|,
name|arcmsr_driver
argument_list|,
name|arcmsr_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BUS_DMA_COHERENT
end_ifndef

begin_define
define|#
directive|define
name|BUS_DMA_COHERENT
value|0x04
end_define

begin_comment
comment|/* hint: map memory in a coherent way */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|501000
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|D_NEEDGIANT
end_ifndef

begin_define
define|#
directive|define
name|D_NEEDGIANT
value|0x00400000
end_define

begin_comment
comment|/* driver want Giant */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|D_VERSION
end_ifndef

begin_define
define|#
directive|define
name|D_VERSION
value|0x20011966
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|arcmsr_cdevsw
init|=
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|502010
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
endif|#
directive|endif
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|arcmsr_open
block|,
comment|/* open     */
operator|.
name|d_close
operator|=
name|arcmsr_close
block|,
comment|/* close    */
operator|.
name|d_ioctl
operator|=
name|arcmsr_ioctl
block|,
comment|/* ioctl    */
operator|.
name|d_name
operator|=
literal|"arcmsr"
block|,
comment|/* name     */
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ARCMSR_CDEV_MAJOR
value|180
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|arcmsr_cdevsw
init|=
block|{
name|arcmsr_open
block|,
comment|/* open     */
name|arcmsr_close
block|,
comment|/* close    */
name|noread
block|,
comment|/* read     */
name|nowrite
block|,
comment|/* write    */
name|arcmsr_ioctl
block|,
comment|/* ioctl    */
name|nopoll
block|,
comment|/* poll     */
name|nommap
block|,
comment|/* mmap     */
name|nostrategy
block|,
comment|/* strategy */
literal|"arcmsr"
block|,
comment|/* name     */
name|ARCMSR_CDEV_MAJOR
block|,
comment|/* major    */
name|nodump
block|,
comment|/* dump     */
name|nopsize
block|,
comment|/* psize    */
literal|0
comment|/* flags    */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_open
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_open
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_open
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
name|d_thread_t
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|struct
name|_ACB
modifier|*
name|pACB
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|_ACB
modifier|*
name|pACB
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pACB
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ************************************************************************** ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_close
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|int
name|flags
argument_list|,
name|int
name|fmt
argument_list|,
name|d_thread_t
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|struct
name|_ACB
modifier|*
name|pACB
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|_ACB
modifier|*
name|pACB
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pACB
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ************************************************************************** **ENOENT **ENOIOCTL **ENOMEM **EINVAL ************************************************************************** */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
end_if

begin_decl_stmt
specifier|static
name|int
name|arcmsr_ioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
expr|struct
name|proc
operator|*
name|proc
argument_list|)
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
decl|static
name|int
name|arcmsr_ioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
expr|struct
name|thread
operator|*
name|proc
argument_list|)
else|#
directive|else
decl|static
name|int
name|arcmsr_ioctl
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|u_long
name|ioctl_cmd
argument_list|,
name|caddr_t
name|arg
argument_list|,
name|int
name|flags
argument_list|,
name|d_thread_t
operator|*
name|proc
argument_list|)
endif|#
directive|endif
endif|#
directive|endif
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|struct
name|_ACB
modifier|*
name|pACB
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|_ACB
modifier|*
name|pACB
init|=
name|devclass_get_softc
argument_list|(
name|arcmsr_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pACB
operator|==
name|NULL
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
return|return
operator|(
name|arcmsr_iop_ioctlcmd
argument_list|(
name|pACB
argument_list|,
name|ioctl_cmd
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ******************************************************************************* ** Bring the controller to a quiescent state, ready for system suspend. ******************************************************************************* */
end_comment

begin_function
specifier|static
name|int
name|arcmsr_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|_ACB
modifier|*
name|pACB
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|)
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
operator|(
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
operator|)
argument_list|)
expr_stmt|;
comment|/* flush controller */
name|printf
argument_list|(
literal|"arcmsr%d: flushing cache...\n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
name|arcmsr_iop_parking
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ******************************************************************************* ** Bring the controller back to a state ready for operation. ******************************************************************************* */
end_comment

begin_function
specifier|static
name|int
name|arcmsr_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|_ACB
modifier|*
name|pACB
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|arcmsr_iop_init
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************************* **  Asynchronous notification handler. ********************************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_async
parameter_list|(
name|void
modifier|*
name|cb_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|_ACB
modifier|*
name|pACB
decl_stmt|;
name|u_int8_t
name|target_id
decl_stmt|,
name|target_lun
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|u_int32_t
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|cb_arg
expr_stmt|;
name|pACB
operator|=
operator|(
expr|struct
name|_ACB
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_LOST_DEVICE
case|:
name|target_id
operator|=
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|target_lun
operator|=
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target_id
operator|>
name|ARCMSR_MAX_TARGETID
operator|)
operator|||
operator|(
name|target_lun
operator|>
name|ARCMSR_MAX_TARGETLUN
operator|)
condition|)
block|{
break|break;
block|}
name|printf
argument_list|(
literal|"%s:scsi id%d lun%d device lost \n"
argument_list|,
name|device_get_name
argument_list|(
name|pACB
operator|->
name|pci_dev
argument_list|)
argument_list|,
name|target_id
argument_list|,
name|target_lun
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** ** ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_flush_adapter_cache
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
block|{
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_FLUSH_CACHE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  **   ** ********************************************************************** */
end_comment

begin_function
specifier|static
name|u_int8_t
name|arcmsr_wait_msgint_ready
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
block|{
name|u_int32_t
name|Index
decl_stmt|;
name|u_int8_t
name|Retries
init|=
literal|0x00
decl_stmt|;
do|do
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
literal|100
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intstatus
argument_list|)
operator|&
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INT
condition|)
block|{
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intstatus
argument_list|,
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INT
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
return|return
literal|0x00
return|;
block|}
comment|/* one us delay	*/
name|UDELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
comment|/*max 1 seconds*/
block|}
do|while
condition|(
name|Retries
operator|++
operator|<
literal|20
condition|)
do|;
comment|/*max 20 sec*/
return|return
literal|0xff
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ** **  Q back this SRB into ACB ArraySRB ** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_srb_complete
parameter_list|(
name|struct
name|_SRB
modifier|*
name|pSRB
parameter_list|)
block|{
name|u_int32_t
name|s
decl_stmt|;
name|struct
name|_ACB
modifier|*
name|pACB
init|=
name|pSRB
operator|->
name|pACB
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
init|=
name|pSRB
operator|->
name|pccb
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|pACB
operator|->
name|srboutstandingcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_DONE
expr_stmt|;
name|pSRB
operator|->
name|srb_flags
operator|=
literal|0
expr_stmt|;
name|pACB
operator|->
name|psrbringQ
index|[
name|pACB
operator|->
name|srb_doneindex
index|]
operator|=
name|pSRB
expr_stmt|;
name|pACB
operator|->
name|srb_doneindex
operator|++
expr_stmt|;
name|pACB
operator|->
name|srb_doneindex
operator|%=
name|ARCMSR_MAX_FREESRB_NUM
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **       if scsi error do auto request sense ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_report_sense_info
parameter_list|(
name|struct
name|_SRB
modifier|*
name|pSRB
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|pccb
init|=
name|pSRB
operator|->
name|pccb
decl_stmt|;
name|PSENSE_DATA
name|psenseBuffer
init|=
operator|(
name|PSENSE_DATA
operator|)
operator|&
name|pccb
operator|->
name|csio
operator|.
name|sense_data
decl_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|pccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
if|if
condition|(
name|psenseBuffer
condition|)
block|{
name|memset
argument_list|(
name|psenseBuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|psenseBuffer
argument_list|,
name|pSRB
operator|->
name|arcmsr_cdb
operator|.
name|SenseData
argument_list|,
name|get_min
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_SENSE_DATA
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|psenseBuffer
operator|->
name|ErrorCode
operator|=
literal|0x70
expr_stmt|;
name|psenseBuffer
operator|->
name|Valid
operator|=
literal|1
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************* ** to insert pSRB into tail of pACB wait exec srbQ  ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_queue_wait2go_srb
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|,
name|struct
name|_SRB
modifier|*
name|pSRB
parameter_list|)
block|{
name|u_int32_t
name|s
decl_stmt|;
name|u_int32_t
name|i
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
operator|=
name|pSRB
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|pACB
operator|->
name|srbwait2gocount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|++
expr_stmt|;
name|i
operator|%=
name|ARCMSR_MAX_OUTSTANDING_CMD
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************* **  ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_abort_allcmd
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
block|{
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_ABORT_CMD
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* **************************************************************************** ** Routine Description: Reset 80331 iop. **           Arguments:  **        Return Value: Nothing. **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_reset
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
block|{
name|struct
name|_SRB
modifier|*
name|pSRB
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|,
name|mask
decl_stmt|;
name|u_int32_t
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pACB
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: iop reset srboutstandingcount=%d \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|pACB
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|)
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
argument_list|)
expr_stmt|;
comment|/* talk to iop 331 outstanding command aborted*/
name|arcmsr_abort_allcmd
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: iop reset wait 'abort all outstanding command' timeout \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
comment|/*clear all outbound posted Q*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|;
name|i
operator|++
control|)
block|{
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_queueport
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|pSRB
operator|=
name|pACB
operator|->
name|psrb_pool
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
name|pSRB
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* enable all outbound interrupt */
name|mask
operator|=
operator|~
operator|(
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE
operator|)
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
name|intmask_org
operator|&
name|mask
argument_list|)
expr_stmt|;
comment|/* post abort all outstanding command message to RAID controller */
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pACB
operator|->
name|srbwait2gocount
operator|>
literal|0
condition|)
block|{
name|pSRB
operator|=
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d:iop reset abort command srbwait2gocount=%d \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|pACB
operator|->
name|srbwait2gocount
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pSRB
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|pACB
operator|->
name|srbwait2gocount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|i
operator|%=
name|ARCMSR_MAX_OUTSTANDING_CMD
expr_stmt|;
block|}
name|atomic_set_int
argument_list|(
operator|&
name|pACB
operator|->
name|srboutstandingcount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  ** PAGE_SIZE=4096 or 8192,PAGE_SHIFT=12 ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_build_srb
parameter_list|(
name|struct
name|_SRB
modifier|*
name|pSRB
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|u_int32_t
name|nseg
parameter_list|)
block|{
name|struct
name|_ARCMSR_CDB
modifier|*
name|pARCMSR_CDB
init|=
operator|&
name|pSRB
operator|->
name|arcmsr_cdb
decl_stmt|;
name|u_int8_t
modifier|*
name|psge
init|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|pARCMSR_CDB
operator|->
name|u
decl_stmt|;
name|u_int32_t
name|address_lo
decl_stmt|,
name|address_hi
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
init|=
name|pSRB
operator|->
name|pccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|pcsio
init|=
operator|&
name|pccb
operator|->
name|csio
decl_stmt|;
name|u_int32_t
name|arccdbsize
init|=
literal|0x30
decl_stmt|;
name|memset
argument_list|(
name|pARCMSR_CDB
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_ARCMSR_CDB
argument_list|)
argument_list|)
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|Bus
operator|=
literal|0
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|TargetID
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|LUN
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|Function
operator|=
literal|1
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|CdbLength
operator|=
operator|(
name|u_int8_t
operator|)
name|pcsio
operator|->
name|cdb_len
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|Context
operator|=
operator|(
name|unsigned
name|long
operator|)
name|pARCMSR_CDB
expr_stmt|;
name|bcopy
argument_list|(
name|pcsio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|pARCMSR_CDB
operator|->
name|Cdb
argument_list|,
name|pcsio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|struct
name|_ACB
modifier|*
name|pACB
init|=
name|pSRB
operator|->
name|pACB
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|u_int32_t
name|length
decl_stmt|,
name|i
decl_stmt|,
name|cdb_sgcount
init|=
literal|0
decl_stmt|;
comment|/* map stor port SG list to our iop SG List.*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get the physical address of the current data pointer */
name|length
operator|=
operator|(
name|u_int32_t
operator|)
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
name|address_lo
operator|=
name|dma_addr_lo32
argument_list|(
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|address_hi
operator|=
name|dma_addr_hi32
argument_list|(
name|dm_segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_hi
operator|==
literal|0
condition|)
block|{
name|struct
name|_SG32ENTRY
modifier|*
name|pdma_sg
init|=
operator|(
expr|struct
name|_SG32ENTRY
operator|*
operator|)
name|psge
decl_stmt|;
name|pdma_sg
operator|->
name|address
operator|=
name|address_lo
expr_stmt|;
name|pdma_sg
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|_SG32ENTRY
argument_list|)
expr_stmt|;
name|arccdbsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|_SG32ENTRY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|sg64s_size
init|=
literal|0
decl_stmt|,
name|tmplength
init|=
name|length
decl_stmt|;
if|#
directive|if
name|ARCMSR_DEBUG
name|printf
argument_list|(
literal|"arcmsr%d: !!!!!!!!!!! address_hi=%x \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|address_hi
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
name|u_int64_t
name|span4G
decl_stmt|,
name|length0
decl_stmt|;
name|struct
name|_SG64ENTRY
modifier|*
name|pdma_sg
init|=
operator|(
expr|struct
name|_SG64ENTRY
operator|*
operator|)
name|psge
decl_stmt|;
name|span4G
operator|=
operator|(
name|u_int64_t
operator|)
name|address_lo
operator|+
name|tmplength
expr_stmt|;
name|pdma_sg
operator|->
name|addresshigh
operator|=
name|address_hi
expr_stmt|;
name|pdma_sg
operator|->
name|address
operator|=
name|address_lo
expr_stmt|;
if|if
condition|(
name|span4G
operator|>
literal|0x100000000
condition|)
block|{
comment|/*see if cross 4G boundary*/
name|length0
operator|=
literal|0x100000000
operator|-
name|address_lo
expr_stmt|;
name|pdma_sg
operator|->
name|length
operator|=
operator|(
name|u_int32_t
operator|)
name|length0
operator||
name|IS_SG64_ADDR
expr_stmt|;
name|address_hi
operator|=
name|address_hi
operator|+
literal|1
expr_stmt|;
name|address_lo
operator|=
literal|0
expr_stmt|;
name|tmplength
operator|=
name|tmplength
operator|-
operator|(
name|u_int32_t
operator|)
name|length0
expr_stmt|;
name|sg64s_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|_SG64ENTRY
argument_list|)
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|_SG64ENTRY
argument_list|)
expr_stmt|;
name|cdb_sgcount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pdma_sg
operator|->
name|length
operator|=
name|tmplength
operator||
name|IS_SG64_ADDR
expr_stmt|;
name|sg64s_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|_SG64ENTRY
argument_list|)
expr_stmt|;
name|psge
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|_SG64ENTRY
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|arccdbsize
operator|+=
name|sg64s_size
expr_stmt|;
block|}
name|cdb_sgcount
operator|++
expr_stmt|;
block|}
name|pARCMSR_CDB
operator|->
name|sgcount
operator|=
operator|(
name|u_int8_t
operator|)
name|cdb_sgcount
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|DataLength
operator|=
name|pcsio
operator|->
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|arccdbsize
operator|>
literal|256
condition|)
block|{
name|pARCMSR_CDB
operator|->
name|Flags
operator||=
name|ARCMSR_CDB_FLAG_SGL_BSIZE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|pARCMSR_CDB
operator|->
name|Flags
operator||=
name|ARCMSR_CDB_FLAG_WRITE
expr_stmt|;
name|pSRB
operator|->
name|srb_flags
operator||=
name|SRB_FLAG_WRITE
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ** **	arcmsr_post_srb - Send a protocol specific ARC send postcard to a AIOC . **	handle: Handle of registered ARC protocol driver **	adapter_id: AIOC unique identifier(integer) **	pPOSTCARD_SEND: Pointer to ARC send postcard ** **	This routine posts a ARC send postcard to the request post FIFO of a **	specific ARC adapter. **                              ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_post_srb
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|,
name|struct
name|_SRB
modifier|*
name|pSRB
parameter_list|)
block|{
name|u_int32_t
name|cdb_shifted_phyaddr
init|=
operator|(
name|u_int32_t
operator|)
name|pSRB
operator|->
name|cdb_shifted_phyaddr
decl_stmt|;
name|struct
name|_ARCMSR_CDB
modifier|*
name|pARCMSR_CDB
init|=
operator|(
expr|struct
name|_ARCMSR_CDB
operator|*
operator|)
operator|&
name|pSRB
operator|->
name|arcmsr_cdb
decl_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|pACB
operator|->
name|srboutstandingcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_START
expr_stmt|;
if|if
condition|(
name|pARCMSR_CDB
operator|->
name|Flags
operator|&
name|ARCMSR_CDB_FLAG_SGL_BSIZE
condition|)
block|{
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_queueport
argument_list|,
name|cdb_shifted_phyaddr
operator||
name|ARCMSR_SRBPOST_FLAG_SGL_BSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_queueport
argument_list|,
name|cdb_shifted_phyaddr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ** ** ************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_post_wait2go_srb
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
block|{
name|u_int32_t
name|s
decl_stmt|;
name|struct
name|_SRB
modifier|*
name|pSRB
decl_stmt|;
name|u_int32_t
name|i
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pACB
operator|->
name|srbwait2gocount
operator|>
literal|0
operator|)
operator|&&
operator|(
name|pACB
operator|->
name|srboutstandingcount
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
operator|)
condition|)
block|{
name|pSRB
operator|=
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|!=
name|NULL
condition|)
block|{
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|arcmsr_post_srb
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|pACB
operator|->
name|srbwait2gocount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|i
operator|%=
name|ARCMSR_MAX_OUTSTANDING_CMD
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **   Function: arcmsr_post_Qbuffer **     Output:  ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_post_Qbuffer
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
block|{
name|u_int32_t
name|s
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|struct
name|_QBUFFER
modifier|*
name|pwbuffer
init|=
operator|(
expr|struct
name|_QBUFFER
operator|*
operator|)
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|ioctl_wbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pwbuffer
operator|->
name|data
decl_stmt|;
name|u_int32_t
name|allxfer_len
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pACB
operator|->
name|wqbuf_firstindex
operator|!=
name|pACB
operator|->
name|wqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|124
operator|)
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|pACB
operator|->
name|wqbuffer
index|[
name|pACB
operator|->
name|wqbuf_firstindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|iop_data
argument_list|,
name|pQbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|wqbuf_firstindex
operator|++
expr_stmt|;
name|pACB
operator|->
name|wqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
name|pwbuffer
operator|->
name|data_len
operator|=
name|allxfer_len
expr_stmt|;
comment|/* 	** push inbound doorbell and wait reply at hwinterrupt routine for next Qbuffer post 	*/
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_stop_adapter_bgrb
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
block|{
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_MSG_STOP_BGRB
expr_stmt|;
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_STOP_BGRB
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|psim
parameter_list|)
block|{
name|arcmsr_interrupt
argument_list|(
name|cam_sim_softc
argument_list|(
name|psim
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **   Function:  arcmsr_interrupt **     Output:  void **   CAM  Status field values    **typedef enum { **	CAM_REQ_INPROG,		   CCB request is in progress    **	CAM_REQ_CMP,		   CCB request completed without error    **	CAM_REQ_ABORTED,	   CCB request aborted by the host    **	CAM_UA_ABORT,		   Unable to abort CCB request    **	CAM_REQ_CMP_ERR,	   CCB request completed with an error    **	CAM_BUSY,		       CAM subsytem is busy    **	CAM_REQ_INVALID,	   CCB request was invalid    **	CAM_PATH_INVALID,	   Supplied Path ID is invalid    **	CAM_DEV_NOT_THERE,	   SCSI Device Not Installed/there    **	CAM_UA_TERMIO,		   Unable to terminate I/O CCB request    **	CAM_SEL_TIMEOUT,	   Target Selection Timeout    **	CAM_CMD_TIMEOUT,	   Command timeout    **	CAM_SCSI_STATUS_ERROR,	   SCSI error, look at error code in CCB    **	CAM_MSG_REJECT_REC,	   Message Reject Received    **	CAM_SCSI_BUS_RESET,	   SCSI Bus Reset Sent/Received    **	CAM_UNCOR_PARITY,	   Uncorrectable parity error occurred    **	CAM_AUTOSENSE_FAIL=0x10,   Autosense: request sense cmd fail    **	CAM_NO_HBA,		   No HBA Detected error    **	CAM_DATA_RUN_ERR,	   Data Overrun error    **	CAM_UNEXP_BUSFREE,	   Unexpected Bus Free    **	CAM_SEQUENCE_FAIL,	   Target Bus Phase Sequence Failure    **	CAM_CCB_LEN_ERR,	   CCB length supplied is inadequate    **	CAM_PROVIDE_FAIL,	   Unable to provide requested capability    **	CAM_BDR_SENT,		   A SCSI BDR msg was sent to target    **	CAM_REQ_TERMIO,		   CCB request terminated by the host    **	CAM_UNREC_HBA_ERROR,	   Unrecoverable Host Bus Adapter Error    **	CAM_REQ_TOO_BIG,	   The request was too large for this host    **	CAM_REQUEUE_REQ,	   **				 * This request should be requeued to preserve **				 * transaction ordering.  This typically occurs **				 * when the SIM recognizes an error that should **				 * freeze the queue and must place additional **				 * requests for the target at the sim level **				 * back into the XPT queue. **				    **	CAM_IDE=0x33,		   Initiator Detected Error    **	CAM_RESRC_UNAVAIL,	   Resource Unavailable    **	CAM_UNACKED_EVENT,	   Unacknowledged Event by Host    **	CAM_MESSAGE_RECV,	   Message Received in Host Target Mode    **	CAM_INVALID_CDB,	   Invalid CDB received in Host Target Mode    **	CAM_LUN_INVALID,	   Lun supplied is invalid    **	CAM_TID_INVALID,	   Target ID supplied is invalid    **	CAM_FUNC_NOTAVAIL,	   The requested function is not available    **	CAM_NO_NEXUS,		   Nexus is not established    **	CAM_IID_INVALID,	   The initiator ID is invalid    **	CAM_CDB_RECVD,		   The SCSI CDB has been received    **	CAM_LUN_ALRDY_ENA,	   The LUN is already eanbeld for target mode    **	CAM_SCSI_BUSY,		   SCSI Bus Busy    ** **	CAM_DEV_QFRZN=0x40,	   The DEV queue is frozen w/this err    ** **				   Autosense data valid for target    **	CAM_AUTOSNS_VALID=0x80, **	CAM_RELEASE_SIMQ=0x100,   SIM ready to take more commands    **	CAM_SIM_QUEUED  =0x200,   SIM has this command in it's queue    ** **	CAM_STATUS_MASK=0x3F,	   Mask bits for just the status #    ** **				   Target Specific Adjunct Status    **	CAM_SENT_SENSE=0x40000000	   sent sense with status    **} cam_status; ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_interrupt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|_ACB
modifier|*
name|pACB
init|=
operator|(
expr|struct
name|_ACB
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|_SRB
modifier|*
name|pSRB
decl_stmt|;
name|u_int32_t
name|flag_srb
decl_stmt|,
name|outbound_intstatus
decl_stmt|,
name|outbound_doorbell
decl_stmt|;
comment|/* 	********************************************* 	**   check outbound intstatus ÀË¹î¦³µL¶l®t«öªù¹a 	********************************************* 	*/
name|outbound_intstatus
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intstatus
argument_list|)
operator|&
name|pACB
operator|->
name|outbound_int_enable
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intstatus
argument_list|,
name|outbound_intstatus
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
if|if
condition|(
name|outbound_intstatus
operator|&
name|ARCMSR_MU_OUTBOUND_DOORBELL_INT
condition|)
block|{
comment|/* 		********************************************* 		**  DOORBELL ¥m¾´! ¬O§_¦³¶l¥ó­nÃ±¦¬ 		********************************************* 		*/
name|outbound_doorbell
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_doorbell
argument_list|)
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_doorbell
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
comment|/*clear interrupt */
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK
condition|)
block|{
name|struct
name|_QBUFFER
modifier|*
name|prbuffer
init|=
operator|(
expr|struct
name|_QBUFFER
operator|*
operator|)
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|ioctl_rbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|prbuffer
operator|->
name|data
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int32_t
name|my_empty_len
decl_stmt|,
name|iop_len
decl_stmt|,
name|rqbuf_firstindex
decl_stmt|,
name|rqbuf_lastindex
decl_stmt|;
comment|/*check this iop data if overflow my rqbuffer*/
name|rqbuf_lastindex
operator|=
name|pACB
operator|->
name|rqbuf_lastindex
expr_stmt|;
name|rqbuf_firstindex
operator|=
name|pACB
operator|->
name|rqbuf_firstindex
expr_stmt|;
name|iop_len
operator|=
name|prbuffer
operator|->
name|data_len
expr_stmt|;
name|my_empty_len
operator|=
operator|(
name|rqbuf_firstindex
operator|-
name|rqbuf_lastindex
operator|-
literal|1
operator|)
operator|&
operator|(
name|ARCMSR_MAX_QBUFFER
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|my_empty_len
operator|>=
name|iop_len
condition|)
block|{
while|while
condition|(
name|iop_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|pACB
operator|->
name|rqbuffer
index|[
name|pACB
operator|->
name|rqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|iop_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|rqbuf_lastindex
operator|++
expr_stmt|;
name|pACB
operator|->
name|rqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|iop_len
operator|--
expr_stmt|;
block|}
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
else|else
block|{
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_OUTBOUND_IOP331_DATA_READ_OK
condition|)
block|{
comment|/* 			********************************************* 			**           ¬Ý¬Ý¬O§_ÁÙ¦³¶l¥ó­n¶¶¹D±H¥X 			********************************************* 			*/
if|if
condition|(
name|pACB
operator|->
name|wqbuf_firstindex
operator|!=
name|pACB
operator|->
name|wqbuf_lastindex
condition|)
block|{
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|struct
name|_QBUFFER
modifier|*
name|pwbuffer
init|=
operator|(
expr|struct
name|_QBUFFER
operator|*
operator|)
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|ioctl_wbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pwbuffer
operator|->
name|data
decl_stmt|;
name|u_int32_t
name|allxfer_len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|pACB
operator|->
name|wqbuf_firstindex
operator|!=
name|pACB
operator|->
name|wqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|124
operator|)
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|pACB
operator|->
name|wqbuffer
index|[
name|pACB
operator|->
name|wqbuf_firstindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|iop_data
argument_list|,
name|pQbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|wqbuf_firstindex
operator|++
expr_stmt|;
name|pACB
operator|->
name|wqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
name|pwbuffer
operator|->
name|data_len
operator|=
name|allxfer_len
expr_stmt|;
comment|/* 				** push inbound doorbell tell iop driver data write ok and wait reply on next hwinterrupt for next Qbuffer post 				*/
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_IOCTL_WQBUFFER_CLEARED
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|outbound_intstatus
operator|&
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
condition|)
block|{
name|int
name|target
decl_stmt|,
name|lun
decl_stmt|;
comment|/* 		***************************************************************************** 		**               areca cdb command done 		***************************************************************************** 		*/
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|flag_srb
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_queueport
argument_list|)
operator|)
operator|==
literal|0xFFFFFFFF
condition|)
block|{
break|break;
comment|/*chip FIFO no srb for completion already*/
block|}
comment|/* check if command done with no error*/
name|pSRB
operator|=
operator|(
expr|struct
name|_SRB
operator|*
operator|)
operator|(
name|pACB
operator|->
name|vir2phy_offset
operator|+
operator|(
name|flag_srb
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
comment|/*frame must be 32 bytes aligned*/
if|if
condition|(
operator|(
name|pSRB
operator|->
name|pACB
operator|!=
name|pACB
operator|)
operator|||
operator|(
name|pSRB
operator|->
name|startdone
operator|!=
name|ARCMSR_SRB_START
operator|)
condition|)
block|{
if|if
condition|(
name|pSRB
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d srb='%p' isr command abort successfully \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"arcmsr%d: isr get an illegal srb command done acb='%p' srb='%p' srbacb='%p' startdone=0x%x srboutstandingcount=%d \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|pACB
argument_list|,
name|pSRB
argument_list|,
name|pSRB
operator|->
name|pACB
argument_list|,
name|pSRB
operator|->
name|startdone
argument_list|,
name|pACB
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|target
operator|=
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pACB
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|ARECA_RAID_GONE
condition|)
block|{
name|pACB
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
block|}
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|pSRB
operator|->
name|arcmsr_cdb
operator|.
name|DeviceStatus
condition|)
block|{
case|case
name|ARCMSR_DEV_SELECT_TIMEOUT
case|:
block|{
name|pACB
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_DEV_ABORTED
case|:
case|case
name|ARCMSR_DEV_INIT_FAIL
case|:
block|{
name|pACB
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCSISTAT_CHECK_CONDITION
case|:
block|{
name|pACB
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
name|arcmsr_report_sense_info
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* error occur Q all error srb to errorsrbpending Q*/
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d isr get command error done, but got unknow DeviceStatus=0x%x \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|pSRB
operator|->
name|arcmsr_cdb
operator|.
name|DeviceStatus
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNCOR_PARITY
expr_stmt|;
comment|/*unknow error or crc error just for retry*/
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*drain reply FIFO*/
block|}
if|if
condition|(
name|pACB
operator|->
name|srbwait2gocount
operator|!=
literal|0
condition|)
block|{
name|arcmsr_post_wait2go_srb
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
comment|/*try to post all pending srb*/
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ******************************************************************************* ******************************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_parking
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
block|{
if|if
condition|(
name|pACB
operator|!=
name|NULL
condition|)
block|{
comment|/* stop adapter background rebuild */
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_MSG_START_BGRB
condition|)
block|{
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|arcmsr_stop_adapter_bgrb
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d:iop parking wait 'stop adapter rebulid' timeout \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
name|arcmsr_flush_adapter_cache
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d:iop parking wait 'flush adapter cache' timeout \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* *********************************************************************** ** **int	copyin __P((const void *udaddr, void *kaddr, size_t len)); **int	copyout __P((const void *kaddr, void *udaddr, size_t len)); ** **ENOENT     "" No such file or directory "" **ENOIOCTL   "" ioctl not handled by this layer "" **ENOMEM     "" Cannot allocate memory "" **EINVAL     "" Invalid argument "" ************************************************************************ */
end_comment

begin_function
name|u_int32_t
name|arcmsr_iop_ioctlcmd
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|,
name|u_int32_t
name|ioctl_cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|_CMD_IO_CONTROL
modifier|*
name|pccbioctl
init|=
operator|(
expr|struct
name|_CMD_IO_CONTROL
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|pccbioctl
operator|->
name|Signature
argument_list|,
literal|"ARCMSR"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|ioctl_cmd
condition|)
block|{
case|case
name|ARCMSR_IOCTL_READ_RQBUFFER
case|:
block|{
name|u_int32_t
name|s
decl_stmt|;
name|struct
name|_CMD_IOCTL_FIELD
modifier|*
name|pccbioctlfld
init|=
operator|(
expr|struct
name|_CMD_IOCTL_FIELD
operator|*
operator|)
name|arg
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|ptmpQbuffer
init|=
name|pccbioctlfld
operator|->
name|ioctldatabuffer
decl_stmt|;
name|u_int32_t
name|allxfer_len
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pACB
operator|->
name|rqbuf_firstindex
operator|!=
name|pACB
operator|->
name|rqbuf_lastindex
operator|)
operator|&&
operator|(
name|allxfer_len
operator|<
literal|1031
operator|)
condition|)
block|{
comment|/*copy READ QBUFFER to srb*/
name|pQbuffer
operator|=
operator|&
name|pACB
operator|->
name|rqbuffer
index|[
name|pACB
operator|->
name|rqbuf_firstindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|ptmpQbuffer
argument_list|,
name|pQbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|rqbuf_firstindex
operator|++
expr_stmt|;
name|pACB
operator|->
name|rqbuf_firstindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|ptmpQbuffer
operator|++
expr_stmt|;
name|allxfer_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|struct
name|_QBUFFER
modifier|*
name|prbuffer
init|=
operator|(
expr|struct
name|_QBUFFER
operator|*
operator|)
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|ioctl_rbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|iop_data
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|prbuffer
operator|->
name|data
decl_stmt|;
name|u_int32_t
name|iop_len
decl_stmt|;
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|iop_len
operator|=
operator|(
name|u_int32_t
operator|)
name|prbuffer
operator|->
name|data_len
expr_stmt|;
comment|/*this iop data does no chance to make me overflow again here, so just do it*/
while|while
condition|(
name|iop_len
operator|>
literal|0
condition|)
block|{
name|pQbuffer
operator|=
operator|&
name|pACB
operator|->
name|rqbuffer
index|[
name|pACB
operator|->
name|rqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|iop_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|rqbuf_lastindex
operator|++
expr_stmt|;
name|pACB
operator|->
name|rqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|iop_data
operator|++
expr_stmt|;
name|iop_len
operator|--
expr_stmt|;
block|}
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
name|pccbioctl
operator|->
name|Length
operator|=
name|allxfer_len
expr_stmt|;
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_OK
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
case|case
name|ARCMSR_IOCTL_WRITE_WQBUFFER
case|:
block|{
name|u_int32_t
name|s
decl_stmt|;
name|struct
name|_CMD_IOCTL_FIELD
modifier|*
name|pccbioctlfld
init|=
operator|(
expr|struct
name|_CMD_IOCTL_FIELD
operator|*
operator|)
name|arg
decl_stmt|;
name|u_int32_t
name|my_empty_len
decl_stmt|,
name|user_len
decl_stmt|,
name|wqbuf_firstindex
decl_stmt|,
name|wqbuf_lastindex
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|u_int8_t
modifier|*
name|ptmpuserbuffer
init|=
name|pccbioctlfld
operator|->
name|ioctldatabuffer
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|user_len
operator|=
name|pccbioctl
operator|->
name|Length
expr_stmt|;
comment|/*check if data xfer length of this request will overflow my array qbuffer */
name|wqbuf_lastindex
operator|=
name|pACB
operator|->
name|wqbuf_lastindex
expr_stmt|;
name|wqbuf_firstindex
operator|=
name|pACB
operator|->
name|wqbuf_firstindex
expr_stmt|;
name|my_empty_len
operator|=
operator|(
name|wqbuf_firstindex
operator|-
name|wqbuf_lastindex
operator|-
literal|1
operator|)
operator|&
operator|(
name|ARCMSR_MAX_QBUFFER
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|my_empty_len
operator|>=
name|user_len
condition|)
block|{
while|while
condition|(
name|user_len
operator|>
literal|0
condition|)
block|{
comment|/*copy srb data to wqbuffer*/
name|pQbuffer
operator|=
operator|&
name|pACB
operator|->
name|wqbuffer
index|[
name|pACB
operator|->
name|wqbuf_lastindex
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pQbuffer
argument_list|,
name|ptmpuserbuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|wqbuf_lastindex
operator|++
expr_stmt|;
name|pACB
operator|->
name|wqbuf_lastindex
operator|%=
name|ARCMSR_MAX_QBUFFER
expr_stmt|;
comment|/*if last index number set it to 0 */
name|ptmpuserbuffer
operator|++
expr_stmt|;
name|user_len
operator|--
expr_stmt|;
block|}
comment|/*post fist Qbuffer*/
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_IOCTL_WQBUFFER_CLEARED
condition|)
block|{
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOCTL_WQBUFFER_CLEARED
expr_stmt|;
name|arcmsr_post_Qbuffer
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
block|}
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_OK
expr_stmt|;
block|}
else|else
block|{
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_ERROR
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
case|case
name|ARCMSR_IOCTL_CLEAR_RQBUFFER
case|:
block|{
name|u_int32_t
name|s
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
init|=
name|pACB
operator|->
name|rqbuffer
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_IOCTL_RQBUFFER_CLEARED
expr_stmt|;
name|pACB
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|pACB
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_OK
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
case|case
name|ARCMSR_IOCTL_CLEAR_WQBUFFER
case|:
block|{
name|u_int32_t
name|s
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
init|=
name|pACB
operator|->
name|wqbuffer
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_IOCTL_WQBUFFER_CLEARED
expr_stmt|;
name|pACB
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|pACB
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
name|ARCMSR_MAX_QBUFFER
argument_list|)
expr_stmt|;
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_OK
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
case|case
name|ARCMSR_IOCTL_CLEAR_ALLQBUFFER
case|:
block|{
name|u_int32_t
name|s
decl_stmt|;
name|u_int8_t
modifier|*
name|pQbuffer
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_IOPDATA_OVERFLOW
condition|)
block|{
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOPDATA_OVERFLOW
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
comment|/*signature, let IOP331 know data has been readed */
block|}
name|pACB
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_IOCTL_WQBUFFER_CLEARED
operator||
name|ACB_F_IOCTL_RQBUFFER_CLEARED
operator|)
expr_stmt|;
name|pACB
operator|->
name|rqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|pACB
operator|->
name|rqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|pACB
operator|->
name|wqbuf_firstindex
operator|=
literal|0
expr_stmt|;
name|pACB
operator|->
name|wqbuf_lastindex
operator|=
literal|0
expr_stmt|;
name|pQbuffer
operator|=
name|pACB
operator|->
name|rqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pQbuffer
operator|=
name|pACB
operator|->
name|wqbuffer
expr_stmt|;
name|memset
argument_list|(
name|pQbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_QBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_OK
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
case|case
name|ARCMSR_IOCTL_REQUEST_RETURNCODE_3F
case|:
block|{
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_3F
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
case|case
name|ARCMSR_IOCTL_SAY_HELLO
case|:
block|{
name|struct
name|_CMD_IOCTL_FIELD
modifier|*
name|pccbioctlfld
init|=
operator|(
expr|struct
name|_CMD_IOCTL_FIELD
operator|*
operator|)
name|arg
decl_stmt|;
name|u_int8_t
modifier|*
name|hello_string
init|=
literal|"Hello! I am ARCMSR"
decl_stmt|;
name|u_int8_t
modifier|*
name|puserbuffer
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pccbioctlfld
operator|->
name|ioctldatabuffer
decl_stmt|;
if|if
condition|(
name|memcpy
argument_list|(
name|puserbuffer
argument_list|,
name|hello_string
argument_list|,
operator|(
name|int16_t
operator|)
name|strlen
argument_list|(
name|hello_string
argument_list|)
argument_list|)
condition|)
block|{
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_ERROR
expr_stmt|;
return|return
name|ENOIOCTL
return|;
block|}
name|pccbioctl
operator|->
name|ReturnCode
operator|=
name|ARCMSR_IOCTL_RETURNCODE_OK
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
case|case
name|ARCMSR_IOCTL_SAY_GOODBYE
case|:
block|{
name|arcmsr_iop_parking
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
case|case
name|ARCMSR_IOCTL_FLUSH_ADAPTER_CACHE
case|:
block|{
name|arcmsr_flush_adapter_cache
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: ioctl flush cache wait 'flush adapter cache' timeout \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
return|return
name|ARC_IOCTL_SUCCESS
return|;
block|}
break|break;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************** ** ************************************************************************** */
end_comment

begin_function
name|struct
name|_SRB
modifier|*
name|arcmsr_get_freesrb
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
block|{
name|struct
name|_SRB
modifier|*
name|pSRB
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|s
decl_stmt|;
name|u_int32_t
name|srb_startindex
decl_stmt|,
name|srb_doneindex
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|srb_doneindex
operator|=
name|pACB
operator|->
name|srb_doneindex
expr_stmt|;
name|srb_startindex
operator|=
name|pACB
operator|->
name|srb_startindex
expr_stmt|;
name|pSRB
operator|=
name|pACB
operator|->
name|psrbringQ
index|[
name|srb_startindex
index|]
expr_stmt|;
name|srb_startindex
operator|++
expr_stmt|;
name|srb_startindex
operator|%=
name|ARCMSR_MAX_FREESRB_NUM
expr_stmt|;
if|if
condition|(
name|srb_doneindex
operator|!=
name|srb_startindex
condition|)
block|{
name|pACB
operator|->
name|srb_startindex
operator|=
name|srb_startindex
expr_stmt|;
block|}
else|else
block|{
name|pSRB
operator|=
name|NULL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|pSRB
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ********************************************************************* ** ** ** ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_executesrb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|_SRB
modifier|*
name|pSRB
init|=
operator|(
expr|struct
name|_SRB
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|_ACB
modifier|*
name|pACB
init|=
operator|(
expr|struct
name|_ACB
operator|*
operator|)
name|pSRB
operator|->
name|pACB
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
decl_stmt|;
name|int
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|pccb
operator|=
name|pSRB
operator|->
name|pccb
expr_stmt|;
name|target
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: unexpected error %x returned from 'bus_dmamap_load' \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|pccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_TOO_BIG
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_BUS_RESET
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: bus reset and return busy \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pACB
operator|->
name|devstate
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|ARECA_RAID_GONE
condition|)
block|{
name|u_int8_t
name|block_cmd
decl_stmt|;
name|block_cmd
operator|=
name|pccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|block_cmd
operator|==
literal|0x08
operator|||
name|block_cmd
operator|==
literal|0x0a
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d:block 'read/write' command with gone raid volume Cmd=%2x,TargetId=%d,Lun=%d \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|block_cmd
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|arcmsr_build_srb
argument_list|(
name|pSRB
argument_list|,
name|dm_segs
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
return|return;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|srboutstandingcount
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|)
block|{
comment|/* 		****************************************************************** 		** and we can make sure there were no pending srb in this duration 		****************************************************************** 		*/
name|arcmsr_post_srb
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		****************************************************************** 		** Q of srbwaitexec will be post out when any outstanding command complete 		****************************************************************** 		*/
name|arcmsr_queue_wait2go_srb
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ***************************************************************************************** ** ***************************************************************************************** */
end_comment

begin_function
specifier|static
name|u_int8_t
name|arcmsr_seek_cmd2abort
parameter_list|(
name|union
name|ccb
modifier|*
name|pabortccb
parameter_list|)
block|{
name|struct
name|_SRB
modifier|*
name|pSRB
decl_stmt|;
name|struct
name|_ACB
modifier|*
name|pACB
init|=
operator|(
expr|struct
name|_ACB
operator|*
operator|)
name|pabortccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbacb_ptr
decl_stmt|;
name|u_int32_t
name|s
decl_stmt|,
name|intmask_org
decl_stmt|,
name|mask
decl_stmt|;
name|u_int32_t
name|i
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|pACB
operator|->
name|num_aborts
operator|++
expr_stmt|;
comment|/*  	*************************************************************************** 	** It is the upper layer do abort command this lock just prior to calling us. 	** First determine if we currently own this command. 	** Start by searching the device queue. If not found 	** at all,and the system wanted us to just abort the 	** command return success. 	*************************************************************************** 	*/
if|if
condition|(
name|pACB
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|pSRB
operator|=
name|pACB
operator|->
name|psrb_pool
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
if|if
condition|(
name|pSRB
operator|->
name|pccb
operator|==
name|pabortccb
condition|)
block|{
name|pSRB
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d:scsi id=%d lun=%d abort srb '%p' outstanding command \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|pabortccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|pabortccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
goto|goto
name|abort_outstanding_cmd
goto|;
block|}
block|}
block|}
block|}
comment|/* 	******************************************************** 	** seek this command at our command list  	** if command found then remove,abort it and free this SRB 	******************************************************** 	*/
if|if
condition|(
name|pACB
operator|->
name|srbwait2gocount
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|;
name|i
operator|++
control|)
block|{
name|pSRB
operator|=
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pSRB
operator|->
name|pccb
operator|==
name|pabortccb
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d:scsi id=%d lun=%d abort ccb '%p' pending command \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|pabortccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|pabortccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pSRB
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|pACB
operator|->
name|srbwait2gocount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
name|abort_outstanding_cmd
label|:
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|)
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
argument_list|)
expr_stmt|;
comment|/* do not talk to iop 331 abort command */
name|arcmsr_polling_srbdone
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
comment|/* enable all outbound interrupt */
name|mask
operator|=
operator|~
operator|(
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE
operator|)
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
name|intmask_org
operator|&
name|mask
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|pACB
operator|->
name|srboutstandingcount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************************** **  **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_bus_reset
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
block|{
name|int
name|retry
init|=
literal|0
decl_stmt|;
name|pACB
operator|->
name|num_resets
operator|++
expr_stmt|;
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_BUS_RESET
expr_stmt|;
while|while
condition|(
name|pACB
operator|->
name|srboutstandingcount
operator|!=
literal|0
operator|&&
name|retry
operator|<
literal|400
condition|)
block|{
name|arcmsr_interrupt
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pACB
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|25000
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
block|}
name|arcmsr_iop_reset
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_BUS_RESET
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************* ** **   CAM  Status field values    **typedef enum { **	CAM_REQ_INPROG,		   CCB request is in progress    **	CAM_REQ_CMP,		   CCB request completed without error    **	CAM_REQ_ABORTED,	   CCB request aborted by the host    **	CAM_UA_ABORT,		   Unable to abort CCB request    **	CAM_REQ_CMP_ERR,	   CCB request completed with an error    **	CAM_BUSY,		       CAM subsytem is busy    **	CAM_REQ_INVALID,	   CCB request was invalid    **	CAM_PATH_INVALID,	   Supplied Path ID is invalid    **	CAM_DEV_NOT_THERE,	   SCSI Device Not Installed/there    **	CAM_UA_TERMIO,		   Unable to terminate I/O CCB request    **	CAM_SEL_TIMEOUT,	   Target Selection Timeout    **	CAM_CMD_TIMEOUT,	   Command timeout    **	CAM_SCSI_STATUS_ERROR,	   SCSI error, look at error code in CCB    **	CAM_MSG_REJECT_REC,	   Message Reject Received    **	CAM_SCSI_BUS_RESET,	   SCSI Bus Reset Sent/Received    **	CAM_UNCOR_PARITY,	   Uncorrectable parity error occurred    **	CAM_AUTOSENSE_FAIL=0x10,   Autosense: request sense cmd fail    **	CAM_NO_HBA,		   No HBA Detected error    **	CAM_DATA_RUN_ERR,	   Data Overrun error    **	CAM_UNEXP_BUSFREE,	   Unexpected Bus Free    **	CAM_SEQUENCE_FAIL,	   Target Bus Phase Sequence Failure    **	CAM_CCB_LEN_ERR,	   CCB length supplied is inadequate    **	CAM_PROVIDE_FAIL,	   Unable to provide requested capability    **	CAM_BDR_SENT,		   A SCSI BDR msg was sent to target    **	CAM_REQ_TERMIO,		   CCB request terminated by the host    **	CAM_UNREC_HBA_ERROR,	   Unrecoverable Host Bus Adapter Error    **	CAM_REQ_TOO_BIG,	   The request was too large for this host    **	CAM_REQUEUE_REQ,	   **				 * This request should be requeued to preserve **				 * transaction ordering.  This typically occurs **				 * when the SIM recognizes an error that should **				 * freeze the queue and must place additional **				 * requests for the target at the sim level **				 * back into the XPT queue. **				    **	CAM_IDE=0x33,		   Initiator Detected Error    **	CAM_RESRC_UNAVAIL,	   Resource Unavailable    **	CAM_UNACKED_EVENT,	   Unacknowledged Event by Host    **	CAM_MESSAGE_RECV,	   Message Received in Host Target Mode    **	CAM_INVALID_CDB,	   Invalid CDB received in Host Target Mode    **	CAM_LUN_INVALID,	   Lun supplied is invalid    **	CAM_TID_INVALID,	   Target ID supplied is invalid    **	CAM_FUNC_NOTAVAIL,	   The requested function is not available    **	CAM_NO_NEXUS,		   Nexus is not established    **	CAM_IID_INVALID,	   The initiator ID is invalid    **	CAM_CDB_RECVD,		   The SCSI CDB has been received    **	CAM_LUN_ALRDY_ENA,	   The LUN is already eanbeld for target mode    **	CAM_SCSI_BUSY,		   SCSI Bus Busy    ** **	CAM_DEV_QFRZN=0x40,	   The DEV queue is frozen w/this err    ** **				   Autosense data valid for target    **	CAM_AUTOSNS_VALID=0x80, **	CAM_RELEASE_SIMQ=0x100,   SIM ready to take more commands    **	CAM_SIM_QUEUED  =0x200,   SIM has this command in it's queue    ** **	CAM_STATUS_MASK=0x3F,	   Mask bits for just the status #    ** **				   Target Specific Adjunct Status    **	CAM_SENT_SENSE=0x40000000	   sent sense with status    **} cam_status; ** **union ccb { **			struct	ccb_hdr			ccb_h;	 For convenience  **			struct	ccb_scsiio		csio; **			struct	ccb_getdev		cgd; **			struct	ccb_getdevlist		cgdl; **			struct	ccb_pathinq		cpi; **			struct	ccb_relsim		crs; **			struct	ccb_setasync		csa; **			struct	ccb_setdev		csd; **			struct	ccb_pathstats		cpis; **			struct	ccb_getdevstats		cgds; **			struct	ccb_dev_match		cdm; **			struct	ccb_trans_settings	cts; **			struct	ccb_calc_geometry	ccg;	 **			struct	ccb_abort		cab; **			struct	ccb_resetbus		crb; **			struct	ccb_resetdev		crd; **			struct	ccb_termio		tio; **			struct	ccb_accept_tio		atio; **			struct	ccb_scsiio		ctio; **			struct	ccb_en_lun		cel; **			struct	ccb_immed_notify	cin; **			struct	ccb_notify_ack		cna; **			struct	ccb_eng_inq		cei; **			struct	ccb_eng_exec		cee; **			struct 	ccb_rescan		crcn; **			struct  ccb_debug		cdbg; **          } ** **struct ccb_hdr { **	cam_pinfo	    pinfo;	                                    "" Info for priority scheduling  **	camq_entry	    xpt_links;	                                "" For chaining in the XPT layer 	 **	camq_entry	    sim_links;	                                "" For chaining in the SIM layer 	 **	camq_entry	    periph_links;                               "" For chaining in the type driver  **	u_int32_t	    retry_count; **	void		    (*cbfcnp)(struct cam_periph *, union ccb *);"" Callback on completion function  **	xpt_opcode	    func_code;	                                "" XPT function code  **	u_int32_t	    status;	                                    "" Status returned by CAM subsystem  **	struct		    cam_path *path;                             "" Compiled path for this ccb  **	path_id_t	    path_id;	                                "" Path ID for the request  **	target_id_t	    target_id;	                                "" Target device ID  **	lun_id_t	    target_lun;                              	"" Target LUN number  **	u_int32_t	    flags; **	ccb_ppriv_area	periph_priv; **	ccb_spriv_area	sim_priv; **	u_int32_t	    timeout;	                                "" Timeout value  **	struct		    callout_handle timeout_ch;                  "" Callout handle used for timeouts  **}; ** **typedef union { **	u_int8_t  *cdb_ptr;		               "" Pointer to the CDB bytes to send  **	u_int8_t  cdb_bytes[IOCDBLEN];         "" Area for the CDB send  **} cdb_t; ** ** SCSI I/O Request CCB used for the XPT_SCSI_IO and XPT_CONT_TARGET_IO ** function codes. ** **struct ccb_scsiio { **	struct	   ccb_hdr ccb_h; **	union	   ccb *next_ccb;	           "" Ptr for next CCB for action  **	u_int8_t   *req_map;		           "" Ptr to mapping info  **	u_int8_t   *data_ptr;		           "" Ptr to the data buf/SG list  **	u_int32_t  dxfer_len;		           "" Data transfer length  **	struct     scsi_sense_data sense_data; "" Autosense storage **	u_int8_t   sense_len;		           "" Number of bytes to autosense **	u_int8_t   cdb_len;		               "" Number of bytes for the CDB  **	u_int16_t  sglist_cnt;		           "" Number of SG list entries **	u_int8_t   scsi_status;		           "" Returned SCSI status  **	u_int8_t   sense_resid;		           "" Autosense resid length: 2's comp  **	u_int32_t  resid;		               "" Transfer residual length: 2's comp **	cdb_t	   cdb_io;		               "" Union for CDB bytes/pointer  **	u_int8_t   *msg_ptr;		           "" Pointer to the message buffer **	u_int16_t  msg_len;		               "" Number of bytes for the Message  **	u_int8_t   tag_action;		           "" What to do for tag queueing  **#define	CAM_TAG_ACTION_NONE	0x00       "" The tag action should be either the define below (to send a non-tagged transaction) or one of the defined scsi tag messages from scsi_message.h. **	u_int	   tag_id;		               "" tag id from initator (target mode)  **	u_int	   init_id;		               "" initiator id of who selected **} ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|psim
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
block|{
name|struct
name|_ACB
modifier|*
name|pACB
decl_stmt|;
name|pACB
operator|=
operator|(
expr|struct
name|_ACB
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|psim
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|==
name|NULL
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
block|{
name|struct
name|_SRB
modifier|*
name|pSRB
decl_stmt|;
if|if
condition|(
operator|(
name|pSRB
operator|=
name|arcmsr_get_freesrb
argument_list|(
name|pACB
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbsrb_ptr
operator|=
name|pSRB
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|arcmsr_ccbacb_ptr
operator|=
name|pACB
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|=
name|pccb
expr_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|u_int32_t
name|error
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|,
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|pccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|arcmsr_executesrb
argument_list|,
name|pSRB
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|pACB
operator|->
name|psim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|pccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|arcmsr_executesrb
argument_list|(
name|pSRB
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
operator|||
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pSRB
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|pccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|arcmsr_executesrb
argument_list|(
name|pSRB
argument_list|,
name|segs
argument_list|,
name|pccb
operator|->
name|csio
operator|.
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|arcmsr_executesrb
argument_list|(
name|pSRB
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_TARGET_IO
case|:
block|{
comment|/* 			** target mode not yet support vendor specific commands. 			*/
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|pccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|ARCMSR_MAX_TARGETID
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|ARCMSR_MAX_TARGETLUN
expr_stmt|;
comment|/* 7 or 0 */
name|cpi
operator|->
name|initiator_id
operator|=
name|ARCMSR_SCSI_INITIATOR_ID
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|psim
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"ARCMSR"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|psim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|psim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_ABORT
case|:
block|{
name|union
name|ccb
modifier|*
name|pabort_ccb
decl_stmt|;
name|pabort_ccb
operator|=
name|pccb
operator|->
name|cab
operator|.
name|abort_ccb
expr_stmt|;
switch|switch
condition|(
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
if|if
condition|(
name|arcmsr_seek_cmd2abort
argument_list|(
name|pabort_ccb
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|xpt_done
argument_list|(
name|pabort_ccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|xpt_print_path
argument_list|(
name|pabort_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Not found\n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
block|}
break|break;
case|case
name|XPT_SCSI_IO
case|:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
break|break;
default|default:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
case|case
name|XPT_RESET_DEV
case|:
block|{
name|u_int32_t
name|i
decl_stmt|;
name|arcmsr_bus_reset
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|500
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|u_int32_t
name|s
decl_stmt|;
name|cts
operator|=
operator|&
name|pccb
operator|->
name|cts
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|cts
operator|->
name|flags
operator|=
operator|(
name|CCB_TRANS_DISC_ENB
operator||
name|CCB_TRANS_TAG_ENB
operator|)
expr_stmt|;
name|cts
operator|->
name|sync_period
operator|=
literal|3
expr_stmt|;
name|cts
operator|->
name|sync_offset
operator|=
literal|32
expr_stmt|;
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
operator||
name|CCB_TRANS_BUS_WIDTH_VALID
operator||
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|u_int32_t
name|size_mb
decl_stmt|;
name|u_int32_t
name|secs_per_cylinder
decl_stmt|;
name|ccg
operator|=
operator|&
name|pccb
operator|->
name|ccg
expr_stmt|;
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|1024
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"arcmsr%d: invalid XPT function CAM_REQ_INVALID\n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  start background rebulid ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_start_adapter_bgrb
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
block|{
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_MSG_START_BGRB
expr_stmt|;
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_MSG_STOP_BGRB
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_START_BGRB
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_polling_srbdone
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|,
name|struct
name|_SRB
modifier|*
name|poll_srb
parameter_list|)
block|{
name|struct
name|_SRB
modifier|*
name|pSRB
decl_stmt|;
name|uint32_t
name|flag_srb
decl_stmt|,
name|outbound_intstatus
decl_stmt|,
name|poll_srb_done
init|=
literal|0
decl_stmt|,
name|poll_count
init|=
literal|0
decl_stmt|;
name|int
name|id
decl_stmt|,
name|lun
decl_stmt|;
name|polling_srb_retry
label|:
name|poll_count
operator|++
expr_stmt|;
name|outbound_intstatus
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intstatus
argument_list|)
operator|&
name|pACB
operator|->
name|outbound_int_enable
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intstatus
argument_list|,
name|outbound_intstatus
argument_list|)
expr_stmt|;
comment|/*clear interrupt*/
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|flag_srb
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_queueport
argument_list|)
operator|)
operator|==
literal|0xFFFFFFFF
condition|)
block|{
if|if
condition|(
name|poll_srb_done
condition|)
block|{
break|break;
comment|/*chip FIFO no ccb for completion already*/
block|}
else|else
block|{
name|UDELAY
argument_list|(
literal|25000
argument_list|)
expr_stmt|;
if|if
condition|(
name|poll_count
operator|>
literal|100
condition|)
block|{
break|break;
block|}
goto|goto
name|polling_srb_retry
goto|;
block|}
block|}
comment|/* check ifcommand done with no error*/
name|pSRB
operator|=
operator|(
expr|struct
name|_SRB
operator|*
operator|)
operator|(
name|pACB
operator|->
name|vir2phy_offset
operator|+
operator|(
name|flag_srb
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
comment|/*frame must be 32 bytes aligned*/
if|if
condition|(
operator|(
name|pSRB
operator|->
name|pACB
operator|!=
name|pACB
operator|)
operator|||
operator|(
name|pSRB
operator|->
name|startdone
operator|!=
name|ARCMSR_SRB_START
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pSRB
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_ABORTED
operator|)
operator|&&
operator|(
name|pSRB
operator|==
name|poll_srb
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d srb='%p' poll command abort successfully \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
name|poll_srb_done
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"arcmsr%d: polling get an illegal srb command done srb='%p' srboutstandingcount=%d \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|pSRB
argument_list|,
name|pACB
operator|->
name|srboutstandingcount
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|id
operator|=
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
operator|(
name|flag_srb
operator|&
name|ARCMSR_SRBREPLY_FLAG_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pACB
operator|->
name|devstate
index|[
name|id
index|]
index|[
name|lun
index|]
operator|==
name|ARECA_RAID_GONE
condition|)
block|{
name|pACB
operator|->
name|devstate
index|[
name|id
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
block|}
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|pSRB
operator|->
name|arcmsr_cdb
operator|.
name|DeviceStatus
condition|)
block|{
case|case
name|ARCMSR_DEV_SELECT_TIMEOUT
case|:
block|{
name|pACB
operator|->
name|devstate
index|[
name|id
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARCMSR_DEV_ABORTED
case|:
case|case
name|ARCMSR_DEV_INIT_FAIL
case|:
block|{
name|pACB
operator|->
name|devstate
index|[
name|id
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCSISTAT_CHECK_CONDITION
case|:
block|{
name|pACB
operator|->
name|devstate
index|[
name|id
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
name|arcmsr_report_sense_info
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* error occur Q all error ccb to errorccbpending Q*/
name|printf
argument_list|(
literal|"arcmsr%d: scsi id=%d lun=%d polling and getting command error done, but got unknow DeviceStatus=0x%x \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|id
argument_list|,
name|lun
argument_list|,
name|pSRB
operator|->
name|arcmsr_cdb
operator|.
name|DeviceStatus
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|devstate
index|[
name|id
index|]
index|[
name|lun
index|]
operator|=
name|ARECA_RAID_GONE
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNCOR_PARITY
expr_stmt|;
comment|/*unknow error or crc error just for retry*/
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*drain reply FIFO*/
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  get firmware miscellaneous data ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_get_firmware_spec
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
block|{
name|char
modifier|*
name|acb_firm_model
init|=
name|pACB
operator|->
name|firm_model
decl_stmt|;
name|char
modifier|*
name|acb_firm_version
init|=
name|pACB
operator|->
name|firm_version
decl_stmt|;
name|char
modifier|*
name|iop_firm_model
init|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|message_rwbuffer
index|[
literal|15
index|]
operator|)
decl_stmt|;
comment|/*firm_model,15,60-67*/
name|char
modifier|*
name|iop_firm_version
init|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|message_rwbuffer
index|[
literal|17
index|]
operator|)
decl_stmt|;
comment|/*firm_version,17,68-83*/
name|int
name|count
decl_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_GET_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: wait 'get adapter firmware miscellaneous data' timeout \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
literal|8
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
operator|*
name|acb_firm_model
operator|=
name|readb
argument_list|(
name|iop_firm_model
argument_list|)
expr_stmt|;
name|acb_firm_model
operator|++
expr_stmt|;
name|iop_firm_model
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
name|count
operator|=
literal|16
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
operator|*
name|acb_firm_version
operator|=
name|readb
argument_list|(
name|iop_firm_version
argument_list|)
expr_stmt|;
name|acb_firm_version
operator|++
expr_stmt|;
name|iop_firm_version
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ARECA RAID ADAPTER%d: FIRMWARE VERSION %s \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|pACB
operator|->
name|firm_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pACB
operator|->
name|firm_version
argument_list|,
literal|"V1.37"
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"!!!!!!   PLEASE UPDATE RAID FIRMWARE VERSION EQUAL OR MORE THAN 'V1.37'   !!!!!!\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
argument_list|)
expr_stmt|;
block|}
name|pACB
operator|->
name|firm_request_len
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|message_rwbuffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*firm_request_len,1,04-07*/
name|pACB
operator|->
name|firm_numbers_queue
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|message_rwbuffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/*firm_numbers_queue,2,08-11*/
name|pACB
operator|->
name|firm_sdram_size
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|message_rwbuffer
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/*firm_sdram_size,3,12-15*/
name|pACB
operator|->
name|firm_ide_channels
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|message_rwbuffer
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/*firm_ide_channels,4,16-19*/
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  start background rebulid ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_iop_init
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
block|{
name|u_int32_t
name|intmask_org
decl_stmt|,
name|mask
decl_stmt|,
name|outbound_doorbell
decl_stmt|,
name|firmware_state
init|=
literal|0
decl_stmt|;
do|do
block|{
name|firmware_state
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_msgaddr1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|firmware_state
operator|&
name|ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK
operator|)
operator|==
literal|0
condition|)
do|;
name|intmask_org
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|)
expr_stmt|;
name|arcmsr_get_firmware_spec
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
comment|/*start background rebuild*/
name|arcmsr_start_adapter_bgrb
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: iop init wait 'start adapter background rebulid' timeout \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
comment|/* clear Qbuffer if door bell ringed */
name|outbound_doorbell
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_doorbell
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbound_doorbell
operator|&
name|ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK
condition|)
block|{
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_doorbell
argument_list|,
name|outbound_doorbell
argument_list|)
expr_stmt|;
comment|/*clear interrupt */
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_doorbell
argument_list|,
name|ARCMSR_INBOUND_DRIVER_DATA_READ_OK
argument_list|)
expr_stmt|;
block|}
comment|/* enable outbound Post Queue,outbound message0,outbell doorbell Interrupt */
name|mask
operator|=
operator|~
operator|(
name|ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE
operator||
name|ARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE
operator|)
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
name|intmask_org
operator|&
name|mask
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|outbound_int_enable
operator|=
operator|~
operator|(
name|intmask_org
operator|&
name|mask
operator|)
operator|&
literal|0x000000ff
expr_stmt|;
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_IOP_INITED
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************************** **  **  map freesrb ** ********************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_map_freesrb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|_ACB
modifier|*
name|pACB
init|=
name|arg
decl_stmt|;
name|struct
name|_SRB
modifier|*
name|psrb_tmp
decl_stmt|;
name|u_int8_t
modifier|*
name|dma_memptr
decl_stmt|;
name|u_int32_t
name|i
decl_stmt|,
name|cdb_phyaddr
decl_stmt|,
name|srb_phyaddr_hi32
decl_stmt|;
name|unsigned
name|long
name|srb_phyaddr
init|=
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_addr
decl_stmt|;
name|dma_memptr
operator|=
name|pACB
operator|->
name|uncacheptr
expr_stmt|;
name|cdb_phyaddr
operator|=
operator|(
name|u_int32_t
operator|)
name|segs
operator|->
name|ds_addr
expr_stmt|;
comment|/* We suppose bus_addr_t high part always 0 here*/
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|dma_memptr
operator|&
literal|0x1F
operator|)
operator|!=
literal|0
condition|)
block|{
name|dma_memptr
operator|=
name|dma_memptr
operator|+
operator|(
literal|0x20
operator|-
operator|(
operator|(
name|unsigned
name|long
operator|)
name|dma_memptr
operator|&
literal|0x1F
operator|)
operator|)
expr_stmt|;
name|cdb_phyaddr
operator|=
name|cdb_phyaddr
operator|+
operator|(
literal|0x20
operator|-
operator|(
operator|(
name|unsigned
name|long
operator|)
name|cdb_phyaddr
operator|&
literal|0x1F
operator|)
operator|)
expr_stmt|;
block|}
name|psrb_tmp
operator|=
operator|(
expr|struct
name|_SRB
operator|*
operator|)
name|dma_memptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|psrb_tmp
operator|&
literal|0x1F
operator|)
operator|==
literal|0
condition|)
comment|/*srb address must 32 (0x20) boundary*/
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|psrb_tmp
operator|->
name|dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_MAPFREESRB_FAILD
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: srb dmamap bus_dmamap_create error\n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|psrb_tmp
operator|->
name|cdb_shifted_phyaddr
operator|=
name|cdb_phyaddr
operator|>>
literal|5
expr_stmt|;
name|psrb_tmp
operator|->
name|pACB
operator|=
name|pACB
expr_stmt|;
name|pACB
operator|->
name|psrbringQ
index|[
name|i
index|]
operator|=
name|pACB
operator|->
name|psrb_pool
index|[
name|i
index|]
operator|=
name|psrb_tmp
expr_stmt|;
name|cdb_phyaddr
operator|=
name|cdb_phyaddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|_SRB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_MAPFREESRB_FAILD
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: dma_memptr=%p i=%d this srb cross 32 bytes boundary ignored psrb_tmp=%p \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|,
name|dma_memptr
argument_list|,
name|i
argument_list|,
name|psrb_tmp
argument_list|)
expr_stmt|;
return|return;
block|}
name|psrb_tmp
operator|++
expr_stmt|;
block|}
comment|/* 	******************************************************************** 	** here we need to tell iop 331 our freesrb.HighPart  	** if freesrb.HighPart is not zero 	******************************************************************** 	*/
name|srb_phyaddr_hi32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|srb_phyaddr
operator|>>
literal|16
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|srb_phyaddr_hi32
operator|!=
literal|0
condition|)
block|{
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|message_rwbuffer
index|[
literal|0
index|]
argument_list|,
name|ARCMSR_SIGNATURE_SET_CONFIG
argument_list|)
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|message_rwbuffer
index|[
literal|1
index|]
argument_list|,
name|srb_phyaddr_hi32
argument_list|)
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|inbound_msgaddr0
argument_list|,
name|ARCMSR_INBOUND_MESG0_SET_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: 'set srb high part physical address' timeout \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
block|}
name|pACB
operator|->
name|vir2phy_offset
operator|=
operator|(
name|unsigned
name|long
operator|)
name|psrb_tmp
operator|-
operator|(
name|unsigned
name|long
operator|)
name|cdb_phyaddr
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** ** ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_free_resource
parameter_list|(
name|struct
name|_ACB
modifier|*
name|pACB
parameter_list|)
block|{
comment|/* remove the control device */
if|if
condition|(
name|pACB
operator|->
name|ioctl_dev
operator|!=
name|NULL
condition|)
block|{
name|destroy_dev
argument_list|(
name|pACB
operator|->
name|ioctl_dev
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** PCI config header registers for all devices  ** ** #define PCIR_COMMAND	        0x04 ** #define PCIM_CMD_PORTEN		0x0001 ** #define PCIM_CMD_MEMEN		0x0002 ** #define PCIM_CMD_BUSMASTEREN	0x0004 ** #define PCIM_CMD_MWRICEN	    0x0010 ** #define PCIM_CMD_PERRESPEN	0x0040     **         ** Function      : arcmsr_initialize  ** Purpose       : initialize the internal structures for a given SCSI host ** Inputs        : host - pointer to this host adapter's structure ** Preconditions : when this function is called,the chip_type **	               field of the pACB structure MUST have been set. ** ** 10h Base Address register #0 ** 14h Base Address register #1 ** 18h Base Address register #2 ** 1Ch Base Address register #3 ** 20h Base Address register #4 ** 24h Base Address register #5 ************************************************************************ */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_initialize
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|_ACB
modifier|*
name|pACB
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|intmask_org
decl_stmt|,
name|rid
init|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|vm_offset_t
name|mem_base
decl_stmt|;
name|u_int16_t
name|pci_command
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502010
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignemnt*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*nsegments*/
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|NULL
argument_list|,
comment|/*lockarg*/
name|NULL
argument_list|,
operator|&
name|pACB
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignemnt*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*nsegments*/
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|pACB
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|printf
argument_list|(
literal|"arcmsr%d: parent_dmat bus_dma_tag_create failure!\n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* Create a single tag describing a region large enough to hold all of the s/g lists we will need. */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502010
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|pACB
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|MAXBSIZE
argument_list|,
comment|/*nsegments*/
name|ARCMSR_MAX_SG_ENTRIES
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
operator|&
name|pACB
operator|->
name|buffer_dmat
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|pACB
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|MAXBSIZE
argument_list|,
comment|/*nsegments*/
name|ARCMSR_MAX_SG_ENTRIES
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
operator|&
name|pACB
operator|->
name|buffer_dmat
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: buffer_dmat bus_dma_tag_create failure!\n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* DMA tag for our srb structures.... Allocate the freesrb memory */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502010
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|pACB
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|_SRB
argument_list|)
operator|*
name|ARCMSR_MAX_FREESRB_NUM
operator|)
operator|+
literal|0x20
operator|)
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/*lockfunc*/
name|NULL
argument_list|,
comment|/*lockarg*/
name|NULL
argument_list|,
operator|&
name|pACB
operator|->
name|srb_dmat
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|pACB
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|_SRB
argument_list|)
operator|*
name|ARCMSR_MAX_FREESRB_NUM
operator|)
operator|+
literal|0x20
operator|)
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
operator|&
name|pACB
operator|->
name|srb_dmat
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: srb_dmat bus_dma_tag_create failure!\n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Allocation for our srbs */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pACB
operator|->
name|uncacheptr
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|pACB
operator|->
name|srb_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: srb_dmat bus_dmamem_alloc failure!\n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* And permanently map them */
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|,
name|pACB
operator|->
name|uncacheptr
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|_SRB
argument_list|)
operator|*
name|ARCMSR_MAX_FREESRB_NUM
operator|)
operator|+
literal|0x20
argument_list|,
name|arcmsr_map_freesrb
argument_list|,
name|pACB
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: srb_dmat bus_dmamap_load failure!\n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|pci_command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_command
operator||=
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_command
operator||=
name|PCIM_CMD_PERRESPEN
expr_stmt|;
name|pci_command
operator||=
name|PCIM_CMD_MWRICEN
expr_stmt|;
comment|/* Enable Busmaster/Mem */
name|pci_command
operator||=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|pci_command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|sys_res_arcmsr
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|0x1000
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|sys_res_arcmsr
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: bus_alloc_resource failure!\n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
name|rman_get_start
argument_list|(
name|pACB
operator|->
name|sys_res_arcmsr
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: rman_get_start failure!\n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|mem_base
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|pACB
operator|->
name|sys_res_arcmsr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_base
operator|==
literal|0
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: rman_get_virtual failure!\n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|pACB
operator|->
name|acb_flags
operator|&
name|ACB_F_MAPFREESRB_FAILD
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: map free srb failure!\n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|pACB
operator|->
name|btag
operator|=
name|rman_get_bustag
argument_list|(
name|pACB
operator|->
name|sys_res_arcmsr
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|pACB
operator|->
name|sys_res_arcmsr
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|pmu
operator|=
operator|(
expr|struct
name|_MU
operator|*
operator|)
name|mem_base
expr_stmt|;
name|pACB
operator|->
name|acb_flags
operator||=
operator|(
name|ACB_F_IOCTL_WQBUFFER_CLEARED
operator||
name|ACB_F_IOCTL_RQBUFFER_CLEARED
operator|)
expr_stmt|;
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_SCSISTOPADAPTER
expr_stmt|;
comment|/* 	******************************************************************** 	** init raid volume state 	******************************************************************** 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_TARGETID
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARCMSR_MAX_TARGETLUN
condition|;
name|j
operator|++
control|)
block|{
name|pACB
operator|->
name|devstate
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|ARECA_RAID_GOOD
expr_stmt|;
block|}
block|}
comment|/* disable iop all outbound interrupt */
name|intmask_org
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|)
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
argument_list|)
expr_stmt|;
name|arcmsr_iop_init
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** **        attach and init a host adapter                ** ************************************************************************ */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|_ACB
modifier|*
name|pACB
init|=
operator|(
expr|struct
name|_ACB
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
comment|/* Device Queue to use for this SIM */
name|struct
name|resource
modifier|*
name|irqres
decl_stmt|;
name|int
name|rid
decl_stmt|;
if|if
condition|(
name|pACB
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: cannot allocate softc\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|pACB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_ACB
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_initialize
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: initialize failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* After setting up the adapter,map our interrupt */
name|rid
operator|=
literal|0
expr_stmt|;
name|irqres
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|irqres
operator|==
name|NULL
operator|||
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|irqres
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
name|arcmsr_interrupt
argument_list|,
name|pACB
argument_list|,
operator|&
name|pACB
operator|->
name|ih
argument_list|)
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: unable to register interrupt handler!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|pACB
operator|->
name|irqres
operator|=
name|irqres
expr_stmt|;
name|pACB
operator|->
name|pci_dev
operator|=
name|dev
expr_stmt|;
name|pACB
operator|->
name|pci_unit
operator|=
name|unit
expr_stmt|;
comment|/* 	 * Now let the CAM generic SCSI layer find the SCSI devices on 	 * the bus *  start queue to reset to the idle loop. * 	 * Create device queue of SIM(s) *  (MAX_START_JOB - 1) : 	 * max_sim_transactions 	*/
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|ARCMSR_MAX_START_JOB
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|pACB
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: cam_simq_alloc failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|pACB
operator|->
name|psim
operator|=
name|cam_sim_alloc
argument_list|(
name|arcmsr_action
argument_list|,
name|arcmsr_poll
argument_list|,
literal|"arcmsr"
argument_list|,
name|pACB
argument_list|,
name|unit
argument_list|,
literal|1
argument_list|,
name|ARCMSR_MAX_OUTSTANDING_CMD
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|psim
operator|==
name|NULL
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|pACB
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: cam_sim_alloc failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|pACB
operator|->
name|psim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|pACB
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|pACB
operator|->
name|psim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: xpt_bus_register failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|pACB
operator|->
name|ppath
argument_list|,
comment|/* periph */
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|pACB
operator|->
name|psim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|pACB
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|pACB
operator|->
name|psim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|pACB
operator|->
name|psim
argument_list|,
comment|/* free_simq */
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arcmsr%d: xpt_create_path failure!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* 	**************************************************** 	*/
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|pACB
operator|->
name|ppath
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
operator||
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|arcmsr_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|pACB
operator|->
name|psim
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
comment|/* Create the control device.  */
name|pACB
operator|->
name|ioctl_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|arcmsr_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
comment|/* GID_OPERATOR */
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|,
literal|"arcmsr%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|503000
name|pACB
operator|->
name|ioctl_dev
operator|->
name|si_drv1
operator|=
name|pACB
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500005
operator|(
name|void
operator|)
name|make_dev_alias
argument_list|(
name|pACB
operator|->
name|ioctl_dev
argument_list|,
literal|"arc%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** **                      ** ************************************************************************ */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|id
decl_stmt|;
switch|switch
condition|(
name|id
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|PCIDevVenIDARC1110
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1110 PCI-X 4 PORTS SATA RAID CONTROLLER \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1120
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1120 PCI-X 8 PORTS SATA RAID CONTROLLER (RAID6-ENGINE Inside) \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1130
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1130 PCI-X 12 PORTS SATA RAID CONTROLLER (RAID6-ENGINE Inside) \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1160
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1160 PCI-X 16 PORTS SATA RAID CONTROLLER (RAID6-ENGINE Inside) \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1170
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1170 PCI-X 24 PORTS SATA RAID CONTROLLER (RAID6-ENGINE Inside) \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1210
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1210 PCI-EXPRESS 4 PORTS SATA RAID CONTROLLER \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1220
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1220 PCI-EXPRESS 8 PORTS SATA RAID CONTROLLER (RAID6-ENGINE Inside) \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1230
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1230 PCI-EXPRESS 12 PORTS SATA RAID CONTROLLER (RAID6-ENGINE Inside) \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PCIDevVenIDARC1260
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1260 PCI-EXPRESS 16 PORTS SATA RAID CONTROLLER (RAID6-ENGINE Inside) \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
case|case
name|PCIDevVenIDARC1270
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARECA ARC1270 PCI-EXPRESS 24 PORTS SATA RAID CONTROLLER (RAID6-ENGINE Inside) \n"
name|ARCMSR_DRIVER_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** **                      ** ************************************************************************ */
end_comment

begin_function
specifier|static
name|void
name|arcmsr_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|i
decl_stmt|,
name|poll_count
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|s
decl_stmt|,
name|intmask_org
decl_stmt|;
name|struct
name|_SRB
modifier|*
name|pSRB
decl_stmt|;
name|struct
name|_ACB
modifier|*
name|pACB
init|=
operator|(
expr|struct
name|_ACB
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* disable all outbound interrupt */
name|intmask_org
operator|=
name|readl
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|)
expr_stmt|;
name|writel
argument_list|(
operator|&
name|pACB
operator|->
name|pmu
operator|->
name|outbound_intmask
argument_list|,
operator|(
name|intmask_org
operator||
name|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE
operator|)
argument_list|)
expr_stmt|;
comment|/* stop adapter background rebuild */
name|arcmsr_stop_adapter_bgrb
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: shutdown wait 'stop adapter rebulid' timeout \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
name|arcmsr_flush_adapter_cache
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: shutdown wait 'flush adapter cache' timeout \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
comment|/* abort all outstanding command */
name|pACB
operator|->
name|acb_flags
operator||=
name|ACB_F_SCSISTOPADAPTER
expr_stmt|;
name|pACB
operator|->
name|acb_flags
operator|&=
operator|~
name|ACB_F_IOP_INITED
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|pACB
operator|->
name|srboutstandingcount
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|poll_count
operator|<
literal|256
operator|)
condition|)
block|{
name|arcmsr_interrupt
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pACB
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|25000
argument_list|)
expr_stmt|;
name|poll_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pACB
operator|->
name|srboutstandingcount
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: shutdown srboutstandingcount!=0 \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
name|arcmsr_abort_allcmd
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcmsr_wait_msgint_ready
argument_list|(
name|pACB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"arcmsr%d: shutdown wait 'abort all outstanding command' timeout \n"
argument_list|,
name|pACB
operator|->
name|pci_unit
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_FREESRB_NUM
condition|;
name|i
operator|++
control|)
block|{
name|pSRB
operator|=
name|pACB
operator|->
name|psrb_pool
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|->
name|startdone
operator|==
name|ARCMSR_SRB_START
condition|)
block|{
name|pSRB
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|pACB
operator|->
name|srbwait2gocount
operator|!=
literal|0
condition|)
block|{
comment|/*remove first wait2go srb and abort it*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCMSR_MAX_OUTSTANDING_CMD
condition|;
name|i
operator|++
control|)
block|{
name|pSRB
operator|=
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pSRB
operator|!=
name|NULL
condition|)
block|{
name|pACB
operator|->
name|psrbwait2go
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pSRB
operator|->
name|startdone
operator|=
name|ARCMSR_SRB_ABORTED
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|arcmsr_srb_complete
argument_list|(
name|pSRB
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|pACB
operator|->
name|srbwait2gocount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|atomic_set_int
argument_list|(
operator|&
name|pACB
operator|->
name|srboutstandingcount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************************ ** **                      ** ************************************************************************ */
end_comment

begin_function
specifier|static
name|u_int32_t
name|arcmsr_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|_ACB
modifier|*
name|pACB
init|=
operator|(
expr|struct
name|_ACB
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|arcmsr_shutdown
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|arcmsr_free_resource
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|pACB
operator|->
name|sys_res_arcmsr
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|pACB
operator|->
name|irqres
argument_list|,
name|pACB
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|pACB
operator|->
name|irqres
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|pACB
operator|->
name|ppath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|pACB
operator|->
name|ppath
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|pACB
operator|->
name|psim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|pACB
operator|->
name|psim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

