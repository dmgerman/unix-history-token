begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Sandvine Incorporated ULC.  * Copyright (c) 2012 iXsystems, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Support for Winbond watchdog.  *  * With minor abstractions it might be possible to add support for other  * different Winbond Super I/O chips as well.  Winbond seems to have four  * different types of chips, four different ways to get into extended config  * mode.  *  * Note: there is no serialization between the debugging sysctl handlers and  * the watchdog functions and possibly others poking the registers at the same  * time.  For that at least possibly interfering sysctls are hidden by default.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/watchdog.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_comment
comment|/*  * Global registers.  */
end_comment

begin_define
define|#
directive|define
name|WB_DEVICE_ID_REG
value|0x20
end_define

begin_comment
comment|/* Device ID */
end_comment

begin_define
define|#
directive|define
name|WB_DEVICE_REV_REG
value|0x21
end_define

begin_comment
comment|/* Device revision */
end_comment

begin_define
define|#
directive|define
name|WB_CR26
value|0x26
end_define

begin_comment
comment|/* Bit6: HEFRAS (base port selector) */
end_comment

begin_comment
comment|/* LDN selection. */
end_comment

begin_define
define|#
directive|define
name|WB_LDN_REG
value|0x07
end_define

begin_define
define|#
directive|define
name|WB_LDN_REG_LDN8
value|0x08
end_define

begin_comment
comment|/* GPIO 2, Watchdog */
end_comment

begin_comment
comment|/*  * LDN8 (GPIO 2, Watchdog) specific registers and options.  */
end_comment

begin_comment
comment|/* CR30: LDN8 activation control. */
end_comment

begin_define
define|#
directive|define
name|WB_LDN8_CR30
value|0x30
end_define

begin_define
define|#
directive|define
name|WB_LDN8_CR30_ACTIVE
value|0x01
end_define

begin_comment
comment|/* 1: LD active */
end_comment

begin_comment
comment|/* CRF5: Watchdog scale, P20. Mapped to reg_1. */
end_comment

begin_define
define|#
directive|define
name|WB_LDN8_CRF5
value|0xF5
end_define

begin_define
define|#
directive|define
name|WB_LDN8_CRF5_SCALE
value|0x08
end_define

begin_comment
comment|/* 0: 1s, 1: 60s */
end_comment

begin_define
define|#
directive|define
name|WB_LDN8_CRF5_KEYB_P20
value|0x04
end_define

begin_comment
comment|/* 1: keyb P20 forces timeout */
end_comment

begin_define
define|#
directive|define
name|WB_LDN8_CRF5_KBRST
value|0x02
end_define

begin_comment
comment|/* 1: timeout causes pin60 kbd reset */
end_comment

begin_comment
comment|/* CRF6: Watchdog Timeout (0 == off). Mapped to reg_timeout. */
end_comment

begin_define
define|#
directive|define
name|WB_LDN8_CRF6
value|0xF6
end_define

begin_comment
comment|/* CRF7: Watchdog mouse, keyb, force, .. Mapped to reg_2. */
end_comment

begin_define
define|#
directive|define
name|WB_LDN8_CRF7
value|0xF7
end_define

begin_define
define|#
directive|define
name|WB_LDN8_CRF7_MOUSE
value|0x80
end_define

begin_comment
comment|/* 1: mouse irq resets wd timer */
end_comment

begin_define
define|#
directive|define
name|WB_LDN8_CRF7_KEYB
value|0x40
end_define

begin_comment
comment|/* 1: keyb irq resets wd timer */
end_comment

begin_define
define|#
directive|define
name|WB_LDN8_CRF7_FORCE
value|0x20
end_define

begin_comment
comment|/* 1: force timeout (self-clear) */
end_comment

begin_define
define|#
directive|define
name|WB_LDN8_CRF7_TS
value|0x10
end_define

begin_comment
comment|/* 0: counting, 1: fired */
end_comment

begin_define
define|#
directive|define
name|WB_LDN8_CRF7_IRQS
value|0x0f
end_define

begin_comment
comment|/* irq source for watchdog, 2 == SMI */
end_comment

begin_define
define|#
directive|define
name|WB_LDN8_CRF7_CLEAR_MASK
define|\
value|(WB_LDN8_CRF7_MOUSE|WB_LDN8_CRF7_KEYB|WB_LDN8_CRF7_TS|WB_LDN8_CRF7_IRQS)
end_define

begin_struct
struct|struct
name|wb_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|portres
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|eventhandler_tag
name|ev_tag
decl_stmt|;
name|int
function_decl|(
modifier|*
name|ext_cfg_enter_f
function_decl|)
parameter_list|(
name|struct
name|wb_softc
modifier|*
parameter_list|,
name|u_short
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|ext_cfg_exit_f
function_decl|)
parameter_list|(
name|struct
name|wb_softc
modifier|*
parameter_list|,
name|u_short
parameter_list|)
function_decl|;
name|int
name|debug_verbose
decl_stmt|;
comment|/* 	 * Special feature to let the watchdog fire at a different 	 * timeout as set by watchdog(4) but still use that API to 	 * re-load it periodically. 	 */
name|unsigned
name|int
name|timeout_override
decl_stmt|;
comment|/* 	 * Space to save current state temporary and for sysctls. 	 * We want to know the timeout value and usually need two 	 * additional registers for options. Do not name them by 	 * register as these might be different by chip. 	 */
name|uint8_t
name|reg_timeout
decl_stmt|;
name|uint8_t
name|reg_1
decl_stmt|;
name|uint8_t
name|reg_2
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|ext_cfg_enter_0x87_0x87
parameter_list|(
name|struct
name|wb_softc
modifier|*
parameter_list|,
name|u_short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ext_cfg_exit_0xaa
parameter_list|(
name|struct
name|wb_softc
modifier|*
parameter_list|,
name|u_short
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|winbond_superio_cfg
block|{
name|uint8_t
name|efer
decl_stmt|;
comment|/* and efir */
name|int
function_decl|(
modifier|*
name|ext_cfg_enter_f
function_decl|)
parameter_list|(
name|struct
name|wb_softc
modifier|*
parameter_list|,
name|u_short
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|ext_cfg_exit_f
function_decl|)
parameter_list|(
name|struct
name|wb_softc
modifier|*
parameter_list|,
name|u_short
parameter_list|)
function_decl|;
block|}
name|probe_addrs
index|[]
init|=
block|{
block|{
operator|.
name|efer
operator|=
literal|0x2e
block|,
operator|.
name|ext_cfg_enter_f
operator|=
name|ext_cfg_enter_0x87_0x87
block|,
operator|.
name|ext_cfg_exit_f
operator|=
name|ext_cfg_exit_0xaa
block|, 	}
block|,
block|{
operator|.
name|efer
operator|=
literal|0x4e
block|,
operator|.
name|ext_cfg_enter_f
operator|=
name|ext_cfg_enter_0x87_0x87
block|,
operator|.
name|ext_cfg_exit_f
operator|=
name|ext_cfg_exit_0xaa
block|, 	}
block|, }
struct|;
end_struct

begin_struct
struct|struct
name|winbond_vendor_device_id
block|{
name|uint16_t
name|vendor_id
decl_stmt|;
name|uint8_t
name|device_id
decl_stmt|;
name|uint8_t
name|device_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|descr
decl_stmt|;
block|}
name|wb_devs
index|[]
init|=
block|{
block|{
operator|.
name|vendor_id
operator|=
literal|0x5ca3
block|,
operator|.
name|device_id
operator|=
literal|0x52
block|,
operator|.
name|device_rev
operator|=
literal|0x17
block|,
operator|.
name|descr
operator|=
literal|"Winbond 83627HF/F/HG/G Rev. G"
block|, 	}
block|,
block|{
operator|.
name|vendor_id
operator|=
literal|0x5ca3
block|,
operator|.
name|device_id
operator|=
literal|0x52
block|,
operator|.
name|device_rev
operator|=
literal|0x3a
block|,
operator|.
name|descr
operator|=
literal|"Winbond 83627HF/F/HG/G Rev. J"
block|, 	}
block|,
block|{
operator|.
name|vendor_id
operator|=
literal|0x5ca3
block|,
operator|.
name|device_id
operator|=
literal|0x52
block|,
operator|.
name|device_rev
operator|=
literal|0x41
block|,
operator|.
name|descr
operator|=
literal|"Winbond 83627HF/F/HG/G Rev. UD-A"
block|, 	}
block|,
block|{
operator|.
name|vendor_id
operator|=
literal|0x5ca3
block|,
operator|.
name|device_id
operator|=
literal|0xa0
block|,
operator|.
name|device_rev
operator|=
literal|0x25
block|,
operator|.
name|descr
operator|=
literal|"Winbond 83627DHG IC ver. 5"
block|,    	}
block|,
block|{
operator|.
name|vendor_id
operator|=
literal|0x5ca3
block|,
operator|.
name|device_id
operator|=
literal|0xb0
block|,
operator|.
name|device_rev
operator|=
literal|0x73
block|,
operator|.
name|descr
operator|=
literal|"Winbond 83627DHG-P"
block|,    	}
block|,
block|{
operator|.
name|vendor_id
operator|=
literal|0x5ca3
block|,
operator|.
name|device_id
operator|=
literal|0xc3
block|,
operator|.
name|device_rev
operator|=
literal|0x33
block|,
operator|.
name|descr
operator|=
literal|"Nuvoton WPCM450RA0BX"
block|,    	}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|void
name|write_efir_1
parameter_list|(
name|struct
name|wb_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|baseport
parameter_list|,
name|uint8_t
name|value
parameter_list|)
block|{
name|MPASS
argument_list|(
name|sc
operator|!=
name|NULL
operator|||
name|baseport
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
name|bus_space_write_1
argument_list|(
operator|(
name|sc
operator|)
operator|->
name|bst
argument_list|,
operator|(
name|sc
operator|)
operator|->
name|bsh
argument_list|,
literal|0
argument_list|,
operator|(
name|value
operator|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|baseport
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|__unused
name|read_efir_1
parameter_list|(
name|struct
name|wb_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|baseport
parameter_list|)
block|{
name|MPASS
argument_list|(
name|sc
operator|!=
name|NULL
operator|||
name|baseport
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
return|return
operator|(
name|bus_space_read_1
argument_list|(
operator|(
name|sc
operator|)
operator|->
name|bst
argument_list|,
operator|(
name|sc
operator|)
operator|->
name|bsh
argument_list|,
literal|0
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|inb
argument_list|(
name|baseport
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_efdr_1
parameter_list|(
name|struct
name|wb_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|baseport
parameter_list|,
name|uint8_t
name|value
parameter_list|)
block|{
name|MPASS
argument_list|(
name|sc
operator|!=
name|NULL
operator|||
name|baseport
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
name|bus_space_write_1
argument_list|(
operator|(
name|sc
operator|)
operator|->
name|bst
argument_list|,
operator|(
name|sc
operator|)
operator|->
name|bsh
argument_list|,
literal|1
argument_list|,
operator|(
name|value
operator|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|baseport
operator|+
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|read_efdr_1
parameter_list|(
name|struct
name|wb_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|baseport
parameter_list|)
block|{
name|MPASS
argument_list|(
name|sc
operator|!=
name|NULL
operator|||
name|baseport
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
return|return
operator|(
name|bus_space_read_1
argument_list|(
operator|(
name|sc
operator|)
operator|->
name|bst
argument_list|,
operator|(
name|sc
operator|)
operator|->
name|bsh
argument_list|,
literal|1
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|inb
argument_list|(
name|baseport
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the watchdog related registers as we last read them.  This will  * usually not give the current timeout or state on whether the watchdog  * fired.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_wb_debug
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|wb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|64
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"LDN8 (GPIO2, Watchdog): "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"CRF5 0x%02x "
argument_list|,
name|sc
operator|->
name|reg_1
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"CRF6 0x%02x "
argument_list|,
name|sc
operator|->
name|reg_timeout
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"CRF7 0x%02x"
argument_list|,
name|sc
operator|->
name|reg_2
argument_list|)
expr_stmt|;
name|sbuf_putc
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* nullterm */
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the current values before returning them.  Given this might poke  * the registers the same time as the watchdog, this sysctl handler should  * be marked CTLFLAG_SKIP to not show up by default.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_wb_debug_current
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|wb_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
comment|/* 	 * Enter extended function mode in case someone else has been 	 * poking on the registers.  We will not leave it though. 	 */
if|if
condition|(
call|(
modifier|*
name|sc
operator|->
name|ext_cfg_enter_f
call|)
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Watchdog is configured as part of LDN 8 (GPIO Port2, Watchdog). */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN_REG
argument_list|)
expr_stmt|;
name|write_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN_REG_LDN8
argument_list|)
expr_stmt|;
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF5
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg_1
operator|=
name|read_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF6
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg_timeout
operator|=
name|read_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF7
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg_2
operator|=
name|read_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_wb_debug
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sysctl handlers to force a watchdog timeout or to test the NMI functionality  * works as expetced.  * For testing we could set a test_nmi flag in the softc that, in case of NMI, a  * callback function from trap.c could check whether we fired and not report the  * timeout but clear the flag for the sysctl again.  This is interesting given a  * lot of boards have jumpers to change the action on watchdog timeout or  * disable the watchdog completely.  * XXX-BZ notyet: currently no general infrastructure exists to do this.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_wb_force_test_nmi
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|wb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|test
decl_stmt|,
name|val
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|test
operator|=
name|arg2
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|val
operator|=
name|sc
operator|->
name|test_nmi
expr_stmt|;
else|#
directive|else
name|val
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|notyet
comment|/* Manually clear the test for a value of 0 and do nothing else. */
if|if
condition|(
name|test
operator|&&
name|val
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|test_nmi
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * Enter extended function mode in case someone else has been 	 * poking on the registers.  We will not leave it though. 	 */
if|if
condition|(
call|(
modifier|*
name|sc
operator|->
name|ext_cfg_enter_f
call|)
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * If we are testing the NMI functionality, set the flag before 	 * forcing the timeout. 	 */
if|if
condition|(
name|test
condition|)
name|sc
operator|->
name|test_nmi
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Watchdog is configured as part of LDN 8 (GPIO Port2, Watchdog). */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN_REG
argument_list|)
expr_stmt|;
name|write_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN_REG_LDN8
argument_list|)
expr_stmt|;
comment|/* Force watchdog to fire. */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF7
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg_2
operator|=
name|read_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg_2
operator||=
name|WB_LDN8_CRF7_FORCE
expr_stmt|;
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF7
argument_list|)
expr_stmt|;
name|write_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|reg_2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print current watchdog state.  *  * Note: it is the responsibility of the caller to update the registers  * upfront.  */
end_comment

begin_function
specifier|static
name|void
name|wb_print_state
parameter_list|(
name|struct
name|wb_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s%sWatchdog %sabled. %s"
literal|"Scaling by %ds, timer at %d (%s=%ds%s). "
literal|"CRF5 0x%02x CRF7 0x%02x\n"
argument_list|,
operator|(
name|msg
operator|!=
name|NULL
operator|)
condition|?
name|msg
else|:
literal|""
argument_list|,
operator|(
name|msg
operator|!=
name|NULL
operator|)
condition|?
literal|": "
else|:
literal|""
argument_list|,
operator|(
name|sc
operator|->
name|reg_timeout
operator|>
literal|0x00
operator|)
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|,
operator|(
name|sc
operator|->
name|reg_2
operator|&
name|WB_LDN8_CRF7_TS
operator|)
condition|?
literal|"Watchdog fired. "
else|:
literal|""
argument_list|,
operator|(
name|sc
operator|->
name|reg_1
operator|&
name|WB_LDN8_CRF5_SCALE
operator|)
condition|?
literal|60
else|:
literal|1
argument_list|,
name|sc
operator|->
name|reg_timeout
argument_list|,
operator|(
name|sc
operator|->
name|reg_timeout
operator|>
literal|0x00
operator|)
condition|?
literal|"<"
else|:
literal|""
argument_list|,
name|sc
operator|->
name|reg_timeout
operator|*
operator|(
operator|(
name|sc
operator|->
name|reg_1
operator|&
name|WB_LDN8_CRF5_SCALE
operator|)
condition|?
literal|60
else|:
literal|1
operator|)
argument_list|,
operator|(
name|sc
operator|->
name|reg_timeout
operator|>
literal|0x00
operator|)
condition|?
literal|" left"
else|:
literal|""
argument_list|,
name|sc
operator|->
name|reg_1
argument_list|,
name|sc
operator|->
name|reg_2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Functions to enter and exit extended function mode.  Possibly shared  * between different chips.  */
end_comment

begin_function
specifier|static
name|int
name|ext_cfg_enter_0x87_0x87
parameter_list|(
name|struct
name|wb_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|baseport
parameter_list|)
block|{
comment|/* 	 * Enable extended function mode. 	 * Winbond does not allow us to validate so always return success. 	 */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
name|baseport
argument_list|,
literal|0x87
argument_list|)
expr_stmt|;
name|write_efir_1
argument_list|(
name|sc
argument_list|,
name|baseport
argument_list|,
literal|0x87
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ext_cfg_exit_0xaa
parameter_list|(
name|struct
name|wb_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|baseport
parameter_list|)
block|{
name|write_efir_1
argument_list|(
name|sc
argument_list|,
name|baseport
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * (Re)load the watchdog counter depending on timeout.  A timeout of 0 will  * disable the watchdog.  */
end_comment

begin_function
specifier|static
name|int
name|wb_set_watchdog
parameter_list|(
name|struct
name|wb_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|timeout
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|debug_verbose
condition|)
name|wb_print_state
argument_list|(
name|sc
argument_list|,
literal|"Before watchdog counter (re)load"
argument_list|)
expr_stmt|;
comment|/* 	 * Enter extended function mode in case someone else has been 	 * poking on the registers.  We will not leave it though. 	 */
if|if
condition|(
call|(
modifier|*
name|sc
operator|->
name|ext_cfg_enter_f
call|)
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Watchdog is configured as part of LDN 8 (GPIO Port2, Watchdog) */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN_REG
argument_list|)
expr_stmt|;
name|write_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN_REG_LDN8
argument_list|)
expr_stmt|;
comment|/* Disable and validate or arm/reset watchdog. */
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
comment|/* Disable watchdog. */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF6
argument_list|)
expr_stmt|;
name|write_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Re-check. */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF6
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg_timeout
operator|=
name|read_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reg_timeout
operator|!=
literal|0x00
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to disable watchdog: "
literal|"0x%02x.\n"
argument_list|,
name|sc
operator|->
name|reg_timeout
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * In case an override is set, let it override.  It may lead 		 * to strange results as we do not check the input of the sysctl. 		 */
if|if
condition|(
name|sc
operator|->
name|timeout_override
operator|>
literal|0
condition|)
name|timeout
operator|=
name|sc
operator|->
name|timeout_override
expr_stmt|;
comment|/* Make sure we support the requested timeout. */
if|if
condition|(
name|timeout
operator|>
literal|255
operator|*
literal|60
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Read current scaling factor. */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF5
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg_1
operator|=
name|read_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|255
condition|)
block|{
comment|/* Set scaling factor to 60s. */
name|sc
operator|->
name|reg_1
operator||=
name|WB_LDN8_CRF5_SCALE
expr_stmt|;
name|sc
operator|->
name|reg_timeout
operator|=
operator|(
name|timeout
operator|/
literal|60
operator|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|%
literal|60
condition|)
name|sc
operator|->
name|reg_timeout
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Set scaling factor to 1s. */
name|sc
operator|->
name|reg_1
operator|&=
operator|~
name|WB_LDN8_CRF5_SCALE
expr_stmt|;
name|sc
operator|->
name|reg_timeout
operator|=
name|timeout
expr_stmt|;
block|}
comment|/* In case we fired before we need to clear to fire again. */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF7
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg_2
operator|=
name|read_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reg_2
operator|&
name|WB_LDN8_CRF7_TS
condition|)
block|{
name|sc
operator|->
name|reg_2
operator|&=
operator|~
name|WB_LDN8_CRF7_TS
expr_stmt|;
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF7
argument_list|)
expr_stmt|;
name|write_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|reg_2
argument_list|)
expr_stmt|;
block|}
comment|/* Write back scaling factor. */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF5
argument_list|)
expr_stmt|;
name|write_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|reg_1
argument_list|)
expr_stmt|;
comment|/* Set timer and arm/reset the watchdog. */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF6
argument_list|)
expr_stmt|;
name|write_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|reg_timeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|debug_verbose
condition|)
name|wb_print_state
argument_list|(
name|sc
argument_list|,
literal|"After watchdog counter (re)load"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * watchdog(9) EVENTHANDLER function implementation to (re)load the counter  * with the given timeout or disable the watchdog.  */
end_comment

begin_function
specifier|static
name|void
name|wb_watchdog_fn
parameter_list|(
name|void
modifier|*
name|private
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|struct
name|wb_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|timeout
decl_stmt|;
name|int
name|e
decl_stmt|;
name|sc
operator|=
name|private
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: watchdog handler function called without "
literal|"softc."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|cmd
operator|&=
name|WD_INTERVAL
expr_stmt|;
if|if
condition|(
name|cmd
operator|>
literal|0
operator|&&
name|cmd
operator|<=
literal|63
condition|)
block|{
comment|/* Reset (and arm) watchdog. */
name|timeout
operator|=
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
name|cmd
operator|)
operator|/
literal|1000000000
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
name|timeout
operator|=
literal|1
expr_stmt|;
name|e
operator|=
name|wb_set_watchdog
argument_list|(
name|sc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|NULL
condition|)
operator|*
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* On error, try to make sure the WD is disabled. */
name|wb_set_watchdog
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Disable watchdog. */
name|e
operator|=
name|wb_set_watchdog
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
literal|0
operator|&&
name|cmd
operator|==
literal|0
operator|&&
name|error
operator|!=
name|NULL
condition|)
block|{
comment|/* Failed to disable watchdog. */
operator|*
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Probe/attach the Winbond Super I/O chip.  *  * Initial abstraction to possibly support more chips:  * - Iterate over the well known base ports, try to enable extended function  *   mode and read and match the device ID and device revision.  Unfortunately  *   the Vendor ID is in the hardware monitoring section accessible by different  *   base ports only.  * - Also HEFRAS, which would tell use the base port, is only accessible after  *   entering extended function mode, for which the base port is needed.  *   At least check HEFRAS to match the current base port we are probing.  * - On match set the description, remember functions to enter/exit extended  *   function mode as well as the base port.  */
end_comment

begin_function
specifier|static
name|int
name|wb_probe_enable
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|probe
parameter_list|)
block|{
name|struct
name|wb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|found
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint8_t
name|dev_id
decl_stmt|,
name|dev_rev
decl_stmt|,
name|cr26
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
name|sc
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
block|}
name|error
operator|=
name|ENXIO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|probe_addrs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|probe_addrs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
comment|/* Allocate bus resources for IO index/data register access. */
name|sc
operator|->
name|portres
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|rid
argument_list|,
name|probe_addrs
index|[
name|i
index|]
operator|.
name|efer
argument_list|,
name|probe_addrs
index|[
name|i
index|]
operator|.
name|efer
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|portres
operator|==
name|NULL
condition|)
continue|continue;
name|sc
operator|->
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|portres
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|portres
argument_list|)
expr_stmt|;
block|}
name|found
operator|=
literal|0
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|probe_addrs
index|[
name|i
index|]
operator|.
name|ext_cfg_enter_f
operator|)
operator|(
name|sc
operator|,
name|probe_addrs
index|[
name|i
index|]
operator|.
name|efer
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Identify the SuperIO chip. */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
name|probe_addrs
index|[
name|i
index|]
operator|.
name|efer
argument_list|,
name|WB_DEVICE_ID_REG
argument_list|)
expr_stmt|;
name|dev_id
operator|=
name|read_efdr_1
argument_list|(
name|sc
argument_list|,
name|probe_addrs
index|[
name|i
index|]
operator|.
name|efer
argument_list|)
expr_stmt|;
name|write_efir_1
argument_list|(
name|sc
argument_list|,
name|probe_addrs
index|[
name|i
index|]
operator|.
name|efer
argument_list|,
name|WB_DEVICE_REV_REG
argument_list|)
expr_stmt|;
name|dev_rev
operator|=
name|read_efdr_1
argument_list|(
name|sc
argument_list|,
name|probe_addrs
index|[
name|i
index|]
operator|.
name|efer
argument_list|)
expr_stmt|;
name|write_efir_1
argument_list|(
name|sc
argument_list|,
name|probe_addrs
index|[
name|i
index|]
operator|.
name|efer
argument_list|,
name|WB_CR26
argument_list|)
expr_stmt|;
name|cr26
operator|=
name|read_efdr_1
argument_list|(
name|sc
argument_list|,
name|probe_addrs
index|[
name|i
index|]
operator|.
name|efer
argument_list|)
expr_stmt|;
comment|/* HEFRAS of 0 means EFER at 0x2e, 1 means EFER at 0x4e. */
if|if
condition|(
operator|(
operator|(
name|cr26
operator|&
literal|0x40
operator|)
operator|==
literal|0x00
operator|&&
name|probe_addrs
index|[
name|i
index|]
operator|.
name|efer
operator|!=
literal|0x2e
operator|)
operator|||
operator|(
operator|(
name|cr26
operator|&
literal|0x40
operator|)
operator|==
literal|0x40
operator|&&
name|probe_addrs
index|[
name|i
index|]
operator|.
name|efer
operator|!=
literal|0x4e
operator|)
condition|)
block|{
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"HEFRAS and EFER do not "
literal|"align: EFER 0x%02x DevID 0x%02x DevRev "
literal|"0x%02x CR26 0x%02x\n"
argument_list|,
name|probe_addrs
index|[
name|i
index|]
operator|.
name|efer
argument_list|,
name|dev_id
argument_list|,
name|dev_rev
argument_list|,
name|cr26
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|dev_id
operator|==
literal|0xff
operator|&&
name|dev_rev
operator|==
literal|0xff
condition|)
goto|goto
name|cleanup
goto|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|wb_devs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|wb_devs
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|wb_devs
index|[
name|j
index|]
operator|.
name|device_id
operator|==
name|dev_id
operator|&&
name|wb_devs
index|[
name|j
index|]
operator|.
name|device_rev
operator|==
name|dev_rev
condition|)
block|{
if|if
condition|(
name|probe
operator|&&
name|dev
operator|!=
name|NULL
condition|)
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|wb_devs
index|[
name|j
index|]
operator|.
name|descr
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|probe
operator|&&
name|dev
operator|!=
name|NULL
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Unknown Winbond/Nuvoton model"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DevID 0x%02x DevRev 0x%02x, "
literal|"please report this.\n"
argument_list|,
name|dev_id
argument_list|,
name|dev_rev
argument_list|)
expr_stmt|;
block|}
name|found
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|probe
operator|&&
name|found
operator|&&
name|bootverbose
operator|&&
name|dev
operator|!=
name|NULL
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s EFER 0x%02x ID 0x%02x Rev 0x%02x"
literal|" CR26 0x%02x (probing)\n"
argument_list|,
name|device_get_desc
argument_list|(
name|dev
argument_list|)
argument_list|,
name|probe_addrs
index|[
name|i
index|]
operator|.
name|efer
argument_list|,
name|dev_id
argument_list|,
name|dev_rev
argument_list|,
name|cr26
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|probe
operator|||
operator|!
name|found
condition|)
block|{
operator|(
operator|*
name|probe_addrs
index|[
name|i
index|]
operator|.
name|ext_cfg_exit_f
operator|)
operator|(
name|sc
operator|,
name|probe_addrs
index|[
name|i
index|]
operator|.
name|efer
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|rid
argument_list|,
name|sc
operator|->
name|portres
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Stop probing if have successfully identified the SuperIO. 		 * Remember the extended function mode enter/exit functions 		 * for operations. 		 */
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|ext_cfg_enter_f
operator|=
name|probe_addrs
index|[
name|i
index|]
operator|.
name|ext_cfg_enter_f
expr_stmt|;
name|sc
operator|->
name|ext_cfg_exit_f
operator|=
name|probe_addrs
index|[
name|i
index|]
operator|.
name|ext_cfg_exit_f
expr_stmt|;
block|}
name|error
operator|=
name|BUS_PROBE_DEFAULT
expr_stmt|;
break|break;
block|}
else|else
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wb_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
if|if
condition|(
operator|(
name|dev
operator|=
name|device_find_child
argument_list|(
name|parent
argument_list|,
name|driver
operator|->
name|name
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|wb_probe_enable
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
operator|!=
name|BUS_PROBE_DEFAULT
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not find compatible Winbond chip.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|dev
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
name|driver
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wb_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* Make sure we do not claim some ISA PNP device. */
if|if
condition|(
name|isa_get_logicalid
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|wb_probe_enable
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wb_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|sctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|soid
decl_stmt|;
name|unsigned
name|long
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|wb_probe_enable
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|ext_cfg_enter_f
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|ext_cfg_exit_f
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: successfull probe result but not setup correctly"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Watchdog is configured as part of LDN 8 (GPIO Port2, Watchdog). */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN_REG
argument_list|)
expr_stmt|;
name|write_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN_REG_LDN8
argument_list|)
expr_stmt|;
comment|/* Make sure LDN8 is enabled (Do we need to? Also affects GPIO). */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CR30
argument_list|)
expr_stmt|;
name|write_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CR30_ACTIVE
argument_list|)
expr_stmt|;
comment|/* Read the current watchdog configuration. */
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF5
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg_1
operator|=
name|read_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF6
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg_timeout
operator|=
name|read_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF7
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg_2
operator|=
name|read_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Print current state if bootverbose or watchdog already enabled. */
if|if
condition|(
name|bootverbose
operator|||
operator|(
name|sc
operator|->
name|reg_timeout
operator|>
literal|0x00
operator|)
condition|)
name|wb_print_state
argument_list|(
name|sc
argument_list|,
literal|"Before watchdog attach"
argument_list|)
expr_stmt|;
comment|/* 	 * Clear a previous watchdog timeout event (if (still) set). 	 * Disable all all interrupt reset sources (defaults). 	 */
name|sc
operator|->
name|reg_1
operator|&=
operator|~
operator|(
name|WB_LDN8_CRF5_KEYB_P20
operator|)
expr_stmt|;
name|sc
operator|->
name|reg_1
operator||=
name|WB_LDN8_CRF5_KBRST
expr_stmt|;
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF5
argument_list|)
expr_stmt|;
name|write_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|reg_1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg_2
operator|&=
operator|~
name|WB_LDN8_CRF7_CLEAR_MASK
expr_stmt|;
name|write_efir_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|WB_LDN8_CRF7
argument_list|)
expr_stmt|;
name|write_efdr_1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|reg_2
argument_list|)
expr_stmt|;
comment|/* Read global timeout override tunable, Add per device sysctls. */
if|if
condition|(
name|TUNABLE_ULONG_FETCH
argument_list|(
literal|"hw.wbwd.timeout_override"
argument_list|,
operator|&
name|timeout
argument_list|)
condition|)
block|{
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
name|sc
operator|->
name|timeout_override
operator|=
name|timeout
expr_stmt|;
block|}
name|sctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|soid
operator|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"timeout_override"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|timeout_override
argument_list|,
literal|0
argument_list|,
literal|"Timeout in seconds overriding default watchdog timeout"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug_verbose"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|debug_verbose
argument_list|,
literal|0
argument_list|,
literal|"Enables extra debugging information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_wb_debug
argument_list|,
literal|"A"
argument_list|,
literal|"Selected register information from last change by driver"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug_current"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_SKIP
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_wb_debug_current
argument_list|,
literal|"A"
argument_list|,
literal|"Selected register information (may interfere)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"force_timeout"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_SKIP
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_wb_force_test_nmi
argument_list|,
literal|"I"
argument_list|,
literal|"Enable to force watchdog to fire."
argument_list|)
expr_stmt|;
comment|/* Register watchdog. */
name|sc
operator|->
name|ev_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|watchdog_list
argument_list|,
name|wb_watchdog_fn
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|wb_print_state
argument_list|(
name|sc
argument_list|,
literal|"After watchdog attach"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wb_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wb_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Unregister and stop the watchdog if running. */
if|if
condition|(
name|sc
operator|->
name|ev_tag
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|watchdog_list
argument_list|,
name|sc
operator|->
name|ev_tag
argument_list|)
expr_stmt|;
name|wb_set_watchdog
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable extended function mode. */
call|(
modifier|*
name|sc
operator|->
name|ext_cfg_exit_f
call|)
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Cleanup resources. */
operator|(
name|void
operator|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|rid
argument_list|,
name|sc
operator|->
name|portres
argument_list|)
expr_stmt|;
comment|/* Bus subroutines take care of sysctls already. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|wb_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|wb_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|wb_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|wb_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|wb_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|wb_isa_driver
init|=
block|{
literal|"wbwd"
block|,
name|wb_methods
block|,
expr|sizeof
operator|(
expr|struct
name|wb_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|wb_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|wb
argument_list|,
name|isa
argument_list|,
name|wb_isa_driver
argument_list|,
name|wb_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

