begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-2001 Granch, Ltd. All rights reserved.  * Author: Denis I.Timofeev<timofeev@granch.ru>  *  * Redistributon and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Device driver for Granch SBNI12 leased line adapters  *  * Revision 2.0.0  1997/08/06  * Initial revision by Alexey Zverev  *  * Revision 2.0.1 1997/08/11  * Additional internal statistics support (tx statistics)  *  * Revision 2.0.2 1997/11/05  * if_bpf bug has been fixed  *  * Revision 2.0.3 1998/12/20  * Memory leakage has been eliminated in  * the sbni_st and sbni_timeout routines.  *  * Revision 3.0 2000/08/10 by Yaroslav Polyakov  * Support for PCI cards. 4.1 modification.  *  * Revision 3.1 2000/09/12  * Removed extra #defines around bpf functions  *  * Revision 4.0 2000/11/23 by Denis Timofeev  * Completely redesigned the buffer management  *  * Revision 4.1 2001/01/21  * Support for PCI Dual cards and new SBNI12D-10, -11 Dual/ISA cards  *  * Written with reference to NE2000 driver developed by David Greenman.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<dev/sbni/if_sbnireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sbni/if_sbnivar.h>
end_include

begin_define
define|#
directive|define
name|ASM_CRC
value|1
end_define

begin_function_decl
specifier|static
name|void
name|sbni_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbni_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbni_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbni_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbni_stop
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_channel
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|card_start
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|recv_frame
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_frame
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upload_data
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|skip_tail
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|interpret_ack
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|download_data
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prepare_to_send
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|drop_xmit_queue
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_rx_buf
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|indicate_pkt
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|change_level
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_fhdr
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|append_frame_to_pkt
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timeout_change_level
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_frame_header
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_initial_values
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|,
name|struct
name|sbni_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|calc_crc32
parameter_list|(
name|u_int32_t
parameter_list|,
name|caddr_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|sbni_timeout
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|__inline
name|u_char
name|sbni_inb
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|,
name|enum
name|sbni_reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|sbni_outb
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|,
name|enum
name|sbni_reg
parameter_list|,
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|sbni_insb
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|sbni_outsb
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_int32_t
name|crc32tab
index|[]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SBNI_DUAL_COMPOUND
end_ifdef

begin_decl_stmt
name|struct
name|sbni_softc
modifier|*
name|headlist
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|u_int32_t
name|next_sbni_unit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|__inline
name|u_char
name|sbni_inb
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|sbni_reg
name|reg
parameter_list|)
block|{
return|return
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|base_addr
operator|+
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|sbni_outb
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|sbni_reg
name|reg
parameter_list|,
name|u_char
name|value
parameter_list|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|base_addr
operator|+
name|reg
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|sbni_insb
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|to
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|insb
argument_list|(
name|sc
operator|->
name|base_addr
operator|+
name|DAT
argument_list|,
name|to
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|sbni_outsb
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|from
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|outsb
argument_list|(
name|sc
operator|->
name|base_addr
operator|+
name|DAT
argument_list|,
name|from
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 	Valid combinations in CSR0 (for probing):  	VALID_DECODER	0000,0011,1011,1010  				    	; 0   ; - 				TR_REQ	; 1   ; + 			TR_RDY	    	; 2   ; - 			TR_RDY	TR_REQ	; 3   ; + 		BU_EMP		    	; 4   ; + 		BU_EMP	     	TR_REQ	; 5   ; + 		BU_EMP	TR_RDY	    	; 6   ; - 		BU_EMP	TR_RDY	TR_REQ	; 7   ; + 	RC_RDY 		     		; 8   ; + 	RC_RDY			TR_REQ	; 9   ; + 	RC_RDY		TR_RDY		; 10  ; - 	RC_RDY		TR_RDY	TR_REQ	; 11  ; - 	RC_RDY	BU_EMP			; 12  ; - 	RC_RDY	BU_EMP		TR_REQ	; 13  ; - 	RC_RDY	BU_EMP	TR_RDY		; 14  ; - 	RC_RDY	BU_EMP	TR_RDY	TR_REQ	; 15  ; - */
end_comment

begin_define
define|#
directive|define
name|VALID_DECODER
value|(2 + 8 + 0x10 + 0x20 + 0x80 + 0x100 + 0x200)
end_define

begin_function
name|int
name|sbni_probe
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|csr0
decl_stmt|;
name|csr0
operator|=
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr0
operator|!=
literal|0xff
operator|&&
name|csr0
operator|!=
literal|0x00
condition|)
block|{
name|csr0
operator|&=
operator|~
name|EN_INT
expr_stmt|;
if|if
condition|(
name|csr0
operator|&
name|BU_EMP
condition|)
name|csr0
operator||=
name|EN_INT
expr_stmt|;
if|if
condition|(
name|VALID_DECODER
operator|&
operator|(
literal|1
operator|<<
operator|(
name|csr0
operator|>>
literal|4
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Install interface into kernel networking data structures  */
end_comment

begin_function
name|void
name|sbni_attach
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|,
name|int
name|unit
parameter_list|,
name|struct
name|sbni_flags
name|flags
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_char
name|csr0
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_initial_values
argument_list|(
name|sc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|wch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifp
operator|->
name|if_name
condition|)
block|{
comment|/* Initialize ifnet structure */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"sbni"
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|sbni_init
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|sbni_start
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|sbni_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|sbni_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
comment|/* report real baud rate */
name|csr0
operator|=
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
operator|(
name|csr0
operator|&
literal|0x01
condition|?
literal|500000
else|:
literal|2000000
operator|)
operator|/
operator|(
literal|1
operator|<<
name|flags
operator|.
name|rate
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
block|}
comment|/* device attach does transition from UNCONFIGURED to IDLE state */
name|printf
argument_list|(
literal|"%s%d: speed %ld, address %6D, rxl "
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|ifp
operator|->
name|if_baudrate
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|delta_rxl
condition|)
name|printf
argument_list|(
literal|"auto\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d (fixed)\n"
argument_list|,
name|sc
operator|->
name|cur_rxl_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|sbni_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|sbni_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sbni_softc
operator|*
operator|)
name|xsc
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/* address not known */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_addrhead
argument_list|)
condition|)
return|return;
comment|/* 	 * kludge to avoid multiple initialization when more than once 	 * protocols configured 	 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|card_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wch
operator|=
name|timeout
argument_list|(
name|sbni_timeout
argument_list|,
name|sc
argument_list|,
name|hz
operator|/
name|SBNI_HZ
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* attempt to start output */
name|sbni_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbni_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sbni_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_frameno
operator|==
literal|0
condition|)
name|prepare_to_send
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbni_stop
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drop_xmit_queue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_buf_p
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|rx_buf_p
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_buf_p
operator|=
name|NULL
expr_stmt|;
block|}
name|untimeout
argument_list|(
name|sbni_timeout
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|wch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wch
operator|.
name|callout
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* interrupt handler */
end_comment

begin_comment
comment|/*  * 	SBNI12D-10, -11/ISA boards within "common interrupt" mode could not  * be looked as two independent single-channel devices. Every channel seems  * as Ethernet interface but interrupt handler must be common. Really, first  * channel ("master") driver only registers the handler. In it's struct softc  * it has got pointer to "slave" channel's struct softc and handles that's  * interrupts too.  *	softc of successfully attached ISA SBNI boards is linked to list.  * While next board driver is initialized, it scans this list. If one  * has found softc with same irq and ioaddr different by 4 then it assumes  * this board to be "master".  */
end_comment

begin_function
name|void
name|sbni_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbni_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|repeat
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sbni_softc
operator|*
operator|)
name|arg
expr_stmt|;
do|do
block|{
name|repeat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
operator|&
operator|(
name|RC_RDY
operator||
name|TR_RDY
operator|)
condition|)
block|{
name|handle_channel
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|slave_sc
comment|/* second channel present */
operator|&&
operator|(
name|sbni_inb
argument_list|(
name|sc
operator|->
name|slave_sc
argument_list|,
name|CSR0
argument_list|)
operator|&
operator|(
name|RC_RDY
operator||
name|TR_RDY
operator|)
operator|)
condition|)
block|{
name|handle_channel
argument_list|(
name|sc
operator|->
name|slave_sc
argument_list|)
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|repeat
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_channel
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|req_ans
decl_stmt|;
name|u_char
name|csr0
decl_stmt|;
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
operator|(
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
operator|&
operator|~
name|EN_INT
operator|)
operator||
name|TR_REQ
argument_list|)
expr_stmt|;
name|sc
operator|->
name|timer_ticks
operator|=
name|CHANGE_LEVEL_START_TICKS
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|csr0
operator|=
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csr0
operator|&
operator|(
name|RC_RDY
operator||
name|TR_RDY
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|req_ans
operator|=
operator|!
operator|(
name|sc
operator|->
name|state
operator|&
name|FL_PREV_OK
operator|)
expr_stmt|;
if|if
condition|(
name|csr0
operator|&
name|RC_RDY
condition|)
name|req_ans
operator|=
name|recv_frame
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * TR_RDY always equals 1 here because we have owned the marker, 		 * and we set TR_REQ when disabled interrupts 		 */
name|csr0
operator|=
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csr0
operator|&
name|TR_RDY
operator|)
operator|==
literal|0
operator|||
operator|(
name|csr0
operator|&
name|RC_RDY
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"sbni: internal error!\n"
argument_list|)
expr_stmt|;
comment|/* if state& FL_NEED_RESEND != 0 then tx_frameno != 0 */
if|if
condition|(
name|req_ans
operator|||
name|sc
operator|->
name|tx_frameno
operator|!=
literal|0
condition|)
name|send_frame
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
comment|/* send the marker without any data */
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
operator|&
operator|~
name|TR_REQ
argument_list|)
expr_stmt|;
block|}
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
operator||
name|EN_INT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine returns 1 if it need to acknoweledge received frame.  * Empty frame received without errors won't be acknoweledged.  */
end_comment

begin_function
specifier|static
name|int
name|recv_frame
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|crc
decl_stmt|;
name|u_int
name|framelen
decl_stmt|,
name|frameno
decl_stmt|,
name|ack
decl_stmt|;
name|u_int
name|is_first
decl_stmt|,
name|frame_ok
decl_stmt|;
name|crc
operator|=
name|CRC32_INITIAL
expr_stmt|;
if|if
condition|(
name|check_fhdr
argument_list|(
name|sc
argument_list|,
operator|&
name|framelen
argument_list|,
operator|&
name|frameno
argument_list|,
operator|&
name|ack
argument_list|,
operator|&
name|is_first
argument_list|,
operator|&
name|crc
argument_list|)
condition|)
block|{
name|frame_ok
operator|=
name|framelen
operator|>
literal|4
condition|?
name|upload_data
argument_list|(
name|sc
argument_list|,
name|framelen
argument_list|,
name|frameno
argument_list|,
name|is_first
argument_list|,
name|crc
argument_list|)
else|:
name|skip_tail
argument_list|(
name|sc
argument_list|,
name|framelen
argument_list|,
name|crc
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_ok
condition|)
name|interpret_ack
argument_list|(
name|sc
argument_list|,
name|ack
argument_list|)
expr_stmt|;
block|}
else|else
name|frame_ok
operator|=
literal|0
expr_stmt|;
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
operator|^
name|CT_ZER
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_ok
condition|)
block|{
name|sc
operator|->
name|state
operator||=
name|FL_PREV_OK
expr_stmt|;
if|if
condition|(
name|framelen
operator|>
literal|4
condition|)
name|sc
operator|->
name|in_stats
operator|.
name|all_rx_number
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|FL_PREV_OK
expr_stmt|;
name|change_level
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|in_stats
operator|.
name|all_rx_number
operator|++
expr_stmt|;
name|sc
operator|->
name|in_stats
operator|.
name|bad_rx_number
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|!
name|frame_ok
operator|||
name|framelen
operator|>
literal|4
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_frame
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|crc
decl_stmt|;
name|u_char
name|csr0
decl_stmt|;
name|crc
operator|=
name|CRC32_INITIAL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|FL_NEED_RESEND
condition|)
block|{
comment|/* if frame was sended but not ACK'ed - resend it */
if|if
condition|(
name|sc
operator|->
name|trans_errors
condition|)
block|{
name|sc
operator|->
name|trans_errors
operator|--
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|framelen
operator|!=
literal|0
condition|)
name|sc
operator|->
name|in_stats
operator|.
name|resend_tx_number
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* cannot xmit with many attempts */
name|drop_xmit_queue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|do_send
goto|;
block|}
block|}
else|else
name|sc
operator|->
name|trans_errors
operator|=
name|TR_ERROR_COUNT
expr_stmt|;
name|send_frame_header
argument_list|(
name|sc
argument_list|,
operator|&
name|crc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator||=
name|FL_NEED_RESEND
expr_stmt|;
comment|/* 	 * FL_NEED_RESEND will be cleared after ACK, but if empty 	 * frame sended then in prepare_to_send next frame 	 */
if|if
condition|(
name|sc
operator|->
name|framelen
condition|)
block|{
name|download_data
argument_list|(
name|sc
argument_list|,
operator|&
name|crc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|in_stats
operator|.
name|all_tx_number
operator|++
expr_stmt|;
name|sc
operator|->
name|state
operator||=
name|FL_WAIT_ACK
expr_stmt|;
block|}
name|sbni_outsb
argument_list|(
name|sc
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|crc
argument_list|,
sizeof|sizeof
name|crc
argument_list|)
expr_stmt|;
name|do_send
label|:
name|csr0
operator|=
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
expr_stmt|;
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|csr0
operator|&
operator|~
name|TR_REQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_frameno
condition|)
block|{
comment|/* next frame exists - request to send */
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|csr0
operator||
name|TR_REQ
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|download_data
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
modifier|*
name|crc_p
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|data_p
decl_stmt|;
name|u_int
name|data_len
decl_stmt|,
name|pos
decl_stmt|,
name|slice
decl_stmt|;
name|data_p
operator|=
name|NULL
expr_stmt|;
comment|/* initialized to avoid warn */
name|pos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|sc
operator|->
name|tx_buf_p
init|;
name|m
operator|!=
name|NULL
operator|&&
name|pos
operator|<
name|sc
operator|->
name|pktlen
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|pos
operator|+
name|m
operator|->
name|m_len
operator|>
name|sc
operator|->
name|outpos
condition|)
block|{
name|data_len
operator|=
name|m
operator|->
name|m_len
operator|-
operator|(
name|sc
operator|->
name|outpos
operator|-
name|pos
operator|)
expr_stmt|;
name|data_p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
operator|(
name|sc
operator|->
name|outpos
operator|-
name|pos
operator|)
expr_stmt|;
goto|goto
name|do_copy
goto|;
block|}
else|else
name|pos
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|data_len
operator|=
literal|0
expr_stmt|;
name|do_copy
label|:
name|pos
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|data_len
condition|)
block|{
name|slice
operator|=
name|min
argument_list|(
name|data_len
argument_list|,
name|sc
operator|->
name|framelen
operator|-
name|pos
argument_list|)
expr_stmt|;
name|sbni_outsb
argument_list|(
name|sc
argument_list|,
name|data_p
argument_list|,
name|slice
argument_list|)
expr_stmt|;
operator|*
name|crc_p
operator|=
name|calc_crc32
argument_list|(
operator|*
name|crc_p
argument_list|,
name|data_p
argument_list|,
name|slice
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|slice
expr_stmt|;
if|if
condition|(
name|data_len
operator|-=
name|slice
condition|)
name|data_p
operator|+=
name|slice
expr_stmt|;
else|else
block|{
do|do
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
do|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|m
condition|)
block|{
name|data_len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|data_p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* frame too short - zero padding */
name|pos
operator|=
name|sc
operator|->
name|framelen
operator|-
name|pos
expr_stmt|;
while|while
condition|(
name|pos
operator|--
condition|)
block|{
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|DAT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|crc_p
operator|=
name|CRC32
argument_list|(
literal|0
argument_list|,
operator|*
name|crc_p
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
do|while
condition|(
name|pos
operator|<
name|sc
operator|->
name|framelen
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|upload_data
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|framelen
parameter_list|,
name|u_int
name|frameno
parameter_list|,
name|u_int
name|is_first
parameter_list|,
name|u_int32_t
name|crc
parameter_list|)
block|{
name|int
name|frame_ok
decl_stmt|;
if|if
condition|(
name|is_first
condition|)
block|{
name|sc
operator|->
name|wait_frameno
operator|=
name|frameno
expr_stmt|;
name|sc
operator|->
name|inppos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|wait_frameno
operator|==
name|frameno
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|inppos
operator|+
name|framelen
operator|<=
name|ETHER_MAX_LEN
condition|)
block|{
name|frame_ok
operator|=
name|append_frame_to_pkt
argument_list|(
name|sc
argument_list|,
name|framelen
argument_list|,
name|crc
argument_list|)
expr_stmt|;
comment|/* 		 * if CRC is right but framelen incorrect then transmitter 		 * error was occured... drop entire packet 		 */
block|}
elseif|else
if|if
condition|(
operator|(
name|frame_ok
operator|=
name|skip_tail
argument_list|(
name|sc
argument_list|,
name|framelen
argument_list|,
name|crc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|wait_frameno
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|inppos
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
comment|/* now skip all frames until is_first != 0 */
block|}
block|}
else|else
name|frame_ok
operator|=
name|skip_tail
argument_list|(
name|sc
argument_list|,
name|framelen
argument_list|,
name|crc
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_first
operator|&&
operator|!
name|frame_ok
condition|)
block|{
comment|/* 		 * Frame has been violated, but we have stored 		 * is_first already... Drop entire packet. 		 */
name|sc
operator|->
name|wait_frameno
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|frame_ok
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|__inline
name|void
name|send_complete
parameter_list|(
name|struct
name|sbni_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|void
name|send_complete
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|tx_buf_p
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_buf_p
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|interpret_ack
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|ack
parameter_list|)
block|{
if|if
condition|(
name|ack
operator|==
name|FRAME_SENT_OK
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|FL_NEED_RESEND
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|FL_WAIT_ACK
condition|)
block|{
name|sc
operator|->
name|outpos
operator|+=
name|sc
operator|->
name|framelen
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|tx_frameno
condition|)
name|sc
operator|->
name|framelen
operator|=
name|min
argument_list|(
name|sc
operator|->
name|maxframe
argument_list|,
name|sc
operator|->
name|pktlen
operator|-
name|sc
operator|->
name|outpos
argument_list|)
expr_stmt|;
else|else
block|{
name|send_complete
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|prepare_to_send
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sc
operator|->
name|state
operator|&=
operator|~
name|FL_WAIT_ACK
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Glue received frame with previous fragments of packet.  * Indicate packet when last frame would be accepted.  */
end_comment

begin_function
specifier|static
name|int
name|append_frame_to_pkt
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|framelen
parameter_list|,
name|u_int32_t
name|crc
parameter_list|)
block|{
name|caddr_t
name|p
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|inppos
operator|+
name|framelen
operator|>
name|ETHER_MAX_LEN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|sc
operator|->
name|rx_buf_p
operator|&&
operator|!
name|get_rx_buf
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|sc
operator|->
name|rx_buf_p
operator|->
name|m_data
operator|+
name|sc
operator|->
name|inppos
expr_stmt|;
name|sbni_insb
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
name|framelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|calc_crc32
argument_list|(
name|crc
argument_list|,
name|p
argument_list|,
name|framelen
argument_list|)
operator|!=
name|CRC32_REMAINDER
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|inppos
operator|+=
name|framelen
operator|-
literal|4
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|wait_frameno
operator|==
literal|0
condition|)
block|{
comment|/* last frame received */
name|indicate_pkt
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepare to start output on adapter. Current priority must be set to splimp  * before this routine is called.  * Transmitter will be actually activated when marker has been accepted.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_to_send
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* sc->tx_buf_p == NULL here! */
if|if
condition|(
name|sc
operator|->
name|tx_buf_p
condition|)
name|printf
argument_list|(
literal|"sbni: memory leak!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|outpos
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|state
operator|&=
operator|~
operator|(
name|FL_WAIT_ACK
operator||
name|FL_NEED_RESEND
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|sc
operator|->
name|tx_buf_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|tx_buf_p
condition|)
block|{
comment|/* nothing to transmit... */
name|sc
operator|->
name|pktlen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tx_frameno
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|framelen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|m
operator|=
name|sc
operator|->
name|tx_buf_p
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
break|break;
name|m_freem
argument_list|(
name|sc
operator|->
name|tx_buf_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
name|SBNI_MIN_LEN
condition|)
name|len
operator|=
name|SBNI_MIN_LEN
expr_stmt|;
name|sc
operator|->
name|pktlen
operator|=
name|len
expr_stmt|;
name|sc
operator|->
name|tx_frameno
operator|=
operator|(
name|len
operator|+
name|sc
operator|->
name|maxframe
operator|-
literal|1
operator|)
operator|/
name|sc
operator|->
name|maxframe
expr_stmt|;
name|sc
operator|->
name|framelen
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|sc
operator|->
name|maxframe
argument_list|)
expr_stmt|;
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
operator||
name|TR_REQ
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|sc
operator|->
name|tx_buf_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|drop_xmit_queue
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_buf_p
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|tx_buf_p
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_buf_p
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
name|sc
operator|->
name|tx_frameno
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|framelen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|outpos
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|state
operator|&=
operator|~
operator|(
name|FL_WAIT_ACK
operator||
name|FL_NEED_RESEND
operator|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_frame_header
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
modifier|*
name|crc_p
parameter_list|)
block|{
name|u_int32_t
name|crc
decl_stmt|;
name|u_int
name|len_field
decl_stmt|;
name|u_char
name|value
decl_stmt|;
name|crc
operator|=
operator|*
name|crc_p
expr_stmt|;
name|len_field
operator|=
name|sc
operator|->
name|framelen
operator|+
literal|6
expr_stmt|;
comment|/* CRC + frameno + reserved */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|FL_NEED_RESEND
condition|)
name|len_field
operator||=
name|FRAME_RETRY
expr_stmt|;
comment|/* non-first attempt... */
if|if
condition|(
name|sc
operator|->
name|outpos
operator|==
literal|0
condition|)
name|len_field
operator||=
name|FRAME_FIRST
expr_stmt|;
name|len_field
operator||=
operator|(
name|sc
operator|->
name|state
operator|&
name|FL_PREV_OK
operator|)
condition|?
name|FRAME_SENT_OK
else|:
name|FRAME_SENT_BAD
expr_stmt|;
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|DAT
argument_list|,
name|SBNI_SIG
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|u_char
operator|)
name|len_field
expr_stmt|;
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|DAT
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|crc
operator|=
name|CRC32
argument_list|(
name|value
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|value
operator|=
call|(
name|u_char
call|)
argument_list|(
name|len_field
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|DAT
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|crc
operator|=
name|CRC32
argument_list|(
name|value
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|DAT
argument_list|,
name|sc
operator|->
name|tx_frameno
argument_list|)
expr_stmt|;
name|crc
operator|=
name|CRC32
argument_list|(
name|sc
operator|->
name|tx_frameno
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|DAT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crc
operator|=
name|CRC32
argument_list|(
literal|0
argument_list|,
name|crc
argument_list|)
expr_stmt|;
operator|*
name|crc_p
operator|=
name|crc
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * if frame tail not needed (incorrect number or received twice),  * it won't store, but CRC will be calculated  */
end_comment

begin_function
specifier|static
name|int
name|skip_tail
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|tail_len
parameter_list|,
name|u_int32_t
name|crc
parameter_list|)
block|{
while|while
condition|(
name|tail_len
operator|--
condition|)
name|crc
operator|=
name|CRC32
argument_list|(
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|DAT
argument_list|)
argument_list|,
name|crc
argument_list|)
expr_stmt|;
return|return
operator|(
name|crc
operator|==
name|CRC32_REMAINDER
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_fhdr
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|,
name|u_int
modifier|*
name|framelen
parameter_list|,
name|u_int
modifier|*
name|frameno
parameter_list|,
name|u_int
modifier|*
name|ack
parameter_list|,
name|u_int
modifier|*
name|is_first
parameter_list|,
name|u_int32_t
modifier|*
name|crc_p
parameter_list|)
block|{
name|u_int32_t
name|crc
decl_stmt|;
name|u_char
name|value
decl_stmt|;
name|crc
operator|=
operator|*
name|crc_p
expr_stmt|;
if|if
condition|(
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|DAT
argument_list|)
operator|!=
name|SBNI_SIG
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|value
operator|=
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|DAT
argument_list|)
expr_stmt|;
operator|*
name|framelen
operator|=
operator|(
name|u_int
operator|)
name|value
expr_stmt|;
name|crc
operator|=
name|CRC32
argument_list|(
name|value
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|value
operator|=
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|DAT
argument_list|)
expr_stmt|;
operator|*
name|framelen
operator||=
operator|(
operator|(
name|u_int
operator|)
name|value
operator|)
operator|<<
literal|8
expr_stmt|;
name|crc
operator|=
name|CRC32
argument_list|(
name|value
argument_list|,
name|crc
argument_list|)
expr_stmt|;
operator|*
name|ack
operator|=
operator|*
name|framelen
operator|&
name|FRAME_ACK_MASK
expr_stmt|;
operator|*
name|is_first
operator|=
operator|(
operator|*
name|framelen
operator|&
name|FRAME_FIRST
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|framelen
operator|&=
name|FRAME_LEN_MASK
operator|)
operator|<
literal|6
operator|||
operator|*
name|framelen
operator|>
name|SBNI_MAX_FRAME
operator|-
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|value
operator|=
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|DAT
argument_list|)
expr_stmt|;
operator|*
name|frameno
operator|=
operator|(
name|u_int
operator|)
name|value
expr_stmt|;
name|crc
operator|=
name|CRC32
argument_list|(
name|value
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|crc
operator|=
name|CRC32
argument_list|(
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|DAT
argument_list|)
argument_list|,
name|crc
argument_list|)
expr_stmt|;
comment|/* reserved byte */
operator|*
name|framelen
operator|-=
literal|2
expr_stmt|;
operator|*
name|crc_p
operator|=
name|crc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_rx_buf
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sbni%d: cannot allocate header mbuf\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We always put the received packet in a single buffer - 	 * either with just an mbuf header or in a cluster attached 	 * to the header. The +2 is to compensate for the alignment 	 * fixup below. 	 */
if|if
condition|(
name|ETHER_MAX_LEN
operator|+
literal|2
operator|>
name|MHLEN
condition|)
block|{
comment|/* Attach an mbuf cluster */
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|ETHER_MAX_LEN
operator|+
literal|2
expr_stmt|;
comment|/* 	 * The +2 is to longword align the start of the real packet. 	 * (sizeof ether_header == 14) 	 * This is important for NFS. 	 */
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_buf_p
operator|=
name|m
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|indicate_pkt
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|m
operator|=
name|sc
operator|->
name|rx_buf_p
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|sc
operator|->
name|inppos
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* Remove link layer address and indicate packet */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_buf_p
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Routine checks periodically wire activity and regenerates marker if  * connect was inactive for a long time.  */
end_comment

begin_function
specifier|static
name|void
name|sbni_timeout
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|sbni_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_char
name|csr0
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sbni_softc
operator|*
operator|)
name|xsc
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|csr0
operator|=
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr0
operator|&
name|RC_CHK
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|timer_ticks
condition|)
block|{
if|if
condition|(
name|csr0
operator|&
operator|(
name|RC_RDY
operator||
name|BU_EMP
operator|)
condition|)
comment|/* receiving not active */
name|sc
operator|->
name|timer_ticks
operator|--
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|in_stats
operator|.
name|timeout_number
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|delta_rxl
condition|)
name|timeout_change_level
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR1
argument_list|,
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sc
operator|->
name|csr1
operator||
name|PR_RES
argument_list|)
expr_stmt|;
name|csr0
operator|=
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
expr_stmt|;
block|}
block|}
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|csr0
operator||
name|RC_CHK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wch
operator|=
name|timeout
argument_list|(
name|sbni_timeout
argument_list|,
name|sc
argument_list|,
name|hz
operator|/
name|SBNI_HZ
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|card_start
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|timer_ticks
operator|=
name|CHANGE_LEVEL_START_TICKS
expr_stmt|;
name|sc
operator|->
name|state
operator|&=
operator|~
operator|(
name|FL_WAIT_ACK
operator||
name|FL_NEED_RESEND
operator|)
expr_stmt|;
name|sc
operator|->
name|state
operator||=
name|FL_PREV_OK
expr_stmt|;
name|sc
operator|->
name|inppos
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|wait_frameno
operator|=
literal|0
expr_stmt|;
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR1
argument_list|,
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sc
operator|->
name|csr1
operator||
name|PR_RES
argument_list|)
expr_stmt|;
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|,
name|EN_INT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Device timeout/watchdog routine. Entered if the device neglects to  *	generate an interrupt after a transmit has been started on it.  */
end_comment

begin_function
specifier|static
name|void
name|sbni_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sbni%d: device timeout\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|u_char
name|rxl_tab
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x08
block|,
literal|0x0a
block|,
literal|0x0c
block|,
literal|0x0f
block|,
literal|0x16
block|,
literal|0x18
block|,
literal|0x1a
block|,
literal|0x1c
block|,
literal|0x1f
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SIZE_OF_TIMEOUT_RXL_TAB
value|4
end_define

begin_decl_stmt
specifier|static
name|u_char
name|timeout_rxl_tab
index|[]
init|=
block|{
literal|0x03
block|,
literal|0x05
block|,
literal|0x08
block|,
literal|0x0b
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_initial_values
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|sbni_flags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|.
name|fixed_rxl
condition|)
block|{
name|sc
operator|->
name|delta_rxl
operator|=
literal|0
expr_stmt|;
comment|/* disable receive level autodetection */
name|sc
operator|->
name|cur_rxl_index
operator|=
name|flags
operator|.
name|rxl
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|delta_rxl
operator|=
name|DEF_RXL_DELTA
expr_stmt|;
name|sc
operator|->
name|cur_rxl_index
operator|=
name|DEF_RXL
expr_stmt|;
block|}
name|sc
operator|->
name|csr1
operator|.
name|rate
operator|=
name|flags
operator|.
name|fixed_rate
condition|?
name|flags
operator|.
name|rate
else|:
name|DEFAULT_RATE
expr_stmt|;
name|sc
operator|->
name|csr1
operator|.
name|rxl
operator|=
name|rxl_tab
index|[
name|sc
operator|->
name|cur_rxl_index
index|]
expr_stmt|;
name|sc
operator|->
name|maxframe
operator|=
name|DEFAULT_FRAME_LEN
expr_stmt|;
comment|/* 	 * generate Ethernet address (0x00ff01xxxxxx) 	 */
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|=
name|htons
argument_list|(
literal|0x00ff
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|mac_addr
condition|)
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|+
literal|2
operator|)
operator|=
name|htonl
argument_list|(
name|flags
operator|.
name|mac_addr
operator||
literal|0x01000000
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* reading timer value */
name|outb
argument_list|(
literal|0x43
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insb
argument_list|(
literal|0x40
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|+
literal|3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|+
literal|2
operator|)
operator|=
literal|0x01
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SBNI_DUAL_COMPOUND
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|offsetof
end_ifndef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|type
parameter_list|,
name|member
parameter_list|)
value|((u_int32_t)(&((type *)0)->member))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|sbni_softc
modifier|*
name|connect_to_master
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sbni_softc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|sbni_softc
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|headlist
operator|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|sbni_softc
argument_list|,
name|link
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|->
name|link
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
name|p
operator|->
name|link
operator|->
name|irq
operator|==
name|sc
operator|->
name|irq
operator|&&
operator|(
name|p
operator|->
name|link
operator|->
name|base_addr
operator|==
name|sc
operator|->
name|base_addr
operator|+
literal|4
operator|||
name|p
operator|->
name|link
operator|->
name|base_addr
operator|==
name|sc
operator|->
name|base_addr
operator|-
literal|4
operator|)
condition|)
block|{
name|struct
name|sbni_softc
modifier|*
name|t
init|=
name|p
operator|->
name|link
decl_stmt|;
name|t
operator|->
name|slave_sc
operator|=
name|sc
expr_stmt|;
name|p
operator|->
name|link
operator|=
name|p
operator|->
name|link
operator|->
name|link
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SBNI_DUAL_COMPOUND */
end_comment

begin_comment
comment|/* Receive level auto-selection */
end_comment

begin_function
specifier|static
name|void
name|change_level
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|delta_rxl
operator|==
literal|0
condition|)
comment|/* do not auto-negotiate RxL */
return|return;
if|if
condition|(
name|sc
operator|->
name|cur_rxl_index
operator|==
literal|0
condition|)
name|sc
operator|->
name|delta_rxl
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|cur_rxl_index
operator|==
literal|15
condition|)
name|sc
operator|->
name|delta_rxl
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|cur_rxl_rcvd
operator|<
name|sc
operator|->
name|prev_rxl_rcvd
condition|)
name|sc
operator|->
name|delta_rxl
operator|=
operator|-
name|sc
operator|->
name|delta_rxl
expr_stmt|;
name|sc
operator|->
name|csr1
operator|.
name|rxl
operator|=
name|rxl_tab
index|[
name|sc
operator|->
name|cur_rxl_index
operator|+=
name|sc
operator|->
name|delta_rxl
index|]
expr_stmt|;
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
expr_stmt|;
comment|/* it needed for PCI cards */
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR1
argument_list|,
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sc
operator|->
name|csr1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|prev_rxl_rcvd
operator|=
name|sc
operator|->
name|cur_rxl_rcvd
expr_stmt|;
name|sc
operator|->
name|cur_rxl_rcvd
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|timeout_change_level
parameter_list|(
name|struct
name|sbni_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|cur_rxl_index
operator|=
name|timeout_rxl_tab
index|[
name|sc
operator|->
name|timeout_rxl
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|sc
operator|->
name|timeout_rxl
operator|>=
literal|4
condition|)
name|sc
operator|->
name|timeout_rxl
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|csr1
operator|.
name|rxl
operator|=
name|rxl_tab
index|[
name|sc
operator|->
name|cur_rxl_index
index|]
expr_stmt|;
name|sbni_inb
argument_list|(
name|sc
argument_list|,
name|CSR0
argument_list|)
expr_stmt|;
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR1
argument_list|,
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sc
operator|->
name|csr1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|prev_rxl_rcvd
operator|=
name|sc
operator|->
name|cur_rxl_rcvd
expr_stmt|;
name|sc
operator|->
name|cur_rxl_rcvd
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Process an ioctl request. This code needs some work - it looks  *	pretty ugly.  */
end_comment

begin_function
specifier|static
name|int
name|sbni_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|sbni_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|sbni_in_stats
modifier|*
name|in_stats
decl_stmt|;
name|struct
name|sbni_flags
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|p
operator|=
name|curproc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * If the interface is marked up and stopped, then start it. 		 * If it is marked down and running, then stop it. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
name|sbni_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|sbni_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 		 * Multicast list has changed; set the hardware filter 		 * accordingly. 		 */
name|error
operator|=
literal|0
expr_stmt|;
comment|/* if (ifr == NULL) 			error = EAFNOSUPPORT; */
break|break;
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
break|break;
comment|/* 		 * SBNI specific ioctl 		 */
case|case
name|SIOCGHWFLAGS
case|:
comment|/* get flags */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|+
literal|3
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|flags
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|flags
operator|.
name|rxl
operator|=
name|sc
operator|->
name|cur_rxl_index
expr_stmt|;
name|flags
operator|.
name|rate
operator|=
name|sc
operator|->
name|csr1
operator|.
name|rate
expr_stmt|;
name|flags
operator|.
name|fixed_rxl
operator|=
operator|(
name|sc
operator|->
name|delta_rxl
operator|==
literal|0
operator|)
expr_stmt|;
name|flags
operator|.
name|fixed_rate
operator|=
literal|1
expr_stmt|;
name|ifr
operator|->
name|ifr_data
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
operator|&
name|flags
expr_stmt|;
break|break;
case|case
name|SIOCGINSTATS
case|:
name|in_stats
operator|=
operator|(
expr|struct
name|sbni_in_stats
operator|*
operator|)
name|ifr
operator|->
name|ifr_data
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
operator|(
name|sc
operator|->
name|in_stats
operator|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|in_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbni_in_stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSHWFLAGS
case|:
comment|/* set flags */
comment|/* root only */
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|flags
operator|=
operator|*
operator|(
expr|struct
name|sbni_flags
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|fixed_rxl
condition|)
block|{
name|sc
operator|->
name|delta_rxl
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|cur_rxl_index
operator|=
name|flags
operator|.
name|rxl
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|delta_rxl
operator|=
name|DEF_RXL_DELTA
expr_stmt|;
name|sc
operator|->
name|cur_rxl_index
operator|=
name|DEF_RXL
expr_stmt|;
block|}
name|sc
operator|->
name|csr1
operator|.
name|rxl
operator|=
name|rxl_tab
index|[
name|sc
operator|->
name|cur_rxl_index
index|]
expr_stmt|;
name|sc
operator|->
name|csr1
operator|.
name|rate
operator|=
name|flags
operator|.
name|fixed_rate
condition|?
name|flags
operator|.
name|rate
else|:
name|DEFAULT_RATE
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|mac_addr
condition|)
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|flags
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|+
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Don't be afraid... */
name|sbni_outb
argument_list|(
name|sc
argument_list|,
name|CSR1
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|sc
operator|->
name|csr1
operator|)
operator||
name|PR_RES
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCRINSTATS
case|:
if|if
condition|(
operator|!
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
operator|)
condition|)
comment|/* root only */
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|in_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbni_in_stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------------- */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_CRC
end_ifdef

begin_function
specifier|static
name|u_int32_t
name|calc_crc32
parameter_list|(
name|u_int32_t
name|crc
parameter_list|,
name|caddr_t
name|p
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
specifier|register
name|u_int32_t
name|_crc
asm|__asm ("ax");
name|_crc
init|=
name|crc
decl_stmt|;
asm|__asm __volatile (
literal|"xorl	%%ebx, %%ebx\n"
literal|"movl	%1, %%esi\n"
literal|"movl	%2, %%ecx\n"
literal|"movl	$crc32tab, %%edi\n"
literal|"shrl	$2, %%ecx\n"
literal|"jz	1f\n"
literal|".align 4\n"
literal|"0:\n"
literal|"movb	%%al, %%bl\n"
literal|"movl	(%%esi), %%edx\n"
literal|"shrl	$8, %%eax\n"
literal|"xorb	%%dl, %%bl\n"
literal|"shrl	$8, %%edx\n"
literal|"xorl	(%%edi,%%ebx,4), %%eax\n"
literal|"movb	%%al, %%bl\n"
literal|"shrl	$8, %%eax\n"
literal|"xorb	%%dl, %%bl\n"
literal|"shrl	$8, %%edx\n"
literal|"xorl	(%%edi,%%ebx,4), %%eax\n"
literal|"movb	%%al, %%bl\n"
literal|"shrl	$8, %%eax\n"
literal|"xorb	%%dl, %%bl\n"
literal|"movb	%%dh, %%dl\n"
literal|"xorl	(%%edi,%%ebx,4), %%eax\n"
literal|"movb	%%al, %%bl\n"
literal|"shrl	$8, %%eax\n"
literal|"xorb	%%dl, %%bl\n"
literal|"addl	$4, %%esi\n"
literal|"xorl	(%%edi,%%ebx,4), %%eax\n"
literal|"decl	%%ecx\n"
literal|"jnz	0b\n"
literal|"1:\n"
literal|"movl	%2, %%ecx\n"
literal|"andl	$3, %%ecx\n"
literal|"jz	2f\n"
literal|"movb	%%al, %%bl\n"
literal|"shrl	$8, %%eax\n"
literal|"xorb	(%%esi), %%bl\n"
literal|"xorl	(%%edi,%%ebx,4), %%eax\n"
literal|"decl	%%ecx\n"
literal|"jz	2f\n"
literal|"movb	%%al, %%bl\n"
literal|"shrl	$8, %%eax\n"
literal|"xorb	1(%%esi), %%bl\n"
literal|"xorl	(%%edi,%%ebx,4), %%eax\n"
literal|"decl	%%ecx\n"
literal|"jz	2f\n"
literal|"movb	%%al, %%bl\n"
literal|"shrl	$8, %%eax\n"
literal|"xorb	2(%%esi), %%bl\n"
literal|"xorl	(%%edi,%%ebx,4), %%eax\n"
literal|"2:\n"
operator|:
operator|:
literal|"a"
operator|(
name|_crc
operator|)
operator|,
literal|"g"
operator|(
name|p
operator|)
operator|,
literal|"g"
operator|(
name|len
operator|)
operator|:
literal|"ax"
operator|,
literal|"bx"
operator|,
literal|"cx"
operator|,
literal|"dx"
operator|,
literal|"si"
operator|,
literal|"di"
block|)
function|;
end_function

begin_return
return|return
operator|(
name|_crc
operator|)
return|;
end_return

begin_else
unit|}
else|#
directive|else
end_else

begin_comment
comment|/* ASM_CRC */
end_comment

begin_function
unit|static
name|u_int32_t
name|calc_crc32
parameter_list|(
name|u_int32_t
name|crc
parameter_list|,
name|caddr_t
name|p
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
while|while
condition|(
name|len
operator|--
condition|)
name|crc
operator|=
name|CRC32
argument_list|(
operator|*
name|p
operator|++
argument_list|,
name|crc
argument_list|)
expr_stmt|;
return|return
operator|(
name|crc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ASM_CRC */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|crc32tab
index|[]
name|__attribute__
argument_list|(
operator|(
name|aligned
argument_list|(
literal|8
argument_list|)
operator|)
argument_list|)
init|=
block|{
literal|0xD202EF8D
block|,
literal|0xA505DF1B
block|,
literal|0x3C0C8EA1
block|,
literal|0x4B0BBE37
block|,
literal|0xD56F2B94
block|,
literal|0xA2681B02
block|,
literal|0x3B614AB8
block|,
literal|0x4C667A2E
block|,
literal|0xDCD967BF
block|,
literal|0xABDE5729
block|,
literal|0x32D70693
block|,
literal|0x45D03605
block|,
literal|0xDBB4A3A6
block|,
literal|0xACB39330
block|,
literal|0x35BAC28A
block|,
literal|0x42BDF21C
block|,
literal|0xCFB5FFE9
block|,
literal|0xB8B2CF7F
block|,
literal|0x21BB9EC5
block|,
literal|0x56BCAE53
block|,
literal|0xC8D83BF0
block|,
literal|0xBFDF0B66
block|,
literal|0x26D65ADC
block|,
literal|0x51D16A4A
block|,
literal|0xC16E77DB
block|,
literal|0xB669474D
block|,
literal|0x2F6016F7
block|,
literal|0x58672661
block|,
literal|0xC603B3C2
block|,
literal|0xB1048354
block|,
literal|0x280DD2EE
block|,
literal|0x5F0AE278
block|,
literal|0xE96CCF45
block|,
literal|0x9E6BFFD3
block|,
literal|0x0762AE69
block|,
literal|0x70659EFF
block|,
literal|0xEE010B5C
block|,
literal|0x99063BCA
block|,
literal|0x000F6A70
block|,
literal|0x77085AE6
block|,
literal|0xE7B74777
block|,
literal|0x90B077E1
block|,
literal|0x09B9265B
block|,
literal|0x7EBE16CD
block|,
literal|0xE0DA836E
block|,
literal|0x97DDB3F8
block|,
literal|0x0ED4E242
block|,
literal|0x79D3D2D4
block|,
literal|0xF4DBDF21
block|,
literal|0x83DCEFB7
block|,
literal|0x1AD5BE0D
block|,
literal|0x6DD28E9B
block|,
literal|0xF3B61B38
block|,
literal|0x84B12BAE
block|,
literal|0x1DB87A14
block|,
literal|0x6ABF4A82
block|,
literal|0xFA005713
block|,
literal|0x8D076785
block|,
literal|0x140E363F
block|,
literal|0x630906A9
block|,
literal|0xFD6D930A
block|,
literal|0x8A6AA39C
block|,
literal|0x1363F226
block|,
literal|0x6464C2B0
block|,
literal|0xA4DEAE1D
block|,
literal|0xD3D99E8B
block|,
literal|0x4AD0CF31
block|,
literal|0x3DD7FFA7
block|,
literal|0xA3B36A04
block|,
literal|0xD4B45A92
block|,
literal|0x4DBD0B28
block|,
literal|0x3ABA3BBE
block|,
literal|0xAA05262F
block|,
literal|0xDD0216B9
block|,
literal|0x440B4703
block|,
literal|0x330C7795
block|,
literal|0xAD68E236
block|,
literal|0xDA6FD2A0
block|,
literal|0x4366831A
block|,
literal|0x3461B38C
block|,
literal|0xB969BE79
block|,
literal|0xCE6E8EEF
block|,
literal|0x5767DF55
block|,
literal|0x2060EFC3
block|,
literal|0xBE047A60
block|,
literal|0xC9034AF6
block|,
literal|0x500A1B4C
block|,
literal|0x270D2BDA
block|,
literal|0xB7B2364B
block|,
literal|0xC0B506DD
block|,
literal|0x59BC5767
block|,
literal|0x2EBB67F1
block|,
literal|0xB0DFF252
block|,
literal|0xC7D8C2C4
block|,
literal|0x5ED1937E
block|,
literal|0x29D6A3E8
block|,
literal|0x9FB08ED5
block|,
literal|0xE8B7BE43
block|,
literal|0x71BEEFF9
block|,
literal|0x06B9DF6F
block|,
literal|0x98DD4ACC
block|,
literal|0xEFDA7A5A
block|,
literal|0x76D32BE0
block|,
literal|0x01D41B76
block|,
literal|0x916B06E7
block|,
literal|0xE66C3671
block|,
literal|0x7F6567CB
block|,
literal|0x0862575D
block|,
literal|0x9606C2FE
block|,
literal|0xE101F268
block|,
literal|0x7808A3D2
block|,
literal|0x0F0F9344
block|,
literal|0x82079EB1
block|,
literal|0xF500AE27
block|,
literal|0x6C09FF9D
block|,
literal|0x1B0ECF0B
block|,
literal|0x856A5AA8
block|,
literal|0xF26D6A3E
block|,
literal|0x6B643B84
block|,
literal|0x1C630B12
block|,
literal|0x8CDC1683
block|,
literal|0xFBDB2615
block|,
literal|0x62D277AF
block|,
literal|0x15D54739
block|,
literal|0x8BB1D29A
block|,
literal|0xFCB6E20C
block|,
literal|0x65BFB3B6
block|,
literal|0x12B88320
block|,
literal|0x3FBA6CAD
block|,
literal|0x48BD5C3B
block|,
literal|0xD1B40D81
block|,
literal|0xA6B33D17
block|,
literal|0x38D7A8B4
block|,
literal|0x4FD09822
block|,
literal|0xD6D9C998
block|,
literal|0xA1DEF90E
block|,
literal|0x3161E49F
block|,
literal|0x4666D409
block|,
literal|0xDF6F85B3
block|,
literal|0xA868B525
block|,
literal|0x360C2086
block|,
literal|0x410B1010
block|,
literal|0xD80241AA
block|,
literal|0xAF05713C
block|,
literal|0x220D7CC9
block|,
literal|0x550A4C5F
block|,
literal|0xCC031DE5
block|,
literal|0xBB042D73
block|,
literal|0x2560B8D0
block|,
literal|0x52678846
block|,
literal|0xCB6ED9FC
block|,
literal|0xBC69E96A
block|,
literal|0x2CD6F4FB
block|,
literal|0x5BD1C46D
block|,
literal|0xC2D895D7
block|,
literal|0xB5DFA541
block|,
literal|0x2BBB30E2
block|,
literal|0x5CBC0074
block|,
literal|0xC5B551CE
block|,
literal|0xB2B26158
block|,
literal|0x04D44C65
block|,
literal|0x73D37CF3
block|,
literal|0xEADA2D49
block|,
literal|0x9DDD1DDF
block|,
literal|0x03B9887C
block|,
literal|0x74BEB8EA
block|,
literal|0xEDB7E950
block|,
literal|0x9AB0D9C6
block|,
literal|0x0A0FC457
block|,
literal|0x7D08F4C1
block|,
literal|0xE401A57B
block|,
literal|0x930695ED
block|,
literal|0x0D62004E
block|,
literal|0x7A6530D8
block|,
literal|0xE36C6162
block|,
literal|0x946B51F4
block|,
literal|0x19635C01
block|,
literal|0x6E646C97
block|,
literal|0xF76D3D2D
block|,
literal|0x806A0DBB
block|,
literal|0x1E0E9818
block|,
literal|0x6909A88E
block|,
literal|0xF000F934
block|,
literal|0x8707C9A2
block|,
literal|0x17B8D433
block|,
literal|0x60BFE4A5
block|,
literal|0xF9B6B51F
block|,
literal|0x8EB18589
block|,
literal|0x10D5102A
block|,
literal|0x67D220BC
block|,
literal|0xFEDB7106
block|,
literal|0x89DC4190
block|,
literal|0x49662D3D
block|,
literal|0x3E611DAB
block|,
literal|0xA7684C11
block|,
literal|0xD06F7C87
block|,
literal|0x4E0BE924
block|,
literal|0x390CD9B2
block|,
literal|0xA0058808
block|,
literal|0xD702B89E
block|,
literal|0x47BDA50F
block|,
literal|0x30BA9599
block|,
literal|0xA9B3C423
block|,
literal|0xDEB4F4B5
block|,
literal|0x40D06116
block|,
literal|0x37D75180
block|,
literal|0xAEDE003A
block|,
literal|0xD9D930AC
block|,
literal|0x54D13D59
block|,
literal|0x23D60DCF
block|,
literal|0xBADF5C75
block|,
literal|0xCDD86CE3
block|,
literal|0x53BCF940
block|,
literal|0x24BBC9D6
block|,
literal|0xBDB2986C
block|,
literal|0xCAB5A8FA
block|,
literal|0x5A0AB56B
block|,
literal|0x2D0D85FD
block|,
literal|0xB404D447
block|,
literal|0xC303E4D1
block|,
literal|0x5D677172
block|,
literal|0x2A6041E4
block|,
literal|0xB369105E
block|,
literal|0xC46E20C8
block|,
literal|0x72080DF5
block|,
literal|0x050F3D63
block|,
literal|0x9C066CD9
block|,
literal|0xEB015C4F
block|,
literal|0x7565C9EC
block|,
literal|0x0262F97A
block|,
literal|0x9B6BA8C0
block|,
literal|0xEC6C9856
block|,
literal|0x7CD385C7
block|,
literal|0x0BD4B551
block|,
literal|0x92DDE4EB
block|,
literal|0xE5DAD47D
block|,
literal|0x7BBE41DE
block|,
literal|0x0CB97148
block|,
literal|0x95B020F2
block|,
literal|0xE2B71064
block|,
literal|0x6FBF1D91
block|,
literal|0x18B82D07
block|,
literal|0x81B17CBD
block|,
literal|0xF6B64C2B
block|,
literal|0x68D2D988
block|,
literal|0x1FD5E91E
block|,
literal|0x86DCB8A4
block|,
literal|0xF1DB8832
block|,
literal|0x616495A3
block|,
literal|0x1663A535
block|,
literal|0x8F6AF48F
block|,
literal|0xF86DC419
block|,
literal|0x660951BA
block|,
literal|0x110E612C
block|,
literal|0x88073096
block|,
literal|0xFF000000
block|}
decl_stmt|;
end_decl_stmt

end_unit

