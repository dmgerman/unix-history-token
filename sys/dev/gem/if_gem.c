begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2001 Eduardo Horvath.  * Copyright (c) 2001-2003 Thomas Moestl  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR  ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: NetBSD: gem.c,v 1.21 2002/06/01 23:50:58 lukem Exp  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for Sun GEM ethernet controllers.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|GEM_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/gem/if_gemreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/gem/if_gemvar.h>
end_include

begin_define
define|#
directive|define
name|TRIES
value|10000
end_define

begin_function_decl
specifier|static
name|void
name|gem_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_cddma_callback
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_rxdma_callback
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bus_size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_txdma_callback
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bus_size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_init_regs
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_ringsize
parameter_list|(
name|int
name|sz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_meminit
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_load_txmbuf
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_mifinit
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_bitwait
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|r
parameter_list|,
name|u_int32_t
name|clr
parameter_list|,
name|u_int32_t
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_reset_rx
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_reset_tx
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_disable_rx
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_disable_tx
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_rxdrain
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_add_rxbuf
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_setladrf
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|mbuf
modifier|*
name|gem_get
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_eint
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_rint
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void	gem_rint_timeout(void *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|gem_tint
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function_decl
specifier|static
name|void
name|gem_power
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|devclass_t
name|gem_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|gem
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|gem
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GEM_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_define
define|#
directive|define
name|KTR_GEM
value|KTR_CT2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GEM_NSEGS
value|GEM_NTXDESC
end_define

begin_comment
comment|/*  * gem_attach:  *  *	Attach a Gem interface to the system.  */
end_comment

begin_function
name|int
name|gem_attach
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mii_softc
modifier|*
name|child
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* Make sure the chip is stopped. */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|gem_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
name|GEM_NSEGS
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_pdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail_ifnet
goto|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MAXBSIZE
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_rdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail_ptag
goto|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|GEM_TD_BUFSIZE
argument_list|,
name|GEM_NTXDESC
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_tdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail_rtag
goto|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gem_control_data
argument_list|)
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gem_control_data
argument_list|)
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail_ttag
goto|;
comment|/* 	 * Allocate the control data structures, and create and load the 	 * DMA map for it. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_control_data
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_cddmamap
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to allocate control data,"
literal|" error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_ctag
goto|;
block|}
name|sc
operator|->
name|sc_cddma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|,
name|sc
operator|->
name|sc_control_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gem_control_data
argument_list|)
argument_list|,
name|gem_cddma_callback
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|||
name|sc
operator|->
name|sc_cddma
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to load control data DMA "
literal|"map, error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_cmem
goto|;
block|}
comment|/* 	 * Initialize the transmit job descriptors. 	 */
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
expr_stmt|;
comment|/* 	 * Create the transmit buffer DMA maps. 	 */
name|error
operator|=
name|ENOMEM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_TXQUEUELEN
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|gem_txsoft
modifier|*
name|txs
decl_stmt|;
name|txs
operator|=
operator|&
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
name|NULL
expr_stmt|;
name|txs
operator|->
name|txs_ndescs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
literal|0
argument_list|,
operator|&
name|txs
operator|->
name|txs_dmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create tx DMA map "
literal|"%d, error = %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_txd
goto|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create the receive buffer DMA maps. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_dmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create rx DMA map "
literal|"%d, error = %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_rxd
goto|;
block|}
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|gem_mifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_miibus
argument_list|,
name|gem_mediachange
argument_list|,
name|gem_mediastatus
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"phy probe failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_rxd
goto|;
block|}
name|sc
operator|->
name|sc_mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
comment|/* 	 * From this point forward, the attachment cannot fail.  A failure 	 * before this point releases all resources that may have been 	 * allocated. 	 */
comment|/* Get RX FIFO size */
name|sc
operator|->
name|sc_rxfifosize
operator|=
literal|64
operator|*
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_RX_FIFO_SIZE
argument_list|)
expr_stmt|;
comment|/* Get TX FIFO size */
name|v
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_FIFO_SIZE
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%ukB RX FIFO, %ukB TX FIFO\n"
argument_list|,
name|sc
operator|->
name|sc_rxfifosize
operator|/
literal|1024
argument_list|,
name|v
operator|/
literal|16
argument_list|)
expr_stmt|;
comment|/* Initialize ifnet structure. */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator||
name|IFF_NEEDSGIANT
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|gem_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|gem_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|gem_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|gem_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|GEM_TXQUEUELEN
expr_stmt|;
comment|/* 	 * Walk along the list of attached MII devices and 	 * establish an `MII instance' to `phy number' 	 * mapping. We'll use this mapping in media change 	 * requests to determine which phy to use to program 	 * the MIF configuration register. 	 */
for|for
control|(
name|child
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii
operator|->
name|mii_phys
argument_list|)
init|;
name|child
operator|!=
name|NULL
condition|;
name|child
operator|=
name|LIST_NEXT
argument_list|(
name|child
argument_list|,
name|mii_list
argument_list|)
control|)
block|{
comment|/* 		 * Note: we support just two PHYs: the built-in 		 * internal device and an external on the MII 		 * connector. 		 */
if|if
condition|(
name|child
operator|->
name|mii_phy
operator|>
literal|1
operator|||
name|child
operator|->
name|mii_inst
operator|>
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot accomodate "
literal|"MII device %s at phy %d, instance %d\n"
argument_list|,
name|device_get_name
argument_list|(
name|child
operator|->
name|mii_dev
argument_list|)
argument_list|,
name|child
operator|->
name|mii_phy
argument_list|,
name|child
operator|->
name|mii_inst
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|sc_phys
index|[
name|child
operator|->
name|mii_inst
index|]
operator|=
name|child
operator|->
name|mii_phy
expr_stmt|;
block|}
comment|/* 	 * Now select and activate the PHY we will use. 	 * 	 * The order of preference is External (MDI1), 	 * Internal (MDI0), Serial Link (no MII). 	 */
if|if
condition|(
name|sc
operator|->
name|sc_phys
index|[
literal|1
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|printf
argument_list|(
literal|"using external phy\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_mif_config
operator||=
name|GEM_MIF_CONFIG_PHY_SEL
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|printf
argument_list|(
literal|"using internal phy\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_mif_config
operator|&=
operator|~
name|GEM_MIF_CONFIG_PHY_SEL
expr_stmt|;
block|}
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_MIF_CONFIG
argument_list|,
name|sc
operator|->
name|sc_mif_config
argument_list|)
expr_stmt|;
comment|/* Attach the interface. */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|)
expr_stmt|;
if|#
directive|if
name|notyet
comment|/* 	 * Add a suspend hook to make sure we come back up after a 	 * resume. 	 */
name|sc
operator|->
name|sc_powerhook
operator|=
name|powerhook_establish
argument_list|(
name|gem_power
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_powerhook
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"WARNING: unable to establish power "
literal|"hook\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Free any resources we've allocated during the failed attach 	 * attempt.  Do this in reverse order and fall through. 	 */
name|fail_rxd
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_dmamap
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_dmamap
argument_list|)
expr_stmt|;
block|}
name|fail_txd
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_TXQUEUELEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
operator|.
name|txs_dmamap
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
operator|.
name|txs_dmamap
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|)
expr_stmt|;
name|fail_cmem
label|:
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_control_data
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|)
expr_stmt|;
name|fail_ctag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|)
expr_stmt|;
name|fail_ttag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|)
expr_stmt|;
name|fail_rtag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|)
expr_stmt|;
name|fail_ptag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|)
expr_stmt|;
name|fail_ifnet
label|:
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gem_detach
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gem_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_dmamap
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_dmamap
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_TXQUEUELEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
operator|.
name|txs_dmamap
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
operator|.
name|txs_dmamap
argument_list|)
expr_stmt|;
block|}
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_control_data
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gem_suspend
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|gem_stop
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gem_resume
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|gem_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_cddma_callback
parameter_list|(
name|xsc
parameter_list|,
name|segs
parameter_list|,
name|nsegs
parameter_list|,
name|error
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|gem_softc
operator|*
operator|)
name|xsc
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|nsegs
operator|!=
literal|1
condition|)
block|{
comment|/* can't happen... */
name|panic
argument_list|(
literal|"gem_cddma_callback: bad control buffer segment count"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_cddma
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_rxdma_callback
parameter_list|(
name|xsc
parameter_list|,
name|segs
parameter_list|,
name|nsegs
parameter_list|,
name|totsz
parameter_list|,
name|error
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|bus_size_t
name|totsz
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
name|struct
name|gem_rxsoft
modifier|*
name|rxs
init|=
operator|(
expr|struct
name|gem_rxsoft
operator|*
operator|)
name|xsc
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"gem_rxdma_callback: bad dma segment count"
operator|)
argument_list|)
expr_stmt|;
name|rxs
operator|->
name|rxs_paddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_txdma_callback
parameter_list|(
name|xsc
parameter_list|,
name|segs
parameter_list|,
name|nsegs
parameter_list|,
name|totsz
parameter_list|,
name|error
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|bus_size_t
name|totsz
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
name|struct
name|gem_txdma
modifier|*
name|txd
init|=
operator|(
expr|struct
name|gem_txdma
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|txd
operator|->
name|txd_sc
decl_stmt|;
name|struct
name|gem_txsoft
modifier|*
name|txs
init|=
name|txd
operator|->
name|txd_txs
decl_stmt|;
name|bus_size_t
name|len
init|=
literal|0
decl_stmt|;
name|uint64_t
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|seg
decl_stmt|,
name|nexttx
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * Ensure we have enough descriptors free to describe 	 * the packet.  Note, we always reserve one descriptor 	 * at the end of the ring as a termination point, to 	 * prevent wrap-around. 	 */
if|if
condition|(
name|nsegs
operator|>
name|sc
operator|->
name|sc_txfree
operator|-
literal|1
condition|)
block|{
name|txs
operator|->
name|txs_ndescs
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|txs
operator|->
name|txs_ndescs
operator|=
name|nsegs
expr_stmt|;
name|nexttx
operator|=
name|txs
operator|->
name|txs_firstdesc
expr_stmt|;
comment|/* 	 * Initialize the transmit descriptors. 	 */
for|for
control|(
name|seg
operator|=
literal|0
init|;
name|seg
operator|<
name|nsegs
condition|;
name|seg
operator|++
operator|,
name|nexttx
operator|=
name|GEM_NEXTTX
argument_list|(
name|nexttx
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR5
argument_list|(
name|KTR_GEM
argument_list|,
literal|"txdma_cb: mapping seg %d (txd %d), len "
literal|"%lx, addr %#lx (%#lx)"
argument_list|,
name|seg
argument_list|,
name|nexttx
argument_list|,
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
argument_list|,
name|segs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|,
name|GEM_DMA_WRITE
argument_list|(
name|sc
argument_list|,
name|segs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
operator|==
literal|0
condition|)
continue|continue;
name|sc
operator|->
name|sc_txdescs
index|[
name|nexttx
index|]
operator|.
name|gd_addr
operator|=
name|GEM_DMA_WRITE
argument_list|(
name|sc
argument_list|,
name|segs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
operator|<
name|GEM_TD_BUFSIZE
argument_list|,
operator|(
literal|"gem_txdma_callback: segment size too large!"
operator|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
operator|&
name|GEM_TD_BUFSIZE
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"txdma_cb: start of packet at seg %d, "
literal|"tx %d"
argument_list|,
name|seg
argument_list|,
name|nexttx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flags
operator||=
name|GEM_TD_START_OF_PACKET
expr_stmt|;
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_txwin
operator|>
name|GEM_NTXSEGS
operator|*
literal|2
operator|/
literal|3
condition|)
block|{
name|sc
operator|->
name|sc_txwin
operator|=
literal|0
expr_stmt|;
name|flags
operator||=
name|GEM_TD_INTERRUPT_ME
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|+
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
operator|==
name|totsz
condition|)
block|{
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"txdma_cb: end of packet at seg %d, "
literal|"tx %d"
argument_list|,
name|seg
argument_list|,
name|nexttx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flags
operator||=
name|GEM_TD_END_OF_PACKET
expr_stmt|;
block|}
name|sc
operator|->
name|sc_txdescs
index|[
name|nexttx
index|]
operator|.
name|gd_flags
operator|=
name|GEM_DMA_WRITE
argument_list|(
name|sc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|txs
operator|->
name|txs_lastdesc
operator|=
name|nexttx
expr_stmt|;
name|len
operator|+=
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
name|GEM_TD_END_OF_PACKET
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"gem_txdma_callback: missed end of packet!"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_tick
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|mii_tick
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
name|hz
argument_list|,
name|gem_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gem_bitwait
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|clr
parameter_list|,
name|set
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
name|bus_addr_t
name|r
decl_stmt|;
name|u_int32_t
name|clr
decl_stmt|;
name|u_int32_t
name|set
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|reg
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TRIES
init|;
name|i
operator|--
condition|;
name|DELAY
argument_list|(
literal|100
argument_list|)
control|)
block|{
name|reg
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
name|clr
operator|)
operator|==
literal|0
operator|&&
operator|(
name|r
operator|&
name|set
operator|)
operator|==
name|set
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gem_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_reset"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gem_reset_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|gem_reset_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Do a full reset */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_RX
operator||
name|GEM_RESET_TX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gem_bitwait
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_RX
operator||
name|GEM_RESET_TX
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot reset device\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * gem_rxdrain:  *  *	Drain the receive queue.  */
end_comment

begin_function
specifier|static
name|void
name|gem_rxdrain
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|gem_rxsoft
modifier|*
name|rxs
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
name|rxs
operator|=
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxs
operator|->
name|rxs_mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxs
operator|->
name|rxs_mbuf
argument_list|)
expr_stmt|;
name|rxs
operator|->
name|rxs_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Reset the whole thing.  */
end_comment

begin_function
specifier|static
name|void
name|gem_stop
parameter_list|(
name|ifp
parameter_list|,
name|disable
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|disable
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|gem_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|gem_txsoft
modifier|*
name|txs
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_stop"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|)
expr_stmt|;
comment|/* XXX - Should we reset these instead? */
name|gem_disable_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|gem_disable_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Release any queued transmit buffers. 	 */
while|while
condition|(
operator|(
name|txs
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|txs
operator|->
name|txs_ndescs
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|txs
operator|->
name|txs_mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txs
operator|->
name|txs_mbuf
argument_list|)
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|disable
condition|)
name|gem_rxdrain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Mark the interface down and cancel the watchdog timer. 	 */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the receiver  */
end_comment

begin_function
name|int
name|gem_reset_rx
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
comment|/* 	 * Resetting while DMA is in progress can cause a bus hang, so we 	 * disable DMA first. 	 */
name|gem_disable_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait till it finishes */
if|if
condition|(
operator|!
name|gem_bitwait
argument_list|(
name|sc
argument_list|,
name|GEM_RX_CONFIG
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot disable read dma\n"
argument_list|)
expr_stmt|;
comment|/* Wait 5ms extra. */
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Finally, reset the ERX */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_RX
argument_list|)
expr_stmt|;
comment|/* Wait till it finishes */
if|if
condition|(
operator|!
name|gem_bitwait
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_TX
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot reset receiver\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset the transmitter  */
end_comment

begin_function
specifier|static
name|int
name|gem_reset_tx
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Resetting while DMA is in progress can cause a bus hang, so we 	 * disable DMA first. 	 */
name|gem_disable_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_TX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait till it finishes */
if|if
condition|(
operator|!
name|gem_bitwait
argument_list|(
name|sc
argument_list|,
name|GEM_TX_CONFIG
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot disable read dma\n"
argument_list|)
expr_stmt|;
comment|/* Wait 5ms extra. */
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Finally, reset the ETX */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_TX
argument_list|)
expr_stmt|;
comment|/* Wait till it finishes */
for|for
control|(
name|i
operator|=
name|TRIES
init|;
name|i
operator|--
condition|;
name|DELAY
argument_list|(
literal|100
argument_list|)
control|)
if|if
condition|(
operator|(
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RESET
argument_list|)
operator|&
name|GEM_RESET_TX
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|gem_bitwait
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_TX
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot reset receiver\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * disable receiver.  */
end_comment

begin_function
specifier|static
name|int
name|gem_disable_rx
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|u_int32_t
name|cfg
decl_stmt|;
comment|/* Flip the enable bit */
name|cfg
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
expr_stmt|;
name|cfg
operator|&=
operator|~
name|GEM_MAC_RX_ENABLE
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
comment|/* Wait for it to finish */
return|return
operator|(
name|gem_bitwait
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|GEM_MAC_RX_ENABLE
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * disable transmitter.  */
end_comment

begin_function
specifier|static
name|int
name|gem_disable_tx
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|u_int32_t
name|cfg
decl_stmt|;
comment|/* Flip the enable bit */
name|cfg
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|)
expr_stmt|;
name|cfg
operator|&=
operator|~
name|GEM_MAC_TX_ENABLE
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
comment|/* Wait for it to finish */
return|return
operator|(
name|gem_bitwait
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
name|GEM_MAC_TX_ENABLE
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize interface.  */
end_comment

begin_function
specifier|static
name|int
name|gem_meminit
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|gem_rxsoft
modifier|*
name|rxs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * Initialize the transmit descriptor ring. 	 */
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|sc_txdescs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_txdescs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NTXDESC
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|gd_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|gd_addr
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|sc_txfree
operator|=
name|GEM_MAXTXFREE
expr_stmt|;
name|sc
operator|->
name|sc_txnext
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_txwin
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize the receive descriptor and receive job 	 * descriptor rings. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
name|rxs
operator|=
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxs
operator|->
name|rxs_mbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|gem_add_rxbuf
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to "
literal|"allocate or map rx buffer %d, error = "
literal|"%d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 				 * XXX Should attempt to run with fewer receive 				 * XXX buffers instead of just failing. 				 */
name|gem_rxdrain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
name|GEM_INIT_RXDESC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rxptr
operator|=
literal|0
expr_stmt|;
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gem_ringsize
parameter_list|(
name|sz
parameter_list|)
name|int
name|sz
decl_stmt|;
block|{
name|int
name|v
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|sz
condition|)
block|{
case|case
literal|32
case|:
name|v
operator|=
name|GEM_RING_SZ_32
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|v
operator|=
name|GEM_RING_SZ_64
expr_stmt|;
break|break;
case|case
literal|128
case|:
name|v
operator|=
name|GEM_RING_SZ_128
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|v
operator|=
name|GEM_RING_SZ_256
expr_stmt|;
break|break;
case|case
literal|512
case|:
name|v
operator|=
name|GEM_RING_SZ_512
expr_stmt|;
break|break;
case|case
literal|1024
case|:
name|v
operator|=
name|GEM_RING_SZ_1024
expr_stmt|;
break|break;
case|case
literal|2048
case|:
name|v
operator|=
name|GEM_RING_SZ_2048
expr_stmt|;
break|break;
case|case
literal|4096
case|:
name|v
operator|=
name|GEM_RING_SZ_4096
expr_stmt|;
break|break;
case|case
literal|8192
case|:
name|v
operator|=
name|GEM_RING_SZ_8192
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"gem: invalid Receive Descriptor ring size\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialization of interface; set up initialization block  * and transmit/receive descriptor rings.  */
end_comment

begin_function
specifier|static
name|void
name|gem_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|gem_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_init: calling stop"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialization sequence. The numbered steps below correspond 	 * to the sequence outlined in section 6.3.5.1 in the Ethernet 	 * Channel Engine manual (part of the PCIO manual). 	 * See also the STP2002-STQ document from Sun Microsystems. 	 */
comment|/* step 1& 2. Reset the Ethernet Channel */
name|gem_stop
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gem_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_init: restarting"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Re-initialize the MIF */
name|gem_mifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* step 3. Setup data structures in host memory */
name|gem_meminit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* step 4. TX MAC registers& counters */
name|gem_init_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX: VLAN code from NetBSD temporarily removed. */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_MAC_MAX_FRAME
argument_list|,
operator|(
name|ETHER_MAX_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
operator||
operator|(
literal|0x2000
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* step 5. RX MAC registers& counters */
name|gem_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* step 6& 7. Program Descriptor Ring Base Addresses */
comment|/* NOTE: we use only 32-bit DMA addresses here. */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_TX_RING_PTR_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_TX_RING_PTR_LO
argument_list|,
name|GEM_CDTXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_RING_PTR_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_RING_PTR_LO
argument_list|,
name|GEM_CDRXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"loading rx ring %lx, tx ring %lx, cddma %lx"
argument_list|,
name|GEM_CDRXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEM_CDTXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_cddma
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* step 8. Global Configuration& Interrupt Mask */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_INTMASK
argument_list|,
operator|~
operator|(
name|GEM_INTR_TX_INTME
operator||
name|GEM_INTR_TX_EMPTY
operator||
name|GEM_INTR_RX_DONE
operator||
name|GEM_INTR_RX_NOBUF
operator||
name|GEM_INTR_RX_TAG_ERR
operator||
name|GEM_INTR_PCS
operator||
name|GEM_INTR_MAC_CONTROL
operator||
name|GEM_INTR_MIF
operator||
name|GEM_INTR_BERR
operator|)
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_MASK
argument_list|,
name|GEM_MAC_RX_DONE
operator||
name|GEM_MAC_RX_FRAME_CNT
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_TX_MASK
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* XXXX */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_CONTROL_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXXX */
comment|/* step 9. ETX Configuration: use mostly default values */
comment|/* Enable DMA */
name|v
operator|=
name|gem_ringsize
argument_list|(
name|GEM_NTXDESC
comment|/*XXX*/
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_TX_CONFIG
argument_list|,
name|v
operator||
name|GEM_TX_CONFIG_TXDMA_EN
operator||
operator|(
operator|(
literal|0x400
operator|<<
literal|10
operator|)
operator|&
name|GEM_TX_CONFIG_TXFIFO_TH
operator|)
argument_list|)
expr_stmt|;
comment|/* step 10. ERX Configuration */
comment|/* Encode Receive Descriptor ring size: four possible values */
name|v
operator|=
name|gem_ringsize
argument_list|(
name|GEM_NRXDESC
comment|/*XXX*/
argument_list|)
expr_stmt|;
comment|/* Enable DMA */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_CONFIG
argument_list|,
name|v
operator||
operator|(
name|GEM_THRSH_1024
operator|<<
name|GEM_RX_CONFIG_FIFO_THRS_SHIFT
operator|)
operator||
operator|(
literal|2
operator|<<
name|GEM_RX_CONFIG_FBOFF_SHFT
operator|)
operator||
name|GEM_RX_CONFIG_RXDMA_EN
operator||
operator|(
literal|0
operator|<<
name|GEM_RX_CONFIG_CXM_START_SHFT
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * The following value is for an OFF Threshold of about 3/4 full 	 * and an ON Threshold of 1/4 full. 	 */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_PAUSE_THRESH
argument_list|,
operator|(
literal|3
operator|*
name|sc
operator|->
name|sc_rxfifosize
operator|/
literal|256
operator|)
operator||
operator|(
operator|(
name|sc
operator|->
name|sc_rxfifosize
operator|/
literal|256
operator|)
operator|<<
literal|12
operator|)
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_BLANKING
argument_list|,
operator|(
literal|6
operator|<<
literal|12
operator|)
operator||
literal|6
argument_list|)
expr_stmt|;
comment|/* step 11. Configure Media */
name|mii_mediachg
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
comment|/* step 12. RX_MAC Configuration Register */
name|v
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
expr_stmt|;
name|v
operator||=
name|GEM_MAC_RX_ENABLE
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* step 14. Issue Transmit Pending command */
comment|/* step 15.  Give the reciever a swift kick */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_KICK
argument_list|,
name|GEM_NRXDESC
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|/* Start the one second timer. */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
name|hz
argument_list|,
name|gem_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ifflags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gem_load_txmbuf
parameter_list|(
name|sc
parameter_list|,
name|m0
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
block|{
name|struct
name|gem_txdma
name|txd
decl_stmt|;
name|struct
name|gem_txsoft
modifier|*
name|txs
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Get a work queue entry. */
if|if
condition|(
operator|(
name|txs
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Ran out of descriptors. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|txd
operator|.
name|txd_sc
operator|=
name|sc
expr_stmt|;
name|txd
operator|.
name|txd_txs
operator|=
name|txs
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
name|m0
expr_stmt|;
name|txs
operator|->
name|txs_firstdesc
operator|=
name|sc
operator|->
name|sc_txnext
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
name|m0
argument_list|,
name|gem_txdma_callback
argument_list|,
operator|&
name|txd
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|txs
operator|->
name|txs_ndescs
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Sync the DMA map. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"load_mbuf: setting firstdesc=%d, lastdesc=%d, "
literal|"ndescs=%d"
argument_list|,
name|txs
operator|->
name|txs_firstdesc
argument_list|,
name|txs
operator|->
name|txs_lastdesc
argument_list|,
name|txs
operator|->
name|txs_ndescs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txnext
operator|=
name|GEM_NEXTTX
argument_list|(
name|txs
operator|->
name|txs_lastdesc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txfree
operator|-=
name|txs
operator|->
name|txs_ndescs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_load_txmbuf failed (%d)"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_init_regs
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|laddr
init|=
name|IFP2ENADDR
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
comment|/* These regs are not cleared on reset */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_inited
condition|)
block|{
comment|/* Wooo.  Magic values. */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_IPG0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_IPG1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_IPG2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_MAC_MIN_FRAME
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
comment|/* Max frame and max burst size */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_MAC_MAX_FRAME
argument_list|,
name|ETHER_MAX_LEN
operator||
operator|(
literal|0x2000
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_PREAMBLE_LEN
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_JAM_SIZE
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ATTEMPT_LIMIT
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Dunno.... */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_CONTROL_TYPE
argument_list|,
literal|0x8088
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RANDOM_SEED
argument_list|,
operator|(
operator|(
name|laddr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|laddr
index|[
literal|4
index|]
operator|)
operator|&
literal|0x3ff
argument_list|)
expr_stmt|;
comment|/* Secondary MAC addr set to 0:0:0:0:0:0 */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* MAC control addr set to 01:80:c2:00:00:01 */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR6
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR7
argument_list|,
literal|0xc200
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR8
argument_list|,
literal|0x0180
argument_list|)
expr_stmt|;
comment|/* MAC filter addr set to 0:0:0:0:0:0 */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR_FILTER0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR_FILTER1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR_FILTER2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADR_FLT_MASK1_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADR_FLT_MASK0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_inited
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Counters need to be zeroed */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_NORM_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_FIRST_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_EXCESS_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_LATE_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_DEFER_TMR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_PEAK_ATTEMPTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_FRAME_COUNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_LEN_ERR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_ALIGN_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CRC_ERR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CODE_VIOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Un-pause stuff */
if|#
directive|if
literal|0
block|bus_space_write_4(t, h, GEM_MAC_SEND_PAUSE_CMD, 0x1BF0);
else|#
directive|else
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_SEND_PAUSE_CMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set the station address. 	 */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR0
argument_list|,
operator|(
name|laddr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|laddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR1
argument_list|,
operator|(
name|laddr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|laddr
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR2
argument_list|,
operator|(
name|laddr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|laddr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Enable MII outputs.  Enable GMII if there is a gigabit PHY. 	 */
name|sc
operator|->
name|sc_mif_config
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MIF_CONFIG
argument_list|)
expr_stmt|;
name|v
operator|=
name|GEM_MAC_XIF_TX_MII_ENA
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mif_config
operator|&
name|GEM_MIF_CONFIG_MDI1
condition|)
block|{
name|v
operator||=
name|GEM_MAC_XIF_FDPLX_LED
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GEM_GIGABIT
condition|)
name|v
operator||=
name|GEM_MAC_XIF_GMII_MODE
expr_stmt|;
block|}
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_XIF_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|gem_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|NULL
decl_stmt|;
name|int
name|firsttx
decl_stmt|,
name|ntx
init|=
literal|0
decl_stmt|,
name|ofree
decl_stmt|,
name|txmfail
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
condition|)
return|return;
comment|/* 	 * Remember the previous number of free descriptors and 	 * the first descriptor we'll use. 	 */
name|ofree
operator|=
name|sc
operator|->
name|sc_txfree
expr_stmt|;
name|firsttx
operator|=
name|sc
operator|->
name|sc_txnext
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_start: txfree %d, txnext %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|ofree
argument_list|,
name|firsttx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Loop through the send queue, setting up transmit descriptors 	 * until we drain the queue, or use up all available transmit 	 * descriptors. 	 */
name|txmfail
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* 		 * Grab a packet off the queue. 		 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
break|break;
name|txmfail
operator|=
name|gem_load_txmbuf
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|txmfail
operator|>
literal|0
condition|)
block|{
comment|/* Drop the mbuf and complain. */
name|printf
argument_list|(
literal|"gem_start: error %d while loading mbuf dma "
literal|"map\n"
argument_list|,
name|txmfail
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Not enough descriptors. */
if|if
condition|(
name|txmfail
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_txfree
operator|==
name|GEM_MAXTXFREE
condition|)
name|panic
argument_list|(
literal|"gem_start: mbuf chain too long!"
argument_list|)
expr_stmt|;
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
break|break;
block|}
name|ntx
operator|++
expr_stmt|;
comment|/* Kick the transmitter. */
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_start: kicking tx %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_txnext
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_KICK
argument_list|,
name|sc
operator|->
name|sc_txnext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_bpf
operator|!=
name|NULL
condition|)
name|bpf_mtap
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
if|if
condition|(
name|txmfail
operator|==
operator|-
literal|1
operator|||
name|sc
operator|->
name|sc_txfree
operator|==
literal|0
condition|)
block|{
comment|/* No more slots left; notify upper layer. */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|ntx
operator|>
literal|0
condition|)
block|{
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: packets enqueued, OWN on %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|firsttx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set a watchdog timer in case the chip flakes out. */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_start: watchdog %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Transmit interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|gem_tint
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|mac
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|struct
name|gem_txsoft
modifier|*
name|txs
decl_stmt|;
name|int
name|txlast
decl_stmt|;
name|int
name|progress
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_tint"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Unload collision counters 	 */
name|ifp
operator|->
name|if_collisions
operator|+=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_NORM_COLL_CNT
argument_list|)
operator|+
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_FIRST_COLL_CNT
argument_list|)
operator|+
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_EXCESS_COLL_CNT
argument_list|)
operator|+
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_LATE_COLL_CNT
argument_list|)
expr_stmt|;
comment|/* 	 * then clear the hardware counters. 	 */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_NORM_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_FIRST_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_EXCESS_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_LATE_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Go through our Tx list and free mbufs for those 	 * frames that have been transmitted. 	 */
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|txs
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|GEM_DEBUG
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"    txsoft %p transmit chain:\n"
argument_list|,
name|txs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|txs
operator|->
name|txs_firstdesc
init|;
condition|;
name|i
operator|=
name|GEM_NEXTTX
argument_list|(
name|i
argument_list|)
control|)
block|{
name|printf
argument_list|(
literal|"descriptor %d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gd_flags: 0x%016llx\t"
argument_list|,
operator|(
name|long
name|long
operator|)
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|gd_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gd_addr: 0x%016llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|gd_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|txs
operator|->
name|txs_lastdesc
condition|)
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * In theory, we could harveast some descriptors before 		 * the ring is empty, but that's a bit complicated. 		 * 		 * GEM_TX_COMPLETION points to the last descriptor 		 * processed +1. 		 */
name|txlast
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_TX_COMPLETION
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_tint: txs->txs_firstdesc = %d, "
literal|"txs->txs_lastdesc = %d, txlast = %d"
argument_list|,
name|txs
operator|->
name|txs_firstdesc
argument_list|,
name|txs
operator|->
name|txs_lastdesc
argument_list|,
name|txlast
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|txs
operator|->
name|txs_firstdesc
operator|<=
name|txs
operator|->
name|txs_lastdesc
condition|)
block|{
if|if
condition|(
operator|(
name|txlast
operator|>=
name|txs
operator|->
name|txs_firstdesc
operator|)
operator|&&
operator|(
name|txlast
operator|<=
name|txs
operator|->
name|txs_lastdesc
operator|)
condition|)
break|break;
block|}
else|else
block|{
comment|/* Ick -- this command wraps */
if|if
condition|(
operator|(
name|txlast
operator|>=
name|txs
operator|->
name|txs_firstdesc
operator|)
operator|||
operator|(
name|txlast
operator|<=
name|txs
operator|->
name|txs_lastdesc
operator|)
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR0
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_tint: releasing a desc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txfree
operator|+=
name|txs
operator|->
name|txs_ndescs
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|txs
operator|->
name|txs_mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txs
operator|->
name|txs_mbuf
argument_list|)
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|progress
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_tint: GEM_TX_STATE_MACHINE %x "
literal|"GEM_TX_DATA_PTR %llx "
literal|"GEM_TX_COMPLETION %x"
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_STATE_MACHINE
argument_list|)
argument_list|,
operator|(
operator|(
name|long
name|long
operator|)
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_DATA_PTR_HI
argument_list|)
operator|<<
literal|32
operator|)
operator||
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_DATA_PTR_LO
argument_list|)
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_COMPLETION
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|progress
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_txfree
operator|==
name|GEM_NTXDESC
operator|-
literal|1
condition|)
name|sc
operator|->
name|sc_txwin
operator|=
literal|0
expr_stmt|;
comment|/* Freed some descriptors, so reset IFF_OACTIVE and restart. */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|gem_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
condition|)
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_tint: watchdog %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void gem_rint_timeout(arg) 	void *arg; {  	gem_rint((struct gem_softc *)arg); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Receive interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|gem_rint
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|struct
name|gem_rxsoft
modifier|*
name|rxs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int64_t
name|rxstat
decl_stmt|;
name|u_int32_t
name|rxcomp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|progress
init|=
literal|0
decl_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_rint"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Read the completion register once.  This limits 	 * how long the following loop can execute. 	 */
name|rxcomp
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_COMPLETION
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_rint: sc->rxptr %d, complete %d"
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|,
name|rxcomp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|sc_rxptr
init|;
name|i
operator|!=
name|rxcomp
condition|;
name|i
operator|=
name|GEM_NEXTRX
argument_list|(
name|i
argument_list|)
control|)
block|{
name|rxs
operator|=
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
expr_stmt|;
name|rxstat
operator|=
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxdescs
index|[
name|i
index|]
operator|.
name|gd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxstat
operator|&
name|GEM_RD_OWN
condition|)
block|{
if|#
directive|if
literal|0
comment|/* XXX: In case of emergency, re-enable this. */
comment|/* 			 * The descriptor is still marked as owned, although 			 * it is supposed to have completed. This has been 			 * observed on some machines. Just exiting here 			 * might leave the packet sitting around until another 			 * one arrives to trigger a new interrupt, which is 			 * generally undesirable, so set up a timeout. 			 */
block|callout_reset(&sc->sc_rx_ch, GEM_RXOWN_TICKS, 			    gem_rint_timeout, sc);
endif|#
directive|endif
break|break;
block|}
name|progress
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
name|rxstat
operator|&
name|GEM_RD_BAD_CRC
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"receive error: CRC error\n"
argument_list|)
expr_stmt|;
name|GEM_INIT_RXDESC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|GEM_DEBUG
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"    rxsoft %p descriptor %d: "
argument_list|,
name|rxs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gd_flags: 0x%016llx\t"
argument_list|,
operator|(
name|long
name|long
operator|)
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxdescs
index|[
name|i
index|]
operator|.
name|gd_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gd_addr: 0x%016llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxdescs
index|[
name|i
index|]
operator|.
name|gd_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * No errors; receive the packet.  Note the Gem 		 * includes the CRC with every packet. 		 */
name|len
operator|=
name|GEM_RD_BUFLEN
argument_list|(
name|rxstat
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate a new mbuf cluster.  If that fails, we are 		 * out of memory, and must drop the packet and recycle 		 * the buffer that's already attached to this descriptor. 		 */
name|m
operator|=
name|rxs
operator|->
name|rxs_mbuf
expr_stmt|;
if|if
condition|(
name|gem_add_rxbuf
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|GEM_INIT_RXDESC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m
operator|->
name|m_data
operator|+=
literal|2
expr_stmt|;
comment|/* We're already off by two */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
comment|/* Pass it on. */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|progress
condition|)
block|{
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Update the receive pointer. */
if|if
condition|(
name|i
operator|==
name|sc
operator|->
name|sc_rxptr
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"rint: ring wrap\n"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rxptr
operator|=
name|i
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_KICK
argument_list|,
name|GEM_PREVRX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_rint: done sc->rxptr %d, complete %d"
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|,
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_COMPLETION
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * gem_add_rxbuf:  *  *	Add a receive buffer to the indicated descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|gem_add_rxbuf
parameter_list|(
name|sc
parameter_list|,
name|idx
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|idx
decl_stmt|;
block|{
name|struct
name|gem_rxsoft
modifier|*
name|rxs
init|=
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
comment|/* bzero the packet to check dma */
name|memset
argument_list|(
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_ext
operator|.
name|ext_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rxs
operator|->
name|rxs_mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|)
expr_stmt|;
block|}
name|rxs
operator|->
name|rxs_mbuf
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|,
name|m
argument_list|,
name|gem_rxdma_callback
argument_list|,
name|rxs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|rxs
operator|->
name|rxs_paddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't load rx DMA map %d, error = "
literal|"%d\n"
argument_list|,
name|idx
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"gem_add_rxbuf"
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|GEM_INIT_RXDESC
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_eint
parameter_list|(
name|sc
parameter_list|,
name|status
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|status
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|status
operator|&
name|GEM_INTR_MIF
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"XXXlink status changed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"status=%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gem_intr
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|gem_softc
operator|*
operator|)
name|v
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|seb
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|status
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|seb
argument_list|,
name|GEM_STATUS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_intr: cplt %x, status %x"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
operator|(
name|status
operator|>>
literal|19
operator|)
argument_list|,
operator|(
name|u_int
operator|)
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|GEM_INTR_RX_TAG_ERR
operator||
name|GEM_INTR_BERR
operator|)
operator|)
operator|!=
literal|0
condition|)
name|gem_eint
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|GEM_INTR_TX_EMPTY
operator||
name|GEM_INTR_TX_INTME
operator|)
operator|)
operator|!=
literal|0
condition|)
name|gem_tint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|GEM_INTR_RX_DONE
operator||
name|GEM_INTR_RX_NOBUF
operator|)
operator|)
operator|!=
literal|0
condition|)
name|gem_rint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* We should eventually do more than just print out error stats. */
if|if
condition|(
name|status
operator|&
name|GEM_INTR_TX_MAC
condition|)
block|{
name|int
name|txstat
init|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|seb
argument_list|,
name|GEM_MAC_TX_STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|txstat
operator|&
operator|~
name|GEM_MAC_TX_XMIT_DONE
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"MAC tx fault, status %x\n"
argument_list|,
name|txstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|txstat
operator|&
operator|(
name|GEM_MAC_TX_UNDERRUN
operator||
name|GEM_MAC_TX_PKT_TOO_LONG
operator|)
condition|)
name|gem_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|GEM_INTR_RX_MAC
condition|)
block|{
name|int
name|rxstat
init|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|seb
argument_list|,
name|GEM_MAC_RX_STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|rxstat
operator|&
operator|~
operator|(
name|GEM_MAC_RX_DONE
operator||
name|GEM_MAC_RX_FRAME_CNT
operator|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"MAC rx fault, status %x\n"
argument_list|,
name|rxstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rxstat
operator|&
name|GEM_MAC_RX_OVERFLOW
operator|)
operator|!=
literal|0
condition|)
name|gem_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gem_watchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_watchdog: GEM_RX_CONFIG %x GEM_MAC_RX_STATUS %x "
literal|"GEM_MAC_RX_CONFIG %x"
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_RX_CONFIG
argument_list|)
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_MAC_RX_STATUS
argument_list|)
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_watchdog: GEM_TX_CONFIG %x GEM_MAC_TX_STATUS %x "
literal|"GEM_MAC_TX_CONFIG %x"
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_CONFIG
argument_list|)
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_MAC_TX_STATUS
argument_list|)
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
operator|++
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
comment|/* Try to get more packets going. */
name|gem_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the MII Management Interface  */
end_comment

begin_function
specifier|static
name|void
name|gem_mifinit
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|mif
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
comment|/* Configure the MIF in frame mode */
name|sc
operator|->
name|sc_mif_config
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mif
argument_list|,
name|GEM_MIF_CONFIG
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mif_config
operator|&=
operator|~
name|GEM_MIF_CONFIG_BB_ENA
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mif
argument_list|,
name|GEM_MIF_CONFIG
argument_list|,
name|sc
operator|->
name|sc_mif_config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MII interface  *  * The GEM MII interface supports at least three different operating modes:  *  * Bitbang mode is implemented using data, clock and output enable registers.  *  * Frame mode is implemented by loading a complete frame into the frame  * register and polling the valid bit for completion.  *  * Polling mode uses the frame register but completion is indicated by  * an interrupt.  *  */
end_comment

begin_function
name|int
name|gem_mii_readreg
parameter_list|(
name|dev
parameter_list|,
name|phy
parameter_list|,
name|reg
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|phy
decl_stmt|,
name|reg
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|mif
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG_PHY
name|printf
argument_list|(
literal|"gem_mii_readreg: phy %d reg %d\n"
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Select the desired PHY in the MIF configuration register */
block|v = bus_space_read_4(t, mif, GEM_MIF_CONFIG);
comment|/* Clear PHY select bit */
block|v&= ~GEM_MIF_CONFIG_PHY_SEL; 	if (phy == GEM_PHYAD_EXTERNAL)
comment|/* Set PHY select bit to get at external device */
block|v |= GEM_MIF_CONFIG_PHY_SEL; 	bus_space_write_4(t, mif, GEM_MIF_CONFIG, v);
endif|#
directive|endif
comment|/* Construct the frame command */
name|v
operator|=
operator|(
name|reg
operator|<<
name|GEM_MIF_REG_SHIFT
operator|)
operator||
operator|(
name|phy
operator|<<
name|GEM_MIF_PHY_SHIFT
operator|)
operator||
name|GEM_MIF_FRAME_READ
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mif
argument_list|,
name|GEM_MIF_FRAME
argument_list|,
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|100
condition|;
name|n
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mif
argument_list|,
name|GEM_MIF_FRAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|GEM_MIF_FRAME_TA0
condition|)
return|return
operator|(
name|v
operator|&
name|GEM_MIF_FRAME_DATA
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"mii_read timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gem_mii_writereg
parameter_list|(
name|dev
parameter_list|,
name|phy
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|phy
decl_stmt|,
name|reg
decl_stmt|,
name|val
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|mif
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG_PHY
name|printf
argument_list|(
literal|"gem_mii_writereg: phy %d reg %d val %x\n"
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Select the desired PHY in the MIF configuration register */
block|v = bus_space_read_4(t, mif, GEM_MIF_CONFIG);
comment|/* Clear PHY select bit */
block|v&= ~GEM_MIF_CONFIG_PHY_SEL; 	if (phy == GEM_PHYAD_EXTERNAL)
comment|/* Set PHY select bit to get at external device */
block|v |= GEM_MIF_CONFIG_PHY_SEL; 	bus_space_write_4(t, mif, GEM_MIF_CONFIG, v);
endif|#
directive|endif
comment|/* Construct the frame command */
name|v
operator|=
name|GEM_MIF_FRAME_WRITE
operator||
operator|(
name|phy
operator|<<
name|GEM_MIF_PHY_SHIFT
operator|)
operator||
operator|(
name|reg
operator|<<
name|GEM_MIF_REG_SHIFT
operator|)
operator||
operator|(
name|val
operator|&
name|GEM_MIF_FRAME_DATA
operator|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mif
argument_list|,
name|GEM_MIF_FRAME
argument_list|,
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|100
condition|;
name|n
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mif
argument_list|,
name|GEM_MIF_FRAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|GEM_MIF_FRAME_TA0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"mii_write timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gem_mii_statchg
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|int
name|instance
init|=
name|IFM_INST
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|mac
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
condition|)
name|printf
argument_list|(
literal|"gem_mii_statchg: status change: phy = %d\n"
argument_list|,
name|sc
operator|->
name|sc_phys
index|[
name|instance
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set tx full duplex options */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* reg must be cleared and delay before changing. */
name|v
operator|=
name|GEM_MAC_TX_ENA_IPG0
operator||
name|GEM_MAC_TX_NGU
operator||
name|GEM_MAC_TX_NGU_LIMIT
operator||
name|GEM_MAC_TX_ENABLE
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
block|{
name|v
operator||=
name|GEM_MAC_TX_IGN_CARRIER
operator||
name|GEM_MAC_TX_IGN_COLLIS
expr_stmt|;
block|}
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* XIF Configuration */
comment|/* We should really calculate all this rather than rely on defaults */
name|v
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_XIF_CONFIG
argument_list|)
expr_stmt|;
name|v
operator|=
name|GEM_MAC_XIF_LINK_LED
expr_stmt|;
name|v
operator||=
name|GEM_MAC_XIF_TX_MII_ENA
expr_stmt|;
comment|/* If an external transceiver is connected, enable its MII drivers */
name|sc
operator|->
name|sc_mif_config
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MIF_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_mif_config
operator|&
name|GEM_MIF_CONFIG_MDI1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* External MII needs echo disable if half duplex. */
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
comment|/* turn on full duplex LED */
name|v
operator||=
name|GEM_MAC_XIF_FDPLX_LED
expr_stmt|;
else|else
comment|/* half duplex -- disable echo */
name|v
operator||=
name|GEM_MAC_XIF_ECHO_DISABL
expr_stmt|;
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_1000_T
condition|)
name|v
operator||=
name|GEM_MAC_XIF_GMII_MODE
expr_stmt|;
else|else
name|v
operator|&=
operator|~
name|GEM_MAC_XIF_GMII_MODE
expr_stmt|;
block|}
else|else
block|{
comment|/* Internal MII needs buf enable */
name|v
operator||=
name|GEM_MAC_XIF_MII_BUF_ENA
expr_stmt|;
block|}
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_XIF_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gem_mediachange
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* XXX Add support for serial media. */
return|return
operator|(
name|mii_mediachg
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gem_mediastatus
parameter_list|(
name|ifp
parameter_list|,
name|ifmr
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmediareq
modifier|*
name|ifmr
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
return|return;
name|mii_pollstat
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_status
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|gem_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ifflags
operator|^
name|ifp
operator|->
name|if_flags
operator|)
operator|==
name|IFF_PROMISC
condition|)
name|gem_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|gem_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|gem_stop
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ifflags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|gem_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
comment|/* Try to get things going again */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|gem_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up the logical address filter.  */
end_comment

begin_function
specifier|static
name|void
name|gem_setladrf
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|inm
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|u_int32_t
name|crc
decl_stmt|;
name|u_int32_t
name|hash
index|[
literal|16
index|]
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get current RX configuration */
name|v
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
expr_stmt|;
comment|/* 	 * Turn off promiscuous mode, promiscuous group mode (all multicast), 	 * and hash filter.  Depending on the case, the right bit will be 	 * enabled. 	 */
name|v
operator|&=
operator|~
operator|(
name|GEM_MAC_RX_PROMISCUOUS
operator||
name|GEM_MAC_RX_HASH_FILTER
operator||
name|GEM_MAC_RX_PROMISC_GRP
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Turn on promiscuous mode */
name|v
operator||=
name|GEM_MAC_RX_PROMISCUOUS
expr_stmt|;
goto|goto
name|chipit
goto|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|!=
literal|0
condition|)
block|{
name|hash
index|[
literal|3
index|]
operator|=
name|hash
index|[
literal|2
index|]
operator|=
name|hash
index|[
literal|1
index|]
operator|=
name|hash
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
name|v
operator||=
name|GEM_MAC_RX_PROMISC_GRP
expr_stmt|;
goto|goto
name|chipit
goto|;
block|}
comment|/* 	 * Set up multicast address filter by passing all multicast addresses 	 * through a crc generator, and then using the high order 8 bits as an 	 * index into the 256 bit logical address filter.  The high order 4 	 * bits selects the word, while the other 4 bits select the bit within 	 * the word (where bit 0 is the MSB). 	 */
comment|/* Clear hash table */
name|memset
argument_list|(
name|hash
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|inm
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|inm
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|crc
operator|=
name|ether_crc32_le
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|inm
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Just want the 8 most significant bits. */
name|crc
operator|>>=
literal|24
expr_stmt|;
comment|/* Set the corresponding bit in the filter. */
name|hash
index|[
name|crc
operator|>>
literal|4
index|]
operator||=
literal|1
operator|<<
operator|(
literal|15
operator|-
operator|(
name|crc
operator|&
literal|15
operator|)
operator|)
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|v
operator||=
name|GEM_MAC_RX_HASH_FILTER
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_ALLMULTI
expr_stmt|;
comment|/* Now load the hash table into the chip (if we are using it) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH0
operator|+
name|i
operator|*
operator|(
name|GEM_MAC_HASH1
operator|-
name|GEM_MAC_HASH0
operator|)
argument_list|,
name|hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|chipit
label|:
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

