begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2001 Eduardo Horvath.  * Copyright (c) 2001-2003 Thomas Moestl  * Copyright (c) 2007 Marius Strobl<marius@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR  ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: NetBSD: gem.c,v 1.21 2002/06/01 23:50:58 lukem Exp  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for Apple GMAC, Sun ERI and Sun GEM Ethernet controllers  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|GEM_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX: In case of emergency, re-enable this. */
end_comment

begin_define
define|#
directive|define
name|GEM_RINT_TIMEOUT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/gem/if_gemreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/gem/if_gemvar.h>
end_include

begin_expr_stmt
name|CTASSERT
argument_list|(
name|powerof2
argument_list|(
name|GEM_NRXDESC
argument_list|)
operator|&&
name|GEM_NRXDESC
operator|>=
literal|32
operator|&&
name|GEM_NRXDESC
operator|<=
literal|8192
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|powerof2
argument_list|(
name|GEM_NTXDESC
argument_list|)
operator|&&
name|GEM_NTXDESC
operator|>=
literal|32
operator|&&
name|GEM_NTXDESC
operator|<=
literal|8192
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|GEM_TRIES
value|10000
end_define

begin_comment
comment|/*  * The hardware supports basic TCP/UDP checksum offloading.  However,  * the hardware doesn't compensate the checksum for UDP datagram which  * can yield to 0x0.  As a safe guard, UDP checksum offload is disabled  * by default.  It can be reactivated by setting special link option  * link0 with ifconfig(8).  */
end_comment

begin_define
define|#
directive|define
name|GEM_CSUM_FEATURES
value|(CSUM_TCP)
end_define

begin_function_decl
specifier|static
name|int
name|gem_add_rxbuf
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_bitwait
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|bank
parameter_list|,
name|bus_addr_t
name|r
parameter_list|,
name|uint32_t
name|clr
parameter_list|,
name|uint32_t
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_cddma_callback
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_disable_rx
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_disable_tx
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_eint
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_init_locked
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_init_regs
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_load_txmbuf
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_meminit
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_mifinit
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_reset
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_reset_rx
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_reset_rxdma
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_reset_tx
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|gem_ringsize
parameter_list|(
name|u_int
name|sz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_rint
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|GEM_RINT_TIMEOUT
end_ifdef

begin_function_decl
specifier|static
name|void
name|gem_rint_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|inline
name|void
name|gem_rxcksum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint64_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_rxdrain
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_setladrf
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|disable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_tint
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|gem_txkick
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_watchdog
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|devclass_t
name|gem_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|gem
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|gem
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GEM_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_define
define|#
directive|define
name|KTR_GEM
value|KTR_CT2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GEM_BANK1_BITWAIT
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|clr
parameter_list|,
name|set
parameter_list|)
define|\
value|gem_bitwait((sc), GEM_RES_BANK1, (r), (clr), (set))
end_define

begin_define
define|#
directive|define
name|GEM_BANK2_BITWAIT
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|clr
parameter_list|,
name|set
parameter_list|)
define|\
value|gem_bitwait((sc), GEM_RES_BANK2, (r), (clr), (set))
end_define

begin_function
name|int
name|gem_attach
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|gem_txsoft
modifier|*
name|txs
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"flags=0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
comment|/* Set up ifnet structure. */
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|sc
operator|->
name|sc_csum_features
operator|=
name|GEM_CSUM_FEATURES
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|gem_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|gem_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|gem_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|GEM_TXQUEUELEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|GEM_TXQUEUELEN
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_RINT_TIMEOUT
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make sure the chip is stopped. */
name|gem_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_pdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail_ifnet
goto|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
literal|1
argument_list|,
name|MCLBYTES
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_rdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail_ptag
goto|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
operator|*
name|GEM_NTXSEGS
argument_list|,
name|GEM_NTXSEGS
argument_list|,
name|MCLBYTES
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_tdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail_rtag
goto|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gem_control_data
argument_list|)
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gem_control_data
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail_ttag
goto|;
comment|/* 	 * Allocate the control data structures, create and load the 	 * DMA map for it. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_control_data
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc
operator|->
name|sc_cddmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to allocate control data, error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_ctag
goto|;
block|}
name|sc
operator|->
name|sc_cddma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|,
name|sc
operator|->
name|sc_control_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gem_control_data
argument_list|)
argument_list|,
name|gem_cddma_callback
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|||
name|sc
operator|->
name|sc_cddma
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to load control data DMA map, error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_cmem
goto|;
block|}
comment|/* 	 * Initialize the transmit job descriptors. 	 */
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
expr_stmt|;
comment|/* 	 * Create the transmit buffer DMA maps. 	 */
name|error
operator|=
name|ENOMEM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_TXQUEUELEN
condition|;
name|i
operator|++
control|)
block|{
name|txs
operator|=
operator|&
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
name|NULL
expr_stmt|;
name|txs
operator|->
name|txs_ndescs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
literal|0
argument_list|,
operator|&
name|txs
operator|->
name|txs_dmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create TX DMA map %d, error = %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_txd
goto|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create the receive buffer DMA maps. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_dmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create RX DMA map %d, error = %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_rxd
goto|;
block|}
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Bad things will happen when touching this register on ERI. */
if|if
condition|(
name|sc
operator|->
name|sc_variant
operator|!=
name|GEM_SUN_ERI
condition|)
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MII_DATAPATH_MODE
argument_list|,
name|GEM_MII_DATAPATH_MII
argument_list|)
expr_stmt|;
name|gem_mifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Look for an external PHY. 	 */
name|error
operator|=
name|ENXIO
expr_stmt|;
name|v
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MIF_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|GEM_MIF_CONFIG_MDI1
operator|)
operator|!=
literal|0
condition|)
block|{
name|v
operator||=
name|GEM_MIF_CONFIG_PHY_SEL
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MIF_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_variant
condition|)
block|{
case|case
name|GEM_SUN_ERI
case|:
name|sc
operator|->
name|sc_phyad
operator|=
name|GEM_PHYAD_EXTERNAL
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|sc_phyad
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_miibus
argument_list|,
name|gem_mediachange
argument_list|,
name|gem_mediastatus
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fall back on an internal PHY if no external PHY was found. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
operator|(
name|v
operator|&
name|GEM_MIF_CONFIG_MDI0
operator|)
operator|!=
literal|0
condition|)
block|{
name|v
operator|&=
operator|~
name|GEM_MIF_CONFIG_PHY_SEL
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MIF_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_variant
condition|)
block|{
case|case
name|GEM_SUN_ERI
case|:
case|case
name|GEM_APPLE_K2_GMAC
case|:
name|sc
operator|->
name|sc_phyad
operator|=
name|GEM_PHYAD_INTERNAL
expr_stmt|;
break|break;
case|case
name|GEM_APPLE_GMAC
case|:
name|sc
operator|->
name|sc_phyad
operator|=
name|GEM_PHYAD_EXTERNAL
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|sc_phyad
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_miibus
argument_list|,
name|gem_mediachange
argument_list|,
name|gem_mediastatus
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Try the external PCS SERDES if we didn't find any PHYs. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|sc_variant
operator|==
name|GEM_SUN_GEM
condition|)
block|{
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MII_DATAPATH_MODE
argument_list|,
name|GEM_MII_DATAPATH_SERDES
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MII_SLINK_CONTROL
argument_list|,
name|GEM_MII_SLINK_LOOPBACK
operator||
name|GEM_MII_SLINK_EN_SYNC_D
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MII_CONFIG
argument_list|,
name|GEM_MII_CONFIG_ENABLE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|GEM_SERDES
expr_stmt|;
name|sc
operator|->
name|sc_phyad
operator|=
name|GEM_PHYAD_EXTERNAL
expr_stmt|;
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_miibus
argument_list|,
name|gem_mediachange
argument_list|,
name|gem_mediastatus
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"PHY probe failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_rxd
goto|;
block|}
name|sc
operator|->
name|sc_mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
comment|/* 	 * From this point forward, the attachment cannot fail.  A failure 	 * before this point releases all resources that may have been 	 * allocated. 	 */
comment|/* Get RX FIFO size. */
name|sc
operator|->
name|sc_rxfifosize
operator|=
literal|64
operator|*
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_FIFO_SIZE
argument_list|)
expr_stmt|;
comment|/* Get TX FIFO size. */
name|v
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_TX_FIFO_SIZE
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%ukB RX FIFO, %ukB TX FIFO\n"
argument_list|,
name|sc
operator|->
name|sc_rxfifosize
operator|/
literal|1024
argument_list|,
name|v
operator|/
literal|16
argument_list|)
expr_stmt|;
comment|/* Attach the interface. */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames/checksum offloads. 	 */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
name|sc
operator|->
name|sc_csum_features
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_HWCSUM
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Free any resources we've allocated during the failed attach 	 * attempt.  Do this in reverse order and fall through. 	 */
name|fail_rxd
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_dmamap
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_dmamap
argument_list|)
expr_stmt|;
name|fail_txd
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_TXQUEUELEN
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
operator|.
name|txs_dmamap
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
operator|.
name|txs_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|)
expr_stmt|;
name|fail_cmem
label|:
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_control_data
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|)
expr_stmt|;
name|fail_ctag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|)
expr_stmt|;
name|fail_ttag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|)
expr_stmt|;
name|fail_rtag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|)
expr_stmt|;
name|fail_ptag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|)
expr_stmt|;
name|fail_ifnet
label|:
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gem_detach
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|GEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|gem_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|GEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_RINT_TIMEOUT
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_dmamap
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_dmamap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_TXQUEUELEN
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
operator|.
name|txs_dmamap
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
operator|.
name|txs_dmamap
argument_list|)
expr_stmt|;
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_control_data
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gem_suspend
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|GEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|gem_stop
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gem_resume
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|GEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * On resume all registers have to be initialized again like 	 * after power-on. 	 */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|GEM_INITED
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|gem_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|GEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|gem_rxcksum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint64_t
name|flags
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
decl_stmt|;
name|uint16_t
modifier|*
name|opts
decl_stmt|;
name|int32_t
name|hlen
decl_stmt|,
name|len
decl_stmt|,
name|pktlen
decl_stmt|;
name|uint32_t
name|temp32
decl_stmt|;
name|uint16_t
name|cksum
decl_stmt|;
name|pktlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
return|return;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
return|return;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|!=
name|IPVERSION
condition|)
return|return;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|pktlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|<
name|hlen
condition|)
return|return;
if|if
condition|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|!=
name|pktlen
condition|)
return|return;
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
operator||
name|IP_OFFMASK
argument_list|)
condition|)
return|return;
comment|/* Cannot handle fragmented packet. */
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|pktlen
operator|<
operator|(
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|)
condition|)
return|return;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|pktlen
operator|<
operator|(
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|)
condition|)
return|return;
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|ip
operator|+
name|hlen
operator|)
expr_stmt|;
if|if
condition|(
name|uh
operator|->
name|uh_sum
operator|==
literal|0
condition|)
return|return;
comment|/* no checksum */
break|break;
default|default:
return|return;
block|}
name|cksum
operator|=
operator|~
operator|(
name|flags
operator|&
name|GEM_RD_CHECKSUM
operator|)
expr_stmt|;
comment|/* checksum fixup for IP options */
name|len
operator|=
name|hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|opts
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|,
name|opts
operator|++
control|)
block|{
name|temp32
operator|=
name|cksum
operator|-
operator|*
name|opts
expr_stmt|;
name|temp32
operator|=
operator|(
name|temp32
operator|>>
literal|16
operator|)
operator|+
operator|(
name|temp32
operator|&
literal|65535
operator|)
expr_stmt|;
name|cksum
operator|=
name|temp32
operator|&
literal|65535
expr_stmt|;
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|cksum
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_cddma_callback
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|nsegs
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: bad control buffer segment count"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cddma
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|GEM_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Unload collision and error counters. 	 */
name|ifp
operator|->
name|if_collisions
operator|+=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_NORM_COLL_CNT
argument_list|)
operator|+
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_FIRST_COLL_CNT
argument_list|)
expr_stmt|;
name|v
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_EXCESS_COLL_CNT
argument_list|)
operator|+
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_LATE_COLL_CNT
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
name|v
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|+=
name|v
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|+=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_LEN_ERR_CNT
argument_list|)
operator|+
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_ALIGN_ERR
argument_list|)
operator|+
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CRC_ERR_CNT
argument_list|)
operator|+
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CODE_VIOL
argument_list|)
expr_stmt|;
comment|/* 	 * Then clear the hardware counters. 	 */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_NORM_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_FIRST_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_EXCESS_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_LATE_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_LEN_ERR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_ALIGN_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CRC_ERR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CODE_VIOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
if|if
condition|(
name|gem_watchdog
argument_list|(
name|sc
argument_list|)
operator|==
name|EJUSTRETURN
condition|)
return|return;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
name|hz
argument_list|,
name|gem_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gem_bitwait
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|bank
parameter_list|,
name|bus_addr_t
name|r
parameter_list|,
name|uint32_t
name|clr
parameter_list|,
name|uint32_t
name|set
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GEM_TRIES
init|;
name|i
operator|--
condition|;
name|DELAY
argument_list|(
literal|100
argument_list|)
control|)
block|{
name|reg
operator|=
name|GEM_BANKN_READ_M
argument_list|(
name|bank
argument_list|,
literal|4
argument_list|,
name|sc
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|clr
operator|)
operator|==
literal|0
operator|&&
operator|(
name|reg
operator|&
name|set
operator|)
operator|==
name|set
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_reset
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: %s"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gem_reset_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|gem_reset_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Do a full reset. */
name|GEM_BANK2_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_RX
operator||
name|GEM_RESET_TX
argument_list|)
expr_stmt|;
name|GEM_BANK2_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GEM_BANK2_BITWAIT
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_RX
operator||
name|GEM_RESET_TX
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot reset device\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_rxdrain
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|gem_rxsoft
modifier|*
name|rxs
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
name|rxs
operator|=
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxs
operator|->
name|rxs_mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxs
operator|->
name|rxs_mbuf
argument_list|)
expr_stmt|;
name|rxs
operator|->
name|rxs_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gem_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|disable
parameter_list|)
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|gem_txsoft
modifier|*
name|txs
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: %s"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_RINT_TIMEOUT
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gem_reset_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|gem_reset_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Release any queued transmit buffers. 	 */
while|while
condition|(
operator|(
name|txs
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|txs
operator|->
name|txs_ndescs
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|txs
operator|->
name|txs_mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txs
operator|->
name|txs_mbuf
argument_list|)
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|disable
condition|)
name|gem_rxdrain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Mark the interface down and cancel the watchdog timer. 	 */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|GEM_LINK
expr_stmt|;
name|sc
operator|->
name|sc_wdog_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gem_reset_rx
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Resetting while DMA is in progress can cause a bus hang, so we 	 * disable DMA first. 	 */
name|gem_disable_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_RX_CONFIG
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GEM_BANK1_BITWAIT
argument_list|(
name|sc
argument_list|,
name|GEM_RX_CONFIG
argument_list|,
name|GEM_RX_CONFIG_RXDMA_EN
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot disable RX DMA\n"
argument_list|)
expr_stmt|;
comment|/* Finally, reset the ERX. */
name|GEM_BANK2_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_RX
argument_list|)
expr_stmt|;
name|GEM_BANK2_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GEM_BANK2_BITWAIT
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_RX
operator||
name|GEM_RESET_TX
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot reset receiver\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset the receiver DMA engine.  *  * Intended to be used in case of GEM_INTR_RX_TAG_ERR, GEM_MAC_RX_OVERFLOW  * etc in order to reset the receiver DMA engine only and not do a full  * reset which amongst others also downs the link and clears the FIFOs.  */
end_comment

begin_function
specifier|static
name|void
name|gem_reset_rxdma
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|gem_reset_rx
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|gem_init_locked
argument_list|(
name|sc
argument_list|)
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_mbuf
operator|!=
name|NULL
condition|)
name|GEM_UPDATE_RXDESC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxptr
operator|=
literal|0
expr_stmt|;
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* NOTE: we use only 32-bit DMA addresses here. */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_RING_PTR_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_RING_PTR_LO
argument_list|,
name|GEM_CDRXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_KICK
argument_list|,
name|GEM_NRXDESC
operator|-
literal|4
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_CONFIG
argument_list|,
name|gem_ringsize
argument_list|(
name|GEM_NRXDESC
comment|/* XXX */
argument_list|)
operator||
operator|(
operator|(
name|ETHER_HDR_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
operator|<<
name|GEM_RX_CONFIG_CXM_START_SHFT
operator|)
operator||
operator|(
name|GEM_THRSH_1024
operator|<<
name|GEM_RX_CONFIG_FIFO_THRS_SHIFT
operator|)
operator||
operator|(
name|ETHER_ALIGN
operator|<<
name|GEM_RX_CONFIG_FBOFF_SHFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Adjust for the SBus clock probably isn't worth the fuzz. */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_BLANKING
argument_list|,
operator|(
operator|(
literal|6
operator|*
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GEM_PCI66
operator|)
operator|!=
literal|0
condition|?
literal|2
else|:
literal|1
operator|)
operator|<<
name|GEM_RX_BLANKING_TIME_SHIFT
operator|)
operator||
literal|6
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_PAUSE_THRESH
argument_list|,
operator|(
literal|3
operator|*
name|sc
operator|->
name|sc_rxfifosize
operator|/
literal|256
operator|)
operator||
operator|(
operator|(
name|sc
operator|->
name|sc_rxfifosize
operator|/
literal|256
operator|)
operator|<<
literal|12
operator|)
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_CONFIG
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_CONFIG
argument_list|)
operator||
name|GEM_RX_CONFIG_RXDMA_EN
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_MASK
argument_list|,
name|GEM_MAC_RX_DONE
operator||
name|GEM_MAC_RX_FRAME_CNT
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
operator||
name|GEM_MAC_RX_ENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gem_reset_tx
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Resetting while DMA is in progress can cause a bus hang, so we 	 * disable DMA first. 	 */
name|gem_disable_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_TX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_TX_CONFIG
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GEM_BANK1_BITWAIT
argument_list|(
name|sc
argument_list|,
name|GEM_TX_CONFIG
argument_list|,
name|GEM_TX_CONFIG_TXDMA_EN
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot disable TX DMA\n"
argument_list|)
expr_stmt|;
comment|/* Finally, reset the ETX. */
name|GEM_BANK2_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_TX
argument_list|)
expr_stmt|;
name|GEM_BANK2_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GEM_BANK2_BITWAIT
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_RX
operator||
name|GEM_RESET_TX
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot reset transmitter\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gem_disable_rx
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
operator|&
operator|~
name|GEM_MAC_RX_ENABLE
argument_list|)
expr_stmt|;
name|GEM_BANK1_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
return|return
operator|(
name|GEM_BANK1_BITWAIT
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|GEM_MAC_RX_ENABLE
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gem_disable_tx
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|)
operator|&
operator|~
name|GEM_MAC_TX_ENABLE
argument_list|)
expr_stmt|;
name|GEM_BANK1_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
return|return
operator|(
name|GEM_BANK1_BITWAIT
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
name|GEM_MAC_TX_ENABLE
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gem_meminit
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|gem_rxsoft
modifier|*
name|rxs
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|GEM_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the transmit descriptor ring. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NTXDESC
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|gd_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|gd_addr
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|sc_txfree
operator|=
name|GEM_MAXTXFREE
expr_stmt|;
name|sc
operator|->
name|sc_txnext
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_txwin
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize the receive descriptor and receive job 	 * descriptor rings. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
name|rxs
operator|=
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxs
operator|->
name|rxs_mbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|gem_add_rxbuf
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to allocate or map RX buffer %d, "
literal|"error = %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 				 * XXX we should attempt to run with fewer 				 * receive buffers instead of just failing. 				 */
name|gem_rxdrain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
name|GEM_INIT_RXDESC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rxptr
operator|=
literal|0
expr_stmt|;
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|gem_ringsize
parameter_list|(
name|u_int
name|sz
parameter_list|)
block|{
switch|switch
condition|(
name|sz
condition|)
block|{
case|case
literal|32
case|:
return|return
operator|(
name|GEM_RING_SZ_32
operator|)
return|;
case|case
literal|64
case|:
return|return
operator|(
name|GEM_RING_SZ_64
operator|)
return|;
case|case
literal|128
case|:
return|return
operator|(
name|GEM_RING_SZ_128
operator|)
return|;
case|case
literal|256
case|:
return|return
operator|(
name|GEM_RING_SZ_256
operator|)
return|;
case|case
literal|512
case|:
return|return
operator|(
name|GEM_RING_SZ_512
operator|)
return|;
case|case
literal|1024
case|:
return|return
operator|(
name|GEM_RING_SZ_1024
operator|)
return|;
case|case
literal|2048
case|:
return|return
operator|(
name|GEM_RING_SZ_2048
operator|)
return|;
case|case
literal|4096
case|:
return|return
operator|(
name|GEM_RING_SZ_4096
operator|)
return|;
case|case
literal|8192
case|:
return|return
operator|(
name|GEM_RING_SZ_8192
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"%s: invalid ring size %d\n"
argument_list|,
name|__func__
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
operator|(
name|GEM_RING_SZ_32
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gem_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|GEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|gem_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|GEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialization of interface; set up initialization block  * and transmit/receive descriptor rings.  */
end_comment

begin_function
specifier|static
name|void
name|gem_init_locked
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|GEM_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: %s: calling stop"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialization sequence.  The numbered steps below correspond 	 * to the sequence outlined in section 6.3.5.1 in the Ethernet 	 * Channel Engine manual (part of the PCIO manual). 	 * See also the STP2002-STQ document from Sun Microsystems. 	 */
comment|/* step 1& 2.  Reset the Ethernet Channel. */
name|gem_stop
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gem_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: %s: restarting"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Re-initialize the MIF. */
name|gem_mifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* step 3.  Setup data structures in host memory. */
if|if
condition|(
name|gem_meminit
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* step 4.  TX MAC registers& counters */
name|gem_init_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* step 5.  RX MAC registers& counters */
name|gem_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* step 6& 7.  Program Descriptor Ring Base Addresses. */
comment|/* NOTE: we use only 32-bit DMA addresses here. */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_TX_RING_PTR_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_TX_RING_PTR_LO
argument_list|,
name|GEM_CDTXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_RING_PTR_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_RING_PTR_LO
argument_list|,
name|GEM_CDRXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"loading RX ring %lx, TX ring %lx, cddma %lx"
argument_list|,
name|GEM_CDRXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEM_CDTXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_cddma
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* step 8.  Global Configuration& Interrupt Mask */
comment|/* 	 * Set the internal arbitration to "infinite" bursts of the 	 * maximum length of 31 * 64 bytes so DMA transfers aren't 	 * split up in cache line size chunks.  This greatly improves 	 * RX performance. 	 * Enable silicon bug workarounds for the Apple variants. 	 */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_CONFIG
argument_list|,
name|GEM_CONFIG_TXDMA_LIMIT
operator||
name|GEM_CONFIG_RXDMA_LIMIT
operator||
operator|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GEM_PCI
operator|)
operator|!=
literal|0
condition|?
name|GEM_CONFIG_BURST_INF
else|:
name|GEM_CONFIG_BURST_64
operator|)
operator||
operator|(
name|GEM_IS_APPLE
argument_list|(
name|sc
argument_list|)
condition|?
name|GEM_CONFIG_RONPAULBIT
operator||
name|GEM_CONFIG_BUG2FIX
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_INTMASK
argument_list|,
operator|~
operator|(
name|GEM_INTR_TX_INTME
operator||
name|GEM_INTR_TX_EMPTY
operator||
name|GEM_INTR_RX_DONE
operator||
name|GEM_INTR_RX_NOBUF
operator||
name|GEM_INTR_RX_TAG_ERR
operator||
name|GEM_INTR_PERR
operator||
name|GEM_INTR_BERR
ifdef|#
directive|ifdef
name|GEM_DEBUG
operator||
name|GEM_INTR_PCS
operator||
name|GEM_INTR_MIF
endif|#
directive|endif
operator|)
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_MASK
argument_list|,
name|GEM_MAC_RX_DONE
operator||
name|GEM_MAC_RX_FRAME_CNT
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_MASK
argument_list|,
name|GEM_MAC_TX_XMIT_DONE
operator||
name|GEM_MAC_TX_DEFER_EXP
operator||
name|GEM_MAC_TX_PEAK_EXP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_CONTROL_MASK
argument_list|,
operator|~
operator|(
name|GEM_MAC_PAUSED
operator||
name|GEM_MAC_PAUSE
operator||
name|GEM_MAC_RESUME
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_CONTROL_MASK
argument_list|,
name|GEM_MAC_PAUSED
operator||
name|GEM_MAC_PAUSE
operator||
name|GEM_MAC_RESUME
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* step 9.  ETX Configuration: use mostly default values. */
comment|/* Enable DMA. */
name|v
operator|=
name|gem_ringsize
argument_list|(
name|GEM_NTXDESC
argument_list|)
expr_stmt|;
comment|/* Set TX FIFO threshold and enable DMA. */
name|v
operator||=
operator|(
operator|(
name|sc
operator|->
name|sc_variant
operator|==
name|GEM_SUN_ERI
condition|?
literal|0x100
else|:
literal|0x4ff
operator|)
operator|<<
literal|10
operator|)
operator|&
name|GEM_TX_CONFIG_TXFIFO_TH
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_TX_CONFIG
argument_list|,
name|v
operator||
name|GEM_TX_CONFIG_TXDMA_EN
argument_list|)
expr_stmt|;
comment|/* step 10.  ERX Configuration */
comment|/* Encode Receive Descriptor ring size. */
name|v
operator|=
name|gem_ringsize
argument_list|(
name|GEM_NRXDESC
comment|/* XXX */
argument_list|)
expr_stmt|;
comment|/* RX TCP/UDP checksum offset */
name|v
operator||=
operator|(
operator|(
name|ETHER_HDR_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
operator|<<
name|GEM_RX_CONFIG_CXM_START_SHFT
operator|)
expr_stmt|;
comment|/* Set RX FIFO threshold, set first byte offset and enable DMA. */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_CONFIG
argument_list|,
name|v
operator||
operator|(
name|GEM_THRSH_1024
operator|<<
name|GEM_RX_CONFIG_FIFO_THRS_SHIFT
operator|)
operator||
operator|(
name|ETHER_ALIGN
operator|<<
name|GEM_RX_CONFIG_FBOFF_SHFT
operator|)
operator||
name|GEM_RX_CONFIG_RXDMA_EN
argument_list|)
expr_stmt|;
comment|/* Adjust for the SBus clock probably isn't worth the fuzz. */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_BLANKING
argument_list|,
operator|(
operator|(
literal|6
operator|*
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GEM_PCI66
operator|)
operator|!=
literal|0
condition|?
literal|2
else|:
literal|1
operator|)
operator|<<
name|GEM_RX_BLANKING_TIME_SHIFT
operator|)
operator||
literal|6
argument_list|)
expr_stmt|;
comment|/* 	 * The following value is for an OFF Threshold of about 3/4 full 	 * and an ON Threshold of 1/4 full. 	 */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_PAUSE_THRESH
argument_list|,
operator|(
literal|3
operator|*
name|sc
operator|->
name|sc_rxfifosize
operator|/
literal|256
operator|)
operator||
operator|(
operator|(
name|sc
operator|->
name|sc_rxfifosize
operator|/
literal|256
operator|)
operator|<<
literal|12
operator|)
argument_list|)
expr_stmt|;
comment|/* step 11.  Configure Media. */
comment|/* step 12.  RX_MAC Configuration Register */
name|v
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
expr_stmt|;
name|v
operator||=
name|GEM_MAC_RX_ENABLE
operator||
name|GEM_MAC_RX_STRIP_CRC
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GEM_BANK1_BITWAIT
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|GEM_MAC_RX_ENABLE
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot configure RX MAC\n"
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* step 13.  TX_MAC Configuration Register */
name|v
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|)
expr_stmt|;
name|v
operator||=
name|GEM_MAC_TX_ENABLE
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GEM_BANK1_BITWAIT
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
name|GEM_MAC_TX_ENABLE
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot configure TX MAC\n"
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* step 14.  Issue Transmit Pending command. */
comment|/* step 15.  Give the reciever a swift kick. */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_KICK
argument_list|,
name|GEM_NRXDESC
operator|-
literal|4
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|mii_mediachg
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
comment|/* Start the one second timer. */
name|sc
operator|->
name|sc_wdog_timer
operator|=
literal|0
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
name|hz
argument_list|,
name|gem_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gem_load_txmbuf
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|)
block|{
name|bus_dma_segment_t
name|txsegs
index|[
name|GEM_NTXSEGS
index|]
decl_stmt|;
name|struct
name|gem_txsoft
modifier|*
name|txs
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint64_t
name|cflags
decl_stmt|,
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nexttx
decl_stmt|,
name|nsegs
decl_stmt|,
name|offset
decl_stmt|,
name|seg
decl_stmt|;
name|GEM_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Get a work queue entry. */
if|if
condition|(
operator|(
name|txs
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Ran out of descriptors. */
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|cflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|m_head
operator|)
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|sc
operator|->
name|sc_csum_features
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|M_WRITABLE
argument_list|(
operator|*
name|m_head
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|m_dup
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_pullup
argument_list|(
operator|*
name|m_head
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|offset
operator|)
expr_stmt|;
name|offset
operator|+=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|cflags
operator|=
name|offset
operator|<<
name|GEM_TD_CXSUM_STARTSHFT
operator||
operator|(
operator|(
name|offset
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|)
operator|<<
name|GEM_TD_CXSUM_STUFFSHFT
operator|)
operator||
name|GEM_TD_CXSUM_ENABLE
expr_stmt|;
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
block|}
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
operator|*
name|m_head
argument_list|,
name|txsegs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|m
operator|=
name|m_collapse
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|,
name|GEM_NTXSEGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
operator|*
name|m_head
argument_list|,
name|txsegs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* If nsegs is wrong then the stack is corrupt. */
name|KASSERT
argument_list|(
name|nsegs
operator|<=
name|GEM_NTXSEGS
argument_list|,
operator|(
literal|"%s: too many DMA segments (%d)"
operator|,
name|__func__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsegs
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Ensure we have enough descriptors free to describe 	 * the packet.  Note, we always reserve one descriptor 	 * at the end of the ring as a termination point, in 	 * order to prevent wrap-around. 	 */
if|if
condition|(
name|nsegs
operator|>
name|sc
operator|->
name|sc_txfree
operator|-
literal|1
condition|)
block|{
name|txs
operator|->
name|txs_ndescs
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|txs
operator|->
name|txs_ndescs
operator|=
name|nsegs
expr_stmt|;
name|txs
operator|->
name|txs_firstdesc
operator|=
name|sc
operator|->
name|sc_txnext
expr_stmt|;
name|nexttx
operator|=
name|txs
operator|->
name|txs_firstdesc
expr_stmt|;
for|for
control|(
name|seg
operator|=
literal|0
init|;
name|seg
operator|<
name|nsegs
condition|;
name|seg
operator|++
operator|,
name|nexttx
operator|=
name|GEM_NEXTTX
argument_list|(
name|nexttx
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR6
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: mapping seg %d (txd %d), len %lx, addr %#lx (%#lx)"
argument_list|,
name|__func__
argument_list|,
name|seg
argument_list|,
name|nexttx
argument_list|,
name|txsegs
index|[
name|seg
index|]
operator|.
name|ds_len
argument_list|,
name|txsegs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|,
name|GEM_DMA_WRITE
argument_list|(
name|sc
argument_list|,
name|txsegs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_txdescs
index|[
name|nexttx
index|]
operator|.
name|gd_addr
operator|=
name|GEM_DMA_WRITE
argument_list|(
name|sc
argument_list|,
name|txsegs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txsegs
index|[
name|seg
index|]
operator|.
name|ds_len
operator|<
name|GEM_TD_BUFSIZE
argument_list|,
operator|(
literal|"%s: segment size too large!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|txsegs
index|[
name|seg
index|]
operator|.
name|ds_len
operator|&
name|GEM_TD_BUFSIZE
expr_stmt|;
name|sc
operator|->
name|sc_txdescs
index|[
name|nexttx
index|]
operator|.
name|gd_flags
operator|=
name|GEM_DMA_WRITE
argument_list|(
name|sc
argument_list|,
name|flags
operator||
name|cflags
argument_list|)
expr_stmt|;
name|txs
operator|->
name|txs_lastdesc
operator|=
name|nexttx
expr_stmt|;
block|}
comment|/* Set EOP on the last descriptor. */
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: end of packet at segment %d, TX %d"
argument_list|,
name|__func__
argument_list|,
name|seg
argument_list|,
name|nexttx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_txdescs
index|[
name|txs
operator|->
name|txs_lastdesc
index|]
operator|.
name|gd_flags
operator||=
name|GEM_DMA_WRITE
argument_list|(
name|sc
argument_list|,
name|GEM_TD_END_OF_PACKET
argument_list|)
expr_stmt|;
comment|/* Lastly set SOP on the first descriptor. */
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: start of packet at segment %d, TX %d"
argument_list|,
name|__func__
argument_list|,
name|seg
argument_list|,
name|nexttx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_txwin
operator|>
name|GEM_NTXSEGS
operator|*
literal|2
operator|/
literal|3
condition|)
block|{
name|sc
operator|->
name|sc_txwin
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_txdescs
index|[
name|txs
operator|->
name|txs_firstdesc
index|]
operator|.
name|gd_flags
operator||=
name|GEM_DMA_WRITE
argument_list|(
name|sc
argument_list|,
name|GEM_TD_INTERRUPT_ME
operator||
name|GEM_TD_START_OF_PACKET
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_txdescs
index|[
name|txs
operator|->
name|txs_firstdesc
index|]
operator|.
name|gd_flags
operator||=
name|GEM_DMA_WRITE
argument_list|(
name|sc
argument_list|,
name|GEM_TD_START_OF_PACKET
argument_list|)
expr_stmt|;
comment|/* Sync the DMA map. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR4
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: setting firstdesc=%d, lastdesc=%d, ndescs=%d"
argument_list|,
name|__func__
argument_list|,
name|txs
operator|->
name|txs_firstdesc
argument_list|,
name|txs
operator|->
name|txs_lastdesc
argument_list|,
name|txs
operator|->
name|txs_ndescs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
operator|*
name|m_head
expr_stmt|;
name|sc
operator|->
name|sc_txnext
operator|=
name|GEM_NEXTTX
argument_list|(
name|txs
operator|->
name|txs_lastdesc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txfree
operator|-=
name|txs
operator|->
name|txs_ndescs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_init_regs
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|laddr
init|=
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
decl_stmt|;
name|GEM_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* These registers are not cleared on reset. */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GEM_INITED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* magic values */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_IPG0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_IPG1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_IPG2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* min frame length */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_MAC_MIN_FRAME
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
comment|/* max frame length and max burst size */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_MAC_MAX_FRAME
argument_list|,
operator|(
name|ETHER_MAX_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|)
operator||
operator|(
literal|0x2000
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* more magic values */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_PREAMBLE_LEN
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_JAM_SIZE
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ATTEMPT_LIMIT
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_CONTROL_TYPE
argument_list|,
literal|0x8088
argument_list|)
expr_stmt|;
comment|/* random number seed */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RANDOM_SEED
argument_list|,
operator|(
operator|(
name|laddr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|laddr
index|[
literal|4
index|]
operator|)
operator|&
literal|0x3ff
argument_list|)
expr_stmt|;
comment|/* secondary MAC address: 0:0:0:0:0:0 */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ADDR3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ADDR4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ADDR5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* MAC control address: 01:80:c2:00:00:01 */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ADDR6
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ADDR7
argument_list|,
literal|0xc200
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ADDR8
argument_list|,
literal|0x0180
argument_list|)
expr_stmt|;
comment|/* MAC filter address: 0:0:0:0:0:0 */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ADDR_FILTER0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ADDR_FILTER1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ADDR_FILTER2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ADR_FLT_MASK1_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ADR_FLT_MASK0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|GEM_INITED
expr_stmt|;
block|}
comment|/* Counters need to be zeroed. */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_NORM_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_FIRST_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_EXCESS_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_LATE_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_DEFER_TMR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_PEAK_ATTEMPTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_FRAME_COUNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_LEN_ERR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_ALIGN_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CRC_ERR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CODE_VIOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set XOFF PAUSE time. */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_SEND_PAUSE_CMD
argument_list|,
literal|0x1BF0
argument_list|)
expr_stmt|;
comment|/* Set the station address. */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ADDR0
argument_list|,
operator|(
name|laddr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|laddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ADDR1
argument_list|,
operator|(
name|laddr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|laddr
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_ADDR2
argument_list|,
operator|(
name|laddr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|laddr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Enable MII outputs. */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_XIF_CONFIG
argument_list|,
name|GEM_MAC_XIF_TX_MII_ENA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|GEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|gem_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|GEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|gem_txkick
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Update the TX kick register.  This register has to point to the 	 * descriptor after the last valid one and for optimum performance 	 * should be incremented in multiples of 4 (the DMA engine fetches/ 	 * updates descriptors in batches of 4). 	 */
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: %s: kicking TX %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_txnext
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_TX_KICK
argument_list|,
name|sc
operator|->
name|sc_txnext
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|kicked
decl_stmt|,
name|ntx
decl_stmt|;
name|GEM_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GEM_LINK
operator|)
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR4
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: %s: txfree %d, txnext %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_txfree
argument_list|,
name|sc
operator|->
name|sc_txnext
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ntx
operator|=
literal|0
expr_stmt|;
name|kicked
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
operator|&&
name|sc
operator|->
name|sc_txfree
operator|>
literal|1
condition|;
control|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|gem_load_txmbuf
argument_list|(
name|sc
argument_list|,
operator|&
name|m
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_txnext
operator|%
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
name|gem_txkick
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|kicked
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|kicked
operator|=
literal|0
expr_stmt|;
name|ntx
operator|++
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntx
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|kicked
operator|==
literal|0
condition|)
name|gem_txkick
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: packets enqueued, OWN on %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_txnext
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set a watchdog timer in case the chip flakes out. */
name|sc
operator|->
name|sc_wdog_timer
operator|=
literal|5
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: %s: watchdog %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_wdog_timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gem_tint
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|gem_txsoft
modifier|*
name|txs
decl_stmt|;
name|int
name|progress
decl_stmt|;
name|uint32_t
name|txlast
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|int
name|i
decl_stmt|;
name|GEM_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: %s"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Go through our TX list and free mbufs for those 	 * frames that have been transmitted. 	 */
name|progress
operator|=
literal|0
expr_stmt|;
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|txs
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|GEM_DEBUG
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"    txsoft %p transmit chain:\n"
argument_list|,
name|txs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|txs
operator|->
name|txs_firstdesc
init|;
condition|;
name|i
operator|=
name|GEM_NEXTTX
argument_list|(
name|i
argument_list|)
control|)
block|{
name|printf
argument_list|(
literal|"descriptor %d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gd_flags: 0x%016llx\t"
argument_list|,
operator|(
name|long
name|long
operator|)
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|gd_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gd_addr: 0x%016llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|gd_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|txs
operator|->
name|txs_lastdesc
condition|)
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * In theory, we could harvest some descriptors before 		 * the ring is empty, but that's a bit complicated. 		 * 		 * GEM_TX_COMPLETION points to the last descriptor 		 * processed + 1. 		 */
name|txlast
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_TX_COMPLETION
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR4
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: txs->txs_firstdesc = %d, "
literal|"txs->txs_lastdesc = %d, txlast = %d"
argument_list|,
name|__func__
argument_list|,
name|txs
operator|->
name|txs_firstdesc
argument_list|,
name|txs
operator|->
name|txs_lastdesc
argument_list|,
name|txlast
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|txs
operator|->
name|txs_firstdesc
operator|<=
name|txs
operator|->
name|txs_lastdesc
condition|)
block|{
if|if
condition|(
operator|(
name|txlast
operator|>=
name|txs
operator|->
name|txs_firstdesc
operator|)
operator|&&
operator|(
name|txlast
operator|<=
name|txs
operator|->
name|txs_lastdesc
operator|)
condition|)
break|break;
block|}
else|else
block|{
comment|/* Ick -- this command wraps. */
if|if
condition|(
operator|(
name|txlast
operator|>=
name|txs
operator|->
name|txs_firstdesc
operator|)
operator|||
operator|(
name|txlast
operator|<=
name|txs
operator|->
name|txs_lastdesc
operator|)
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: releasing a descriptor"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txfree
operator|+=
name|txs
operator|->
name|txs_ndescs
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|txs
operator|->
name|txs_mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txs
operator|->
name|txs_mbuf
argument_list|)
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|progress
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR4
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: GEM_TX_STATE_MACHINE %x GEM_TX_DATA_PTR %llx "
literal|"GEM_TX_COMPLETION %x"
argument_list|,
name|__func__
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_TX_STATE_MACHINE
argument_list|)
argument_list|,
operator|(
operator|(
name|long
name|long
operator|)
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_TX_DATA_PTR_HI
argument_list|)
operator|<<
literal|32
operator|)
operator||
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_TX_DATA_PTR_LO
argument_list|)
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_TX_COMPLETION
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|progress
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_txfree
operator|==
name|GEM_NTXDESC
operator|-
literal|1
condition|)
name|sc
operator|->
name|sc_txwin
operator|=
literal|0
expr_stmt|;
comment|/* 		 * We freed some descriptors, so reset IFF_DRV_OACTIVE 		 * and restart. 		 */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
condition|)
name|sc
operator|->
name|sc_wdog_timer
operator|=
literal|0
expr_stmt|;
name|gem_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: %s: watchdog %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_wdog_timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GEM_RINT_TIMEOUT
end_ifdef

begin_function
specifier|static
name|void
name|gem_rint_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|GEM_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|gem_rint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|gem_rint
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint64_t
name|rxstat
decl_stmt|;
name|uint32_t
name|rxcomp
decl_stmt|;
name|GEM_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_RINT_TIMEOUT
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: %s"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Read the completion register once.  This limits 	 * how long the following loop can execute. 	 */
name|rxcomp
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_COMPLETION
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: sc->sc_rxptr %d, complete %d"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|,
name|rxcomp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sc
operator|->
name|sc_rxptr
operator|!=
name|rxcomp
condition|;
control|)
block|{
name|m
operator|=
name|sc
operator|->
name|sc_rxsoft
index|[
name|sc
operator|->
name|sc_rxptr
index|]
operator|.
name|rxs_mbuf
expr_stmt|;
name|rxstat
operator|=
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxdescs
index|[
name|sc
operator|->
name|sc_rxptr
index|]
operator|.
name|gd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxstat
operator|&
name|GEM_RD_OWN
condition|)
block|{
ifdef|#
directive|ifdef
name|GEM_RINT_TIMEOUT
comment|/* 			 * The descriptor is still marked as owned, although 			 * it is supposed to have completed.  This has been 			 * observed on some machines.  Just exiting here 			 * might leave the packet sitting around until another 			 * one arrives to trigger a new interrupt, which is 			 * generally undesirable, so set up a timeout. 			 */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|,
name|GEM_RXOWN_TICKS
argument_list|,
name|gem_rint_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m
operator|=
name|NULL
expr_stmt|;
goto|goto
name|kickit
goto|;
block|}
if|if
condition|(
name|rxstat
operator|&
name|GEM_RD_BAD_CRC
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"receive error: CRC error\n"
argument_list|)
expr_stmt|;
name|GEM_INIT_RXDESC
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
goto|goto
name|kickit
goto|;
block|}
ifdef|#
directive|ifdef
name|GEM_DEBUG
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"    rxsoft %p descriptor %d: "
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|sc
operator|->
name|sc_rxptr
index|]
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gd_flags: 0x%016llx\t"
argument_list|,
operator|(
name|long
name|long
operator|)
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxdescs
index|[
name|sc
operator|->
name|sc_rxptr
index|]
operator|.
name|gd_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gd_addr: 0x%016llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxdescs
index|[
name|sc
operator|->
name|sc_rxptr
index|]
operator|.
name|gd_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * Allocate a new mbuf cluster.  If that fails, we are 		 * out of memory, and must drop the packet and recycle 		 * the buffer that's already attached to this descriptor. 		 */
if|if
condition|(
name|gem_add_rxbuf
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|GEM_INIT_RXDESC
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|kickit
label|:
comment|/* 		 * Update the RX kick register.  This register has to point 		 * to the descriptor after the last valid one (before the 		 * current batch) and for optimum performance should be 		 * incremented in multiples of 4 (the DMA engine fetches/ 		 * updates descriptors in batches of 4). 		 */
name|sc
operator|->
name|sc_rxptr
operator|=
name|GEM_NEXTRX
argument_list|(
name|sc
operator|->
name|sc_rxptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_rxptr
operator|%
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
name|GEM_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_KICK
argument_list|,
operator|(
name|sc
operator|->
name|sc_rxptr
operator|+
name|GEM_NRXDESC
operator|-
literal|4
operator|)
operator|&
name|GEM_NRXDESC_MASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rxstat
operator|&
name|GEM_RD_OWN
condition|)
break|break;
continue|continue;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|ETHER_ALIGN
expr_stmt|;
comment|/* first byte offset */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|GEM_RD_BUFLEN
argument_list|(
name|rxstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|gem_rxcksum
argument_list|(
name|m
argument_list|,
name|rxstat
argument_list|)
expr_stmt|;
comment|/* Pass it on. */
name|GEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|GEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: done sc->sc_rxptr %d, complete %d"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_COMPLETION
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|gem_add_rxbuf
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|gem_rxsoft
modifier|*
name|rxs
init|=
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nsegs
decl_stmt|;
name|GEM_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
comment|/* Bzero the packet to check DMA. */
name|memset
argument_list|(
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_ext
operator|.
name|ext_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rxs
operator|->
name|rxs_mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot load RS DMA map %d, error = %d\n"
argument_list|,
name|idx
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* If nsegs is wrong then the stack is corrupt. */
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: too many DMA segments (%d)"
operator|,
name|__func__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
name|rxs
operator|->
name|rxs_mbuf
operator|=
name|m
expr_stmt|;
name|rxs
operator|->
name|rxs_paddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|GEM_INIT_RXDESC
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_eint
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|status
parameter_list|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|GEM_INTR_RX_TAG_ERR
operator|)
operator|!=
literal|0
condition|)
block|{
name|gem_reset_rxdma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: status 0x%x"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|GEM_INTR_BERR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GEM_PCI
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", PCI bus error 0x%x\n"
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_PCI_ERROR_STATUS
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", SBus error 0x%x\n"
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_SBUS_STATUS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|gem_intr
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|uint32_t
name|status
decl_stmt|,
name|status2
decl_stmt|;
name|GEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|status
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_STATUS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR4
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: %s: cplt %x, status %x"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|,
operator|(
name|status
operator|>>
name|GEM_STATUS_TX_COMPLETION_SHFT
operator|)
argument_list|,
operator|(
name|u_int
operator|)
name|status
argument_list|)
expr_stmt|;
comment|/* 	 * PCS interrupts must be cleared, otherwise no traffic is passed! 	 */
if|if
condition|(
operator|(
name|status
operator|&
name|GEM_INTR_PCS
operator|)
operator|!=
literal|0
condition|)
block|{
name|status2
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MII_INTERRUP_STATUS
argument_list|)
operator||
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MII_INTERRUP_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status2
operator|&
name|GEM_MII_INTERRUP_LINK
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: PCS link status changed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|GEM_MAC_CONTROL_STATUS
operator|)
operator|!=
literal|0
condition|)
block|{
name|status2
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_CONTROL_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status2
operator|&
name|GEM_MAC_PAUSED
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: PAUSE received (PAUSE time %d slots)\n"
argument_list|,
name|__func__
argument_list|,
name|GEM_MAC_PAUSE_TIME
argument_list|(
name|status2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status2
operator|&
name|GEM_MAC_PAUSE
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: transited to PAUSE state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status2
operator|&
name|GEM_MAC_RESUME
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: transited to non-PAUSE state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|GEM_INTR_MIF
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: MIF interrupt\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__predict_false
argument_list|(
name|status
operator|&
operator|(
name|GEM_INTR_RX_TAG_ERR
operator||
name|GEM_INTR_PERR
operator||
name|GEM_INTR_BERR
operator|)
argument_list|)
operator|!=
literal|0
condition|)
name|gem_eint
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|GEM_INTR_RX_DONE
operator||
name|GEM_INTR_RX_NOBUF
operator|)
operator|)
operator|!=
literal|0
condition|)
name|gem_rint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|GEM_INTR_TX_EMPTY
operator||
name|GEM_INTR_TX_INTME
operator|)
operator|)
operator|!=
literal|0
condition|)
name|gem_tint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|status
operator|&
name|GEM_INTR_TX_MAC
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|status2
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status2
operator|&
operator|~
operator|(
name|GEM_MAC_TX_XMIT_DONE
operator||
name|GEM_MAC_TX_DEFER_EXP
operator||
name|GEM_MAC_TX_PEAK_EXP
operator|)
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"MAC TX fault, status %x\n"
argument_list|,
name|status2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status2
operator|&
operator|(
name|GEM_MAC_TX_UNDERRUN
operator||
name|GEM_MAC_TX_PKT_TOO_LONG
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|gem_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|status
operator|&
name|GEM_INTR_RX_MAC
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|status2
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_STATUS
argument_list|)
expr_stmt|;
comment|/* 		 * At least with GEM_SUN_GEM and some GEM_SUN_ERI 		 * revisions GEM_MAC_RX_OVERFLOW happen often due to a 		 * silicon bug so handle them silently.  Moreover, it's 		 * likely that the receiver has hung so we reset it. 		 */
if|if
condition|(
operator|(
name|status2
operator|&
name|GEM_MAC_RX_OVERFLOW
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|gem_reset_rxdma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status2
operator|&
operator|~
operator|(
name|GEM_MAC_RX_DONE
operator||
name|GEM_MAC_RX_FRAME_CNT
operator|)
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"MAC RX fault, status %x\n"
argument_list|,
name|status2
argument_list|)
expr_stmt|;
block|}
name|GEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gem_watchdog
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|GEM_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|CTR4
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: GEM_RX_CONFIG %x GEM_MAC_RX_STATUS %x GEM_MAC_RX_CONFIG %x"
argument_list|,
name|__func__
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_RX_CONFIG
argument_list|)
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_STATUS
argument_list|)
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: GEM_TX_CONFIG %x GEM_MAC_TX_STATUS %x GEM_MAC_TX_CONFIG %x"
argument_list|,
name|__func__
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_TX_CONFIG
argument_list|)
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_STATUS
argument_list|)
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_wdog_timer
operator|==
literal|0
operator|||
operator|--
name|sc
operator|->
name|sc_wdog_timer
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GEM_LINK
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device timeout (no link)\n"
argument_list|)
expr_stmt|;
operator|++
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
comment|/* Try to get more packets going. */
name|gem_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|gem_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_mifinit
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Configure the MIF in frame mode. */
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MIF_CONFIG
argument_list|,
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MIF_CONFIG
argument_list|)
operator|&
operator|~
name|GEM_MIF_CONFIG_BB_ENA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MII interface  *  * The MII interface supports at least three different operating modes:  *  * Bitbang mode is implemented using data, clock and output enable registers.  *  * Frame mode is implemented by loading a complete frame into the frame  * register and polling the valid bit for completion.  *  * Polling mode uses the frame register but completion is indicated by  * an interrupt.  *  */
end_comment

begin_function
name|int
name|gem_mii_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG_PHY
name|printf
argument_list|(
literal|"%s: phy %d reg %d\n"
argument_list|,
name|__func__
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_phyad
operator|!=
operator|-
literal|1
operator|&&
name|phy
operator|!=
name|sc
operator|->
name|sc_phyad
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GEM_SERDES
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|MII_BMCR
case|:
name|reg
operator|=
name|GEM_MII_CONTROL
expr_stmt|;
break|break;
case|case
name|MII_BMSR
case|:
name|reg
operator|=
name|GEM_MII_STATUS
expr_stmt|;
break|break;
case|case
name|MII_PHYIDR1
case|:
case|case
name|MII_PHYIDR2
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MII_ANAR
case|:
name|reg
operator|=
name|GEM_MII_ANAR
expr_stmt|;
break|break;
case|case
name|MII_ANLPAR
case|:
name|reg
operator|=
name|GEM_MII_ANLPAR
expr_stmt|;
break|break;
case|case
name|MII_EXTSR
case|:
return|return
operator|(
name|EXTSR_1000XFDX
operator||
name|EXTSR_1000XHDX
operator|)
return|;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unhandled register %d\n"
argument_list|,
name|__func__
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
comment|/* Construct the frame command. */
name|v
operator|=
name|GEM_MIF_FRAME_READ
operator||
operator|(
name|phy
operator|<<
name|GEM_MIF_PHY_SHIFT
operator|)
operator||
operator|(
name|reg
operator|<<
name|GEM_MIF_REG_SHIFT
operator|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MIF_FRAME
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|GEM_BANK1_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_MIF_FRAME
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|100
condition|;
name|n
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MIF_FRAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|GEM_MIF_FRAME_TA0
condition|)
return|return
operator|(
name|v
operator|&
name|GEM_MIF_FRAME_DATA
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timed out\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gem_mii_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG_PHY
name|printf
argument_list|(
literal|"%s: phy %d reg %d val %x\n"
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_phyad
operator|!=
operator|-
literal|1
operator|&&
name|phy
operator|!=
name|sc
operator|->
name|sc_phyad
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GEM_SERDES
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|MII_BMSR
case|:
name|reg
operator|=
name|GEM_MII_STATUS
expr_stmt|;
break|break;
case|case
name|MII_BMCR
case|:
name|reg
operator|=
name|GEM_MII_CONTROL
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|GEM_MII_CONTROL_RESET
operator|)
operator|==
literal|0
condition|)
break|break;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MII_CONTROL
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|GEM_BANK1_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_MII_CONTROL
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GEM_BANK1_BITWAIT
argument_list|(
name|sc
argument_list|,
name|GEM_MII_CONTROL
argument_list|,
name|GEM_MII_CONTROL_RESET
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot reset PCS\n"
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MII_ANAR
case|:
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MII_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_MII_CONFIG
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MII_ANAR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MII_SLINK_CONTROL
argument_list|,
name|GEM_MII_SLINK_LOOPBACK
operator||
name|GEM_MII_SLINK_EN_SYNC_D
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MII_CONFIG
argument_list|,
name|GEM_MII_CONFIG_ENABLE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MII_ANLPAR
case|:
name|reg
operator|=
name|GEM_MII_ANLPAR
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unhandled register %d\n"
argument_list|,
name|__func__
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Construct the frame command. */
name|v
operator|=
name|GEM_MIF_FRAME_WRITE
operator||
operator|(
name|phy
operator|<<
name|GEM_MIF_PHY_SHIFT
operator|)
operator||
operator|(
name|reg
operator|<<
name|GEM_MIF_REG_SHIFT
operator|)
operator||
operator|(
name|val
operator|&
name|GEM_MIF_FRAME_DATA
operator|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MIF_FRAME
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|GEM_BANK1_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_MIF_FRAME
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|100
condition|;
name|n
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MIF_FRAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|GEM_MIF_FRAME_TA0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timed out\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gem_mii_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|gigabit
decl_stmt|;
name|uint32_t
name|rxcfg
decl_stmt|,
name|txcfg
decl_stmt|,
name|v
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|GEM_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: status change: PHY = %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_phyad
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_status
operator|&
name|IFM_ACTIVE
operator|)
operator|!=
literal|0
operator|&&
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|!=
name|IFM_NONE
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|GEM_LINK
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|GEM_LINK
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_1000_SX
case|:
case|case
name|IFM_1000_LX
case|:
case|case
name|IFM_1000_CX
case|:
case|case
name|IFM_1000_T
case|:
name|gigabit
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|gigabit
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * The configuration done here corresponds to the steps F) and 	 * G) and as far as enabling of RX and TX MAC goes also step H) 	 * of the initialization sequence outlined in section 3.2.1 of 	 * the GEM Gigabit Ethernet ASIC Specification. 	 */
name|rxcfg
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
expr_stmt|;
name|rxcfg
operator|&=
operator|~
operator|(
name|GEM_MAC_RX_CARR_EXTEND
operator||
name|GEM_MAC_RX_ENABLE
operator|)
expr_stmt|;
name|txcfg
operator|=
name|GEM_MAC_TX_ENA_IPG0
operator||
name|GEM_MAC_TX_NGU
operator||
name|GEM_MAC_TX_NGU_LIMIT
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|txcfg
operator||=
name|GEM_MAC_TX_IGN_CARRIER
operator||
name|GEM_MAC_TX_IGN_COLLIS
expr_stmt|;
elseif|else
if|if
condition|(
name|gigabit
operator|!=
literal|0
condition|)
block|{
name|rxcfg
operator||=
name|GEM_MAC_RX_CARR_EXTEND
expr_stmt|;
name|txcfg
operator||=
name|GEM_MAC_TX_CARR_EXTEND
expr_stmt|;
block|}
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GEM_BANK1_BITWAIT
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
name|GEM_MAC_TX_ENABLE
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot disable TX MAC\n"
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
name|txcfg
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GEM_BANK1_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GEM_BANK1_BITWAIT
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|GEM_MAC_RX_ENABLE
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot disable RX MAC\n"
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|rxcfg
argument_list|)
expr_stmt|;
name|v
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_CONTROL_CONFIG
argument_list|)
operator|&
operator|~
operator|(
name|GEM_MAC_CC_RX_PAUSE
operator||
name|GEM_MAC_CC_TX_PAUSE
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_RXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|v
operator||=
name|GEM_MAC_CC_RX_PAUSE
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_TXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|v
operator||=
name|GEM_MAC_CC_TX_PAUSE
expr_stmt|;
endif|#
directive|endif
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_CONTROL_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|==
literal|0
operator|&&
name|gigabit
operator|!=
literal|0
condition|)
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_SLOT_TIME
argument_list|,
name|GEM_MAC_SLOT_TIME_CARR_EXTEND
argument_list|)
expr_stmt|;
else|else
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_SLOT_TIME
argument_list|,
name|GEM_MAC_SLOT_TIME_NORMAL
argument_list|)
expr_stmt|;
comment|/* XIF Configuration */
name|v
operator|=
name|GEM_MAC_XIF_LINK_LED
expr_stmt|;
name|v
operator||=
name|GEM_MAC_XIF_TX_MII_ENA
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GEM_SERDES
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MIF_CONFIG
argument_list|)
operator|&
name|GEM_MIF_CONFIG_PHY_SEL
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* External MII needs echo disable if half duplex. */
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|==
literal|0
condition|)
name|v
operator||=
name|GEM_MAC_XIF_ECHO_DISABL
expr_stmt|;
block|}
else|else
comment|/* 			 * Internal MII needs buffer enable. 			 * XXX buffer enable makes only sense for an 			 * external PHY. 			 */
name|v
operator||=
name|GEM_MAC_XIF_MII_BUF_ENA
expr_stmt|;
block|}
if|if
condition|(
name|gigabit
operator|!=
literal|0
condition|)
name|v
operator||=
name|GEM_MAC_XIF_GMII_MODE
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|v
operator||=
name|GEM_MAC_XIF_FDPLX_LED
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_XIF_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GEM_LINK
operator|)
operator|!=
literal|0
condition|)
block|{
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
name|txcfg
operator||
name|GEM_MAC_TX_ENABLE
argument_list|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|rxcfg
operator||
name|GEM_MAC_RX_ENABLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|gem_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* XXX add support for serial media. */
name|GEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mii_mediachg
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
name|GEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gem_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|GEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|GEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|mii_pollstat
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_status
expr_stmt|;
name|GEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gem_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|GEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|sc_ifflags
operator|)
operator|&
operator|(
name|IFF_ALLMULTI
operator||
name|IFF_PROMISC
operator|)
operator|)
operator|!=
literal|0
condition|)
name|gem_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|gem_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|gem_stop
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_csum_features
operator||=
name|CSUM_UDP
expr_stmt|;
else|else
name|sc
operator|->
name|sc_csum_features
operator|&=
operator|~
name|CSUM_UDP
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|sc
operator|->
name|sc_csum_features
expr_stmt|;
name|sc
operator|->
name|sc_ifflags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|GEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|GEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|gem_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|GEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|GEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifr
operator|->
name|ifr_reqcap
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|sc
operator|->
name|sc_csum_features
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
name|GEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_setladrf
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|inm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|hash
index|[
literal|16
index|]
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|,
name|v
decl_stmt|;
name|GEM_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Get the current RX configuration. */
name|v
operator|=
name|GEM_BANK1_READ_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
expr_stmt|;
comment|/* 	 * Turn off promiscuous mode, promiscuous group mode (all multicast), 	 * and hash filter.  Depending on the case, the right bit will be 	 * enabled. 	 */
name|v
operator|&=
operator|~
operator|(
name|GEM_MAC_RX_PROMISCUOUS
operator||
name|GEM_MAC_RX_HASH_FILTER
operator||
name|GEM_MAC_RX_PROMISC_GRP
operator|)
expr_stmt|;
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|GEM_BANK1_BARRIER
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GEM_BANK1_BITWAIT
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|GEM_MAC_RX_HASH_FILTER
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot disable RX hash filter\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
block|{
name|v
operator||=
name|GEM_MAC_RX_PROMISCUOUS
expr_stmt|;
goto|goto
name|chipit
goto|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|!=
literal|0
condition|)
block|{
name|v
operator||=
name|GEM_MAC_RX_PROMISC_GRP
expr_stmt|;
goto|goto
name|chipit
goto|;
block|}
comment|/* 	 * Set up multicast address filter by passing all multicast 	 * addresses through a crc generator, and then using the high 	 * order 8 bits as an index into the 256 bit logical address 	 * filter.  The high order 4 bits selects the word, while the 	 * other 4 bits select the bit within the word (where bit 0 	 * is the MSB). 	 */
comment|/* Clear the hash table. */
name|memset
argument_list|(
name|hash
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|inm
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|inm
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|crc
operator|=
name|ether_crc32_le
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|inm
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* We just want the 8 most significant bits. */
name|crc
operator|>>=
literal|24
expr_stmt|;
comment|/* Set the corresponding bit in the filter. */
name|hash
index|[
name|crc
operator|>>
literal|4
index|]
operator||=
literal|1
operator|<<
operator|(
literal|15
operator|-
operator|(
name|crc
operator|&
literal|15
operator|)
operator|)
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|v
operator||=
name|GEM_MAC_RX_HASH_FILTER
expr_stmt|;
comment|/* Now load the hash table into the chip (if we are using it). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_HASH0
operator|+
name|i
operator|*
operator|(
name|GEM_MAC_HASH1
operator|-
name|GEM_MAC_HASH0
operator|)
argument_list|,
name|hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|chipit
label|:
name|GEM_BANK1_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

