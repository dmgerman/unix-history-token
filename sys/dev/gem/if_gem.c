begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2001 Eduardo Horvath.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR  ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: NetBSD: gem.c,v 1.9 2001/10/21 20:45:15 thorpej Exp  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Driver for Sun GEM ethernet controllers.  */
end_comment

begin_define
define|#
directive|define
name|GEM_DEBUG
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<gem/if_gemreg.h>
end_include

begin_include
include|#
directive|include
file|<gem/if_gemvar.h>
end_include

begin_define
define|#
directive|define
name|TRIES
value|10000
end_define

begin_function_decl
specifier|static
name|void
name|gem_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_cddma_callback
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_rxdma_callback
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_txdma_callback
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_init_regs
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_ringsize
parameter_list|(
name|int
name|sz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_meminit
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_dmamap_load_mbuf
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|bus_dmamap_callback_t
modifier|*
parameter_list|,
name|struct
name|gem_txjob
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_dmamap_unload_mbuf
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|,
name|struct
name|gem_txjob
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_dmamap_commit_mbuf
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|,
name|struct
name|gem_txjob
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_mifinit
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_bitwait
parameter_list|(
name|struct
name|gem_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|r
parameter_list|,
name|u_int32_t
name|clr
parameter_list|,
name|u_int32_t
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_reset_rx
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_reset_tx
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_disable_rx
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_disable_tx
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_rxdrain
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gem_add_rxbuf
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_setladrf
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|mbuf
modifier|*
name|gem_get
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_eint
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_rint
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_rint_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gem_tint
parameter_list|(
name|struct
name|gem_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function_decl
specifier|static
name|void
name|gem_power
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|devclass_t
name|gem_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|gem
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|gem
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GEM_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|x
parameter_list|)
value|if ((sc)->sc_arpcom.ac_if.if_flags& IFF_DEBUG) \ 				printf x
end_define

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_define
define|#
directive|define
name|KTR_GEM
value|KTR_CT2
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|x
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GEM_NSEGS
value|GEM_NTXSEGS
end_define

begin_comment
comment|/*  * gem_attach:  *  *	Attach a Gem interface to the system.  */
end_comment

begin_function
name|int
name|gem_attach
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|mii_softc
modifier|*
name|child
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
comment|/* Make sure the chip is stopped. */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|gem_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
name|GEM_NSEGS
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_pdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MAXBSIZE
argument_list|,
name|GEM_NSEGS
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
operator|&
name|sc
operator|->
name|sc_dmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail_0
goto|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gem_control_data
argument_list|)
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gem_control_data
argument_list|)
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail_1
goto|;
comment|/* 	 * Allocate the control data structures, and create and load the 	 * DMA map for it. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_control_data
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_cddmamap
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to allocate control data,"
literal|" error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_2
goto|;
block|}
name|sc
operator|->
name|sc_cddma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|,
name|sc
operator|->
name|sc_control_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gem_control_data
argument_list|)
argument_list|,
name|gem_cddma_callback
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|||
name|sc
operator|->
name|sc_cddma
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to load control data DMA "
literal|"map, error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_3
goto|;
block|}
comment|/* 	 * Initialize the transmit job descriptors. 	 */
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
expr_stmt|;
comment|/* 	 * Create the transmit buffer DMA maps. 	 */
name|error
operator|=
name|ENOMEM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_TXQUEUELEN
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|gem_txsoft
modifier|*
name|txs
decl_stmt|;
name|txs
operator|=
operator|&
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
name|NULL
expr_stmt|;
name|txs
operator|->
name|txs_ndescs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
literal|0
argument_list|,
operator|&
name|txs
operator|->
name|txs_dmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create tx DMA map "
literal|"%d, error = %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_4
goto|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create the receive buffer DMA maps. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_dmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create rx DMA map "
literal|"%d, error = %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_5
goto|;
block|}
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|gem_mifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_miibus
argument_list|,
name|gem_mediachange
argument_list|,
name|gem_mediastatus
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"phy probe failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_5
goto|;
block|}
name|sc
operator|->
name|sc_mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
comment|/* 	 * From this point forward, the attachment cannot fail.  A failure 	 * before this point releases all resources that may have been 	 * allocated. 	 */
comment|/* Announce ourselves. */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Ethernet address:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%c%02x"
argument_list|,
name|i
operator|>
literal|0
condition|?
literal|':'
else|:
literal|' '
argument_list|,
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Initialize ifnet structure. */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"gem"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|gem_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|gem_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|gem_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|gem_init
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|GEM_TXQUEUELEN
expr_stmt|;
comment|/* 	 * Walk along the list of attached MII devices and 	 * establish an `MII instance' to `phy number' 	 * mapping. We'll use this mapping in media change 	 * requests to determine which phy to use to program 	 * the MIF configuration register. 	 */
for|for
control|(
name|child
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii
operator|->
name|mii_phys
argument_list|)
init|;
name|child
operator|!=
name|NULL
condition|;
name|child
operator|=
name|LIST_NEXT
argument_list|(
name|child
argument_list|,
name|mii_list
argument_list|)
control|)
block|{
comment|/* 		 * Note: we support just two PHYs: the built-in 		 * internal device and an external on the MII 		 * connector. 		 */
if|if
condition|(
name|child
operator|->
name|mii_phy
operator|>
literal|1
operator|||
name|child
operator|->
name|mii_inst
operator|>
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot accomodate "
literal|"MII device %s at phy %d, instance %d\n"
argument_list|,
name|device_get_name
argument_list|(
name|child
operator|->
name|mii_dev
argument_list|)
argument_list|,
name|child
operator|->
name|mii_phy
argument_list|,
name|child
operator|->
name|mii_inst
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|sc_phys
index|[
name|child
operator|->
name|mii_inst
index|]
operator|=
name|child
operator|->
name|mii_phy
expr_stmt|;
block|}
comment|/* 	 * Now select and activate the PHY we will use. 	 * 	 * The order of preference is External (MDI1), 	 * Internal (MDI0), Serial Link (no MII). 	 */
if|if
condition|(
name|sc
operator|->
name|sc_phys
index|[
literal|1
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|printf
argument_list|(
literal|"using external phy\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_mif_config
operator||=
name|GEM_MIF_CONFIG_PHY_SEL
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|printf
argument_list|(
literal|"using internal phy\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_mif_config
operator|&=
operator|~
name|GEM_MIF_CONFIG_PHY_SEL
expr_stmt|;
block|}
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_MIF_CONFIG
argument_list|,
name|sc
operator|->
name|sc_mif_config
argument_list|)
expr_stmt|;
comment|/* Attach the interface. */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
if|#
directive|if
name|notyet
comment|/* 	 * Add a suspend hook to make sure we come back up after a 	 * resume. 	 */
name|sc
operator|->
name|sc_powerhook
operator|=
name|powerhook_establish
argument_list|(
name|gem_power
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_powerhook
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"WARNING: unable to establish power "
literal|"hook\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Free any resources we've allocated during the failed attach 	 * attempt.  Do this in reverse order and fall through. 	 */
name|fail_5
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_dmamap
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
operator|.
name|rxs_dmamap
argument_list|)
expr_stmt|;
block|}
name|fail_4
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_TXQUEUELEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
operator|.
name|txs_dmamap
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
operator|.
name|txs_dmamap
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|)
expr_stmt|;
name|fail_3
label|:
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_control_data
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|)
expr_stmt|;
name|fail_2
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|)
expr_stmt|;
name|fail_1
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|)
expr_stmt|;
name|fail_0
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_cddma_callback
parameter_list|(
name|xsc
parameter_list|,
name|segs
parameter_list|,
name|nsegs
parameter_list|,
name|error
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|gem_softc
operator|*
operator|)
name|xsc
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|nsegs
operator|!=
literal|1
condition|)
block|{
comment|/* can't happen... */
name|panic
argument_list|(
literal|"gem_cddma_callback: bad control buffer segment count"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_cddma
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_rxdma_callback
parameter_list|(
name|xsc
parameter_list|,
name|segs
parameter_list|,
name|nsegs
parameter_list|,
name|error
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
name|struct
name|gem_rxsoft
modifier|*
name|rxs
init|=
operator|(
expr|struct
name|gem_rxsoft
operator|*
operator|)
name|xsc
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|nsegs
operator|!=
literal|1
condition|)
block|{
comment|/* can't happen... */
name|panic
argument_list|(
literal|"gem_rxdma_callback: bad control buffer segment count"
argument_list|)
expr_stmt|;
block|}
name|rxs
operator|->
name|rxs_paddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called multiple times in our version of dmamap_load_mbuf, but should  * be fit for a generic version that only calls it once.  */
end_comment

begin_function
specifier|static
name|void
name|gem_txdma_callback
parameter_list|(
name|xsc
parameter_list|,
name|segs
parameter_list|,
name|nsegs
parameter_list|,
name|error
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
name|struct
name|gem_txdma
modifier|*
name|tx
init|=
operator|(
expr|struct
name|gem_txdma
operator|*
operator|)
name|xsc
decl_stmt|;
name|int
name|seg
decl_stmt|;
name|tx
operator|->
name|txd_error
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|tx
operator|->
name|txd_nsegs
operator|=
name|nsegs
expr_stmt|;
comment|/* 	 * Initialize the transmit descriptors. 	 */
for|for
control|(
name|seg
operator|=
literal|0
init|;
name|seg
operator|<
name|nsegs
condition|;
name|seg
operator|++
operator|,
name|tx
operator|->
name|txd_nexttx
operator|=
name|GEM_NEXTTX
argument_list|(
name|tx
operator|->
name|txd_nexttx
argument_list|)
control|)
block|{
name|uint64_t
name|flags
decl_stmt|;
name|DPRINTF
argument_list|(
name|tx
operator|->
name|txd_sc
argument_list|,
operator|(
literal|"txdma_cb: mapping seg %d (txd %d), len "
literal|"%lx, addr %#lx (%#lx)\n"
operator|,
name|seg
operator|,
name|tx
operator|->
name|txd_nexttx
operator|,
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
operator|,
name|segs
index|[
name|seg
index|]
operator|.
name|ds_addr
operator|,
name|GEM_DMA_WRITE
argument_list|(
name|tx
operator|->
name|txd_sc
argument_list|,
name|segs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_GEM
argument_list|,
literal|"txdma_cb: mapping seg %d (txd %d), len "
literal|"%lx, addr %#lx (%#lx)"
argument_list|,
name|seg
argument_list|,
name|tx
operator|->
name|txd_nexttx
argument_list|,
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
argument_list|,
name|segs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|,
name|GEM_DMA_WRITE
argument_list|(
name|tx
operator|->
name|txd_sc
argument_list|,
name|segs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If this is the first descriptor we're 		 * enqueueing, set the start of packet flag, 		 * and the checksum stuff if we want the hardware 		 * to do it. 		 */
name|tx
operator|->
name|txd_sc
operator|->
name|sc_txdescs
index|[
name|tx
operator|->
name|txd_nexttx
index|]
operator|.
name|gd_addr
operator|=
name|GEM_DMA_WRITE
argument_list|(
name|tx
operator|->
name|txd_sc
argument_list|,
name|segs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|flags
operator|=
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
operator|&
name|GEM_TD_BUFSIZE
expr_stmt|;
if|if
condition|(
operator|(
name|tx
operator|->
name|txd_flags
operator|&
name|GTXD_FIRST
operator|)
operator|!=
literal|0
operator|&&
name|seg
operator|==
literal|0
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"txdma_cb: start of packet at seg %d, "
literal|"tx %d"
argument_list|,
name|seg
argument_list|,
name|tx
operator|->
name|txd_nexttx
argument_list|)
expr_stmt|;
name|flags
operator||=
name|GEM_TD_START_OF_PACKET
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tx
operator|->
name|txd_flags
operator|&
name|GTXD_LAST
operator|)
operator|!=
literal|0
operator|&&
name|seg
operator|==
name|nsegs
operator|-
literal|1
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"txdma_cb: end of packet at seg %d, "
literal|"tx %d"
argument_list|,
name|seg
argument_list|,
name|tx
operator|->
name|txd_nexttx
argument_list|)
expr_stmt|;
name|flags
operator||=
name|GEM_TD_END_OF_PACKET
expr_stmt|;
block|}
name|tx
operator|->
name|txd_sc
operator|->
name|sc_txdescs
index|[
name|tx
operator|->
name|txd_nexttx
index|]
operator|.
name|gd_flags
operator|=
name|GEM_DMA_WRITE
argument_list|(
name|tx
operator|->
name|txd_sc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|tx
operator|->
name|txd_lasttx
operator|=
name|tx
operator|->
name|txd_nexttx
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gem_tick
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|mii_tick
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
name|hz
argument_list|,
name|gem_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gem_bitwait
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|clr
parameter_list|,
name|set
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
name|bus_addr_t
name|r
decl_stmt|;
name|u_int32_t
name|clr
decl_stmt|;
name|u_int32_t
name|set
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|reg
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TRIES
init|;
name|i
operator|--
condition|;
name|DELAY
argument_list|(
literal|100
argument_list|)
control|)
block|{
name|reg
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
name|clr
operator|)
operator|==
literal|0
operator|&&
operator|(
name|r
operator|&
name|set
operator|)
operator|==
name|set
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gem_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"%s: gem_reset\n"
operator|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_reset"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|gem_reset_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|gem_reset_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Do a full reset */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_RX
operator||
name|GEM_RESET_TX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gem_bitwait
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_RX
operator||
name|GEM_RESET_TX
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot reset device\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * gem_rxdrain:  *  *	Drain the receive queue.  */
end_comment

begin_function
specifier|static
name|void
name|gem_rxdrain
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|gem_rxsoft
modifier|*
name|rxs
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
name|rxs
operator|=
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxs
operator|->
name|rxs_mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxs
operator|->
name|rxs_mbuf
argument_list|)
expr_stmt|;
name|rxs
operator|->
name|rxs_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Reset the whole thing.  */
end_comment

begin_function
specifier|static
name|void
name|gem_stop
parameter_list|(
name|ifp
parameter_list|,
name|disable
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|disable
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|gem_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|gem_txsoft
modifier|*
name|txs
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"%s: gem_stop\n"
operator|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_stop"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|)
expr_stmt|;
comment|/* XXX - Should we reset these instead? */
name|gem_disable_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|gem_disable_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Release any queued transmit buffers. 	 */
while|while
condition|(
operator|(
name|txs
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|txs
operator|->
name|txs_ndescs
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|txs
operator|->
name|txs_mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txs
operator|->
name|txs_mbuf
argument_list|)
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|disable
condition|)
name|gem_rxdrain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Mark the interface down and cancel the watchdog timer. 	 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the receiver  */
end_comment

begin_function
name|int
name|gem_reset_rx
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
comment|/* 	 * Resetting while DMA is in progress can cause a bus hang, so we 	 * disable DMA first. 	 */
name|gem_disable_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait till it finishes */
if|if
condition|(
operator|!
name|gem_bitwait
argument_list|(
name|sc
argument_list|,
name|GEM_RX_CONFIG
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot disable read dma\n"
argument_list|)
expr_stmt|;
comment|/* Wait 5ms extra. */
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Finally, reset the ERX */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_RX
argument_list|)
expr_stmt|;
comment|/* Wait till it finishes */
if|if
condition|(
operator|!
name|gem_bitwait
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_TX
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot reset receiver\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset the transmitter  */
end_comment

begin_function
specifier|static
name|int
name|gem_reset_tx
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Resetting while DMA is in progress can cause a bus hang, so we 	 * disable DMA first. 	 */
name|gem_disable_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_TX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait till it finishes */
if|if
condition|(
operator|!
name|gem_bitwait
argument_list|(
name|sc
argument_list|,
name|GEM_TX_CONFIG
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot disable read dma\n"
argument_list|)
expr_stmt|;
comment|/* Wait 5ms extra. */
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Finally, reset the ETX */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_TX
argument_list|)
expr_stmt|;
comment|/* Wait till it finishes */
for|for
control|(
name|i
operator|=
name|TRIES
init|;
name|i
operator|--
condition|;
name|DELAY
argument_list|(
literal|100
argument_list|)
control|)
if|if
condition|(
operator|(
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RESET
argument_list|)
operator|&
name|GEM_RESET_TX
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|gem_bitwait
argument_list|(
name|sc
argument_list|,
name|GEM_RESET
argument_list|,
name|GEM_RESET_TX
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot reset receiver\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * disable receiver.  */
end_comment

begin_function
specifier|static
name|int
name|gem_disable_rx
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|u_int32_t
name|cfg
decl_stmt|;
comment|/* Flip the enable bit */
name|cfg
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
expr_stmt|;
name|cfg
operator|&=
operator|~
name|GEM_MAC_RX_ENABLE
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
comment|/* Wait for it to finish */
return|return
operator|(
name|gem_bitwait
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|GEM_MAC_RX_ENABLE
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * disable transmitter.  */
end_comment

begin_function
specifier|static
name|int
name|gem_disable_tx
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|u_int32_t
name|cfg
decl_stmt|;
comment|/* Flip the enable bit */
name|cfg
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|)
expr_stmt|;
name|cfg
operator|&=
operator|~
name|GEM_MAC_TX_ENABLE
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
comment|/* Wait for it to finish */
return|return
operator|(
name|gem_bitwait
argument_list|(
name|sc
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
name|GEM_MAC_TX_ENABLE
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize interface.  */
end_comment

begin_function
specifier|static
name|int
name|gem_meminit
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|gem_rxsoft
modifier|*
name|rxs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * Initialize the transmit descriptor ring. 	 */
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|sc_txdescs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_txdescs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NTXDESC
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|gd_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|gd_addr
operator|=
literal|0
expr_stmt|;
block|}
name|GEM_CDTXSYNC
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|GEM_NTXDESC
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txfree
operator|=
name|GEM_NTXDESC
expr_stmt|;
name|sc
operator|->
name|sc_txnext
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize the receive descriptor and receive job 	 * descriptor rings. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GEM_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
name|rxs
operator|=
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxs
operator|->
name|rxs_mbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|gem_add_rxbuf
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to "
literal|"allocate or map rx buffer %d, error = "
literal|"%d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 				 * XXX Should attempt to run with fewer receive 				 * XXX buffers instead of just failing. 				 */
name|gem_rxdrain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
name|GEM_INIT_RXDESC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rxptr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gem_ringsize
parameter_list|(
name|sz
parameter_list|)
name|int
name|sz
decl_stmt|;
block|{
name|int
name|v
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|sz
condition|)
block|{
case|case
literal|32
case|:
name|v
operator|=
name|GEM_RING_SZ_32
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|v
operator|=
name|GEM_RING_SZ_64
expr_stmt|;
break|break;
case|case
literal|128
case|:
name|v
operator|=
name|GEM_RING_SZ_128
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|v
operator|=
name|GEM_RING_SZ_256
expr_stmt|;
break|break;
case|case
literal|512
case|:
name|v
operator|=
name|GEM_RING_SZ_512
expr_stmt|;
break|break;
case|case
literal|1024
case|:
name|v
operator|=
name|GEM_RING_SZ_1024
expr_stmt|;
break|break;
case|case
literal|2048
case|:
name|v
operator|=
name|GEM_RING_SZ_2048
expr_stmt|;
break|break;
case|case
literal|4096
case|:
name|v
operator|=
name|GEM_RING_SZ_4096
expr_stmt|;
break|break;
case|case
literal|8192
case|:
name|v
operator|=
name|GEM_RING_SZ_8192
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"gem: invalid Receive Descriptor ring size\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialization of interface; set up initialization block  * and transmit/receive descriptor rings.  */
end_comment

begin_function
specifier|static
name|void
name|gem_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|gem_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"%s: gem_init: calling stop\n"
operator|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_init: calling stop"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialization sequence. The numbered steps below correspond 	 * to the sequence outlined in section 6.3.5.1 in the Ethernet 	 * Channel Engine manual (part of the PCIO manual). 	 * See also the STP2002-STQ document from Sun Microsystems. 	 */
comment|/* step 1& 2. Reset the Ethernet Channel */
name|gem_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gem_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"%s: gem_init: restarting\n"
operator|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_init: restarting"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Re-initialize the MIF */
name|gem_mifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Call MI reset function if any */
if|if
condition|(
name|sc
operator|->
name|sc_hwreset
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_hwreset
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* step 3. Setup data structures in host memory */
name|gem_meminit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* step 4. TX MAC registers& counters */
name|gem_init_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX: VLAN code from NetBSD temporarily removed. */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_MAC_MAX_FRAME
argument_list|,
operator|(
name|ETHER_MAX_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
operator||
operator|(
literal|0x2000
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* step 5. RX MAC registers& counters */
name|gem_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* step 6& 7. Program Descriptor Ring Base Addresses */
comment|/* NOTE: we use only 32-bit DMA addresses here. */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_TX_RING_PTR_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_TX_RING_PTR_LO
argument_list|,
name|GEM_CDTXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_RING_PTR_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_RING_PTR_LO
argument_list|,
name|GEM_CDRXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"loading rx ring %lx, tx ring %lx, cddma %lx\n"
operator|,
name|GEM_CDRXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|,
name|GEM_CDTXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|,
name|sc
operator|->
name|sc_cddma
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"loading rx ring %lx, tx ring %lx, cddma %lx"
argument_list|,
name|GEM_CDRXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEM_CDTXADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_cddma
argument_list|)
expr_stmt|;
comment|/* step 8. Global Configuration& Interrupt Mask */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_INTMASK
argument_list|,
operator|~
operator|(
name|GEM_INTR_TX_INTME
operator||
name|GEM_INTR_TX_EMPTY
operator||
name|GEM_INTR_RX_DONE
operator||
name|GEM_INTR_RX_NOBUF
operator||
name|GEM_INTR_RX_TAG_ERR
operator||
name|GEM_INTR_PCS
operator||
name|GEM_INTR_MAC_CONTROL
operator||
name|GEM_INTR_MIF
operator||
name|GEM_INTR_BERR
operator|)
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXXX */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_TX_MASK
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* XXXX */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_CONTROL_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXXX */
comment|/* step 9. ETX Configuration: use mostly default values */
comment|/* Enable DMA */
name|v
operator|=
name|gem_ringsize
argument_list|(
name|GEM_NTXDESC
comment|/*XXX*/
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_TX_CONFIG
argument_list|,
name|v
operator||
name|GEM_TX_CONFIG_TXDMA_EN
operator||
operator|(
operator|(
literal|0x400
operator|<<
literal|10
operator|)
operator|&
name|GEM_TX_CONFIG_TXFIFO_TH
operator|)
argument_list|)
expr_stmt|;
comment|/* step 10. ERX Configuration */
comment|/* Encode Receive Descriptor ring size: four possible values */
name|v
operator|=
name|gem_ringsize
argument_list|(
name|GEM_NRXDESC
comment|/*XXX*/
argument_list|)
expr_stmt|;
comment|/* Enable DMA */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_CONFIG
argument_list|,
name|v
operator||
operator|(
name|GEM_THRSH_1024
operator|<<
name|GEM_RX_CONFIG_FIFO_THRS_SHIFT
operator|)
operator||
operator|(
literal|2
operator|<<
name|GEM_RX_CONFIG_FBOFF_SHFT
operator|)
operator||
name|GEM_RX_CONFIG_RXDMA_EN
operator||
operator|(
literal|0
operator|<<
name|GEM_RX_CONFIG_CXM_START_SHFT
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * The following value is for an OFF Threshold of about 15.5 Kbytes 	 * and an ON Threshold of 4K bytes. 	 */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_PAUSE_THRESH
argument_list|,
literal|0xf8
operator||
operator|(
literal|0x40
operator|<<
literal|12
operator|)
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_BLANKING
argument_list|,
operator|(
literal|2
operator|<<
literal|12
operator|)
operator||
literal|6
argument_list|)
expr_stmt|;
comment|/* step 11. Configure Media */
operator|(
name|void
operator|)
name|gem_mii_statchg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
comment|/* step 12. RX_MAC Configuration Register */
name|v
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
expr_stmt|;
name|v
operator||=
name|GEM_MAC_RX_ENABLE
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* step 14. Issue Transmit Pending command */
comment|/* Call MI initialization function if any */
if|if
condition|(
name|sc
operator|->
name|sc_hwinit
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_hwinit
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* step 15.  Give the reciever a swift kick */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_KICK
argument_list|,
name|GEM_NRXDESC
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|/* Start the one second timer. */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
name|hz
argument_list|,
name|gem_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX: This is really a substitute for bus_dmamap_load_mbuf(), which FreeBSD  * does not yet have, with some adaptions for this driver.  * Some changes are mandated by the fact that multiple maps may needed to map  * a single mbuf.  * It should be removed once generic support is available.  *  * This is derived from NetBSD (syssrc/sys/arch/sparc64/sparc64/machdep.c), for  * a copyright notice see sparc64/sparc64/bus_machdep.c.  *  * Not every error condition is passed to the callback in this version, and the  * callback may be called more than once.  * It also gropes in the entails of the callback arg...  */
end_comment

begin_function
specifier|static
name|int
name|gem_dmamap_load_mbuf
parameter_list|(
name|sc
parameter_list|,
name|m0
parameter_list|,
name|cb
parameter_list|,
name|txj
parameter_list|,
name|flags
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|bus_dmamap_callback_t
modifier|*
name|cb
decl_stmt|;
name|struct
name|gem_txjob
modifier|*
name|txj
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|gem_txdma
name|txd
decl_stmt|;
name|struct
name|gem_txsoft
modifier|*
name|txs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|void
modifier|*
name|vaddr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|first
init|=
literal|1
decl_stmt|,
name|len
decl_stmt|,
name|totlen
decl_stmt|;
if|if
condition|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"gem_dmamap_load_mbuf: no packet header"
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|txd
operator|.
name|txd_sc
operator|=
name|sc
expr_stmt|;
name|txd
operator|.
name|txd_nexttx
operator|=
name|txj
operator|->
name|txj_nexttx
expr_stmt|;
name|txj
operator|->
name|txj_nsegs
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|txj
operator|->
name|txj_txsq
argument_list|)
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|len
operator|<
name|totlen
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
continue|continue;
comment|/* Get a work queue entry. */
if|if
condition|(
operator|(
name|txs
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Ran out of descriptors, return a value that 			 * cannot be returned by bus_dmamap_load to notify 			 * the caller. 			 */
name|error
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|txd
operator|.
name|txd_flags
operator|=
name|first
condition|?
name|GTXD_FIRST
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
name|NULL
operator|||
name|len
operator|>=
name|totlen
condition|)
name|txd
operator|.
name|txd_flags
operator||=
name|GTXD_LAST
expr_stmt|;
name|vaddr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
name|vaddr
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|cb
argument_list|,
operator|&
name|txd
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|txd
operator|.
name|txd_error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Sync the DMA map. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
comment|/* 		 * Store a pointer to the packet so we can free it later, 		 * and remember what txdirty will be once the packet is 		 * done. 		 */
name|txs
operator|->
name|txs_mbuf
operator|=
name|first
condition|?
name|m0
else|:
name|NULL
expr_stmt|;
name|txs
operator|->
name|txs_firstdesc
operator|=
name|txj
operator|->
name|txj_nexttx
expr_stmt|;
name|txs
operator|->
name|txs_lastdesc
operator|=
name|txd
operator|.
name|txd_lasttx
expr_stmt|;
name|txs
operator|->
name|txs_ndescs
operator|=
name|txd
operator|.
name|txd_nsegs
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"load_mbuf: setting firstdesc=%d, lastdesc=%d, "
literal|"ndescs=%d"
argument_list|,
name|txs
operator|->
name|txs_firstdesc
argument_list|,
name|txs
operator|->
name|txs_lastdesc
argument_list|,
name|txs
operator|->
name|txs_ndescs
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|txj
operator|->
name|txj_txsq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|txj
operator|->
name|txj_nexttx
operator|=
name|txd
operator|.
name|txd_nexttx
expr_stmt|;
name|txj
operator|->
name|txj_nsegs
operator|+=
name|txd
operator|.
name|txd_nsegs
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|txj
operator|->
name|txj_lasttx
operator|=
name|txd
operator|.
name|txd_lasttx
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_dmamap_load_mbuf failed (%d)"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|gem_dmamap_unload_mbuf
argument_list|(
name|sc
argument_list|,
name|txj
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unload an mbuf using the txd the information was placed in.  * The tx interrupt code frees the tx segments one by one, because the txd is  * not available any more.  */
end_comment

begin_function
specifier|static
name|void
name|gem_dmamap_unload_mbuf
parameter_list|(
name|sc
parameter_list|,
name|txj
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|gem_txjob
modifier|*
name|txj
decl_stmt|;
block|{
name|struct
name|gem_txsoft
modifier|*
name|txs
decl_stmt|;
comment|/* Readd the removed descriptors and unload the segments. */
while|while
condition|(
operator|(
name|txs
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txj
operator|->
name|txj_txsq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|txj
operator|->
name|txj_txsq
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gem_dmamap_commit_mbuf
parameter_list|(
name|sc
parameter_list|,
name|txj
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|gem_txjob
modifier|*
name|txj
decl_stmt|;
block|{
name|struct
name|gem_txsoft
modifier|*
name|txs
decl_stmt|;
comment|/* Commit the txjob by transfering the txsoft's to the txdirtyq. */
while|while
condition|(
operator|(
name|txs
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txj
operator|->
name|txj_txsq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|txj
operator|->
name|txj_txsq
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gem_init_regs
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
comment|/* These regs are not cleared on reset */
name|sc
operator|->
name|sc_inited
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_inited
condition|)
block|{
comment|/* Wooo.  Magic values. */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_IPG0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_IPG1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_IPG2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_MAC_MIN_FRAME
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
comment|/* Max frame and max burst size */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_MAC_MAX_FRAME
argument_list|,
operator|(
name|ifp
operator|->
name|if_mtu
operator|+
literal|18
operator|)
operator||
operator|(
literal|0x2000
operator|<<
literal|16
operator|)
comment|/* Burst size */
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_PREAMBLE_LEN
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_JAM_SIZE
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ATTEMPT_LIMIT
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Dunno.... */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_CONTROL_TYPE
argument_list|,
literal|0x8088
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RANDOM_SEED
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_enaddr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_enaddr
index|[
literal|4
index|]
operator|)
operator|&
literal|0x3ff
argument_list|)
expr_stmt|;
comment|/* Secondary MAC addr set to 0:0:0:0:0:0 */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* MAC control addr set to 0:1:c2:0:1:80 */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR6
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR7
argument_list|,
literal|0xc200
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR8
argument_list|,
literal|0x0180
argument_list|)
expr_stmt|;
comment|/* MAC filter addr set to 0:0:0:0:0:0 */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR_FILTER0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR_FILTER1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR_FILTER2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADR_FLT_MASK1_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADR_FLT_MASK0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_inited
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Counters need to be zeroed */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_NORM_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_FIRST_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_EXCESS_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_LATE_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_DEFER_TMR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_PEAK_ATTEMPTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_FRAME_COUNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_LEN_ERR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_ALIGN_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CRC_ERR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CODE_VIOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Un-pause stuff */
if|#
directive|if
literal|0
block|bus_space_write_4(t, h, GEM_MAC_SEND_PAUSE_CMD, 0x1BF0);
else|#
directive|else
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_SEND_PAUSE_CMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set the station address. 	 */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR0
argument_list|,
operator|(
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_enaddr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_enaddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR1
argument_list|,
operator|(
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_enaddr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_enaddr
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_ADDR2
argument_list|,
operator|(
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_enaddr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_enaddr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|gem_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|gem_txjob
name|txj
decl_stmt|;
name|int
name|firsttx
decl_stmt|,
name|ofree
decl_stmt|,
name|seg
decl_stmt|,
name|ntx
decl_stmt|,
name|txmfail
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_RUNNING
condition|)
return|return;
comment|/* 	 * Remember the previous number of free descriptors and 	 * the first descriptor we'll use. 	 */
name|ofree
operator|=
name|sc
operator|->
name|sc_txfree
expr_stmt|;
name|firsttx
operator|=
name|sc
operator|->
name|sc_txnext
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"%s: gem_start: txfree %d, txnext %d\n"
operator|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|ofree
operator|,
name|firsttx
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_start: txfree %d, txnext %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|ofree
argument_list|,
name|firsttx
argument_list|)
expr_stmt|;
name|txj
operator|.
name|txj_nexttx
operator|=
name|firsttx
expr_stmt|;
name|txj
operator|.
name|txj_lasttx
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Loop through the send queue, setting up transmit descriptors 	 * until we drain the queue, or use up all available transmit 	 * descriptors. 	 */
name|txmfail
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ntx
operator|=
literal|0
init|;
condition|;
name|ntx
operator|++
control|)
block|{
comment|/* 		 * Grab a packet off the queue. 		 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
break|break;
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Load the DMA map.  If this fails, the packet either 		 * didn't fit in the alloted number of segments, or we were 		 * short on resources.  In this case, we'll copy and try 		 * again. 		 */
name|txmfail
operator|=
name|gem_dmamap_load_mbuf
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|,
name|gem_txdma_callback
argument_list|,
operator|&
name|txj
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|txmfail
operator|==
operator|-
literal|1
condition|)
block|{
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|txmfail
operator|>
literal|0
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to "
literal|"allocate Tx mbuf\n"
argument_list|)
expr_stmt|;
comment|/* Failed; requeue. */
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to "
literal|"allocate Tx cluster\n"
argument_list|)
expr_stmt|;
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|txmfail
operator|=
name|gem_dmamap_load_mbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|gem_txdma_callback
argument_list|,
operator|&
name|txj
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|txmfail
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|txmfail
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to "
literal|"load Tx buffer, error = %d\n"
argument_list|,
name|txmfail
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Ensure we have enough descriptors free to describe 		 * the packet.  Note, we always reserve one descriptor 		 * at the end of the ring as a termination point, to 		 * prevent wrap-around. 		 */
if|if
condition|(
name|txj
operator|.
name|txj_nsegs
operator|>
operator|(
name|sc
operator|->
name|sc_txfree
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* 			 * Not enough free descriptors to transmit this 			 * packet.  We haven't committed to anything yet, 			 * so just unload the DMA map, put the packet 			 * back on the queue, and punt.  Notify the upper 			 * layer that there are no more slots left. 			 * 			 * XXX We could allocate an mbuf and copy, but 			 * XXX it is worth it? 			 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|gem_dmamap_unload_mbuf
argument_list|(
name|sc
argument_list|,
operator|&
name|txj
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* 		 * WE ARE NOW COMMITTED TO TRANSMITTING THE PACKET. 		 */
ifdef|#
directive|ifdef
name|GEM_DEBUG
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"     gem_start %p transmit chain:\n"
argument_list|,
name|STAILQ_FIRST
argument_list|(
operator|&
name|txj
operator|.
name|txj_txsq
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|seg
operator|=
name|sc
operator|->
name|sc_txnext
init|;
condition|;
name|seg
operator|=
name|GEM_NEXTTX
argument_list|(
name|seg
argument_list|)
control|)
block|{
name|printf
argument_list|(
literal|"descriptor %d:\t"
argument_list|,
name|seg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gd_flags:   0x%016llx\t"
argument_list|,
operator|(
name|long
name|long
operator|)
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txdescs
index|[
name|seg
index|]
operator|.
name|gd_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gd_addr: 0x%016llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txdescs
index|[
name|seg
index|]
operator|.
name|gd_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|txj
operator|.
name|txj_lasttx
condition|)
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* Sync the descriptors we're using. */
name|GEM_CDTXSYNC
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txnext
argument_list|,
name|txj
operator|.
name|txj_nsegs
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Advance the tx pointer. */
name|sc
operator|->
name|sc_txfree
operator|-=
name|txj
operator|.
name|txj_nsegs
expr_stmt|;
name|sc
operator|->
name|sc_txnext
operator|=
name|txj
operator|.
name|txj_nexttx
expr_stmt|;
name|gem_dmamap_commit_mbuf
argument_list|(
name|sc
argument_list|,
operator|&
name|txj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|txmfail
operator|==
operator|-
literal|1
operator|||
name|sc
operator|->
name|sc_txfree
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
comment|/* No more slots left; notify upper layer. */
block|}
if|if
condition|(
name|ntx
operator|>
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"%s: packets enqueued, IC on %d, OWN on %d\n"
operator|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|txj
operator|.
name|txj_lasttx
operator|,
name|firsttx
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: packets enqueued, IC on %d, OWN on %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|txj
operator|.
name|txj_lasttx
argument_list|,
name|firsttx
argument_list|)
expr_stmt|;
comment|/* 		 * The entire packet chain is set up. 		 * Kick the transmitter. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"%s: gem_start: kicking tx %d\n"
operator|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|txj
operator|.
name|txj_nexttx
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_start: kicking tx %d=%d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|txj
operator|.
name|txj_nexttx
argument_list|,
name|sc
operator|->
name|sc_txnext
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_KICK
argument_list|,
name|sc
operator|->
name|sc_txnext
argument_list|)
expr_stmt|;
comment|/* Set a watchdog timer in case the chip flakes out. */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"%s: gem_start: watchdog %d\n"
operator|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|ifp
operator|->
name|if_timer
operator|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_start: watchdog %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_timer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Transmit interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|gem_tint
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|mac
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|struct
name|gem_txsoft
modifier|*
name|txs
decl_stmt|;
name|int
name|txlast
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"%s: gem_tint\n"
operator|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_tint"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Unload collision counters 	 */
name|ifp
operator|->
name|if_collisions
operator|+=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_NORM_COLL_CNT
argument_list|)
operator|+
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_FIRST_COLL_CNT
argument_list|)
operator|+
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_EXCESS_COLL_CNT
argument_list|)
operator|+
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_LATE_COLL_CNT
argument_list|)
expr_stmt|;
comment|/* 	 * then clear the hardware counters. 	 */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_NORM_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_FIRST_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_EXCESS_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_LATE_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Go through our Tx list and free mbufs for those 	 * frames that have been transmitted. 	 */
while|while
condition|(
operator|(
name|txs
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|GEM_CDTXSYNC
argument_list|(
name|sc
argument_list|,
name|txs
operator|->
name|txs_lastdesc
argument_list|,
name|txs
operator|->
name|txs_ndescs
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"    txsoft %p transmit chain:\n"
argument_list|,
name|txs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|txs
operator|->
name|txs_firstdesc
init|;
condition|;
name|i
operator|=
name|GEM_NEXTTX
argument_list|(
name|i
argument_list|)
control|)
block|{
name|printf
argument_list|(
literal|"descriptor %d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gd_flags: 0x%016llx\t"
argument_list|,
operator|(
name|long
name|long
operator|)
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|gd_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gd_addr: 0x%016llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|gd_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|txs
operator|->
name|txs_lastdesc
condition|)
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * In theory, we could harveast some descriptors before 		 * the ring is empty, but that's a bit complicated. 		 * 		 * GEM_TX_COMPLETION points to the last descriptor 		 * processed +1. 		 */
name|txlast
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_TX_COMPLETION
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"gem_tint: txs->txs_lastdesc = %d, txlast = %d\n"
operator|,
name|txs
operator|->
name|txs_lastdesc
operator|,
name|txlast
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_tint: txs->txs_firstdesc = %d, "
literal|"txs->txs_lastdesc = %d, txlast = %d"
argument_list|,
name|txs
operator|->
name|txs_firstdesc
argument_list|,
name|txs
operator|->
name|txs_lastdesc
argument_list|,
name|txlast
argument_list|)
expr_stmt|;
if|if
condition|(
name|txs
operator|->
name|txs_firstdesc
operator|<=
name|txs
operator|->
name|txs_lastdesc
condition|)
block|{
if|if
condition|(
operator|(
name|txlast
operator|>=
name|txs
operator|->
name|txs_firstdesc
operator|)
operator|&&
operator|(
name|txlast
operator|<=
name|txs
operator|->
name|txs_lastdesc
operator|)
condition|)
break|break;
block|}
else|else
block|{
comment|/* Ick -- this command wraps */
if|if
condition|(
operator|(
name|txlast
operator|>=
name|txs
operator|->
name|txs_firstdesc
operator|)
operator|||
operator|(
name|txlast
operator|<=
name|txs
operator|->
name|txs_lastdesc
operator|)
condition|)
break|break;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"gem_tint: releasing a desc\n"
operator|)
argument_list|)
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_tint: releasing a desc"
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txfree
operator|+=
name|txs
operator|->
name|txs_ndescs
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|txs
operator|->
name|txs_mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txs
operator|->
name|txs_mbuf
argument_list|)
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"gem_tint: GEM_TX_STATE_MACHINE %x "
literal|"GEM_TX_DATA_PTR %llx "
literal|"GEM_TX_COMPLETION %x\n"
operator|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_STATE_MACHINE
argument_list|)
operator|,
operator|(
operator|(
name|long
name|long
operator|)
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_DATA_PTR_HI
argument_list|)
operator|<<
literal|32
operator|)
operator||
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_DATA_PTR_LO
argument_list|)
operator|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_COMPLETION
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_tint: GEM_TX_STATE_MACHINE %x "
literal|"GEM_TX_DATA_PTR %llx "
literal|"GEM_TX_COMPLETION %x"
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_STATE_MACHINE
argument_list|)
argument_list|,
operator|(
operator|(
name|long
name|long
operator|)
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_DATA_PTR_HI
argument_list|)
operator|<<
literal|32
operator|)
operator||
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_DATA_PTR_LO
argument_list|)
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_COMPLETION
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
operator|==
name|NULL
condition|)
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"%s: gem_tint: watchdog %d\n"
operator|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|ifp
operator|->
name|if_timer
operator|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_tint: watchdog %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_timer
argument_list|)
expr_stmt|;
comment|/* Freed some descriptors, so reset IFF_OACTIVE and restart. */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|gem_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_rint_timeout
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|gem_rint
argument_list|(
operator|(
expr|struct
name|gem_softc
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Receive interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|gem_rint
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|gem_rxsoft
modifier|*
name|rxs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int64_t
name|rxstat
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"%s: gem_rint\n"
operator|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_rint"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXXX Read the lastrx only once at the top for speed. 	 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"gem_rint: sc->rxptr %d, complete %d\n"
operator|,
name|sc
operator|->
name|sc_rxptr
operator|,
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_COMPLETION
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_rint: sc->rxptr %d, complete %d"
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|,
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_COMPLETION
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|sc_rxptr
init|;
name|i
operator|!=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_COMPLETION
argument_list|)
condition|;
name|i
operator|=
name|GEM_NEXTRX
argument_list|(
name|i
argument_list|)
control|)
block|{
name|rxs
operator|=
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|i
index|]
expr_stmt|;
name|GEM_CDRXSYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|rxstat
operator|=
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxdescs
index|[
name|i
index|]
operator|.
name|gd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxstat
operator|&
name|GEM_RD_OWN
condition|)
block|{
comment|/* 			 * The descriptor is still marked as owned, although 			 * it is supposed to have completed. This has been 			 * observed on some machines. Just exiting here 			 * might leave the packet sitting around until another 			 * one arrives to trigger a new interrupt, which is 			 * generally undesirable, so set up a timeout. 			 */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|,
name|GEM_RXOWN_TICKS
argument_list|,
name|gem_rint_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rxstat
operator|&
name|GEM_RD_BAD_CRC
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"receive error: CRC error\n"
argument_list|)
expr_stmt|;
name|GEM_INIT_RXDESC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"    rxsoft %p descriptor %d: "
argument_list|,
name|rxs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gd_flags: 0x%016llx\t"
argument_list|,
operator|(
name|long
name|long
operator|)
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxdescs
index|[
name|i
index|]
operator|.
name|gd_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gd_addr: 0x%016llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|GEM_DMA_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxdescs
index|[
name|i
index|]
operator|.
name|gd_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * No errors; receive the packet.  Note the Gem 		 * includes the CRC with every packet. 		 */
name|len
operator|=
name|GEM_RD_BUFLEN
argument_list|(
name|rxstat
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate a new mbuf cluster.  If that fails, we are 		 * out of memory, and must drop the packet and recycle 		 * the buffer that's already attached to this descriptor. 		 */
name|m
operator|=
name|rxs
operator|->
name|rxs_mbuf
expr_stmt|;
if|if
condition|(
name|gem_add_rxbuf
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|GEM_INIT_RXDESC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m
operator|->
name|m_data
operator|+=
literal|2
expr_stmt|;
comment|/* We're already off by two */
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pass it on. */
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Update the receive pointer. */
name|sc
operator|->
name|sc_rxptr
operator|=
name|i
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_KICK
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"gem_rint: done sc->rxptr %d, complete %d\n"
operator|,
name|sc
operator|->
name|sc_rxptr
operator|,
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_COMPLETION
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_rint: done sc->rxptr %d, complete %d"
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|,
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_RX_COMPLETION
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * gem_add_rxbuf:  *  *	Add a receive buffer to the indicated descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|gem_add_rxbuf
parameter_list|(
name|sc
parameter_list|,
name|idx
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|idx
decl_stmt|;
block|{
name|struct
name|gem_rxsoft
modifier|*
name|rxs
init|=
operator|&
name|sc
operator|->
name|sc_rxsoft
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|GEM_DEBUG
comment|/* bzero the packet to check dma */
name|memset
argument_list|(
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_ext
operator|.
name|ext_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rxs
operator|->
name|rxs_mbuf
operator|!=
name|NULL
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|)
expr_stmt|;
name|rxs
operator|->
name|rxs_mbuf
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|,
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|,
name|m
operator|->
name|m_ext
operator|.
name|ext_size
argument_list|,
name|gem_rxdma_callback
argument_list|,
name|rxs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|rxs
operator|->
name|rxs_paddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't load rx DMA map %d, error = "
literal|"%d\n"
argument_list|,
name|idx
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"gem_add_rxbuf"
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|rxs
operator|->
name|rxs_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|GEM_INIT_RXDESC
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gem_eint
parameter_list|(
name|sc
parameter_list|,
name|status
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|status
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|status
operator|&
name|GEM_INTR_MIF
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"XXXlink status changed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"status=%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gem_intr
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|gem_softc
operator|*
operator|)
name|v
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|seb
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|status
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|seb
argument_list|,
name|GEM_STATUS
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"%s: gem_intr: cplt %x, status %x\n"
operator|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
operator|(
name|status
operator|>>
literal|19
operator|)
operator|,
operator|(
name|u_int
operator|)
name|status
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"%s: gem_intr: cplt %x, status %x"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
operator|(
name|status
operator|>>
literal|19
operator|)
argument_list|,
operator|(
name|u_int
operator|)
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|GEM_INTR_RX_TAG_ERR
operator||
name|GEM_INTR_BERR
operator|)
operator|)
operator|!=
literal|0
condition|)
name|gem_eint
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|GEM_INTR_TX_EMPTY
operator||
name|GEM_INTR_TX_INTME
operator|)
operator|)
operator|!=
literal|0
condition|)
name|gem_tint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|GEM_INTR_RX_DONE
operator||
name|GEM_INTR_RX_NOBUF
operator|)
operator|)
operator|!=
literal|0
condition|)
name|gem_rint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* We should eventually do more than just print out error stats. */
if|if
condition|(
name|status
operator|&
name|GEM_INTR_TX_MAC
condition|)
block|{
name|int
name|txstat
init|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|seb
argument_list|,
name|GEM_MAC_TX_STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|txstat
operator|&
operator|~
name|GEM_MAC_TX_XMIT_DONE
condition|)
name|printf
argument_list|(
literal|"MAC tx fault, status %x\n"
argument_list|,
name|txstat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|GEM_INTR_RX_MAC
condition|)
block|{
name|int
name|rxstat
init|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|seb
argument_list|,
name|GEM_MAC_RX_STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|rxstat
operator|&
operator|~
operator|(
name|GEM_MAC_RX_DONE
operator||
name|GEM_MAC_RX_FRAME_CNT
operator|)
condition|)
name|printf
argument_list|(
literal|"MAC rx fault, status %x\n"
argument_list|,
name|rxstat
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gem_watchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
operator|(
literal|"gem_watchdog: GEM_RX_CONFIG %x GEM_MAC_RX_STATUS %x "
literal|"GEM_MAC_RX_CONFIG %x\n"
operator|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_RX_CONFIG
argument_list|)
operator|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_MAC_RX_STATUS
argument_list|)
operator|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_watchdog: GEM_RX_CONFIG %x GEM_MAC_RX_STATUS %x "
literal|"GEM_MAC_RX_CONFIG %x"
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_RX_CONFIG
argument_list|)
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_MAC_RX_STATUS
argument_list|)
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_GEM
argument_list|,
literal|"gem_watchdog: GEM_TX_CONFIG %x GEM_MAC_TX_STATUS %x "
literal|"GEM_MAC_TX_CONFIG %x"
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_TX_CONFIG
argument_list|)
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_MAC_TX_STATUS
argument_list|)
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bustag
argument_list|,
name|sc
operator|->
name|sc_h
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
operator|++
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
comment|/* Try to get more packets going. */
name|gem_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the MII Management Interface  */
end_comment

begin_function
specifier|static
name|void
name|gem_mifinit
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|mif
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
comment|/* Configure the MIF in frame mode */
name|sc
operator|->
name|sc_mif_config
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mif
argument_list|,
name|GEM_MIF_CONFIG
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mif_config
operator|&=
operator|~
name|GEM_MIF_CONFIG_BB_ENA
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mif
argument_list|,
name|GEM_MIF_CONFIG
argument_list|,
name|sc
operator|->
name|sc_mif_config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MII interface  *  * The GEM MII interface supports at least three different operating modes:  *  * Bitbang mode is implemented using data, clock and output enable registers.  *  * Frame mode is implemented by loading a complete frame into the frame  * register and polling the valid bit for completion.  *  * Polling mode uses the frame register but completion is indicated by  * an interrupt.  *  */
end_comment

begin_function
name|int
name|gem_mii_readreg
parameter_list|(
name|dev
parameter_list|,
name|phy
parameter_list|,
name|reg
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|phy
decl_stmt|,
name|reg
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|mif
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG_PHY
name|printf
argument_list|(
literal|"gem_mii_readreg: phy %d reg %d\n"
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Select the desired PHY in the MIF configuration register */
block|v = bus_space_read_4(t, mif, GEM_MIF_CONFIG);
comment|/* Clear PHY select bit */
block|v&= ~GEM_MIF_CONFIG_PHY_SEL; 	if (phy == GEM_PHYAD_EXTERNAL)
comment|/* Set PHY select bit to get at external device */
block|v |= GEM_MIF_CONFIG_PHY_SEL; 	bus_space_write_4(t, mif, GEM_MIF_CONFIG, v);
endif|#
directive|endif
comment|/* Construct the frame command */
name|v
operator|=
operator|(
name|reg
operator|<<
name|GEM_MIF_REG_SHIFT
operator|)
operator||
operator|(
name|phy
operator|<<
name|GEM_MIF_PHY_SHIFT
operator|)
operator||
name|GEM_MIF_FRAME_READ
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mif
argument_list|,
name|GEM_MIF_FRAME
argument_list|,
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|100
condition|;
name|n
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mif
argument_list|,
name|GEM_MIF_FRAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|GEM_MIF_FRAME_TA0
condition|)
return|return
operator|(
name|v
operator|&
name|GEM_MIF_FRAME_DATA
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"mii_read timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gem_mii_writereg
parameter_list|(
name|dev
parameter_list|,
name|phy
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|phy
decl_stmt|,
name|reg
decl_stmt|,
name|val
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|mif
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG_PHY
name|printf
argument_list|(
literal|"gem_mii_writereg: phy %d reg %d val %x\n"
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Select the desired PHY in the MIF configuration register */
block|v = bus_space_read_4(t, mif, GEM_MIF_CONFIG);
comment|/* Clear PHY select bit */
block|v&= ~GEM_MIF_CONFIG_PHY_SEL; 	if (phy == GEM_PHYAD_EXTERNAL)
comment|/* Set PHY select bit to get at external device */
block|v |= GEM_MIF_CONFIG_PHY_SEL; 	bus_space_write_4(t, mif, GEM_MIF_CONFIG, v);
endif|#
directive|endif
comment|/* Construct the frame command */
name|v
operator|=
name|GEM_MIF_FRAME_WRITE
operator||
operator|(
name|phy
operator|<<
name|GEM_MIF_PHY_SHIFT
operator|)
operator||
operator|(
name|reg
operator|<<
name|GEM_MIF_REG_SHIFT
operator|)
operator||
operator|(
name|val
operator|&
name|GEM_MIF_FRAME_DATA
operator|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mif
argument_list|,
name|GEM_MIF_FRAME
argument_list|,
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|100
condition|;
name|n
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mif
argument_list|,
name|GEM_MIF_FRAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|GEM_MIF_FRAME_TA0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"mii_write timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gem_mii_statchg
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
name|int
name|instance
init|=
name|IFM_INST
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|mac
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|GEM_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
condition|)
name|printf
argument_list|(
literal|"gem_mii_statchg: status change: phy = %d\n"
argument_list|,
name|sc
operator|->
name|sc_phys
index|[
name|instance
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set tx full duplex options */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* reg must be cleared and delay before changing. */
name|v
operator|=
name|GEM_MAC_TX_ENA_IPG0
operator||
name|GEM_MAC_TX_NGU
operator||
name|GEM_MAC_TX_NGU_LIMIT
operator||
name|GEM_MAC_TX_ENABLE
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
block|{
name|v
operator||=
name|GEM_MAC_TX_IGN_CARRIER
operator||
name|GEM_MAC_TX_IGN_COLLIS
expr_stmt|;
block|}
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_TX_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* XIF Configuration */
comment|/* We should really calculate all this rather than rely on defaults */
name|v
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_XIF_CONFIG
argument_list|)
expr_stmt|;
name|v
operator|=
name|GEM_MAC_XIF_LINK_LED
expr_stmt|;
name|v
operator||=
name|GEM_MAC_XIF_TX_MII_ENA
expr_stmt|;
comment|/* If an external transceiver is connected, enable its MII drivers */
name|sc
operator|->
name|sc_mif_config
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MIF_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_mif_config
operator|&
name|GEM_MIF_CONFIG_MDI1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* External MII needs echo disable if half duplex. */
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
comment|/* turn on full duplex LED */
name|v
operator||=
name|GEM_MAC_XIF_FDPLX_LED
expr_stmt|;
else|else
comment|/* half duplex -- disable echo */
name|v
operator||=
name|GEM_MAC_XIF_ECHO_DISABL
expr_stmt|;
block|}
else|else
block|{
comment|/* Internal MII needs buf enable */
name|v
operator||=
name|GEM_MAC_XIF_MII_BUF_ENA
expr_stmt|;
block|}
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|mac
argument_list|,
name|GEM_MAC_XIF_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gem_mediachange
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* XXX Add support for serial media. */
return|return
operator|(
name|mii_mediachg
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gem_mediastatus
parameter_list|(
name|ifp
parameter_list|,
name|ifmr
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmediareq
modifier|*
name|ifmr
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
return|return;
name|mii_pollstat
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_status
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|gem_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|^
name|ifp
operator|->
name|if_flags
operator|)
operator|==
name|IFF_PROMISC
condition|)
name|gem_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|gem_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|gem_stop
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|gem_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
comment|/* Try to get things going again */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|gem_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up the logical address filter.  */
end_comment

begin_function
specifier|static
name|void
name|gem_setladrf
parameter_list|(
name|sc
parameter_list|)
name|struct
name|gem_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|inm
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_bustag
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_h
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_int32_t
name|crc
decl_stmt|;
name|u_int32_t
name|hash
index|[
literal|16
index|]
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Clear hash table */
name|memset
argument_list|(
name|hash
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get current RX configuration */
name|v
operator|=
name|bus_space_read_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Turn on promiscuous mode; turn off the hash filter */
name|v
operator||=
name|GEM_MAC_RX_PROMISCUOUS
expr_stmt|;
name|v
operator|&=
operator|~
name|GEM_MAC_RX_HASH_FILTER
expr_stmt|;
empty_stmt|;
goto|goto
name|chipit
goto|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|!=
literal|0
condition|)
block|{
name|hash
index|[
literal|3
index|]
operator|=
name|hash
index|[
literal|2
index|]
operator|=
name|hash
index|[
literal|1
index|]
operator|=
name|hash
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
goto|goto
name|chipit
goto|;
block|}
comment|/* Turn off promiscuous mode; turn on the hash filter */
name|v
operator|&=
operator|~
name|GEM_MAC_RX_PROMISCUOUS
expr_stmt|;
name|v
operator||=
name|GEM_MAC_RX_HASH_FILTER
expr_stmt|;
comment|/* 	 * Set up multicast address filter by passing all multicast addresses 	 * through a crc generator, and then using the high order 6 bits as an 	 * index into the 256 bit logical address filter.  The high order bit 	 * selects the word, while the rest of the bits select the bit within 	 * the word. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|inm
argument_list|,
argument|&sc->sc_arpcom.ac_if.if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|inm
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|inm
operator|->
name|ifma_addr
expr_stmt|;
name|cp
operator|=
name|LLADDR
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|crc
operator|=
literal|0xffffffff
expr_stmt|;
for|for
control|(
name|len
operator|=
name|sdl
operator|->
name|sdl_alen
init|;
operator|--
name|len
operator|>=
literal|0
condition|;
control|)
block|{
name|int
name|octet
init|=
operator|*
name|cp
operator|++
decl_stmt|;
name|int
name|i
decl_stmt|;
define|#
directive|define
name|MC_POLY_LE
value|0xedb88320UL
comment|/* mcast crc, little endian */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|crc
operator|&
literal|1
operator|)
operator|^
operator|(
name|octet
operator|&
literal|1
operator|)
condition|)
block|{
name|crc
operator|>>=
literal|1
expr_stmt|;
name|crc
operator|^=
name|MC_POLY_LE
expr_stmt|;
block|}
else|else
block|{
name|crc
operator|>>=
literal|1
expr_stmt|;
block|}
name|octet
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Just want the 8 most significant bits. */
name|crc
operator|>>=
literal|24
expr_stmt|;
comment|/* Set the corresponding bit in the filter. */
name|hash
index|[
name|crc
operator|>>
literal|4
index|]
operator||=
literal|1
operator|<<
operator|(
name|crc
operator|&
literal|0xf
operator|)
expr_stmt|;
block|}
name|chipit
label|:
comment|/* Now load the hash table into the chip */
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH0
argument_list|,
name|hash
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH1
argument_list|,
name|hash
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH2
argument_list|,
name|hash
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH3
argument_list|,
name|hash
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH4
argument_list|,
name|hash
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH5
argument_list|,
name|hash
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH6
argument_list|,
name|hash
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH7
argument_list|,
name|hash
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH8
argument_list|,
name|hash
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH9
argument_list|,
name|hash
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH10
argument_list|,
name|hash
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH11
argument_list|,
name|hash
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH12
argument_list|,
name|hash
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH13
argument_list|,
name|hash
index|[
literal|13
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH14
argument_list|,
name|hash
index|[
literal|14
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_HASH15
argument_list|,
name|hash
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|GEM_MAC_RX_CONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|notyet
end_if

begin_comment
comment|/*  * gem_power:  *  *	Power management (suspend/resume) hook.  */
end_comment

begin_function
name|void
specifier|static
name|gem_power
parameter_list|(
name|why
parameter_list|,
name|arg
parameter_list|)
name|int
name|why
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|gem_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|PWR_SUSPEND
case|:
case|case
name|PWR_STANDBY
case|:
name|gem_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_power
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_power
call|)
argument_list|(
name|sc
argument_list|,
name|why
argument_list|)
expr_stmt|;
break|break;
case|case
name|PWR_RESUME
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_power
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_power
call|)
argument_list|(
name|sc
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|gem_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PWR_SOFTSUSPEND
case|:
case|case
name|PWR_SOFTSTANDBY
case|:
case|case
name|PWR_SOFTRESUME
case|:
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

