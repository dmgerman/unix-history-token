begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2008 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USB_GLOBAL_INCLUDE_FILE
end_ifdef

begin_include
include|#
directive|include
include|USB_GLOBAL_INCLUDE_FILE
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|usb_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USB_GLOBAL_INCLUDE_FILE */
end_comment

begin_if
if|#
directive|if
name|USB_HAVE_BUSDMA
end_if

begin_function_decl
specifier|static
name|void
name|usb_dma_tag_create
parameter_list|(
name|struct
name|usb_dma_tag
modifier|*
parameter_list|,
name|usb_size_t
parameter_list|,
name|usb_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_dma_tag_destroy
parameter_list|(
name|struct
name|usb_dma_tag
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_dma_lock_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_lock_op_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_pc_alloc_mem_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_pc_load_mem_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_pc_common_mem_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *  usbd_get_page - lookup DMA-able memory for the given offset  *  * NOTE: Only call this function when the "page_cache" structure has  * been properly initialized !  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_get_page
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|,
name|usb_frlength_t
name|offset
parameter_list|,
name|struct
name|usb_page_search
modifier|*
name|res
parameter_list|)
block|{
if|#
directive|if
name|USB_HAVE_BUSDMA
name|struct
name|usb_page
modifier|*
name|page
decl_stmt|;
if|if
condition|(
name|pc
operator|->
name|page_start
condition|)
block|{
comment|/* Case 1 - something has been loaded into DMA */
if|if
condition|(
name|pc
operator|->
name|buffer
condition|)
block|{
comment|/* Case 1a - Kernel Virtual Address */
name|res
operator|->
name|buffer
operator|=
name|USB_ADD_BYTES
argument_list|(
name|pc
operator|->
name|buffer
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|pc
operator|->
name|page_offset_buf
expr_stmt|;
comment|/* compute destination page */
name|page
operator|=
name|pc
operator|->
name|page_start
expr_stmt|;
if|if
condition|(
name|pc
operator|->
name|ismultiseg
condition|)
block|{
name|page
operator|+=
operator|(
name|offset
operator|/
name|USB_PAGE_SIZE
operator|)
expr_stmt|;
name|offset
operator|%=
name|USB_PAGE_SIZE
expr_stmt|;
name|res
operator|->
name|length
operator|=
name|USB_PAGE_SIZE
operator|-
name|offset
expr_stmt|;
name|res
operator|->
name|physaddr
operator|=
name|page
operator|->
name|physaddr
operator|+
name|offset
expr_stmt|;
block|}
else|else
block|{
name|res
operator|->
name|length
operator|=
operator|(
name|usb_size_t
operator|)
operator|-
literal|1
expr_stmt|;
name|res
operator|->
name|physaddr
operator|=
name|page
operator|->
name|physaddr
operator|+
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pc
operator|->
name|buffer
condition|)
block|{
comment|/* Case 1b - Non Kernel Virtual Address */
name|res
operator|->
name|buffer
operator|=
name|USB_ADD_BYTES
argument_list|(
name|page
operator|->
name|buffer
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
comment|/* Case 2 - Plain PIO */
name|res
operator|->
name|buffer
operator|=
name|USB_ADD_BYTES
argument_list|(
name|pc
operator|->
name|buffer
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|res
operator|->
name|length
operator|=
operator|(
name|usb_size_t
operator|)
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|USB_HAVE_BUSDMA
name|res
operator|->
name|physaddr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *  usb_pc_buffer_is_aligned - verify alignment  *   * This function is used to check if a page cache buffer is properly  * aligned to reduce the use of bounce buffers in PIO mode.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usb_pc_buffer_is_aligned
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|,
name|usb_frlength_t
name|offset
parameter_list|,
name|usb_frlength_t
name|len
parameter_list|,
name|usb_frlength_t
name|mask
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|usbd_get_page
argument_list|(
name|pc
argument_list|,
name|offset
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_res
operator|.
name|length
operator|>
name|len
condition|)
name|buf_res
operator|.
name|length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|USB_P2U
argument_list|(
name|buf_res
operator|.
name|buffer
argument_list|)
operator|&
name|mask
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|buf_res
operator|.
name|length
operator|&
name|mask
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|offset
operator|+=
name|buf_res
operator|.
name|length
expr_stmt|;
name|len
operator|-=
name|buf_res
operator|.
name|length
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *  usbd_copy_in - copy directly to DMA-able memory  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_copy_in
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|cache
parameter_list|,
name|usb_frlength_t
name|offset
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|usb_frlength_t
name|len
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|usbd_get_page
argument_list|(
name|cache
argument_list|,
name|offset
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_res
operator|.
name|length
operator|>
name|len
condition|)
block|{
name|buf_res
operator|.
name|length
operator|=
name|len
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buf_res
operator|.
name|buffer
argument_list|,
name|ptr
argument_list|,
name|buf_res
operator|.
name|length
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|buf_res
operator|.
name|length
expr_stmt|;
name|len
operator|-=
name|buf_res
operator|.
name|length
expr_stmt|;
name|ptr
operator|=
name|USB_ADD_BYTES
argument_list|(
name|ptr
argument_list|,
name|buf_res
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *  usbd_copy_in_user - copy directly to DMA-able memory from userland  *  * Return values:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|USB_HAVE_USER_IO
end_if

begin_function
name|int
name|usbd_copy_in_user
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|cache
parameter_list|,
name|usb_frlength_t
name|offset
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|usb_frlength_t
name|len
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|int
name|error
decl_stmt|;
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|usbd_get_page
argument_list|(
name|cache
argument_list|,
name|offset
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_res
operator|.
name|length
operator|>
name|len
condition|)
block|{
name|buf_res
operator|.
name|length
operator|=
name|len
expr_stmt|;
block|}
name|error
operator|=
name|copyin
argument_list|(
name|ptr
argument_list|,
name|buf_res
operator|.
name|buffer
argument_list|,
name|buf_res
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|offset
operator|+=
name|buf_res
operator|.
name|length
expr_stmt|;
name|len
operator|-=
name|buf_res
operator|.
name|length
expr_stmt|;
name|ptr
operator|=
name|USB_ADD_BYTES
argument_list|(
name|ptr
argument_list|,
name|buf_res
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *  usbd_m_copy_in - copy a mbuf chain directly into DMA-able memory  *------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|USB_HAVE_MBUF
end_if

begin_struct
struct|struct
name|usb_m_copy_in_arg
block|{
name|struct
name|usb_page_cache
modifier|*
name|cache
decl_stmt|;
name|usb_frlength_t
name|dst_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|usbd_m_copy_in_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|uint32_t
name|count
parameter_list|)
block|{
name|struct
name|usb_m_copy_in_arg
modifier|*
name|ua
init|=
name|arg
decl_stmt|;
name|usbd_copy_in
argument_list|(
name|ua
operator|->
name|cache
argument_list|,
name|ua
operator|->
name|dst_offset
argument_list|,
name|src
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ua
operator|->
name|dst_offset
operator|+=
name|count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbd_m_copy_in
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|cache
parameter_list|,
name|usb_frlength_t
name|dst_offset
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|usb_size_t
name|src_offset
parameter_list|,
name|usb_frlength_t
name|src_len
parameter_list|)
block|{
name|struct
name|usb_m_copy_in_arg
name|arg
init|=
block|{
name|cache
block|,
name|dst_offset
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|m_apply
argument_list|(
name|m
argument_list|,
name|src_offset
argument_list|,
name|src_len
argument_list|,
operator|&
name|usbd_m_copy_in_cb
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *  usb_uiomove - factored out code  *------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|USB_HAVE_USER_IO
end_if

begin_function
name|int
name|usb_uiomove
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|usb_frlength_t
name|pc_offset
parameter_list|,
name|usb_frlength_t
name|len
parameter_list|)
block|{
name|struct
name|usb_page_search
name|res
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|usbd_get_page
argument_list|(
name|pc
argument_list|,
name|pc_offset
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|length
operator|>
name|len
condition|)
block|{
name|res
operator|.
name|length
operator|=
name|len
expr_stmt|;
block|}
comment|/* 		 * "uiomove()" can sleep so one needs to make a wrapper, 		 * exiting the mutex and checking things 		 */
name|error
operator|=
name|uiomove
argument_list|(
name|res
operator|.
name|buffer
argument_list|,
name|res
operator|.
name|length
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|pc_offset
operator|+=
name|res
operator|.
name|length
expr_stmt|;
name|len
operator|-=
name|res
operator|.
name|length
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *  usbd_copy_out - copy directly from DMA-able memory  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_copy_out
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|cache
parameter_list|,
name|usb_frlength_t
name|offset
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|usb_frlength_t
name|len
parameter_list|)
block|{
name|struct
name|usb_page_search
name|res
decl_stmt|;
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|usbd_get_page
argument_list|(
name|cache
argument_list|,
name|offset
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|length
operator|>
name|len
condition|)
block|{
name|res
operator|.
name|length
operator|=
name|len
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|res
operator|.
name|buffer
argument_list|,
name|res
operator|.
name|length
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|res
operator|.
name|length
expr_stmt|;
name|len
operator|-=
name|res
operator|.
name|length
expr_stmt|;
name|ptr
operator|=
name|USB_ADD_BYTES
argument_list|(
name|ptr
argument_list|,
name|res
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *  usbd_copy_out_user - copy directly from DMA-able memory to userland  *  * Return values:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|USB_HAVE_USER_IO
end_if

begin_function
name|int
name|usbd_copy_out_user
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|cache
parameter_list|,
name|usb_frlength_t
name|offset
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|usb_frlength_t
name|len
parameter_list|)
block|{
name|struct
name|usb_page_search
name|res
decl_stmt|;
name|int
name|error
decl_stmt|;
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|usbd_get_page
argument_list|(
name|cache
argument_list|,
name|offset
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|length
operator|>
name|len
condition|)
block|{
name|res
operator|.
name|length
operator|=
name|len
expr_stmt|;
block|}
name|error
operator|=
name|copyout
argument_list|(
name|res
operator|.
name|buffer
argument_list|,
name|ptr
argument_list|,
name|res
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|offset
operator|+=
name|res
operator|.
name|length
expr_stmt|;
name|len
operator|-=
name|res
operator|.
name|length
expr_stmt|;
name|ptr
operator|=
name|USB_ADD_BYTES
argument_list|(
name|ptr
argument_list|,
name|res
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *  usbd_frame_zero - zero DMA-able memory  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_frame_zero
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|cache
parameter_list|,
name|usb_frlength_t
name|offset
parameter_list|,
name|usb_frlength_t
name|len
parameter_list|)
block|{
name|struct
name|usb_page_search
name|res
decl_stmt|;
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|usbd_get_page
argument_list|(
name|cache
argument_list|,
name|offset
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|length
operator|>
name|len
condition|)
block|{
name|res
operator|.
name|length
operator|=
name|len
expr_stmt|;
block|}
name|memset
argument_list|(
name|res
operator|.
name|buffer
argument_list|,
literal|0
argument_list|,
name|res
operator|.
name|length
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|res
operator|.
name|length
expr_stmt|;
name|len
operator|-=
name|res
operator|.
name|length
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|USB_HAVE_BUSDMA
end_if

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_dma_lock_cb - dummy callback  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_dma_lock_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_lock_op_t
name|op
parameter_list|)
block|{
comment|/* we use "mtx_owned()" instead of this function */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_dma_tag_create - allocate a DMA tag  *  * NOTE: If the "align" parameter has a value of 1 the DMA-tag will  * allow multi-segment mappings. Else all mappings are single-segment.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_dma_tag_create
parameter_list|(
name|struct
name|usb_dma_tag
modifier|*
name|udt
parameter_list|,
name|usb_size_t
name|size
parameter_list|,
name|usb_size_t
name|align
parameter_list|)
block|{
name|bus_dma_tag_t
name|tag
decl_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/* parent    */
name|udt
operator|->
name|tag_parent
operator|->
name|tag
argument_list|,
comment|/* alignment */
name|align
argument_list|,
comment|/* boundary  */
literal|0
argument_list|,
comment|/* lowaddr   */
operator|(
literal|2ULL
operator|<<
operator|(
name|udt
operator|->
name|tag_parent
operator|->
name|dma_bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
argument_list|,
comment|/* highaddr  */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter    */
name|NULL
argument_list|,
comment|/* filterarg */
name|NULL
argument_list|,
comment|/* maxsize   */
name|size
argument_list|,
comment|/* nsegments */
operator|(
name|align
operator|==
literal|1
operator|&&
name|size
operator|>
literal|1
operator|)
condition|?
operator|(
literal|2
operator|+
operator|(
name|size
operator|/
name|USB_PAGE_SIZE
operator|)
operator|)
else|:
literal|1
argument_list|,
comment|/* maxsegsz  */
operator|(
name|align
operator|==
literal|1
operator|&&
name|size
operator|>
name|USB_PAGE_SIZE
operator|)
condition|?
name|USB_PAGE_SIZE
else|:
name|size
argument_list|,
comment|/* flags     */
name|BUS_DMA_KEEP_PG_OFFSET
argument_list|,
comment|/* lockfn    */
operator|&
name|usb_dma_lock_cb
argument_list|,
comment|/* lockarg   */
name|NULL
argument_list|,
operator|&
name|tag
argument_list|)
condition|)
block|{
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
name|udt
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_dma_tag_free - free a DMA tag  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_dma_tag_destroy
parameter_list|(
name|struct
name|usb_dma_tag
modifier|*
name|udt
parameter_list|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|udt
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_pc_alloc_mem_cb - BUS-DMA callback function  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_pc_alloc_mem_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|usb_pc_common_mem_cb
argument_list|(
name|arg
argument_list|,
name|segs
argument_list|,
name|nseg
argument_list|,
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_pc_load_mem_cb - BUS-DMA callback function  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_pc_load_mem_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|usb_pc_common_mem_cb
argument_list|(
name|arg
argument_list|,
name|segs
argument_list|,
name|nseg
argument_list|,
name|error
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_pc_common_mem_cb - BUS-DMA callback function  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_pc_common_mem_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|,
name|uint8_t
name|isload
parameter_list|)
block|{
name|struct
name|usb_dma_parent_tag
modifier|*
name|uptag
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|struct
name|usb_page
modifier|*
name|pg
decl_stmt|;
name|usb_size_t
name|rem
decl_stmt|;
name|bus_size_t
name|off
decl_stmt|;
name|uint8_t
name|owned
decl_stmt|;
name|pc
operator|=
name|arg
expr_stmt|;
name|uptag
operator|=
name|pc
operator|->
name|tag_parent
expr_stmt|;
comment|/* 	 * XXX There is sometimes recursive locking here. 	 * XXX We should try to find a better solution. 	 * XXX Until further the "owned" variable does 	 * XXX the trick. 	 */
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|off
operator|=
literal|0
expr_stmt|;
name|pg
operator|=
name|pc
operator|->
name|page_start
expr_stmt|;
name|pg
operator|->
name|physaddr
operator|=
name|rounddown2
argument_list|(
name|segs
operator|->
name|ds_addr
argument_list|,
name|USB_PAGE_SIZE
argument_list|)
expr_stmt|;
name|rem
operator|=
name|segs
operator|->
name|ds_addr
operator|&
operator|(
name|USB_PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|pc
operator|->
name|page_offset_buf
operator|=
name|rem
expr_stmt|;
name|pc
operator|->
name|page_offset_end
operator|+=
name|rem
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|nseg
operator|>
literal|1
condition|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|nseg
operator|-
literal|1
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|segs
index|[
name|x
index|]
operator|.
name|ds_addr
operator|+
name|segs
index|[
name|x
index|]
operator|.
name|ds_len
operator|)
operator|&
operator|(
name|USB_PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|==
operator|(
operator|(
name|segs
index|[
name|x
operator|+
literal|1
index|]
operator|.
name|ds_addr
operator|&
operator|(
name|USB_PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
continue|continue;
comment|/* 			 * This check verifies there is no page offset 			 * hole between any of the segments. See the 			 * BUS_DMA_KEEP_PG_OFFSET flag. 			 */
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Page offset was not preserved\n"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
endif|#
directive|endif
while|while
condition|(
name|pc
operator|->
name|ismultiseg
condition|)
block|{
name|off
operator|+=
name|USB_PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|off
operator|>=
operator|(
name|segs
operator|->
name|ds_len
operator|+
name|rem
operator|)
condition|)
block|{
comment|/* page crossing */
name|nseg
operator|--
expr_stmt|;
name|segs
operator|++
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|rem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nseg
operator|==
literal|0
condition|)
break|break;
block|}
name|pg
operator|++
expr_stmt|;
name|pg
operator|->
name|physaddr
operator|=
name|rounddown2
argument_list|(
name|segs
operator|->
name|ds_addr
operator|+
name|off
argument_list|,
name|USB_PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|owned
operator|=
name|mtx_owned
argument_list|(
name|uptag
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|owned
condition|)
name|USB_MTX_LOCK
argument_list|(
name|uptag
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|uptag
operator|->
name|dma_error
operator|=
operator|(
name|error
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|isload
condition|)
block|{
call|(
name|uptag
operator|->
name|func
call|)
argument_list|(
name|uptag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cv_broadcast
argument_list|(
name|uptag
operator|->
name|cv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|owned
condition|)
name|USB_MTX_UNLOCK
argument_list|(
name|uptag
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_pc_alloc_mem - allocate DMA'able memory  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usb_pc_alloc_mem
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|,
name|struct
name|usb_page
modifier|*
name|pg
parameter_list|,
name|usb_size_t
name|size
parameter_list|,
name|usb_size_t
name|align
parameter_list|)
block|{
name|struct
name|usb_dma_parent_tag
modifier|*
name|uptag
decl_stmt|;
name|struct
name|usb_dma_tag
modifier|*
name|utag
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uptag
operator|=
name|pc
operator|->
name|tag_parent
expr_stmt|;
if|if
condition|(
name|align
operator|!=
literal|1
condition|)
block|{
comment|/* 	         * The alignment must be greater or equal to the 	         * "size" else the object can be split between two 	         * memory pages and we get a problem! 	         */
while|while
condition|(
name|align
operator|<
name|size
condition|)
block|{
name|align
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|align
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
if|#
directive|if
literal|1
comment|/* 		 * XXX BUS-DMA workaround - FIXME later: 		 * 		 * We assume that that the aligment at this point of 		 * the code is greater than or equal to the size and 		 * less than two times the size, so that if we double 		 * the size, the size will be greater than the 		 * alignment. 		 * 		 * The bus-dma system has a check for "alignment" 		 * being less than "size". If that check fails we end 		 * up using contigmalloc which is page based even for 		 * small allocations. Try to avoid that to save 		 * memory, hence we sometimes to a large number of 		 * small allocations! 		 */
if|if
condition|(
name|size
operator|<=
operator|(
name|USB_PAGE_SIZE
operator|/
literal|2
operator|)
condition|)
block|{
name|size
operator|*=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* get the correct DMA tag */
name|utag
operator|=
name|usb_dma_tag_find
argument_list|(
name|uptag
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|utag
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* allocate memory */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|utag
operator|->
name|tag
argument_list|,
operator|&
name|ptr
argument_list|,
operator|(
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator|)
argument_list|,
operator|&
name|map
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* setup page cache */
name|pc
operator|->
name|buffer
operator|=
name|ptr
expr_stmt|;
name|pc
operator|->
name|page_start
operator|=
name|pg
expr_stmt|;
name|pc
operator|->
name|page_offset_buf
operator|=
literal|0
expr_stmt|;
name|pc
operator|->
name|page_offset_end
operator|=
name|size
expr_stmt|;
name|pc
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|pc
operator|->
name|tag
operator|=
name|utag
operator|->
name|tag
expr_stmt|;
name|pc
operator|->
name|ismultiseg
operator|=
operator|(
name|align
operator|==
literal|1
operator|)
expr_stmt|;
name|USB_MTX_LOCK
argument_list|(
name|uptag
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* load memory into DMA */
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|utag
operator|->
name|tag
argument_list|,
name|map
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
operator|&
name|usb_pc_alloc_mem_cb
argument_list|,
name|pc
argument_list|,
operator|(
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EINPROGRESS
condition|)
block|{
name|cv_wait
argument_list|(
name|uptag
operator|->
name|cv
argument_list|,
name|uptag
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
name|USB_MTX_UNLOCK
argument_list|(
name|uptag
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|uptag
operator|->
name|dma_error
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|utag
operator|->
name|tag
argument_list|,
name|ptr
argument_list|,
name|map
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|pc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
comment|/* reset most of the page cache */
name|pc
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|pc
operator|->
name|page_start
operator|=
name|NULL
expr_stmt|;
name|pc
operator|->
name|page_offset_buf
operator|=
literal|0
expr_stmt|;
name|pc
operator|->
name|page_offset_end
operator|=
literal|0
expr_stmt|;
name|pc
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
name|pc
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_pc_free_mem - free DMA memory  *  * This function is NULL safe.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_pc_free_mem
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|)
block|{
if|if
condition|(
name|pc
operator|&&
name|pc
operator|->
name|buffer
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|pc
operator|->
name|tag
argument_list|,
name|pc
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|pc
operator|->
name|tag
argument_list|,
name|pc
operator|->
name|buffer
argument_list|,
name|pc
operator|->
name|map
argument_list|)
expr_stmt|;
name|pc
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_pc_load_mem - load virtual memory into DMA  *  * Return values:  * 0: Success  * Else: Error  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usb_pc_load_mem
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|,
name|usb_size_t
name|size
parameter_list|,
name|uint8_t
name|sync
parameter_list|)
block|{
comment|/* setup page cache */
name|pc
operator|->
name|page_offset_buf
operator|=
literal|0
expr_stmt|;
name|pc
operator|->
name|page_offset_end
operator|=
name|size
expr_stmt|;
name|pc
operator|->
name|ismultiseg
operator|=
literal|1
expr_stmt|;
name|USB_MTX_ASSERT
argument_list|(
name|pc
operator|->
name|tag_parent
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sync
condition|)
block|{
name|struct
name|usb_dma_parent_tag
modifier|*
name|uptag
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uptag
operator|=
name|pc
operator|->
name|tag_parent
expr_stmt|;
comment|/* 			 * We have to unload the previous loaded DMA 			 * pages before trying to load a new one! 			 */
name|bus_dmamap_unload
argument_list|(
name|pc
operator|->
name|tag
argument_list|,
name|pc
operator|->
name|map
argument_list|)
expr_stmt|;
comment|/* 			 * Try to load memory into DMA. 			 */
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|pc
operator|->
name|tag
argument_list|,
name|pc
operator|->
name|map
argument_list|,
name|pc
operator|->
name|buffer
argument_list|,
name|size
argument_list|,
operator|&
name|usb_pc_alloc_mem_cb
argument_list|,
name|pc
argument_list|,
name|BUS_DMA_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EINPROGRESS
condition|)
block|{
name|cv_wait
argument_list|(
name|uptag
operator|->
name|cv
argument_list|,
name|uptag
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|||
name|uptag
operator|->
name|dma_error
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 			 * We have to unload the previous loaded DMA 			 * pages before trying to load a new one! 			 */
name|bus_dmamap_unload
argument_list|(
name|pc
operator|->
name|tag
argument_list|,
name|pc
operator|->
name|map
argument_list|)
expr_stmt|;
comment|/* 			 * Try to load memory into DMA. The callback 			 * will be called in all cases: 			 */
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|pc
operator|->
name|tag
argument_list|,
name|pc
operator|->
name|map
argument_list|,
name|pc
operator|->
name|buffer
argument_list|,
name|size
argument_list|,
operator|&
name|usb_pc_load_mem_cb
argument_list|,
name|pc
argument_list|,
name|BUS_DMA_WAITOK
argument_list|)
condition|)
block|{ 			}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|sync
condition|)
block|{
comment|/* 			 * Call callback so that refcount is decremented 			 * properly: 			 */
name|pc
operator|->
name|tag_parent
operator|->
name|dma_error
operator|=
literal|0
expr_stmt|;
call|(
name|pc
operator|->
name|tag_parent
operator|->
name|func
call|)
argument_list|(
name|pc
operator|->
name|tag_parent
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_pc_cpu_invalidate - invalidate CPU cache  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_pc_cpu_invalidate
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|)
block|{
if|if
condition|(
name|pc
operator|->
name|page_offset_end
operator|==
name|pc
operator|->
name|page_offset_buf
condition|)
block|{
comment|/* nothing has been loaded into this page cache! */
return|return;
block|}
comment|/* 	 * TODO: We currently do XXX_POSTREAD and XXX_PREREAD at the 	 * same time, but in the future we should try to isolate the 	 * different cases to optimise the code. --HPS 	 */
name|bus_dmamap_sync
argument_list|(
name|pc
operator|->
name|tag
argument_list|,
name|pc
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|pc
operator|->
name|tag
argument_list|,
name|pc
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_pc_cpu_flush - flush CPU cache  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_pc_cpu_flush
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|)
block|{
if|if
condition|(
name|pc
operator|->
name|page_offset_end
operator|==
name|pc
operator|->
name|page_offset_buf
condition|)
block|{
comment|/* nothing has been loaded into this page cache! */
return|return;
block|}
name|bus_dmamap_sync
argument_list|(
name|pc
operator|->
name|tag
argument_list|,
name|pc
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_pc_dmamap_create - create a DMA map  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usb_pc_dmamap_create
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|,
name|usb_size_t
name|size
parameter_list|)
block|{
name|struct
name|usb_xfer_root
modifier|*
name|info
decl_stmt|;
name|struct
name|usb_dma_tag
modifier|*
name|utag
decl_stmt|;
comment|/* get info */
name|info
operator|=
name|USB_DMATAG_TO_XROOT
argument_list|(
name|pc
operator|->
name|tag_parent
argument_list|)
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|utag
operator|=
name|usb_dma_tag_find
argument_list|(
name|pc
operator|->
name|tag_parent
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|utag
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* create DMA map */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|utag
operator|->
name|tag
argument_list|,
literal|0
argument_list|,
operator|&
name|pc
operator|->
name|map
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|pc
operator|->
name|tag
operator|=
name|utag
operator|->
name|tag
expr_stmt|;
return|return
literal|0
return|;
comment|/* success */
name|error
label|:
name|pc
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
name|pc
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
comment|/* failure */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_pc_dmamap_destroy  *  * This function is NULL safe.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_pc_dmamap_destroy
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|)
block|{
if|if
condition|(
name|pc
operator|&&
name|pc
operator|->
name|tag
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|pc
operator|->
name|tag
argument_list|,
name|pc
operator|->
name|map
argument_list|)
expr_stmt|;
name|pc
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
name|pc
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_dma_tag_find - factored out code  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb_dma_tag
modifier|*
name|usb_dma_tag_find
parameter_list|(
name|struct
name|usb_dma_parent_tag
modifier|*
name|udpt
parameter_list|,
name|usb_size_t
name|size
parameter_list|,
name|usb_size_t
name|align
parameter_list|)
block|{
name|struct
name|usb_dma_tag
modifier|*
name|udt
decl_stmt|;
name|uint8_t
name|nudt
decl_stmt|;
name|USB_ASSERT
argument_list|(
name|align
operator|>
literal|0
argument_list|,
operator|(
literal|"Invalid parameter align = 0\n"
operator|)
argument_list|)
expr_stmt|;
name|USB_ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|,
operator|(
literal|"Invalid parameter size = 0\n"
operator|)
argument_list|)
expr_stmt|;
name|udt
operator|=
name|udpt
operator|->
name|utag_first
expr_stmt|;
name|nudt
operator|=
name|udpt
operator|->
name|utag_max
expr_stmt|;
while|while
condition|(
name|nudt
operator|--
condition|)
block|{
if|if
condition|(
name|udt
operator|->
name|align
operator|==
literal|0
condition|)
block|{
name|usb_dma_tag_create
argument_list|(
name|udt
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|udt
operator|->
name|tag
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|udt
operator|->
name|align
operator|=
name|align
expr_stmt|;
name|udt
operator|->
name|size
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|udt
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|udt
operator|->
name|align
operator|==
name|align
operator|)
operator|&&
operator|(
name|udt
operator|->
name|size
operator|==
name|size
operator|)
condition|)
block|{
return|return
operator|(
name|udt
operator|)
return|;
block|}
name|udt
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_dma_tag_setup - initialise USB DMA tags  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_dma_tag_setup
parameter_list|(
name|struct
name|usb_dma_parent_tag
modifier|*
name|udpt
parameter_list|,
name|struct
name|usb_dma_tag
modifier|*
name|udt
parameter_list|,
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|struct
name|mtx
modifier|*
name|mtx
parameter_list|,
name|usb_dma_callback_t
modifier|*
name|func
parameter_list|,
name|uint8_t
name|ndmabits
parameter_list|,
name|uint8_t
name|nudt
parameter_list|)
block|{
name|memset
argument_list|(
name|udpt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|udpt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* sanity checking */
if|if
condition|(
operator|(
name|nudt
operator|==
literal|0
operator|)
operator|||
operator|(
name|ndmabits
operator|==
literal|0
operator|)
operator|||
operator|(
name|mtx
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* something is corrupt */
return|return;
block|}
comment|/* initialise condition variable */
name|cv_init
argument_list|(
name|udpt
operator|->
name|cv
argument_list|,
literal|"USB DMA CV"
argument_list|)
expr_stmt|;
comment|/* store some information */
name|udpt
operator|->
name|mtx
operator|=
name|mtx
expr_stmt|;
name|udpt
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|udpt
operator|->
name|tag
operator|=
name|dmat
expr_stmt|;
name|udpt
operator|->
name|utag_first
operator|=
name|udt
expr_stmt|;
name|udpt
operator|->
name|utag_max
operator|=
name|nudt
expr_stmt|;
name|udpt
operator|->
name|dma_bits
operator|=
name|ndmabits
expr_stmt|;
while|while
condition|(
name|nudt
operator|--
condition|)
block|{
name|memset
argument_list|(
name|udt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|udt
argument_list|)
argument_list|)
expr_stmt|;
name|udt
operator|->
name|tag_parent
operator|=
name|udpt
expr_stmt|;
name|udt
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_bus_tag_unsetup - factored out code  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_dma_tag_unsetup
parameter_list|(
name|struct
name|usb_dma_parent_tag
modifier|*
name|udpt
parameter_list|)
block|{
name|struct
name|usb_dma_tag
modifier|*
name|udt
decl_stmt|;
name|uint8_t
name|nudt
decl_stmt|;
name|udt
operator|=
name|udpt
operator|->
name|utag_first
expr_stmt|;
name|nudt
operator|=
name|udpt
operator|->
name|utag_max
expr_stmt|;
while|while
condition|(
name|nudt
operator|--
condition|)
block|{
if|if
condition|(
name|udt
operator|->
name|align
condition|)
block|{
comment|/* destroy the USB DMA tag */
name|usb_dma_tag_destroy
argument_list|(
name|udt
argument_list|)
expr_stmt|;
name|udt
operator|->
name|align
operator|=
literal|0
expr_stmt|;
block|}
name|udt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|udpt
operator|->
name|utag_max
condition|)
block|{
comment|/* destroy the condition variable */
name|cv_destroy
argument_list|(
name|udpt
operator|->
name|cv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_bdma_work_loop  *  * This function handles loading of virtual buffers into DMA and is  * only called when "dma_refcount" is zero.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_bdma_work_loop
parameter_list|(
name|struct
name|usb_xfer_queue
modifier|*
name|pq
parameter_list|)
block|{
name|struct
name|usb_xfer_root
modifier|*
name|info
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|usb_frcount_t
name|nframes
decl_stmt|;
name|xfer
operator|=
name|pq
operator|->
name|curr
expr_stmt|;
name|info
operator|=
name|xfer
operator|->
name|xroot
expr_stmt|;
name|USB_MTX_ASSERT
argument_list|(
name|info
operator|->
name|xfer_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|error
condition|)
block|{
comment|/* some error happened */
name|USB_BUS_LOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_setup
condition|)
block|{
name|struct
name|usb_page
modifier|*
name|pg
decl_stmt|;
name|usb_frlength_t
name|frlength_0
decl_stmt|;
name|uint8_t
name|isread
decl_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_setup
operator|=
literal|1
expr_stmt|;
comment|/* reset BUS-DMA load state */
name|info
operator|->
name|dma_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
comment|/* only one frame buffer */
name|nframes
operator|=
literal|1
expr_stmt|;
name|frlength_0
operator|=
name|xfer
operator|->
name|sumlen
expr_stmt|;
block|}
else|else
block|{
comment|/* can be multiple frame buffers */
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
name|frlength_0
operator|=
name|xfer
operator|->
name|frlengths
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* 		 * Set DMA direction first. This is needed to 		 * select the correct cache invalidate and cache 		 * flush operations. 		 */
name|isread
operator|=
name|USB_GET_DATA_ISREAD
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|pg
operator|=
name|xfer
operator|->
name|dma_page_ptr
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|&&
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
condition|)
block|{
comment|/* special case */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
comment|/* The device controller writes to memory */
name|xfer
operator|->
name|frbuffers
index|[
literal|0
index|]
operator|.
name|isread
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* The host controller reads from memory */
name|xfer
operator|->
name|frbuffers
index|[
literal|0
index|]
operator|.
name|isread
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* default case */
name|xfer
operator|->
name|frbuffers
index|[
literal|0
index|]
operator|.
name|isread
operator|=
name|isread
expr_stmt|;
block|}
comment|/* 		 * Setup the "page_start" pointer which points to an array of 		 * USB pages where information about the physical address of a 		 * page will be stored. Also initialise the "isread" field of 		 * the USB page caches. 		 */
name|xfer
operator|->
name|frbuffers
index|[
literal|0
index|]
operator|.
name|page_start
operator|=
name|pg
expr_stmt|;
name|info
operator|->
name|dma_nframes
operator|=
name|nframes
expr_stmt|;
name|info
operator|->
name|dma_currframe
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|dma_frlength_0
operator|=
name|frlength_0
expr_stmt|;
name|pg
operator|+=
operator|(
name|frlength_0
operator|/
name|USB_PAGE_SIZE
operator|)
expr_stmt|;
name|pg
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|--
name|nframes
operator|>
literal|0
condition|)
block|{
name|xfer
operator|->
name|frbuffers
index|[
name|nframes
index|]
operator|.
name|isread
operator|=
name|isread
expr_stmt|;
name|xfer
operator|->
name|frbuffers
index|[
name|nframes
index|]
operator|.
name|page_start
operator|=
name|pg
expr_stmt|;
name|pg
operator|+=
operator|(
name|xfer
operator|->
name|frlengths
index|[
name|nframes
index|]
operator|/
name|USB_PAGE_SIZE
operator|)
expr_stmt|;
name|pg
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|dma_error
condition|)
block|{
name|USB_BUS_LOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_DMA_LOAD_FAILED
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|info
operator|->
name|dma_currframe
operator|!=
name|info
operator|->
name|dma_nframes
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|dma_currframe
operator|==
literal|0
condition|)
block|{
comment|/* special case */
name|usb_pc_load_mem
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|info
operator|->
name|dma_frlength_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* default case */
name|nframes
operator|=
name|info
operator|->
name|dma_currframe
expr_stmt|;
name|usb_pc_load_mem
argument_list|(
name|xfer
operator|->
name|frbuffers
operator|+
name|nframes
argument_list|,
name|xfer
operator|->
name|frlengths
index|[
name|nframes
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* advance frame index */
name|info
operator|->
name|dma_currframe
operator|++
expr_stmt|;
return|return;
block|}
comment|/* go ahead */
name|usb_bdma_pre_sync
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* start loading next USB transfer, if any */
name|usb_command_wrapper
argument_list|(
name|pq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* finally start the hardware */
name|usbd_pipe_enter
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_bdma_done_event  *  * This function is called when the BUS-DMA has loaded virtual memory  * into DMA, if any.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_bdma_done_event
parameter_list|(
name|struct
name|usb_dma_parent_tag
modifier|*
name|udpt
parameter_list|)
block|{
name|struct
name|usb_xfer_root
modifier|*
name|info
decl_stmt|;
name|info
operator|=
name|USB_DMATAG_TO_XROOT
argument_list|(
name|udpt
argument_list|)
expr_stmt|;
name|USB_MTX_ASSERT
argument_list|(
name|info
operator|->
name|xfer_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* copy error */
name|info
operator|->
name|dma_error
operator|=
name|udpt
operator|->
name|dma_error
expr_stmt|;
comment|/* enter workloop again */
name|usb_command_wrapper
argument_list|(
operator|&
name|info
operator|->
name|dma_q
argument_list|,
name|info
operator|->
name|dma_q
operator|.
name|curr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_bdma_pre_sync  *  * This function handles DMA synchronisation that must be done before  * an USB transfer is started.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_bdma_pre_sync
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|usb_frcount_t
name|nframes
decl_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
comment|/* only one frame buffer */
name|nframes
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* can be multiple frame buffers */
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
block|}
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
expr_stmt|;
while|while
condition|(
name|nframes
operator|--
condition|)
block|{
if|if
condition|(
name|pc
operator|->
name|isread
condition|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usb_pc_cpu_flush
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
name|pc
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_bdma_post_sync  *  * This function handles DMA synchronisation that must be done after  * an USB transfer is complete.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_bdma_post_sync
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|usb_frcount_t
name|nframes
decl_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
comment|/* only one frame buffer */
name|nframes
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* can be multiple frame buffers */
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
block|}
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
expr_stmt|;
while|while
condition|(
name|nframes
operator|--
condition|)
block|{
if|if
condition|(
name|pc
operator|->
name|isread
condition|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
name|pc
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

