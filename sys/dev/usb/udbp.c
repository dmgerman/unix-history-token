begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996-2000 Whistle Communications, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of author nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY NICK HIBMA AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_comment
comment|/* Driver for arbitrary double bulk pipe devices.  * The driver assumes that there will be the same driver on the other side.  *  * XXX Some more information on what the framing of the IP packets looks like.  *  * To take full advantage of bulk transmission, packets should be chosen  * between 1k and 5k in size (1k to make sure the sending side starts  * straming, and<5k to avoid overflowing the system with small TDs).  */
end_comment

begin_comment
comment|/* probe/attach/detach:  *  Connect the driver to the hardware and netgraph  *  * udbp_setup_out_transfer(sc);  *  Setup an outbound transfer. Only one transmit can be active at the same  *  time.  *  XXX If it is required that the driver is able to queue multiple requests  *      let me know. That is slightly difficult, due to the fact that we  *	cannot call usbd_alloc_xfer in int context.  *  * udbp_setup_in_transfer(sc)  *  Prepare an in transfer that will be waiting for data to come in. It  *  is submitted and sits there until data is available.  *  The callback resubmits a new transfer on completion.  *  *  The reason we submit a bulk in transfer is that USB does not know about  *  interrupts. The bulk transfer continuously polls the device for data.  *  While the device has no data available, the device NAKs the TDs. As soon  *  as there is data, the transfer happens and the data comes flowing in.  *  *  In case you were wondering, interrupt transfers happen exactly that way.  *  It therefore doesn't make sense to use the interrupt pipe to signal  *  'data ready' and then schedule a bulk transfer to fetch it. That would  *  incur a 2ms delay at least, without reducing bandwidth requirements.  *    */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500014
end_if

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbhid.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdevs.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/udbp.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|UDBP_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (udbpdebug) logprintf x
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (udbpdebug>(n)) logprintf x
end_define

begin_decl_stmt
name|int
name|udbpdebug
init|=
literal|9
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MS_TO_TICKS
parameter_list|(
name|ms
parameter_list|)
value|((ms) * hz / 1000)
end_define

begin_define
define|#
directive|define
name|UDBP_TIMEOUT
value|2000
end_define

begin_comment
comment|/* timeout on outbound transfers, in msecs */
end_comment

begin_define
define|#
directive|define
name|UDBP_BUFFERSIZE
value|2048
end_define

begin_comment
comment|/* maximum number of bytes in one transfer */
end_comment

begin_struct
struct|struct
name|udbp_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
comment|/* base device */
name|usbd_interface_handle
name|sc_iface
decl_stmt|;
name|usbd_pipe_handle
name|sc_bulkin_pipe
decl_stmt|;
name|int
name|sc_bulkin
decl_stmt|;
name|usbd_xfer_handle
name|sc_bulkin_xfer
decl_stmt|;
name|void
modifier|*
name|sc_bulkin_buffer
decl_stmt|;
name|int
name|sc_bulkin_bufferlen
decl_stmt|;
name|int
name|sc_bulkin_datalen
decl_stmt|;
name|usbd_pipe_handle
name|sc_bulkout_pipe
decl_stmt|;
name|int
name|sc_bulkout
decl_stmt|;
name|usbd_xfer_handle
name|sc_bulkout_xfer
decl_stmt|;
name|void
modifier|*
name|sc_bulkout_buffer
decl_stmt|;
name|int
name|sc_bulkout_bufferlen
decl_stmt|;
name|int
name|sc_bulkout_datalen
decl_stmt|;
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|DISCONNECTED
value|0x01
define|#
directive|define
name|OUT_BUSY
value|0x02
define|#
directive|define
name|NETGRAPH_INITIALISED
value|0x04
name|node_p
name|node
decl_stmt|;
comment|/* back pointer to node */
name|hook_p
name|hook
decl_stmt|;
comment|/* pointer to the hook */
name|u_int
name|packets_in
decl_stmt|;
comment|/* packets in from downstream */
name|u_int
name|packets_out
decl_stmt|;
comment|/* packets out towards downstream */
name|struct
name|ifqueue
name|xmitq_hipri
decl_stmt|;
comment|/* hi-priority transmit queue */
name|struct
name|ifqueue
name|xmitq
decl_stmt|;
comment|/* low-priority transmit queue */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|udbp_softc
modifier|*
name|udbp_p
typedef|;
end_typedef

begin_decl_stmt
name|Static
name|ng_constructor_t
name|ng_udbp_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|ng_rcvmsg_t
name|ng_udbp_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|ng_shutdown_t
name|ng_udbp_rmnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|ng_newhook_t
name|ng_udbp_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|ng_connect_t
name|ng_udbp_connect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|ng_rcvdata_t
name|ng_udbp_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|ng_disconnect_t
name|ng_udbp_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ngudbpstat */
end_comment

begin_expr_stmt
name|Static
specifier|const
expr|struct
name|ng_parse_struct_info
name|ng_udbp_stat_type_info
operator|=
name|NG_UDBP_STATS_TYPE_INFO
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Static
specifier|const
expr|struct
name|ng_parse_type
name|ng_udbp_stat_type
operator|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_udbp_stat_type_info
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* List of commands and how to convert arguments to/from ASCII */
end_comment

begin_expr_stmt
name|Static
specifier|const
expr|struct
name|ng_cmdlist
name|ng_udbp_cmdlist
index|[]
operator|=
block|{
block|{
name|NGM_UDBP_COOKIE
block|,
name|NGM_UDBP_GET_STATUS
block|,
literal|"getstatus"
block|,
name|NULL
block|,
operator|&
name|ng_udbp_stat_type
block|, 	}
block|,
block|{
name|NGM_UDBP_COOKIE
block|,
name|NGM_UDBP_SET_FLAG
block|,
literal|"setflag"
block|,
operator|&
name|ng_parse_int32_type
block|,
name|NULL
block|}
block|,
block|{
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Netgraph node type descriptor */
end_comment

begin_decl_stmt
name|Static
name|struct
name|ng_type
name|ng_udbp_typestruct
init|=
block|{
name|NG_ABI_VERSION
block|,
name|NG_UDBP_NODE_TYPE
block|,
name|NULL
block|,
name|ng_udbp_constructor
block|,
name|ng_udbp_rcvmsg
block|,
name|ng_udbp_rmnode
block|,
name|ng_udbp_newhook
block|,
name|NULL
block|,
name|ng_udbp_connect
block|,
name|ng_udbp_rcvdata
block|,
name|ng_udbp_disconnect
block|,
name|ng_udbp_cmdlist
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Static
name|int
name|udbp_setup_in_transfer
parameter_list|(
name|udbp_p
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|udbp_in_transfer_cb
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|priv
parameter_list|,
name|usbd_status
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|udbp_setup_out_transfer
parameter_list|(
name|udbp_p
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|udbp_out_transfer_cb
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|priv
parameter_list|,
name|usbd_status
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|USB_DECLARE_DRIVER
argument_list|(
name|udbp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|USB_MATCH
argument_list|(
argument|udbp
argument_list|)
end_macro

begin_block
block|{
name|USB_MATCH_START
argument_list|(
name|udbp
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
if|if
condition|(
operator|!
name|uaa
operator|->
name|iface
condition|)
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
comment|/* XXX Julian, add the id of the device if you have one to test 	 * things with. run 'usbdevs -v' and note the 3 ID's that appear. 	 * The Vendor Id and Product Id are in hex and the Revision Id is in 	 * bcd. But as usual if the revision is 0x101 then you should compare 	 * the revision id in the device descriptor with 0x101 	 * Or go search the file usbdevs.h. Maybe the device is already in 	 * there. 	 */
if|if
condition|(
operator|(
name|uaa
operator|->
name|vendor
operator|==
name|USB_VENDOR_NETCHIP
operator|&&
name|uaa
operator|->
name|product
operator|==
name|USB_PRODUCT_NETCHIP_TURBOCONNECT
operator|)
condition|)
return|return
operator|(
name|UMATCH_VENDOR_PRODUCT
operator|)
return|;
if|if
condition|(
operator|(
name|uaa
operator|->
name|vendor
operator|==
name|USB_VENDOR_PROLIFIC
operator|&&
operator|(
name|uaa
operator|->
name|product
operator|==
name|USB_PRODUCT_PROLIFIC_PL2301
operator|||
name|uaa
operator|->
name|product
operator|==
name|USB_PRODUCT_PROLIFIC_PL2302
operator|)
operator|)
condition|)
return|return
operator|(
name|UMATCH_VENDOR_PRODUCT
operator|)
return|;
if|if
condition|(
operator|(
name|uaa
operator|->
name|vendor
operator|==
name|USB_VENDOR_ANCHOR
operator|&&
name|uaa
operator|->
name|product
operator|==
name|USB_PRODUCT_ANCHOR_EZLINK
operator|)
condition|)
return|return
operator|(
name|UMATCH_VENDOR_PRODUCT
operator|)
return|;
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
block|}
end_block

begin_macro
name|USB_ATTACH
argument_list|(
argument|udbp
argument_list|)
end_macro

begin_block
block|{
name|USB_ATTACH_START
argument_list|(
name|udbp
argument_list|,
name|sc
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|usbd_interface_handle
name|iface
init|=
name|uaa
operator|->
name|iface
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
decl_stmt|,
modifier|*
name|ed_bulkin
init|=
name|NULL
decl_stmt|,
modifier|*
name|ed_bulkout
init|=
name|NULL
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|char
name|devinfo
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|ngudbp_done_init
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|flags
operator||=
name|DISCONNECTED
expr_stmt|;
comment|/* fetch the interface handle for the first interface */
operator|(
name|void
operator|)
name|usbd_device2interface_handle
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
literal|0
argument_list|,
operator|&
name|iface
argument_list|)
expr_stmt|;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|iface
argument_list|)
expr_stmt|;
name|usbd_devinfo
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
literal|0
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|USB_ATTACH_SETUP
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %s, iclass %d/%d\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|devinfo
argument_list|,
name|id
operator|->
name|bInterfaceClass
argument_list|,
name|id
operator|->
name|bInterfaceSubClass
argument_list|)
expr_stmt|;
comment|/* Find the two first bulk endpoints */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|id
operator|->
name|bNumEndpoints
condition|;
name|i
operator|++
control|)
block|{
name|ed
operator|=
name|usbd_interface2endpoint_descriptor
argument_list|(
name|iface
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ed
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not read endpoint descriptor\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_IN
operator|&&
operator|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|==
name|UE_BULK
condition|)
block|{
name|ed_bulkin
operator|=
name|ed
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_OUT
operator|&&
operator|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|==
name|UE_BULK
condition|)
block|{
name|ed_bulkout
operator|=
name|ed
expr_stmt|;
block|}
if|if
condition|(
name|ed_bulkin
operator|&&
name|ed_bulkout
condition|)
comment|/* found all we need */
break|break;
block|}
comment|/* Verify that we goething sensible */
if|if
condition|(
name|ed_bulkin
operator|==
name|NULL
operator|||
name|ed_bulkout
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bulk-in and/or bulk-out endpoint not found\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
if|if
condition|(
name|ed_bulkin
operator|->
name|wMaxPacketSize
index|[
literal|0
index|]
operator|!=
name|ed_bulkout
operator|->
name|wMaxPacketSize
index|[
literal|0
index|]
operator|||
name|ed_bulkin
operator|->
name|wMaxPacketSize
index|[
literal|1
index|]
operator|!=
name|ed_bulkout
operator|->
name|wMaxPacketSize
index|[
literal|1
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bulk-in and bulk-out have different packet sizes %d %d %d %d\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|ed_bulkin
operator|->
name|wMaxPacketSize
index|[
literal|0
index|]
argument_list|,
name|ed_bulkout
operator|->
name|wMaxPacketSize
index|[
literal|0
index|]
argument_list|,
name|ed_bulkin
operator|->
name|wMaxPacketSize
index|[
literal|1
index|]
argument_list|,
name|ed_bulkout
operator|->
name|wMaxPacketSize
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
name|sc
operator|->
name|sc_bulkin
operator|=
name|ed_bulkin
operator|->
name|bEndpointAddress
expr_stmt|;
name|sc
operator|->
name|sc_bulkout
operator|=
name|ed_bulkout
operator|->
name|bEndpointAddress
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: Bulk-in: 0x%02x, bulk-out 0x%02x, packet size = %d\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|sc
operator|->
name|sc_bulkin
operator|,
name|sc
operator|->
name|sc_bulkout
operator|,
name|ed_bulkin
operator|->
name|wMaxPacketSize
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* Allocate the in transfer struct */
name|sc
operator|->
name|sc_bulkin_xfer
operator|=
name|usbd_alloc_xfer
argument_list|(
name|uaa
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_bulkin_xfer
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_bulkout_xfer
operator|=
name|usbd_alloc_xfer
argument_list|(
name|uaa
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_bulkout_xfer
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_bulkin_buffer
operator|=
name|malloc
argument_list|(
name|UDBP_BUFFERSIZE
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_bulkin_buffer
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_bulkout_buffer
operator|=
name|malloc
argument_list|(
name|UDBP_BUFFERSIZE
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_bulkout_xfer
operator|||
operator|!
name|sc
operator|->
name|sc_bulkout_buffer
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_bulkin_bufferlen
operator|=
name|UDBP_BUFFERSIZE
expr_stmt|;
name|sc
operator|->
name|sc_bulkout_bufferlen
operator|=
name|UDBP_BUFFERSIZE
expr_stmt|;
comment|/* We have decided on which endpoints to use, now open the pipes */
name|err
operator|=
name|usbd_open_pipe
argument_list|(
name|iface
argument_list|,
name|sc
operator|->
name|sc_bulkin
argument_list|,
name|USBD_EXCLUSIVE_USE
argument_list|,
operator|&
name|sc
operator|->
name|sc_bulkin_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot open bulk-in pipe (addr %d)\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_bulkin
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|err
operator|=
name|usbd_open_pipe
argument_list|(
name|iface
argument_list|,
name|sc
operator|->
name|sc_bulkout
argument_list|,
name|USBD_EXCLUSIVE_USE
argument_list|,
operator|&
name|sc
operator|->
name|sc_bulkout_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot open bulk-out pipe (addr %d)\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_bulkout
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
name|ngudbp_done_init
condition|)
block|{
name|ngudbp_done_init
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ng_newtype
argument_list|(
operator|&
name|ng_udbp_typestruct
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ngudbp install failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|ng_udbp_typestruct
argument_list|,
operator|&
name|sc
operator|->
name|node
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|char
name|nodename
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|nodename
argument_list|,
literal|"%s"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|ng_name_node
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|nodename
argument_list|)
operator|)
condition|)
block|{
name|NG_NODE_UNREF
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
name|sc
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
else|else
block|{
name|NG_NODE_SET_PRIVATE
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|xmitq
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|sc
operator|->
name|xmitq_hipri
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|xmitq
operator|.
name|ifq_mtx
argument_list|,
literal|"usb_xmitq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|xmitq_hipri
operator|.
name|ifq_mtx
argument_list|,
literal|"usb_xmitq_hipri"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|flags
operator|=
name|NETGRAPH_INITIALISED
expr_stmt|;
comment|/* sc->flags&= ~DISCONNECTED; */
comment|/* XXX */
comment|/* the device is now operational */
comment|/* schedule the first incoming xfer */
name|err
operator|=
name|udbp_setup_in_transfer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|USB_ATTACH_SUCCESS_RETURN
expr_stmt|;
name|bad
label|:
if|#
directive|if
literal|0
comment|/* probably done in udbp_detach() */
block|if (sc->sc_bulkout_buffer) { 			FREE(sc->sc_bulkout_buffer, M_USBDEV); 		} 		if (sc->sc_bulkin_buffer) { 			FREE(sc->sc_bulkin_buffer, M_USBDEV); 		} 		if (sc->sc_bulkout_xfer) { 			usbd_free_xfer(sc->sc_bulkout_xfer); 		} 		if (sc->sc_bulkin_xfer) { 			usbd_free_xfer(sc->sc_bulkin_xfer); 		}
endif|#
directive|endif
name|udbp_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|USB_DETACH
argument_list|(
argument|udbp
argument_list|)
end_macro

begin_block
block|{
name|USB_DETACH_START
argument_list|(
name|udbp
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|DISCONNECTED
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: disconnected\n"
operator|,
name|USBDEVNAME
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bulkin_pipe
condition|)
block|{
name|usbd_abort_pipe
argument_list|(
name|sc
operator|->
name|sc_bulkin_pipe
argument_list|)
expr_stmt|;
name|usbd_close_pipe
argument_list|(
name|sc
operator|->
name|sc_bulkin_pipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bulkout_pipe
condition|)
block|{
name|usbd_abort_pipe
argument_list|(
name|sc
operator|->
name|sc_bulkout_pipe
argument_list|)
expr_stmt|;
name|usbd_close_pipe
argument_list|(
name|sc
operator|->
name|sc_bulkout_pipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|NETGRAPH_INITIALISED
condition|)
block|{
name|ng_rmnode_self
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
name|sc
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
comment|/* Paranoid */
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bulkin_xfer
condition|)
name|usbd_free_xfer
argument_list|(
name|sc
operator|->
name|sc_bulkin_xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bulkout_xfer
condition|)
name|usbd_free_xfer
argument_list|(
name|sc
operator|->
name|sc_bulkout_xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bulkin_buffer
condition|)
name|free
argument_list|(
name|sc
operator|->
name|sc_bulkin_buffer
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bulkout_buffer
condition|)
name|free
argument_list|(
name|sc
operator|->
name|sc_bulkout_buffer
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_function
name|Static
name|int
name|udbp_setup_in_transfer
parameter_list|(
name|udbp_p
name|sc
parameter_list|)
block|{
name|void
modifier|*
name|priv
init|=
name|sc
decl_stmt|;
comment|/* XXX this should probably be some pointer to 				 * struct describing the transfer (mbuf?) 				 * See also below. 				 */
name|usbd_status
name|err
decl_stmt|;
comment|/* XXX 	 * How should we arrange for 2 extra bytes at the start of the 	 * packet? 	 */
comment|/* Initialise a USB transfer and then schedule it */
operator|(
name|void
operator|)
name|usbd_setup_xfer
argument_list|(
name|sc
operator|->
name|sc_bulkin_xfer
argument_list|,
name|sc
operator|->
name|sc_bulkin_pipe
argument_list|,
name|priv
argument_list|,
name|sc
operator|->
name|sc_bulkin_buffer
argument_list|,
name|sc
operator|->
name|sc_bulkin_bufferlen
argument_list|,
name|USBD_SHORT_XFER_OK
argument_list|,
name|USBD_NO_TIMEOUT
argument_list|,
name|udbp_in_transfer_cb
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_transfer
argument_list|(
name|sc
operator|->
name|sc_bulkin_xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
name|USBD_IN_PROGRESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: failed to setup in-transfer, %s\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|void
name|udbp_in_transfer_cb
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|priv
parameter_list|,
name|usbd_status
name|err
parameter_list|)
block|{
name|udbp_p
name|sc
init|=
name|priv
decl_stmt|;
comment|/* XXX see priv above */
name|int
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|!=
name|USBD_CANCELLED
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: bulk-out transfer failed: %s\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* USBD_CANCELLED happens at unload of the driver */
return|return;
block|}
comment|/* Transfer has failed, packet is not received */
block|}
else|else
block|{
name|len
operator|=
name|xfer
operator|->
name|actlen
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* block network stuff too */
if|if
condition|(
name|sc
operator|->
name|hook
condition|)
block|{
comment|/* get packet from device and send on */
name|m
operator|=
name|m_devget
argument_list|(
name|sc
operator|->
name|sc_bulkin_buffer
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|err
argument_list|,
name|sc
operator|->
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* schedule the next in transfer */
name|udbp_setup_in_transfer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Static
name|int
name|udbp_setup_out_transfer
parameter_list|(
name|udbp_p
name|sc
parameter_list|)
block|{
name|void
modifier|*
name|priv
init|=
name|sc
decl_stmt|;
comment|/* XXX this should probably be some pointer to 				 * struct describing the transfer (mbuf?) 				 * See also below. 				 */
name|int
name|pktlen
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|s
decl_stmt|,
name|s1
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|OUT_BUSY
condition|)
name|panic
argument_list|(
literal|"out transfer already in use, we should add queuing"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|OUT_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s1
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Queueing happens at splnet */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|xmitq_hipri
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|xmitq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|sc
operator|->
name|flags
operator|&=
operator|~
name|OUT_BUSY
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
name|pktlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|pktlen
operator|>
name|sc
operator|->
name|sc_bulkout_bufferlen
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Packet too large, %d> %d\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|pktlen
argument_list|,
name|sc
operator|->
name|sc_bulkout_bufferlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|pktlen
argument_list|,
name|sc
operator|->
name|sc_bulkout_buffer
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Initialise a USB transfer and then schedule it */
operator|(
name|void
operator|)
name|usbd_setup_xfer
argument_list|(
name|sc
operator|->
name|sc_bulkout_xfer
argument_list|,
name|sc
operator|->
name|sc_bulkout_pipe
argument_list|,
name|priv
argument_list|,
name|sc
operator|->
name|sc_bulkout_buffer
argument_list|,
name|pktlen
argument_list|,
name|USBD_SHORT_XFER_OK
argument_list|,
name|UDBP_TIMEOUT
argument_list|,
name|udbp_out_transfer_cb
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_transfer
argument_list|(
name|sc
operator|->
name|sc_bulkout_xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
name|USBD_IN_PROGRESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: failed to setup out-transfer, %s\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|void
name|udbp_out_transfer_cb
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|priv
parameter_list|,
name|usbd_status
name|err
parameter_list|)
block|{
name|udbp_p
name|sc
init|=
name|priv
decl_stmt|;
comment|/* XXX see priv above */
name|int
name|s
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: bulk-out transfer failed: %s\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Transfer has failed, packet is not transmitted */
comment|/* XXX Invalidate packet */
return|return;
block|}
comment|/* packet has been transmitted */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
comment|/* mark the buffer available */
name|sc
operator|->
name|flags
operator|&=
operator|~
name|OUT_BUSY
expr_stmt|;
name|udbp_setup_out_transfer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|udbp
argument_list|,
name|uhub
argument_list|,
name|udbp_driver
argument_list|,
name|udbp_devclass
argument_list|,
name|usbd_driver_load
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/***********************************************************************  * Start of Netgraph methods  **********************************************************************/
end_comment

begin_comment
comment|/*  * If this is a device node so this work is done in the attach()  * routine and the constructor will return EINVAL as you should not be able  * to create nodes that depend on hardware (unless you can add the hardware :)  */
end_comment

begin_function
name|Static
name|int
name|ng_udbp_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give our ok for a hook to be added...  * If we are not running this might kick a device into life.  * Possibly decode information out of the hook name.  * Add the hook's private info to the hook structure.  * (if we had some). In this example, we assume that there is a  * an array of structs, called 'channel' in the private info,  * one for each active channel. The private  * pointer of each hook points to the appropriate UDBP_hookinfo struct  * so that the source of an input packet is easily identified.  */
end_comment

begin_function
name|Static
name|int
name|ng_udbp_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|udbp_p
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Possibly start up the device if it's not already going */
block|if ((sc->flags& SCF_RUNNING) == 0) { 		ng_udbp_start_hardware(sc); 	}
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_UDBP_HOOK_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* not a hook we know about */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a netgraph control message.  * Check it is one we understand. If needed, send a response.  * We could save the address for an async action later, but don't here.  * Always free the message.  * The response should be in a malloc'd region that the caller can 'free'.  * A response is not required.  * Theoretically you could respond defferently to old message types if  * the cookie in the header didn't match what we consider to be current  * (so that old userland programs could continue to work).  */
end_comment

begin_function
name|Static
name|int
name|ng_udbp_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
specifier|const
name|udbp_p
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* Deal with message according to cookie and command */
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_UDBP_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_UDBP_GET_STATUS
case|:
block|{
name|struct
name|ngudbpstat
modifier|*
name|stats
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|stats
operator|=
operator|(
expr|struct
name|ngudbpstat
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|stats
operator|->
name|packets_in
operator|=
name|sc
operator|->
name|packets_in
expr_stmt|;
name|stats
operator|->
name|packets_out
operator|=
name|sc
operator|->
name|packets_out
expr_stmt|;
break|break;
block|}
case|case
name|NGM_UDBP_SET_FLAG
case|:
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|flags
operator|=
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|msg
operator|->
name|data
operator|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* unknown command */
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* unknown cookie type */
break|break;
block|}
comment|/* Take care of synchronous response, if any */
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Accept data from the hook and queue it for output.  */
end_comment

begin_function
name|Static
name|int
name|ng_udbp_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|udbp_p
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|xmitq_p
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|meta_p
name|meta
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NGI_GET_META
argument_list|(
name|item
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/*  	 * Now queue the data for when it can be sent 	 */
if|if
condition|(
name|meta
operator|&&
name|meta
operator|->
name|priority
operator|>
literal|0
condition|)
block|{
name|xmitq_p
operator|=
operator|(
operator|&
name|sc
operator|->
name|xmitq_hipri
operator|)
expr_stmt|;
block|}
else|else
block|{
name|xmitq_p
operator|=
operator|(
operator|&
name|sc
operator|->
name|xmitq
operator|)
expr_stmt|;
block|}
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|IF_LOCK
argument_list|(
name|xmitq_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IF_QFULL
argument_list|(
name|xmitq_p
argument_list|)
condition|)
block|{
name|_IF_DROP
argument_list|(
name|xmitq_p
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|xmitq_p
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|_IF_ENQUEUE
argument_list|(
name|xmitq_p
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|xmitq_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|OUT_BUSY
operator|)
condition|)
name|udbp_setup_out_transfer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
comment|/*          * It was an error case. 	 * check if we need to free the mbuf, and then return the error 	 */
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do local shutdown processing..  * We are a persistant device, we refuse to go away, and  * only remove our links and reset ourself.  */
end_comment

begin_function
name|Static
name|int
name|ng_udbp_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|udbp_p
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|DISCONNECTED
condition|)
block|{
comment|/*  		 * WE are really going away.. hardware must have gone. 		 * Assume that the hardware drive part will clear up the  		 * sc, in fact it may already have done so.. 		 * In which case we may have just segfaulted..XXX 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* stolen from attach routine */
comment|/* Drain the queues */
name|IF_DRAIN
argument_list|(
operator|&
name|sc
operator|->
name|xmitq_hipri
argument_list|)
expr_stmt|;
name|IF_DRAIN
argument_list|(
operator|&
name|sc
operator|->
name|xmitq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|packets_in
operator|=
literal|0
expr_stmt|;
comment|/* reset stats */
name|sc
operator|->
name|packets_out
operator|=
literal|0
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* forget it ever existed */
if|if
condition|(
operator|(
name|err
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|ng_udbp_typestruct
argument_list|,
operator|&
name|sc
operator|->
name|node
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|char
name|nodename
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|nodename
argument_list|,
literal|"%s"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|ng_name_node
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|nodename
argument_list|)
operator|)
condition|)
block|{
name|NG_NODE_UNREF
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* out damned spot! */
name|sc
operator|->
name|flags
operator|&=
operator|~
name|NETGRAPH_INITIALISED
expr_stmt|;
name|sc
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|NG_NODE_SET_PRIVATE
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called once we've already connected a new hook to the other node.  * It gives us a chance to balk at the last minute.  */
end_comment

begin_function
name|Static
name|int
name|ng_udbp_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
comment|/* probably not at splnet, force outward queueing */
name|NG_HOOK_FORCE_QUEUE
argument_list|(
name|NG_HOOK_PEER
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
comment|/* be really amiable and just say "YUP that's OK by me! " */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dook disconnection  *  * For this type, removal of the last link destroys the node  */
end_comment

begin_function
name|Static
name|int
name|ng_udbp_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
specifier|const
name|udbp_p
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|sc
operator|->
name|hook
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|NG_NODE_IS_VALID
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
operator|)
condition|)
name|ng_rmnode_self
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

