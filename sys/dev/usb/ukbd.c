begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*      $NetBSD: ukbd.c,v 1.22 1999/01/09 12:10:36 drochner Exp $        */
end_comment

begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (augustss@carlstedt.se) at  * Carlstedt Research& Technology.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Information about USB keyboard can be found in the USB HID spec.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbhid.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdevs.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_quirks.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/hid.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/wscons/wsconsio.h>
end_include

begin_include
include|#
directive|include
file|<dev/wscons/wskbdvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/wscons/wsksymdef.h>
end_include

begin_include
include|#
directive|include
file|<dev/wscons/wsksymvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/wscons/wskbdmap_mfii.h>
end_include

begin_include
include|#
directive|include
file|"opt_pckbd_layout.h"
end_include

begin_include
include|#
directive|include
file|"opt_wsdisplay_compat.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_define
define|#
directive|define
name|delay
parameter_list|(
name|d
parameter_list|)
value|DELAY(d)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (ukbddebug) printf x
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (ukbddebug>(n)) printf x
end_define

begin_decl_stmt
name|int
name|ukbddebug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UPROTO_BOOT_KEYBOARD
value|1
end_define

begin_define
define|#
directive|define
name|NKEYCODE
value|6
end_define

begin_define
define|#
directive|define
name|NUM_LOCK
value|0x01
end_define

begin_define
define|#
directive|define
name|CAPS_LOCK
value|0x02
end_define

begin_define
define|#
directive|define
name|SCROLL_LOCK
value|0x04
end_define

begin_struct
struct|struct
name|ukbd_data
block|{
name|u_int8_t
name|modifiers
decl_stmt|;
define|#
directive|define
name|MOD_CONTROL_L
value|0x01
define|#
directive|define
name|MOD_CONTROL_R
value|0x10
define|#
directive|define
name|MOD_SHIFT_L
value|0x02
define|#
directive|define
name|MOD_SHIFT_R
value|0x20
define|#
directive|define
name|MOD_ALT_L
value|0x04
define|#
directive|define
name|MOD_ALT_R
value|0x40
define|#
directive|define
name|MOD_WIN_L
value|0x08
define|#
directive|define
name|MOD_WIN_R
value|0x80
name|u_int8_t
name|reserved
decl_stmt|;
name|u_int8_t
name|keycode
index|[
name|NKEYCODE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PRESS
value|0
end_define

begin_define
define|#
directive|define
name|RELEASE
value|0x100
end_define

begin_define
define|#
directive|define
name|NMOD
value|6
end_define

begin_struct
specifier|static
struct|struct
block|{
name|int
name|mask
decl_stmt|,
name|key
decl_stmt|;
block|}
name|ukbd_mods
index|[
name|NMOD
index|]
init|=
block|{
block|{
name|MOD_CONTROL_L
block|,
literal|29
block|}
block|,
block|{
name|MOD_CONTROL_R
block|,
literal|58
block|}
block|,
block|{
name|MOD_SHIFT_L
block|,
literal|42
block|}
block|,
block|{
name|MOD_SHIFT_R
block|,
literal|54
block|}
block|,
block|{
name|MOD_ALT_L
block|,
literal|56
block|}
block|,
block|{
name|MOD_ALT_R
block|,
literal|184
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|NN
value|0
end_define

begin_comment
comment|/* no translation */
end_comment

begin_comment
comment|/*   * Translate USB keycodes to US keyboard AT scancodes.  * Scancodes>= 128 represent EXTENDED keycodes.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int8_t
name|ukbd_trtab
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|30
block|,
literal|48
block|,
literal|46
block|,
literal|32
block|,
comment|/* 00 - 07 */
literal|18
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|23
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
comment|/* 08 - 0F */
literal|50
block|,
literal|49
block|,
literal|24
block|,
literal|25
block|,
literal|16
block|,
literal|19
block|,
literal|31
block|,
literal|20
block|,
comment|/* 10 - 17 */
literal|22
block|,
literal|47
block|,
literal|17
block|,
literal|45
block|,
literal|21
block|,
literal|44
block|,
literal|2
block|,
literal|3
block|,
comment|/* 18 - 1F */
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
comment|/* 20 - 27 */
literal|28
block|,
literal|1
block|,
literal|14
block|,
literal|15
block|,
literal|57
block|,
literal|12
block|,
literal|13
block|,
literal|26
block|,
comment|/* 28 - 2F */
literal|27
block|,
literal|43
block|,
name|NN
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|51
block|,
literal|52
block|,
comment|/* 30 - 37 */
literal|53
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
comment|/* 38 - 3F */
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|87
block|,
literal|88
block|,
literal|170
block|,
literal|70
block|,
comment|/* 40 - 47 */
literal|127
block|,
literal|210
block|,
literal|199
block|,
literal|201
block|,
literal|211
block|,
literal|207
block|,
literal|209
block|,
literal|205
block|,
comment|/* 48 - 4F */
literal|203
block|,
literal|208
block|,
literal|200
block|,
literal|69
block|,
literal|181
block|,
literal|55
block|,
literal|74
block|,
literal|78
block|,
comment|/* 50 - 57 */
literal|156
block|,
literal|79
block|,
literal|80
block|,
literal|81
block|,
literal|75
block|,
literal|76
block|,
literal|77
block|,
literal|71
block|,
comment|/* 58 - 5F */
literal|72
block|,
literal|73
block|,
literal|82
block|,
literal|83
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* 60 - 67 */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* 68 - 6F */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
literal|221
block|,
name|NN
block|,
comment|/* 70 - 77 */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* 78 - 7F */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* 80 - 87 */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* 88 - 8F */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* 90 - 97 */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* 98 - 9F */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* A0 - A7 */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* A8 - AF */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* B0 - B7 */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* B8 - BF */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* C0 - C7 */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* C8 - CF */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* D0 - D7 */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* D8 - DF */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* E0 - E7 */
name|NN
block|,
name|NN
block|,
name|NN
block|,
literal|219
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
literal|220
block|,
comment|/* E8 - EF */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* F0 - F7 */
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
name|NN
block|,
comment|/* F8 - FF */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KEY_ERROR
value|0x01
end_define

begin_define
define|#
directive|define
name|MAXKEYS
value|(NMOD+2*NKEYCODE)
end_define

begin_struct
struct|struct
name|ukbd_softc
block|{
name|bdevice
name|sc_dev
decl_stmt|;
comment|/* base device */
name|usbd_interface_handle
name|sc_iface
decl_stmt|;
comment|/* interface */
name|usbd_pipe_handle
name|sc_intrpipe
decl_stmt|;
comment|/* interrupt pipe */
name|int
name|sc_ep_addr
decl_stmt|;
name|struct
name|ukbd_data
name|sc_ndata
decl_stmt|;
name|struct
name|ukbd_data
name|sc_odata
decl_stmt|;
name|char
name|sc_enabled
decl_stmt|;
name|char
name|sc_disconnected
decl_stmt|;
comment|/* device is gone */
name|int
name|sc_leds
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|struct
name|device
modifier|*
name|sc_wskbddev
decl_stmt|;
ifdef|#
directive|ifdef
name|WSDISPLAY_COMPAT_RAWKBD
define|#
directive|define
name|REP_DELAY1
value|400
define|#
directive|define
name|REP_DELAYN
value|100
name|int
name|sc_rawkbd
decl_stmt|;
name|int
name|sc_nrep
decl_stmt|;
name|char
name|sc_rep
index|[
name|MAXKEYS
index|]
decl_stmt|;
endif|#
directive|endif
name|int
name|sc_polling
decl_stmt|;
name|int
name|sc_pollchar
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|UKBDUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev))
end_define

begin_define
define|#
directive|define
name|UKBD_CHUNK
value|128
end_define

begin_comment
comment|/* chunk size for read */
end_comment

begin_define
define|#
directive|define
name|UKBD_BSIZE
value|1020
end_define

begin_comment
comment|/* buffer size */
end_comment

begin_decl_stmt
name|void
name|ukbd_cngetc
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|u_int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ukbd_cnpollc
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|const
name|struct
name|wskbd_consops
name|ukbd_consops
init|=
block|{
name|ukbd_cngetc
block|,
name|ukbd_cnpollc
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|ukbd_intr
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|,
name|usbd_private_handle
operator|,
name|usbd_status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ukbd_disco
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ukbd_enable
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ukbd_set_leds
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_decl_stmt
name|int
name|ukbd_ioctl
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|u_long
operator|,
name|caddr_t
operator|,
name|int
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ukbd_cnattach
name|__P
argument_list|(
operator|(
name|void
operator|*
name|v
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ukbd_rawrepeat
name|__P
argument_list|(
operator|(
name|void
operator|*
name|v
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|wskbd_accessops
name|ukbd_accessops
init|=
block|{
name|ukbd_enable
block|,
name|ukbd_set_leds
block|,
name|ukbd_ioctl
block|,
if|#
directive|if
literal|0
block|ukbd_cnattach,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|wskbd_mapdata
name|ukbd_keymapdata
init|=
block|{
name|pckbd_keydesctab
block|,
ifdef|#
directive|ifdef
name|PCKBD_LAYOUT
name|PCKBD_LAYOUT
block|,
else|#
directive|else
name|KB_US
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|USB_DECLARE_DRIVER
argument_list|(
name|ukbd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|USB_MATCH
argument_list|(
argument|ukbd
argument_list|)
end_macro

begin_block
block|{
name|USB_MATCH_START
argument_list|(
name|ukbd
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
comment|/* Check that this is a keyboard that speaks the boot protocol. */
if|if
condition|(
operator|!
name|uaa
operator|->
name|iface
condition|)
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id
operator|||
name|id
operator|->
name|bInterfaceClass
operator|!=
name|UCLASS_HID
operator|||
name|id
operator|->
name|bInterfaceSubClass
operator|!=
name|USUBCLASS_BOOT
operator|||
name|id
operator|->
name|bInterfaceProtocol
operator|!=
name|UPROTO_BOOT_KEYBOARD
condition|)
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
return|return
operator|(
name|UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO
operator|)
return|;
block|}
end_block

begin_macro
name|USB_ATTACH
argument_list|(
argument|ukbd
argument_list|)
end_macro

begin_block
block|{
name|USB_ATTACH_START
argument_list|(
name|ukbd
argument_list|,
name|sc
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|usbd_interface_handle
name|iface
init|=
name|uaa
operator|->
name|iface
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|char
name|devinfo
index|[
literal|1024
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|struct
name|wskbddev_attach_args
name|a
decl_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_disconnected
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_iface
operator|=
name|iface
expr_stmt|;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|iface
argument_list|)
expr_stmt|;
name|usbd_devinfo
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
literal|0
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|USB_ATTACH_SETUP
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %s, iclass %d/%d\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|devinfo
argument_list|,
name|id
operator|->
name|bInterfaceClass
argument_list|,
name|id
operator|->
name|bInterfaceSubClass
argument_list|)
expr_stmt|;
name|ed
operator|=
name|usbd_interface2endpoint_descriptor
argument_list|(
name|iface
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ed
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not read endpoint descriptor\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ukbd_attach: bLength=%d bDescriptorType=%d "
literal|"bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d"
literal|" bInterval=%d\n"
operator|,
name|ed
operator|->
name|bLength
operator|,
name|ed
operator|->
name|bDescriptorType
operator|,
name|ed
operator|->
name|bEndpointAddress
operator|&
name|UE_ADDR
operator|,
name|ed
operator|->
name|bEndpointAddress
operator|&
name|UE_IN
condition|?
literal|"in"
else|:
literal|"out"
operator|,
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|,
name|UGETW
argument_list|(
name|ed
operator|->
name|wMaxPacketSize
argument_list|)
operator|,
name|ed
operator|->
name|bInterval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ed
operator|->
name|bEndpointAddress
operator|&
name|UE_IN
operator|)
operator|!=
name|UE_IN
operator|||
operator|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|!=
name|UE_INTERRUPT
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected endpoint\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|usbd_get_quirks
argument_list|(
name|uaa
operator|->
name|device
argument_list|)
operator|->
name|uq_flags
operator|&
name|UQ_NO_SET_PROTO
operator|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|usbd_set_protocol
argument_list|(
name|iface
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ukbd_attach: protocol set\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|printf
argument_list|(
literal|"%s: set protocol failed\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
block|}
comment|/* Ignore if SETIDLE fails since it is not crucial. */
name|usbd_set_idle
argument_list|(
name|iface
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ep_addr
operator|=
name|ed
operator|->
name|bEndpointAddress
expr_stmt|;
name|sc
operator|->
name|sc_disconnected
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|a
operator|.
name|console
operator|=
literal|0
expr_stmt|;
name|a
operator|.
name|keymap
operator|=
operator|&
name|ukbd_keymapdata
expr_stmt|;
name|a
operator|.
name|accessops
operator|=
operator|&
name|ukbd_accessops
expr_stmt|;
name|a
operator|.
name|accesscookie
operator|=
name|sc
expr_stmt|;
comment|/* Flash the leds; no real purpose, just shows we're alive. */
name|ukbd_set_leds
argument_list|(
name|sc
argument_list|,
name|WSKBD_LED_SCROLL
operator||
name|WSKBD_LED_NUM
operator||
name|WSKBD_LED_CAPS
argument_list|)
expr_stmt|;
name|usbd_delay_ms
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
literal|300
argument_list|)
expr_stmt|;
name|ukbd_set_leds
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_wskbddev
operator|=
name|config_found
argument_list|(
name|self
argument_list|,
operator|&
name|a
argument_list|,
name|wskbddevprint
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* XXX why waste CPU in delay() ? */
comment|/* It's alive!  IT'S ALIVE!  Do a little song and dance. */
name|ukbd_set_leds
argument_list|(
name|sc
argument_list|,
name|NUM_LOCK
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|15000
argument_list|)
expr_stmt|;
name|ukbd_set_leds
argument_list|(
name|sc
argument_list|,
name|CAPS_LOCK
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
name|ukbd_set_leds
argument_list|(
name|sc
argument_list|,
name|SCROLL_LOCK
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|30000
argument_list|)
expr_stmt|;
name|ukbd_set_leds
argument_list|(
name|sc
argument_list|,
name|CAPS_LOCK
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|ukbd_set_leds
argument_list|(
name|sc
argument_list|,
name|NUM_LOCK
argument_list|)
expr_stmt|;
name|ukbd_enable
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|USB_ATTACH_SUCCESS_RETURN
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
name|int
name|ukbd_detach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|ukbd_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|char
modifier|*
name|devinfo
init|=
operator|(
name|char
operator|*
operator|)
name|device_get_desc
argument_list|(
name|self
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_enabled
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|devinfo
condition|)
block|{
name|device_set_desc
argument_list|(
name|self
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|devinfo
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|ukbd_disco
parameter_list|(
name|p
parameter_list|)
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|ukbd_softc
modifier|*
name|sc
init|=
name|p
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ukbd_disco: sc=%p\n"
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
name|usbd_abort_pipe
argument_list|(
name|sc
operator|->
name|sc_intrpipe
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_disconnected
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ukbd_enable
parameter_list|(
name|v
parameter_list|,
name|on
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
name|int
name|on
decl_stmt|;
block|{
name|struct
name|ukbd_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
if|if
condition|(
name|on
condition|)
block|{
comment|/* Set up interrupt pipe. */
if|if
condition|(
name|sc
operator|->
name|sc_enabled
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|->
name|sc_enabled
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|usbd_open_pipe_intr
argument_list|(
name|sc
operator|->
name|sc_iface
argument_list|,
name|sc
operator|->
name|sc_ep_addr
argument_list|,
name|USBD_SHORT_XFER_OK
argument_list|,
operator|&
name|sc
operator|->
name|sc_intrpipe
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ndata
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ndata
argument_list|)
argument_list|,
name|ukbd_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|usbd_set_disco
argument_list|(
name|sc
operator|->
name|sc_intrpipe
argument_list|,
name|ukbd_disco
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Disable interrupts. */
name|usbd_abort_pipe
argument_list|(
name|sc
operator|->
name|sc_intrpipe
argument_list|)
expr_stmt|;
name|usbd_close_pipe
argument_list|(
name|sc
operator|->
name|sc_intrpipe
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_enabled
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ukbd_intr
parameter_list|(
name|reqh
parameter_list|,
name|addr
parameter_list|,
name|status
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
name|usbd_private_handle
name|addr
decl_stmt|;
name|usbd_status
name|status
decl_stmt|;
block|{
name|struct
name|ukbd_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|struct
name|ukbd_data
modifier|*
name|ud
init|=
operator|&
name|sc
operator|->
name|sc_ndata
decl_stmt|;
name|int
name|mod
decl_stmt|,
name|omod
decl_stmt|;
name|int
name|ibuf
index|[
name|MAXKEYS
index|]
decl_stmt|;
comment|/* chars events */
name|int
name|nkeys
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|key
decl_stmt|,
name|c
decl_stmt|;
define|#
directive|define
name|ADDKEY
parameter_list|(
name|c
parameter_list|)
value|ibuf[nkeys++] = (c)
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ukbd_intr: status=%d\n"
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|USBD_CANCELLED
condition|)
return|return;
if|if
condition|(
name|status
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ukbd_intr: status=%d\n"
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
name|usbd_clear_endpoint_stall_async
argument_list|(
name|sc
operator|->
name|sc_intrpipe
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"          mod=0x%02x key0=0x%02x key1=0x%02x\n"
operator|,
name|ud
operator|->
name|modifiers
operator|,
name|ud
operator|->
name|keycode
index|[
literal|0
index|]
operator|,
name|ud
operator|->
name|keycode
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|keycode
index|[
literal|0
index|]
operator|==
name|KEY_ERROR
condition|)
return|return;
comment|/* ignore  */
name|nkeys
operator|=
literal|0
expr_stmt|;
name|mod
operator|=
name|ud
operator|->
name|modifiers
expr_stmt|;
name|omod
operator|=
name|sc
operator|->
name|sc_odata
operator|.
name|modifiers
expr_stmt|;
if|if
condition|(
name|mod
operator|!=
name|omod
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMOD
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|mod
operator|&
name|ukbd_mods
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|!=
operator|(
name|omod
operator|&
name|ukbd_mods
index|[
name|i
index|]
operator|.
name|mask
operator|)
condition|)
name|ADDKEY
argument_list|(
name|ukbd_mods
index|[
name|i
index|]
operator|.
name|key
operator||
operator|(
name|mod
operator|&
name|ukbd_mods
index|[
name|i
index|]
operator|.
name|mask
condition|?
name|PRESS
else|:
name|RELEASE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|ud
operator|->
name|keycode
argument_list|,
name|sc
operator|->
name|sc_odata
operator|.
name|keycode
argument_list|,
name|NKEYCODE
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Check for released keys. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NKEYCODE
condition|;
name|i
operator|++
control|)
block|{
name|key
operator|=
name|sc
operator|->
name|sc_odata
operator|.
name|keycode
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|key
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NKEYCODE
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|key
operator|==
name|ud
operator|->
name|keycode
index|[
name|j
index|]
condition|)
goto|goto
name|rfound
goto|;
name|c
operator|=
name|ukbd_trtab
index|[
name|key
index|]
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|ADDKEY
argument_list|(
name|c
operator||
name|RELEASE
argument_list|)
expr_stmt|;
name|rfound
label|:
empty_stmt|;
block|}
comment|/* Check for pressed keys. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NKEYCODE
condition|;
name|i
operator|++
control|)
block|{
name|key
operator|=
name|ud
operator|->
name|keycode
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|key
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NKEYCODE
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|key
operator|==
name|sc
operator|->
name|sc_odata
operator|.
name|keycode
index|[
name|j
index|]
condition|)
goto|goto
name|pfound
goto|;
name|c
operator|=
name|ukbd_trtab
index|[
name|key
index|]
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ukbd_intr: press key=0x%02x -> 0x%02x\n"
operator|,
name|key
operator|,
name|c
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|ADDKEY
argument_list|(
name|c
operator||
name|PRESS
argument_list|)
expr_stmt|;
name|pfound
label|:
empty_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_odata
operator|=
operator|*
name|ud
expr_stmt|;
if|if
condition|(
name|nkeys
operator|==
literal|0
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_polling
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ukbd_intr: pollchar = 0x%02x\n"
operator|,
name|ibuf
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkeys
operator|>
literal|0
condition|)
name|sc
operator|->
name|sc_pollchar
operator|=
name|ibuf
index|[
literal|0
index|]
expr_stmt|;
comment|/* XXX lost keys? */
return|return;
block|}
ifdef|#
directive|ifdef
name|WSDISPLAY_COMPAT_RAWKBD
if|if
condition|(
name|sc
operator|->
name|sc_rawkbd
condition|)
block|{
name|char
name|cbuf
index|[
name|MAXKEYS
operator|*
literal|2
index|]
decl_stmt|;
name|int
name|npress
decl_stmt|;
for|for
control|(
name|npress
operator|=
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|c
operator|=
name|ibuf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
name|cbuf
index|[
name|j
operator|++
index|]
operator|=
literal|0xe0
expr_stmt|;
name|cbuf
index|[
name|j
index|]
operator|=
name|c
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|RELEASE
condition|)
name|cbuf
index|[
name|j
index|]
operator||=
literal|0x80
expr_stmt|;
else|else
block|{
comment|/* remember keys for autorepeat */
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
name|sc
operator|->
name|sc_rep
index|[
name|npress
operator|++
index|]
operator|=
literal|0xe0
expr_stmt|;
name|sc
operator|->
name|sc_rep
index|[
name|npress
operator|++
index|]
operator|=
name|c
operator|&
literal|0x7f
expr_stmt|;
block|}
block|}
name|wskbd_rawinput
argument_list|(
name|sc
operator|->
name|sc_wskbddev
argument_list|,
name|cbuf
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ukbd_rawrepeat
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|npress
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_nrep
operator|=
name|npress
expr_stmt|;
name|timeout
argument_list|(
name|ukbd_rawrepeat
argument_list|,
name|sc
argument_list|,
name|hz
operator|*
name|REP_DELAY1
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|ibuf
index|[
name|i
index|]
expr_stmt|;
name|wskbd_input
argument_list|(
name|sc
operator|->
name|sc_wskbddev
argument_list|,
name|c
operator|&
name|RELEASE
condition|?
name|WSCONS_EVENT_KEY_UP
else|:
name|WSCONS_EVENT_KEY_DOWN
argument_list|,
name|c
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* XXX shouldn't the keys be used? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|ibuf
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%c (%d) %s\n"
argument_list|,
operator|(
operator|(
name|c
operator|&
literal|0xff
operator|)
operator|<
literal|32
operator|||
operator|(
name|c
operator|&
literal|0xff
operator|)
operator|>
literal|126
condition|?
literal|'.'
else|:
operator|(
name|c
operator|&
literal|0xff
operator|)
operator|)
argument_list|,
name|c
argument_list|,
operator|(
name|c
operator|&
name|RELEASE
condition|?
literal|"released"
else|:
literal|"pressed"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|modifiers
condition|)
name|printf
argument_list|(
literal|"0x%04x\n"
argument_list|,
name|ud
operator|->
name|modifiers
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NKEYCODE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ud
operator|->
name|keycode
index|[
name|i
index|]
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|ud
operator|->
name|keycode
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ukbd_set_leds
parameter_list|(
name|v
parameter_list|,
name|leds
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
name|int
name|leds
decl_stmt|;
block|{
name|struct
name|ukbd_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|u_int8_t
name|res
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ukbd_set_leds: sc=%p leds=%d\n"
operator|,
name|sc
operator|,
name|leds
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_leds
operator|=
name|leds
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|res
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|leds
operator|&
name|WSKBD_LED_SCROLL
condition|)
name|res
operator||=
name|SCROLL_LOCK
expr_stmt|;
if|if
condition|(
name|leds
operator|&
name|WSKBD_LED_NUM
condition|)
name|res
operator||=
name|NUM_LOCK
expr_stmt|;
if|if
condition|(
name|leds
operator|&
name|WSKBD_LED_CAPS
condition|)
name|res
operator||=
name|CAPS_LOCK
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|res
operator|=
name|leds
expr_stmt|;
endif|#
directive|endif
name|usbd_set_report_async
argument_list|(
name|sc
operator|->
name|sc_iface
argument_list|,
name|UHID_OUTPUT_REPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|res
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|WSDISPLAY_COMPAT_RAWKBD
end_ifdef

begin_function
name|void
name|ukbd_rawrepeat
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|ukbd_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|wskbd_rawinput
argument_list|(
name|sc
operator|->
name|sc_wskbddev
argument_list|,
name|sc
operator|->
name|sc_rep
argument_list|,
name|sc
operator|->
name|sc_nrep
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ukbd_rawrepeat
argument_list|,
name|sc
argument_list|,
name|hz
operator|*
name|REP_DELAYN
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ukbd_ioctl
parameter_list|(
name|v
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|ukbd_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|WSKBDIO_GTYPE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|WSKBD_TYPE_USB
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|WSKBDIO_SETLEDS
case|:
name|ukbd_set_leds
argument_list|(
name|v
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|WSKBDIO_GETLEDS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_leds
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|WSDISPLAY_COMPAT_RAWKBD
case|case
name|WSKBDIO_SETMODE
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"ukbd_ioctl: set raw = %d\n"
operator|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rawkbd
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
name|WSKBD_RAW
expr_stmt|;
name|untimeout
argument_list|(
name|ukbd_rawrepeat
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Console interface. */
end_comment

begin_function
name|void
name|ukbd_cngetc
parameter_list|(
name|v
parameter_list|,
name|type
parameter_list|,
name|data
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
name|u_int
modifier|*
name|type
decl_stmt|;
name|int
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|ukbd_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|usbd_lock_token
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ukbd_cngetc: enter\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|usbd_lock
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_polling
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_pollchar
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_pollchar
operator|==
operator|-
literal|1
condition|)
name|usbd_dopoll
argument_list|(
name|sc
operator|->
name|sc_iface
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_polling
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|sc
operator|->
name|sc_pollchar
expr_stmt|;
operator|*
name|type
operator|=
name|c
operator|&
name|RELEASE
condition|?
name|WSCONS_EVENT_KEY_UP
else|:
name|WSCONS_EVENT_KEY_DOWN
expr_stmt|;
operator|*
name|data
operator|=
name|c
operator|&
literal|0xff
expr_stmt|;
name|usbd_unlock
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ukbd_cngetc: return 0x%02x\n"
operator|,
name|c
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ukbd_cnpollc
parameter_list|(
name|v
parameter_list|,
name|on
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
name|int
name|on
decl_stmt|;
block|{
name|struct
name|ukbd_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ukbd_cnpollc: sc=%p on=%d\n"
operator|,
name|v
operator|,
name|on
operator|)
argument_list|)
expr_stmt|;
name|usbd_set_polling
argument_list|(
name|sc
operator|->
name|sc_iface
argument_list|,
name|on
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ukbd_cnattach
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|ukbd_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ukbd_cnattach: sc=%p\n"
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
name|wskbd_cnattach
argument_list|(
operator|&
name|ukbd_consops
argument_list|,
name|sc
argument_list|,
operator|&
name|ukbd_keymapdata
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NetBSD */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ukbd
argument_list|,
name|usb
argument_list|,
name|ukbd_driver
argument_list|,
name|ukbd_devclass
argument_list|,
name|usbd_driver_load
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

