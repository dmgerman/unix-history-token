begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2008 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|usb_proc_debug
end_define

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|700000
operator|)
end_if

begin_define
define|#
directive|define
name|thread_lock
parameter_list|(
name|td
parameter_list|)
value|mtx_lock_spin(&sched_lock)
end_define

begin_define
define|#
directive|define
name|thread_unlock
parameter_list|(
name|td
parameter_list|)
value|mtx_unlock_spin(&sched_lock)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|800000
operator|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|usbproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usb_pcount
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USB_THREAD_CREATE
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|,
name|p
parameter_list|,
modifier|...
parameter_list|)
define|\
value|kproc_kthread_add((f), (s),&usbproc, (p), RFHIGHPID, \ 		    0, "usb", __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|USB_THREAD_SUSPEND
parameter_list|(
name|p
parameter_list|)
value|kthread_suspend(p,0)
end_define

begin_define
define|#
directive|define
name|USB_THREAD_EXIT
parameter_list|(
name|err
parameter_list|)
value|kthread_exit()
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USB_THREAD_CREATE
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|,
name|p
parameter_list|,
modifier|...
parameter_list|)
define|\
value|kthread_create((f), (s), (p), RFHIGHPID, 0, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|USB_THREAD_SUSPEND
parameter_list|(
name|p
parameter_list|)
value|kthread_suspend(p,0)
end_define

begin_define
define|#
directive|define
name|USB_THREAD_EXIT
parameter_list|(
name|err
parameter_list|)
value|kthread_exit(err)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|usb_proc_debug
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|proc
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB process"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_proc
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|usb_proc_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.proc.debug"
argument_list|,
operator|&
name|usb_proc_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_process  *  * This function is the USB process dispatcher.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_process
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|usb_process
modifier|*
name|up
init|=
name|arg
decl_stmt|;
name|struct
name|usb_proc_msg
modifier|*
name|pm
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
comment|/* adjust priority */
name|td
operator|=
name|curthread
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_prio
argument_list|(
name|td
argument_list|,
name|up
operator|->
name|up_prio
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|up
operator|->
name|up_mtx
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_curtd
operator|=
name|td
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|up
operator|->
name|up_gone
condition|)
break|break;
comment|/* 		 * NOTE to reimplementors: dequeueing a command from the 		 * "used" queue and executing it must be atomic, with regard 		 * to the "up_mtx" mutex. That means any attempt to queue a 		 * command by another thread must be blocked until either: 		 * 		 * 1) the command sleeps 		 * 		 * 2) the command returns 		 * 		 * Here is a practical example that shows how this helps 		 * solving a problem: 		 * 		 * Assume that you want to set the baud rate on a USB serial 		 * device. During the programming of the device you don't 		 * want to receive nor transmit any data, because it will be 		 * garbage most likely anyway. The programming of our USB 		 * device takes 20 milliseconds and it needs to call 		 * functions that sleep. 		 * 		 * Non-working solution: Before we queue the programming 		 * command, we stop transmission and reception of data. Then 		 * we queue a programming command. At the end of the 		 * programming command we enable transmission and reception 		 * of data. 		 * 		 * Problem: If a second programming command is queued while the 		 * first one is sleeping, we end up enabling transmission 		 * and reception of data too early. 		 * 		 * Working solution: Before we queue the programming command, 		 * we stop transmission and reception of data. Then we queue 		 * a programming command. Then we queue a second command 		 * that only enables transmission and reception of data. 		 * 		 * Why it works: If a second programming command is queued 		 * while the first one is sleeping, then the queueing of a 		 * second command to enable the data transfers, will cause 		 * the previous one, which is still on the queue, to be 		 * removed from the queue, and re-inserted after the last 		 * baud rate programming command, which then gives the 		 * desired result. 		 */
name|pm
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|up
operator|->
name|up_qhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Message pm=%p, cb=%p (enter)\n"
argument_list|,
name|pm
argument_list|,
name|pm
operator|->
name|pm_callback
argument_list|)
expr_stmt|;
call|(
name|pm
operator|->
name|pm_callback
call|)
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|TAILQ_FIRST
argument_list|(
operator|&
name|up
operator|->
name|up_qhead
argument_list|)
condition|)
block|{
comment|/* nothing changed */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|up
operator|->
name|up_qhead
argument_list|,
name|pm
argument_list|,
name|pm_qentry
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_qentry
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"Message pm=%p (leave)\n"
argument_list|,
name|pm
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* end if messages - check if anyone is waiting for sync */
if|if
condition|(
name|up
operator|->
name|up_dsleep
condition|)
block|{
name|up
operator|->
name|up_dsleep
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|up
operator|->
name|up_drain
argument_list|)
expr_stmt|;
block|}
name|up
operator|->
name|up_msleep
operator|=
literal|1
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|up
operator|->
name|up_cv
argument_list|,
name|up
operator|->
name|up_mtx
argument_list|)
expr_stmt|;
block|}
name|up
operator|->
name|up_ptr
operator|=
name|NULL
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|up
operator|->
name|up_cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|up
operator|->
name|up_mtx
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|800000
operator|)
comment|/* Clear the proc pointer if this is the last thread. */
if|if
condition|(
operator|--
name|usb_pcount
operator|==
literal|0
condition|)
name|usbproc
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|USB_THREAD_EXIT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_proc_create  *  * This function will create a process using the given "prio" that can  * execute callbacks. The mutex pointed to by "p_mtx" will be applied  * before calling the callbacks and released after that the callback  * has returned. The structure pointed to by "up" is assumed to be  * zeroed before this function is called.  *  * Return values:  *    0: success  * Else: failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb_proc_create
parameter_list|(
name|struct
name|usb_process
modifier|*
name|up
parameter_list|,
name|struct
name|mtx
modifier|*
name|p_mtx
parameter_list|,
specifier|const
name|char
modifier|*
name|pmesg
parameter_list|,
name|uint8_t
name|prio
parameter_list|)
block|{
name|up
operator|->
name|up_mtx
operator|=
name|p_mtx
expr_stmt|;
name|up
operator|->
name|up_prio
operator|=
name|prio
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|up
operator|->
name|up_qhead
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|up
operator|->
name|up_cv
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|up
operator|->
name|up_drain
argument_list|,
literal|"usbdrain"
argument_list|)
expr_stmt|;
if|if
condition|(
name|USB_THREAD_CREATE
argument_list|(
operator|&
name|usb_process
argument_list|,
name|up
argument_list|,
operator|&
name|up
operator|->
name|up_ptr
argument_list|,
name|pmesg
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Unable to create USB process."
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_ptr
operator|=
name|NULL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|800000
operator|)
name|usb_pcount
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|usb_proc_free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_proc_free  *  * NOTE: If the structure pointed to by "up" is all zero, this  * function does nothing.  *  * NOTE: Messages that are pending on the process queue will not be  * removed nor called.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_proc_free
parameter_list|(
name|struct
name|usb_process
modifier|*
name|up
parameter_list|)
block|{
comment|/* check if not initialised */
if|if
condition|(
name|up
operator|->
name|up_mtx
operator|==
name|NULL
condition|)
return|return;
name|usb_proc_drain
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|up
operator|->
name|up_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|up
operator|->
name|up_drain
argument_list|)
expr_stmt|;
comment|/* make sure that we do not enter here again */
name|up
operator|->
name|up_mtx
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_proc_msignal  *  * This function will queue one of the passed USB process messages on  * the USB process queue. The first message that is not already queued  * will get queued. If both messages are already queued the one queued  * last will be removed from the queue and queued in the end. The USB  * process mutex must be locked when calling this function. This  * function exploits the fact that a process can only do one callback  * at a time. The message that was queued is returned.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
modifier|*
name|usb_proc_msignal
parameter_list|(
name|struct
name|usb_process
modifier|*
name|up
parameter_list|,
name|void
modifier|*
name|_pm0
parameter_list|,
name|void
modifier|*
name|_pm1
parameter_list|)
block|{
name|struct
name|usb_proc_msg
modifier|*
name|pm0
init|=
name|_pm0
decl_stmt|;
name|struct
name|usb_proc_msg
modifier|*
name|pm1
init|=
name|_pm1
decl_stmt|;
name|struct
name|usb_proc_msg
modifier|*
name|pm2
decl_stmt|;
name|usb_size_t
name|d
decl_stmt|;
name|uint8_t
name|t
decl_stmt|;
comment|/* check if gone, return dummy value */
if|if
condition|(
name|up
operator|->
name|up_gone
condition|)
return|return
operator|(
name|_pm0
operator|)
return|;
name|mtx_assert
argument_list|(
name|up
operator|->
name|up_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pm0
operator|->
name|pm_qentry
operator|.
name|tqe_prev
condition|)
block|{
name|t
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pm1
operator|->
name|pm_qentry
operator|.
name|tqe_prev
condition|)
block|{
name|t
operator||=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No entries are queued. Queue "pm0" and use the existing 		 * message number. 		 */
name|pm2
operator|=
name|pm0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
literal|1
condition|)
block|{
comment|/* Check if we need to increment the message number. */
if|if
condition|(
name|pm0
operator|->
name|pm_num
operator|==
name|up
operator|->
name|up_msg_num
condition|)
block|{
name|up
operator|->
name|up_msg_num
operator|++
expr_stmt|;
block|}
name|pm2
operator|=
name|pm1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
literal|2
condition|)
block|{
comment|/* Check if we need to increment the message number. */
if|if
condition|(
name|pm1
operator|->
name|pm_num
operator|==
name|up
operator|->
name|up_msg_num
condition|)
block|{
name|up
operator|->
name|up_msg_num
operator|++
expr_stmt|;
block|}
name|pm2
operator|=
name|pm0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
literal|3
condition|)
block|{
comment|/* 		 * Both entries are queued. Re-queue the entry closest to 		 * the end. 		 */
name|d
operator|=
operator|(
name|pm1
operator|->
name|pm_num
operator|-
name|pm0
operator|->
name|pm_num
operator|)
expr_stmt|;
comment|/* Check sign after subtraction */
if|if
condition|(
name|d
operator|&
literal|0x80000000
condition|)
block|{
name|pm2
operator|=
name|pm0
expr_stmt|;
block|}
else|else
block|{
name|pm2
operator|=
name|pm1
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|up
operator|->
name|up_qhead
argument_list|,
name|pm2
argument_list|,
name|pm_qentry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pm2
operator|=
name|NULL
expr_stmt|;
comment|/* panic - should not happen */
block|}
name|DPRINTF
argument_list|(
literal|" t=%u, num=%u\n"
argument_list|,
name|t
argument_list|,
name|up
operator|->
name|up_msg_num
argument_list|)
expr_stmt|;
comment|/* Put message last on queue */
name|pm2
operator|->
name|pm_num
operator|=
name|up
operator|->
name|up_msg_num
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|up
operator|->
name|up_qhead
argument_list|,
name|pm2
argument_list|,
name|pm_qentry
argument_list|)
expr_stmt|;
comment|/* Check if we need to wakeup the USB process. */
if|if
condition|(
name|up
operator|->
name|up_msleep
condition|)
block|{
name|up
operator|->
name|up_msleep
operator|=
literal|0
expr_stmt|;
comment|/* save "cv_signal()" calls */
name|cv_signal
argument_list|(
operator|&
name|up
operator|->
name|up_cv
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pm2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_proc_is_gone  *  * Return values:  *    0: USB process is running  * Else: USB process is tearing down  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usb_proc_is_gone
parameter_list|(
name|struct
name|usb_process
modifier|*
name|up
parameter_list|)
block|{
if|if
condition|(
name|up
operator|->
name|up_gone
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|mtx_assert
argument_list|(
name|up
operator|->
name|up_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_proc_mwait  *  * This function will return when the USB process message pointed to  * by "pm" is no longer on a queue. This function must be called  * having "up->up_mtx" locked.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_proc_mwait
parameter_list|(
name|struct
name|usb_process
modifier|*
name|up
parameter_list|,
name|void
modifier|*
name|_pm0
parameter_list|,
name|void
modifier|*
name|_pm1
parameter_list|)
block|{
name|struct
name|usb_proc_msg
modifier|*
name|pm0
init|=
name|_pm0
decl_stmt|;
name|struct
name|usb_proc_msg
modifier|*
name|pm1
init|=
name|_pm1
decl_stmt|;
comment|/* check if gone */
if|if
condition|(
name|up
operator|->
name|up_gone
condition|)
return|return;
name|mtx_assert
argument_list|(
name|up
operator|->
name|up_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|up_curtd
operator|==
name|curthread
condition|)
block|{
comment|/* Just remove the messages from the queue. */
if|if
condition|(
name|pm0
operator|->
name|pm_qentry
operator|.
name|tqe_prev
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|up
operator|->
name|up_qhead
argument_list|,
name|pm0
argument_list|,
name|pm_qentry
argument_list|)
expr_stmt|;
name|pm0
operator|->
name|pm_qentry
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pm1
operator|->
name|pm_qentry
operator|.
name|tqe_prev
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|up
operator|->
name|up_qhead
argument_list|,
name|pm1
argument_list|,
name|pm_qentry
argument_list|)
expr_stmt|;
name|pm1
operator|->
name|pm_qentry
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
while|while
condition|(
name|pm0
operator|->
name|pm_qentry
operator|.
name|tqe_prev
operator|||
name|pm1
operator|->
name|pm_qentry
operator|.
name|tqe_prev
condition|)
block|{
comment|/* check if config thread is gone */
if|if
condition|(
name|up
operator|->
name|up_gone
condition|)
break|break;
name|up
operator|->
name|up_dsleep
operator|=
literal|1
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|up
operator|->
name|up_drain
argument_list|,
name|up
operator|->
name|up_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_proc_drain  *  * This function will tear down an USB process, waiting for the  * currently executing command to return.  *  * NOTE: If the structure pointed to by "up" is all zero,  * this function does nothing.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_proc_drain
parameter_list|(
name|struct
name|usb_process
modifier|*
name|up
parameter_list|)
block|{
comment|/* check if not initialised */
if|if
condition|(
name|up
operator|->
name|up_mtx
operator|==
name|NULL
condition|)
return|return;
comment|/* handle special case with Giant */
if|if
condition|(
name|up
operator|->
name|up_mtx
operator|!=
operator|&
name|Giant
condition|)
name|mtx_assert
argument_list|(
name|up
operator|->
name|up_mtx
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|up
operator|->
name|up_mtx
argument_list|)
expr_stmt|;
comment|/* Set the gone flag */
name|up
operator|->
name|up_gone
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|up
operator|->
name|up_ptr
condition|)
block|{
comment|/* Check if we need to wakeup the USB process */
if|if
condition|(
name|up
operator|->
name|up_msleep
operator|||
name|up
operator|->
name|up_csleep
condition|)
block|{
name|up
operator|->
name|up_msleep
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|up_csleep
operator|=
literal|0
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|up
operator|->
name|up_cv
argument_list|)
expr_stmt|;
block|}
comment|/* Check if we are still cold booted */
if|if
condition|(
name|cold
condition|)
block|{
name|USB_THREAD_SUSPEND
argument_list|(
name|up
operator|->
name|up_ptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"WARNING: A USB process has "
literal|"been left suspended!\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|cv_wait
argument_list|(
operator|&
name|up
operator|->
name|up_cv
argument_list|,
name|up
operator|->
name|up_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* Check if someone is waiting - should not happen */
if|if
condition|(
name|up
operator|->
name|up_dsleep
condition|)
block|{
name|up
operator|->
name|up_dsleep
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|up
operator|->
name|up_drain
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"WARNING: Someone is waiting "
literal|"for USB process drain!\n"
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
name|up
operator|->
name|up_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_proc_rewakeup  *  * This function is called to re-wakeup the the given USB  * process. This usually happens after that the USB system has been in  * polling mode, like during a panic. This function must be called  * having "up->up_mtx" locked.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_proc_rewakeup
parameter_list|(
name|struct
name|usb_process
modifier|*
name|up
parameter_list|)
block|{
comment|/* check if not initialised */
if|if
condition|(
name|up
operator|->
name|up_mtx
operator|==
name|NULL
condition|)
return|return;
comment|/* check if gone */
if|if
condition|(
name|up
operator|->
name|up_gone
condition|)
return|return;
name|mtx_assert
argument_list|(
name|up
operator|->
name|up_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|up_msleep
operator|==
literal|0
condition|)
block|{
comment|/* re-wakeup */
name|cv_signal
argument_list|(
operator|&
name|up
operator|->
name|up_cv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

