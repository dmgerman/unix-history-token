begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: ugen.c,v 1.79 2006/03/01 12:38:13 yamt Exp $	*/
end_comment

begin_comment
comment|/* Also already merged from NetBSD:  *	$NetBSD: ugen.c,v 1.61 2002/09/23 05:51:20 simonb Exp $  *	$NetBSD: ugen.c,v 1.64 2003/06/28 14:21:46 darrenr Exp $  *	$NetBSD: ugen.c,v 1.65 2003/06/29 22:30:56 fvdl Exp $  *	$NetBSD: ugen.c,v 1.68 2004/06/23 02:30:52 mycroft Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Copyright (c) 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (lennart@augustsson.net) at  * Carlstedt Research& Technology.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the NetBSD  *	Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (ugendebug) printf x
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (ugendebug>(n)) printf x
end_define

begin_decl_stmt
name|int
name|ugendebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|ugen
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB ugen"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_ugen
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ugendebug
argument_list|,
literal|0
argument_list|,
literal|"ugen debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UGEN_CHUNK
value|128
end_define

begin_comment
comment|/* chunk size for read */
end_comment

begin_define
define|#
directive|define
name|UGEN_IBSIZE
value|1020
end_define

begin_comment
comment|/* buffer size */
end_comment

begin_define
define|#
directive|define
name|UGEN_BBSIZE
value|1024
end_define

begin_define
define|#
directive|define
name|UGEN_NISOFRAMES
value|500
end_define

begin_comment
comment|/* 0.5 seconds worth */
end_comment

begin_define
define|#
directive|define
name|UGEN_NISOREQS
value|6
end_define

begin_comment
comment|/* number of outstanding xfer requests */
end_comment

begin_define
define|#
directive|define
name|UGEN_NISORFRMS
value|4
end_define

begin_comment
comment|/* number of frames (miliseconds) per req */
end_comment

begin_struct
struct|struct
name|ugen_endpoint
block|{
name|struct
name|ugen_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|edesc
decl_stmt|;
name|usbd_interface_handle
name|iface
decl_stmt|;
name|int
name|state
decl_stmt|;
define|#
directive|define
name|UGEN_ASLP
value|0x02
comment|/* waiting for data */
define|#
directive|define
name|UGEN_SHORT_OK
value|0x04
comment|/* short xfers are OK */
name|usbd_pipe_handle
name|pipeh
decl_stmt|;
name|struct
name|clist
name|q
decl_stmt|;
name|struct
name|selinfo
name|rsel
decl_stmt|;
name|u_char
modifier|*
name|ibuf
decl_stmt|;
comment|/* start of buffer (circular for isoc) */
name|u_char
modifier|*
name|fill
decl_stmt|;
comment|/* location for input (isoc) */
name|u_char
modifier|*
name|limit
decl_stmt|;
comment|/* end of circular buffer (isoc) */
name|u_char
modifier|*
name|cur
decl_stmt|;
comment|/* current read location (isoc) */
name|u_int32_t
name|timeout
decl_stmt|;
struct|struct
name|isoreq
block|{
name|struct
name|ugen_endpoint
modifier|*
name|sce
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|void
modifier|*
name|dmabuf
decl_stmt|;
name|u_int16_t
name|sizes
index|[
name|UGEN_NISORFRMS
index|]
decl_stmt|;
block|}
name|isoreqs
index|[
name|UGEN_NISOREQS
index|]
struct|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ugen_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
comment|/* base device */
name|usbd_device_handle
name|sc_udev
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|char
name|sc_is_open
index|[
name|USB_MAX_ENDPOINTS
index|]
decl_stmt|;
name|struct
name|ugen_endpoint
name|sc_endpoints
index|[
name|USB_MAX_ENDPOINTS
index|]
index|[
literal|2
index|]
decl_stmt|;
define|#
directive|define
name|OUT
value|0
define|#
directive|define
name|IN
value|1
define|#
directive|define
name|UGEN_DEV_REF
parameter_list|(
name|dev
parameter_list|,
name|sc
parameter_list|)
define|\
value|if ((sc)->sc_dying || dev_refthread(dev) == NULL)	\ 		return (ENXIO)
define|#
directive|define
name|UGEN_DEV_RELE
parameter_list|(
name|dev
parameter_list|,
name|sc
parameter_list|)
define|\
value|dev_relthread(dev)
define|#
directive|define
name|UGEN_DEV_OPEN
parameter_list|(
name|dev
parameter_list|,
name|sc
parameter_list|)
block|\
comment|/* handled by dev layer */
define|#
directive|define
name|UGEN_DEV_CLOSE
parameter_list|(
name|dev
parameter_list|,
name|sc
parameter_list|)
block|\
comment|/* handled by dev layer */
name|u_char
name|sc_dying
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|d_open_t
name|ugenopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_close_t
name|ugenclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_read_t
name|ugenread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_write_t
name|ugenwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_ioctl_t
name|ugenioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_poll_t
name|ugenpoll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_purge_t
name|ugenpurge
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ugenctl_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|ugenopen
block|,
operator|.
name|d_close
operator|=
name|ugenclose
block|,
operator|.
name|d_ioctl
operator|=
name|ugenioctl
block|,
operator|.
name|d_purge
operator|=
name|ugenpurge
block|,
operator|.
name|d_name
operator|=
literal|"ugenctl"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ugen_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|ugenopen
block|,
operator|.
name|d_close
operator|=
name|ugenclose
block|,
operator|.
name|d_read
operator|=
name|ugenread
block|,
operator|.
name|d_write
operator|=
name|ugenwrite
block|,
operator|.
name|d_ioctl
operator|=
name|ugenioctl
block|,
operator|.
name|d_poll
operator|=
name|ugenpoll
block|,
operator|.
name|d_purge
operator|=
name|ugenpurge
block|,
operator|.
name|d_name
operator|=
literal|"ugen"
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ugenintr
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|addr
parameter_list|,
name|usbd_status
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ugen_isoc_rintr
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|addr
parameter_list|,
name|usbd_status
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ugen_do_read
parameter_list|(
name|struct
name|ugen_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ugen_do_write
parameter_list|(
name|struct
name|ugen_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ugen_do_ioctl
parameter_list|(
name|struct
name|ugen_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ugen_make_devnodes
parameter_list|(
name|struct
name|ugen_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ugen_destroy_devnodes
parameter_list|(
name|struct
name|ugen_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ugen_set_config
parameter_list|(
name|struct
name|ugen_softc
modifier|*
name|sc
parameter_list|,
name|int
name|configno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_config_descriptor_t
modifier|*
name|ugen_get_cdesc
parameter_list|(
name|struct
name|ugen_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ugen_set_interface
parameter_list|(
name|struct
name|ugen_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ugen_get_alt_index
parameter_list|(
name|struct
name|ugen_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ifaceidx
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|UGENUNIT
parameter_list|(
name|n
parameter_list|)
value|((minor(n)>> 4)& 0xf)
end_define

begin_define
define|#
directive|define
name|UGENENDPOINT
parameter_list|(
name|n
parameter_list|)
value|(minor(n)& 0xf)
end_define

begin_define
define|#
directive|define
name|UGENMINOR
parameter_list|(
name|u
parameter_list|,
name|e
parameter_list|)
value|(((u)<< 4) | (e))
end_define

begin_decl_stmt
specifier|static
name|device_probe_t
name|ugen_match
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|ugen_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|ugen_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ugen_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ugen_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ugen_match
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ugen_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ugen_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ugen_driver
init|=
block|{
literal|"ugen"
block|,
name|ugen_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ugen_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ugen
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|ugen_match
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|self
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|if (uaa->matchlvl) 		return (uaa->matchlvl);
endif|#
directive|endif
if|if
condition|(
name|uaa
operator|->
name|usegeneric
condition|)
return|return
operator|(
name|UMATCH_GENERIC
operator|)
return|;
else|else
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ugen_attach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|ugen_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|usbd_device_handle
name|udev
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|conf
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|self
expr_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_endpoints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|sc_endpoints
argument_list|)
expr_stmt|;
comment|/* First set configuration index 0, the default one for ugen. */
name|err
operator|=
name|usbd_set_config_index
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"%s: setting configuration index 0 failed\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|conf
operator|=
name|usbd_get_config_descriptor
argument_list|(
name|udev
argument_list|)
operator|->
name|bConfigurationValue
expr_stmt|;
comment|/* Set up all the local state for this configuration. */
name|err
operator|=
name|ugen_set_config
argument_list|(
name|sc
argument_list|,
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"%s: setting configuration %d failed\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* the main device, ctrl endpoint */
name|sc
operator|->
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|ugenctl_cdevsw
argument_list|,
name|UGENMINOR
argument_list|(
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0644
argument_list|,
literal|"%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ugen_make_devnodes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|usbd_add_drv_event
argument_list|(
name|USB_EVENT_DRIVER_ATTACH
argument_list|,
name|sc
operator|->
name|sc_udev
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ugen_make_devnodes
parameter_list|(
name|struct
name|ugen_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|endptno
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
for|for
control|(
name|endptno
operator|=
literal|1
init|;
name|endptno
operator|<
name|USB_MAX_ENDPOINTS
condition|;
name|endptno
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_endpoints
index|[
name|endptno
index|]
index|[
name|IN
index|]
operator|.
name|sc
operator|!=
name|NULL
operator|||
name|sc
operator|->
name|sc_endpoints
index|[
name|endptno
index|]
index|[
name|OUT
index|]
operator|.
name|sc
operator|!=
name|NULL
condition|)
block|{
comment|/* endpt can be 0x81 and 0x01, representing 			 * endpoint address 0x01 and IN/OUT directions. 			 * We map both endpts to the same device, 			 * IN is reading from it, OUT is writing to it. 			 * 			 * In the if clause above we check whether one 			 * of the structs is populated. 			 */
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|ugen_cdevsw
argument_list|,
name|UGENMINOR
argument_list|(
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|endptno
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0644
argument_list|,
literal|"%s.%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|endptno
argument_list|)
expr_stmt|;
name|dev_depends
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_endpoints
index|[
name|endptno
index|]
index|[
name|IN
index|]
operator|.
name|sc
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_endpoints
index|[
name|endptno
index|]
index|[
name|IN
index|]
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_endpoints
index|[
name|endptno
index|]
index|[
name|OUT
index|]
operator|.
name|sc
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_endpoints
index|[
name|endptno
index|]
index|[
name|OUT
index|]
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ugen_destroy_devnodes
parameter_list|(
name|struct
name|ugen_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|endptno
decl_stmt|,
name|prev_sc_dying
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|prev_sc_dying
operator|=
name|sc
operator|->
name|sc_dying
expr_stmt|;
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
comment|/* destroy all devices for the other (existing) endpoints as well */
for|for
control|(
name|endptno
operator|=
literal|1
init|;
name|endptno
operator|<
name|USB_MAX_ENDPOINTS
condition|;
name|endptno
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_endpoints
index|[
name|endptno
index|]
index|[
name|IN
index|]
operator|.
name|sc
operator|!=
name|NULL
operator|||
name|sc
operator|->
name|sc_endpoints
index|[
name|endptno
index|]
index|[
name|OUT
index|]
operator|.
name|sc
operator|!=
name|NULL
condition|)
block|{
comment|/* endpt can be 0x81 and 0x01, representing 			 * endpoint address 0x01 and IN/OUT directions. 			 * We map both endpoint addresses to the same device, 			 * IN is reading from it, OUT is writing to it. 			 * 			 * In the if clause above we check whether one 			 * of the structs is populated. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_endpoints
index|[
name|endptno
index|]
index|[
name|IN
index|]
operator|.
name|sc
operator|!=
name|NULL
condition|)
name|dev
operator|=
name|sc
operator|->
name|sc_endpoints
index|[
name|endptno
index|]
index|[
name|IN
index|]
operator|.
name|dev
expr_stmt|;
else|else
name|dev
operator|=
name|sc
operator|->
name|sc_endpoints
index|[
name|endptno
index|]
index|[
name|OUT
index|]
operator|.
name|dev
expr_stmt|;
name|KASSERT
argument_list|(
name|dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"ugen_destroy_devnodes: NULL dev"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_endpoints
index|[
name|endptno
index|]
index|[
name|IN
index|]
operator|.
name|sc
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_endpoints
index|[
name|endptno
index|]
index|[
name|OUT
index|]
operator|.
name|sc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_dying
operator|=
name|prev_sc_dying
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ugen_set_config
parameter_list|(
name|struct
name|ugen_softc
modifier|*
name|sc
parameter_list|,
name|int
name|configno
parameter_list|)
block|{
name|usbd_device_handle
name|dev
init|=
name|sc
operator|->
name|sc_udev
decl_stmt|;
name|usbd_interface_handle
name|iface
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
decl_stmt|;
name|struct
name|ugen_endpoint
modifier|*
name|sce
decl_stmt|,
modifier|*
modifier|*
name|sce_cache
decl_stmt|,
modifier|*
modifier|*
modifier|*
name|sce_cache_arr
decl_stmt|;
name|u_int8_t
name|niface
decl_stmt|,
name|niface_cache
decl_stmt|,
name|nendpt
decl_stmt|,
modifier|*
name|nendpt_cache
decl_stmt|;
name|int
name|ifaceno
decl_stmt|,
name|endptno
decl_stmt|,
name|endpt
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ugen_set_config: %s to configno %d, sc=%p\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|configno
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
comment|/* We start at 1, not 0, because we don't care whether the 	 * control endpoint is open or not. It is always present. 	 */
for|for
control|(
name|endptno
operator|=
literal|1
init|;
name|endptno
operator|<
name|USB_MAX_ENDPOINTS
condition|;
name|endptno
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_is_open
index|[
name|endptno
index|]
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ugen_set_config: %s - endpoint %d is open\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|endptno
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_USE
operator|)
return|;
block|}
name|err
operator|=
name|usbd_interface_count
argument_list|(
name|dev
argument_list|,
operator|&
name|niface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* store an array of endpoint descriptors to clear if the configuration 	 * change succeeds - these aren't available afterwards */
name|nendpt_cache
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
operator|*
name|niface
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sce_cache_arr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ugen_endpoint
operator|*
operator|*
argument_list|)
operator|*
name|niface
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|niface_cache
operator|=
name|niface
expr_stmt|;
for|for
control|(
name|ifaceno
operator|=
literal|0
init|;
name|ifaceno
operator|<
name|niface
condition|;
name|ifaceno
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ugen_set_config: ifaceno %d\n"
operator|,
name|ifaceno
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_device2interface_handle
argument_list|(
name|dev
argument_list|,
name|ifaceno
argument_list|,
operator|&
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"ugen_set_config: can't obtain interface handle"
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_endpoint_count
argument_list|(
name|iface
argument_list|,
operator|&
name|nendpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"ugen_set_config: endpoint count failed"
argument_list|)
expr_stmt|;
comment|/* store endpoint descriptors for each interface */
name|nendpt_cache
index|[
name|ifaceno
index|]
operator|=
name|nendpt
expr_stmt|;
name|sce_cache
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ugen_endpoint
operator|*
argument_list|)
operator|*
name|nendpt
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sce_cache_arr
index|[
name|ifaceno
index|]
operator|=
name|sce_cache
expr_stmt|;
for|for
control|(
name|endptno
operator|=
literal|0
init|;
name|endptno
operator|<
name|nendpt
condition|;
name|endptno
operator|++
control|)
block|{
name|ed
operator|=
name|usbd_interface2endpoint_descriptor
argument_list|(
name|iface
argument_list|,
name|endptno
argument_list|)
expr_stmt|;
name|endpt
operator|=
name|ed
operator|->
name|bEndpointAddress
expr_stmt|;
name|dir
operator|=
name|UE_GET_DIR
argument_list|(
name|endpt
argument_list|)
operator|==
name|UE_DIR_IN
condition|?
name|IN
else|:
name|OUT
expr_stmt|;
name|sce_cache
index|[
name|endptno
index|]
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|UE_GET_ADDR
argument_list|(
name|endpt
argument_list|)
index|]
index|[
name|dir
index|]
expr_stmt|;
block|}
block|}
comment|/* Avoid setting the current value. */
if|if
condition|(
name|usbd_get_config_descriptor
argument_list|(
name|dev
argument_list|)
operator|->
name|bConfigurationValue
operator|!=
name|configno
condition|)
block|{
comment|/* attempt to perform the configuration change */
name|err
operator|=
name|usbd_set_config_no
argument_list|(
name|dev
argument_list|,
name|configno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
for|for
control|(
name|ifaceno
operator|=
literal|0
init|;
name|ifaceno
operator|<
name|niface_cache
condition|;
name|ifaceno
operator|++
control|)
name|free
argument_list|(
name|sce_cache_arr
index|[
name|ifaceno
index|]
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sce_cache_arr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nendpt_cache
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
name|ugen_destroy_devnodes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* now we can clear the old interface's ugen_endpoints */
for|for
control|(
name|ifaceno
operator|=
literal|0
init|;
name|ifaceno
operator|<
name|niface_cache
condition|;
name|ifaceno
operator|++
control|)
block|{
name|sce_cache
operator|=
name|sce_cache_arr
index|[
name|ifaceno
index|]
expr_stmt|;
for|for
control|(
name|endptno
operator|=
literal|0
init|;
name|endptno
operator|<
name|nendpt_cache
index|[
name|ifaceno
index|]
condition|;
name|endptno
operator|++
control|)
block|{
name|sce
operator|=
name|sce_cache
index|[
name|endptno
index|]
expr_stmt|;
name|sce
operator|->
name|sc
operator|=
literal|0
expr_stmt|;
name|sce
operator|->
name|edesc
operator|=
literal|0
expr_stmt|;
name|sce
operator|->
name|iface
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* and free the cache storing them */
for|for
control|(
name|ifaceno
operator|=
literal|0
init|;
name|ifaceno
operator|<
name|niface_cache
condition|;
name|ifaceno
operator|++
control|)
name|free
argument_list|(
name|sce_cache_arr
index|[
name|ifaceno
index|]
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sce_cache_arr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nendpt_cache
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
comment|/* no endpoints if the device is in the unconfigured state */
if|if
condition|(
name|configno
operator|!=
name|USB_UNCONFIG_NO
condition|)
block|{
comment|/* set the new configuration's ugen_endpoints */
name|err
operator|=
name|usbd_interface_count
argument_list|(
name|dev
argument_list|,
operator|&
name|niface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"ugen_set_config: interface count failed"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_endpoints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|sc_endpoints
argument_list|)
expr_stmt|;
for|for
control|(
name|ifaceno
operator|=
literal|0
init|;
name|ifaceno
operator|<
name|niface
condition|;
name|ifaceno
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ugen_set_config: ifaceno %d\n"
operator|,
name|ifaceno
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_device2interface_handle
argument_list|(
name|dev
argument_list|,
name|ifaceno
argument_list|,
operator|&
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"ugen_set_config: can't obtain interface handle"
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_endpoint_count
argument_list|(
name|iface
argument_list|,
operator|&
name|nendpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"ugen_set_config: endpoint count failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|endptno
operator|=
literal|0
init|;
name|endptno
operator|<
name|nendpt
condition|;
name|endptno
operator|++
control|)
block|{
name|ed
operator|=
name|usbd_interface2endpoint_descriptor
argument_list|(
name|iface
argument_list|,
name|endptno
argument_list|)
expr_stmt|;
name|endpt
operator|=
name|ed
operator|->
name|bEndpointAddress
expr_stmt|;
name|dir
operator|=
name|UE_GET_DIR
argument_list|(
name|endpt
argument_list|)
operator|==
name|UE_DIR_IN
condition|?
name|IN
else|:
name|OUT
expr_stmt|;
name|sce
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|UE_GET_ADDR
argument_list|(
name|endpt
argument_list|)
index|]
index|[
name|dir
index|]
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ugen_set_config: endptno %d, endpt=0x%02x"
literal|"(%d,%d), sce=%p\n"
operator|,
name|endptno
operator|,
name|endpt
operator|,
name|UE_GET_ADDR
argument_list|(
name|endpt
argument_list|)
operator|,
name|UE_GET_DIR
argument_list|(
name|endpt
argument_list|)
operator|,
name|sce
operator|)
argument_list|)
expr_stmt|;
name|sce
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|sce
operator|->
name|edesc
operator|=
name|ed
expr_stmt|;
name|sce
operator|->
name|iface
operator|=
name|iface
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ugenopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ugen_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
init|=
name|UGENUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|endpt
init|=
name|UGENENDPOINT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|edesc
decl_stmt|;
name|struct
name|ugen_endpoint
modifier|*
name|sce
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|isize
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|ugen_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenopen: flag=%d, mode=%d, unit=%d endpt=%d\n"
operator|,
name|flag
operator|,
name|mode
operator|,
name|unit
operator|,
name|endpt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_is_open
index|[
name|endpt
index|]
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|endpt
operator|==
name|USB_CONTROL_ENDPOINT
condition|)
block|{
name|sc
operator|->
name|sc_is_open
index|[
name|USB_CONTROL_ENDPOINT
index|]
operator|=
literal|1
expr_stmt|;
name|UGEN_DEV_OPEN
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Make sure there are pipes for all directions. */
for|for
control|(
name|dir
operator|=
name|OUT
init|;
name|dir
operator|<=
name|IN
condition|;
name|dir
operator|++
control|)
block|{
if|if
condition|(
name|flag
operator|&
operator|(
name|dir
operator|==
name|OUT
condition|?
name|FWRITE
else|:
name|FREAD
operator|)
condition|)
block|{
name|sce
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|endpt
index|]
index|[
name|dir
index|]
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|edesc
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/* Actually open the pipes. */
comment|/* XXX Should back out properly if it fails. */
for|for
control|(
name|dir
operator|=
name|OUT
init|;
name|dir
operator|<=
name|IN
condition|;
name|dir
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
operator|(
name|dir
operator|==
name|OUT
condition|?
name|FWRITE
else|:
name|FREAD
operator|)
operator|)
condition|)
continue|continue;
name|sce
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|endpt
index|]
index|[
name|dir
index|]
expr_stmt|;
name|sce
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|sce
operator|->
name|timeout
operator|=
name|USBD_NO_TIMEOUT
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenopen: sc=%p, endpt=%d, dir=%d, sce=%p\n"
operator|,
name|sc
operator|,
name|endpt
operator|,
name|dir
operator|,
name|sce
operator|)
argument_list|)
expr_stmt|;
name|edesc
operator|=
name|sce
operator|->
name|edesc
expr_stmt|;
switch|switch
condition|(
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_INTERRUPT
case|:
if|if
condition|(
name|dir
operator|==
name|OUT
condition|)
block|{
name|err
operator|=
name|usbd_open_pipe
argument_list|(
name|sce
operator|->
name|iface
argument_list|,
name|edesc
operator|->
name|bEndpointAddress
argument_list|,
literal|0
argument_list|,
operator|&
name|sce
operator|->
name|pipeh
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
block|}
name|isize
operator|=
name|UGETW
argument_list|(
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|isize
operator|==
literal|0
condition|)
comment|/* shouldn't happen */
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sce
operator|->
name|ibuf
operator|=
name|malloc
argument_list|(
name|isize
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenopen: intr endpt=%d,isize=%d\n"
operator|,
name|endpt
operator|,
name|isize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|clist_alloc_cblocks
argument_list|(
operator|&
name|sce
operator|->
name|q
argument_list|,
name|UGEN_IBSIZE
argument_list|,
name|UGEN_IBSIZE
argument_list|)
operator|,
literal|0
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|err
operator|=
name|usbd_open_pipe_intr
argument_list|(
name|sce
operator|->
name|iface
argument_list|,
name|edesc
operator|->
name|bEndpointAddress
argument_list|,
name|USBD_SHORT_XFER_OK
argument_list|,
operator|&
name|sce
operator|->
name|pipeh
argument_list|,
name|sce
argument_list|,
name|sce
operator|->
name|ibuf
argument_list|,
name|isize
argument_list|,
name|ugenintr
argument_list|,
name|USBD_DEFAULT_INTERVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|free
argument_list|(
name|sce
operator|->
name|ibuf
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
name|clist_free_cblocks
argument_list|(
operator|&
name|sce
operator|->
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenopen: interrupt open done\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_BULK
case|:
name|err
operator|=
name|usbd_open_pipe
argument_list|(
name|sce
operator|->
name|iface
argument_list|,
name|edesc
operator|->
name|bEndpointAddress
argument_list|,
literal|0
argument_list|,
operator|&
name|sce
operator|->
name|pipeh
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
if|if
condition|(
name|dir
operator|==
name|OUT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|isize
operator|=
name|UGETW
argument_list|(
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|isize
operator|==
literal|0
condition|)
comment|/* shouldn't happen */
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sce
operator|->
name|ibuf
operator|=
name|malloc
argument_list|(
name|isize
operator|*
name|UGEN_NISOFRAMES
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sce
operator|->
name|cur
operator|=
name|sce
operator|->
name|fill
operator|=
name|sce
operator|->
name|ibuf
expr_stmt|;
name|sce
operator|->
name|limit
operator|=
name|sce
operator|->
name|ibuf
operator|+
name|isize
operator|*
name|UGEN_NISOFRAMES
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenopen: isoc endpt=%d, isize=%d\n"
operator|,
name|endpt
operator|,
name|isize
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_open_pipe
argument_list|(
name|sce
operator|->
name|iface
argument_list|,
name|edesc
operator|->
name|bEndpointAddress
argument_list|,
literal|0
argument_list|,
operator|&
name|sce
operator|->
name|pipeh
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|free
argument_list|(
name|sce
operator|->
name|ibuf
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UGEN_NISOREQS
condition|;
operator|++
name|i
control|)
block|{
name|sce
operator|->
name|isoreqs
index|[
name|i
index|]
operator|.
name|sce
operator|=
name|sce
expr_stmt|;
name|xfer
operator|=
name|usbd_alloc_xfer
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|sce
operator|->
name|isoreqs
index|[
name|i
index|]
operator|.
name|xfer
operator|=
name|xfer
expr_stmt|;
name|buf
operator|=
name|usbd_alloc_buffer
argument_list|(
name|xfer
argument_list|,
name|isize
operator|*
name|UGEN_NISORFRMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sce
operator|->
name|isoreqs
index|[
name|i
index|]
operator|.
name|dmabuf
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|UGEN_NISORFRMS
condition|;
operator|++
name|j
control|)
name|sce
operator|->
name|isoreqs
index|[
name|i
index|]
operator|.
name|sizes
index|[
name|j
index|]
operator|=
name|isize
expr_stmt|;
name|usbd_setup_isoc_xfer
argument_list|(
name|xfer
argument_list|,
name|sce
operator|->
name|pipeh
argument_list|,
operator|&
name|sce
operator|->
name|isoreqs
index|[
name|i
index|]
argument_list|,
name|sce
operator|->
name|isoreqs
index|[
name|i
index|]
operator|.
name|sizes
argument_list|,
name|UGEN_NISORFRMS
argument_list|,
name|USBD_NO_COPY
argument_list|,
name|ugen_isoc_rintr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|usbd_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenopen: isoc open done\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
name|bad
label|:
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
comment|/* implicit buffer free */
name|usbd_free_xfer
argument_list|(
name|sce
operator|->
name|isoreqs
index|[
name|i
index|]
operator|.
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
case|case
name|UE_CONTROL
case|:
name|sce
operator|->
name|timeout
operator|=
name|USBD_DEFAULT_TIMEOUT
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|sc_is_open
index|[
name|endpt
index|]
operator|=
literal|1
expr_stmt|;
name|UGEN_DEV_OPEN
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ugenclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|int
name|endpt
init|=
name|UGENENDPOINT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ugen_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ugen_endpoint
modifier|*
name|sce
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|ugen_devclass
argument_list|,
name|UGENUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenclose: flag=%d, mode=%d, unit=%d, endpt=%d\n"
operator|,
name|flag
operator|,
name|mode
operator|,
name|UGENUNIT
argument_list|(
name|dev
argument_list|)
operator|,
name|endpt
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_is_open
index|[
name|endpt
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"ugenclose: not open\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|endpt
operator|==
name|USB_CONTROL_ENDPOINT
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenclose: close control\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_is_open
index|[
name|endpt
index|]
operator|=
literal|0
expr_stmt|;
name|UGEN_DEV_CLOSE
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|dir
operator|=
name|OUT
init|;
name|dir
operator|<=
name|IN
condition|;
name|dir
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
operator|(
name|dir
operator|==
name|OUT
condition|?
name|FWRITE
else|:
name|FREAD
operator|)
operator|)
condition|)
continue|continue;
name|sce
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|endpt
index|]
index|[
name|dir
index|]
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|pipeh
operator|==
name|NULL
condition|)
continue|continue;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenclose: endpt=%d dir=%d sce=%p\n"
operator|,
name|endpt
operator|,
name|dir
operator|,
name|sce
operator|)
argument_list|)
expr_stmt|;
name|usbd_abort_pipe
argument_list|(
name|sce
operator|->
name|pipeh
argument_list|)
expr_stmt|;
name|usbd_close_pipe
argument_list|(
name|sce
operator|->
name|pipeh
argument_list|)
expr_stmt|;
name|sce
operator|->
name|pipeh
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|sce
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_INTERRUPT
case|:
name|ndflush
argument_list|(
operator|&
name|sce
operator|->
name|q
argument_list|,
name|sce
operator|->
name|q
operator|.
name|c_cc
argument_list|)
expr_stmt|;
name|clist_free_cblocks
argument_list|(
operator|&
name|sce
operator|->
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UGEN_NISOREQS
condition|;
operator|++
name|i
control|)
name|usbd_free_xfer
argument_list|(
name|sce
operator|->
name|isoreqs
index|[
name|i
index|]
operator|.
name|xfer
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
if|if
condition|(
name|sce
operator|->
name|ibuf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sce
operator|->
name|ibuf
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
name|sce
operator|->
name|ibuf
operator|=
name|NULL
expr_stmt|;
name|clist_free_cblocks
argument_list|(
operator|&
name|sce
operator|->
name|q
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_is_open
index|[
name|endpt
index|]
operator|=
literal|0
expr_stmt|;
name|UGEN_DEV_CLOSE
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ugen_do_read
parameter_list|(
name|struct
name|ugen_softc
modifier|*
name|sc
parameter_list|,
name|int
name|endpt
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|ugen_endpoint
modifier|*
name|sce
init|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|endpt
index|]
index|[
name|IN
index|]
decl_stmt|;
name|u_int32_t
name|n
decl_stmt|,
name|tn
decl_stmt|;
name|char
name|buf
index|[
name|UGEN_BBSIZE
index|]
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|doneone
init|=
literal|0
decl_stmt|;
name|u_char
name|buffer
index|[
name|UGEN_CHUNK
index|]
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s: ugenread: %d\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|endpt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|endpt
operator|==
name|USB_CONTROL_ENDPOINT
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sce
operator|->
name|edesc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ugenread: no edesc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|sce
operator|->
name|pipeh
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ugenread: no pipe\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|sce
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_INTERRUPT
case|:
comment|/* Block until activity occurred. */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
while|while
condition|(
name|sce
operator|->
name|q
operator|.
name|c_cc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|sce
operator|->
name|state
operator||=
name|UGEN_ASLP
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenread: sleep on %p\n"
operator|,
name|sce
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|sce
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"ugenri"
argument_list|,
operator|(
name|sce
operator|->
name|timeout
operator|*
name|hz
operator|+
literal|999
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|sce
operator|->
name|state
operator|&=
operator|~
name|UGEN_ASLP
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenread: woke, error=%d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
comment|/* timeout, return 0 bytes */
break|break;
block|}
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Transfer as many chunks as possible. */
while|while
condition|(
name|sce
operator|->
name|q
operator|.
name|c_cc
operator|>
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
operator|!
name|error
condition|)
block|{
name|n
operator|=
name|min
argument_list|(
name|sce
operator|->
name|q
operator|.
name|c_cc
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|)
name|n
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Remove a small chunk from the input queue. */
name|q_to_b
argument_list|(
operator|&
name|sce
operator|->
name|q
argument_list|,
name|buffer
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenread: got %d chars\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
comment|/* Copy the data to the user process. */
name|error
operator|=
name|uiomove
argument_list|(
name|buffer
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
break|break;
case|case
name|UE_BULK
case|:
name|xfer
operator|=
name|usbd_alloc_xfer
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
while|while
condition|(
operator|(
name|n
operator|=
name|min
argument_list|(
name|UGEN_BBSIZE
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|!
name|doneone
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ugenread: start transfer %d bytes\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|tn
operator|=
name|n
expr_stmt|;
name|doneone
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|usbd_bulk_transfer
argument_list|(
name|xfer
argument_list|,
name|sce
operator|->
name|pipeh
argument_list|,
name|sce
operator|->
name|state
operator|&
name|UGEN_SHORT_OK
condition|?
name|USBD_SHORT_XFER_OK
else|:
literal|0
argument_list|,
name|sce
operator|->
name|timeout
argument_list|,
name|buf
argument_list|,
operator|&
name|tn
argument_list|,
literal|"ugenrb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|USBD_INTERRUPTED
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|USBD_TIMEOUT
condition|)
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
else|else
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ugenread: got %d bytes\n"
operator|,
name|tn
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|tn
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|tn
operator|<
name|n
condition|)
break|break;
block|}
name|usbd_free_xfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
while|while
condition|(
name|sce
operator|->
name|cur
operator|==
name|sce
operator|->
name|fill
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|sce
operator|->
name|state
operator||=
name|UGEN_ASLP
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenread: sleep on %p\n"
operator|,
name|sce
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|sce
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"ugenri"
argument_list|,
operator|(
name|sce
operator|->
name|timeout
operator|*
name|hz
operator|+
literal|999
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|sce
operator|->
name|state
operator|&=
operator|~
name|UGEN_ASLP
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenread: woke, error=%d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
comment|/* timeout, return 0 bytes */
break|break;
block|}
if|if
condition|(
name|error
condition|)
break|break;
block|}
while|while
condition|(
name|sce
operator|->
name|cur
operator|!=
name|sce
operator|->
name|fill
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|sce
operator|->
name|fill
operator|>
name|sce
operator|->
name|cur
condition|)
name|n
operator|=
name|min
argument_list|(
name|sce
operator|->
name|fill
operator|-
name|sce
operator|->
name|cur
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|min
argument_list|(
name|sce
operator|->
name|limit
operator|-
name|sce
operator|->
name|cur
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenread: isoc got %d chars\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
comment|/* Copy the data to the user process. */
name|error
operator|=
name|uiomove
argument_list|(
name|sce
operator|->
name|cur
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|sce
operator|->
name|cur
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|cur
operator|>=
name|sce
operator|->
name|limit
condition|)
name|sce
operator|->
name|cur
operator|=
name|sce
operator|->
name|ibuf
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ugenread
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|endpt
init|=
name|UGENENDPOINT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ugen_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|ugen_devclass
argument_list|,
name|UGENUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|UGEN_DEV_REF
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ugen_do_read
argument_list|(
name|sc
argument_list|,
name|endpt
argument_list|,
name|uio
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|UGEN_DEV_RELE
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ugen_do_write
parameter_list|(
name|struct
name|ugen_softc
modifier|*
name|sc
parameter_list|,
name|int
name|endpt
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|ugen_endpoint
modifier|*
name|sce
init|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|endpt
index|]
index|[
name|OUT
index|]
decl_stmt|;
name|u_int32_t
name|n
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|doneone
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
name|UGEN_BBSIZE
index|]
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s: ugenwrite: %d\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|endpt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|endpt
operator|==
name|USB_CONTROL_ENDPOINT
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sce
operator|->
name|edesc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ugenwrite: no edesc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|sce
operator|->
name|pipeh
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ugenwrite: no pipe\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|sce
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_BULK
case|:
name|xfer
operator|=
name|usbd_alloc_xfer
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
while|while
condition|(
operator|(
name|n
operator|=
name|min
argument_list|(
name|UGEN_BBSIZE
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|!
name|doneone
condition|)
block|{
name|doneone
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ugenwrite: transfer %d bytes\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_bulk_transfer
argument_list|(
name|xfer
argument_list|,
name|sce
operator|->
name|pipeh
argument_list|,
literal|0
argument_list|,
name|sce
operator|->
name|timeout
argument_list|,
name|buf
argument_list|,
operator|&
name|n
argument_list|,
literal|"ugenwb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|USBD_INTERRUPTED
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|USBD_TIMEOUT
condition|)
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
else|else
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
block|}
name|usbd_free_xfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_INTERRUPT
case|:
name|xfer
operator|=
name|usbd_alloc_xfer
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
while|while
condition|(
operator|(
name|n
operator|=
name|min
argument_list|(
name|UGETW
argument_list|(
name|sce
operator|->
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|!
name|doneone
condition|)
block|{
name|doneone
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ugenwrite: transfer %d bytes\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_intr_transfer
argument_list|(
name|xfer
argument_list|,
name|sce
operator|->
name|pipeh
argument_list|,
literal|0
argument_list|,
name|sce
operator|->
name|timeout
argument_list|,
name|buf
argument_list|,
operator|&
name|n
argument_list|,
literal|"ugenwi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|USBD_INTERRUPTED
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|USBD_TIMEOUT
condition|)
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
else|else
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
block|}
name|usbd_free_xfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ugenwrite
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|endpt
init|=
name|UGENENDPOINT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ugen_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|ugen_devclass
argument_list|,
name|UGENUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|UGEN_DEV_REF
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ugen_do_write
argument_list|(
name|sc
argument_list|,
name|endpt
argument_list|,
name|uio
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|UGEN_DEV_RELE
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ugenpurge
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|endpt
init|=
name|UGENENDPOINT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ugen_endpoint
modifier|*
name|sce
decl_stmt|;
name|struct
name|ugen_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|endpt
operator|==
name|USB_CONTROL_ENDPOINT
condition|)
return|return;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|ugen_devclass
argument_list|,
name|UGENUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sce
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|endpt
index|]
index|[
name|IN
index|]
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|pipeh
condition|)
name|usbd_abort_pipe
argument_list|(
name|sce
operator|->
name|pipeh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|state
operator|&
name|UGEN_ASLP
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenpurge: waking %p\n"
operator|,
name|sce
operator|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sce
argument_list|)
expr_stmt|;
block|}
name|selwakeuppri
argument_list|(
operator|&
name|sce
operator|->
name|rsel
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
name|sce
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|endpt
index|]
index|[
name|OUT
index|]
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|pipeh
condition|)
name|usbd_abort_pipe
argument_list|(
name|sce
operator|->
name|pipeh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|state
operator|&
name|UGEN_ASLP
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenpurge: waking %p\n"
operator|,
name|sce
operator|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sce
argument_list|)
expr_stmt|;
block|}
name|selwakeuppri
argument_list|(
operator|&
name|sce
operator|->
name|rsel
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ugen_detach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|ugen_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|struct
name|ugen_endpoint
modifier|*
name|sce
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dir
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ugen_detach: sc=%p\n"
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
comment|/* Abort all pipes.  Causes processes waiting for transfer to wake. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|USB_MAX_ENDPOINTS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|dir
operator|=
name|OUT
init|;
name|dir
operator|<=
name|IN
condition|;
name|dir
operator|++
control|)
block|{
name|sce
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|i
index|]
index|[
name|dir
index|]
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|pipeh
condition|)
name|usbd_abort_pipe
argument_list|(
name|sce
operator|->
name|pipeh
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|sce
operator|->
name|rsel
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* destroy the device for the control endpoint */
name|destroy_dev
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|usbd_add_drv_event
argument_list|(
name|USB_EVENT_DRIVER_DETACH
argument_list|,
name|sc
operator|->
name|sc_udev
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ugenintr
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|addr
parameter_list|,
name|usbd_status
name|status
parameter_list|)
block|{
name|struct
name|ugen_endpoint
modifier|*
name|sce
init|=
name|addr
decl_stmt|;
comment|/*struct ugen_softc *sc = sce->sc;*/
name|u_int32_t
name|count
decl_stmt|;
name|u_char
modifier|*
name|ibuf
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|USBD_CANCELLED
condition|)
return|return;
if|if
condition|(
name|status
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ugenintr: status=%d\n"
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|USBD_STALLED
condition|)
name|usbd_clear_endpoint_stall_async
argument_list|(
name|sce
operator|->
name|pipeh
argument_list|)
expr_stmt|;
return|return;
block|}
name|usbd_get_xfer_status
argument_list|(
name|xfer
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ibuf
operator|=
name|sce
operator|->
name|ibuf
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenintr: xfer=%p status=%d count=%d\n"
operator|,
name|xfer
operator|,
name|status
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"          data = %02x %02x %02x\n"
operator|,
name|ibuf
index|[
literal|0
index|]
operator|,
name|ibuf
index|[
literal|1
index|]
operator|,
name|ibuf
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|b_to_q
argument_list|(
name|ibuf
argument_list|,
name|count
argument_list|,
operator|&
name|sce
operator|->
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|state
operator|&
name|UGEN_ASLP
condition|)
block|{
name|sce
operator|->
name|state
operator|&=
operator|~
name|UGEN_ASLP
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugen_intr: waking %p\n"
operator|,
name|sce
operator|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sce
argument_list|)
expr_stmt|;
block|}
name|selwakeuppri
argument_list|(
operator|&
name|sce
operator|->
name|rsel
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ugen_isoc_rintr
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|addr
parameter_list|,
name|usbd_status
name|status
parameter_list|)
block|{
name|struct
name|isoreq
modifier|*
name|req
init|=
name|addr
decl_stmt|;
name|struct
name|ugen_endpoint
modifier|*
name|sce
init|=
name|req
operator|->
name|sce
decl_stmt|;
name|u_int32_t
name|count
decl_stmt|,
name|n
decl_stmt|;
name|int
name|i
decl_stmt|,
name|isize
decl_stmt|;
comment|/* Return if we are aborting. */
if|if
condition|(
name|status
operator|==
name|USBD_CANCELLED
condition|)
return|return;
name|usbd_get_xfer_status
argument_list|(
name|xfer
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugen_isoc_rintr: xfer %td, count=%d\n"
operator|,
name|req
operator|-
name|sce
operator|->
name|isoreqs
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
comment|/* throw away oldest input if the buffer is full */
if|if
condition|(
name|sce
operator|->
name|fill
operator|<
name|sce
operator|->
name|cur
operator|&&
name|sce
operator|->
name|cur
operator|<=
name|sce
operator|->
name|fill
operator|+
name|count
condition|)
block|{
name|sce
operator|->
name|cur
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|cur
operator|>=
name|sce
operator|->
name|limit
condition|)
name|sce
operator|->
name|cur
operator|=
name|sce
operator|->
name|ibuf
operator|+
operator|(
name|sce
operator|->
name|limit
operator|-
name|sce
operator|->
name|cur
operator|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugen_isoc_rintr: throwing away %d bytes\n"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
block|}
name|isize
operator|=
name|UGETW
argument_list|(
name|sce
operator|->
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UGEN_NISORFRMS
condition|;
name|i
operator|++
control|)
block|{
name|u_int32_t
name|actlen
init|=
name|req
operator|->
name|sizes
index|[
name|i
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|buf
init|=
operator|(
name|char
specifier|const
operator|*
operator|)
name|req
operator|->
name|dmabuf
operator|+
name|isize
operator|*
name|i
decl_stmt|;
comment|/* copy data to buffer */
while|while
condition|(
name|actlen
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|min
argument_list|(
name|actlen
argument_list|,
name|sce
operator|->
name|limit
operator|-
name|sce
operator|->
name|fill
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sce
operator|->
name|fill
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|n
expr_stmt|;
name|actlen
operator|-=
name|n
expr_stmt|;
name|sce
operator|->
name|fill
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|fill
operator|==
name|sce
operator|->
name|limit
condition|)
name|sce
operator|->
name|fill
operator|=
name|sce
operator|->
name|ibuf
expr_stmt|;
block|}
comment|/* setup size for next transfer */
name|req
operator|->
name|sizes
index|[
name|i
index|]
operator|=
name|isize
expr_stmt|;
block|}
name|usbd_setup_isoc_xfer
argument_list|(
name|xfer
argument_list|,
name|sce
operator|->
name|pipeh
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|sizes
argument_list|,
name|UGEN_NISORFRMS
argument_list|,
name|USBD_NO_COPY
argument_list|,
name|ugen_isoc_rintr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|usbd_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|state
operator|&
name|UGEN_ASLP
condition|)
block|{
name|sce
operator|->
name|state
operator|&=
operator|~
name|UGEN_ASLP
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugen_isoc_rintr: waking %p\n"
operator|,
name|sce
operator|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sce
argument_list|)
expr_stmt|;
block|}
name|selwakeuppri
argument_list|(
operator|&
name|sce
operator|->
name|rsel
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|usbd_status
name|ugen_set_interface
parameter_list|(
name|struct
name|ugen_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ifaceidx
parameter_list|,
name|int
name|altno
parameter_list|)
block|{
name|usbd_interface_handle
name|iface
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|struct
name|ugen_endpoint
modifier|*
name|sce
decl_stmt|,
modifier|*
modifier|*
name|sce_cache
decl_stmt|;
name|u_int8_t
name|niface
decl_stmt|,
name|nendpt
decl_stmt|,
name|nendpt_cache
decl_stmt|,
name|endptno
decl_stmt|,
name|endpt
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"ugen_set_interface %d %d\n"
operator|,
name|ifaceidx
operator|,
name|altno
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_interface_count
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|niface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|ifaceidx
operator|<
literal|0
operator|||
name|ifaceidx
operator|>=
name|niface
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|err
operator|=
name|usbd_device2interface_handle
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|ifaceidx
argument_list|,
operator|&
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|usbd_endpoint_count
argument_list|(
name|iface
argument_list|,
operator|&
name|nendpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* store an array of endpoint descriptors to clear if the interface 	 * change succeeds - these aren't available afterwards */
name|sce_cache
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ugen_endpoint
operator|*
argument_list|)
operator|*
name|nendpt
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nendpt_cache
operator|=
name|nendpt
expr_stmt|;
for|for
control|(
name|endptno
operator|=
literal|0
init|;
name|endptno
operator|<
name|nendpt
condition|;
name|endptno
operator|++
control|)
block|{
name|ed
operator|=
name|usbd_interface2endpoint_descriptor
argument_list|(
name|iface
argument_list|,
name|endptno
argument_list|)
expr_stmt|;
name|endpt
operator|=
name|ed
operator|->
name|bEndpointAddress
expr_stmt|;
name|dir
operator|=
name|UE_GET_DIR
argument_list|(
name|endpt
argument_list|)
operator|==
name|UE_DIR_IN
condition|?
name|IN
else|:
name|OUT
expr_stmt|;
name|sce_cache
index|[
name|endptno
index|]
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|UE_GET_ADDR
argument_list|(
name|endpt
argument_list|)
index|]
index|[
name|dir
index|]
expr_stmt|;
block|}
comment|/* change setting */
name|err
operator|=
name|usbd_set_interface
argument_list|(
name|iface
argument_list|,
name|altno
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|free
argument_list|(
name|sce_cache
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|err
operator|=
name|usbd_endpoint_count
argument_list|(
name|iface
argument_list|,
operator|&
name|nendpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"ugen_set_interface: endpoint count failed"
argument_list|)
expr_stmt|;
comment|/* destroy the existing devices, we remake the new ones in a moment */
name|ugen_destroy_devnodes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* now we can clear the old interface's ugen_endpoints */
for|for
control|(
name|endptno
operator|=
literal|0
init|;
name|endptno
operator|<
name|nendpt_cache
condition|;
name|endptno
operator|++
control|)
block|{
name|sce
operator|=
name|sce_cache
index|[
name|endptno
index|]
expr_stmt|;
name|sce
operator|->
name|sc
operator|=
literal|0
expr_stmt|;
name|sce
operator|->
name|edesc
operator|=
literal|0
expr_stmt|;
name|sce
operator|->
name|iface
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|sce_cache
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
comment|/* set the new interface's ugen_endpoints */
for|for
control|(
name|endptno
operator|=
literal|0
init|;
name|endptno
operator|<
name|nendpt
condition|;
name|endptno
operator|++
control|)
block|{
name|ed
operator|=
name|usbd_interface2endpoint_descriptor
argument_list|(
name|iface
argument_list|,
name|endptno
argument_list|)
expr_stmt|;
name|endpt
operator|=
name|ed
operator|->
name|bEndpointAddress
expr_stmt|;
name|dir
operator|=
name|UE_GET_DIR
argument_list|(
name|endpt
argument_list|)
operator|==
name|UE_DIR_IN
condition|?
name|IN
else|:
name|OUT
expr_stmt|;
name|sce
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|UE_GET_ADDR
argument_list|(
name|endpt
argument_list|)
index|]
index|[
name|dir
index|]
expr_stmt|;
name|sce
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|sce
operator|->
name|edesc
operator|=
name|ed
expr_stmt|;
name|sce
operator|->
name|iface
operator|=
name|iface
expr_stmt|;
block|}
comment|/* make the new devices */
name|ugen_make_devnodes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Retrieve a complete descriptor for a certain device and index. */
end_comment

begin_function
specifier|static
name|usb_config_descriptor_t
modifier|*
name|ugen_get_cdesc
parameter_list|(
name|struct
name|ugen_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|)
block|{
name|usb_config_descriptor_t
modifier|*
name|cdesc
decl_stmt|,
modifier|*
name|tdesc
decl_stmt|,
name|cdescr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|if
condition|(
name|index
operator|==
name|USB_CURRENT_CONFIG_INDEX
condition|)
block|{
name|tdesc
operator|=
name|usbd_get_config_descriptor
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
name|len
operator|=
name|UGETW
argument_list|(
name|tdesc
operator|->
name|wTotalLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|lenp
condition|)
operator|*
name|lenp
operator|=
name|len
expr_stmt|;
name|cdesc
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cdesc
argument_list|,
name|tdesc
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugen_get_cdesc: current, len=%d\n"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|usbd_get_config_desc
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|index
argument_list|,
operator|&
name|cdescr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|len
operator|=
name|UGETW
argument_list|(
name|cdescr
operator|.
name|wTotalLength
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugen_get_cdesc: index=%d, len=%d\n"
operator|,
name|index
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lenp
condition|)
operator|*
name|lenp
operator|=
name|len
expr_stmt|;
name|cdesc
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_get_config_desc_full
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|index
argument_list|,
name|cdesc
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|free
argument_list|(
name|cdesc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|cdesc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ugen_get_alt_index
parameter_list|(
name|struct
name|ugen_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ifaceidx
parameter_list|)
block|{
name|usbd_interface_handle
name|iface
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|err
operator|=
name|usbd_device2interface_handle
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|ifaceidx
argument_list|,
operator|&
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|usbd_get_interface_altindex
argument_list|(
name|iface
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ugen_do_ioctl
parameter_list|(
name|struct
name|ugen_softc
modifier|*
name|sc
parameter_list|,
name|int
name|endpt
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ugen_endpoint
modifier|*
name|sce
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|usbd_interface_handle
name|iface
decl_stmt|;
name|struct
name|usb_config_desc
modifier|*
name|cd
decl_stmt|;
name|usb_config_descriptor_t
modifier|*
name|cdesc
decl_stmt|;
name|struct
name|usb_interface_desc
modifier|*
name|id
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|idesc
decl_stmt|;
name|struct
name|usb_endpoint_desc
modifier|*
name|ed
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|edesc
decl_stmt|;
name|struct
name|usb_alt_interface
modifier|*
name|ai
decl_stmt|;
name|struct
name|usb_string_desc
modifier|*
name|si
decl_stmt|;
name|u_int8_t
name|conf
decl_stmt|,
name|alt
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ugenioctl: cmd=%08lx\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIONBIO
case|:
case|case
name|FIOASYNC
case|:
comment|/* All handled in the upper FS layer. */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|USB_SET_SHORT_XFER
case|:
if|if
condition|(
name|endpt
operator|==
name|USB_CONTROL_ENDPOINT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* This flag only affects read */
name|sce
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|endpt
index|]
index|[
name|IN
index|]
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|pipeh
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ugenioctl: USB_SET_SHORT_XFER, no pipe\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
condition|)
name|sce
operator|->
name|state
operator||=
name|UGEN_SHORT_OK
expr_stmt|;
else|else
name|sce
operator|->
name|state
operator|&=
operator|~
name|UGEN_SHORT_OK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|USB_SET_TIMEOUT
case|:
name|sce
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|endpt
index|]
index|[
name|IN
index|]
expr_stmt|;
name|sce
operator|->
name|timeout
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
name|sce
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|endpt
index|]
index|[
name|OUT
index|]
expr_stmt|;
name|sce
operator|->
name|timeout
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|endpt
operator|!=
name|USB_CONTROL_ENDPOINT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
ifdef|#
directive|ifdef
name|USB_DEBUG
case|case
name|USB_SETDEBUG
case|:
name|ugendebug
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|USB_GET_CONFIG
case|:
name|err
operator|=
name|usbd_get_config
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|conf
expr_stmt|;
break|break;
case|case
name|USB_SET_CONFIG
case|:
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|err
operator|=
name|ugen_set_config
argument_list|(
name|sc
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|USBD_NORMAL_COMPLETION
case|:
name|ugen_make_devnodes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|USBD_IN_USE
case|:
return|return
operator|(
name|EBUSY
operator|)
return|;
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
break|break;
case|case
name|USB_GET_ALTINTERFACE
case|:
name|ai
operator|=
operator|(
expr|struct
name|usb_alt_interface
operator|*
operator|)
name|addr
expr_stmt|;
name|err
operator|=
name|usbd_device2interface_handle
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|ai
operator|->
name|uai_interface_index
argument_list|,
operator|&
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|idesc
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|idesc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|ai
operator|->
name|uai_alt_no
operator|=
name|idesc
operator|->
name|bAlternateSetting
expr_stmt|;
break|break;
case|case
name|USB_SET_ALTINTERFACE
case|:
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|ai
operator|=
operator|(
expr|struct
name|usb_alt_interface
operator|*
operator|)
name|addr
expr_stmt|;
name|err
operator|=
name|usbd_device2interface_handle
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|ai
operator|->
name|uai_interface_index
argument_list|,
operator|&
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|err
operator|=
name|ugen_set_interface
argument_list|(
name|sc
argument_list|,
name|ai
operator|->
name|uai_interface_index
argument_list|,
name|ai
operator|->
name|uai_alt_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|USB_GET_NO_ALT
case|:
name|ai
operator|=
operator|(
expr|struct
name|usb_alt_interface
operator|*
operator|)
name|addr
expr_stmt|;
name|cdesc
operator|=
name|ugen_get_cdesc
argument_list|(
name|sc
argument_list|,
name|ai
operator|->
name|uai_config_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdesc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|idesc
operator|=
name|usbd_find_idesc
argument_list|(
name|cdesc
argument_list|,
name|ai
operator|->
name|uai_interface_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|idesc
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cdesc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ai
operator|->
name|uai_alt_no
operator|=
name|usbd_get_no_alts
argument_list|(
name|cdesc
argument_list|,
name|idesc
operator|->
name|bInterfaceNumber
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cdesc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_GET_DEVICE_DESC
case|:
operator|*
operator|(
name|usb_device_descriptor_t
operator|*
operator|)
name|addr
operator|=
operator|*
name|usbd_get_device_descriptor
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_GET_CONFIG_DESC
case|:
name|cd
operator|=
operator|(
expr|struct
name|usb_config_desc
operator|*
operator|)
name|addr
expr_stmt|;
name|cdesc
operator|=
name|ugen_get_cdesc
argument_list|(
name|sc
argument_list|,
name|cd
operator|->
name|ucd_config_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdesc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cd
operator|->
name|ucd_desc
operator|=
operator|*
name|cdesc
expr_stmt|;
name|free
argument_list|(
name|cdesc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_GET_INTERFACE_DESC
case|:
name|id
operator|=
operator|(
expr|struct
name|usb_interface_desc
operator|*
operator|)
name|addr
expr_stmt|;
name|cdesc
operator|=
name|ugen_get_cdesc
argument_list|(
name|sc
argument_list|,
name|id
operator|->
name|uid_config_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdesc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|id
operator|->
name|uid_config_index
operator|==
name|USB_CURRENT_CONFIG_INDEX
operator|&&
name|id
operator|->
name|uid_alt_index
operator|==
name|USB_CURRENT_ALT_INDEX
condition|)
name|alt
operator|=
name|ugen_get_alt_index
argument_list|(
name|sc
argument_list|,
name|id
operator|->
name|uid_interface_index
argument_list|)
expr_stmt|;
else|else
name|alt
operator|=
name|id
operator|->
name|uid_alt_index
expr_stmt|;
name|idesc
operator|=
name|usbd_find_idesc
argument_list|(
name|cdesc
argument_list|,
name|id
operator|->
name|uid_interface_index
argument_list|,
name|alt
argument_list|)
expr_stmt|;
if|if
condition|(
name|idesc
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cdesc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|id
operator|->
name|uid_desc
operator|=
operator|*
name|idesc
expr_stmt|;
name|free
argument_list|(
name|cdesc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_GET_ENDPOINT_DESC
case|:
name|ed
operator|=
operator|(
expr|struct
name|usb_endpoint_desc
operator|*
operator|)
name|addr
expr_stmt|;
name|cdesc
operator|=
name|ugen_get_cdesc
argument_list|(
name|sc
argument_list|,
name|ed
operator|->
name|ued_config_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdesc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ed
operator|->
name|ued_config_index
operator|==
name|USB_CURRENT_CONFIG_INDEX
operator|&&
name|ed
operator|->
name|ued_alt_index
operator|==
name|USB_CURRENT_ALT_INDEX
condition|)
name|alt
operator|=
name|ugen_get_alt_index
argument_list|(
name|sc
argument_list|,
name|ed
operator|->
name|ued_interface_index
argument_list|)
expr_stmt|;
else|else
name|alt
operator|=
name|ed
operator|->
name|ued_alt_index
expr_stmt|;
name|edesc
operator|=
name|usbd_find_edesc
argument_list|(
name|cdesc
argument_list|,
name|ed
operator|->
name|ued_interface_index
argument_list|,
name|alt
argument_list|,
name|ed
operator|->
name|ued_endpoint_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|edesc
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cdesc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ed
operator|->
name|ued_desc
operator|=
operator|*
name|edesc
expr_stmt|;
name|free
argument_list|(
name|cdesc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_GET_FULL_DESC
case|:
block|{
name|int
name|len
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|usb_full_desc
modifier|*
name|fd
init|=
operator|(
expr|struct
name|usb_full_desc
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cdesc
operator|=
name|ugen_get_cdesc
argument_list|(
name|sc
argument_list|,
name|fd
operator|->
name|ufd_config_index
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|fd
operator|->
name|ufd_size
condition|)
name|len
operator|=
name|fd
operator|->
name|ufd_size
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
name|fd
operator|->
name|ufd_data
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|len
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|len
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|p
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|void
operator|*
operator|)
name|cdesc
argument_list|,
name|len
argument_list|,
operator|&
name|uio
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cdesc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|USB_GET_STRING_DESC
case|:
block|{
name|int
name|len
decl_stmt|;
name|si
operator|=
operator|(
expr|struct
name|usb_string_desc
operator|*
operator|)
name|addr
expr_stmt|;
name|err
operator|=
name|usbd_get_string_desc
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|si
operator|->
name|usd_string_index
argument_list|,
name|si
operator|->
name|usd_language_id
argument_list|,
operator|&
name|si
operator|->
name|usd_desc
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
case|case
name|USB_DO_REQUEST
case|:
block|{
name|struct
name|usb_ctl_request
modifier|*
name|ur
init|=
operator|(
name|void
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|len
init|=
name|UGETW
argument_list|(
name|ur
operator|->
name|ucr_request
operator|.
name|wLength
argument_list|)
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|void
modifier|*
name|ptr
init|=
literal|0
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* Avoid requests that would damage the bus integrity. */
if|if
condition|(
operator|(
name|ur
operator|->
name|ucr_request
operator|.
name|bmRequestType
operator|==
name|UT_WRITE_DEVICE
operator|&&
name|ur
operator|->
name|ucr_request
operator|.
name|bRequest
operator|==
name|UR_SET_ADDRESS
operator|)
operator|||
operator|(
name|ur
operator|->
name|ucr_request
operator|.
name|bmRequestType
operator|==
name|UT_WRITE_DEVICE
operator|&&
name|ur
operator|->
name|ucr_request
operator|.
name|bRequest
operator|==
name|UR_SET_CONFIG
operator|)
operator|||
operator|(
name|ur
operator|->
name|ucr_request
operator|.
name|bmRequestType
operator|==
name|UT_WRITE_INTERFACE
operator|&&
name|ur
operator|->
name|ucr_request
operator|.
name|bRequest
operator|==
name|UR_SET_INTERFACE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
literal|32767
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|iov
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
name|ur
operator|->
name|ucr_data
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|len
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|len
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|ur
operator|->
name|ucr_request
operator|.
name|bmRequestType
operator|&
name|UT_READ
condition|?
name|UIO_READ
else|:
name|UIO_WRITE
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|p
expr_stmt|;
name|ptr
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|.
name|uio_rw
operator|==
name|UIO_WRITE
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|,
operator|&
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|ret
goto|;
block|}
block|}
name|sce
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|endpt
index|]
index|[
name|IN
index|]
expr_stmt|;
name|err
operator|=
name|usbd_do_request_flags
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|ur
operator|->
name|ucr_request
argument_list|,
name|ptr
argument_list|,
name|ur
operator|->
name|ucr_flags
argument_list|,
operator|&
name|ur
operator|->
name|ucr_actlen
argument_list|,
name|sce
operator|->
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|uio
operator|.
name|uio_rw
operator|==
name|UIO_READ
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|,
operator|&
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|ret
goto|;
block|}
block|}
name|ret
label|:
if|if
condition|(
name|ptr
condition|)
name|free
argument_list|(
name|ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|USB_GET_DEVICEINFO
case|:
name|usbd_fill_deviceinfo
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|(
expr|struct
name|usb_device_info
operator|*
operator|)
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ugenioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|int
name|endpt
init|=
name|UGENENDPOINT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ugen_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|ugen_devclass
argument_list|,
name|UGENUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|UGEN_DEV_REF
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ugen_do_ioctl
argument_list|(
name|sc
argument_list|,
name|endpt
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|UGEN_DEV_RELE
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ugenpoll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ugen_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ugen_endpoint
modifier|*
name|sce_in
decl_stmt|,
modifier|*
name|sce_out
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|edesc
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|ugen_devclass
argument_list|,
name|UGENUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLOUT
operator||
name|POLLRDNORM
operator||
name|POLLWRNORM
operator|)
operator|)
operator||
name|POLLHUP
operator|)
return|;
comment|/* Do not allow to poll a control endpoint */
if|if
condition|(
name|UGENENDPOINT
argument_list|(
name|dev
argument_list|)
operator|==
name|USB_CONTROL_ENDPOINT
condition|)
return|return
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLOUT
operator||
name|POLLRDNORM
operator||
name|POLLWRNORM
operator|)
operator|)
return|;
name|sce_in
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|UGENENDPOINT
argument_list|(
name|dev
argument_list|)
index|]
index|[
name|IN
index|]
expr_stmt|;
name|sce_out
operator|=
operator|&
name|sc
operator|->
name|sc_endpoints
index|[
name|UGENENDPOINT
argument_list|(
name|dev
argument_list|)
index|]
index|[
name|OUT
index|]
expr_stmt|;
name|edesc
operator|=
operator|(
name|sce_in
operator|->
name|edesc
operator|!=
name|NULL
operator|)
condition|?
name|sce_in
operator|->
name|edesc
else|:
name|sce_out
operator|->
name|edesc
expr_stmt|;
name|KASSERT
argument_list|(
name|edesc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"ugenpoll: NULL edesc"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sce_in
operator|->
name|edesc
operator|==
name|NULL
operator|||
name|sce_in
operator|->
name|pipeh
operator|==
name|NULL
condition|)
name|sce_in
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sce_out
operator|->
name|edesc
operator|==
name|NULL
operator|||
name|sce_out
operator|->
name|pipeh
operator|==
name|NULL
condition|)
name|sce_out
operator|=
name|NULL
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_INTERRUPT
case|:
if|if
condition|(
name|sce_in
operator|!=
name|NULL
operator|&&
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|sce_in
operator|->
name|q
operator|.
name|c_cc
operator|>
literal|0
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sce_in
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sce_out
operator|!=
name|NULL
operator|&&
operator|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|sce_out
operator|->
name|q
operator|.
name|c_cc
operator|>
literal|0
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sce_out
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
if|if
condition|(
name|sce_in
operator|!=
name|NULL
operator|&&
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|sce_in
operator|->
name|cur
operator|!=
name|sce_in
operator|->
name|fill
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sce_in
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sce_out
operator|!=
name|NULL
operator|&&
operator|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|sce_out
operator|->
name|cur
operator|!=
name|sce_out
operator|->
name|fill
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sce_out
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UE_BULK
case|:
comment|/* 		 * We have no easy way of determining if a read will 		 * yield any data or a write will happen. 		 * Pretend they will. 		 */
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator||
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ugen
argument_list|,
name|uhub
argument_list|,
name|ugen_driver
argument_list|,
name|ugen_devclass
argument_list|,
name|usbd_driver_load
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

