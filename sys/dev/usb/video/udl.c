begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: udl.c,v 1.81 2014/12/09 07:05:06 doug Exp $ */
end_comment

begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2015 Hans Petter Selasky<hselasky@freebsd.org>  * Copyright (c) 2009 Marcus Glocker<mglocker@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Driver for the "DisplayLink DL-120 / DL-160" graphic chips based on  * the reversed engineered specifications of Florian Echtler  *<floe@butterbrot.org>:  *  * 	http://floe.butterbrot.org/displaylink/doku.php  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/consio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fbio.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/fbreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/syscons/syscons.h>
end_include

begin_include
include|#
directive|include
file|<dev/videomode/videomode.h>
end_include

begin_include
include|#
directive|include
file|<dev/videomode/edidvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_include
include|#
directive|include
file|<dev/usb/video/udl.h>
end_include

begin_include
include|#
directive|include
file|"fb_if.h"
end_include

begin_undef
undef|#
directive|undef
name|DPRINTF
end_undef

begin_undef
undef|#
directive|undef
name|DPRINTFN
end_undef

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|udl_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|udl_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|udl
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB UDL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_udl
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|udl_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|usb_callback_t
name|udl_bulk_write_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_probe_t
name|udl_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|udl_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|udl_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fb_getinfo_t
name|udl_fb_getinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fb_setblankmode_t
name|udl_fb_setblankmode
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|udl_select_chip
parameter_list|(
name|struct
name|udl_softc
modifier|*
parameter_list|,
name|struct
name|usb_attach_arg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udl_init_chip
parameter_list|(
name|struct
name|udl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udl_select_mode
parameter_list|(
name|struct
name|udl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udl_init_resolution
parameter_list|(
name|struct
name|udl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udl_fbmem_alloc
parameter_list|(
name|struct
name|udl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udl_cmd_write_buf_le16
parameter_list|(
name|struct
name|udl_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udl_cmd_buf_copy_le16
parameter_list|(
name|struct
name|udl_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udl_cmd_insert_int_1
parameter_list|(
name|struct
name|udl_cmd_buf
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udl_cmd_insert_int_3
parameter_list|(
name|struct
name|udl_cmd_buf
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udl_cmd_insert_buf_le16
parameter_list|(
name|struct
name|udl_cmd_buf
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udl_cmd_write_reg_1
parameter_list|(
name|struct
name|udl_cmd_buf
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udl_cmd_write_reg_3
parameter_list|(
name|struct
name|udl_cmd_buf
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udl_power_save
parameter_list|(
name|struct
name|udl_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|udl_config
index|[
name|UDL_N_TRANSFER
index|]
init|=
block|{
index|[
name|UDL_BULK_WRITE_0
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_TX
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|force_short_xfer
operator|=
literal|1
block|,
operator|.
name|ext_buffer
operator|=
literal|1
block|,}
block|,
operator|.
name|bufsize
operator|=
name|UDL_CMD_MAX_DATA_SIZE
operator|*
name|UDL_CMD_MAX_FRAMES
block|,
operator|.
name|callback
operator|=
operator|&
name|udl_bulk_write_callback
block|,
operator|.
name|frames
operator|=
name|UDL_CMD_MAX_FRAMES
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
block|}
block|,
index|[
name|UDL_BULK_WRITE_1
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_TX
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|force_short_xfer
operator|=
literal|1
block|,
operator|.
name|ext_buffer
operator|=
literal|1
block|,}
block|,
operator|.
name|bufsize
operator|=
name|UDL_CMD_MAX_DATA_SIZE
operator|*
name|UDL_CMD_MAX_FRAMES
block|,
operator|.
name|callback
operator|=
operator|&
name|udl_bulk_write_callback
block|,
operator|.
name|frames
operator|=
name|UDL_CMD_MAX_FRAMES
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Driver glue.  */
end_comment

begin_decl_stmt
specifier|static
name|devclass_t
name|udl_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|udl_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|udl_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|udl_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|udl_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|fb_getinfo
argument_list|,
name|udl_fb_getinfo
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|udl_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"udl"
block|,
operator|.
name|methods
operator|=
name|udl_methods
block|,
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|udl_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|udl
argument_list|,
name|uhub
argument_list|,
name|udl_driver
argument_list|,
name|udl_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|udl
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|udl
argument_list|,
name|fbd
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|udl
argument_list|,
name|videomode
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|udl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Matching devices.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|STRUCT_USB_HOST_ID
name|udl_devs
index|[]
init|=
block|{
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_LCD4300U
argument_list|,
argument|DL120
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_LCD8000U
argument_list|,
argument|DL120
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_GUC2020
argument_list|,
argument|DL160
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_LD220
argument_list|,
argument|DL165
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_VCUD60
argument_list|,
argument|DL160
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_DLDVI
argument_list|,
argument|DL160
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_VGA10
argument_list|,
argument|DL120
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_WSDVI
argument_list|,
argument|DLUNK
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_EC008
argument_list|,
argument|DL160
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_HPDOCK
argument_list|,
argument|DL160
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_NL571
argument_list|,
argument|DL160
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_M01061
argument_list|,
argument|DL195
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_NBDOCK
argument_list|,
argument|DL165
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_SWDVI
argument_list|,
argument|DLUNK
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_UM7X0
argument_list|,
argument|DL120
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_CONV
argument_list|,
argument|DL160
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_PLUGABLE
argument_list|,
argument|DL160
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_LUM70
argument_list|,
argument|DL125
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_POLARIS2
argument_list|,
argument|DLUNK
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_DISPLAYLINK
argument_list|,
argument|USB_PRODUCT_DISPLAYLINK_LT1421
argument_list|,
argument|DLUNK
argument_list|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint32_t
name|udl_get_fb_size
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|i
init|=
name|sc
operator|->
name|sc_cur_mode
decl_stmt|;
return|return
operator|(
operator|(
name|uint32_t
operator|)
name|udl_modes
index|[
name|i
index|]
operator|.
name|hdisplay
operator|*
operator|(
name|uint32_t
operator|)
name|udl_modes
index|[
name|i
index|]
operator|.
name|vdisplay
operator|*
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|udl_get_fb_width
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|i
init|=
name|sc
operator|->
name|sc_cur_mode
decl_stmt|;
return|return
operator|(
name|udl_modes
index|[
name|i
index|]
operator|.
name|hdisplay
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|udl_get_fb_height
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|i
init|=
name|sc
operator|->
name|sc_cur_mode
decl_stmt|;
return|return
operator|(
name|udl_modes
index|[
name|i
index|]
operator|.
name|vdisplay
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|udl_get_fb_hz
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|i
init|=
name|sc
operator|->
name|sc_cur_mode
decl_stmt|;
return|return
operator|(
name|udl_modes
index|[
name|i
index|]
operator|.
name|hz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|udl_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|udl_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
specifier|const
name|uint32_t
name|max
init|=
name|udl_get_fb_size
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_power_save
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_sync_off
operator|>=
name|max
condition|)
name|sc
operator|->
name|sc_sync_off
operator|=
literal|0
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UDL_BULK_WRITE_0
index|]
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UDL_BULK_WRITE_1
index|]
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
name|hz
operator|/
literal|5
argument_list|,
operator|&
name|udl_callout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|udl_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bConfigIndex
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|usbd_lookup_id_by_uaa
argument_list|(
name|udl_devs
argument_list|,
sizeof|sizeof
argument_list|(
name|udl_devs
argument_list|)
argument_list|,
name|uaa
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udl_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|udl_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|"UDL lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_cv
argument_list|,
literal|"UDLCV"
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
name|error
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|,
name|sc
operator|->
name|sc_xfer
argument_list|,
name|udl_config
argument_list|,
name|UDL_N_TRANSFER
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"usbd_transfer_setup error=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|usbd_xfer_set_priv
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UDL_BULK_WRITE_0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|sc_xfer_head
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usbd_xfer_set_priv
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UDL_BULK_WRITE_1
index|]
argument_list|,
operator|&
name|sc
operator|->
name|sc_xfer_head
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_xfer_head
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_xfer_head
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_buf_free
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_buf_pending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_def_chip
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_chip
operator|=
name|USB_GET_DRIVER_INFO
argument_list|(
name|uaa
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_def_mode
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_cur_mode
operator|=
name|UDL_MAX_MODES
expr_stmt|;
comment|/* Allow chip ID to be overwritten */
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"chipid_force"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|sc
operator|->
name|sc_def_chip
argument_list|,
literal|0
argument_list|,
literal|"chip ID"
argument_list|)
expr_stmt|;
comment|/* Export current chip ID */
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"chipid"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sc_chip
argument_list|,
literal|0
argument_list|,
literal|"chip ID"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_def_chip
operator|>
operator|-
literal|1
operator|&&
name|sc
operator|->
name|sc_def_chip
operator|<=
name|DLMAX
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Forcing chip ID to 0x%04x\n"
argument_list|,
name|sc
operator|->
name|sc_def_chip
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_chip
operator|=
name|sc
operator|->
name|sc_def_chip
expr_stmt|;
block|}
comment|/* 	 * The product might have more than one chip 	 */
if|if
condition|(
name|sc
operator|->
name|sc_chip
operator|==
name|DLUNK
condition|)
name|udl_select_chip
argument_list|(
name|sc
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|UDL_CMD_MAX_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|udl_cmd_buf
modifier|*
name|cb
init|=
operator|&
name|sc
operator|->
name|sc_cmd_buf_temp
index|[
name|i
index|]
decl_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_buf_free
argument_list|,
name|cb
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize chip. 	 */
name|error
operator|=
name|udl_init_chip
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
goto|goto
name|detach
goto|;
comment|/* 	 * Select edid mode. 	 */
name|udl_select_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Allow default mode to be overwritten */
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mode_force"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|sc
operator|->
name|sc_def_mode
argument_list|,
literal|0
argument_list|,
literal|"mode"
argument_list|)
expr_stmt|;
comment|/* Export current mode */
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mode"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sc_cur_mode
argument_list|,
literal|0
argument_list|,
literal|"mode"
argument_list|)
expr_stmt|;
name|i
operator|=
name|sc
operator|->
name|sc_def_mode
expr_stmt|;
if|if
condition|(
name|i
operator|>
operator|-
literal|1
operator|&&
name|i
operator|<
name|UDL_MAX_MODES
condition|)
block|{
if|if
condition|(
name|udl_modes
index|[
name|i
index|]
operator|.
name|chip
operator|<=
name|sc
operator|->
name|sc_chip
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Forcing mode to %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cur_mode
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* Printout current mode */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Mode selected %dx%d @ %dHz\n"
argument_list|,
operator|(
name|int
operator|)
name|udl_get_fb_width
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|udl_get_fb_height
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|udl_get_fb_hz
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|udl_init_resolution
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Allocate frame buffer */
name|udl_fbmem_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|UDL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|udl_callout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|UDL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fb_info
operator|.
name|fb_name
operator|=
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fb_info
operator|.
name|fb_size
operator|=
name|sc
operator|->
name|sc_fb_size
expr_stmt|;
name|sc
operator|->
name|sc_fb_info
operator|.
name|fb_bpp
operator|=
literal|16
expr_stmt|;
name|sc
operator|->
name|sc_fb_info
operator|.
name|fb_depth
operator|=
literal|16
expr_stmt|;
name|sc
operator|->
name|sc_fb_info
operator|.
name|fb_width
operator|=
name|udl_get_fb_width
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fb_info
operator|.
name|fb_height
operator|=
name|udl_get_fb_height
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fb_info
operator|.
name|fb_stride
operator|=
name|sc
operator|->
name|sc_fb_info
operator|.
name|fb_width
operator|*
literal|2
expr_stmt|;
name|sc
operator|->
name|sc_fb_info
operator|.
name|fb_pbase
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_fb_info
operator|.
name|fb_vbase
operator|=
operator|(
name|uintptr_t
operator|)
name|sc
operator|->
name|sc_fb_addr
expr_stmt|;
name|sc
operator|->
name|sc_fb_info
operator|.
name|fb_priv
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_fb_info
operator|.
name|setblankmode
operator|=
operator|&
name|udl_fb_setblankmode
expr_stmt|;
name|sc
operator|->
name|sc_fbdev
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"fbd"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_fbdev
operator|==
name|NULL
condition|)
goto|goto
name|detach
goto|;
if|if
condition|(
name|device_probe_and_attach
argument_list|(
name|sc
operator|->
name|sc_fbdev
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|detach
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|detach
label|:
name|udl_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udl_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|udl_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_fbdev
operator|!=
name|NULL
condition|)
block|{
name|device_t
name|bdev
decl_stmt|;
name|bdev
operator|=
name|sc
operator|->
name|sc_fbdev
expr_stmt|;
name|sc
operator|->
name|sc_fbdev
operator|=
name|NULL
expr_stmt|;
name|device_detach
argument_list|(
name|bdev
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|bdev
argument_list|)
expr_stmt|;
block|}
name|UDL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_gone
operator|=
literal|1
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
name|UDL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|UDL_N_TRANSFER
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_cv
argument_list|)
expr_stmt|;
comment|/* 	 * Free framebuffer memory, if any. 	 */
name|free
argument_list|(
name|sc
operator|->
name|sc_fb_addr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_fb_copy
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|fb_info
modifier|*
name|udl_fb_getinfo
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|udl_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
operator|&
name|sc
operator|->
name|sc_fb_info
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udl_fb_setblankmode
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|udl_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V_DISPLAY_ON
case|:
name|udl_power_save
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_DISPLAY_BLANK
case|:
name|udl_power_save
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_fb_addr
operator|!=
literal|0
condition|)
block|{
specifier|const
name|uint32_t
name|max
init|=
name|udl_get_fb_size
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|sc_fb_addr
argument_list|,
literal|0
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|V_DISPLAY_STAND_BY
case|:
case|case
name|V_DISPLAY_SUSPEND
case|:
name|udl_power_save
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|udl_cmd_buf
modifier|*
name|udl_cmd_buf_alloc_locked
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|udl_cmd_buf
modifier|*
name|cb
decl_stmt|;
while|while
condition|(
operator|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_buf_free
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|!=
name|M_WAITOK
condition|)
break|break;
name|cv_wait
argument_list|(
operator|&
name|sc
operator|->
name|sc_cv
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_buf_free
argument_list|,
name|cb
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|cb
operator|->
name|off
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|cb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|udl_cmd_buf
modifier|*
name|udl_cmd_buf_alloc
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|udl_cmd_buf
modifier|*
name|cb
decl_stmt|;
name|UDL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cb
operator|=
name|udl_cmd_buf_alloc_locked
argument_list|(
name|sc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|UDL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|cb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|udl_cmd_buf_send
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|udl_cmd_buf
modifier|*
name|cb
parameter_list|)
block|{
name|UDL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_gone
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_buf_free
argument_list|,
name|cb
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* mark end of command stack */
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|UDL_BULK_SOC
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|UDL_BULK_CMD_EOC
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_buf_pending
argument_list|,
name|cb
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UDL_BULK_WRITE_0
index|]
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UDL_BULK_WRITE_1
index|]
argument_list|)
expr_stmt|;
block|}
name|UDL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|udl_cmd_buf
modifier|*
name|udl_fb_synchronize_locked
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|uint32_t
name|max
init|=
name|udl_get_fb_size
argument_list|(
name|sc
argument_list|)
decl_stmt|;
comment|/* check if framebuffer is not ready */
if|if
condition|(
name|sc
operator|->
name|sc_fb_addr
operator|==
name|NULL
operator|||
name|sc
operator|->
name|sc_fb_copy
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
name|sc
operator|->
name|sc_sync_off
operator|<
name|max
condition|)
block|{
name|uint32_t
name|delta
init|=
name|max
operator|-
name|sc
operator|->
name|sc_sync_off
decl_stmt|;
if|if
condition|(
name|delta
operator|>
name|UDL_CMD_MAX_PIXEL_COUNT
operator|*
literal|2
condition|)
name|delta
operator|=
name|UDL_CMD_MAX_PIXEL_COUNT
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sc
operator|->
name|sc_fb_addr
operator|+
name|sc
operator|->
name|sc_sync_off
argument_list|,
name|sc
operator|->
name|sc_fb_copy
operator|+
name|sc
operator|->
name|sc_sync_off
argument_list|,
name|delta
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|udl_cmd_buf
modifier|*
name|cb
decl_stmt|;
name|cb
operator|=
name|udl_cmd_buf_alloc_locked
argument_list|(
name|sc
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_fb_copy
operator|+
name|sc
operator|->
name|sc_sync_off
argument_list|,
name|sc
operator|->
name|sc_fb_addr
operator|+
name|sc
operator|->
name|sc_sync_off
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|UDL_BULK_SOC
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|UDL_BULK_CMD_FB_WRITE
operator||
name|UDL_BULK_CMD_FB_WORD
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_3
argument_list|(
name|cb
argument_list|,
name|sc
operator|->
name|sc_sync_off
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|delta
operator|/
literal|2
argument_list|)
expr_stmt|;
name|udl_cmd_insert_buf_le16
argument_list|(
name|cb
argument_list|,
name|sc
operator|->
name|sc_fb_copy
operator|+
name|sc
operator|->
name|sc_sync_off
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sync_off
operator|+=
name|delta
expr_stmt|;
return|return
operator|(
name|cb
operator|)
return|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_sync_off
operator|+=
name|delta
expr_stmt|;
block|}
block|}
name|done
label|:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|udl_bulk_write_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|udl_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|udl_cmd_head
modifier|*
name|phead
init|=
name|usbd_xfer_get_priv
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|udl_cmd_buf
modifier|*
name|cb
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|TAILQ_CONCAT
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_buf_free
argument_list|,
name|phead
argument_list|,
name|entry
argument_list|)
expr_stmt|;
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|UDL_CMD_MAX_FRAMES
condition|;
name|i
operator|++
control|)
block|{
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_buf_pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
block|{
name|cb
operator|=
name|udl_fb_synchronize_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
break|break;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_buf_pending
argument_list|,
name|cb
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
name|phead
argument_list|,
name|cb
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
name|i
argument_list|,
name|cb
operator|->
name|buf
argument_list|,
name|cb
operator|->
name|off
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|usbd_xfer_set_frames
argument_list|(
name|xfer
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|TAILQ_CONCAT
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_buf_free
argument_list|,
name|phead
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* try clear stall first */
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
break|break;
block|}
comment|/* wakeup any waiters */
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|sc_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|udl_power_save
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|,
name|int
name|on
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|udl_cmd_buf
modifier|*
name|cb
decl_stmt|;
comment|/* get new buffer */
name|cb
operator|=
name|udl_cmd_buf_alloc
argument_list|(
name|sc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
name|DPRINTF
argument_list|(
literal|"screen %s\n"
argument_list|,
name|on
condition|?
literal|"ON"
else|:
literal|"OFF"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_power_save
operator|=
name|on
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|udl_cmd_write_reg_1
argument_list|(
name|cb
argument_list|,
name|UDL_REG_SCREEN
argument_list|,
name|UDL_REG_SCREEN_ON
argument_list|)
expr_stmt|;
else|else
name|udl_cmd_write_reg_1
argument_list|(
name|cb
argument_list|,
name|UDL_REG_SCREEN
argument_list|,
name|UDL_REG_SCREEN_OFF
argument_list|)
expr_stmt|;
name|udl_cmd_write_reg_1
argument_list|(
name|cb
argument_list|,
name|UDL_REG_SYNC
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|udl_cmd_buf_send
argument_list|(
name|sc
argument_list|,
name|cb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udl_ctrl_msg
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|rt
parameter_list|,
name|uint8_t
name|r
parameter_list|,
name|uint16_t
name|index
parameter_list|,
name|uint16_t
name|value
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|int
name|error
decl_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|rt
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|r
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|usbd_do_request_flags
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|NULL
argument_list|,
operator|&
name|req
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|USB_DEFAULT_TIMEOUT
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udl_poll
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|buf
parameter_list|)
block|{
name|uint32_t
name|lbuf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|udl_ctrl_msg
argument_list|(
name|sc
argument_list|,
name|UT_READ_VENDOR_DEVICE
argument_list|,
name|UDL_CTRL_CMD_POLL
argument_list|,
literal|0x0000
argument_list|,
literal|0x0000
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|lbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|USB_ERR_NORMAL_COMPLETION
condition|)
operator|*
name|buf
operator|=
name|le32toh
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udl_read_1
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|addr
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
name|uint8_t
name|lbuf
index|[
literal|1
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|udl_ctrl_msg
argument_list|(
name|sc
argument_list|,
name|UT_READ_VENDOR_DEVICE
argument_list|,
name|UDL_CTRL_CMD_READ_1
argument_list|,
name|addr
argument_list|,
literal|0x0000
argument_list|,
name|lbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|USB_ERR_NORMAL_COMPLETION
condition|)
operator|*
name|buf
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|lbuf
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udl_write_1
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|addr
parameter_list|,
name|uint8_t
name|buf
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|udl_ctrl_msg
argument_list|(
name|sc
argument_list|,
name|UT_WRITE_VENDOR_DEVICE
argument_list|,
name|UDL_CTRL_CMD_WRITE_1
argument_list|,
name|addr
argument_list|,
literal|0x0000
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udl_read_edid
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
name|uint8_t
name|lbuf
index|[
literal|64
index|]
decl_stmt|;
name|uint16_t
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|udl_ctrl_msg
argument_list|(
name|sc
argument_list|,
name|UT_READ_VENDOR_DEVICE
argument_list|,
name|UDL_CTRL_CMD_READ_EDID
argument_list|,
literal|0x00a1
argument_list|,
operator|(
name|offset
operator|<<
literal|8
operator|)
argument_list|,
name|lbuf
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
goto|goto
name|fail
goto|;
name|bcopy
argument_list|(
name|lbuf
operator|+
literal|1
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
literal|63
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|63
expr_stmt|;
name|error
operator|=
name|udl_ctrl_msg
argument_list|(
name|sc
argument_list|,
name|UT_READ_VENDOR_DEVICE
argument_list|,
name|UDL_CTRL_CMD_READ_EDID
argument_list|,
literal|0x00a1
argument_list|,
operator|(
name|offset
operator|<<
literal|8
operator|)
argument_list|,
name|lbuf
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
goto|goto
name|fail
goto|;
name|bcopy
argument_list|(
name|lbuf
operator|+
literal|1
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
literal|63
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|63
expr_stmt|;
name|error
operator|=
name|udl_ctrl_msg
argument_list|(
name|sc
argument_list|,
name|UT_READ_VENDOR_DEVICE
argument_list|,
name|UDL_CTRL_CMD_READ_EDID
argument_list|,
literal|0x00a1
argument_list|,
operator|(
name|offset
operator|<<
literal|8
operator|)
argument_list|,
name|lbuf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
goto|goto
name|fail
goto|;
name|bcopy
argument_list|(
name|lbuf
operator|+
literal|1
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|udl_lookup_mode
parameter_list|(
name|uint16_t
name|hdisplay
parameter_list|,
name|uint16_t
name|vdisplay
parameter_list|,
name|uint8_t
name|hz
parameter_list|,
name|uint16_t
name|chip
parameter_list|,
name|uint32_t
name|clock
parameter_list|)
block|{
name|uint8_t
name|idx
decl_stmt|;
comment|/* 	 * Check first if we have a matching mode with pixelclock 	 */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|!=
name|UDL_MAX_MODES
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|udl_modes
index|[
name|idx
index|]
operator|.
name|hdisplay
operator|==
name|hdisplay
operator|)
operator|&&
operator|(
name|udl_modes
index|[
name|idx
index|]
operator|.
name|vdisplay
operator|==
name|vdisplay
operator|)
operator|&&
operator|(
name|udl_modes
index|[
name|idx
index|]
operator|.
name|clock
operator|==
name|clock
operator|)
operator|&&
operator|(
name|udl_modes
index|[
name|idx
index|]
operator|.
name|chip
operator|<=
name|chip
operator|)
condition|)
block|{
return|return
operator|(
name|idx
operator|)
return|;
block|}
block|}
comment|/* 	 * If not, check for matching mode with update frequency 	 */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|!=
name|UDL_MAX_MODES
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|udl_modes
index|[
name|idx
index|]
operator|.
name|hdisplay
operator|==
name|hdisplay
operator|)
operator|&&
operator|(
name|udl_modes
index|[
name|idx
index|]
operator|.
name|vdisplay
operator|==
name|vdisplay
operator|)
operator|&&
operator|(
name|udl_modes
index|[
name|idx
index|]
operator|.
name|hz
operator|==
name|hz
operator|)
operator|&&
operator|(
name|udl_modes
index|[
name|idx
index|]
operator|.
name|chip
operator|<=
name|chip
operator|)
condition|)
block|{
return|return
operator|(
name|idx
operator|)
return|;
block|}
block|}
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|udl_select_chip
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_attach_arg
modifier|*
name|uaa
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pserial
decl_stmt|;
name|pserial
operator|=
name|usb_get_serial
argument_list|(
name|uaa
operator|->
name|device
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_chip
operator|=
name|DL120
expr_stmt|;
if|if
condition|(
operator|(
name|uaa
operator|->
name|info
operator|.
name|idVendor
operator|==
name|USB_VENDOR_DISPLAYLINK
operator|)
operator|&&
operator|(
name|uaa
operator|->
name|info
operator|.
name|idProduct
operator|==
name|USB_PRODUCT_DISPLAYLINK_WSDVI
operator|)
condition|)
block|{
comment|/* 		 * WS Tech DVI is DL120 or DL160. All deviced uses the 		 * same revision (0.04) so iSerialNumber must be used 		 * to determin which chip it is. 		 */
if|if
condition|(
name|strlen
argument_list|(
name|pserial
argument_list|)
operator|>
literal|7
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|pserial
argument_list|,
literal|"0198-13"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_chip
operator|=
name|DL160
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"iSerialNumber (%s) used to select chip (%d)\n"
argument_list|,
name|pserial
argument_list|,
name|sc
operator|->
name|sc_chip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uaa
operator|->
name|info
operator|.
name|idVendor
operator|==
name|USB_VENDOR_DISPLAYLINK
operator|)
operator|&&
operator|(
name|uaa
operator|->
name|info
operator|.
name|idProduct
operator|==
name|USB_PRODUCT_DISPLAYLINK_SWDVI
operator|)
condition|)
block|{
comment|/* 		 * SUNWEIT DVI is DL160, DL125, DL165 or DL195. Major revision 		 * can be used to differ between DL1x0 and DL1x5. Minor to 		 * differ between DL1x5. iSerialNumber seems not to be uniqe. 		 */
name|sc
operator|->
name|sc_chip
operator|=
name|DL160
expr_stmt|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bcdDevice
operator|>=
literal|0x100
condition|)
block|{
name|sc
operator|->
name|sc_chip
operator|=
name|DL165
expr_stmt|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bcdDevice
operator|==
literal|0x104
condition|)
name|sc
operator|->
name|sc_chip
operator|=
name|DL195
expr_stmt|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bcdDevice
operator|==
literal|0x108
condition|)
name|sc
operator|->
name|sc_chip
operator|=
name|DL125
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"bcdDevice (%02x) used to select chip (%d)\n"
argument_list|,
name|uaa
operator|->
name|info
operator|.
name|bcdDevice
argument_list|,
name|sc
operator|->
name|sc_chip
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|udl_set_enc_key
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint8_t
name|len
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|udl_ctrl_msg
argument_list|(
name|sc
argument_list|,
name|UT_WRITE_VENDOR_DEVICE
argument_list|,
name|UDL_CTRL_CMD_SET_KEY
argument_list|,
literal|0x0000
argument_list|,
literal|0x0000
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|udl_fbmem_alloc
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|size
decl_stmt|;
name|size
operator|=
name|udl_get_fb_size
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fb_addr
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fb_copy
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fb_size
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|udl_cmd_insert_int_1
parameter_list|(
name|struct
name|udl_cmd_buf
modifier|*
name|cb
parameter_list|,
name|uint8_t
name|value
parameter_list|)
block|{
name|cb
operator|->
name|buf
index|[
name|cb
operator|->
name|off
index|]
operator|=
name|value
expr_stmt|;
name|cb
operator|->
name|off
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void udl_cmd_insert_int_2(struct udl_cmd_buf *cb, uint16_t value) { 	uint16_t lvalue;  	lvalue = htobe16(value); 	bcopy(&lvalue, cb->buf + cb->off, 2);  	cb->off += 2; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|udl_cmd_insert_int_3
parameter_list|(
name|struct
name|udl_cmd_buf
modifier|*
name|cb
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|uint32_t
name|lvalue
decl_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|lvalue
operator|=
name|htobe32
argument_list|(
name|value
argument_list|)
operator|<<
literal|8
expr_stmt|;
else|#
directive|else
name|lvalue
operator|=
name|htobe32
argument_list|(
name|value
argument_list|)
operator|>>
literal|8
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
operator|&
name|lvalue
argument_list|,
name|cb
operator|->
name|buf
operator|+
name|cb
operator|->
name|off
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|cb
operator|->
name|off
operator|+=
literal|3
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void udl_cmd_insert_int_4(struct udl_cmd_buf *cb, uint32_t value) { 	uint32_t lvalue;  	lvalue = htobe32(value); 	bcopy(&lvalue, cb->buf + cb->off, 4);  	cb->off += 4; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|udl_cmd_insert_buf_le16
parameter_list|(
name|struct
name|udl_cmd_buf
modifier|*
name|cb
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|uint32_t
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|len
condition|;
name|x
operator|+=
literal|2
control|)
block|{
comment|/* byte swap from little endian to big endian */
name|cb
operator|->
name|buf
index|[
name|cb
operator|->
name|off
operator|+
name|x
operator|+
literal|0
index|]
operator|=
name|buf
index|[
name|x
operator|+
literal|1
index|]
expr_stmt|;
name|cb
operator|->
name|buf
index|[
name|cb
operator|->
name|off
operator|+
name|x
operator|+
literal|1
index|]
operator|=
name|buf
index|[
name|x
operator|+
literal|0
index|]
expr_stmt|;
block|}
name|cb
operator|->
name|off
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|udl_cmd_write_reg_1
parameter_list|(
name|struct
name|udl_cmd_buf
modifier|*
name|cb
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|UDL_BULK_SOC
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|UDL_BULK_CMD_REG_WRITE_1
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|udl_cmd_write_reg_3
parameter_list|(
name|struct
name|udl_cmd_buf
modifier|*
name|cb
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|udl_cmd_write_reg_1
argument_list|(
name|cb
argument_list|,
name|reg
operator|+
literal|0
argument_list|,
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|udl_cmd_write_reg_1
argument_list|(
name|cb
argument_list|,
name|reg
operator|+
literal|1
argument_list|,
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|udl_cmd_write_reg_1
argument_list|(
name|cb
argument_list|,
name|reg
operator|+
literal|2
argument_list|,
operator|(
name|val
operator|>>
literal|0
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|udl_init_chip
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ui32
decl_stmt|;
name|uint8_t
name|ui8
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|udl_poll
argument_list|(
name|sc
argument_list|,
operator|&
name|ui32
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|DPRINTF
argument_list|(
literal|"poll=0x%08x\n"
argument_list|,
name|ui32
argument_list|)
expr_stmt|;
comment|/* Some products may use later chip too */
switch|switch
condition|(
name|ui32
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0xf1
case|:
comment|/* DL1x5 */
switch|switch
condition|(
name|sc
operator|->
name|sc_chip
condition|)
block|{
case|case
name|DL120
case|:
name|sc
operator|->
name|sc_chip
operator|=
name|DL125
expr_stmt|;
break|break;
case|case
name|DL160
case|:
name|sc
operator|->
name|sc_chip
operator|=
name|DL165
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|DPRINTF
argument_list|(
literal|"chip 0x%04x\n"
argument_list|,
name|sc
operator|->
name|sc_chip
argument_list|)
expr_stmt|;
name|error
operator|=
name|udl_read_1
argument_list|(
name|sc
argument_list|,
literal|0xc484
argument_list|,
operator|&
name|ui8
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|DPRINTF
argument_list|(
literal|"read 0x%02x from 0xc484\n"
argument_list|,
name|ui8
argument_list|)
expr_stmt|;
name|error
operator|=
name|udl_write_1
argument_list|(
name|sc
argument_list|,
literal|0xc41f
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|DPRINTF
argument_list|(
literal|"write 0x01 to 0xc41f\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|udl_read_edid
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_edid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|DPRINTF
argument_list|(
literal|"read EDID\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|udl_set_enc_key
argument_list|(
name|sc
argument_list|,
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|udl_null_key_1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|udl_null_key_1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|DPRINTF
argument_list|(
literal|"set encryption key\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|udl_write_1
argument_list|(
name|sc
argument_list|,
literal|0xc40b
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|DPRINTF
argument_list|(
literal|"write 0x00 to 0xc40b\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|udl_init_fb_offsets
parameter_list|(
name|struct
name|udl_cmd_buf
modifier|*
name|cb
parameter_list|,
name|uint32_t
name|start16
parameter_list|,
name|uint32_t
name|stride16
parameter_list|,
name|uint32_t
name|start8
parameter_list|,
name|uint32_t
name|stride8
parameter_list|)
block|{
name|udl_cmd_write_reg_1
argument_list|(
name|cb
argument_list|,
name|UDL_REG_SYNC
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|udl_cmd_write_reg_3
argument_list|(
name|cb
argument_list|,
name|UDL_REG_ADDR_START16
argument_list|,
name|start16
argument_list|)
expr_stmt|;
name|udl_cmd_write_reg_3
argument_list|(
name|cb
argument_list|,
name|UDL_REG_ADDR_STRIDE16
argument_list|,
name|stride16
argument_list|)
expr_stmt|;
name|udl_cmd_write_reg_3
argument_list|(
name|cb
argument_list|,
name|UDL_REG_ADDR_START8
argument_list|,
name|start8
argument_list|)
expr_stmt|;
name|udl_cmd_write_reg_3
argument_list|(
name|cb
argument_list|,
name|UDL_REG_ADDR_STRIDE8
argument_list|,
name|stride8
argument_list|)
expr_stmt|;
name|udl_cmd_write_reg_1
argument_list|(
name|cb
argument_list|,
name|UDL_REG_SYNC
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|udl_init_resolution
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|uint32_t
name|max
init|=
name|udl_get_fb_size
argument_list|(
name|sc
argument_list|)
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|buf
init|=
name|udl_modes
index|[
name|sc
operator|->
name|sc_cur_mode
index|]
operator|.
name|mode
decl_stmt|;
name|struct
name|udl_cmd_buf
modifier|*
name|cb
decl_stmt|;
name|uint32_t
name|delta
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* get new buffer */
name|cb
operator|=
name|udl_cmd_buf_alloc
argument_list|(
name|sc
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
comment|/* write resolution values and set video memory offsets */
name|udl_cmd_write_reg_1
argument_list|(
name|cb
argument_list|,
name|UDL_REG_SYNC
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UDL_MODE_SIZE
condition|;
name|i
operator|++
control|)
name|udl_cmd_write_reg_1
argument_list|(
name|cb
argument_list|,
name|i
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|udl_cmd_write_reg_1
argument_list|(
name|cb
argument_list|,
name|UDL_REG_SYNC
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|udl_init_fb_offsets
argument_list|(
name|cb
argument_list|,
literal|0x000000
argument_list|,
literal|0x000a00
argument_list|,
literal|0x555555
argument_list|,
literal|0x000500
argument_list|)
expr_stmt|;
name|udl_cmd_buf_send
argument_list|(
name|sc
argument_list|,
name|cb
argument_list|)
expr_stmt|;
comment|/* fill screen with black color */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|+=
name|delta
control|)
block|{
specifier|static
specifier|const
name|uint8_t
name|udl_black
index|[
name|UDL_CMD_MAX_PIXEL_COUNT
operator|*
literal|2
index|]
name|__aligned
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|delta
operator|=
name|max
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|UDL_CMD_MAX_PIXEL_COUNT
operator|*
literal|2
condition|)
name|delta
operator|=
name|UDL_CMD_MAX_PIXEL_COUNT
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|error
operator|=
name|udl_cmd_write_buf_le16
argument_list|(
name|sc
argument_list|,
name|udl_black
argument_list|,
name|i
argument_list|,
name|delta
operator|/
literal|2
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|udl_cmd_buf_copy_le16
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|delta
operator|/
literal|2
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* get new buffer */
name|cb
operator|=
name|udl_cmd_buf_alloc
argument_list|(
name|sc
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
comment|/* show framebuffer content */
name|udl_cmd_write_reg_1
argument_list|(
name|cb
argument_list|,
name|UDL_REG_SCREEN
argument_list|,
name|UDL_REG_SCREEN_ON
argument_list|)
expr_stmt|;
name|udl_cmd_write_reg_1
argument_list|(
name|cb
argument_list|,
name|UDL_REG_SYNC
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|udl_cmd_buf_send
argument_list|(
name|sc
argument_list|,
name|cb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|udl_select_mode
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|udl_mode
name|mode
decl_stmt|;
name|int
name|index
init|=
name|UDL_MAX_MODES
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* try to get the preferred mode from EDID */
name|edid_parse
argument_list|(
name|sc
operator|->
name|sc_edid
argument_list|,
operator|&
name|sc
operator|->
name|sc_edid_info
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|edid_print
argument_list|(
operator|&
name|sc
operator|->
name|sc_edid_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_edid_info
operator|.
name|edid_preferred_mode
operator|!=
name|NULL
condition|)
block|{
name|mode
operator|.
name|hz
operator|=
operator|(
name|sc
operator|->
name|sc_edid_info
operator|.
name|edid_preferred_mode
operator|->
name|dot_clock
operator|*
literal|1000
operator|)
operator|/
operator|(
name|sc
operator|->
name|sc_edid_info
operator|.
name|edid_preferred_mode
operator|->
name|htotal
operator|*
name|sc
operator|->
name|sc_edid_info
operator|.
name|edid_preferred_mode
operator|->
name|vtotal
operator|)
expr_stmt|;
name|mode
operator|.
name|clock
operator|=
name|sc
operator|->
name|sc_edid_info
operator|.
name|edid_preferred_mode
operator|->
name|dot_clock
operator|/
literal|10
expr_stmt|;
name|mode
operator|.
name|hdisplay
operator|=
name|sc
operator|->
name|sc_edid_info
operator|.
name|edid_preferred_mode
operator|->
name|hdisplay
expr_stmt|;
name|mode
operator|.
name|vdisplay
operator|=
name|sc
operator|->
name|sc_edid_info
operator|.
name|edid_preferred_mode
operator|->
name|vdisplay
expr_stmt|;
name|index
operator|=
name|udl_lookup_mode
argument_list|(
name|mode
operator|.
name|hdisplay
argument_list|,
name|mode
operator|.
name|vdisplay
argument_list|,
name|mode
operator|.
name|hz
argument_list|,
name|sc
operator|->
name|sc_chip
argument_list|,
name|mode
operator|.
name|clock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cur_mode
operator|=
name|index
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"no preferred mode found!\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|==
name|UDL_MAX_MODES
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"no mode line found for %dx%d @ %dHz!\n"
argument_list|,
name|mode
operator|.
name|hdisplay
argument_list|,
name|mode
operator|.
name|vdisplay
argument_list|,
name|mode
operator|.
name|hz
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|sc
operator|->
name|sc_edid_info
operator|.
name|edid_nmodes
condition|)
block|{
name|mode
operator|.
name|hz
operator|=
operator|(
name|sc
operator|->
name|sc_edid_info
operator|.
name|edid_modes
index|[
name|i
index|]
operator|.
name|dot_clock
operator|*
literal|1000
operator|)
operator|/
operator|(
name|sc
operator|->
name|sc_edid_info
operator|.
name|edid_modes
index|[
name|i
index|]
operator|.
name|htotal
operator|*
name|sc
operator|->
name|sc_edid_info
operator|.
name|edid_modes
index|[
name|i
index|]
operator|.
name|vtotal
operator|)
expr_stmt|;
name|mode
operator|.
name|clock
operator|=
name|sc
operator|->
name|sc_edid_info
operator|.
name|edid_modes
index|[
name|i
index|]
operator|.
name|dot_clock
operator|/
literal|10
expr_stmt|;
name|mode
operator|.
name|hdisplay
operator|=
name|sc
operator|->
name|sc_edid_info
operator|.
name|edid_modes
index|[
name|i
index|]
operator|.
name|hdisplay
expr_stmt|;
name|mode
operator|.
name|vdisplay
operator|=
name|sc
operator|->
name|sc_edid_info
operator|.
name|edid_modes
index|[
name|i
index|]
operator|.
name|vdisplay
expr_stmt|;
name|index
operator|=
name|udl_lookup_mode
argument_list|(
name|mode
operator|.
name|hdisplay
argument_list|,
name|mode
operator|.
name|vdisplay
argument_list|,
name|mode
operator|.
name|hz
argument_list|,
name|sc
operator|->
name|sc_chip
argument_list|,
name|mode
operator|.
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|UDL_MAX_MODES
condition|)
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_cur_mode
operator|==
name|UDL_MAX_MODES
operator|)
operator|||
operator|(
name|index
operator|>
name|sc
operator|->
name|sc_cur_mode
operator|)
condition|)
name|sc
operator|->
name|sc_cur_mode
operator|=
name|index
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * If no mode found use default. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_cur_mode
operator|==
name|UDL_MAX_MODES
condition|)
name|sc
operator|->
name|sc_cur_mode
operator|=
name|udl_lookup_mode
argument_list|(
literal|800
argument_list|,
literal|600
argument_list|,
literal|60
argument_list|,
name|sc
operator|->
name|sc_chip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|udl_cmd_write_buf_le16
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|off
parameter_list|,
name|uint8_t
name|pixels
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|udl_cmd_buf
modifier|*
name|cb
decl_stmt|;
name|cb
operator|=
name|udl_cmd_buf_alloc
argument_list|(
name|sc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|UDL_BULK_SOC
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|UDL_BULK_CMD_FB_WRITE
operator||
name|UDL_BULK_CMD_FB_WORD
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_3
argument_list|(
name|cb
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
name|udl_cmd_insert_buf_le16
argument_list|(
name|cb
argument_list|,
name|buf
argument_list|,
literal|2
operator|*
name|pixels
argument_list|)
expr_stmt|;
name|udl_cmd_buf_send
argument_list|(
name|sc
argument_list|,
name|cb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udl_cmd_buf_copy_le16
parameter_list|(
name|struct
name|udl_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|src
parameter_list|,
name|uint32_t
name|dst
parameter_list|,
name|uint8_t
name|pixels
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|udl_cmd_buf
modifier|*
name|cb
decl_stmt|;
name|cb
operator|=
name|udl_cmd_buf_alloc
argument_list|(
name|sc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|UDL_BULK_SOC
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|UDL_BULK_CMD_FB_COPY
operator||
name|UDL_BULK_CMD_FB_WORD
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_3
argument_list|(
name|cb
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_1
argument_list|(
name|cb
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
name|udl_cmd_insert_int_3
argument_list|(
name|cb
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|udl_cmd_buf_send
argument_list|(
name|sc
argument_list|,
name|cb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

