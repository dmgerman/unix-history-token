begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2008 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USB_GLOBAL_INCLUDE_FILE
end_ifdef

begin_include
include|#
directive|include
include|USB_GLOBAL_INCLUDE_FILE
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_ioctl.h>
end_include

begin_if
if|#
directive|if
name|USB_HAVE_UGEN
end_if

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|usb_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_dynamic.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_hub.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_msctest.h>
end_include

begin_if
if|#
directive|if
name|USB_HAVE_UGEN
end_if

begin_include
include|#
directive|include
file|<dev/usb/usb_dev.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_generic.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/usb/quirk/usb_quirk.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USB_GLOBAL_INCLUDE_FILE */
end_comment

begin_comment
comment|/* function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|usb_init_endpoint
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|struct
name|usb_endpoint_descriptor
modifier|*
parameter_list|,
name|struct
name|usb_endpoint_ss_comp_descriptor
modifier|*
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_unconfigure
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_detach_device_sub
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|device_t
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|usb_probe_and_attach_sub
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|struct
name|usb_attach_arg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_init_attach_arg
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|struct
name|usb_attach_arg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_suspend_resume_sub
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|device_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|usb_proc_callback_t
name|usbd_clear_stall_proc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|usb_error_t
name|usb_config_parse
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_set_device_strings
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|USB_HAVE_DEVCTL
end_if

begin_function_decl
specifier|static
name|void
name|usb_notify_addq
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|struct
name|usb_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USB_HAVE_UGEN
end_if

begin_function_decl
specifier|static
name|void
name|usb_fifo_free_wrap
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_cdev_create
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_cdev_free
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This variable is global to allow easy access to it: */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USB_TEMPLATE
end_ifdef

begin_decl_stmt
name|int
name|usb_template
init|=
name|USB_TEMPLATE
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|usb_template
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.usb_template"
argument_list|,
operator|&
name|usb_template
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|template
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|usb_template
argument_list|,
literal|0
argument_list|,
literal|"Selected USB device side template"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* English is default language */
end_comment

begin_decl_stmt
specifier|static
name|int
name|usb_lang_id
init|=
literal|0x0009
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usb_lang_mask
init|=
literal|0x00FF
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.usb_lang_id"
argument_list|,
operator|&
name|usb_lang_id
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|usb_lang_id
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|usb_lang_id
argument_list|,
literal|0
argument_list|,
literal|"Preferred USB language ID"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.usb_lang_mask"
argument_list|,
operator|&
name|usb_lang_mask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|usb_lang_mask
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|usb_lang_mask
argument_list|,
literal|0
argument_list|,
literal|"Preferred USB language mask"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|statestr
index|[
name|USB_STATE_MAX
index|]
init|=
block|{
index|[
name|USB_STATE_DETACHED
index|]
operator|=
literal|"DETACHED"
block|,
index|[
name|USB_STATE_ATTACHED
index|]
operator|=
literal|"ATTACHED"
block|,
index|[
name|USB_STATE_POWERED
index|]
operator|=
literal|"POWERED"
block|,
index|[
name|USB_STATE_ADDRESSED
index|]
operator|=
literal|"ADDRESSED"
block|,
index|[
name|USB_STATE_CONFIGURED
index|]
operator|=
literal|"CONFIGURED"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|usb_statestr
parameter_list|(
name|enum
name|usb_dev_state
name|state
parameter_list|)
block|{
return|return
operator|(
operator|(
name|state
operator|<
name|USB_STATE_MAX
operator|)
condition|?
name|statestr
index|[
name|state
index|]
else|:
literal|"UNKNOWN"
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|usb_get_manufacturer
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
return|return
operator|(
name|udev
operator|->
name|manufacturer
condition|?
name|udev
operator|->
name|manufacturer
else|:
literal|"Unknown"
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|usb_get_product
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
return|return
operator|(
name|udev
operator|->
name|product
condition|?
name|udev
operator|->
name|product
else|:
literal|""
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|usb_get_serial
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
return|return
operator|(
name|udev
operator|->
name|serial
condition|?
name|udev
operator|->
name|serial
else|:
literal|""
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_get_ep_by_addr  *  * This function searches for an USB ep by endpoint address and  * direction.  *  * Returns:  * NULL: Failure  * Else: Success  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb_endpoint
modifier|*
name|usbd_get_ep_by_addr
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|ea_val
parameter_list|)
block|{
name|struct
name|usb_endpoint
modifier|*
name|ep
init|=
name|udev
operator|->
name|endpoints
decl_stmt|;
name|struct
name|usb_endpoint
modifier|*
name|ep_end
init|=
name|udev
operator|->
name|endpoints
operator|+
name|udev
operator|->
name|endpoints_max
decl_stmt|;
enum|enum
block|{
name|EA_MASK
init|=
operator|(
name|UE_DIR_IN
operator||
name|UE_DIR_OUT
operator||
name|UE_ADDR
operator|)
block|, 	}
enum|;
comment|/* 	 * According to the USB specification not all bits are used 	 * for the endpoint address. Keep defined bits only: 	 */
name|ea_val
operator|&=
name|EA_MASK
expr_stmt|;
comment|/* 	 * Iterate accross all the USB endpoints searching for a match 	 * based on the endpoint address: 	 */
for|for
control|(
init|;
name|ep
operator|!=
name|ep_end
condition|;
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|ep
operator|->
name|edesc
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
comment|/* do the mask and check the value */
if|if
condition|(
operator|(
name|ep
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|EA_MASK
operator|)
operator|==
name|ea_val
condition|)
block|{
goto|goto
name|found
goto|;
block|}
block|}
comment|/* 	 * The default endpoint is always present and is checked separately: 	 */
if|if
condition|(
operator|(
name|udev
operator|->
name|ctrl_ep
operator|.
name|edesc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|udev
operator|->
name|ctrl_ep
operator|.
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|EA_MASK
operator|)
operator|==
name|ea_val
operator|)
condition|)
block|{
name|ep
operator|=
operator|&
name|udev
operator|->
name|ctrl_ep
expr_stmt|;
goto|goto
name|found
goto|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
name|found
label|:
return|return
operator|(
name|ep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_get_endpoint  *  * This function searches for an USB endpoint based on the information  * given by the passed "struct usb_config" pointer.  *  * Return values:  * NULL: No match.  * Else: Pointer to "struct usb_endpoint".  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb_endpoint
modifier|*
name|usbd_get_endpoint
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
specifier|const
name|struct
name|usb_config
modifier|*
name|setup
parameter_list|)
block|{
name|struct
name|usb_endpoint
modifier|*
name|ep
init|=
name|udev
operator|->
name|endpoints
decl_stmt|;
name|struct
name|usb_endpoint
modifier|*
name|ep_end
init|=
name|udev
operator|->
name|endpoints
operator|+
name|udev
operator|->
name|endpoints_max
decl_stmt|;
name|uint8_t
name|index
init|=
name|setup
operator|->
name|ep_index
decl_stmt|;
name|uint8_t
name|ea_mask
decl_stmt|;
name|uint8_t
name|ea_val
decl_stmt|;
name|uint8_t
name|type_mask
decl_stmt|;
name|uint8_t
name|type_val
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
literal|"udev=%p iface_index=%d address=0x%x "
literal|"type=0x%x dir=0x%x index=%d\n"
argument_list|,
name|udev
argument_list|,
name|iface_index
argument_list|,
name|setup
operator|->
name|endpoint
argument_list|,
name|setup
operator|->
name|type
argument_list|,
name|setup
operator|->
name|direction
argument_list|,
name|setup
operator|->
name|ep_index
argument_list|)
expr_stmt|;
comment|/* check USB mode */
if|if
condition|(
name|setup
operator|->
name|usb_mode
operator|!=
name|USB_MODE_DUAL
operator|&&
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|!=
name|setup
operator|->
name|usb_mode
condition|)
block|{
comment|/* wrong mode - no endpoint */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* setup expected endpoint direction mask and value */
if|if
condition|(
name|setup
operator|->
name|direction
operator|==
name|UE_DIR_RX
condition|)
block|{
name|ea_mask
operator|=
operator|(
name|UE_DIR_IN
operator||
name|UE_DIR_OUT
operator|)
expr_stmt|;
name|ea_val
operator|=
operator|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
operator|)
condition|?
name|UE_DIR_OUT
else|:
name|UE_DIR_IN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|setup
operator|->
name|direction
operator|==
name|UE_DIR_TX
condition|)
block|{
name|ea_mask
operator|=
operator|(
name|UE_DIR_IN
operator||
name|UE_DIR_OUT
operator|)
expr_stmt|;
name|ea_val
operator|=
operator|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
operator|)
condition|?
name|UE_DIR_IN
else|:
name|UE_DIR_OUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|setup
operator|->
name|direction
operator|==
name|UE_DIR_ANY
condition|)
block|{
comment|/* match any endpoint direction */
name|ea_mask
operator|=
literal|0
expr_stmt|;
name|ea_val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* match the given endpoint direction */
name|ea_mask
operator|=
operator|(
name|UE_DIR_IN
operator||
name|UE_DIR_OUT
operator|)
expr_stmt|;
name|ea_val
operator|=
operator|(
name|setup
operator|->
name|direction
operator|&
operator|(
name|UE_DIR_IN
operator||
name|UE_DIR_OUT
operator|)
operator|)
expr_stmt|;
block|}
comment|/* setup expected endpoint address */
if|if
condition|(
name|setup
operator|->
name|endpoint
operator|==
name|UE_ADDR_ANY
condition|)
block|{
comment|/* match any endpoint address */
block|}
else|else
block|{
comment|/* match the given endpoint address */
name|ea_mask
operator||=
name|UE_ADDR
expr_stmt|;
name|ea_val
operator||=
operator|(
name|setup
operator|->
name|endpoint
operator|&
name|UE_ADDR
operator|)
expr_stmt|;
block|}
comment|/* setup expected endpoint type */
if|if
condition|(
name|setup
operator|->
name|type
operator|==
name|UE_BULK_INTR
condition|)
block|{
comment|/* this will match BULK and INTERRUPT endpoints */
name|type_mask
operator|=
literal|2
expr_stmt|;
name|type_val
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|setup
operator|->
name|type
operator|==
name|UE_TYPE_ANY
condition|)
block|{
comment|/* match any endpoint type */
name|type_mask
operator|=
literal|0
expr_stmt|;
name|type_val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* match the given endpoint type */
name|type_mask
operator|=
name|UE_XFERTYPE
expr_stmt|;
name|type_val
operator|=
operator|(
name|setup
operator|->
name|type
operator|&
name|UE_XFERTYPE
operator|)
expr_stmt|;
block|}
comment|/* 	 * Iterate accross all the USB endpoints searching for a match 	 * based on the endpoint address. Note that we are searching 	 * the endpoints from the beginning of the "udev->endpoints" array. 	 */
for|for
control|(
init|;
name|ep
operator|!=
name|ep_end
condition|;
name|ep
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|edesc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ep
operator|->
name|iface_index
operator|!=
name|iface_index
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* do the masks and check the values */
if|if
condition|(
operator|(
operator|(
name|ep
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|ea_mask
operator|)
operator|==
name|ea_val
operator|)
operator|&&
operator|(
operator|(
name|ep
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|type_mask
operator|)
operator|==
name|type_val
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|index
operator|--
condition|)
block|{
goto|goto
name|found
goto|;
block|}
block|}
block|}
comment|/* 	 * Match against default endpoint last, so that "any endpoint", "any 	 * address" and "any direction" returns the first endpoint of the 	 * interface. "iface_index" and "direction" is ignored: 	 */
if|if
condition|(
operator|(
name|udev
operator|->
name|ctrl_ep
operator|.
name|edesc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|udev
operator|->
name|ctrl_ep
operator|.
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|ea_mask
operator|)
operator|==
name|ea_val
operator|)
operator|&&
operator|(
operator|(
name|udev
operator|->
name|ctrl_ep
operator|.
name|edesc
operator|->
name|bmAttributes
operator|&
name|type_mask
operator|)
operator|==
name|type_val
operator|)
operator|&&
operator|(
operator|!
name|index
operator|)
condition|)
block|{
name|ep
operator|=
operator|&
name|udev
operator|->
name|ctrl_ep
expr_stmt|;
goto|goto
name|found
goto|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
name|found
label|:
return|return
operator|(
name|ep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_interface_count  *  * This function stores the number of USB interfaces excluding  * alternate settings, which the USB config descriptor reports into  * the unsigned 8-bit integer pointed to by "count".  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb_error_t
name|usbd_interface_count
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
modifier|*
name|count
parameter_list|)
block|{
if|if
condition|(
name|udev
operator|->
name|cdesc
operator|==
name|NULL
condition|)
block|{
operator|*
name|count
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|USB_ERR_NOT_CONFIGURED
operator|)
return|;
block|}
operator|*
name|count
operator|=
name|udev
operator|->
name|ifaces_max
expr_stmt|;
return|return
operator|(
name|USB_ERR_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_init_endpoint  *  * This function will initialise the USB endpoint structure pointed to by  * the "endpoint" argument. The structure pointed to by "endpoint" must be  * zeroed before calling this function.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_init_endpoint
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|struct
name|usb_endpoint_descriptor
modifier|*
name|edesc
parameter_list|,
name|struct
name|usb_endpoint_ss_comp_descriptor
modifier|*
name|ecomp
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|usb_bus_methods
modifier|*
name|methods
decl_stmt|;
name|usb_stream_t
name|x
decl_stmt|;
name|methods
operator|=
name|udev
operator|->
name|bus
operator|->
name|methods
expr_stmt|;
call|(
name|methods
operator|->
name|endpoint_init
call|)
argument_list|(
name|udev
argument_list|,
name|edesc
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* initialise USB endpoint structure */
name|ep
operator|->
name|edesc
operator|=
name|edesc
expr_stmt|;
name|ep
operator|->
name|ecomp
operator|=
name|ecomp
expr_stmt|;
name|ep
operator|->
name|iface_index
operator|=
name|iface_index
expr_stmt|;
comment|/* setup USB stream queues */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|USB_MAX_EP_STREAMS
condition|;
name|x
operator|++
control|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|ep
operator|->
name|endpoint_q
index|[
name|x
index|]
operator|.
name|head
argument_list|)
expr_stmt|;
name|ep
operator|->
name|endpoint_q
index|[
name|x
index|]
operator|.
name|command
operator|=
operator|&
name|usbd_pipe_start
expr_stmt|;
block|}
comment|/* the pipe is not supported by the hardware */
if|if
condition|(
name|ep
operator|->
name|methods
operator|==
name|NULL
condition|)
return|return;
comment|/* check for SUPER-speed streams mode endpoint */
if|if
condition|(
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_SUPER
operator|&&
name|ecomp
operator|!=
name|NULL
operator|&&
operator|(
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|==
name|UE_BULK
operator|&&
operator|(
name|UE_GET_BULK_STREAMS
argument_list|(
name|ecomp
operator|->
name|bmAttributes
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|usbd_set_endpoint_mode
argument_list|(
name|udev
argument_list|,
name|ep
argument_list|,
name|USB_EP_MODE_STREAMS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usbd_set_endpoint_mode
argument_list|(
name|udev
argument_list|,
name|ep
argument_list|,
name|USB_EP_MODE_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/* clear stall, if any */
if|if
condition|(
name|methods
operator|->
name|clear_stall
operator|!=
name|NULL
condition|)
block|{
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
call|(
name|methods
operator|->
name|clear_stall
call|)
argument_list|(
name|udev
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------*  *	usb_endpoint_foreach  *  * This function will iterate all the USB endpoints except the control  * endpoint. This function is NULL safe.  *  * Return values:  * NULL: End of USB endpoints  * Else: Pointer to next USB endpoint  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb_endpoint
modifier|*
name|usb_endpoint_foreach
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|usb_endpoint
modifier|*
name|ep_end
decl_stmt|;
comment|/* be NULL safe */
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ep_end
operator|=
name|udev
operator|->
name|endpoints
operator|+
name|udev
operator|->
name|endpoints_max
expr_stmt|;
comment|/* get next endpoint */
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|ep
operator|=
name|udev
operator|->
name|endpoints
expr_stmt|;
else|else
name|ep
operator|++
expr_stmt|;
comment|/* find next allocated ep */
while|while
condition|(
name|ep
operator|!=
name|ep_end
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|edesc
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ep
operator|)
return|;
name|ep
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_wait_pending_refs  *  * This function will wait for any USB references to go away before  * returning. This function is used before freeing a USB device.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_wait_pending_refs
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
if|#
directive|if
name|USB_HAVE_UGEN
name|DPRINTF
argument_list|(
literal|"Refcount = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|udev
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
name|udev
operator|->
name|refcount
operator|--
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* wait for any pending references to go away */
if|if
condition|(
name|udev
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
comment|/* prevent further refs being taken, if any */
name|udev
operator|->
name|refcount
operator|=
name|USB_DEV_REF_MAX
expr_stmt|;
break|break;
block|}
name|cv_wait
argument_list|(
operator|&
name|udev
operator|->
name|ref_cv
argument_list|,
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_unconfigure  *  * This function will free all USB interfaces and USB endpoints belonging  * to an USB device.  *  * Flag values, see "USB_UNCFG_FLAG_XXX".  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_unconfigure
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|flag
parameter_list|)
block|{
name|uint8_t
name|do_unlock
decl_stmt|;
comment|/* Prevent re-enumeration */
name|do_unlock
operator|=
name|usbd_enum_lock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
comment|/* detach all interface drivers */
name|usb_detach_device
argument_list|(
name|udev
argument_list|,
name|USB_IFACE_INDEX_ANY
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_HAVE_UGEN
comment|/* free all FIFOs except control endpoint FIFOs */
name|usb_fifo_free_wrap
argument_list|(
name|udev
argument_list|,
name|USB_IFACE_INDEX_ANY
argument_list|,
name|flag
argument_list|)
expr_stmt|;
comment|/* 	 * Free all cdev's, if any. 	 */
name|usb_cdev_free
argument_list|(
name|udev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|USB_HAVE_COMPAT_LINUX
comment|/* free Linux compat device, if any */
if|if
condition|(
name|udev
operator|->
name|linux_endpoint_start
condition|)
block|{
name|usb_linux_free_device
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|udev
operator|->
name|linux_endpoint_start
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|usb_config_parse
argument_list|(
name|udev
argument_list|,
name|USB_IFACE_INDEX_ANY
argument_list|,
name|USB_CFG_FREE
argument_list|)
expr_stmt|;
comment|/* free "cdesc" after "ifaces" and "endpoints", if any */
if|if
condition|(
name|udev
operator|->
name|cdesc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|!=
name|USB_MODE_DEVICE
condition|)
name|usbd_free_config_desc
argument_list|(
name|udev
argument_list|,
name|udev
operator|->
name|cdesc
argument_list|)
expr_stmt|;
name|udev
operator|->
name|cdesc
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* set unconfigured state */
name|udev
operator|->
name|curr_config_no
operator|=
name|USB_UNCONFIG_NO
expr_stmt|;
name|udev
operator|->
name|curr_config_index
operator|=
name|USB_UNCONFIG_INDEX
expr_stmt|;
if|if
condition|(
name|do_unlock
condition|)
name|usbd_enum_unlock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_set_config_index  *  * This function selects configuration by index, independent of the  * actual configuration number. This function should not be used by  * USB drivers.  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb_error_t
name|usbd_set_config_index
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|index
parameter_list|)
block|{
name|struct
name|usb_status
name|ds
decl_stmt|;
name|struct
name|usb_config_descriptor
modifier|*
name|cdp
decl_stmt|;
name|uint16_t
name|power
decl_stmt|;
name|uint16_t
name|max_power
decl_stmt|;
name|uint8_t
name|selfpowered
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"udev=%p index=%d\n"
argument_list|,
name|udev
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* Prevent re-enumeration */
name|do_unlock
operator|=
name|usbd_enum_lock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|usb_unconfigure
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|USB_UNCONFIG_INDEX
condition|)
block|{
comment|/* 		 * Leave unallocated when unconfiguring the 		 * device. "usb_unconfigure()" will also reset 		 * the current config number and index. 		 */
name|err
operator|=
name|usbd_req_set_config
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|USB_UNCONFIG_NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|state
operator|==
name|USB_STATE_CONFIGURED
condition|)
name|usb_set_device_state
argument_list|(
name|udev
argument_list|,
name|USB_STATE_ADDRESSED
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* get the full config descriptor */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
comment|/* save some memory */
name|err
operator|=
name|usbd_req_get_descriptor_ptr
argument_list|(
name|udev
argument_list|,
operator|&
name|cdp
argument_list|,
operator|(
name|UDESC_CONFIG
operator|<<
literal|8
operator|)
operator||
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* normal request */
name|err
operator|=
name|usbd_req_get_config_desc_full
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
operator|&
name|cdp
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* set the new config descriptor */
name|udev
operator|->
name|cdesc
operator|=
name|cdp
expr_stmt|;
comment|/* Figure out if the device is self or bus powered. */
name|selfpowered
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|udev
operator|->
name|flags
operator|.
name|uq_bus_powered
operator|)
operator|&&
operator|(
name|cdp
operator|->
name|bmAttributes
operator|&
name|UC_SELF_POWERED
operator|)
operator|&&
operator|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_HOST
operator|)
condition|)
block|{
comment|/* May be self powered. */
if|if
condition|(
name|cdp
operator|->
name|bmAttributes
operator|&
name|UC_BUS_POWERED
condition|)
block|{
comment|/* Must ask device. */
name|err
operator|=
name|usbd_req_get_device_status
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"could not read "
literal|"device status: %s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UGETW
argument_list|(
name|ds
operator|.
name|wStatus
argument_list|)
operator|&
name|UDS_SELF_POWERED
condition|)
block|{
name|selfpowered
operator|=
literal|1
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"status=0x%04x \n"
argument_list|,
name|UGETW
argument_list|(
name|ds
operator|.
name|wStatus
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|selfpowered
operator|=
literal|1
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"udev=%p cdesc=%p (addr %d) cno=%d attr=0x%02x, "
literal|"selfpowered=%d, power=%d\n"
argument_list|,
name|udev
argument_list|,
name|cdp
argument_list|,
name|udev
operator|->
name|address
argument_list|,
name|cdp
operator|->
name|bConfigurationValue
argument_list|,
name|cdp
operator|->
name|bmAttributes
argument_list|,
name|selfpowered
argument_list|,
name|cdp
operator|->
name|bMaxPower
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* Check if we have enough power. */
name|power
operator|=
name|cdp
operator|->
name|bMaxPower
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|parent_hub
condition|)
block|{
name|max_power
operator|=
name|udev
operator|->
name|parent_hub
operator|->
name|hub
operator|->
name|portpower
expr_stmt|;
block|}
else|else
block|{
name|max_power
operator|=
name|USB_MAX_POWER
expr_stmt|;
block|}
if|if
condition|(
name|power
operator|>
name|max_power
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"power exceeded %d> %d\n"
argument_list|,
name|power
argument_list|,
name|max_power
argument_list|)
expr_stmt|;
name|err
operator|=
name|USB_ERR_NO_POWER
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Only update "self_powered" in USB Host Mode */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_HOST
condition|)
block|{
name|udev
operator|->
name|flags
operator|.
name|self_powered
operator|=
name|selfpowered
expr_stmt|;
block|}
name|udev
operator|->
name|power
operator|=
name|power
expr_stmt|;
name|udev
operator|->
name|curr_config_no
operator|=
name|cdp
operator|->
name|bConfigurationValue
expr_stmt|;
name|udev
operator|->
name|curr_config_index
operator|=
name|index
expr_stmt|;
name|usb_set_device_state
argument_list|(
name|udev
argument_list|,
name|USB_STATE_CONFIGURED
argument_list|)
expr_stmt|;
comment|/* Set the actual configuration value. */
name|err
operator|=
name|usbd_req_set_config
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|cdp
operator|->
name|bConfigurationValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|err
operator|=
name|usb_config_parse
argument_list|(
name|udev
argument_list|,
name|USB_IFACE_INDEX_ANY
argument_list|,
name|USB_CFG_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|err
operator|=
name|usb_config_parse
argument_list|(
name|udev
argument_list|,
name|USB_IFACE_INDEX_ANY
argument_list|,
name|USB_CFG_INIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|#
directive|if
name|USB_HAVE_UGEN
comment|/* create device nodes for each endpoint */
name|usb_cdev_create
argument_list|(
name|udev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|done
label|:
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|usb_unconfigure
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_unlock
condition|)
name|usbd_enum_unlock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_config_parse  *  * This function will allocate and free USB interfaces and USB endpoints,  * parse the USB configuration structure and initialise the USB endpoints  * and interfaces. If "iface_index" is not equal to  * "USB_IFACE_INDEX_ANY" then the "cmd" parameter is the  * alternate_setting to be selected for the given interface. Else the  * "cmd" parameter is defined by "USB_CFG_XXX". "iface_index" can be  * "USB_IFACE_INDEX_ANY" or a valid USB interface index. This function  * is typically called when setting the configuration or when setting  * an alternate interface.  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|usb_error_t
name|usb_config_parse
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|cmd
parameter_list|)
block|{
name|struct
name|usb_idesc_parse_state
name|ips
decl_stmt|;
name|struct
name|usb_interface_descriptor
modifier|*
name|id
decl_stmt|;
name|struct
name|usb_endpoint_descriptor
modifier|*
name|ed
decl_stmt|;
name|struct
name|usb_interface
modifier|*
name|iface
decl_stmt|;
name|struct
name|usb_endpoint
modifier|*
name|ep
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|uint8_t
name|ep_curr
decl_stmt|;
name|uint8_t
name|ep_max
decl_stmt|;
name|uint8_t
name|temp
decl_stmt|;
name|uint8_t
name|do_init
decl_stmt|;
name|uint8_t
name|alt_index
decl_stmt|;
if|if
condition|(
name|iface_index
operator|!=
name|USB_IFACE_INDEX_ANY
condition|)
block|{
comment|/* parameter overload */
name|alt_index
operator|=
name|cmd
expr_stmt|;
name|cmd
operator|=
name|USB_CFG_INIT
expr_stmt|;
block|}
else|else
block|{
comment|/* not used */
name|alt_index
operator|=
literal|0
expr_stmt|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"iface_index=%d cmd=%d\n"
argument_list|,
name|iface_index
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|USB_CFG_FREE
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|cmd
operator|==
name|USB_CFG_INIT
condition|)
block|{
name|sx_assert
argument_list|(
operator|&
name|udev
operator|->
name|enum_sx
argument_list|,
name|SA_LOCKED
argument_list|)
expr_stmt|;
comment|/* check for in-use endpoints */
name|ep
operator|=
name|udev
operator|->
name|endpoints
expr_stmt|;
name|ep_max
operator|=
name|udev
operator|->
name|endpoints_max
expr_stmt|;
while|while
condition|(
name|ep_max
operator|--
condition|)
block|{
comment|/* look for matching endpoints */
if|if
condition|(
operator|(
name|iface_index
operator|==
name|USB_IFACE_INDEX_ANY
operator|)
operator|||
operator|(
name|iface_index
operator|==
name|ep
operator|->
name|iface_index
operator|)
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|refcount_alloc
operator|!=
literal|0
condition|)
block|{
comment|/* 					 * This typically indicates a 					 * more serious error. 					 */
name|err
operator|=
name|USB_ERR_IN_USE
expr_stmt|;
block|}
else|else
block|{
comment|/* reset endpoint */
name|memset
argument_list|(
name|ep
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make sure we don't zero the endpoint again */
name|ep
operator|->
name|iface_index
operator|=
name|USB_IFACE_INDEX_ANY
expr_stmt|;
block|}
block|}
name|ep
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|ips
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ips
argument_list|)
argument_list|)
expr_stmt|;
name|ep_curr
operator|=
literal|0
expr_stmt|;
name|ep_max
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|id
operator|=
name|usb_idesc_foreach
argument_list|(
name|udev
operator|->
name|cdesc
argument_list|,
operator|&
name|ips
argument_list|)
operator|)
condition|)
block|{
name|iface
operator|=
name|udev
operator|->
name|ifaces
operator|+
name|ips
operator|.
name|iface_index
expr_stmt|;
comment|/* check for specific interface match */
if|if
condition|(
name|cmd
operator|==
name|USB_CFG_INIT
condition|)
block|{
if|if
condition|(
operator|(
name|iface_index
operator|!=
name|USB_IFACE_INDEX_ANY
operator|)
operator|&&
operator|(
name|iface_index
operator|!=
name|ips
operator|.
name|iface_index
operator|)
condition|)
block|{
comment|/* wrong interface */
name|do_init
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alt_index
operator|!=
name|ips
operator|.
name|iface_index_alt
condition|)
block|{
comment|/* wrong alternate setting */
name|do_init
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* initialise interface */
name|do_init
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|do_init
operator|=
literal|0
expr_stmt|;
comment|/* check for new interface */
if|if
condition|(
name|ips
operator|.
name|iface_index_alt
operator|==
literal|0
condition|)
block|{
comment|/* update current number of endpoints */
name|ep_curr
operator|=
name|ep_max
expr_stmt|;
block|}
comment|/* check for init */
if|if
condition|(
name|do_init
condition|)
block|{
comment|/* setup the USB interface structure */
name|iface
operator|->
name|idesc
operator|=
name|id
expr_stmt|;
comment|/* set alternate index */
name|iface
operator|->
name|alt_index
operator|=
name|alt_index
expr_stmt|;
comment|/* set default interface parent */
if|if
condition|(
name|iface_index
operator|==
name|USB_IFACE_INDEX_ANY
condition|)
block|{
name|iface
operator|->
name|parent_iface_index
operator|=
name|USB_IFACE_INDEX_ANY
expr_stmt|;
block|}
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"found idesc nendpt=%d\n"
argument_list|,
name|id
operator|->
name|bNumEndpoints
argument_list|)
expr_stmt|;
name|ed
operator|=
operator|(
expr|struct
name|usb_endpoint_descriptor
operator|*
operator|)
name|id
expr_stmt|;
name|temp
operator|=
name|ep_curr
expr_stmt|;
comment|/* iterate all the endpoint descriptors */
while|while
condition|(
operator|(
name|ed
operator|=
name|usb_edesc_foreach
argument_list|(
name|udev
operator|->
name|cdesc
argument_list|,
name|ed
argument_list|)
operator|)
condition|)
block|{
comment|/* check if endpoint limit has been reached */
if|if
condition|(
name|temp
operator|>=
name|USB_MAX_EP_UNITS
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Endpoint limit reached\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ep
operator|=
name|udev
operator|->
name|endpoints
operator|+
name|temp
expr_stmt|;
if|if
condition|(
name|do_init
condition|)
block|{
name|void
modifier|*
name|ecomp
decl_stmt|;
name|ecomp
operator|=
name|usb_ed_comp_foreach
argument_list|(
name|udev
operator|->
name|cdesc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecomp
operator|!=
name|NULL
condition|)
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"Found endpoint companion descriptor\n"
argument_list|)
expr_stmt|;
name|usb_init_endpoint
argument_list|(
name|udev
argument_list|,
name|ips
operator|.
name|iface_index
argument_list|,
name|ed
argument_list|,
name|ecomp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
name|temp
operator|++
expr_stmt|;
comment|/* find maximum number of endpoints */
if|if
condition|(
name|ep_max
operator|<
name|temp
condition|)
name|ep_max
operator|=
name|temp
expr_stmt|;
block|}
block|}
comment|/* NOTE: It is valid to have no interfaces and no endpoints! */
if|if
condition|(
name|cmd
operator|==
name|USB_CFG_ALLOC
condition|)
block|{
name|udev
operator|->
name|ifaces_max
operator|=
name|ips
operator|.
name|iface_index
expr_stmt|;
if|#
directive|if
operator|(
name|USB_HAVE_FIXED_IFACE
operator|==
literal|0
operator|)
name|udev
operator|->
name|ifaces
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|ifaces_max
operator|!=
literal|0
condition|)
block|{
name|udev
operator|->
name|ifaces
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|iface
argument_list|)
operator|*
name|udev
operator|->
name|ifaces_max
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|ifaces
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
operator|(
name|USB_HAVE_FIXED_ENDPOINT
operator|==
literal|0
operator|)
if|if
condition|(
name|ep_max
operator|!=
literal|0
condition|)
block|{
name|udev
operator|->
name|endpoints
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|*
name|ep_max
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|endpoints
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
name|udev
operator|->
name|endpoints
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|udev
operator|->
name|endpoints_max
operator|=
name|ep_max
expr_stmt|;
comment|/* reset any ongoing clear-stall */
name|udev
operator|->
name|ep_curr
operator|=
name|NULL
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|USB_HAVE_FIXED_IFACE
operator|==
literal|0
operator|)
operator|||
operator|(
name|USB_HAVE_FIXED_ENDPOINT
operator|==
literal|0
operator|)
name|done
label|:
endif|#
directive|endif
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
name|USB_CFG_ALLOC
condition|)
block|{
name|cleanup
label|:
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|udev
operator|->
name|endpoints_max
operator|=
literal|0
expr_stmt|;
comment|/* reset any ongoing clear-stall */
name|udev
operator|->
name|ep_curr
operator|=
name|NULL
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|USB_HAVE_FIXED_IFACE
operator|==
literal|0
operator|)
name|free
argument_list|(
name|udev
operator|->
name|ifaces
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|udev
operator|->
name|ifaces
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|USB_HAVE_FIXED_ENDPOINT
operator|==
literal|0
operator|)
name|free
argument_list|(
name|udev
operator|->
name|endpoints
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|udev
operator|->
name|endpoints
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|udev
operator|->
name|ifaces_max
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_set_alt_interface_index  *  * This function will select an alternate interface index for the  * given interface index. The interface should not be in use when this  * function is called. That means there should not be any open USB  * transfers. Else an error is returned. If the alternate setting is  * already set this function will simply return success. This function  * is called in Host mode and Device mode!  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb_error_t
name|usbd_set_alt_interface_index
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|alt_index
parameter_list|)
block|{
name|struct
name|usb_interface
modifier|*
name|iface
init|=
name|usbd_get_iface
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|)
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
comment|/* Prevent re-enumeration */
name|do_unlock
operator|=
name|usbd_enum_lock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|iface
operator|->
name|alt_index
operator|==
name|alt_index
condition|)
block|{
comment|/*  		 * Optimise away duplicate setting of 		 * alternate setting in USB Host Mode! 		 */
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|#
directive|if
name|USB_HAVE_UGEN
comment|/* 	 * Free all generic FIFOs for this interface, except control 	 * endpoint FIFOs: 	 */
name|usb_fifo_free_wrap
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|usb_config_parse
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|,
name|alt_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|iface
operator|->
name|alt_index
operator|!=
name|alt_index
condition|)
block|{
comment|/* the alternate setting does not exist */
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|err
operator|=
name|usbd_req_set_alt_interface_no
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|iface_index
argument_list|,
name|iface
operator|->
name|idesc
operator|->
name|bAlternateSetting
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|do_unlock
condition|)
name|usbd_enum_unlock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_set_endpoint_stall  *  * This function is used to make a BULK or INTERRUPT endpoint send  * STALL tokens in USB device mode.  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb_error_t
name|usbd_set_endpoint_stall
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|,
name|uint8_t
name|do_stall
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|usb_stream_t
name|x
decl_stmt|;
name|uint8_t
name|et
decl_stmt|;
name|uint8_t
name|was_stalled
decl_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
block|{
comment|/* nothing to do */
name|DPRINTF
argument_list|(
literal|"Cannot find endpoint\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Pretend that the clear or set stall request is 		 * successful else some USB host stacks can do 		 * strange things, especially when a control endpoint 		 * stalls. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|et
operator|=
operator|(
name|ep
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|et
operator|!=
name|UE_BULK
operator|)
operator|&&
operator|(
name|et
operator|!=
name|UE_INTERRUPT
operator|)
condition|)
block|{
comment|/* 	         * Should not stall control 	         * nor isochronous endpoints. 	         */
name|DPRINTF
argument_list|(
literal|"Invalid endpoint\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* store current stall state */
name|was_stalled
operator|=
name|ep
operator|->
name|is_stalled
expr_stmt|;
comment|/* check for no change */
if|if
condition|(
name|was_stalled
operator|&&
name|do_stall
condition|)
block|{
comment|/* if the endpoint is already stalled do nothing */
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"No change\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* set stalled state */
name|ep
operator|->
name|is_stalled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|do_stall
operator|||
operator|(
operator|!
name|was_stalled
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|was_stalled
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|USB_MAX_EP_STREAMS
condition|;
name|x
operator|++
control|)
block|{
comment|/* lookup the current USB transfer, if any */
name|xfer
operator|=
name|ep
operator|->
name|endpoint_q
index|[
name|x
index|]
operator|.
name|curr
expr_stmt|;
if|if
condition|(
name|xfer
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * The "xfer_stall" method 					 * will complete the USB 					 * transfer like in case of a 					 * timeout setting the error 					 * code "USB_ERR_STALLED". 					 */
call|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|xfer_stall
call|)
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
call|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|set_stall
call|)
argument_list|(
name|udev
argument_list|,
name|ep
argument_list|,
operator|&
name|do_stall
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_stall
condition|)
block|{
name|ep
operator|->
name|toggle_next
operator|=
literal|0
expr_stmt|;
comment|/* reset data toggle */
name|ep
operator|->
name|is_stalled
operator|=
literal|0
expr_stmt|;
comment|/* clear stalled state */
call|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|clear_stall
call|)
argument_list|(
name|udev
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* start the current or next transfer, if any */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|USB_MAX_EP_STREAMS
condition|;
name|x
operator|++
control|)
block|{
name|usb_command_wrapper
argument_list|(
operator|&
name|ep
operator|->
name|endpoint_q
index|[
name|x
index|]
argument_list|,
name|ep
operator|->
name|endpoint_q
index|[
name|x
index|]
operator|.
name|curr
argument_list|)
expr_stmt|;
block|}
block|}
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_reset_iface_endpoints - used in USB device side mode  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb_error_t
name|usb_reset_iface_endpoints
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|)
block|{
name|struct
name|usb_endpoint
modifier|*
name|ep
decl_stmt|;
name|struct
name|usb_endpoint
modifier|*
name|ep_end
decl_stmt|;
name|ep
operator|=
name|udev
operator|->
name|endpoints
expr_stmt|;
name|ep_end
operator|=
name|udev
operator|->
name|endpoints
operator|+
name|udev
operator|->
name|endpoints_max
expr_stmt|;
for|for
control|(
init|;
name|ep
operator|!=
name|ep_end
condition|;
name|ep
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|edesc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ep
operator|->
name|iface_index
operator|!=
name|iface_index
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* simulate a clear stall from the peer */
name|usbd_set_endpoint_stall
argument_list|(
name|udev
argument_list|,
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_detach_device_sub  *  * This function will try to detach an USB device. If it fails a panic  * will result.  *  * Flag values, see "USB_UNCFG_FLAG_XXX".  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_detach_device_sub
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|device_t
modifier|*
name|ppdev
parameter_list|,
name|char
modifier|*
modifier|*
name|ppnpinfo
parameter_list|,
name|uint8_t
name|flag
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|char
modifier|*
name|pnpinfo
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dev
operator|=
operator|*
name|ppdev
expr_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
comment|/* 		 * NOTE: It is important to clear "*ppdev" before deleting 		 * the child due to some device methods being called late 		 * during the delete process ! 		 */
operator|*
name|ppdev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|rebooting
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"at %s, port %d, addr %d "
literal|"(disconnected)\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|udev
operator|->
name|parent_dev
argument_list|)
argument_list|,
name|udev
operator|->
name|port_no
argument_list|,
name|udev
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|peer_suspended
condition|)
block|{
name|err
operator|=
name|DEVICE_RESUME
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Resume failed\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|device_detach
argument_list|(
name|dev
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
name|device_delete_child
argument_list|(
name|udev
operator|->
name|parent_dev
argument_list|,
name|dev
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
name|pnpinfo
operator|=
operator|*
name|ppnpinfo
expr_stmt|;
if|if
condition|(
name|pnpinfo
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ppnpinfo
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|pnpinfo
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
return|return;
name|error
label|:
comment|/* Detach is not allowed to fail in the USB world */
name|panic
argument_list|(
literal|"usb_detach_device_sub: A USB driver would not detach\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_detach_device  *  * The following function will detach the matching interfaces.  * This function is NULL safe.  *  * Flag values, see "USB_UNCFG_FLAG_XXX".  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_detach_device
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|flag
parameter_list|)
block|{
name|struct
name|usb_interface
modifier|*
name|iface
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
block|{
comment|/* nothing to do */
return|return;
block|}
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"udev=%p\n"
argument_list|,
name|udev
argument_list|)
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|udev
operator|->
name|enum_sx
argument_list|,
name|SA_LOCKED
argument_list|)
expr_stmt|;
comment|/* 	 * First detach the child to give the child's detach routine a 	 * chance to detach the sub-devices in the correct order. 	 * Then delete the child using "device_delete_child()" which 	 * will detach all sub-devices from the bottom and upwards! 	 */
if|if
condition|(
name|iface_index
operator|!=
name|USB_IFACE_INDEX_ANY
condition|)
block|{
name|i
operator|=
name|iface_index
expr_stmt|;
name|iface_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|iface_index
operator|=
name|USB_IFACE_MAX
expr_stmt|;
block|}
comment|/* do the detach */
for|for
control|(
init|;
name|i
operator|!=
name|iface_index
condition|;
name|i
operator|++
control|)
block|{
name|iface
operator|=
name|usbd_get_iface
argument_list|(
name|udev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
block|{
comment|/* looks like the end of the USB interfaces */
break|break;
block|}
name|usb_detach_device_sub
argument_list|(
name|udev
argument_list|,
operator|&
name|iface
operator|->
name|subdev
argument_list|,
operator|&
name|iface
operator|->
name|pnpinfo
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_probe_and_attach_sub  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|usb_probe_and_attach_sub
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_attach_arg
modifier|*
name|uaa
parameter_list|)
block|{
name|struct
name|usb_interface
modifier|*
name|iface
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|;
name|iface
operator|=
name|uaa
operator|->
name|iface
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|parent_iface_index
operator|!=
name|USB_IFACE_INDEX_ANY
condition|)
block|{
comment|/* leave interface alone */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dev
operator|=
name|iface
operator|->
name|subdev
expr_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
comment|/* clean up after module unload */
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* already a device there */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* clear "iface->subdev" as early as possible */
name|iface
operator|->
name|subdev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|device_delete_child
argument_list|(
name|udev
operator|->
name|parent_dev
argument_list|,
name|dev
argument_list|)
condition|)
block|{
comment|/* 			 * Panic here, else one can get a double call 			 * to device_detach().  USB devices should 			 * never fail on detach! 			 */
name|panic
argument_list|(
literal|"device_delete_child() failed\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|uaa
operator|->
name|temp_dev
operator|==
name|NULL
condition|)
block|{
comment|/* create a new child */
name|uaa
operator|->
name|temp_dev
operator|=
name|device_add_child
argument_list|(
name|udev
operator|->
name|parent_dev
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|uaa
operator|->
name|temp_dev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|udev
operator|->
name|parent_dev
argument_list|,
literal|"Device creation failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* failure */
block|}
name|device_set_ivars
argument_list|(
name|uaa
operator|->
name|temp_dev
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|device_quiet
argument_list|(
name|uaa
operator|->
name|temp_dev
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set "subdev" before probe and attach so that "devd" gets 	 * the information it needs. 	 */
name|iface
operator|->
name|subdev
operator|=
name|uaa
operator|->
name|temp_dev
expr_stmt|;
if|if
condition|(
name|device_probe_and_attach
argument_list|(
name|iface
operator|->
name|subdev
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The USB attach arguments are only available during probe 		 * and attach ! 		 */
name|uaa
operator|->
name|temp_dev
operator|=
name|NULL
expr_stmt|;
name|device_set_ivars
argument_list|(
name|iface
operator|->
name|subdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|peer_suspended
condition|)
block|{
name|err
operator|=
name|DEVICE_SUSPEND
argument_list|(
name|iface
operator|->
name|subdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|device_printf
argument_list|(
name|iface
operator|->
name|subdev
argument_list|,
literal|"Suspend failed\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
else|else
block|{
comment|/* No USB driver found */
name|iface
operator|->
name|subdev
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* failure */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_set_parent_iface  *  * Using this function will lock the alternate interface setting on an  * interface. It is typically used for multi interface drivers. In USB  * device side mode it is assumed that the alternate interfaces all  * have the same endpoint descriptors. The default parent index value  * is "USB_IFACE_INDEX_ANY". Then the alternate setting value is not  * locked.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_set_parent_iface
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|parent_index
parameter_list|)
block|{
name|struct
name|usb_interface
modifier|*
name|iface
decl_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
block|{
comment|/* nothing to do */
return|return;
block|}
name|iface
operator|=
name|usbd_get_iface
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|!=
name|NULL
condition|)
name|iface
operator|->
name|parent_iface_index
operator|=
name|parent_index
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_init_attach_arg
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_attach_arg
modifier|*
name|uaa
parameter_list|)
block|{
name|memset
argument_list|(
name|uaa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|uaa
argument_list|)
argument_list|)
expr_stmt|;
name|uaa
operator|->
name|device
operator|=
name|udev
expr_stmt|;
name|uaa
operator|->
name|usb_mode
operator|=
name|udev
operator|->
name|flags
operator|.
name|usb_mode
expr_stmt|;
name|uaa
operator|->
name|port
operator|=
name|udev
operator|->
name|port_no
expr_stmt|;
name|uaa
operator|->
name|dev_state
operator|=
name|UAA_DEV_READY
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|idVendor
operator|=
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|idVendor
argument_list|)
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|idProduct
operator|=
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|idProduct
argument_list|)
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|bcdDevice
operator|=
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|bcdDevice
argument_list|)
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|bDeviceClass
operator|=
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceClass
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|bDeviceSubClass
operator|=
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceSubClass
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|bDeviceProtocol
operator|=
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceProtocol
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|bConfigIndex
operator|=
name|udev
operator|->
name|curr_config_index
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|bConfigNum
operator|=
name|udev
operator|->
name|curr_config_no
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_probe_and_attach  *  * This function is called from "uhub_explore_sub()",  * "usb_handle_set_config()" and "usb_handle_request()".  *  * Returns:  *    0: Success  * Else: A control transfer failed  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb_error_t
name|usb_probe_and_attach
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|)
block|{
name|struct
name|usb_attach_arg
name|uaa
decl_stmt|;
name|struct
name|usb_interface
modifier|*
name|iface
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint8_t
name|j
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"udev == NULL\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
comment|/* Prevent re-enumeration */
name|do_unlock
operator|=
name|usbd_enum_lock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|curr_config_index
operator|==
name|USB_UNCONFIG_INDEX
condition|)
block|{
comment|/* do nothing - no configuration has been set */
goto|goto
name|done
goto|;
block|}
comment|/* setup USB attach arguments */
name|usb_init_attach_arg
argument_list|(
name|udev
argument_list|,
operator|&
name|uaa
argument_list|)
expr_stmt|;
comment|/* 	 * If the whole USB device is targeted, invoke the USB event 	 * handler(s): 	 */
if|if
condition|(
name|iface_index
operator|==
name|USB_IFACE_INDEX_ANY
condition|)
block|{
if|if
condition|(
name|usb_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_MSC_DYMO_EJECT
argument_list|)
operator|!=
literal|0
operator|&&
name|usb_dymo_eject
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* success, mark the udev as disappearing */
name|uaa
operator|.
name|dev_state
operator|=
name|UAA_DEV_EJECTING
expr_stmt|;
block|}
name|EVENTHANDLER_INVOKE
argument_list|(
name|usb_dev_configured
argument_list|,
name|udev
argument_list|,
operator|&
name|uaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|uaa
operator|.
name|dev_state
operator|!=
name|UAA_DEV_READY
condition|)
block|{
comment|/* leave device unconfigured */
name|usb_unconfigure
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* Check if only one interface should be probed: */
if|if
condition|(
name|iface_index
operator|!=
name|USB_IFACE_INDEX_ANY
condition|)
block|{
name|i
operator|=
name|iface_index
expr_stmt|;
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|USB_IFACE_MAX
expr_stmt|;
block|}
comment|/* Do the probe and attach */
for|for
control|(
init|;
name|i
operator|!=
name|j
condition|;
name|i
operator|++
control|)
block|{
name|iface
operator|=
name|usbd_get_iface
argument_list|(
name|udev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Looks like the end of the USB 			 * interfaces ! 			 */
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"end of interfaces "
literal|"at %u\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|iface
operator|->
name|idesc
operator|==
name|NULL
condition|)
block|{
comment|/* no interface descriptor */
continue|continue;
block|}
name|uaa
operator|.
name|iface
operator|=
name|iface
expr_stmt|;
name|uaa
operator|.
name|info
operator|.
name|bInterfaceClass
operator|=
name|iface
operator|->
name|idesc
operator|->
name|bInterfaceClass
expr_stmt|;
name|uaa
operator|.
name|info
operator|.
name|bInterfaceSubClass
operator|=
name|iface
operator|->
name|idesc
operator|->
name|bInterfaceSubClass
expr_stmt|;
name|uaa
operator|.
name|info
operator|.
name|bInterfaceProtocol
operator|=
name|iface
operator|->
name|idesc
operator|->
name|bInterfaceProtocol
expr_stmt|;
name|uaa
operator|.
name|info
operator|.
name|bIfaceIndex
operator|=
name|i
expr_stmt|;
name|uaa
operator|.
name|info
operator|.
name|bIfaceNum
operator|=
name|iface
operator|->
name|idesc
operator|->
name|bInterfaceNumber
expr_stmt|;
name|uaa
operator|.
name|driver_info
operator|=
literal|0
expr_stmt|;
comment|/* reset driver_info */
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"iclass=%u/%u/%u iindex=%u/%u\n"
argument_list|,
name|uaa
operator|.
name|info
operator|.
name|bInterfaceClass
argument_list|,
name|uaa
operator|.
name|info
operator|.
name|bInterfaceSubClass
argument_list|,
name|uaa
operator|.
name|info
operator|.
name|bInterfaceProtocol
argument_list|,
name|uaa
operator|.
name|info
operator|.
name|bIfaceIndex
argument_list|,
name|uaa
operator|.
name|info
operator|.
name|bIfaceNum
argument_list|)
expr_stmt|;
name|usb_probe_and_attach_sub
argument_list|(
name|udev
argument_list|,
operator|&
name|uaa
argument_list|)
expr_stmt|;
comment|/* 		 * Remove the leftover child, if any, to enforce that 		 * a new nomatch devd event is generated for the next 		 * interface if no driver is found: 		 */
if|if
condition|(
name|uaa
operator|.
name|temp_dev
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|device_delete_child
argument_list|(
name|udev
operator|->
name|parent_dev
argument_list|,
name|uaa
operator|.
name|temp_dev
argument_list|)
condition|)
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"device delete child failed\n"
argument_list|)
expr_stmt|;
name|uaa
operator|.
name|temp_dev
operator|=
name|NULL
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|do_unlock
condition|)
name|usbd_enum_unlock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_suspend_resume_sub  *  * This function is called when the suspend or resume methods should  * be executed on an USB device.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_suspend_resume_sub
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|uint8_t
name|do_suspend
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|do_suspend
condition|)
block|{
name|err
operator|=
name|DEVICE_SUSPEND
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|DEVICE_RESUME
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s failed\n"
argument_list|,
name|do_suspend
condition|?
literal|"Suspend"
else|:
literal|"Resume"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_suspend_resume  *  * The following function will suspend or resume the USB device.  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb_error_t
name|usb_suspend_resume
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|do_suspend
parameter_list|)
block|{
name|struct
name|usb_interface
modifier|*
name|iface
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
block|{
comment|/* nothing to do */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"udev=%p do_suspend=%d\n"
argument_list|,
name|udev
argument_list|,
name|do_suspend
argument_list|)
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|udev
operator|->
name|sr_sx
argument_list|,
name|SA_LOCKED
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* filter the suspend events */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|peer_suspended
operator|==
name|do_suspend
condition|)
block|{
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* nothing to do */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|udev
operator|->
name|flags
operator|.
name|peer_suspended
operator|=
name|do_suspend
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* do the suspend or resume */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|USB_IFACE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|iface
operator|=
name|usbd_get_iface
argument_list|(
name|udev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
block|{
comment|/* looks like the end of the USB interfaces */
break|break;
block|}
name|usb_suspend_resume_sub
argument_list|(
name|udev
argument_list|,
name|iface
operator|->
name|subdev
argument_list|,
name|do_suspend
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *      usbd_clear_stall_proc  *  * This function performs generic USB clear stall operations.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usbd_clear_stall_proc
parameter_list|(
name|struct
name|usb_proc_msg
modifier|*
name|_pm
parameter_list|)
block|{
name|struct
name|usb_udev_msg
modifier|*
name|pm
init|=
operator|(
name|void
operator|*
operator|)
name|_pm
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|udev
init|=
name|pm
operator|->
name|udev
decl_stmt|;
comment|/* Change lock */
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|udev
operator|->
name|device_mtx
argument_list|)
expr_stmt|;
comment|/* Start clear stall callback */
name|usbd_transfer_start
argument_list|(
name|udev
operator|->
name|ctrl_xfer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Change lock */
name|mtx_unlock
argument_list|(
operator|&
name|udev
operator|->
name|device_mtx
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_alloc_device  *  * This function allocates a new USB device. This function is called  * when a new device has been put in the powered state, but not yet in  * the addressed state. Get initial descriptor, set the address, get  * full descriptor and get strings.  *  * Return values:  *    0: Failure  * Else: Success  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb_device
modifier|*
name|usb_alloc_device
parameter_list|(
name|device_t
name|parent_dev
parameter_list|,
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
name|struct
name|usb_device
modifier|*
name|parent_hub
parameter_list|,
name|uint8_t
name|depth
parameter_list|,
name|uint8_t
name|port_index
parameter_list|,
name|uint8_t
name|port_no
parameter_list|,
name|enum
name|usb_dev_speed
name|speed
parameter_list|,
name|enum
name|usb_hc_mode
name|mode
parameter_list|)
block|{
name|struct
name|usb_attach_arg
name|uaa
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|udev
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|adev
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|hub
decl_stmt|;
name|uint8_t
modifier|*
name|scratch_ptr
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|uint8_t
name|device_index
decl_stmt|;
name|uint8_t
name|config_index
decl_stmt|;
name|uint8_t
name|config_quirk
decl_stmt|;
name|uint8_t
name|set_config_failed
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"parent_dev=%p, bus=%p, parent_hub=%p, depth=%u, "
literal|"port_index=%u, port_no=%u, speed=%u, usb_mode=%u\n"
argument_list|,
name|parent_dev
argument_list|,
name|bus
argument_list|,
name|parent_hub
argument_list|,
name|depth
argument_list|,
name|port_index
argument_list|,
name|port_no
argument_list|,
name|speed
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* 	 * Find an unused device index. In USB Host mode this is the 	 * same as the device address. 	 * 	 * Device index zero is not used and device index 1 should 	 * always be the root hub. 	 */
for|for
control|(
name|device_index
operator|=
name|USB_ROOT_HUB_ADDR
init|;
operator|(
name|device_index
operator|!=
name|bus
operator|->
name|devices_max
operator|)
operator|&&
operator|(
name|bus
operator|->
name|devices
index|[
name|device_index
index|]
operator|!=
name|NULL
operator|)
condition|;
name|device_index
operator|++
control|)
comment|/* nop */
empty_stmt|;
if|if
condition|(
name|device_index
operator|==
name|bus
operator|->
name|devices_max
condition|)
block|{
name|device_printf
argument_list|(
name|bus
operator|->
name|bdev
argument_list|,
literal|"No free USB device index for new device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|depth
operator|>
literal|0x10
condition|)
block|{
name|device_printf
argument_list|(
name|bus
operator|->
name|bdev
argument_list|,
literal|"Invalid device depth\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|udev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|udev
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* initialise our SX-lock */
name|sx_init_flags
argument_list|(
operator|&
name|udev
operator|->
name|enum_sx
argument_list|,
literal|"USB config SX lock"
argument_list|,
name|SX_DUPOK
argument_list|)
expr_stmt|;
name|sx_init_flags
argument_list|(
operator|&
name|udev
operator|->
name|sr_sx
argument_list|,
literal|"USB suspend and resume SX lock"
argument_list|,
name|SX_NOWITNESS
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|udev
operator|->
name|ctrlreq_cv
argument_list|,
literal|"WCTRL"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|udev
operator|->
name|ref_cv
argument_list|,
literal|"UGONE"
argument_list|)
expr_stmt|;
comment|/* initialise our mutex */
name|mtx_init
argument_list|(
operator|&
name|udev
operator|->
name|device_mtx
argument_list|,
literal|"USB device mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* initialise generic clear stall */
name|udev
operator|->
name|cs_msg
index|[
literal|0
index|]
operator|.
name|hdr
operator|.
name|pm_callback
operator|=
operator|&
name|usbd_clear_stall_proc
expr_stmt|;
name|udev
operator|->
name|cs_msg
index|[
literal|0
index|]
operator|.
name|udev
operator|=
name|udev
expr_stmt|;
name|udev
operator|->
name|cs_msg
index|[
literal|1
index|]
operator|.
name|hdr
operator|.
name|pm_callback
operator|=
operator|&
name|usbd_clear_stall_proc
expr_stmt|;
name|udev
operator|->
name|cs_msg
index|[
literal|1
index|]
operator|.
name|udev
operator|=
name|udev
expr_stmt|;
comment|/* initialise some USB device fields */
name|udev
operator|->
name|parent_hub
operator|=
name|parent_hub
expr_stmt|;
name|udev
operator|->
name|parent_dev
operator|=
name|parent_dev
expr_stmt|;
name|udev
operator|->
name|port_index
operator|=
name|port_index
expr_stmt|;
name|udev
operator|->
name|port_no
operator|=
name|port_no
expr_stmt|;
name|udev
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|udev
operator|->
name|bus
operator|=
name|bus
expr_stmt|;
name|udev
operator|->
name|address
operator|=
name|USB_START_ADDR
expr_stmt|;
comment|/* default value */
name|udev
operator|->
name|plugtime
operator|=
operator|(
name|usb_ticks_t
operator|)
name|ticks
expr_stmt|;
comment|/* 	 * We need to force the power mode to "on" because there are plenty 	 * of USB devices out there that do not work very well with 	 * automatic suspend and resume! 	 */
name|udev
operator|->
name|power_mode
operator|=
name|usbd_filter_power_mode
argument_list|(
name|udev
argument_list|,
name|USB_POWER_MODE_ON
argument_list|)
expr_stmt|;
name|udev
operator|->
name|pwr_save
operator|.
name|last_xfer_time
operator|=
name|ticks
expr_stmt|;
comment|/* we are not ready yet */
name|udev
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
comment|/* set up default endpoint descriptor */
name|udev
operator|->
name|ctrl_ep_desc
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|ctrl_ep_desc
argument_list|)
expr_stmt|;
name|udev
operator|->
name|ctrl_ep_desc
operator|.
name|bDescriptorType
operator|=
name|UDESC_ENDPOINT
expr_stmt|;
name|udev
operator|->
name|ctrl_ep_desc
operator|.
name|bEndpointAddress
operator|=
name|USB_CONTROL_ENDPOINT
expr_stmt|;
name|udev
operator|->
name|ctrl_ep_desc
operator|.
name|bmAttributes
operator|=
name|UE_CONTROL
expr_stmt|;
name|udev
operator|->
name|ctrl_ep_desc
operator|.
name|wMaxPacketSize
index|[
literal|0
index|]
operator|=
name|USB_MAX_IPACKET
expr_stmt|;
name|udev
operator|->
name|ctrl_ep_desc
operator|.
name|wMaxPacketSize
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|udev
operator|->
name|ctrl_ep_desc
operator|.
name|bInterval
operator|=
literal|0
expr_stmt|;
comment|/* set up default endpoint companion descriptor */
name|udev
operator|->
name|ctrl_ep_comp_desc
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|ctrl_ep_comp_desc
argument_list|)
expr_stmt|;
name|udev
operator|->
name|ctrl_ep_comp_desc
operator|.
name|bDescriptorType
operator|=
name|UDESC_ENDPOINT_SS_COMP
expr_stmt|;
name|udev
operator|->
name|ddesc
operator|.
name|bMaxPacketSize
operator|=
name|USB_MAX_IPACKET
expr_stmt|;
name|udev
operator|->
name|speed
operator|=
name|speed
expr_stmt|;
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|=
name|mode
expr_stmt|;
comment|/* search for our High Speed USB HUB, if any */
name|adev
operator|=
name|udev
expr_stmt|;
name|hub
operator|=
name|udev
operator|->
name|parent_hub
expr_stmt|;
while|while
condition|(
name|hub
condition|)
block|{
if|if
condition|(
name|hub
operator|->
name|speed
operator|==
name|USB_SPEED_HIGH
condition|)
block|{
name|udev
operator|->
name|hs_hub_addr
operator|=
name|hub
operator|->
name|address
expr_stmt|;
name|udev
operator|->
name|parent_hs_hub
operator|=
name|hub
expr_stmt|;
name|udev
operator|->
name|hs_port_no
operator|=
name|adev
operator|->
name|port_no
expr_stmt|;
break|break;
block|}
name|adev
operator|=
name|hub
expr_stmt|;
name|hub
operator|=
name|hub
operator|->
name|parent_hub
expr_stmt|;
block|}
comment|/* init the default endpoint */
name|usb_init_endpoint
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|,
operator|&
name|udev
operator|->
name|ctrl_ep_desc
argument_list|,
operator|&
name|udev
operator|->
name|ctrl_ep_comp_desc
argument_list|,
operator|&
name|udev
operator|->
name|ctrl_ep
argument_list|)
expr_stmt|;
comment|/* set device index */
name|udev
operator|->
name|device_index
operator|=
name|device_index
expr_stmt|;
if|#
directive|if
name|USB_HAVE_UGEN
comment|/* Create ugen name */
name|snprintf
argument_list|(
name|udev
operator|->
name|ugen_name
argument_list|,
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|ugen_name
argument_list|)
argument_list|,
name|USB_GENERIC_NAME
literal|"%u.%u"
argument_list|,
name|device_get_unit
argument_list|(
name|bus
operator|->
name|bdev
argument_list|)
argument_list|,
name|device_index
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|udev
operator|->
name|pd_list
argument_list|)
expr_stmt|;
comment|/* Create the control endpoint device */
name|udev
operator|->
name|ctrl_dev
operator|=
name|usb_make_dev
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
comment|/* Create a link from /dev/ugenX.X to the default endpoint */
if|if
condition|(
name|udev
operator|->
name|ctrl_dev
operator|!=
name|NULL
condition|)
name|make_dev_alias
argument_list|(
name|udev
operator|->
name|ctrl_dev
operator|->
name|cdev
argument_list|,
literal|"%s"
argument_list|,
name|udev
operator|->
name|ugen_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialise device */
if|if
condition|(
name|bus
operator|->
name|methods
operator|->
name|device_init
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
call|(
name|bus
operator|->
name|methods
operator|->
name|device_init
call|)
argument_list|(
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"device init %d failed "
literal|"(%s, ignored)\n"
argument_list|,
name|device_index
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* set powered device state after device init is complete */
name|usb_set_device_state
argument_list|(
name|udev
argument_list|,
name|USB_STATE_POWERED
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_HOST
condition|)
block|{
name|err
operator|=
name|usbd_req_set_address
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|device_index
argument_list|)
expr_stmt|;
comment|/* 		 * This is the new USB device address from now on, if 		 * the set address request didn't set it already. 		 */
if|if
condition|(
name|udev
operator|->
name|address
operator|==
name|USB_START_ADDR
condition|)
name|udev
operator|->
name|address
operator|=
name|device_index
expr_stmt|;
comment|/* 		 * We ignore any set-address errors, hence there are 		 * buggy USB devices out there that actually receive 		 * the SETUP PID, but manage to set the address before 		 * the STATUS stage is ACK'ed. If the device responds 		 * to the subsequent get-descriptor at the new 		 * address, then we know that the set-address command 		 * was successful. 		 */
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"set address %d failed "
literal|"(%s, ignored)\n"
argument_list|,
name|udev
operator|->
name|address
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We are not self powered */
name|udev
operator|->
name|flags
operator|.
name|self_powered
operator|=
literal|0
expr_stmt|;
comment|/* Set unconfigured state */
name|udev
operator|->
name|curr_config_no
operator|=
name|USB_UNCONFIG_NO
expr_stmt|;
name|udev
operator|->
name|curr_config_index
operator|=
name|USB_UNCONFIG_INDEX
expr_stmt|;
comment|/* Setup USB descriptors */
name|err
operator|=
call|(
name|usb_temp_setup_by_index_p
call|)
argument_list|(
name|udev
argument_list|,
name|usb_template
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"setting up USB template failed maybe the USB "
literal|"template module has not been loaded\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|usb_set_device_state
argument_list|(
name|udev
argument_list|,
name|USB_STATE_ADDRESSED
argument_list|)
expr_stmt|;
comment|/* setup the device descriptor and the initial "wMaxPacketSize" */
name|err
operator|=
name|usbd_setup_device_desc
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
comment|/* try to enumerate two more times */
name|err
operator|=
name|usbd_req_re_enumerate
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|usbd_req_re_enumerate
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
block|}
comment|/* 	 * Setup temporary USB attach args so that we can figure out some 	 * basic quirks for this device. 	 */
name|usb_init_attach_arg
argument_list|(
name|udev
argument_list|,
operator|&
name|uaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_BUS_POWERED
argument_list|)
condition|)
block|{
name|udev
operator|->
name|flags
operator|.
name|uq_bus_powered
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|usb_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_NO_STRINGS
argument_list|)
condition|)
block|{
name|udev
operator|->
name|flags
operator|.
name|no_strings
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Workaround for buggy USB devices. 	 * 	 * It appears that some string-less USB chips will crash and 	 * disappear if any attempts are made to read any string 	 * descriptors. 	 * 	 * Try to detect such chips by checking the strings in the USB 	 * device descriptor. If no strings are present there we 	 * simply disable all USB strings. 	 */
comment|/* Protect scratch area */
name|do_unlock
operator|=
name|usbd_enum_lock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|scratch_ptr
operator|=
name|udev
operator|->
name|scratch
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|no_strings
condition|)
block|{
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udev
operator|->
name|ddesc
operator|.
name|iManufacturer
operator|||
name|udev
operator|->
name|ddesc
operator|.
name|iProduct
operator|||
name|udev
operator|->
name|ddesc
operator|.
name|iSerialNumber
condition|)
block|{
comment|/* read out the language ID string */
name|err
operator|=
name|usbd_req_get_string_desc
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|scratch_ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|USB_LANGUAGE_TABLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|||
operator|(
name|scratch_ptr
index|[
literal|0
index|]
operator|<
literal|4
operator|)
condition|)
block|{
name|udev
operator|->
name|flags
operator|.
name|no_strings
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|uint16_t
name|langid
decl_stmt|;
name|uint16_t
name|pref
decl_stmt|;
name|uint16_t
name|mask
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
comment|/* load preferred value and mask */
name|pref
operator|=
name|usb_lang_id
expr_stmt|;
name|mask
operator|=
name|usb_lang_mask
expr_stmt|;
comment|/* align length correctly */
name|scratch_ptr
index|[
literal|0
index|]
operator|&=
operator|~
literal|1U
expr_stmt|;
comment|/* fix compiler warning */
name|langid
operator|=
literal|0
expr_stmt|;
comment|/* search for preferred language */
for|for
control|(
name|x
operator|=
literal|2
init|;
operator|(
name|x
operator|<
name|scratch_ptr
index|[
literal|0
index|]
operator|)
condition|;
name|x
operator|+=
literal|2
control|)
block|{
name|langid
operator|=
name|UGETW
argument_list|(
name|scratch_ptr
operator|+
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|langid
operator|&
name|mask
operator|)
operator|==
name|pref
condition|)
break|break;
block|}
if|if
condition|(
name|x
operator|>=
name|scratch_ptr
index|[
literal|0
index|]
condition|)
block|{
comment|/* pick the first language as the default */
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
literal|"Using first language\n"
argument_list|)
expr_stmt|;
name|langid
operator|=
name|UGETW
argument_list|(
name|scratch_ptr
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
literal|"Language selected: 0x%04x\n"
argument_list|,
name|langid
argument_list|)
expr_stmt|;
name|udev
operator|->
name|langid
operator|=
name|langid
expr_stmt|;
block|}
if|if
condition|(
name|do_unlock
condition|)
name|usbd_enum_unlock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
comment|/* assume 100mA bus powered for now. Changed when configured. */
name|udev
operator|->
name|power
operator|=
name|USB_MIN_POWER
expr_stmt|;
comment|/* fetch the vendor and product strings from the device */
name|usbd_set_device_strings
argument_list|(
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
comment|/* USB device mode setup is complete */
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|config_done
goto|;
block|}
comment|/* 	 * Most USB devices should attach to config index 0 by 	 * default 	 */
if|if
condition|(
name|usb_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_CFG_INDEX_0
argument_list|)
condition|)
block|{
name|config_index
operator|=
literal|0
expr_stmt|;
name|config_quirk
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usb_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_CFG_INDEX_1
argument_list|)
condition|)
block|{
name|config_index
operator|=
literal|1
expr_stmt|;
name|config_quirk
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usb_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_CFG_INDEX_2
argument_list|)
condition|)
block|{
name|config_index
operator|=
literal|2
expr_stmt|;
name|config_quirk
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usb_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_CFG_INDEX_3
argument_list|)
condition|)
block|{
name|config_index
operator|=
literal|3
expr_stmt|;
name|config_quirk
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usb_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_CFG_INDEX_4
argument_list|)
condition|)
block|{
name|config_index
operator|=
literal|4
expr_stmt|;
name|config_quirk
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|config_index
operator|=
literal|0
expr_stmt|;
name|config_quirk
operator|=
literal|0
expr_stmt|;
block|}
name|set_config_failed
operator|=
literal|0
expr_stmt|;
name|repeat_set_config
label|:
name|DPRINTF
argument_list|(
literal|"setting config %u\n"
argument_list|,
name|config_index
argument_list|)
expr_stmt|;
comment|/* get the USB device configured */
name|err
operator|=
name|usbd_set_config_index
argument_list|(
name|udev
argument_list|,
name|config_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|udev
operator|->
name|ddesc
operator|.
name|bNumConfigurations
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|set_config_failed
condition|)
block|{
name|set_config_failed
operator|=
literal|1
expr_stmt|;
comment|/* XXX try to re-enumerate the device */
name|err
operator|=
name|usbd_req_re_enumerate
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
goto|goto
name|repeat_set_config
goto|;
block|}
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Failure selecting configuration index %u:"
literal|"%s, port %u, addr %u (ignored)\n"
argument_list|,
name|config_index
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|,
name|udev
operator|->
name|port_no
argument_list|,
name|udev
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Some USB devices do not have any configurations. Ignore any 		 * set config failures! 		 */
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|config_done
goto|;
block|}
if|if
condition|(
operator|!
name|config_quirk
operator|&&
name|config_index
operator|+
literal|1
operator|<
name|udev
operator|->
name|ddesc
operator|.
name|bNumConfigurations
condition|)
block|{
if|if
condition|(
operator|(
name|udev
operator|->
name|cdesc
operator|->
name|bNumInterface
operator|<
literal|2
operator|)
operator|&&
name|usbd_get_no_descriptors
argument_list|(
name|udev
operator|->
name|cdesc
argument_list|,
name|UDESC_ENDPOINT
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Found no endpoints, trying next config\n"
argument_list|)
expr_stmt|;
name|config_index
operator|++
expr_stmt|;
goto|goto
name|repeat_set_config
goto|;
block|}
if|#
directive|if
name|USB_HAVE_MSCTEST
if|if
condition|(
name|config_index
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Try to figure out if we have an 			 * auto-install disk there: 			 */
if|if
condition|(
name|usb_iface_is_cdrom
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Found possible auto-install "
literal|"disk (trying next config)\n"
argument_list|)
expr_stmt|;
name|config_index
operator|++
expr_stmt|;
goto|goto
name|repeat_set_config
goto|;
block|}
block|}
endif|#
directive|endif
block|}
if|#
directive|if
name|USB_HAVE_MSCTEST
if|if
condition|(
name|set_config_failed
operator|==
literal|0
operator|&&
name|config_index
operator|==
literal|0
operator|&&
name|usb_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_MSC_NO_SYNC_CACHE
argument_list|)
operator|==
literal|0
operator|&&
name|usb_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_MSC_NO_GETMAXLUN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Try to figure out if there are any MSC quirks we 		 * should apply automatically: 		 */
name|err
operator|=
name|usb_msc_auto_quirk
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|set_config_failed
operator|=
literal|1
expr_stmt|;
goto|goto
name|repeat_set_config
goto|;
block|}
block|}
endif|#
directive|endif
name|config_done
label|:
name|DPRINTF
argument_list|(
literal|"new dev (addr %d), udev=%p, parent_hub=%p\n"
argument_list|,
name|udev
operator|->
name|address
argument_list|,
name|udev
argument_list|,
name|udev
operator|->
name|parent_hub
argument_list|)
expr_stmt|;
comment|/* register our device - we are ready */
name|usb_bus_port_set_device
argument_list|(
name|bus
argument_list|,
name|parent_hub
condition|?
name|parent_hub
operator|->
name|hub
operator|->
name|ports
operator|+
name|port_index
else|:
name|NULL
argument_list|,
name|udev
argument_list|,
name|device_index
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_HAVE_UGEN
comment|/* Symlink the ugen device name */
name|udev
operator|->
name|ugen_symlink
operator|=
name|usb_alloc_symlink
argument_list|(
name|udev
operator|->
name|ugen_name
argument_list|)
expr_stmt|;
comment|/* Announce device */
name|printf
argument_list|(
literal|"%s:<%s> at %s\n"
argument_list|,
name|udev
operator|->
name|ugen_name
argument_list|,
name|usb_get_manufacturer
argument_list|(
name|udev
argument_list|)
argument_list|,
name|device_get_nameunit
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|USB_HAVE_DEVCTL
name|usb_notify_addq
argument_list|(
literal|"ATTACH"
argument_list|,
name|udev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|done
label|:
if|if
condition|(
name|err
condition|)
block|{
comment|/* 		 * Free USB device and all subdevices, if any. 		 */
name|usb_free_device
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|udev
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|udev
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|USB_HAVE_UGEN
end_if

begin_function
name|struct
name|usb_fs_privdata
modifier|*
name|usb_make_dev
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
specifier|const
name|char
modifier|*
name|devname
parameter_list|,
name|int
name|ep
parameter_list|,
name|int
name|fi
parameter_list|,
name|int
name|rwmode
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|usb_fs_privdata
modifier|*
name|pd
decl_stmt|;
name|char
name|buffer
index|[
literal|32
index|]
decl_stmt|;
comment|/* Store information to locate ourselves again later */
name|pd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|usb_fs_privdata
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pd
operator|->
name|bus_index
operator|=
name|device_get_unit
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
expr_stmt|;
name|pd
operator|->
name|dev_index
operator|=
name|udev
operator|->
name|device_index
expr_stmt|;
name|pd
operator|->
name|ep_addr
operator|=
name|ep
expr_stmt|;
name|pd
operator|->
name|fifo_index
operator|=
name|fi
expr_stmt|;
name|pd
operator|->
name|mode
operator|=
name|rwmode
expr_stmt|;
comment|/* Now, create the device itself */
if|if
condition|(
name|devname
operator|==
name|NULL
condition|)
block|{
name|devname
operator|=
name|buffer
expr_stmt|;
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|USB_DEVICE_DIR
literal|"/%u.%u.%u"
argument_list|,
name|pd
operator|->
name|bus_index
argument_list|,
name|pd
operator|->
name|dev_index
argument_list|,
name|pd
operator|->
name|ep_addr
argument_list|)
expr_stmt|;
block|}
name|pd
operator|->
name|cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|usb_devsw
argument_list|,
literal|0
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|,
name|mode
argument_list|,
literal|"%s"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|cdev
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Failed to create device %s\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pd
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* XXX setting si_drv1 and creating the device is not atomic! */
name|pd
operator|->
name|cdev
operator|->
name|si_drv1
operator|=
name|pd
expr_stmt|;
return|return
operator|(
name|pd
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usb_destroy_dev_sync
parameter_list|(
name|struct
name|usb_fs_privdata
modifier|*
name|pd
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
literal|"Destroying device at ugen%d.%d\n"
argument_list|,
name|pd
operator|->
name|bus_index
argument_list|,
name|pd
operator|->
name|dev_index
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy character device synchronously. After this 	 * all system calls are returned. Can block. 	 */
name|destroy_dev
argument_list|(
name|pd
operator|->
name|cdev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pd
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usb_destroy_dev
parameter_list|(
name|struct
name|usb_fs_privdata
modifier|*
name|pd
parameter_list|)
block|{
name|struct
name|usb_bus
modifier|*
name|bus
decl_stmt|;
if|if
condition|(
name|pd
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
name|bus
operator|=
name|devclass_get_softc
argument_list|(
name|usb_devclass_ptr
argument_list|,
name|pd
operator|->
name|bus_index
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|==
name|NULL
condition|)
block|{
name|usb_destroy_dev_sync
argument_list|(
name|pd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* make sure we can re-use the device name */
name|delist_dev
argument_list|(
name|pd
operator|->
name|cdev
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bus
operator|->
name|pd_cleanup_list
argument_list|,
name|pd
argument_list|,
name|pd_next
argument_list|)
expr_stmt|;
comment|/* get cleanup going */
name|usb_proc_msignal
argument_list|(
name|USB_BUS_EXPLORE_PROC
argument_list|(
name|bus
argument_list|)
argument_list|,
operator|&
name|bus
operator|->
name|cleanup_msg
index|[
literal|0
index|]
argument_list|,
operator|&
name|bus
operator|->
name|cleanup_msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_cdev_create
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb_config_descriptor
modifier|*
name|cd
decl_stmt|;
name|struct
name|usb_endpoint_descriptor
modifier|*
name|ed
decl_stmt|;
name|struct
name|usb_descriptor
modifier|*
name|desc
decl_stmt|;
name|struct
name|usb_fs_privdata
modifier|*
name|pd
decl_stmt|;
name|int
name|inmode
decl_stmt|,
name|outmode
decl_stmt|,
name|inmask
decl_stmt|,
name|outmask
decl_stmt|,
name|mode
decl_stmt|;
name|uint8_t
name|ep
decl_stmt|;
name|KASSERT
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|udev
operator|->
name|pd_list
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"stale cdev entries"
operator|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"Creating device nodes\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbd_get_mode
argument_list|(
name|udev
argument_list|)
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
name|inmode
operator|=
name|FWRITE
expr_stmt|;
name|outmode
operator|=
name|FREAD
expr_stmt|;
block|}
else|else
block|{
comment|/* USB_MODE_HOST */
name|inmode
operator|=
name|FREAD
expr_stmt|;
name|outmode
operator|=
name|FWRITE
expr_stmt|;
block|}
name|inmask
operator|=
literal|0
expr_stmt|;
name|outmask
operator|=
literal|0
expr_stmt|;
name|desc
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Collect all used endpoint numbers instead of just 	 * generating 16 static endpoints. 	 */
name|cd
operator|=
name|usbd_get_config_descriptor
argument_list|(
name|udev
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|desc
operator|=
name|usb_desc_foreach
argument_list|(
name|cd
argument_list|,
name|desc
argument_list|)
operator|)
condition|)
block|{
comment|/* filter out all endpoint descriptors */
if|if
condition|(
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_ENDPOINT
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|ed
argument_list|)
operator|)
condition|)
block|{
name|ed
operator|=
operator|(
expr|struct
name|usb_endpoint_descriptor
operator|*
operator|)
name|desc
expr_stmt|;
comment|/* update masks */
name|ep
operator|=
name|ed
operator|->
name|bEndpointAddress
expr_stmt|;
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ep
argument_list|)
operator|==
name|UE_DIR_OUT
condition|)
name|outmask
operator||=
literal|1
operator|<<
name|UE_GET_ADDR
argument_list|(
name|ep
argument_list|)
expr_stmt|;
else|else
name|inmask
operator||=
literal|1
operator|<<
name|UE_GET_ADDR
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create all available endpoints except EP0 */
for|for
control|(
name|ep
operator|=
literal|1
init|;
name|ep
operator|<
literal|16
condition|;
name|ep
operator|++
control|)
block|{
name|mode
operator|=
operator|(
name|inmask
operator|&
operator|(
literal|1
operator|<<
name|ep
operator|)
operator|)
condition|?
name|inmode
else|:
literal|0
expr_stmt|;
name|mode
operator||=
operator|(
name|outmask
operator|&
operator|(
literal|1
operator|<<
name|ep
operator|)
operator|)
condition|?
name|outmode
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
continue|continue;
comment|/* no IN or OUT endpoint */
name|pd
operator|=
name|usb_make_dev
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|ep
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|!=
name|NULL
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|udev
operator|->
name|pd_list
argument_list|,
name|pd
argument_list|,
name|pd_next
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usb_cdev_free
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb_fs_privdata
modifier|*
name|pd
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"Freeing device nodes\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pd
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|udev
operator|->
name|pd_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|pd
operator|->
name|cdev
operator|->
name|si_drv1
operator|==
name|pd
argument_list|,
operator|(
literal|"privdata corrupt"
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pd
argument_list|,
name|pd_next
argument_list|)
expr_stmt|;
name|usb_destroy_dev
argument_list|(
name|pd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_free_device  *  * This function is NULL safe and will free an USB device and its  * children devices, if any.  *  * Flag values: Reserved, set to zero.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_free_device
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|flag
parameter_list|)
block|{
name|struct
name|usb_bus
modifier|*
name|bus
decl_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
return|return;
comment|/* already freed */
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"udev=%p port=%d\n"
argument_list|,
name|udev
argument_list|,
name|udev
operator|->
name|port_no
argument_list|)
expr_stmt|;
name|bus
operator|=
name|udev
operator|->
name|bus
expr_stmt|;
comment|/* set DETACHED state to prevent any further references */
name|usb_set_device_state
argument_list|(
name|udev
argument_list|,
name|USB_STATE_DETACHED
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_HAVE_DEVCTL
name|usb_notify_addq
argument_list|(
literal|"DETACH"
argument_list|,
name|udev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|USB_HAVE_UGEN
if|if
condition|(
operator|!
name|rebooting
condition|)
block|{
name|printf
argument_list|(
literal|"%s:<%s> at %s (disconnected)\n"
argument_list|,
name|udev
operator|->
name|ugen_name
argument_list|,
name|usb_get_manufacturer
argument_list|(
name|udev
argument_list|)
argument_list|,
name|device_get_nameunit
argument_list|(
name|bus
operator|->
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Destroy UGEN symlink, if any */
if|if
condition|(
name|udev
operator|->
name|ugen_symlink
condition|)
block|{
name|usb_free_symlink
argument_list|(
name|udev
operator|->
name|ugen_symlink
argument_list|)
expr_stmt|;
name|udev
operator|->
name|ugen_symlink
operator|=
name|NULL
expr_stmt|;
block|}
name|usb_destroy_dev
argument_list|(
name|udev
operator|->
name|ctrl_dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
comment|/* stop receiving any control transfers (Device Side Mode) */
name|usbd_transfer_unsetup
argument_list|(
name|udev
operator|->
name|ctrl_xfer
argument_list|,
name|USB_CTRL_XFER_MAX
argument_list|)
expr_stmt|;
block|}
comment|/* the following will get the device unconfigured in software */
name|usb_unconfigure
argument_list|(
name|udev
argument_list|,
name|USB_UNCFG_FLAG_FREE_EP0
argument_list|)
expr_stmt|;
comment|/* final device unregister after all character devices are closed */
name|usb_bus_port_set_device
argument_list|(
name|bus
argument_list|,
name|udev
operator|->
name|parent_hub
condition|?
name|udev
operator|->
name|parent_hub
operator|->
name|hub
operator|->
name|ports
operator|+
name|udev
operator|->
name|port_index
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
name|USB_ROOT_HUB_ADDR
argument_list|)
expr_stmt|;
comment|/* unsetup any leftover default USB transfers */
name|usbd_transfer_unsetup
argument_list|(
name|udev
operator|->
name|ctrl_xfer
argument_list|,
name|USB_CTRL_XFER_MAX
argument_list|)
expr_stmt|;
comment|/* template unsetup, if any */
call|(
name|usb_temp_unsetup_p
call|)
argument_list|(
name|udev
argument_list|)
expr_stmt|;
comment|/*  	 * Make sure that our clear-stall messages are not queued 	 * anywhere: 	 */
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|usb_proc_mwait
argument_list|(
name|USB_BUS_CS_PROC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
argument_list|,
operator|&
name|udev
operator|->
name|cs_msg
index|[
literal|0
index|]
argument_list|,
operator|&
name|udev
operator|->
name|cs_msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* wait for all references to go away */
name|usb_wait_pending_refs
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|udev
operator|->
name|enum_sx
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|udev
operator|->
name|sr_sx
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|udev
operator|->
name|ctrlreq_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|udev
operator|->
name|ref_cv
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|udev
operator|->
name|device_mtx
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_HAVE_UGEN
name|KASSERT
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|udev
operator|->
name|pd_list
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"leaked cdev entries"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Uninitialise device */
if|if
condition|(
name|bus
operator|->
name|methods
operator|->
name|device_uninit
operator|!=
name|NULL
condition|)
call|(
name|bus
operator|->
name|methods
operator|->
name|device_uninit
call|)
argument_list|(
name|udev
argument_list|)
expr_stmt|;
comment|/* free device */
name|free
argument_list|(
name|udev
operator|->
name|serial
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|udev
operator|->
name|manufacturer
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|udev
operator|->
name|product
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|udev
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_get_iface  *  * This function is the safe way to get the USB interface structure  * pointer by interface index.  *  * Return values:  *   NULL: Interface not present.  *   Else: Pointer to USB interface structure.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb_interface
modifier|*
name|usbd_get_iface
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|)
block|{
name|struct
name|usb_interface
modifier|*
name|iface
init|=
name|udev
operator|->
name|ifaces
operator|+
name|iface_index
decl_stmt|;
if|if
condition|(
name|iface_index
operator|>=
name|udev
operator|->
name|ifaces_max
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|iface
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_find_descriptor  *  * This function will lookup the first descriptor that matches the  * criteria given by the arguments "type" and "subtype". Descriptors  * will only be searched within the interface having the index  * "iface_index".  If the "id" argument points to an USB descriptor,  * it will be skipped before the search is started. This allows  * searching for multiple descriptors using the same criteria. Else  * the search is started after the interface descriptor.  *  * Return values:  *   NULL: End of descriptors  *   Else: A descriptor matching the criteria  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
modifier|*
name|usbd_find_descriptor
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|void
modifier|*
name|id
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint8_t
name|type_mask
parameter_list|,
name|uint8_t
name|subtype
parameter_list|,
name|uint8_t
name|subtype_mask
parameter_list|)
block|{
name|struct
name|usb_descriptor
modifier|*
name|desc
decl_stmt|;
name|struct
name|usb_config_descriptor
modifier|*
name|cd
decl_stmt|;
name|struct
name|usb_interface
modifier|*
name|iface
decl_stmt|;
name|cd
operator|=
name|usbd_get_config_descriptor
argument_list|(
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
name|iface
operator|=
name|usbd_get_iface
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|desc
operator|=
operator|(
name|void
operator|*
operator|)
name|id
expr_stmt|;
while|while
condition|(
operator|(
name|desc
operator|=
name|usb_desc_foreach
argument_list|(
name|cd
argument_list|,
name|desc
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_INTERFACE
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|desc
operator|->
name|bDescriptorType
operator|&
name|type_mask
operator|)
operator|==
name|type
operator|)
operator|&&
operator|(
operator|(
name|desc
operator|->
name|bDescriptorSubtype
operator|&
name|subtype_mask
operator|)
operator|==
name|subtype
operator|)
condition|)
block|{
return|return
operator|(
name|desc
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_devinfo  *  * This function will dump information from the device descriptor  * belonging to the USB device pointed to by "udev", to the string  * pointed to by "dst_ptr" having a maximum length of "dst_len" bytes  * including the terminating zero.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_devinfo
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|char
modifier|*
name|dst_ptr
parameter_list|,
name|uint16_t
name|dst_len
parameter_list|)
block|{
name|struct
name|usb_device_descriptor
modifier|*
name|udd
init|=
operator|&
name|udev
operator|->
name|ddesc
decl_stmt|;
name|uint16_t
name|bcdDevice
decl_stmt|;
name|uint16_t
name|bcdUSB
decl_stmt|;
name|bcdUSB
operator|=
name|UGETW
argument_list|(
name|udd
operator|->
name|bcdUSB
argument_list|)
expr_stmt|;
name|bcdDevice
operator|=
name|UGETW
argument_list|(
name|udd
operator|->
name|bcdDevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|udd
operator|->
name|bDeviceClass
operator|!=
literal|0xFF
condition|)
block|{
name|snprintf
argument_list|(
name|dst_ptr
argument_list|,
name|dst_len
argument_list|,
literal|"%s %s, class %d/%d, rev %x.%02x/"
literal|"%x.%02x, addr %d"
argument_list|,
name|usb_get_manufacturer
argument_list|(
name|udev
argument_list|)
argument_list|,
name|usb_get_product
argument_list|(
name|udev
argument_list|)
argument_list|,
name|udd
operator|->
name|bDeviceClass
argument_list|,
name|udd
operator|->
name|bDeviceSubClass
argument_list|,
operator|(
name|bcdUSB
operator|>>
literal|8
operator|)
argument_list|,
name|bcdUSB
operator|&
literal|0xFF
argument_list|,
operator|(
name|bcdDevice
operator|>>
literal|8
operator|)
argument_list|,
name|bcdDevice
operator|&
literal|0xFF
argument_list|,
name|udev
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|dst_ptr
argument_list|,
name|dst_len
argument_list|,
literal|"%s %s, rev %x.%02x/"
literal|"%x.%02x, addr %d"
argument_list|,
name|usb_get_manufacturer
argument_list|(
name|udev
argument_list|)
argument_list|,
name|usb_get_product
argument_list|(
name|udev
argument_list|)
argument_list|,
operator|(
name|bcdUSB
operator|>>
literal|8
operator|)
argument_list|,
name|bcdUSB
operator|&
literal|0xFF
argument_list|,
operator|(
name|bcdDevice
operator|>>
literal|8
operator|)
argument_list|,
name|bcdDevice
operator|&
literal|0xFF
argument_list|,
name|udev
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USB_VERBOSE
end_ifdef

begin_comment
comment|/*  * Descriptions of of known vendors and devices ("products").  */
end_comment

begin_struct
struct|struct
name|usb_knowndev
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|product
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|vendorname
decl_stmt|;
specifier|const
name|char
modifier|*
name|productname
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|USB_KNOWNDEV_NOPROD
value|0x01
end_define

begin_comment
comment|/* match on vendor only */
end_comment

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_include
include|#
directive|include
file|"usbdevs_data.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USB_VERBOSE */
end_comment

begin_function
specifier|static
name|void
name|usbd_set_device_strings
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb_device_descriptor
modifier|*
name|udd
init|=
operator|&
name|udev
operator|->
name|ddesc
decl_stmt|;
ifdef|#
directive|ifdef
name|USB_VERBOSE
specifier|const
name|struct
name|usb_knowndev
modifier|*
name|kdp
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|temp_ptr
decl_stmt|;
name|size_t
name|temp_size
decl_stmt|;
name|uint16_t
name|vendor_id
decl_stmt|;
name|uint16_t
name|product_id
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
comment|/* Protect scratch area */
name|do_unlock
operator|=
name|usbd_enum_lock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|temp_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|udev
operator|->
name|scratch
operator|.
name|data
expr_stmt|;
name|temp_size
operator|=
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|scratch
operator|.
name|data
argument_list|)
expr_stmt|;
name|vendor_id
operator|=
name|UGETW
argument_list|(
name|udd
operator|->
name|idVendor
argument_list|)
expr_stmt|;
name|product_id
operator|=
name|UGETW
argument_list|(
name|udd
operator|->
name|idProduct
argument_list|)
expr_stmt|;
comment|/* get serial number string */
name|usbd_req_get_string_any
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|temp_ptr
argument_list|,
name|temp_size
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|iSerialNumber
argument_list|)
expr_stmt|;
name|udev
operator|->
name|serial
operator|=
name|strdup
argument_list|(
name|temp_ptr
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
comment|/* get manufacturer string */
name|usbd_req_get_string_any
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|temp_ptr
argument_list|,
name|temp_size
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|iManufacturer
argument_list|)
expr_stmt|;
name|usb_trim_spaces
argument_list|(
name|temp_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_ptr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|udev
operator|->
name|manufacturer
operator|=
name|strdup
argument_list|(
name|temp_ptr
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
comment|/* get product string */
name|usbd_req_get_string_any
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|temp_ptr
argument_list|,
name|temp_size
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|iProduct
argument_list|)
expr_stmt|;
name|usb_trim_spaces
argument_list|(
name|temp_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_ptr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|udev
operator|->
name|product
operator|=
name|strdup
argument_list|(
name|temp_ptr
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_VERBOSE
if|if
condition|(
name|udev
operator|->
name|manufacturer
operator|==
name|NULL
operator|||
name|udev
operator|->
name|product
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|kdp
operator|=
name|usb_knowndevs
init|;
name|kdp
operator|->
name|vendorname
operator|!=
name|NULL
condition|;
name|kdp
operator|++
control|)
block|{
if|if
condition|(
name|kdp
operator|->
name|vendor
operator|==
name|vendor_id
operator|&&
operator|(
name|kdp
operator|->
name|product
operator|==
name|product_id
operator|||
operator|(
name|kdp
operator|->
name|flags
operator|&
name|USB_KNOWNDEV_NOPROD
operator|)
operator|!=
literal|0
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|kdp
operator|->
name|vendorname
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX should use pointer to knowndevs string */
if|if
condition|(
name|udev
operator|->
name|manufacturer
operator|==
name|NULL
condition|)
block|{
name|udev
operator|->
name|manufacturer
operator|=
name|strdup
argument_list|(
name|kdp
operator|->
name|vendorname
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|udev
operator|->
name|product
operator|==
name|NULL
operator|&&
operator|(
name|kdp
operator|->
name|flags
operator|&
name|USB_KNOWNDEV_NOPROD
operator|)
operator|==
literal|0
condition|)
block|{
name|udev
operator|->
name|product
operator|=
name|strdup
argument_list|(
name|kdp
operator|->
name|productname
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Provide default strings if none were found */
if|if
condition|(
name|udev
operator|->
name|manufacturer
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|temp_ptr
argument_list|,
name|temp_size
argument_list|,
literal|"vendor 0x%04x"
argument_list|,
name|vendor_id
argument_list|)
expr_stmt|;
name|udev
operator|->
name|manufacturer
operator|=
name|strdup
argument_list|(
name|temp_ptr
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|udev
operator|->
name|product
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|temp_ptr
argument_list|,
name|temp_size
argument_list|,
literal|"product 0x%04x"
argument_list|,
name|product_id
argument_list|)
expr_stmt|;
name|udev
operator|->
name|product
operator|=
name|strdup
argument_list|(
name|temp_ptr
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_unlock
condition|)
name|usbd_enum_unlock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns:  * See: USB_MODE_XXX  */
end_comment

begin_function
name|enum
name|usb_hc_mode
name|usbd_get_mode
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
return|return
operator|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns:  * See: USB_SPEED_XXX  */
end_comment

begin_function
name|enum
name|usb_dev_speed
name|usbd_get_speed
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
return|return
operator|(
name|udev
operator|->
name|speed
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|usbd_get_isoc_fps
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
empty_stmt|;
comment|/* indent fix */
switch|switch
condition|(
name|udev
operator|->
name|speed
condition|)
block|{
case|case
name|USB_SPEED_LOW
case|:
case|case
name|USB_SPEED_FULL
case|:
return|return
operator|(
literal|1000
operator|)
return|;
default|default:
return|return
operator|(
literal|8000
operator|)
return|;
block|}
block|}
end_function

begin_function
name|struct
name|usb_device_descriptor
modifier|*
name|usbd_get_device_descriptor
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* be NULL safe */
return|return
operator|(
operator|&
name|udev
operator|->
name|ddesc
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|usb_config_descriptor
modifier|*
name|usbd_get_config_descriptor
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* be NULL safe */
return|return
operator|(
name|udev
operator|->
name|cdesc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_test_quirk - test a device for a given quirk  *  * Return values:  * 0: The USB device does not have the given quirk.  * Else: The USB device has the given quirk.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usb_test_quirk
parameter_list|(
specifier|const
name|struct
name|usb_attach_arg
modifier|*
name|uaa
parameter_list|,
name|uint16_t
name|quirk
parameter_list|)
block|{
name|uint8_t
name|found
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
if|if
condition|(
name|quirk
operator|==
name|UQ_NONE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* search the automatic per device quirks first */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|USB_MAX_AUTO_QUIRK
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|uaa
operator|->
name|device
operator|->
name|autoQuirk
index|[
name|x
index|]
operator|==
name|quirk
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* search global quirk table, if any */
name|found
operator|=
call|(
name|usb_test_quirk_p
call|)
argument_list|(
operator|&
name|uaa
operator|->
name|info
argument_list|,
name|quirk
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|usb_interface_descriptor
modifier|*
name|usbd_get_interface_descriptor
parameter_list|(
name|struct
name|usb_interface
modifier|*
name|iface
parameter_list|)
block|{
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* be NULL safe */
return|return
operator|(
name|iface
operator|->
name|idesc
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|usbd_get_interface_altindex
parameter_list|(
name|struct
name|usb_interface
modifier|*
name|iface
parameter_list|)
block|{
return|return
operator|(
name|iface
operator|->
name|alt_index
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|usbd_get_bus_index
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
return|return
operator|(
operator|(
name|uint8_t
operator|)
name|device_get_unit
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|usbd_get_device_index
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
return|return
operator|(
name|udev
operator|->
name|device_index
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|USB_HAVE_DEVCTL
end_if

begin_function
specifier|static
name|void
name|usb_notify_addq
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb_interface
modifier|*
name|iface
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* announce the device */
name|sb
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
if|#
directive|if
name|USB_HAVE_UGEN
literal|"ugen=%s "
literal|"cdev=%s "
endif|#
directive|endif
literal|"vendor=0x%04x "
literal|"product=0x%04x "
literal|"devclass=0x%02x "
literal|"devsubclass=0x%02x "
literal|"sernum=\"%s\" "
literal|"release=0x%04x "
literal|"mode=%s "
literal|"port=%u "
if|#
directive|if
name|USB_HAVE_UGEN
literal|"parent=%s"
endif|#
directive|endif
literal|""
argument_list|,
if|#
directive|if
name|USB_HAVE_UGEN
name|udev
operator|->
name|ugen_name
argument_list|,
name|udev
operator|->
name|ugen_name
argument_list|,
endif|#
directive|endif
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|idVendor
argument_list|)
argument_list|,
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|idProduct
argument_list|)
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceClass
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceSubClass
argument_list|,
name|usb_get_serial
argument_list|(
name|udev
argument_list|)
argument_list|,
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|bcdDevice
argument_list|)
argument_list|,
operator|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_HOST
operator|)
condition|?
literal|"host"
else|:
literal|"device"
argument_list|,
name|udev
operator|->
name|port_no
if|#
directive|if
name|USB_HAVE_UGEN
argument_list|,
name|udev
operator|->
name|parent_hub
operator|!=
name|NULL
condition|?
name|udev
operator|->
name|parent_hub
operator|->
name|ugen_name
else|:
name|device_get_nameunit
argument_list|(
name|device_get_parent
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
argument_list|)
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|devctl_notify
argument_list|(
literal|"USB"
argument_list|,
literal|"DEVICE"
argument_list|,
name|type
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* announce each interface */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|USB_IFACE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|iface
operator|=
name|usbd_get_iface
argument_list|(
name|udev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
break|break;
comment|/* end of interfaces */
if|if
condition|(
name|iface
operator|->
name|idesc
operator|==
name|NULL
condition|)
continue|continue;
comment|/* no interface descriptor */
name|sb
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
if|#
directive|if
name|USB_HAVE_UGEN
literal|"ugen=%s "
literal|"cdev=%s "
endif|#
directive|endif
literal|"vendor=0x%04x "
literal|"product=0x%04x "
literal|"devclass=0x%02x "
literal|"devsubclass=0x%02x "
literal|"sernum=\"%s\" "
literal|"release=0x%04x "
literal|"mode=%s "
literal|"interface=%d "
literal|"endpoints=%d "
literal|"intclass=0x%02x "
literal|"intsubclass=0x%02x "
literal|"intprotocol=0x%02x"
argument_list|,
if|#
directive|if
name|USB_HAVE_UGEN
name|udev
operator|->
name|ugen_name
argument_list|,
name|udev
operator|->
name|ugen_name
argument_list|,
endif|#
directive|endif
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|idVendor
argument_list|)
argument_list|,
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|idProduct
argument_list|)
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceClass
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceSubClass
argument_list|,
name|usb_get_serial
argument_list|(
name|udev
argument_list|)
argument_list|,
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|bcdDevice
argument_list|)
argument_list|,
operator|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_HOST
operator|)
condition|?
literal|"host"
else|:
literal|"device"
argument_list|,
name|iface
operator|->
name|idesc
operator|->
name|bInterfaceNumber
argument_list|,
name|iface
operator|->
name|idesc
operator|->
name|bNumEndpoints
argument_list|,
name|iface
operator|->
name|idesc
operator|->
name|bInterfaceClass
argument_list|,
name|iface
operator|->
name|idesc
operator|->
name|bInterfaceSubClass
argument_list|,
name|iface
operator|->
name|idesc
operator|->
name|bInterfaceProtocol
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|devctl_notify
argument_list|(
literal|"USB"
argument_list|,
literal|"INTERFACE"
argument_list|,
name|type
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USB_HAVE_UGEN
end_if

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_fifo_free_wrap  *  * This function will free the FIFOs.  *  * Description of "flag" argument: If the USB_UNCFG_FLAG_FREE_EP0 flag  * is set and "iface_index" is set to "USB_IFACE_INDEX_ANY", we free  * all FIFOs. If the USB_UNCFG_FLAG_FREE_EP0 flag is not set and  * "iface_index" is set to "USB_IFACE_INDEX_ANY", we free all non  * control endpoint FIFOs. If "iface_index" is not set to  * "USB_IFACE_INDEX_ANY" the flag has no effect.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_fifo_free_wrap
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|flag
parameter_list|)
block|{
name|struct
name|usb_fifo
modifier|*
name|f
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
comment|/* 	 * Free any USB FIFOs on the given interface: 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|USB_FIFO_MAX
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|udev
operator|->
name|fifo
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
comment|/* Check if the interface index matches */
if|if
condition|(
name|iface_index
operator|==
name|f
operator|->
name|iface_index
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|methods
operator|!=
operator|&
name|usb_ugen_methods
condition|)
block|{
comment|/* 				 * Don't free any non-generic FIFOs in 				 * this case. 				 */
continue|continue;
block|}
if|if
condition|(
operator|(
name|f
operator|->
name|dev_ep_index
operator|==
literal|0
operator|)
operator|&&
operator|(
name|f
operator|->
name|fs_xfer
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* no need to free this FIFO */
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|iface_index
operator|==
name|USB_IFACE_INDEX_ANY
condition|)
block|{
if|if
condition|(
operator|(
name|f
operator|->
name|methods
operator|==
operator|&
name|usb_ugen_methods
operator|)
operator|&&
operator|(
name|f
operator|->
name|dev_ep_index
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
operator|(
name|flag
operator|&
name|USB_UNCFG_FLAG_FREE_EP0
operator|)
operator|)
operator|&&
operator|(
name|f
operator|->
name|fs_xfer
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* no need to free this FIFO */
continue|continue;
block|}
block|}
else|else
block|{
comment|/* no need to free this FIFO */
continue|continue;
block|}
comment|/* free this FIFO */
name|usb_fifo_free
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_peer_can_wakeup  *  * Return values:  * 0: Peer cannot do resume signalling.  * Else: Peer can do resume signalling.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usb_peer_can_wakeup
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
specifier|const
name|struct
name|usb_config_descriptor
modifier|*
name|cdp
decl_stmt|;
name|cdp
operator|=
name|udev
operator|->
name|cdesc
expr_stmt|;
if|if
condition|(
operator|(
name|cdp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_HOST
operator|)
condition|)
block|{
return|return
operator|(
name|cdp
operator|->
name|bmAttributes
operator|&
name|UC_REMOTE_WAKEUP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not supported */
block|}
end_function

begin_function
name|void
name|usb_set_device_state
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|enum
name|usb_dev_state
name|state
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|state
operator|<
name|USB_STATE_MAX
argument_list|,
operator|(
literal|"invalid udev state"
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"udev %p state %s -> %s\n"
argument_list|,
name|udev
argument_list|,
name|usb_statestr
argument_list|(
name|udev
operator|->
name|state
argument_list|)
argument_list|,
name|usb_statestr
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_HAVE_UGEN
name|mtx_lock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|udev
operator|->
name|state
operator|=
name|state
expr_stmt|;
if|#
directive|if
name|USB_HAVE_UGEN
name|mtx_unlock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|device_state_change
operator|!=
name|NULL
condition|)
call|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|device_state_change
call|)
argument_list|(
name|udev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|usb_dev_state
name|usb_get_device_state
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
return|return
operator|(
name|USB_STATE_DETACHED
operator|)
return|;
return|return
operator|(
name|udev
operator|->
name|state
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|usbd_device_attached
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
return|return
operator|(
name|udev
operator|->
name|state
operator|>
name|USB_STATE_DETACHED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The following function locks enumerating the given USB device. If  * the lock is already grabbed this function returns zero. Else a  * a value of one is returned.  */
end_comment

begin_function
name|uint8_t
name|usbd_enum_lock
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
if|if
condition|(
name|sx_xlocked
argument_list|(
operator|&
name|udev
operator|->
name|enum_sx
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|udev
operator|->
name|enum_sx
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|udev
operator|->
name|sr_sx
argument_list|)
expr_stmt|;
comment|/*  	 * NEWBUS LOCK NOTE: We should check if any parent SX locks 	 * are locked before locking Giant. Else the lock can be 	 * locked multiple times. 	 */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|USB_HAVE_UGEN
end_if

begin_comment
comment|/*  * This function is the same like usbd_enum_lock() except a value of  * 255 is returned when a signal is pending:  */
end_comment

begin_function
name|uint8_t
name|usbd_enum_lock_sig
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
if|if
condition|(
name|sx_xlocked
argument_list|(
operator|&
name|udev
operator|->
name|enum_sx
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sx_xlock_sig
argument_list|(
operator|&
name|udev
operator|->
name|enum_sx
argument_list|)
condition|)
return|return
operator|(
literal|255
operator|)
return|;
if|if
condition|(
name|sx_xlock_sig
argument_list|(
operator|&
name|udev
operator|->
name|sr_sx
argument_list|)
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|udev
operator|->
name|enum_sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|255
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following function unlocks enumerating the given USB device. */
end_comment

begin_function
name|void
name|usbd_enum_unlock
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|udev
operator|->
name|enum_sx
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|udev
operator|->
name|sr_sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function locks suspend and resume. */
end_comment

begin_function
name|void
name|usbd_sr_lock
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|udev
operator|->
name|sr_sx
argument_list|)
expr_stmt|;
comment|/*  	 * NEWBUS LOCK NOTE: We should check if any parent SX locks 	 * are locked before locking Giant. Else the lock can be 	 * locked multiple times. 	 */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function unlocks suspend and resume. */
end_comment

begin_function
name|void
name|usbd_sr_unlock
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|udev
operator|->
name|sr_sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The following function checks the enumerating lock for the given  * USB device.  */
end_comment

begin_function
name|uint8_t
name|usbd_enum_is_locked
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
return|return
operator|(
name|sx_xlocked
argument_list|(
operator|&
name|udev
operator|->
name|enum_sx
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The following function is used to set the per-interface specific  * plug and play information. The string referred to by the pnpinfo  * argument can safely be freed after calling this function. The  * pnpinfo of an interface will be reset at device detach or when  * passing a NULL argument to this function. This function  * returns zero on success, else a USB_ERR_XXX failure code.  */
end_comment

begin_function
name|usb_error_t
name|usbd_set_pnpinfo
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
specifier|const
name|char
modifier|*
name|pnpinfo
parameter_list|)
block|{
name|struct
name|usb_interface
modifier|*
name|iface
decl_stmt|;
name|iface
operator|=
name|usbd_get_iface
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
if|if
condition|(
name|iface
operator|->
name|pnpinfo
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|iface
operator|->
name|pnpinfo
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
name|iface
operator|->
name|pnpinfo
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pnpinfo
operator|==
name|NULL
operator|||
name|pnpinfo
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
name|iface
operator|->
name|pnpinfo
operator|=
name|strdup
argument_list|(
name|pnpinfo
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|pnpinfo
operator|==
name|NULL
condition|)
return|return
operator|(
name|USB_ERR_NOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
name|usb_error_t
name|usbd_add_dynamic_quirk
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint16_t
name|quirk
parameter_list|)
block|{
name|uint8_t
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|USB_MAX_AUTO_QUIRK
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|udev
operator|->
name|autoQuirk
index|[
name|x
index|]
operator|==
literal|0
operator|||
name|udev
operator|->
name|autoQuirk
index|[
name|x
index|]
operator|==
name|quirk
condition|)
block|{
name|udev
operator|->
name|autoQuirk
index|[
name|x
index|]
operator|=
name|quirk
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
block|}
return|return
operator|(
name|USB_ERR_NOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The following function is used to select the endpoint mode. It  * should not be called outside enumeration context.  */
end_comment

begin_function
name|usb_error_t
name|usbd_set_endpoint_mode
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|,
name|uint8_t
name|ep_mode
parameter_list|)
block|{
name|usb_error_t
name|error
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
comment|/* Prevent re-enumeration */
name|do_unlock
operator|=
name|usbd_enum_lock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|set_endpoint_mode
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
call|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|set_endpoint_mode
call|)
argument_list|(
name|udev
argument_list|,
name|ep
argument_list|,
name|ep_mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ep_mode
operator|!=
name|USB_EP_MODE_DEFAULT
condition|)
block|{
name|error
operator|=
name|USB_ERR_INVAL
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
comment|/* only set new mode regardless of error */
name|ep
operator|->
name|ep_mode
operator|=
name|ep_mode
expr_stmt|;
if|if
condition|(
name|do_unlock
condition|)
name|usbd_enum_unlock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|usbd_get_endpoint_mode
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|)
block|{
return|return
operator|(
name|ep
operator|->
name|ep_mode
operator|)
return|;
block|}
end_function

end_unit

