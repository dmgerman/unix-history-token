begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: uhci.c,v 1.170 2003/02/19 01:35:04 augustss Exp $	*/
end_comment

begin_comment
comment|/*	Also already incorporated from NetBSD:  *	$NetBSD: uhci.c,v 1.172 2003/02/23 04:19:26 simonb Exp $  *	$NetBSD: uhci.c,v 1.173 2003/05/13 04:41:59 gson Exp $  *	$NetBSD: uhci.c,v 1.175 2003/09/12 16:18:08 mycroft Exp $  *	$NetBSD: uhci.c,v 1.176 2003/11/04 19:11:21 mycroft Exp $  *	$NetBSD: uhci.c,v 1.177 2003/12/29 08:17:10 toshii Exp $  *	$NetBSD: uhci.c,v 1.178 2004/03/02 16:32:05 martin Exp $  *	$NetBSD: uhci.c,v 1.180 2004/07/17 20:12:03 mycroft Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Copyright (c) 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (lennart@augustsson.net) at  * Carlstedt Research& Technology.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * USB Universal Host Controller driver.  * Handles e.g. PIIX3 and PIIX4.  *  * UHCI spec: http://developer.intel.com/design/USB/UHCI11D.htm  * USB spec: http://www.usb.org/developers/docs/usbspec.zip  * PIIXn spec: ftp://download.intel.com/design/intarch/datashts/29055002.pdf  *             ftp://download.intel.com/design/intarch/datashts/29056201.pdf  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/endian.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_mem.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_quirks.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/uhcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/uhcivar.h>
end_include

begin_comment
comment|/* Use bandwidth reclamation for control transfers. Some devices choke on it. */
end_comment

begin_comment
comment|/*#define UHCI_CTL_LOOP */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|delay
parameter_list|(
name|d
parameter_list|)
value|DELAY(d)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MS_TO_TICKS
parameter_list|(
name|ms
parameter_list|)
value|((ms) * hz / 1000)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_decl_stmt
name|struct
name|cfdriver
name|uhci_cd
init|=
block|{
name|NULL
block|,
literal|"uhci"
block|,
name|DV_DULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
name|uhci_softc_t
modifier|*
name|thesc
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (uhcidebug) printf x
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (uhcidebug>(n)) printf x
end_define

begin_decl_stmt
name|int
name|uhcidebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|uhcinoloop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|uhci
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB uhci"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_uhci
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uhcidebug
argument_list|,
literal|0
argument_list|,
literal|"uhci debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_uhci
argument_list|,
name|OID_AUTO
argument_list|,
name|loop
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uhcinoloop
argument_list|,
literal|0
argument_list|,
literal|"uhci noloop"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__NetBSD__
end_ifndef

begin_define
define|#
directive|define
name|bitmask_snprintf
parameter_list|(
name|q
parameter_list|,
name|f
parameter_list|,
name|b
parameter_list|,
name|l
parameter_list|)
value|snprintf((b), (l), "%b", (q), (f))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The UHCI controller is little endian, so on big endian machines  * the data strored in memory needs to be swapped.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
end_if

begin_define
define|#
directive|define
name|htole32
parameter_list|(
name|x
parameter_list|)
value|(bswap32(x))
end_define

begin_define
define|#
directive|define
name|le32toh
parameter_list|(
name|x
parameter_list|)
value|(bswap32(x))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|htole32
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_define
define|#
directive|define
name|le32toh
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|uhci_pipe
block|{
name|struct
name|usbd_pipe
name|pipe
decl_stmt|;
name|int
name|nexttoggle
decl_stmt|;
name|u_char
name|aborting
decl_stmt|;
name|usbd_xfer_handle
name|abortstart
decl_stmt|,
name|abortend
decl_stmt|;
comment|/* Info needed for different pipe kinds. */
union|union
block|{
comment|/* Control pipe */
struct|struct
block|{
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usb_dma_t
name|reqdma
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|setup
decl_stmt|,
modifier|*
name|stat
decl_stmt|;
name|u_int
name|length
decl_stmt|;
block|}
name|ctl
struct|;
comment|/* Interrupt pipe */
struct|struct
block|{
name|int
name|npoll
decl_stmt|;
name|int
name|isread
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
modifier|*
name|qhs
decl_stmt|;
block|}
name|intr
struct|;
comment|/* Bulk pipe */
struct|struct
block|{
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|u_int
name|length
decl_stmt|;
name|int
name|isread
decl_stmt|;
block|}
name|bulk
struct|;
comment|/* Iso pipe */
struct|struct
name|iso
block|{
name|uhci_soft_td_t
modifier|*
modifier|*
name|stds
decl_stmt|;
name|int
name|next
decl_stmt|,
name|inuse
decl_stmt|;
block|}
name|iso
struct|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|uhci_globalreset
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_portreset
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_reset
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|uhci_shutdown
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_power
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|usbd_status
name|uhci_run
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|int
name|run
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uhci_soft_td_t
modifier|*
name|uhci_alloc_std
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_free_std
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|uhci_soft_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uhci_soft_qh_t
modifier|*
name|uhci_alloc_sqh
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_free_sqh
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|uhci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_aux_dma_alloc
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|uhci_soft_td_t
modifier|*
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uhci_physaddr_t
name|uhci_aux_dma_prepare
parameter_list|(
name|uhci_soft_td_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_aux_dma_complete
parameter_list|(
name|uhci_soft_td_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void		uhci_enter_ctl_q(uhci_softc_t *, uhci_soft_qh_t *, 					 uhci_intr_info_t *); static void		uhci_exit_ctl_q(uhci_softc_t *, uhci_soft_qh_t *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|uhci_free_std_chain
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|uhci_soft_td_t
modifier|*
parameter_list|,
name|uhci_soft_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_alloc_std_chain
parameter_list|(
name|struct
name|uhci_pipe
modifier|*
parameter_list|,
name|uhci_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|u_int16_t
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|uhci_soft_td_t
modifier|*
modifier|*
parameter_list|,
name|uhci_soft_td_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_poll_hub
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_waitintr
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_check_intr
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|uhci_intr_info_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_idone
parameter_list|(
name|uhci_intr_info_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_abort_xfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|,
name|usbd_status
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_transfer_complete
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_timeout_task
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_add_ls_ctrl
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|uhci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_add_hs_ctrl
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|uhci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_add_bulk
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|uhci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_remove_ls_ctrl
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|uhci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_remove_hs_ctrl
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|uhci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_remove_bulk
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|uhci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uhci_str
parameter_list|(
name|usb_string_descriptor_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_add_loop
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_rem_loop
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_setup_isoc
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_isoc_enter
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_allocm
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|,
name|usb_dma_t
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_freem
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|,
name|usb_dma_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_xfer_handle
name|uhci_allocx
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_freex
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|,
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_device_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_device_ctrl_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_ctrl_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_ctrl_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_device_intr_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_device_intr_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_intr_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_intr_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_intr_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_device_bulk_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_device_bulk_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_bulk_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_bulk_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_bulk_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_device_isoc_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_device_isoc_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_isoc_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_isoc_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_isoc_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_root_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_root_ctrl_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_root_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_root_ctrl_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_root_ctrl_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_root_intr_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_root_intr_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_root_intr_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_root_intr_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_root_intr_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_open
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_poll
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_softintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_device_request
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_add_intr
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|uhci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_remove_intr
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|,
name|uhci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uhci_device_setintr
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|uhci_pipe
modifier|*
name|pipe
parameter_list|,
name|int
name|ival
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_clear_toggle
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_noop
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uhci_soft_qh_t
modifier|*
name|uhci_find_prev_qh
parameter_list|(
name|uhci_soft_qh_t
modifier|*
parameter_list|,
name|uhci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|uhci_dump_all
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_dumpregs
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_dump_qhs
parameter_list|(
name|uhci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_dump_qh
parameter_list|(
name|uhci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_dump_tds
parameter_list|(
name|uhci_soft_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_dump_td
parameter_list|(
name|uhci_soft_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_dump_ii
parameter_list|(
name|uhci_intr_info_t
modifier|*
name|ii
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|uhci_dump
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UBARR
parameter_list|(
name|sc
parameter_list|)
value|bus_space_barrier((sc)->iot, (sc)->ioh, 0, (sc)->sc_size, \ 			BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE)
end_define

begin_define
define|#
directive|define
name|UWRITE1
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
define|\
value|do { UBARR(sc); bus_space_write_1((sc)->iot, (sc)->ioh, (r), (x)); \  } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|UWRITE2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
define|\
value|do { UBARR(sc); bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x)); \  } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|UWRITE4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
define|\
value|do { UBARR(sc); bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x)); \  } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|UREAD1
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|(UBARR(sc), bus_space_read_1((sc)->iot, (sc)->ioh, (r)))
end_define

begin_define
define|#
directive|define
name|UREAD2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|(UBARR(sc), bus_space_read_2((sc)->iot, (sc)->ioh, (r)))
end_define

begin_define
define|#
directive|define
name|UREAD4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|(UBARR(sc), bus_space_read_4((sc)->iot, (sc)->ioh, (r)))
end_define

begin_define
define|#
directive|define
name|UHCICMD
parameter_list|(
name|sc
parameter_list|,
name|cmd
parameter_list|)
value|UWRITE2(sc, UHCI_CMD, cmd)
end_define

begin_define
define|#
directive|define
name|UHCISTS
parameter_list|(
name|sc
parameter_list|)
value|UREAD2(sc, UHCI_STS)
end_define

begin_define
define|#
directive|define
name|UHCI_RESET_TIMEOUT
value|100
end_define

begin_comment
comment|/* ms, reset timeout */
end_comment

begin_define
define|#
directive|define
name|UHCI_CURFRAME
parameter_list|(
name|sc
parameter_list|)
value|(UREAD2(sc, UHCI_FRNUM)& UHCI_FRNUM_MASK)
end_define

begin_define
define|#
directive|define
name|UHCI_INTR_ENDPT
value|1
end_define

begin_decl_stmt
name|struct
name|usbd_bus_methods
name|uhci_bus_methods
init|=
block|{
name|uhci_open
block|,
name|uhci_softintr
block|,
name|uhci_poll
block|,
name|uhci_allocm
block|,
name|uhci_freem
block|,
name|uhci_allocx
block|,
name|uhci_freex
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_pipe_methods
name|uhci_root_ctrl_methods
init|=
block|{
name|uhci_root_ctrl_transfer
block|,
name|uhci_root_ctrl_start
block|,
name|uhci_root_ctrl_abort
block|,
name|uhci_root_ctrl_close
block|,
name|uhci_noop
block|,
name|uhci_root_ctrl_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_pipe_methods
name|uhci_root_intr_methods
init|=
block|{
name|uhci_root_intr_transfer
block|,
name|uhci_root_intr_start
block|,
name|uhci_root_intr_abort
block|,
name|uhci_root_intr_close
block|,
name|uhci_noop
block|,
name|uhci_root_intr_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_pipe_methods
name|uhci_device_ctrl_methods
init|=
block|{
name|uhci_device_ctrl_transfer
block|,
name|uhci_device_ctrl_start
block|,
name|uhci_device_ctrl_abort
block|,
name|uhci_device_ctrl_close
block|,
name|uhci_noop
block|,
name|uhci_device_ctrl_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_pipe_methods
name|uhci_device_intr_methods
init|=
block|{
name|uhci_device_intr_transfer
block|,
name|uhci_device_intr_start
block|,
name|uhci_device_intr_abort
block|,
name|uhci_device_intr_close
block|,
name|uhci_device_clear_toggle
block|,
name|uhci_device_intr_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_pipe_methods
name|uhci_device_bulk_methods
init|=
block|{
name|uhci_device_bulk_transfer
block|,
name|uhci_device_bulk_start
block|,
name|uhci_device_bulk_abort
block|,
name|uhci_device_bulk_close
block|,
name|uhci_device_clear_toggle
block|,
name|uhci_device_bulk_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_pipe_methods
name|uhci_device_isoc_methods
init|=
block|{
name|uhci_device_isoc_transfer
block|,
name|uhci_device_isoc_start
block|,
name|uhci_device_isoc_abort
block|,
name|uhci_device_isoc_close
block|,
name|uhci_noop
block|,
name|uhci_device_isoc_done
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|uhci_add_intr_info
parameter_list|(
name|sc
parameter_list|,
name|ii
parameter_list|)
define|\
value|LIST_INSERT_HEAD(&(sc)->sc_intrhead, (ii), list)
end_define

begin_define
define|#
directive|define
name|uhci_del_intr_info
parameter_list|(
name|ii
parameter_list|)
define|\
value|do { \ 		LIST_REMOVE((ii), list); \ 		(ii)->list.le_prev = NULL; \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|uhci_active_intr_info
parameter_list|(
name|ii
parameter_list|)
value|((ii)->list.le_prev != NULL)
end_define

begin_function
specifier|static
name|__inline
name|uhci_soft_qh_t
modifier|*
name|uhci_find_prev_qh
parameter_list|(
name|uhci_soft_qh_t
modifier|*
name|pqh
parameter_list|,
name|uhci_soft_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"uhci_find_prev_qh: pqh=%p sqh=%p\n"
operator|,
name|pqh
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|pqh
operator|->
name|hlink
operator|!=
name|sqh
condition|;
name|pqh
operator|=
name|pqh
operator|->
name|hlink
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|||
name|defined
argument_list|(
name|USB_DEBUG
argument_list|)
if|if
condition|(
name|le32toh
argument_list|(
name|pqh
operator|->
name|qh
operator|.
name|qh_hlink
argument_list|)
operator|&
name|UHCI_PTR_T
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_find_prev_qh: QH not found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
name|pqh
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_globalreset
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD_GRESET
argument_list|)
expr_stmt|;
comment|/* global reset */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_BUS_RESET_DELAY
argument_list|)
expr_stmt|;
comment|/* wait a little */
name|UHCICMD
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* do nothing */
block|}
end_function

begin_function
name|usbd_status
name|uhci_init
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|clsqh
decl_stmt|,
modifier|*
name|chsqh
decl_stmt|,
modifier|*
name|bsqh
decl_stmt|,
modifier|*
name|sqh
decl_stmt|,
modifier|*
name|lsqh
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_init: start\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|thesc
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|uhcidebug
operator|>
literal|2
condition|)
name|uhci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|uhci_globalreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* reset the controller */
name|uhci_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize real frame array. */
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|UHCI_FRAMELIST_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|uhci_physaddr_t
argument_list|)
argument_list|,
name|UHCI_FRAMELIST_ALIGN
argument_list|,
operator|&
name|sc
operator|->
name|sc_dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|sc
operator|->
name|sc_pframes
operator|=
name|KERNADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_dma
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_FRNUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set frame number to 0 */
name|UWRITE4
argument_list|(
name|sc
argument_list|,
name|UHCI_FLBASEADDR
argument_list|,
name|DMAADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_dma
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set frame list*/
comment|/* 	 * Allocate a TD, inactive, that hangs from the last QH. 	 * This is to avoid a bug in the PIIX that makes it run berserk 	 * otherwise. 	 */
name|std
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|==
name|NULL
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|std
operator|->
name|link
operator|.
name|std
operator|=
name|NULL
expr_stmt|;
name|std
operator|->
name|td
operator|.
name|td_link
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|std
operator|->
name|td
operator|.
name|td_status
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* inactive */
name|std
operator|->
name|td
operator|.
name|td_token
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|std
operator|->
name|td
operator|.
name|td_buffer
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Allocate the dummy QH marking the end and used for looping the QHs.*/
name|lsqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsqh
operator|==
name|NULL
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|lsqh
operator|->
name|hlink
operator|=
name|NULL
expr_stmt|;
name|lsqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
comment|/* end of QH chain */
name|lsqh
operator|->
name|elink
operator|=
name|std
expr_stmt|;
name|lsqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|std
operator|->
name|physaddr
operator||
name|UHCI_PTR_TD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_last_qh
operator|=
name|lsqh
expr_stmt|;
comment|/* Allocate the dummy QH where bulk traffic will be queued. */
name|bsqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsqh
operator|==
name|NULL
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|bsqh
operator|->
name|hlink
operator|=
name|lsqh
expr_stmt|;
name|bsqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|htole32
argument_list|(
name|lsqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_QH
argument_list|)
expr_stmt|;
name|bsqh
operator|->
name|elink
operator|=
name|NULL
expr_stmt|;
name|bsqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bulk_start
operator|=
name|sc
operator|->
name|sc_bulk_end
operator|=
name|bsqh
expr_stmt|;
comment|/* Allocate dummy QH where high speed control traffic will be queued. */
name|chsqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|chsqh
operator|==
name|NULL
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|chsqh
operator|->
name|hlink
operator|=
name|bsqh
expr_stmt|;
name|chsqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|htole32
argument_list|(
name|bsqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_QH
argument_list|)
expr_stmt|;
name|chsqh
operator|->
name|elink
operator|=
name|NULL
expr_stmt|;
name|chsqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hctl_start
operator|=
name|sc
operator|->
name|sc_hctl_end
operator|=
name|chsqh
expr_stmt|;
comment|/* Allocate dummy QH where control traffic will be queued. */
name|clsqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|clsqh
operator|==
name|NULL
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|clsqh
operator|->
name|hlink
operator|=
name|chsqh
expr_stmt|;
name|clsqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|htole32
argument_list|(
name|chsqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_QH
argument_list|)
expr_stmt|;
name|clsqh
operator|->
name|elink
operator|=
name|NULL
expr_stmt|;
name|clsqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_lctl_start
operator|=
name|sc
operator|->
name|sc_lctl_end
operator|=
name|clsqh
expr_stmt|;
comment|/* 	 * Make all (virtual) frame list pointers point to the interrupt 	 * queue heads and the interrupt queue heads at the control 	 * queue head and point the physical frame list to the virtual. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|std
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|==
name|NULL
operator|||
name|sqh
operator|==
name|NULL
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|std
operator|->
name|link
operator|.
name|sqh
operator|=
name|sqh
expr_stmt|;
name|std
operator|->
name|td
operator|.
name|td_link
operator|=
name|htole32
argument_list|(
name|sqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_QH
argument_list|)
expr_stmt|;
name|std
operator|->
name|td
operator|.
name|td_status
operator|=
name|htole32
argument_list|(
name|UHCI_TD_IOS
argument_list|)
expr_stmt|;
comment|/* iso, inactive */
name|std
operator|->
name|td
operator|.
name|td_token
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|std
operator|->
name|td
operator|.
name|td_buffer
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|hlink
operator|=
name|clsqh
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|htole32
argument_list|(
name|clsqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_QH
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|elink
operator|=
name|NULL
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|htd
operator|=
name|std
expr_stmt|;
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|etd
operator|=
name|std
expr_stmt|;
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|hqh
operator|=
name|sqh
expr_stmt|;
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|eqh
operator|=
name|sqh
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|UHCI_FRAMELIST_COUNT
condition|;
name|j
operator|+=
name|UHCI_VFRAMELIST_COUNT
control|)
name|sc
operator|->
name|sc_pframes
index|[
name|j
index|]
operator|=
name|htole32
argument_list|(
name|std
operator|->
name|physaddr
argument_list|)
expr_stmt|;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|)
expr_stmt|;
name|usb_callout_init
argument_list|(
name|sc
operator|->
name|sc_poll_handle
argument_list|)
expr_stmt|;
comment|/* Set up the bus struct. */
name|sc
operator|->
name|sc_bus
operator|.
name|methods
operator|=
operator|&
name|uhci_bus_methods
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|pipe_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uhci_pipe
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|sc
operator|->
name|sc_suspend
operator|=
name|PWR_RESUME
expr_stmt|;
name|sc
operator|->
name|sc_powerhook
operator|=
name|powerhook_establish
argument_list|(
name|uhci_power
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_shutdownhook
operator|=
name|shutdownhook_establish
argument_list|(
name|uhci_shutdown
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_init: enabling\n"
operator|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|,
name|UHCI_INTR_TOCRCIE
operator||
name|UHCI_INTR_RIE
operator||
name|UHCI_INTR_IOCE
operator||
name|UHCI_INTR_SPIE
argument_list|)
expr_stmt|;
comment|/* enable interrupts */
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD_MAXP
argument_list|)
expr_stmt|;
comment|/* Assume 64 byte packets at frame end */
return|return
operator|(
name|uhci_run
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|)
return|;
comment|/* and here we go... */
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|int
name|uhci_activate
parameter_list|(
name|device_t
name|self
parameter_list|,
name|enum
name|devact
name|act
parameter_list|)
block|{
name|struct
name|uhci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|uhci_softc
operator|*
operator|)
name|self
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|act
condition|)
block|{
case|case
name|DVACT_ACTIVATE
case|:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
case|case
name|DVACT_DEACTIVATE
case|:
if|if
condition|(
name|sc
operator|->
name|sc_child
operator|!=
name|NULL
condition|)
name|rv
operator|=
name|config_deactivate
argument_list|(
name|sc
operator|->
name|sc_child
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|uhci_detach
parameter_list|(
name|struct
name|uhci_softc
modifier|*
name|sc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_child
operator|!=
name|NULL
condition|)
name|rv
operator|=
name|config_detach
argument_list|(
name|sc
operator|->
name|sc_child
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
else|#
directive|else
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|uhci_run
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|powerhook_disestablish
argument_list|(
name|sc
operator|->
name|sc_powerhook
argument_list|)
expr_stmt|;
name|shutdownhook_disestablish
argument_list|(
name|sc
operator|->
name|sc_shutdownhook
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Free all xfers associated with this HC. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
break|break;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xfer
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
block|}
comment|/* XXX free other data structures XXX */
name|usb_freemem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_dma
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_allocm
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|,
name|usb_dma_t
modifier|*
name|dma
parameter_list|,
name|u_int32_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|usb_allocmem
argument_list|(
name|bus
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|dma
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_freem
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|,
name|usb_dma_t
modifier|*
name|dma
parameter_list|)
block|{
name|usb_freemem
argument_list|(
name|bus
argument_list|,
name|dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_xfer_handle
name|uhci_allocx
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|uhci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|uhci_softc
operator|*
operator|)
name|bus
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|,
name|next
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|busy_free
operator|!=
name|XFER_FREE
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_allocx: xfer=%p not free, 0x%08x\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|busy_free
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|xfer
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uhci_xfer
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xfer
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uhci_xfer
argument_list|)
argument_list|)
expr_stmt|;
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|iinfo
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|usb_init_task
argument_list|(
operator|&
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|abort_task
argument_list|,
name|uhci_timeout_task
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|uhci_xfer_flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|iinfo
operator|.
name|isdone
operator|=
literal|1
expr_stmt|;
name|xfer
operator|->
name|busy_free
operator|=
name|XFER_BUSY
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|xfer
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_freex
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|uhci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|uhci_softc
operator|*
operator|)
name|bus
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|busy_free
operator|!=
name|XFER_BUSY
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_freex: xfer=%p not busy, 0x%08x\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|busy_free
argument_list|)
expr_stmt|;
return|return;
block|}
name|xfer
operator|->
name|busy_free
operator|=
name|XFER_FREE
expr_stmt|;
if|if
condition|(
operator|!
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|iinfo
operator|.
name|isdone
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_freex: !isdone\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|,
name|xfer
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shut down the controller when the system is going down.  */
end_comment

begin_function
name|void
name|uhci_shutdown
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_shutdown: stopping the HC\n"
operator|)
argument_list|)
expr_stmt|;
name|uhci_run
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* stop the controller */
block|}
end_function

begin_comment
comment|/*  * Handle suspend/resume.  *  * We need to switch to polling mode here, because this routine is  * called from an interrupt context.  This is all right since we  * are almost suspended anyway.  */
end_comment

begin_function
name|void
name|uhci_power
parameter_list|(
name|int
name|why
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhardusb
argument_list|()
expr_stmt|;
name|cmd
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_power: sc=%p, why=%d (was %d), cmd=0x%x\n"
operator|,
name|sc
operator|,
name|why
operator|,
name|sc
operator|->
name|sc_suspend
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|why
operator|!=
name|PWR_RESUME
condition|)
block|{
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|2
condition|)
name|uhci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_intr_xfer
operator|!=
name|NULL
condition|)
name|usb_uncallout
argument_list|(
name|sc
operator|->
name|sc_poll_handle
argument_list|,
name|uhci_poll_hub
argument_list|,
name|sc
operator|->
name|sc_intr_xfer
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
operator|++
expr_stmt|;
name|uhci_run
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* stop the controller */
name|cmd
operator|&=
operator|~
name|UHCI_CMD_RS
expr_stmt|;
comment|/* save some state if BIOS doesn't */
name|sc
operator|->
name|sc_saved_frnum
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_FRNUM
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_saved_sof
operator|=
name|UREAD1
argument_list|(
name|sc
argument_list|,
name|UHCI_SOF
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable intrs */
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|cmd
operator||
name|UHCI_CMD_EGSM
argument_list|)
expr_stmt|;
comment|/* enter global suspend */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_RESUME_WAIT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_suspend
operator|=
name|why
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
operator|--
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_power: cmd=0x%x\n"
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sc
operator|->
name|sc_suspend
operator|==
name|PWR_RESUME
condition|)
name|printf
argument_list|(
literal|"uhci_power: weird, resume without suspend.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_suspend
operator|=
name|why
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|uhci_globalreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* reset the controller */
name|uhci_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
name|UHCI_CMD_RS
condition|)
name|uhci_run
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in case BIOS has started it */
name|uhci_globalreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|uhci_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* restore saved state */
name|UWRITE4
argument_list|(
name|sc
argument_list|,
name|UHCI_FLBASEADDR
argument_list|,
name|DMAADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_dma
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_FRNUM
argument_list|,
name|sc
operator|->
name|sc_saved_frnum
argument_list|)
expr_stmt|;
name|UWRITE1
argument_list|(
name|sc
argument_list|,
name|UHCI_SOF
argument_list|,
name|sc
operator|->
name|sc_saved_sof
argument_list|)
expr_stmt|;
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|cmd
operator||
name|UHCI_CMD_FGR
argument_list|)
expr_stmt|;
comment|/* force global resume */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_RESUME_DELAY
argument_list|)
expr_stmt|;
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|cmd
operator|&
operator|~
name|UHCI_CMD_EGSM
argument_list|)
expr_stmt|;
comment|/* back to normal */
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|,
name|UHCI_INTR_TOCRCIE
operator||
name|UHCI_INTR_RIE
operator||
name|UHCI_INTR_IOCE
operator||
name|UHCI_INTR_SPIE
argument_list|)
expr_stmt|;
comment|/* re-enable intrs */
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD_MAXP
argument_list|)
expr_stmt|;
name|uhci_run
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* and start traffic again */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_RESUME_RECOVERY
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
operator|--
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_intr_xfer
operator|!=
name|NULL
condition|)
name|usb_callout
argument_list|(
name|sc
operator|->
name|sc_poll_handle
argument_list|,
name|sc
operator|->
name|sc_ival
argument_list|,
name|uhci_poll_hub
argument_list|,
name|sc
operator|->
name|sc_intr_xfer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|2
condition|)
name|uhci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|uhci_dumpregs
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, "
literal|"flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD
argument_list|)
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|)
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_FRNUM
argument_list|)
operator|,
name|UREAD4
argument_list|(
name|sc
argument_list|,
name|UHCI_FLBASEADDR
argument_list|)
operator|,
name|UREAD1
argument_list|(
name|sc
argument_list|,
name|UHCI_SOF
argument_list|)
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC1
argument_list|)
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_dump_td
parameter_list|(
name|uhci_soft_td_t
modifier|*
name|p
parameter_list|)
block|{
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|,
name|sbuf2
index|[
literal|128
index|]
decl_stmt|;
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"TD(%p) at %08lx = link=0x%08lx status=0x%08lx "
literal|"token=0x%08lx buffer=0x%08lx\n"
operator|,
name|p
operator|,
operator|(
name|long
operator|)
name|p
operator|->
name|physaddr
operator|,
operator|(
name|long
operator|)
name|le32toh
argument_list|(
name|p
operator|->
name|td
operator|.
name|td_link
argument_list|)
operator|,
operator|(
name|long
operator|)
name|le32toh
argument_list|(
name|p
operator|->
name|td
operator|.
name|td_status
argument_list|)
operator|,
operator|(
name|long
operator|)
name|le32toh
argument_list|(
name|p
operator|->
name|td
operator|.
name|td_token
argument_list|)
operator|,
operator|(
name|long
operator|)
name|le32toh
argument_list|(
name|p
operator|->
name|td
operator|.
name|td_buffer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bitmask_snprintf
argument_list|(
operator|(
name|u_int32_t
operator|)
name|le32toh
argument_list|(
name|p
operator|->
name|td
operator|.
name|td_link
argument_list|)
argument_list|,
literal|"\20\1T\2Q\3VF"
argument_list|,
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
name|bitmask_snprintf
argument_list|(
operator|(
name|u_int32_t
operator|)
name|le32toh
argument_list|(
name|p
operator|->
name|td
operator|.
name|td_status
argument_list|)
argument_list|,
literal|"\20\22BITSTUFF\23CRCTO\24NAK\25BABBLE\26DBUFFER\27"
literal|"STALLED\30ACTIVE\31IOC\32ISO\33LS\36SPD"
argument_list|,
name|sbuf2
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf2
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"  %s %s,errcnt=%d,actlen=%d pid=%02x,addr=%d,endpt=%d,"
literal|"D=%d,maxlen=%d\n"
operator|,
name|sbuf
operator|,
name|sbuf2
operator|,
name|UHCI_TD_GET_ERRCNT
argument_list|(
name|le32toh
argument_list|(
name|p
operator|->
name|td
operator|.
name|td_status
argument_list|)
argument_list|)
operator|,
name|UHCI_TD_GET_ACTLEN
argument_list|(
name|le32toh
argument_list|(
name|p
operator|->
name|td
operator|.
name|td_status
argument_list|)
argument_list|)
operator|,
name|UHCI_TD_GET_PID
argument_list|(
name|le32toh
argument_list|(
name|p
operator|->
name|td
operator|.
name|td_token
argument_list|)
argument_list|)
operator|,
name|UHCI_TD_GET_DEVADDR
argument_list|(
name|le32toh
argument_list|(
name|p
operator|->
name|td
operator|.
name|td_token
argument_list|)
argument_list|)
operator|,
name|UHCI_TD_GET_ENDPT
argument_list|(
name|le32toh
argument_list|(
name|p
operator|->
name|td
operator|.
name|td_token
argument_list|)
argument_list|)
operator|,
name|UHCI_TD_GET_DT
argument_list|(
name|le32toh
argument_list|(
name|p
operator|->
name|td
operator|.
name|td_token
argument_list|)
argument_list|)
operator|,
name|UHCI_TD_GET_MAXLEN
argument_list|(
name|le32toh
argument_list|(
name|p
operator|->
name|td
operator|.
name|td_token
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_dump_qh
parameter_list|(
name|uhci_soft_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"QH(%p) at %08x: hlink=%08x elink=%08x\n"
operator|,
name|sqh
operator|,
operator|(
name|int
operator|)
name|sqh
operator|->
name|physaddr
operator|,
name|le32toh
argument_list|(
name|sqh
operator|->
name|qh
operator|.
name|qh_hlink
argument_list|)
operator|,
name|le32toh
argument_list|(
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|1
end_if

begin_function
name|void
name|uhci_dump
parameter_list|(
name|void
parameter_list|)
block|{
name|uhci_dump_all
argument_list|(
name|thesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|uhci_dump_all
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uhci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"intrs=%d\n"
argument_list|,
name|sc
operator|->
name|sc_bus
operator|.
name|no_intrs
argument_list|)
expr_stmt|;
comment|/*printf("framelist[i].link = %08x\n", sc->sc_framelist[0].link);*/
name|uhci_dump_qh
argument_list|(
name|sc
operator|->
name|sc_lctl_start
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_dump_qhs
parameter_list|(
name|uhci_soft_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|uhci_dump_qh
argument_list|(
name|sqh
argument_list|)
expr_stmt|;
comment|/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards 	 * Traverses sideways first, then down. 	 * 	 * QH1 	 * QH2 	 * No QH 	 * TD2.1 	 * TD2.2 	 * TD1.1 	 * etc. 	 * 	 * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1. 	 */
if|if
condition|(
name|sqh
operator|->
name|hlink
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|le32toh
argument_list|(
name|sqh
operator|->
name|qh
operator|.
name|qh_hlink
argument_list|)
operator|&
name|UHCI_PTR_T
operator|)
condition|)
name|uhci_dump_qhs
argument_list|(
name|sqh
operator|->
name|hlink
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
operator|(
literal|"No QH\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqh
operator|->
name|elink
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|le32toh
argument_list|(
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
argument_list|)
operator|&
name|UHCI_PTR_T
operator|)
condition|)
name|uhci_dump_tds
argument_list|(
name|sqh
operator|->
name|elink
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
operator|(
literal|"No TD\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_dump_tds
parameter_list|(
name|uhci_soft_td_t
modifier|*
name|std
parameter_list|)
block|{
name|uhci_soft_td_t
modifier|*
name|td
decl_stmt|;
for|for
control|(
name|td
operator|=
name|std
init|;
name|td
operator|!=
name|NULL
condition|;
name|td
operator|=
name|td
operator|->
name|link
operator|.
name|std
control|)
block|{
name|uhci_dump_td
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* Check whether the link pointer in this TD marks 		 * the link pointer as end of queue. This avoids 		 * printing the free list in case the queue/TD has 		 * already been moved there (seatbelt). 		 */
if|if
condition|(
name|le32toh
argument_list|(
name|td
operator|->
name|td
operator|.
name|td_link
argument_list|)
operator|&
name|UHCI_PTR_T
operator|||
name|le32toh
argument_list|(
name|td
operator|->
name|td
operator|.
name|td_link
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_dump_ii
parameter_list|(
name|uhci_intr_info_t
modifier|*
name|ii
parameter_list|)
block|{
name|usbd_pipe_handle
name|pipe
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
decl_stmt|;
name|usbd_device_handle
name|dev
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
define|#
directive|define
name|DONE
value|ii->isdone
else|#
directive|else
define|#
directive|define
name|DONE
value|0
endif|#
directive|endif
if|if
condition|(
name|ii
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ii NULL\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ii
operator|->
name|xfer
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ii %p: done=%d xfer=NULL\n"
argument_list|,
name|ii
argument_list|,
name|DONE
argument_list|)
expr_stmt|;
return|return;
block|}
name|pipe
operator|=
name|ii
operator|->
name|xfer
operator|->
name|pipe
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ii %p: done=%d xfer=%p pipe=NULL\n"
argument_list|,
name|ii
argument_list|,
name|DONE
argument_list|,
name|ii
operator|->
name|xfer
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pipe
operator|->
name|endpoint
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ii %p: done=%d xfer=%p pipe=%p pipe->endpoint=NULL\n"
argument_list|,
name|ii
argument_list|,
name|DONE
argument_list|,
name|ii
operator|->
name|xfer
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pipe
operator|->
name|device
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ii %p: done=%d xfer=%p pipe=%p pipe->device=NULL\n"
argument_list|,
name|ii
argument_list|,
name|DONE
argument_list|,
name|ii
operator|->
name|xfer
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
return|return;
block|}
name|ed
operator|=
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
expr_stmt|;
name|dev
operator|=
name|pipe
operator|->
name|device
expr_stmt|;
name|printf
argument_list|(
literal|"ii %p: done=%d xfer=%p dev=%p vid=0x%04x pid=0x%04x addr=%d pipe=%p ep=0x%02x attr=0x%02x\n"
argument_list|,
name|ii
argument_list|,
name|DONE
argument_list|,
name|ii
operator|->
name|xfer
argument_list|,
name|dev
argument_list|,
name|UGETW
argument_list|(
name|dev
operator|->
name|ddesc
operator|.
name|idVendor
argument_list|)
argument_list|,
name|UGETW
argument_list|(
name|dev
operator|->
name|ddesc
operator|.
name|idProduct
argument_list|)
argument_list|,
name|dev
operator|->
name|address
argument_list|,
name|pipe
argument_list|,
name|ed
operator|->
name|bEndpointAddress
argument_list|,
name|ed
operator|->
name|bmAttributes
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|DONE
block|}
end_function

begin_function_decl
name|void
name|uhci_dump_iis
parameter_list|(
name|struct
name|uhci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|uhci_dump_iis
parameter_list|(
name|struct
name|uhci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
name|printf
argument_list|(
literal|"intr_info list:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|)
init|;
name|ii
condition|;
name|ii
operator|=
name|LIST_NEXT
argument_list|(
name|ii
argument_list|,
name|list
argument_list|)
control|)
name|uhci_dump_ii
argument_list|(
name|ii
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|iidump
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|iidump
parameter_list|(
name|void
parameter_list|)
block|{
name|uhci_dump_iis
argument_list|(
name|thesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This routine is executed periodically and simulates interrupts  * from the root controller interrupt pipe for port status change.  */
end_comment

begin_function
name|void
name|uhci_poll_hub
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|usbd_xfer_handle
name|xfer
init|=
name|addr
decl_stmt|;
name|usbd_pipe_handle
name|pipe
init|=
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|pipe
operator|->
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"uhci_poll_hub\n"
operator|)
argument_list|)
expr_stmt|;
name|usb_callout
argument_list|(
name|sc
operator|->
name|sc_poll_handle
argument_list|,
name|sc
operator|->
name|sc_ival
argument_list|,
name|uhci_poll_hub
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|p
operator|=
name|xfer
operator|->
name|buffer
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC1
argument_list|)
operator|&
operator|(
name|UHCI_PORTSC_CSC
operator||
name|UHCI_PORTSC_OCIC
operator|)
condition|)
name|p
index|[
literal|0
index|]
operator||=
literal|1
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC2
argument_list|)
operator|&
operator|(
name|UHCI_PORTSC_CSC
operator||
name|UHCI_PORTSC_OCIC
operator|)
condition|)
name|p
index|[
literal|0
index|]
operator||=
literal|1
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* No change, try again in a while */
return|return;
name|xfer
operator|->
name|actlen
operator|=
literal|1
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|dev
operator|->
name|bus
operator|->
name|intr_context
operator|++
expr_stmt|;
name|uhci_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|dev
operator|->
name|bus
operator|->
name|intr_context
operator|--
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_root_intr_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|uhci_root_ctrl_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Let the last QH loop back to the high speed control transfer QH.  * This is what intel calls "bandwidth reclamation" and improves  * USB performance a lot for some devices.  * If we are already looping, just count it.  */
end_comment

begin_function
name|void
name|uhci_add_loop
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcinoloop
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_loops
operator|==
literal|1
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_start_loop: add\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Note, we don't loop back the soft pointer. */
name|sc
operator|->
name|sc_last_qh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_hctl_start
operator|->
name|physaddr
operator||
name|UHCI_PTR_QH
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|uhci_rem_loop
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcinoloop
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_loops
operator|==
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_end_loop: remove\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_last_qh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add high speed control QH, called at splusb(). */
end_comment

begin_function
name|void
name|uhci_add_hs_ctrl
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|uhci_soft_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|uhci_soft_qh_t
modifier|*
name|eqh
decl_stmt|;
name|SPLUSBCHECK
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_add_ctrl: sqh=%p\n"
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
name|eqh
operator|=
name|sc
operator|->
name|sc_hctl_end
expr_stmt|;
name|sqh
operator|->
name|hlink
operator|=
name|eqh
operator|->
name|hlink
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|eqh
operator|->
name|qh
operator|.
name|qh_hlink
expr_stmt|;
name|eqh
operator|->
name|hlink
operator|=
name|sqh
expr_stmt|;
name|eqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|htole32
argument_list|(
name|sqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_QH
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hctl_end
operator|=
name|sqh
expr_stmt|;
ifdef|#
directive|ifdef
name|UHCI_CTL_LOOP
name|uhci_add_loop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Remove high speed control QH, called at splusb(). */
end_comment

begin_function
name|void
name|uhci_remove_hs_ctrl
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|uhci_soft_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|uhci_soft_qh_t
modifier|*
name|pqh
decl_stmt|;
name|SPLUSBCHECK
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_remove_hs_ctrl: sqh=%p\n"
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UHCI_CTL_LOOP
name|uhci_rem_loop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The T bit should be set in the elink of the QH so that the HC 	 * doesn't follow the pointer.  This condition may fail if the 	 * the transferred packet was short so that the QH still points 	 * at the last used TD. 	 * In this case we set the T bit and wait a little for the HC 	 * to stop looking at the TD. 	 */
if|if
condition|(
operator|!
operator|(
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|&
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
operator|)
condition|)
block|{
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|UHCI_QH_REMOVE_DELAY
argument_list|)
expr_stmt|;
block|}
name|pqh
operator|=
name|uhci_find_prev_qh
argument_list|(
name|sc
operator|->
name|sc_hctl_start
argument_list|,
name|sqh
argument_list|)
expr_stmt|;
name|pqh
operator|->
name|hlink
operator|=
name|sqh
operator|->
name|hlink
expr_stmt|;
name|pqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|sqh
operator|->
name|qh
operator|.
name|qh_hlink
expr_stmt|;
name|delay
argument_list|(
name|UHCI_QH_REMOVE_DELAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hctl_end
operator|==
name|sqh
condition|)
name|sc
operator|->
name|sc_hctl_end
operator|=
name|pqh
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add low speed control QH, called at splusb(). */
end_comment

begin_function
name|void
name|uhci_add_ls_ctrl
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|uhci_soft_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|uhci_soft_qh_t
modifier|*
name|eqh
decl_stmt|;
name|SPLUSBCHECK
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_add_ls_ctrl: sqh=%p\n"
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
name|eqh
operator|=
name|sc
operator|->
name|sc_lctl_end
expr_stmt|;
name|sqh
operator|->
name|hlink
operator|=
name|eqh
operator|->
name|hlink
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|eqh
operator|->
name|qh
operator|.
name|qh_hlink
expr_stmt|;
name|eqh
operator|->
name|hlink
operator|=
name|sqh
expr_stmt|;
name|eqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|htole32
argument_list|(
name|sqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_QH
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_lctl_end
operator|=
name|sqh
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove low speed control QH, called at splusb(). */
end_comment

begin_function
name|void
name|uhci_remove_ls_ctrl
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|uhci_soft_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|uhci_soft_qh_t
modifier|*
name|pqh
decl_stmt|;
name|SPLUSBCHECK
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_remove_ls_ctrl: sqh=%p\n"
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
comment|/* See comment in uhci_remove_hs_ctrl() */
if|if
condition|(
operator|!
operator|(
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|&
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
operator|)
condition|)
block|{
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|UHCI_QH_REMOVE_DELAY
argument_list|)
expr_stmt|;
block|}
name|pqh
operator|=
name|uhci_find_prev_qh
argument_list|(
name|sc
operator|->
name|sc_lctl_start
argument_list|,
name|sqh
argument_list|)
expr_stmt|;
name|pqh
operator|->
name|hlink
operator|=
name|sqh
operator|->
name|hlink
expr_stmt|;
name|pqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|sqh
operator|->
name|qh
operator|.
name|qh_hlink
expr_stmt|;
name|delay
argument_list|(
name|UHCI_QH_REMOVE_DELAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_lctl_end
operator|==
name|sqh
condition|)
name|sc
operator|->
name|sc_lctl_end
operator|=
name|pqh
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add bulk QH, called at splusb(). */
end_comment

begin_function
name|void
name|uhci_add_bulk
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|uhci_soft_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|uhci_soft_qh_t
modifier|*
name|eqh
decl_stmt|;
name|SPLUSBCHECK
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_add_bulk: sqh=%p\n"
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
name|eqh
operator|=
name|sc
operator|->
name|sc_bulk_end
expr_stmt|;
name|sqh
operator|->
name|hlink
operator|=
name|eqh
operator|->
name|hlink
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|eqh
operator|->
name|qh
operator|.
name|qh_hlink
expr_stmt|;
name|eqh
operator|->
name|hlink
operator|=
name|sqh
expr_stmt|;
name|eqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|htole32
argument_list|(
name|sqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_QH
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bulk_end
operator|=
name|sqh
expr_stmt|;
name|uhci_add_loop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove bulk QH, called at splusb(). */
end_comment

begin_function
name|void
name|uhci_remove_bulk
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|uhci_soft_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|uhci_soft_qh_t
modifier|*
name|pqh
decl_stmt|;
name|SPLUSBCHECK
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_remove_bulk: sqh=%p\n"
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
name|uhci_rem_loop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See comment in uhci_remove_hs_ctrl() */
if|if
condition|(
operator|!
operator|(
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|&
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
operator|)
condition|)
block|{
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|UHCI_QH_REMOVE_DELAY
argument_list|)
expr_stmt|;
block|}
name|pqh
operator|=
name|uhci_find_prev_qh
argument_list|(
name|sc
operator|->
name|sc_bulk_start
argument_list|,
name|sqh
argument_list|)
expr_stmt|;
name|pqh
operator|->
name|hlink
operator|=
name|sqh
operator|->
name|hlink
expr_stmt|;
name|pqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|sqh
operator|->
name|qh
operator|.
name|qh_hlink
expr_stmt|;
name|delay
argument_list|(
name|UHCI_QH_REMOVE_DELAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bulk_end
operator|==
name|sqh
condition|)
name|sc
operator|->
name|sc_bulk_end
operator|=
name|pqh
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|uhci_intr1
parameter_list|(
name|uhci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|uhci_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"uhci_intr: real interrupt\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"uhci_intr: ignored interrupt while polling\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|uhci_intr1
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uhci_intr1
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|ack
decl_stmt|;
comment|/* 	 * It can happen that an interrupt will be delivered to 	 * us before the device has been fully attached and the 	 * softc struct has been configured. Usually this happens 	 * when kldloading the USB support as a module after the 	 * system has been booted. If we detect this condition, 	 * we need to squelch the unwanted interrupts until we're 	 * ready for them. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
operator|==
name|NULL
condition|)
block|{
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
comment|/* ack pending interrupts */
name|uhci_run
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* stop the controller */
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|15
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: uhci_intr1\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|uhci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|status
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
name|UHCI_STS_ALLINTRS
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
comment|/* The interrupt was not for us. */
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_suspend
operator|!=
name|PWR_RESUME
condition|)
name|printf
argument_list|(
literal|"uhci_intr: suspended sts=0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_suspend
operator|!=
name|PWR_RESUME
condition|)
block|{
name|printf
argument_list|(
literal|"%s: interrupt while not operating ignored\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* acknowledge the ints */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|UHCI_STS_USBINT
condition|)
name|ack
operator||=
name|UHCI_STS_USBINT
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|UHCI_STS_USBEI
condition|)
name|ack
operator||=
name|UHCI_STS_USBEI
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|UHCI_STS_RD
condition|)
block|{
name|ack
operator||=
name|UHCI_STS_RD
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|printf
argument_list|(
literal|"%s: resume detect\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_STS_HSE
condition|)
block|{
name|ack
operator||=
name|UHCI_STS_HSE
expr_stmt|;
name|printf
argument_list|(
literal|"%s: host system error\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_STS_HCPE
condition|)
block|{
name|ack
operator||=
name|UHCI_STS_HCPE
expr_stmt|;
name|printf
argument_list|(
literal|"%s: host controller process error\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_STS_HCH
condition|)
block|{
comment|/* no acknowledge needed */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_dying
condition|)
block|{
name|printf
argument_list|(
literal|"%s: host controller halted\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|uhci_dump_all
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ack
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nothing to acknowledge */
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|,
name|ack
argument_list|)
expr_stmt|;
comment|/* acknowledge the ints */
name|sc
operator|->
name|sc_bus
operator|.
name|no_intrs
operator|++
expr_stmt|;
name|usb_schedsoftintr
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"%s: uhci_intr: exit\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_softintr
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|,
modifier|*
name|nextii
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"%s: uhci_softintr (%d)\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|,
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|++
expr_stmt|;
comment|/* 	 * Interrupts on UHCI really suck.  When the host controller 	 * interrupts because a transfer is completed there is no 	 * way of knowing which transfer it was.  You can scan down 	 * the TDs and QHs of the previous frame to limit the search, 	 * but that assumes that the interrupt was not delayed by more 	 * than 1 ms, which may not always be true (e.g. after debug 	 * output on a slow console). 	 * We scan all interrupt descriptors to see if any have 	 * completed. 	 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|ii
argument_list|,
argument|&sc->sc_intrhead
argument_list|,
argument|list
argument_list|,
argument|nextii
argument_list|)
name|uhci_check_intr
argument_list|(
name|sc
argument_list|,
name|ii
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_USE_SOFTINTR
if|if
condition|(
name|sc
operator|->
name|sc_softwake
condition|)
block|{
name|sc
operator|->
name|sc_softwake
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_softwake
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USB_USE_SOFTINTR */
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check for an interrupt. */
end_comment

begin_function
name|void
name|uhci_check_intr
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|uhci_intr_info_t
modifier|*
name|ii
parameter_list|)
block|{
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|lstd
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"uhci_check_intr: ii=%p\n"
operator|,
name|ii
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ii
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_check_intr: no ii? %p\n"
argument_list|,
name|ii
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|ii
operator|->
name|xfer
operator|->
name|status
operator|==
name|USBD_CANCELLED
operator|||
name|ii
operator|->
name|xfer
operator|->
name|status
operator|==
name|USBD_TIMEOUT
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_check_intr: aborted xfer=%p\n"
operator|,
name|ii
operator|->
name|xfer
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ii
operator|->
name|stdstart
operator|==
name|NULL
condition|)
return|return;
name|lstd
operator|=
name|ii
operator|->
name|stdend
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|lstd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_check_intr: std==0\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * If the last TD is still active we need to check whether there 	 * is an error somewhere in the middle, or whether there was a 	 * short packet (SPD and not ACTIVE). 	 */
if|if
condition|(
name|le32toh
argument_list|(
name|lstd
operator|->
name|td
operator|.
name|td_status
argument_list|)
operator|&
name|UHCI_TD_ACTIVE
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|12
argument_list|,
operator|(
literal|"uhci_check_intr: active ii=%p\n"
operator|,
name|ii
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|std
operator|=
name|ii
operator|->
name|stdstart
init|;
name|std
operator|!=
name|lstd
condition|;
name|std
operator|=
name|std
operator|->
name|link
operator|.
name|std
control|)
block|{
name|status
operator|=
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_status
argument_list|)
expr_stmt|;
comment|/* If there's an active TD the xfer isn't done. */
if|if
condition|(
name|status
operator|&
name|UHCI_TD_ACTIVE
condition|)
break|break;
comment|/* Any kind of error makes the xfer done. */
if|if
condition|(
name|status
operator|&
name|UHCI_TD_STALLED
condition|)
goto|goto
name|done
goto|;
comment|/* We want short packets, and it is short: it's done */
if|if
condition|(
operator|(
name|status
operator|&
name|UHCI_TD_SPD
operator|)
operator|&&
name|UHCI_TD_GET_ACTLEN
argument_list|(
name|status
argument_list|)
operator|<
name|UHCI_TD_GET_MAXLEN
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_token
argument_list|)
argument_list|)
condition|)
goto|goto
name|done
goto|;
block|}
name|DPRINTFN
argument_list|(
literal|12
argument_list|,
operator|(
literal|"uhci_check_intr: ii=%p std=%p still active\n"
operator|,
name|ii
operator|,
name|ii
operator|->
name|stdstart
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|done
label|:
name|DPRINTFN
argument_list|(
literal|12
argument_list|,
operator|(
literal|"uhci_check_intr: ii=%p done\n"
operator|,
name|ii
operator|)
argument_list|)
expr_stmt|;
name|usb_uncallout
argument_list|(
name|ii
operator|->
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|uhci_timeout
argument_list|,
name|ii
argument_list|)
expr_stmt|;
name|usb_rem_task
argument_list|(
name|ii
operator|->
name|xfer
operator|->
name|pipe
operator|->
name|device
argument_list|,
operator|&
name|UXFER
argument_list|(
name|ii
operator|->
name|xfer
argument_list|)
operator|->
name|abort_task
argument_list|)
expr_stmt|;
name|uhci_idone
argument_list|(
name|ii
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at splusb() */
end_comment

begin_function
name|void
name|uhci_idone
parameter_list|(
name|uhci_intr_info_t
modifier|*
name|ii
parameter_list|)
block|{
name|usbd_xfer_handle
name|xfer
init|=
name|ii
operator|->
name|xfer
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|u_int32_t
name|status
init|=
literal|0
decl_stmt|,
name|nstatus
decl_stmt|;
name|int
name|actlen
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|12
argument_list|,
operator|(
literal|"uhci_idone: ii=%p\n"
operator|,
name|ii
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
if|if
condition|(
name|ii
operator|->
name|isdone
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|printf
argument_list|(
literal|"uhci_idone: ii is done!\n   "
argument_list|)
expr_stmt|;
name|uhci_dump_ii
argument_list|(
name|ii
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"uhci_idone: ii=%p is done!\n"
argument_list|,
name|ii
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|ii
operator|->
name|isdone
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|!=
literal|0
condition|)
block|{
comment|/* Isoc transfer, do things differently. */
name|uhci_soft_td_t
modifier|*
modifier|*
name|stds
init|=
name|upipe
operator|->
name|u
operator|.
name|iso
operator|.
name|stds
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|nframes
decl_stmt|,
name|len
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_idone: ii=%p isoc ready\n"
operator|,
name|ii
operator|)
argument_list|)
expr_stmt|;
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
name|actlen
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|curframe
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nframes
condition|;
name|i
operator|++
control|)
block|{
name|std
operator|=
name|stds
index|[
name|n
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|5
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"uhci_idone: isoc TD %d\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|uhci_dump_td
argument_list|(
name|std
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|++
name|n
operator|>=
name|UHCI_VFRAMELIST_COUNT
condition|)
name|n
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_status
argument_list|)
expr_stmt|;
name|len
operator|=
name|UHCI_TD_GET_ACTLEN
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|frlengths
index|[
name|i
index|]
operator|=
name|len
expr_stmt|;
name|actlen
operator|+=
name|len
expr_stmt|;
block|}
name|upipe
operator|->
name|u
operator|.
name|iso
operator|.
name|inuse
operator|-=
name|nframes
expr_stmt|;
name|xfer
operator|->
name|actlen
operator|=
name|actlen
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
goto|goto
name|end
goto|;
block|}
ifdef|#
directive|ifdef
name|USB_DEBUG
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_idone: ii=%p, xfer=%p, pipe=%p ready\n"
operator|,
name|ii
operator|,
name|xfer
operator|,
name|upipe
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
name|uhci_dump_tds
argument_list|(
name|ii
operator|->
name|stdstart
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The transfer is done, compute actual length and status. */
name|actlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|std
operator|=
name|ii
operator|->
name|stdstart
init|;
name|std
operator|!=
name|NULL
condition|;
name|std
operator|=
name|std
operator|->
name|link
operator|.
name|std
control|)
block|{
name|nstatus
operator|=
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstatus
operator|&
name|UHCI_TD_ACTIVE
condition|)
break|break;
name|status
operator|=
name|nstatus
expr_stmt|;
if|if
condition|(
name|UHCI_TD_GET_PID
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_token
argument_list|)
argument_list|)
operator|!=
name|UHCI_TD_PID_SETUP
condition|)
name|actlen
operator|+=
name|UHCI_TD_GET_ACTLEN
argument_list|(
name|status
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 			 * UHCI will report CRCTO in addition to a STALL or NAK 			 * for a SETUP transaction.  See section 3.2.2, "TD 			 * CONTROL AND STATUS". 			 */
if|if
condition|(
name|status
operator|&
operator|(
name|UHCI_TD_STALLED
operator||
name|UHCI_TD_NAK
operator|)
condition|)
name|status
operator|&=
operator|~
name|UHCI_TD_CRCTO
expr_stmt|;
block|}
block|}
comment|/* If there are left over TDs we need to update the toggle. */
if|if
condition|(
name|std
operator|!=
name|NULL
condition|)
name|upipe
operator|->
name|nexttoggle
operator|=
name|UHCI_TD_GET_DT
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_token
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|&=
name|UHCI_TD_ERROR
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_idone: actlen=%d, status=0x%x\n"
operator|,
name|actlen
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|actlen
operator|=
name|actlen
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|USB_DEBUG
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
name|bitmask_snprintf
argument_list|(
operator|(
name|u_int32_t
operator|)
name|status
argument_list|,
literal|"\20\22BITSTUFF\23CRCTO\24NAK\25"
literal|"BABBLE\26DBUFFER\27STALLED\30ACTIVE"
argument_list|,
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
operator|(
name|status
operator|==
name|UHCI_TD_STALLED
operator|)
operator|*
literal|10
argument_list|,
operator|(
literal|"uhci_idone: error, addr=%d, endpt=0x%02x, "
literal|"status 0x%s\n"
operator|,
name|xfer
operator|->
name|pipe
operator|->
name|device
operator|->
name|address
operator|,
name|xfer
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|,
name|sbuf
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
name|UHCI_TD_STALLED
condition|)
name|xfer
operator|->
name|status
operator|=
name|USBD_STALLED
expr_stmt|;
else|else
name|xfer
operator|->
name|status
operator|=
name|USBD_IOERROR
expr_stmt|;
comment|/* more info XXX */
block|}
else|else
block|{
name|xfer
operator|->
name|status
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
block|}
name|end
label|:
name|uhci_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|12
argument_list|,
operator|(
literal|"uhci_idone: ii=%p done\n"
operator|,
name|ii
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when a request does not complete.  */
end_comment

begin_function
name|void
name|uhci_timeout
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|uhci_intr_info_t
modifier|*
name|ii
init|=
name|addr
decl_stmt|;
name|struct
name|uhci_xfer
modifier|*
name|uxfer
init|=
name|UXFER
argument_list|(
name|ii
operator|->
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|uxfer
operator|->
name|xfer
operator|.
name|pipe
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_timeout: uxfer=%p\n"
operator|,
name|uxfer
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
block|{
name|uhci_abort_xfer
argument_list|(
operator|&
name|uxfer
operator|->
name|xfer
argument_list|,
name|USBD_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Execute the abort in a process context. */
name|usb_add_task
argument_list|(
name|uxfer
operator|->
name|xfer
operator|.
name|pipe
operator|->
name|device
argument_list|,
operator|&
name|uxfer
operator|->
name|abort_task
argument_list|,
name|USB_TASKQ_HC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_timeout_task
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|usbd_xfer_handle
name|xfer
init|=
name|addr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_timeout_task: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|uhci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_TIMEOUT
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait here until controller claims to have an interrupt.  * Then call uhci_intr and return.  Use timeout to avoid waiting  * too long.  * Only used during boot when interrupts are not enabled yet.  */
end_comment

begin_function
name|void
name|uhci_waitintr
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|int
name|timo
init|=
name|xfer
operator|->
name|timeout
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_waitintr: timeout = %dms\n"
operator|,
name|timo
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
for|for
control|(
init|;
name|timo
operator|>=
literal|0
condition|;
name|timo
operator|--
control|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"uhci_waitintr: 0x%04x\n"
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
name|UHCI_STS_ALLINTRS
condition|)
name|uhci_intr1
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|status
operator|!=
name|USBD_IN_PROGRESS
condition|)
return|return;
block|}
comment|/* Timeout */
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_waitintr: timeout\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|)
init|;
name|ii
operator|!=
name|NULL
operator|&&
name|ii
operator|->
name|xfer
operator|!=
name|xfer
condition|;
name|ii
operator|=
name|LIST_NEXT
argument_list|(
name|ii
argument_list|,
name|list
argument_list|)
control|)
empty_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ii
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"uhci_waitintr: lost intr_info"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uhci_idone
argument_list|(
name|ii
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_poll
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|bus
decl_stmt|;
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
name|UHCI_STS_ALLINTRS
condition|)
name|uhci_intr1
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_reset
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD_HCRESET
argument_list|)
expr_stmt|;
comment|/* The reset bit goes low when the controller is done. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|UHCI_RESET_TIMEOUT
operator|&&
operator|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD
argument_list|)
operator|&
name|UHCI_CMD_HCRESET
operator|)
condition|;
name|n
operator|++
control|)
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|UHCI_RESET_TIMEOUT
condition|)
name|printf
argument_list|(
literal|"%s: controller did not reset\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_run
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|run
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|n
decl_stmt|,
name|running
decl_stmt|;
name|u_int16_t
name|cmd
decl_stmt|;
name|run
operator|=
name|run
operator|!=
literal|0
expr_stmt|;
name|s
operator|=
name|splhardusb
argument_list|()
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_run: setting run=%d\n"
operator|,
name|run
operator|)
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
condition|)
name|cmd
operator||=
name|UHCI_CMD_RS
expr_stmt|;
else|else
name|cmd
operator|&=
operator|~
name|UHCI_CMD_RS
expr_stmt|;
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|10
condition|;
name|n
operator|++
control|)
block|{
name|running
operator|=
operator|!
operator|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
name|UHCI_STS_HCH
operator|)
expr_stmt|;
comment|/* return when we've entered the state we want */
if|if
condition|(
name|run
operator|==
name|running
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_run: done cmd=0x%x sts=0x%x\n"
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD
argument_list|)
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: cannot %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|,
name|run
condition|?
literal|"start"
else|:
literal|"stop"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Memory management routines.  *  uhci_alloc_std allocates TDs  *  uhci_alloc_sqh allocates QHs  * These two routines do their own free list management,  * partly for speed, partly because allocating DMAable memory  * has page size granularaity so much memory would be wasted if  * only one TD/QH (32 bytes) was placed in each allocated chunk.  */
end_comment

begin_function
name|uhci_soft_td_t
modifier|*
name|uhci_alloc_std
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offs
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_freetds
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_alloc_std: allocating chunk\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|UHCI_STD_SIZE
operator|*
name|UHCI_STD_CHUNK
argument_list|,
name|UHCI_TD_ALIGN
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_STD_CHUNK
condition|;
name|i
operator|++
control|)
block|{
name|offs
operator|=
name|i
operator|*
name|UHCI_STD_SIZE
expr_stmt|;
name|std
operator|=
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|std
operator|->
name|physaddr
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|std
operator|->
name|link
operator|.
name|std
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|std
operator|->
name|aux_dma
operator|.
name|block
operator|=
name|NULL
expr_stmt|;
name|std
operator|->
name|aux_data
operator|=
name|NULL
expr_stmt|;
name|std
operator|->
name|aux_len
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
expr_stmt|;
block|}
block|}
name|std
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
operator|->
name|link
operator|.
name|std
expr_stmt|;
name|memset
argument_list|(
operator|&
name|std
operator|->
name|td
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uhci_td_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|std
return|;
block|}
end_function

begin_function
name|void
name|uhci_free_std
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|uhci_soft_td_t
modifier|*
name|std
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
define|#
directive|define
name|TD_IS_FREE
value|0x12345678
if|if
condition|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_token
argument_list|)
operator|==
name|TD_IS_FREE
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_free_std: freeing free TD %p\n"
argument_list|,
name|std
argument_list|)
expr_stmt|;
return|return;
block|}
name|std
operator|->
name|td
operator|.
name|td_token
operator|=
name|htole32
argument_list|(
name|TD_IS_FREE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|std
operator|->
name|aux_dma
operator|.
name|block
operator|!=
name|NULL
condition|)
block|{
name|usb_freemem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
operator|&
name|std
operator|->
name|aux_dma
argument_list|)
expr_stmt|;
name|std
operator|->
name|aux_dma
operator|.
name|block
operator|=
name|NULL
expr_stmt|;
name|std
operator|->
name|aux_data
operator|=
name|NULL
expr_stmt|;
name|std
operator|->
name|aux_len
operator|=
literal|0
expr_stmt|;
block|}
name|std
operator|->
name|link
operator|.
name|std
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
expr_stmt|;
block|}
end_function

begin_function
name|uhci_soft_qh_t
modifier|*
name|uhci_alloc_sqh
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offs
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_freeqhs
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_alloc_sqh: allocating chunk\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|UHCI_SQH_SIZE
operator|*
name|UHCI_SQH_CHUNK
argument_list|,
name|UHCI_QH_ALIGN
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_SQH_CHUNK
condition|;
name|i
operator|++
control|)
block|{
name|offs
operator|=
name|i
operator|*
name|UHCI_SQH_SIZE
expr_stmt|;
name|sqh
operator|=
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|physaddr
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|hlink
operator|=
name|sc
operator|->
name|sc_freeqhs
expr_stmt|;
name|sc
operator|->
name|sc_freeqhs
operator|=
name|sqh
expr_stmt|;
block|}
block|}
name|sqh
operator|=
name|sc
operator|->
name|sc_freeqhs
expr_stmt|;
name|sc
operator|->
name|sc_freeqhs
operator|=
name|sqh
operator|->
name|hlink
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sqh
operator|->
name|qh
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uhci_qh_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sqh
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_free_sqh
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|uhci_soft_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|sqh
operator|->
name|hlink
operator|=
name|sc
operator|->
name|sc_freeqhs
expr_stmt|;
name|sc
operator|->
name|sc_freeqhs
operator|=
name|sqh
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_free_std_chain
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|uhci_soft_td_t
modifier|*
name|std
parameter_list|,
name|uhci_soft_td_t
modifier|*
name|stdend
parameter_list|)
block|{
name|uhci_soft_td_t
modifier|*
name|p
decl_stmt|;
for|for
control|(
init|;
name|std
operator|!=
name|stdend
condition|;
name|std
operator|=
name|p
control|)
block|{
name|p
operator|=
name|std
operator|->
name|link
operator|.
name|std
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|usbd_status
name|uhci_alloc_std_chain
parameter_list|(
name|struct
name|uhci_pipe
modifier|*
name|upipe
parameter_list|,
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|rd
parameter_list|,
name|u_int16_t
name|flags
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|uhci_soft_td_t
modifier|*
modifier|*
name|sp
parameter_list|,
name|uhci_soft_td_t
modifier|*
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|usb_dma_mapping
modifier|*
name|dma
init|=
operator|&
name|xfer
operator|->
name|dmamap
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|prevp
decl_stmt|,
modifier|*
name|startp
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|,
name|ntd
decl_stmt|,
name|l
decl_stmt|,
name|tog
decl_stmt|,
name|maxp
decl_stmt|,
name|seg
decl_stmt|,
name|segoff
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|int
name|addr
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|address
decl_stmt|;
name|int
name|endpt
init|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"uhci_alloc_std_chain: addr=%d endpt=%d len=%d speed=%d "
literal|"flags=0x%x\n"
operator|,
name|addr
operator|,
name|UE_GET_ADDR
argument_list|(
name|endpt
argument_list|)
operator|,
name|len
operator|,
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|speed
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|maxp
operator|=
name|UGETW
argument_list|(
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_alloc_std_chain: maxp=0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
name|ntd
operator|=
operator|(
name|len
operator|+
name|maxp
operator|-
literal|1
operator|)
operator|/
name|maxp
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|flags
operator||=
name|USBD_FORCE_SHORT_XFER
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|USBD_FORCE_SHORT_XFER
operator|)
operator|&&
name|len
operator|%
name|maxp
operator|==
literal|0
condition|)
name|ntd
operator|++
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_alloc_std_chain: maxp=%d ntd=%d\n"
operator|,
name|maxp
operator|,
name|ntd
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ntd
operator|>
literal|0
argument_list|,
operator|(
literal|"uhci_alloc_std_chain: ntd=0"
operator|)
argument_list|)
expr_stmt|;
name|tog
operator|=
name|upipe
operator|->
name|nexttoggle
expr_stmt|;
name|prevp
operator|=
name|NULL
expr_stmt|;
name|startp
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|UHCI_TD_ZERO_ACTLEN
argument_list|(
name|UHCI_TD_SET_ERRCNT
argument_list|(
literal|3
argument_list|)
operator||
name|UHCI_TD_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|)
name|status
operator||=
name|UHCI_TD_LS
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|USBD_SHORT_XFER_OK
condition|)
name|status
operator||=
name|UHCI_TD_SPD
expr_stmt|;
name|seg
operator|=
literal|0
expr_stmt|;
name|segoff
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntd
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|uhci_free_std_chain
argument_list|(
name|sc
argument_list|,
name|startp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
name|p
operator|->
name|link
operator|.
name|std
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prevp
operator|!=
name|NULL
condition|)
block|{
name|prevp
operator|->
name|link
operator|.
name|std
operator|=
name|p
expr_stmt|;
name|prevp
operator|->
name|td
operator|.
name|td_link
operator|=
name|htole32
argument_list|(
name|p
operator|->
name|physaddr
operator||
name|UHCI_PTR_VF
operator||
name|UHCI_PTR_TD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|startp
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|->
name|td
operator|.
name|td_status
operator|=
name|htole32
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ntd
operator|-
literal|1
condition|)
block|{
comment|/* last TD */
name|l
operator|=
name|len
operator|%
name|maxp
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
operator|&&
operator|!
operator|(
name|flags
operator|&
name|USBD_FORCE_SHORT_XFER
operator|)
condition|)
name|l
operator|=
name|maxp
expr_stmt|;
operator|*
name|ep
operator|=
name|p
expr_stmt|;
block|}
else|else
name|l
operator|=
name|maxp
expr_stmt|;
name|p
operator|->
name|td
operator|.
name|td_token
operator|=
name|htole32
argument_list|(
name|rd
condition|?
name|UHCI_TD_IN
argument_list|(
name|l
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
name|tog
argument_list|)
else|:
name|UHCI_TD_OUT
argument_list|(
name|l
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
name|tog
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|seg
operator|<
name|dma
operator|->
name|nsegs
operator|||
name|l
operator|==
literal|0
argument_list|,
operator|(
literal|"uhci_alloc_std_chain: too few segments"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|td
operator|.
name|td_buffer
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|>
name|dma
operator|->
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
operator|-
name|segoff
condition|)
block|{
comment|/* UHCI can't handle non-contiguous data. */
name|err
operator|=
name|uhci_aux_dma_alloc
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|xfer
operator|->
name|buffer
operator|+
name|i
operator|*
name|maxp
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|uhci_free_std_chain
argument_list|(
name|sc
argument_list|,
name|startp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|p
operator|->
name|td
operator|.
name|td_buffer
operator|=
name|htole32
argument_list|(
name|uhci_aux_dma_prepare
argument_list|(
name|p
argument_list|,
name|rd
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|-=
name|dma
operator|->
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
operator|-
name|segoff
expr_stmt|;
name|seg
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|seg
operator|<
name|dma
operator|->
name|nsegs
argument_list|,
operator|(
literal|"uhci_alloc_std_chain: too few segments 2"
operator|)
argument_list|)
expr_stmt|;
name|segoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|td
operator|.
name|td_buffer
operator|=
name|htole32
argument_list|(
name|dma
operator|->
name|segs
index|[
name|seg
index|]
operator|.
name|ds_addr
operator|+
name|segoff
argument_list|)
expr_stmt|;
block|}
name|segoff
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
operator|&&
name|segoff
operator|>=
name|dma
operator|->
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
condition|)
block|{
name|KASSERT
argument_list|(
name|segoff
operator|==
name|dma
operator|->
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
argument_list|,
operator|(
literal|"uhci_alloc_std_chain: overlap"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|*
name|maxp
operator|+
name|l
operator|!=
name|len
condition|)
block|{
name|seg
operator|++
expr_stmt|;
name|segoff
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|prevp
operator|=
name|p
expr_stmt|;
name|tog
operator|^=
literal|1
expr_stmt|;
block|}
name|prevp
operator|->
name|td
operator|.
name|td_link
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
operator||
name|UHCI_PTR_VF
operator||
name|UHCI_PTR_TD
argument_list|)
expr_stmt|;
name|upipe
operator|->
name|nexttoggle
operator|=
name|tog
expr_stmt|;
operator|*
name|sp
operator|=
name|startp
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_alloc_std_chain: nexttog=%d\n"
operator|,
name|upipe
operator|->
name|nexttoggle
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a physically contiguous buffer to handle cases where UHCI  * cannot handle a packet because it is not physically contiguous.  * If the usb_dma_t was already allocated this just ensures it is  * large enough for the specified size.  */
end_comment

begin_function
specifier|static
name|usbd_status
name|uhci_aux_dma_alloc
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|uhci_soft_td_t
modifier|*
name|std
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|align
decl_stmt|;
if|if
condition|(
name|std
operator|->
name|aux_dma
operator|.
name|block
operator|==
name|NULL
operator|||
name|std
operator|->
name|aux_dma
operator|.
name|block
operator|->
name|size
operator|<
name|len
condition|)
block|{
comment|/* Align to avoid crossing a page boundary. */
if|if
condition|(
name|powerof2
argument_list|(
name|len
argument_list|)
condition|)
name|align
operator|=
name|len
expr_stmt|;
else|else
name|align
operator|=
literal|1
operator|<<
name|fls
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|->
name|aux_dma
operator|.
name|block
operator|!=
name|NULL
condition|)
name|usb_freemem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
operator|&
name|std
operator|->
name|aux_dma
argument_list|)
expr_stmt|;
name|std
operator|->
name|aux_dma
operator|.
name|block
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|len
argument_list|,
name|align
argument_list|,
operator|&
name|std
operator|->
name|aux_dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
name|std
operator|->
name|aux_data
operator|=
name|data
expr_stmt|;
name|std
operator|->
name|aux_len
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uhci_physaddr_t
name|uhci_aux_dma_prepare
parameter_list|(
name|uhci_soft_td_t
modifier|*
name|std
parameter_list|,
name|int
name|isread
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isread
condition|)
block|{
name|bcopy
argument_list|(
name|std
operator|->
name|aux_data
argument_list|,
name|KERNADDR
argument_list|(
operator|&
name|std
operator|->
name|aux_dma
argument_list|,
literal|0
argument_list|)
argument_list|,
name|std
operator|->
name|aux_len
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|std
operator|->
name|aux_dma
operator|.
name|block
operator|->
name|tag
argument_list|,
name|std
operator|->
name|aux_dma
operator|.
name|block
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|DMAADDR
argument_list|(
operator|&
name|std
operator|->
name|aux_dma
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_aux_dma_complete
parameter_list|(
name|uhci_soft_td_t
modifier|*
name|std
parameter_list|,
name|int
name|isread
parameter_list|)
block|{
if|if
condition|(
name|isread
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|std
operator|->
name|aux_dma
operator|.
name|block
operator|->
name|tag
argument_list|,
name|std
operator|->
name|aux_dma
operator|.
name|block
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|KERNADDR
argument_list|(
operator|&
name|std
operator|->
name|aux_dma
argument_list|,
literal|0
argument_list|)
argument_list|,
name|std
operator|->
name|aux_data
argument_list|,
name|std
operator|->
name|aux_len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|uhci_device_clear_toggle
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|upipe
operator|->
name|nexttoggle
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_noop
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{ }
end_function

begin_function
name|usbd_status
name|uhci_device_bulk_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Pipe isn't running (otherwise err would be USBD_INPROG), 	 * so start it first. 	 */
return|return
operator|(
name|uhci_device_bulk_start
argument_list|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_bulk_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
init|=
operator|&
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|iinfo
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|dataend
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|len
decl_stmt|,
name|isread
decl_stmt|,
name|endpt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_device_bulk_start: xfer=%p len=%d flags=%d ii=%p\n"
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|length
operator|,
name|xfer
operator|->
name|flags
operator|,
name|ii
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
condition|)
name|panic
argument_list|(
literal|"uhci_device_bulk_transfer: a request"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|xfer
operator|->
name|length
expr_stmt|;
name|endpt
operator|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
name|isread
operator|=
name|UE_GET_DIR
argument_list|(
name|endpt
argument_list|)
operator|==
name|UE_DIR_IN
expr_stmt|;
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|isread
operator|=
name|isread
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|err
operator|=
name|uhci_alloc_std_chain
argument_list|(
name|upipe
argument_list|,
name|sc
argument_list|,
name|len
argument_list|,
name|isread
argument_list|,
name|xfer
operator|->
name|flags
argument_list|,
name|xfer
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|dataend
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dataend
operator|->
name|td
operator|.
name|td_status
operator||=
name|htole32
argument_list|(
name|UHCI_TD_IOC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|8
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_device_bulk_transfer: data(1)\n"
operator|)
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Set up interrupt info. */
name|ii
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
name|data
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|dataend
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|ii
operator|->
name|isdone
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_device_bulk_transfer: not done, ii=%p\n"
argument_list|,
name|ii
argument_list|)
expr_stmt|;
block|}
name|ii
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|sqh
operator|->
name|elink
operator|=
name|data
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|data
operator|->
name|physaddr
operator||
name|UHCI_PTR_TD
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|uhci_add_bulk
argument_list|(
name|sc
argument_list|,
name|sqh
argument_list|)
expr_stmt|;
name|uhci_add_intr_info
argument_list|(
name|sc
argument_list|,
name|ii
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|&&
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|usb_callout
argument_list|(
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|MS_TO_TICKS
argument_list|(
name|xfer
operator|->
name|timeout
argument_list|)
argument_list|,
name|uhci_timeout
argument_list|,
name|ii
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_device_bulk_transfer: data(2)\n"
operator|)
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
name|uhci_waitintr
argument_list|(
name|sc
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a device bulk request. */
end_comment

begin_function
name|void
name|uhci_device_bulk_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_device_bulk_abort:\n"
operator|)
argument_list|)
expr_stmt|;
name|uhci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Abort a device request.  * If this routine is called at splusb() it guarantees that the request  * will be removed from the hardware scheduling and that the callback  * for it will be called with USBD_CANCELLED status.  * It's impossible to guarantee that the requested transfer will not  * have happened since the hardware runs concurrently.  * If the transaction has already happened we rely on the ordinary  * interrupt processing to process it.  */
end_comment

begin_function
name|void
name|uhci_abort_xfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_status
name|status
parameter_list|)
block|{
name|struct
name|uhci_xfer
modifier|*
name|uxfer
init|=
name|UXFER
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
init|=
operator|&
name|uxfer
operator|->
name|iinfo
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_abort_xfer: xfer=%p, status=%d\n"
operator|,
name|xfer
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
block|{
comment|/* If we're dying, just do the software part. */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|status
expr_stmt|;
comment|/* make software ignore it */
name|usb_uncallout
argument_list|(
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|uhci_timeout
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|usb_rem_task
argument_list|(
name|xfer
operator|->
name|pipe
operator|->
name|device
argument_list|,
operator|&
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|abort_task
argument_list|)
expr_stmt|;
name|uhci_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xfer
operator|->
name|device
operator|->
name|bus
operator|->
name|intr_context
operator|||
operator|!
name|curproc
condition|)
name|panic
argument_list|(
literal|"uhci_abort_xfer: not in process context"
argument_list|)
expr_stmt|;
comment|/* 	 * If an abort is already in progress then just wait for it to 	 * complete and return. 	 */
if|if
condition|(
name|uxfer
operator|->
name|uhci_xfer_flags
operator|&
name|UHCI_XFER_ABORTING
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_abort_xfer: already aborting\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* No need to wait if we're aborting from a timeout. */
if|if
condition|(
name|status
operator|==
name|USBD_TIMEOUT
condition|)
return|return;
comment|/* Override the status which might be USBD_TIMEOUT. */
name|xfer
operator|->
name|status
operator|=
name|status
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_abort_xfer: waiting for abort to finish\n"
operator|)
argument_list|)
expr_stmt|;
name|uxfer
operator|->
name|uhci_xfer_flags
operator||=
name|UHCI_XFER_ABORTWAIT
expr_stmt|;
while|while
condition|(
name|uxfer
operator|->
name|uhci_xfer_flags
operator|&
name|UHCI_XFER_ABORTING
condition|)
name|tsleep
argument_list|(
operator|&
name|uxfer
operator|->
name|uhci_xfer_flags
argument_list|,
name|PZERO
argument_list|,
literal|"uhciaw"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Step 1: Make interrupt routine and hardware ignore xfer. 	 */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|uxfer
operator|->
name|uhci_xfer_flags
operator||=
name|UHCI_XFER_ABORTING
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|status
expr_stmt|;
comment|/* make software ignore it */
name|usb_uncallout
argument_list|(
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|uhci_timeout
argument_list|,
name|ii
argument_list|)
expr_stmt|;
name|usb_rem_task
argument_list|(
name|xfer
operator|->
name|pipe
operator|->
name|device
argument_list|,
operator|&
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|abort_task
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_abort_xfer: stop ii=%p\n"
operator|,
name|ii
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|std
operator|=
name|ii
operator|->
name|stdstart
init|;
name|std
operator|!=
name|NULL
condition|;
name|std
operator|=
name|std
operator|->
name|link
operator|.
name|std
control|)
name|std
operator|->
name|td
operator|.
name|td_status
operator|&=
name|htole32
argument_list|(
operator|~
operator|(
name|UHCI_TD_ACTIVE
operator||
name|UHCI_TD_IOC
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Step 2: Wait until we know hardware has finished any possible 	 * use of the xfer.  Also make sure the soft interrupt routine 	 * has run. 	 */
name|usb_delay_ms
argument_list|(
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Hardware finishes in 1ms */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_USE_SOFTINTR
name|sc
operator|->
name|sc_softwake
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* USB_USE_SOFTINTR */
name|usb_schedsoftintr
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_USE_SOFTINTR
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_abort_xfer: tsleep\n"
operator|)
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_softwake
argument_list|,
name|PZERO
argument_list|,
literal|"uhciab"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USB_USE_SOFTINTR */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Step 3: Execute callback. 	 */
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_abort_xfer: callback\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|ii
operator|->
name|isdone
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Do the wakeup first to avoid touching the xfer after the callback. */
name|uxfer
operator|->
name|uhci_xfer_flags
operator|&=
operator|~
name|UHCI_XFER_ABORTING
expr_stmt|;
if|if
condition|(
name|uxfer
operator|->
name|uhci_xfer_flags
operator|&
name|UHCI_XFER_ABORTWAIT
condition|)
block|{
name|uxfer
operator|->
name|uhci_xfer_flags
operator|&=
operator|~
name|UHCI_XFER_ABORTWAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|uxfer
operator|->
name|uhci_xfer_flags
argument_list|)
expr_stmt|;
block|}
name|uhci_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform any UHCI-specific transfer completion operations, then  * call usb_transfer_complete().  */
end_comment

begin_function
specifier|static
name|void
name|uhci_transfer_complete
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|uhci_intr_info_t
modifier|*
name|ii
init|=
operator|&
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|iinfo
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|isread
decl_stmt|,
name|n
decl_stmt|;
comment|/* XXX, must be an easier way to detect reads... */
name|isread
operator|=
operator|(
operator|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
operator|)
operator|&&
operator|(
name|xfer
operator|->
name|request
operator|.
name|bmRequestType
operator|&
name|UT_READ
operator|)
operator|)
operator|||
operator|(
name|xfer
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|UE_DIR_IN
operator|)
expr_stmt|;
comment|/* Copy back from any auxillary buffers after a read operation. */
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|ii
operator|->
name|stdstart
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|link
operator|.
name|std
control|)
block|{
if|if
condition|(
name|p
operator|->
name|aux_data
operator|!=
name|NULL
condition|)
name|uhci_aux_dma_complete
argument_list|(
name|p
argument_list|,
name|isread
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|!=
literal|0
condition|)
block|{
comment|/* Isoc transfer, do things differently. */
name|n
operator|=
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|curframe
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xfer
operator|->
name|nframes
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|upipe
operator|->
name|u
operator|.
name|iso
operator|.
name|stds
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|aux_data
operator|!=
name|NULL
condition|)
name|uhci_aux_dma_complete
argument_list|(
name|p
argument_list|,
name|isread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|n
operator|>=
name|UHCI_VFRAMELIST_COUNT
condition|)
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close a device bulk pipe. */
end_comment

begin_function
name|void
name|uhci_device_bulk_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
argument_list|)
expr_stmt|;
name|pipe
operator|->
name|endpoint
operator|->
name|savedtoggle
operator|=
name|upipe
operator|->
name|nexttoggle
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Pipe isn't running (otherwise err would be USBD_INPROG), 	 * so start it first. 	 */
return|return
operator|(
name|uhci_device_ctrl_start
argument_list|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_ctrl_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|xfer
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
operator|)
condition|)
name|panic
argument_list|(
literal|"uhci_device_ctrl_transfer: not a request"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|uhci_device_request
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
name|uhci_waitintr
argument_list|(
name|sc
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_intr_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Pipe isn't running (otherwise err would be USBD_INPROG), 	 * so start it first. 	 */
return|return
operator|(
name|uhci_device_intr_start
argument_list|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_intr_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
init|=
operator|&
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|iinfo
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|dataend
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|isread
decl_stmt|,
name|endpt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_device_intr_transfer: xfer=%p len=%d flags=%d\n"
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|length
operator|,
name|xfer
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
condition|)
name|panic
argument_list|(
literal|"uhci_device_intr_transfer: a request"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|endpt
operator|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
name|isread
operator|=
name|UE_GET_DIR
argument_list|(
name|endpt
argument_list|)
operator|==
name|UE_DIR_IN
expr_stmt|;
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|isread
operator|=
name|isread
expr_stmt|;
name|err
operator|=
name|uhci_alloc_std_chain
argument_list|(
name|upipe
argument_list|,
name|sc
argument_list|,
name|xfer
operator|->
name|length
argument_list|,
name|isread
argument_list|,
name|xfer
operator|->
name|flags
argument_list|,
name|xfer
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|dataend
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dataend
operator|->
name|td
operator|.
name|td_status
operator||=
name|htole32
argument_list|(
name|UHCI_TD_IOC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_device_intr_transfer: data(1)\n"
operator|)
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
comment|/* Set up interrupt info. */
name|ii
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
name|data
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|dataend
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|ii
operator|->
name|isdone
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_device_intr_transfer: not done, ii=%p\n"
argument_list|,
name|ii
argument_list|)
expr_stmt|;
block|}
name|ii
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_device_intr_transfer: qhs[0]=%p\n"
operator|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|npoll
condition|;
name|i
operator|++
control|)
block|{
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
expr_stmt|;
name|sqh
operator|->
name|elink
operator|=
name|data
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|data
operator|->
name|physaddr
operator||
name|UHCI_PTR_TD
argument_list|)
expr_stmt|;
block|}
name|uhci_add_intr_info
argument_list|(
name|sc
argument_list|,
name|ii
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_device_intr_transfer: data(2)\n"
operator|)
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a device control request. */
end_comment

begin_function
name|void
name|uhci_device_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_device_ctrl_abort:\n"
operator|)
argument_list|)
expr_stmt|;
name|uhci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close a device control pipe. */
end_comment

begin_function
name|void
name|uhci_device_ctrl_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Abort a device interrupt request. */
end_comment

begin_function
name|void
name|uhci_device_intr_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_device_intr_abort: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|==
name|xfer
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_device_intr_abort: remove\n"
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|=
name|NULL
expr_stmt|;
block|}
name|uhci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close a device interrupt pipe. */
end_comment

begin_function
name|void
name|uhci_device_intr_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|int
name|i
decl_stmt|,
name|npoll
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Unlink descriptors from controller data structures. */
name|npoll
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|npoll
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
name|uhci_remove_intr
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * We now have to wait for any activity on the physical 	 * descriptors to stop. 	 */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
argument_list|,
name|M_USBHC
argument_list|)
expr_stmt|;
comment|/* XXX free other resources */
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_request
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usb_device_request_t
modifier|*
name|req
init|=
operator|&
name|xfer
operator|->
name|request
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|int
name|addr
init|=
name|dev
operator|->
name|address
decl_stmt|;
name|int
name|endpt
init|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
init|=
operator|&
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|iinfo
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|setup
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|stat
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|dataend
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_int32_t
name|ls
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|isread
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_device_control type=0x%02x, request=0x%02x, "
literal|"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\n"
operator|,
name|req
operator|->
name|bmRequestType
operator|,
name|req
operator|->
name|bRequest
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
operator|,
name|addr
operator|,
name|endpt
operator|)
argument_list|)
expr_stmt|;
name|ls
operator|=
name|dev
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|?
name|UHCI_TD_LS
else|:
literal|0
expr_stmt|;
name|isread
operator|=
name|req
operator|->
name|bmRequestType
operator|&
name|UT_READ
expr_stmt|;
name|len
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
expr_stmt|;
name|setup
operator|=
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
expr_stmt|;
name|stat
operator|=
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|stat
expr_stmt|;
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
expr_stmt|;
comment|/* Set up data transaction */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|upipe
operator|->
name|nexttoggle
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|uhci_alloc_std_chain
argument_list|(
name|upipe
argument_list|,
name|sc
argument_list|,
name|len
argument_list|,
name|isread
argument_list|,
name|xfer
operator|->
name|flags
argument_list|,
name|xfer
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|dataend
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|next
operator|=
name|data
expr_stmt|;
name|dataend
operator|->
name|link
operator|.
name|std
operator|=
name|stat
expr_stmt|;
name|dataend
operator|->
name|td
operator|.
name|td_link
operator|=
name|htole32
argument_list|(
name|stat
operator|->
name|physaddr
operator||
name|UHCI_PTR_VF
operator||
name|UHCI_PTR_TD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|stat
expr_stmt|;
block|}
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|KERNADDR
argument_list|(
operator|&
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|,
literal|0
argument_list|)
argument_list|,
name|req
argument_list|,
sizeof|sizeof
expr|*
name|req
argument_list|)
expr_stmt|;
name|setup
operator|->
name|link
operator|.
name|std
operator|=
name|next
expr_stmt|;
name|setup
operator|->
name|td
operator|.
name|td_link
operator|=
name|htole32
argument_list|(
name|next
operator|->
name|physaddr
operator||
name|UHCI_PTR_VF
operator||
name|UHCI_PTR_TD
argument_list|)
expr_stmt|;
name|setup
operator|->
name|td
operator|.
name|td_status
operator|=
name|htole32
argument_list|(
name|UHCI_TD_SET_ERRCNT
argument_list|(
literal|3
argument_list|)
operator||
name|ls
operator||
name|UHCI_TD_ACTIVE
argument_list|)
expr_stmt|;
name|setup
operator|->
name|td
operator|.
name|td_token
operator|=
name|htole32
argument_list|(
name|UHCI_TD_SETUP
argument_list|(
sizeof|sizeof
expr|*
name|req
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|setup
operator|->
name|td
operator|.
name|td_buffer
operator|=
name|htole32
argument_list|(
name|DMAADDR
argument_list|(
operator|&
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|stat
operator|->
name|link
operator|.
name|std
operator|=
name|NULL
expr_stmt|;
name|stat
operator|->
name|td
operator|.
name|td_link
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|stat
operator|->
name|td
operator|.
name|td_status
operator|=
name|htole32
argument_list|(
name|UHCI_TD_SET_ERRCNT
argument_list|(
literal|3
argument_list|)
operator||
name|ls
operator||
name|UHCI_TD_ACTIVE
operator||
name|UHCI_TD_IOC
argument_list|)
expr_stmt|;
name|stat
operator|->
name|td
operator|.
name|td_token
operator|=
name|htole32
argument_list|(
name|isread
condition|?
name|UHCI_TD_OUT
argument_list|(
literal|0
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
else|:
name|UHCI_TD_IN
argument_list|(
literal|0
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|stat
operator|->
name|td
operator|.
name|td_buffer
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_device_request: before transfer\n"
operator|)
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|setup
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Set up interrupt info. */
name|ii
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
name|setup
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|stat
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|ii
operator|->
name|isdone
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_device_request: not done, ii=%p\n"
argument_list|,
name|ii
argument_list|)
expr_stmt|;
block|}
name|ii
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|sqh
operator|->
name|elink
operator|=
name|setup
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|setup
operator|->
name|physaddr
operator||
name|UHCI_PTR_TD
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|)
name|uhci_add_ls_ctrl
argument_list|(
name|sc
argument_list|,
name|sqh
argument_list|)
expr_stmt|;
else|else
name|uhci_add_hs_ctrl
argument_list|(
name|sc
argument_list|,
name|sqh
argument_list|)
expr_stmt|;
name|uhci_add_intr_info
argument_list|(
name|sc
argument_list|,
name|ii
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|12
condition|)
block|{
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|xqh
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sxqh
decl_stmt|;
name|int
name|maxqh
init|=
literal|0
decl_stmt|;
name|uhci_physaddr_t
name|link
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_enter_ctl_q: follow from [0]\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|std
operator|=
name|sc
operator|->
name|sc_vframes
index|[
literal|0
index|]
operator|.
name|htd
operator|,
name|link
operator|=
literal|0
init|;
operator|(
name|link
operator|&
name|UHCI_PTR_QH
operator|)
operator|==
literal|0
condition|;
name|std
operator|=
name|std
operator|->
name|link
operator|.
name|std
control|)
block|{
name|link
operator|=
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_link
argument_list|)
expr_stmt|;
name|uhci_dump_td
argument_list|(
name|std
argument_list|)
expr_stmt|;
block|}
name|sxqh
operator|=
operator|(
name|uhci_soft_qh_t
operator|*
operator|)
name|std
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|sxqh
argument_list|)
expr_stmt|;
for|for
control|(
name|xqh
operator|=
name|sxqh
init|;
name|xqh
operator|!=
name|NULL
condition|;
name|xqh
operator|=
operator|(
name|maxqh
operator|++
operator|==
literal|5
operator|||
name|xqh
operator|->
name|hlink
operator|==
name|sxqh
operator|||
name|xqh
operator|->
name|hlink
operator|==
name|xqh
condition|?
name|NULL
else|:
name|xqh
operator|->
name|hlink
operator|)
control|)
block|{
name|uhci_dump_qh
argument_list|(
name|xqh
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"Enqueued QH:\n"
operator|)
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|sqh
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|sqh
operator|->
name|elink
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|&&
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|usb_callout
argument_list|(
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|MS_TO_TICKS
argument_list|(
name|xfer
operator|->
name|timeout
argument_list|)
argument_list|,
name|uhci_timeout
argument_list|,
name|ii
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_isoc_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_device_isoc_transfer: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
comment|/* Put it on our queue, */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* bail out on error, */
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
name|USBD_IN_PROGRESS
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* XXX should check inuse here */
comment|/* insert into schedule, */
name|uhci_device_isoc_enter
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* and start if the pipe wasn't running */
if|if
condition|(
operator|!
name|err
condition|)
name|uhci_device_isoc_start
argument_list|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_device_isoc_enter
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|struct
name|iso
modifier|*
name|iso
init|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|iso
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|void
modifier|*
name|dataptr
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|,
name|status
decl_stmt|;
name|int
name|err
decl_stmt|,
name|s
decl_stmt|,
name|i
decl_stmt|,
name|isread
decl_stmt|,
name|next
decl_stmt|,
name|nframes
decl_stmt|,
name|seg
decl_stmt|,
name|segoff
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_device_isoc_enter: used=%d next=%d xfer=%p "
literal|"nframes=%d\n"
operator|,
name|iso
operator|->
name|inuse
operator|,
name|iso
operator|->
name|next
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|nframes
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return;
if|if
condition|(
name|xfer
operator|->
name|status
operator|==
name|USBD_IN_PROGRESS
condition|)
block|{
comment|/* This request has already been entered into the frame list */
name|printf
argument_list|(
literal|"uhci_device_isoc_enter: xfer=%p in frame list\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|iso
operator|->
name|inuse
operator|>=
name|UHCI_VFRAMELIST_COUNT
condition|)
name|printf
argument_list|(
literal|"uhci_device_isoc_enter: overflow!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|next
operator|=
name|iso
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Not in use yet, schedule it a few frames ahead. */
name|next
operator|=
operator|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_FRNUM
argument_list|)
operator|+
literal|3
operator|)
operator|%
name|UHCI_VFRAMELIST_COUNT
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_device_isoc_enter: start next=%d\n"
operator|,
name|next
operator|)
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|curframe
operator|=
name|next
expr_stmt|;
name|seg
operator|=
literal|0
expr_stmt|;
name|segoff
operator|=
literal|0
expr_stmt|;
name|dataptr
operator|=
name|xfer
operator|->
name|allocbuf
expr_stmt|;
comment|/* Normal buffers not possible for isoc? */
name|isread
operator|=
name|xfer
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|UE_DIR_IN
expr_stmt|;
name|status
operator|=
name|UHCI_TD_ZERO_ACTLEN
argument_list|(
name|UHCI_TD_SET_ERRCNT
argument_list|(
literal|0
argument_list|)
operator||
name|UHCI_TD_ACTIVE
operator||
name|UHCI_TD_IOS
argument_list|)
expr_stmt|;
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nframes
condition|;
name|i
operator|++
control|)
block|{
name|std
operator|=
name|iso
operator|->
name|stds
index|[
name|next
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|next
operator|>=
name|UHCI_VFRAMELIST_COUNT
condition|)
name|next
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|xfer
operator|->
name|frlengths
index|[
name|i
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|seg
operator|<
name|xfer
operator|->
name|dmamap
operator|.
name|nsegs
argument_list|,
operator|(
literal|"uhci_device_isoc_enter: too few segments"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|segoff
operator|>
name|xfer
operator|->
name|dmamap
operator|.
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
condition|)
block|{
comment|/* UHCI can't handle non-contiguous data. */
name|err
operator|=
name|uhci_aux_dma_alloc
argument_list|(
name|sc
argument_list|,
name|std
argument_list|,
name|dataptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|err
condition|)
name|printf
argument_list|(
literal|"uhci_device_isoc_enter: aux alloc\n"
argument_list|)
expr_stmt|;
name|std
operator|->
name|td
operator|.
name|td_buffer
operator|=
name|htole32
argument_list|(
name|uhci_aux_dma_prepare
argument_list|(
name|std
argument_list|,
name|isread
argument_list|)
argument_list|)
expr_stmt|;
name|segoff
operator|+=
name|len
expr_stmt|;
while|while
condition|(
name|segoff
operator|>=
name|xfer
operator|->
name|dmamap
operator|.
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
condition|)
block|{
name|KASSERT
argument_list|(
name|seg
operator|<
name|xfer
operator|->
name|dmamap
operator|.
name|nsegs
operator|-
literal|1
operator|||
name|segoff
operator|==
name|xfer
operator|->
name|dmamap
operator|.
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
argument_list|,
operator|(
literal|"uhci_device_isoc_enter: overlap2"
operator|)
argument_list|)
expr_stmt|;
name|segoff
operator|-=
name|xfer
operator|->
name|dmamap
operator|.
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|std
operator|->
name|td
operator|.
name|td_buffer
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|dmamap
operator|.
name|segs
index|[
name|seg
index|]
operator|.
name|ds_addr
operator|+
name|segoff
argument_list|)
expr_stmt|;
name|segoff
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|segoff
operator|>=
name|xfer
operator|->
name|dmamap
operator|.
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
condition|)
block|{
name|KASSERT
argument_list|(
name|segoff
operator|==
name|xfer
operator|->
name|dmamap
operator|.
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
argument_list|,
operator|(
literal|"uhci_device_isoc_enter: overlap"
operator|)
argument_list|)
expr_stmt|;
name|segoff
operator|=
literal|0
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|nframes
operator|-
literal|1
condition|)
name|status
operator||=
name|UHCI_TD_IOC
expr_stmt|;
name|std
operator|->
name|td
operator|.
name|td_status
operator|=
name|htole32
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|std
operator|->
name|td
operator|.
name|td_token
operator|&=
name|htole32
argument_list|(
operator|~
name|UHCI_TD_MAXLEN_MASK
argument_list|)
expr_stmt|;
name|std
operator|->
name|td
operator|.
name|td_token
operator||=
name|htole32
argument_list|(
name|UHCI_TD_SET_MAXLEN
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|5
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_device_isoc_enter: TD %d\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|uhci_dump_td
argument_list|(
name|std
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dataptr
operator|=
operator|(
name|char
operator|*
operator|)
name|dataptr
operator|+
name|len
expr_stmt|;
block|}
name|iso
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|iso
operator|->
name|inuse
operator|+=
name|xfer
operator|->
name|nframes
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_isoc_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
init|=
operator|&
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|iinfo
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|end
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_device_isoc_start: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|status
operator|!=
name|USBD_IN_PROGRESS
condition|)
name|printf
argument_list|(
literal|"uhci_device_isoc_start: not in progress %p\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Find the last TD */
name|i
operator|=
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|curframe
operator|+
name|xfer
operator|->
name|nframes
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|UHCI_VFRAMELIST_COUNT
condition|)
name|i
operator|-=
name|UHCI_VFRAMELIST_COUNT
expr_stmt|;
name|end
operator|=
name|upipe
operator|->
name|u
operator|.
name|iso
operator|.
name|stds
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_device_isoc_start: end == NULL\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
endif|#
directive|endif
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
comment|/* Set up interrupt info. */
name|ii
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
name|end
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|end
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|ii
operator|->
name|isdone
condition|)
name|printf
argument_list|(
literal|"uhci_device_isoc_start: not done, ii=%p\n"
argument_list|,
name|ii
argument_list|)
expr_stmt|;
name|ii
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|uhci_add_intr_info
argument_list|(
name|sc
argument_list|,
name|ii
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_device_isoc_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|uhci_soft_td_t
modifier|*
modifier|*
name|stds
init|=
name|upipe
operator|->
name|u
operator|.
name|iso
operator|.
name|stds
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|s
decl_stmt|,
name|nframes
decl_stmt|,
name|maxlen
decl_stmt|,
name|len
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
comment|/* Transfer is already done. */
if|if
condition|(
name|xfer
operator|->
name|status
operator|!=
name|USBD_NOT_STARTED
operator|&&
name|xfer
operator|->
name|status
operator|!=
name|USBD_IN_PROGRESS
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Give xfer the requested abort code. */
name|xfer
operator|->
name|status
operator|=
name|USBD_CANCELLED
expr_stmt|;
comment|/* make hardware ignore it, */
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
name|n
operator|=
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|curframe
expr_stmt|;
name|maxlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nframes
condition|;
name|i
operator|++
control|)
block|{
name|std
operator|=
name|stds
index|[
name|n
index|]
expr_stmt|;
name|std
operator|->
name|td
operator|.
name|td_status
operator|&=
name|htole32
argument_list|(
operator|~
operator|(
name|UHCI_TD_ACTIVE
operator||
name|UHCI_TD_IOC
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|UHCI_TD_GET_MAXLEN
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|++
name|n
operator|>=
name|UHCI_VFRAMELIST_COUNT
condition|)
name|n
operator|=
literal|0
expr_stmt|;
block|}
comment|/* and wait until we are sure the hardware has finished. */
name|delay
argument_list|(
name|maxlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|iinfo
operator|.
name|isdone
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Run callback and remove from interrupt list. */
name|uhci_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_device_isoc_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|vstd
decl_stmt|;
name|struct
name|iso
modifier|*
name|iso
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
comment|/* 	 * Make sure all TDs are marked as inactive. 	 * Wait for completion. 	 * Unschedule. 	 * Deallocate. 	 */
name|iso
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|iso
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
name|iso
operator|->
name|stds
index|[
name|i
index|]
operator|->
name|td
operator|.
name|td_status
operator|&=
name|htole32
argument_list|(
operator|~
name|UHCI_TD_ACTIVE
argument_list|)
expr_stmt|;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* wait for completion */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|std
operator|=
name|iso
operator|->
name|stds
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|vstd
operator|=
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|htd
init|;
name|vstd
operator|!=
name|NULL
operator|&&
name|vstd
operator|->
name|link
operator|.
name|std
operator|!=
name|std
condition|;
name|vstd
operator|=
name|vstd
operator|->
name|link
operator|.
name|std
control|)
empty_stmt|;
if|if
condition|(
name|vstd
operator|==
name|NULL
condition|)
block|{
comment|/*panic*/
name|printf
argument_list|(
literal|"uhci_device_isoc_close: %p not found\n"
argument_list|,
name|std
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|vstd
operator|->
name|link
operator|=
name|std
operator|->
name|link
expr_stmt|;
name|vstd
operator|->
name|td
operator|.
name|td_link
operator|=
name|std
operator|->
name|td
operator|.
name|td_link
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso
operator|->
name|stds
argument_list|,
name|M_USBHC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_setup_isoc
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|int
name|addr
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|address
decl_stmt|;
name|int
name|endpt
init|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
decl_stmt|;
name|int
name|rd
init|=
name|UE_GET_DIR
argument_list|(
name|endpt
argument_list|)
operator|==
name|UE_DIR_IN
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|vstd
decl_stmt|;
name|u_int32_t
name|token
decl_stmt|;
name|struct
name|iso
modifier|*
name|iso
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|iso
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|iso
expr_stmt|;
name|iso
operator|->
name|stds
operator|=
name|malloc
argument_list|(
name|UHCI_VFRAMELIST_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|uhci_soft_td_t
operator|*
argument_list|)
argument_list|,
name|M_USBHC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|token
operator|=
name|rd
condition|?
name|UHCI_TD_IN
argument_list|(
literal|0
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
else|:
name|UHCI_TD_OUT
argument_list|(
literal|0
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allocate the TDs and mark as inactive; */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|std
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|std
operator|->
name|td
operator|.
name|td_status
operator|=
name|htole32
argument_list|(
name|UHCI_TD_IOS
argument_list|)
expr_stmt|;
comment|/* iso, inactive */
name|std
operator|->
name|td
operator|.
name|td_token
operator|=
name|htole32
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|iso
operator|->
name|stds
index|[
name|i
index|]
operator|=
name|std
expr_stmt|;
block|}
comment|/* Insert TDs into schedule. */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|std
operator|=
name|iso
operator|->
name|stds
index|[
name|i
index|]
expr_stmt|;
name|vstd
operator|=
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|htd
expr_stmt|;
name|std
operator|->
name|link
operator|=
name|vstd
operator|->
name|link
expr_stmt|;
name|std
operator|->
name|td
operator|.
name|td_link
operator|=
name|vstd
operator|->
name|td
operator|.
name|td_link
expr_stmt|;
name|vstd
operator|->
name|link
operator|.
name|std
operator|=
name|std
expr_stmt|;
name|vstd
operator|->
name|td
operator|.
name|td_link
operator|=
name|htole32
argument_list|(
name|std
operator|->
name|physaddr
operator||
name|UHCI_PTR_TD
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|iso
operator|->
name|next
operator|=
operator|-
literal|1
expr_stmt|;
name|iso
operator|->
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad
label|:
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|iso
operator|->
name|stds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso
operator|->
name|stds
argument_list|,
name|M_USBHC
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_device_isoc_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|uhci_intr_info_t
modifier|*
name|ii
init|=
operator|&
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|iinfo
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"uhci_isoc_done: length=%d\n"
operator|,
name|xfer
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|xfer
operator|!=
name|xfer
condition|)
comment|/* Not on interrupt list, ignore it. */
return|return;
if|if
condition|(
operator|!
name|uhci_active_intr_info
argument_list|(
name|ii
argument_list|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|busy_free
operator|!=
name|XFER_BUSY
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_device_isoc_done: xfer=%p not busy 0x%08x\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|busy_free
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ii
operator|->
name|stdend
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_device_isoc_done: xfer=%p stdend==NULL\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|uhci_dump_ii
argument_list|(
name|ii
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
endif|#
directive|endif
comment|/* Turn off the interrupt since it is active even if the TD is not. */
name|ii
operator|->
name|stdend
operator|->
name|td
operator|.
name|td_status
operator|&=
name|htole32
argument_list|(
operator|~
name|UHCI_TD_IOC
argument_list|)
expr_stmt|;
name|uhci_del_intr_info
argument_list|(
name|ii
argument_list|)
expr_stmt|;
comment|/* remove from active list */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ii
operator|->
name|stdend
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_device_isoc_done: xfer=%p stdend==NULL\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|uhci_dump_ii
argument_list|(
name|ii
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
endif|#
directive|endif
name|ii
operator|->
name|stdstart
operator|=
name|NULL
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_device_intr_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|uhci_intr_info_t
modifier|*
name|ii
init|=
operator|&
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|iinfo
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
name|ii
operator|->
name|sc
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|int
name|i
decl_stmt|,
name|npoll
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_device_intr_done: length=%d\n"
operator|,
name|xfer
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
name|npoll
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|npoll
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
block|{
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
expr_stmt|;
name|sqh
operator|->
name|elink
operator|=
name|NULL
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
block|}
name|uhci_free_std_chain
argument_list|(
name|sc
argument_list|,
name|ii
operator|->
name|stdstart
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX Wasteful. */
if|if
condition|(
name|xfer
operator|->
name|pipe
operator|->
name|repeat
condition|)
block|{
name|uhci_soft_td_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|dataend
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_device_intr_done: requeing\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* This alloc cannot fail since we freed the chain above. */
name|uhci_alloc_std_chain
argument_list|(
name|upipe
argument_list|,
name|sc
argument_list|,
name|xfer
operator|->
name|length
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|isread
argument_list|,
name|xfer
operator|->
name|flags
argument_list|,
name|xfer
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|dataend
argument_list|)
expr_stmt|;
name|dataend
operator|->
name|td
operator|.
name|td_status
operator||=
name|htole32
argument_list|(
name|UHCI_TD_IOC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_device_intr_done: data(1)\n"
operator|)
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ii
operator|->
name|stdstart
operator|=
name|data
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|dataend
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|ii
operator|->
name|isdone
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_device_intr_done: not done, ii=%p\n"
argument_list|,
name|ii
argument_list|)
expr_stmt|;
block|}
name|ii
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
block|{
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
expr_stmt|;
name|sqh
operator|->
name|elink
operator|=
name|data
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|data
operator|->
name|physaddr
operator||
name|UHCI_PTR_TD
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
comment|/* The ii is already on the examined list, just leave it. */
block|}
else|else
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_device_intr_done: removing\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uhci_active_intr_info
argument_list|(
name|ii
argument_list|)
condition|)
block|{
name|uhci_del_intr_info
argument_list|(
name|ii
argument_list|)
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
name|NULL
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Deallocate request data structures */
end_comment

begin_function
name|void
name|uhci_device_ctrl_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|uhci_intr_info_t
modifier|*
name|ii
init|=
operator|&
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|iinfo
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
name|ii
operator|->
name|sc
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
operator|)
condition|)
name|panic
argument_list|(
literal|"uhci_device_ctrl_done: not a request"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|uhci_active_intr_info
argument_list|(
name|ii
argument_list|)
condition|)
return|return;
name|uhci_del_intr_info
argument_list|(
name|ii
argument_list|)
expr_stmt|;
comment|/* remove from active list */
if|if
condition|(
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|)
name|uhci_remove_ls_ctrl
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
argument_list|)
expr_stmt|;
else|else
name|uhci_remove_hs_ctrl
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|length
operator|!=
literal|0
condition|)
name|uhci_free_std_chain
argument_list|(
name|sc
argument_list|,
name|ii
operator|->
name|stdstart
operator|->
name|link
operator|.
name|std
argument_list|,
name|ii
operator|->
name|stdend
argument_list|)
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
name|NULL
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|NULL
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_device_ctrl_done: length=%d\n"
operator|,
name|xfer
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deallocate request data structures */
end_comment

begin_function
name|void
name|uhci_device_bulk_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|uhci_intr_info_t
modifier|*
name|ii
init|=
operator|&
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|iinfo
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
name|ii
operator|->
name|sc
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_device_bulk_done: xfer=%p ii=%p sc=%p upipe=%p\n"
operator|,
name|xfer
operator|,
name|ii
operator|,
name|sc
operator|,
name|upipe
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uhci_active_intr_info
argument_list|(
name|ii
argument_list|)
condition|)
return|return;
name|uhci_del_intr_info
argument_list|(
name|ii
argument_list|)
expr_stmt|;
comment|/* remove from active list */
name|uhci_remove_bulk
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
argument_list|)
expr_stmt|;
name|uhci_free_std_chain
argument_list|(
name|sc
argument_list|,
name|ii
operator|->
name|stdstart
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
name|NULL
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|NULL
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_device_bulk_done: length=%d\n"
operator|,
name|xfer
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add interrupt QH, called with vflock. */
end_comment

begin_function
name|void
name|uhci_add_intr
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|uhci_soft_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|struct
name|uhci_vframe
modifier|*
name|vf
init|=
operator|&
name|sc
operator|->
name|sc_vframes
index|[
name|sqh
operator|->
name|pos
index|]
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|eqh
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"uhci_add_intr: n=%d sqh=%p\n"
operator|,
name|sqh
operator|->
name|pos
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
name|eqh
operator|=
name|vf
operator|->
name|eqh
expr_stmt|;
name|sqh
operator|->
name|hlink
operator|=
name|eqh
operator|->
name|hlink
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|eqh
operator|->
name|qh
operator|.
name|qh_hlink
expr_stmt|;
name|eqh
operator|->
name|hlink
operator|=
name|sqh
expr_stmt|;
name|eqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|htole32
argument_list|(
name|sqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_QH
argument_list|)
expr_stmt|;
name|vf
operator|->
name|eqh
operator|=
name|sqh
expr_stmt|;
name|vf
operator|->
name|bandwidth
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove interrupt QH. */
end_comment

begin_function
name|void
name|uhci_remove_intr
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|uhci_soft_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|struct
name|uhci_vframe
modifier|*
name|vf
init|=
operator|&
name|sc
operator|->
name|sc_vframes
index|[
name|sqh
operator|->
name|pos
index|]
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|pqh
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"uhci_remove_intr: n=%d sqh=%p\n"
operator|,
name|sqh
operator|->
name|pos
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
comment|/* See comment in uhci_remove_ctrl() */
if|if
condition|(
operator|!
operator|(
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|&
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
operator|)
condition|)
block|{
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|UHCI_QH_REMOVE_DELAY
argument_list|)
expr_stmt|;
block|}
name|pqh
operator|=
name|uhci_find_prev_qh
argument_list|(
name|vf
operator|->
name|hqh
argument_list|,
name|sqh
argument_list|)
expr_stmt|;
name|pqh
operator|->
name|hlink
operator|=
name|sqh
operator|->
name|hlink
expr_stmt|;
name|pqh
operator|->
name|qh
operator|.
name|qh_hlink
operator|=
name|sqh
operator|->
name|qh
operator|.
name|qh_hlink
expr_stmt|;
name|delay
argument_list|(
name|UHCI_QH_REMOVE_DELAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|vf
operator|->
name|eqh
operator|==
name|sqh
condition|)
name|vf
operator|->
name|eqh
operator|=
name|pqh
expr_stmt|;
name|vf
operator|->
name|bandwidth
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_setintr
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|uhci_pipe
modifier|*
name|upipe
parameter_list|,
name|int
name|ival
parameter_list|)
block|{
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|int
name|i
decl_stmt|,
name|npoll
decl_stmt|,
name|s
decl_stmt|;
name|u_int
name|bestbw
decl_stmt|,
name|bw
decl_stmt|,
name|bestoffs
decl_stmt|,
name|offs
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_device_setintr: pipe=%p\n"
operator|,
name|upipe
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ival
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_setintr: 0 interval\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
if|if
condition|(
name|ival
operator|>
name|UHCI_VFRAMELIST_COUNT
condition|)
name|ival
operator|=
name|UHCI_VFRAMELIST_COUNT
expr_stmt|;
name|npoll
operator|=
operator|(
name|UHCI_VFRAMELIST_COUNT
operator|+
name|ival
operator|-
literal|1
operator|)
operator|/
name|ival
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_device_setintr: ival=%d npoll=%d\n"
operator|,
name|ival
operator|,
name|npoll
operator|)
argument_list|)
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|npoll
operator|=
name|npoll
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
operator|=
name|malloc
argument_list|(
name|npoll
operator|*
sizeof|sizeof
argument_list|(
name|uhci_soft_qh_t
operator|*
argument_list|)
argument_list|,
name|M_USBHC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out which offset in the schedule that has most 	 * bandwidth left over. 	 */
define|#
directive|define
name|MOD
parameter_list|(
name|i
parameter_list|)
value|((i)& (UHCI_VFRAMELIST_COUNT-1))
for|for
control|(
name|bestoffs
operator|=
name|offs
operator|=
literal|0
operator|,
name|bestbw
operator|=
operator|~
literal|0
init|;
name|offs
operator|<
name|ival
condition|;
name|offs
operator|++
control|)
block|{
for|for
control|(
name|bw
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
name|bw
operator|+=
name|sc
operator|->
name|sc_vframes
index|[
name|MOD
argument_list|(
name|i
operator|*
name|ival
operator|+
name|offs
argument_list|)
index|]
operator|.
name|bandwidth
expr_stmt|;
if|if
condition|(
name|bw
operator|<
name|bestbw
condition|)
block|{
name|bestbw
operator|=
name|bw
expr_stmt|;
name|bestoffs
operator|=
name|offs
expr_stmt|;
block|}
block|}
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_device_setintr: bw=%d offs=%d\n"
operator|,
name|bestbw
operator|,
name|bestoffs
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
block|{
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
operator|=
name|sqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|elink
operator|=
name|NULL
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_elink
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|pos
operator|=
name|MOD
argument_list|(
name|i
operator|*
name|ival
operator|+
name|bestoffs
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|MOD
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
comment|/* Enter QHs into the controller data structures. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
name|uhci_add_intr
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_device_setintr: returns %p\n"
operator|,
name|upipe
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Open a new pipe. */
end_comment

begin_function
name|usbd_status
name|uhci_open
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
init|=
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|ival
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_open: pipe=%p, addr=%d, endpt=%d (%d)\n"
operator|,
name|pipe
operator|,
name|pipe
operator|->
name|device
operator|->
name|address
operator|,
name|ed
operator|->
name|bEndpointAddress
operator|,
name|sc
operator|->
name|sc_addr
operator|)
argument_list|)
expr_stmt|;
name|upipe
operator|->
name|aborting
operator|=
literal|0
expr_stmt|;
name|upipe
operator|->
name|nexttoggle
operator|=
name|pipe
operator|->
name|endpoint
operator|->
name|savedtoggle
expr_stmt|;
if|if
condition|(
name|pipe
operator|->
name|device
operator|->
name|address
operator|==
name|sc
operator|->
name|sc_addr
condition|)
block|{
switch|switch
condition|(
name|ed
operator|->
name|bEndpointAddress
condition|)
block|{
case|case
name|USB_CONTROL_ENDPOINT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_root_ctrl_methods
expr_stmt|;
break|break;
case|case
name|UE_DIR_IN
operator||
name|UHCI_INTR_ENDPT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_root_intr_methods
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_CONTROL
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_device_ctrl_methods
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
operator|==
name|NULL
condition|)
block|{
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|stat
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|stat
operator|==
name|NULL
condition|)
block|{
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
argument_list|)
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
sizeof|sizeof
argument_list|(
name|usb_device_request_t
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
argument_list|)
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
argument_list|)
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|stat
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
break|break;
case|case
name|UE_INTERRUPT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_device_intr_methods
expr_stmt|;
name|ival
operator|=
name|pipe
operator|->
name|interval
expr_stmt|;
if|if
condition|(
name|ival
operator|==
name|USBD_DEFAULT_INTERVAL
condition|)
name|ival
operator|=
name|ed
operator|->
name|bInterval
expr_stmt|;
return|return
operator|(
name|uhci_device_setintr
argument_list|(
name|sc
argument_list|,
name|upipe
argument_list|,
name|ival
argument_list|)
operator|)
return|;
case|case
name|UE_ISOCHRONOUS
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_device_isoc_methods
expr_stmt|;
return|return
operator|(
name|uhci_setup_isoc
argument_list|(
name|pipe
argument_list|)
operator|)
return|;
case|case
name|UE_BULK
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_device_bulk_methods
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
break|break;
block|}
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad
label|:
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Data structures and routines to emulate the root hub.  */
end_comment

begin_decl_stmt
name|usb_device_descriptor_t
name|uhci_devd
init|=
block|{
name|USB_DEVICE_DESCRIPTOR_SIZE
block|,
name|UDESC_DEVICE
block|,
comment|/* type */
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* USB version */
name|UDCLASS_HUB
block|,
comment|/* class */
name|UDSUBCLASS_HUB
block|,
comment|/* subclass */
name|UDPROTO_FSHUB
block|,
comment|/* protocol */
literal|64
block|,
comment|/* max packet */
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* device id */
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* string indicies */
literal|1
comment|/* # of configurations */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usb_config_descriptor_t
name|uhci_confd
init|=
block|{
name|USB_CONFIG_DESCRIPTOR_SIZE
block|,
name|UDESC_CONFIG
block|,
block|{
name|USB_CONFIG_DESCRIPTOR_SIZE
operator|+
name|USB_INTERFACE_DESCRIPTOR_SIZE
operator|+
name|USB_ENDPOINT_DESCRIPTOR_SIZE
block|}
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|UC_SELF_POWERED
block|,
literal|0
comment|/* max power */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usb_interface_descriptor_t
name|uhci_ifcd
init|=
block|{
name|USB_INTERFACE_DESCRIPTOR_SIZE
block|,
name|UDESC_INTERFACE
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
name|UICLASS_HUB
block|,
name|UISUBCLASS_HUB
block|,
name|UIPROTO_FSHUB
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usb_endpoint_descriptor_t
name|uhci_endpd
init|=
block|{
name|USB_ENDPOINT_DESCRIPTOR_SIZE
block|,
name|UDESC_ENDPOINT
block|,
name|UE_DIR_IN
operator||
name|UHCI_INTR_ENDPT
block|,
name|UE_INTERRUPT
block|,
block|{
literal|8
block|}
block|,
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usb_hub_descriptor_t
name|uhci_hubd_piix
init|=
block|{
name|USB_HUB_DESCRIPTOR_SIZE
block|,
name|UDESC_HUB
block|,
literal|2
block|,
block|{
name|UHD_PWR_NO_SWITCH
operator||
name|UHD_OC_INDIVIDUAL
block|,
literal|0
block|}
block|,
literal|50
block|,
comment|/* power on to power good */
literal|0
block|,
block|{
literal|0x00
block|}
block|,
comment|/* both ports are removable */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|uhci_str
parameter_list|(
name|usb_string_descriptor_t
modifier|*
name|p
parameter_list|,
name|int
name|l
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|->
name|bLength
operator|=
literal|2
operator|*
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|p
operator|->
name|bDescriptorType
operator|=
name|UDESC_STRING
expr_stmt|;
name|l
operator|-=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
index|[
name|i
index|]
operator|&&
name|l
operator|>
literal|1
condition|;
name|i
operator|++
operator|,
name|l
operator|-=
literal|2
control|)
name|USETW2
argument_list|(
name|p
operator|->
name|bString
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|*
name|i
operator|+
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The USB hub protocol requires that SET_FEATURE(PORT_RESET) also  * enables the port, and also states that SET_FEATURE(PORT_ENABLE)  * should not be used by the USB subsystem.  As we cannot issue a  * SET_FEATURE(PORT_ENABLE) externally, we must ensure that the port  * will be enabled as part of the reset.  *  * On the VT83C572, the port cannot be successfully enabled until the  * outstanding "port enable change" and "connection status change"  * events have been reset.  */
end_comment

begin_function
specifier|static
name|usbd_status
name|uhci_portreset
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|int
name|lim
decl_stmt|,
name|port
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_PR
argument_list|)
expr_stmt|;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_PORT_ROOT_RESET_DELAY
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci port %d reset, status0 = 0x%04x\n"
operator|,
name|index
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_PR
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci port %d reset, status1 = 0x%04x\n"
operator|,
name|index
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_PE
argument_list|)
expr_stmt|;
for|for
control|(
name|lim
operator|=
literal|10
init|;
operator|--
name|lim
operator|>
literal|0
condition|;
control|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_PORT_RESET_DELAY
argument_list|)
expr_stmt|;
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci port %d iteration %u, status = 0x%04x\n"
operator|,
name|index
operator|,
name|lim
operator|,
name|x
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|UHCI_PORTSC_CCS
operator|)
condition|)
block|{
comment|/* 			 * No device is connected (or was disconnected 			 * during reset).  Consider the port reset. 			 * The delay must be long enough to ensure on 			 * the initial iteration that the device 			 * connection will have been registered.  50ms 			 * appears to be sufficient, but 20ms is not. 			 */
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci port %d loop %u, device detached\n"
operator|,
name|index
operator|,
name|lim
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|x
operator|&
operator|(
name|UHCI_PORTSC_POEDC
operator||
name|UHCI_PORTSC_CSC
operator|)
condition|)
block|{
comment|/* 			 * Port enabled changed and/or connection 			 * status changed were set.  Reset either or 			 * both raised flags (by writing a 1 to that 			 * bit), and wait again for state to settle. 			 */
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|URWMASK
argument_list|(
name|x
argument_list|)
operator||
operator|(
name|x
operator|&
operator|(
name|UHCI_PORTSC_POEDC
operator||
name|UHCI_PORTSC_CSC
operator|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_PE
condition|)
comment|/* Port is enabled */
break|break;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|URWMASK
argument_list|(
name|x
argument_list|)
operator||
name|UHCI_PORTSC_PE
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci port %d reset, status2 = 0x%04x\n"
operator|,
name|index
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lim
operator|<=
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci port %d reset timed out\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_TIMEOUT
operator|)
return|;
block|}
name|sc
operator|->
name|sc_isreset
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simulate a hardware hub by handling all the necessary requests.  */
end_comment

begin_function
name|usbd_status
name|uhci_root_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Pipe isn't running (otherwise err would be USBD_INPROG), 	 * so start it first. 	 */
return|return
operator|(
name|uhci_root_ctrl_start
argument_list|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_root_ctrl_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|xfer
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|usb_device_request_t
modifier|*
name|req
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|port
decl_stmt|,
name|x
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|,
name|value
decl_stmt|,
name|index
decl_stmt|,
name|status
decl_stmt|,
name|change
decl_stmt|,
name|l
decl_stmt|,
name|totlen
init|=
literal|0
decl_stmt|;
name|usb_port_status_t
name|ps
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
operator|)
condition|)
name|panic
argument_list|(
literal|"uhci_root_ctrl_transfer: not a request"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|req
operator|=
operator|&
name|xfer
operator|->
name|request
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_root_ctrl_control type=0x%02x request=%02x\n"
operator|,
name|req
operator|->
name|bmRequestType
operator|,
name|req
operator|->
name|bRequest
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
expr_stmt|;
name|value
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
expr_stmt|;
name|index
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|buf
operator|=
name|xfer
operator|->
name|buffer
expr_stmt|;
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) | ((y)<< 8))
switch|switch
condition|(
name|C
argument_list|(
name|req
operator|->
name|bRequest
argument_list|,
name|req
operator|->
name|bmRequestType
argument_list|)
condition|)
block|{
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
comment|/* 		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops 		 * for the integrated root hub. 		 */
break|break;
case|case
name|C
argument_list|(
name|UR_GET_CONFIG
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
name|sc
operator|->
name|sc_conf
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_root_ctrl_control wValue=0x%04x\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
operator|>>
literal|8
condition|)
block|{
case|case
name|UDESC_DEVICE
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|totlen
operator|=
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_DEVICE_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|uhci_devd
operator|.
name|idVendor
argument_list|,
name|sc
operator|->
name|sc_id_vendor
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_devd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESC_CONFIG
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|totlen
operator|=
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_CONFIG_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_confd
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_INTERFACE_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_ifcd
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_ENDPOINT_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_endpd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESC_STRING
case|:
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
literal|0
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
case|case
literal|1
case|:
comment|/* Vendor */
name|totlen
operator|=
name|uhci_str
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|sc
operator|->
name|sc_vendor
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Product */
name|totlen
operator|=
name|uhci_str
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"UHCI root hub"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_INTERFACE
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
literal|0
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|USETW
argument_list|(
operator|(
operator|(
name|usb_status_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|wStatus
argument_list|,
name|UDS_SELF_POWERED
argument_list|)
expr_stmt|;
name|totlen
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_ENDPOINT
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|USETW
argument_list|(
operator|(
operator|(
name|usb_status_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|wStatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|totlen
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_SET_ADDRESS
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|>=
name|USB_MAX_DEVICES
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|sc
operator|->
name|sc_addr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_CONFIG
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|value
operator|!=
literal|1
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|sc
operator|->
name|sc_conf
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|C
argument_list|(
name|UR_SET_INTERFACE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SYNCH_FRAME
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
break|break;
comment|/* Hub requests */
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_root_ctrl_control: UR_CLEAR_PORT_FEATURE "
literal|"port=%d feature=%d\n"
operator|,
name|index
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_PE
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_SUSP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_RESET
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_PR
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONNECTION
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_CSC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_ENABLE
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_POEDC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_OCIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_RESET
case|:
name|sc
operator|->
name|sc_isreset
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|UHF_PORT_CONNECTION
case|:
case|case
name|UHF_PORT_OVER_CURRENT
case|:
case|case
name|UHF_PORT_POWER
case|:
case|case
name|UHF_PORT_LOW_SPEED
case|:
case|case
name|UHF_C_PORT_SUSPEND
case|:
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_BUS_STATE
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
operator|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|&
name|UHCI_PORTSC_LS
operator|)
operator|>>
name|UHCI_PORTSC_LS_SHIFT
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_HUB_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_hubd_piix
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|!=
literal|4
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|len
operator|!=
literal|4
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|status
operator|=
name|change
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_CCS
condition|)
name|status
operator||=
name|UPS_CURRENT_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_CSC
condition|)
name|change
operator||=
name|UPS_C_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_PE
condition|)
name|status
operator||=
name|UPS_PORT_ENABLED
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_POEDC
condition|)
name|change
operator||=
name|UPS_C_PORT_ENABLED
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_OCI
condition|)
name|status
operator||=
name|UPS_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_OCIC
condition|)
name|change
operator||=
name|UPS_C_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_SUSP
condition|)
name|status
operator||=
name|UPS_SUSPEND
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_LSDA
condition|)
name|status
operator||=
name|UPS_LOW_SPEED
expr_stmt|;
name|status
operator||=
name|UPS_PORT_POWER
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_isreset
condition|)
name|change
operator||=
name|UPS_C_PORT_RESET
expr_stmt|;
name|USETW
argument_list|(
name|ps
operator|.
name|wPortStatus
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|ps
operator|.
name|wPortChange
argument_list|,
name|change
argument_list|)
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
sizeof|sizeof
name|ps
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ps
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|l
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_PE
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_SUSP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_RESET
case|:
name|err
operator|=
name|uhci_portreset
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|UHF_PORT_POWER
case|:
comment|/* Pretend we turned on power */
name|err
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|UHF_C_PORT_CONNECTION
case|:
case|case
name|UHF_C_PORT_ENABLE
case|:
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
case|case
name|UHF_PORT_CONNECTION
case|:
case|case
name|UHF_PORT_OVER_CURRENT
case|:
case|case
name|UHF_PORT_LOW_SPEED
case|:
case|case
name|UHF_C_PORT_SUSPEND
case|:
case|case
name|UHF_C_PORT_RESET
case|:
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
break|break;
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|xfer
operator|->
name|actlen
operator|=
name|totlen
expr_stmt|;
name|err
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|ret
label|:
name|xfer
operator|->
name|status
operator|=
name|err
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|uhci_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a root control request. */
end_comment

begin_function
name|void
name|uhci_root_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
comment|/* Nothing to do, all transfers are synchronous. */
block|}
end_function

begin_comment
comment|/* Close the root pipe. */
end_comment

begin_function
name|void
name|uhci_root_ctrl_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_root_ctrl_close\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Abort a root interrupt request. */
end_comment

begin_function
name|void
name|uhci_root_intr_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|xfer
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|usb_uncallout
argument_list|(
name|sc
operator|->
name|sc_poll_handle
argument_list|,
name|uhci_poll_hub
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr_xfer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|==
name|xfer
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_root_intr_abort: remove\n"
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|=
literal|0
expr_stmt|;
block|}
name|xfer
operator|->
name|status
operator|=
name|USBD_CANCELLED
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|UXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|iinfo
operator|.
name|isdone
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|uhci_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_root_intr_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Pipe isn't running (otherwise err would be USBD_INPROG), 	 * so start it first. 	 */
return|return
operator|(
name|uhci_root_intr_start
argument_list|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Start a transfer on the root interrupt pipe */
end_comment

begin_function
name|usbd_status
name|uhci_root_intr_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_pipe_handle
name|pipe
init|=
name|xfer
operator|->
name|pipe
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_root_intr_start: xfer=%p len=%d flags=%d\n"
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|length
operator|,
name|xfer
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
name|sc
operator|->
name|sc_ival
operator|=
name|MS_TO_TICKS
argument_list|(
name|xfer
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bInterval
argument_list|)
expr_stmt|;
name|usb_callout
argument_list|(
name|sc
operator|->
name|sc_poll_handle
argument_list|,
name|sc
operator|->
name|sc_ival
argument_list|,
name|uhci_poll_hub
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr_xfer
operator|=
name|xfer
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Close the root interrupt pipe. */
end_comment

begin_function
name|void
name|uhci_root_intr_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|usb_uncallout
argument_list|(
name|sc
operator|->
name|sc_poll_handle
argument_list|,
name|uhci_poll_hub
argument_list|,
name|sc
operator|->
name|sc_intr_xfer
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr_xfer
operator|=
name|NULL
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_root_intr_close\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

