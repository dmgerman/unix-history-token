begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: uhci.c,v 1.22 1999/01/08 11:58:25 augustss Exp $	*/
end_comment

begin_comment
comment|/*	FreeBSD $Id: uhci.c,v 1.6 1999/01/07 23:31:33 n_hibma Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (augustss@carlstedt.se) at  * Carlstedt Research& Technology.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * USB Universal Host Controller driver.  * Handles PIIX3 and PIIX4.  *  * Data sheets: ftp://download.intel.com/design/intarch/datashts/29055002.pdf  *              ftp://download.intel.com/design/intarch/datashts/29056201.pdf  * UHCI spec: http://www.intel.com/design/usb/uhci11d.pdf  * USB spec: http://www.teleport.com/cgi-bin/mailmerge.cgi/~usb/cgiform.tpl  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_mem.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_quirks.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/uhcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/uhcivar.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_define
define|#
directive|define
name|delay
parameter_list|(
name|d
parameter_list|)
value|DELAY(d)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MS_TO_TICKS
parameter_list|(
name|ms
parameter_list|)
value|((ms) * hz / 1000)
end_define

begin_struct
struct|struct
name|uhci_pipe
block|{
name|struct
name|usbd_pipe
name|pipe
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|iinfo
decl_stmt|;
name|int
name|newtoggle
decl_stmt|;
comment|/* Info needed for different pipe kinds. */
union|union
block|{
comment|/* Control pipe */
struct|struct
block|{
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usb_dma_t
name|reqdma
decl_stmt|;
name|usb_dma_t
name|datadma
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|setup
decl_stmt|,
modifier|*
name|stat
decl_stmt|;
name|u_int
name|length
decl_stmt|;
block|}
name|ctl
struct|;
comment|/* Interrupt pipe */
struct|struct
block|{
name|usb_dma_t
name|datadma
decl_stmt|;
name|int
name|npoll
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
modifier|*
name|qhs
decl_stmt|;
block|}
name|intr
struct|;
comment|/* Bulk pipe */
struct|struct
block|{
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usb_dma_t
name|datadma
decl_stmt|;
name|u_int
name|length
decl_stmt|;
name|int
name|isread
decl_stmt|;
block|}
name|bulk
struct|;
comment|/* Iso pipe */
struct|struct
name|iso
block|{
name|u_int
name|bufsize
decl_stmt|;
name|u_int
name|nbuf
decl_stmt|;
name|usb_dma_t
modifier|*
name|bufs
decl_stmt|;
name|uhci_soft_td_t
modifier|*
modifier|*
name|stds
decl_stmt|;
block|}
name|iso
struct|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/*   * The uhci_intr_info free list can be global since they contain  * no dma specific data.  The other free lists do.  */
end_comment

begin_macro
name|LIST_HEAD
argument_list|(
argument_list|,
argument|uhci_intr_info
argument_list|)
end_macro

begin_expr_stmt
name|uhci_ii_free
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
name|uhci_busreset
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_run
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|,
name|int
name|run
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uhci_soft_td_t
modifier|*
name|uhci_alloc_std
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_free_std
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|,
name|uhci_soft_td_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uhci_soft_qh_t
modifier|*
name|uhci_alloc_sqh
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_free_sqh
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|,
name|uhci_soft_qh_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uhci_intr_info_t
modifier|*
name|uhci_alloc_intr_info
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_free_intr_info
name|__P
argument_list|(
operator|(
name|uhci_intr_info_t
operator|*
name|ii
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void		uhci_enter_ctl_q __P((uhci_softc_t *, uhci_soft_qh_t *, 				      uhci_intr_info_t *)); void		uhci_exit_ctl_q __P((uhci_softc_t *, uhci_soft_qh_t *));
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|uhci_free_std_chain
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|,
name|uhci_soft_td_t
operator|*
operator|,
name|uhci_soft_td_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_alloc_std_chain
name|__P
argument_list|(
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|,
name|uhci_softc_t
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|usb_dma_t
operator|*
operator|,
name|uhci_soft_td_t
operator|*
operator|*
operator|,
name|uhci_soft_td_t
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_waitintr
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|,
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_check_intr
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|,
name|uhci_intr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_ii_done
name|__P
argument_list|(
operator|(
name|uhci_intr_info_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_timeout
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_wakeup_ctrl
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_lock_frames
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_unlock_frames
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_add_ctrl
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|,
name|uhci_soft_qh_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_add_bulk
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|,
name|uhci_soft_qh_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_remove_ctrl
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|,
name|uhci_soft_qh_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_remove_bulk
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|,
name|uhci_soft_qh_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|uhci_str
name|__P
argument_list|(
operator|(
name|usb_string_descriptor_t
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_wakeup_cb
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_ctrl_transfer
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_ctrl_start
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_ctrl_abort
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_ctrl_close
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_intr_transfer
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_intr_start
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_intr_abort
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_intr_close
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_bulk_transfer
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_bulk_start
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_bulk_abort
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_bulk_close
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_isoc_transfer
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_isoc_start
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_isoc_abort
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_isoc_close
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_isoc_setbuf
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
operator|,
name|u_int
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_root_ctrl_transfer
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_root_ctrl_start
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_root_ctrl_abort
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_root_ctrl_close
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_root_intr_transfer
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_root_intr_start
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_root_intr_abort
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_root_intr_close
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_open
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_poll
name|__P
argument_list|(
operator|(
expr|struct
name|usbd_bus
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_request
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_ctrl_done
name|__P
argument_list|(
operator|(
name|uhci_intr_info_t
operator|*
name|ii
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_bulk_done
name|__P
argument_list|(
operator|(
name|uhci_intr_info_t
operator|*
name|ii
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_add_intr
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|,
name|int
operator|,
name|uhci_soft_qh_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_remove_intr
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|,
name|int
operator|,
name|uhci_soft_qh_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_setintr
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
expr|struct
name|uhci_pipe
operator|*
name|pipe
operator|,
name|int
name|ival
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_intr_done
name|__P
argument_list|(
operator|(
name|uhci_intr_info_t
operator|*
name|ii
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_isoc_done
name|__P
argument_list|(
operator|(
name|uhci_intr_info_t
operator|*
name|ii
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|uhci_dumpregs
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_dump_tds
name|__P
argument_list|(
operator|(
name|uhci_soft_td_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_dump_qh
name|__P
argument_list|(
operator|(
name|uhci_soft_qh_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_dump
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_dump_td
name|__P
argument_list|(
operator|(
name|uhci_soft_td_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|UWRITE2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
value|bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x))
end_define

begin_define
define|#
directive|define
name|UWRITE4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
value|bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x))
end_define

begin_define
define|#
directive|define
name|UREAD2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|bus_space_read_2((sc)->iot, (sc)->ioh, (r))
end_define

begin_define
define|#
directive|define
name|UREAD4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|bus_space_read_4((sc)->iot, (sc)->ioh, (r))
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|UWRITE2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
value|outw((sc)->sc_iobase + (r), (x))
end_define

begin_define
define|#
directive|define
name|UWRITE4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
value|outl((sc)->sc_iobase + (r), (x))
end_define

begin_define
define|#
directive|define
name|UREAD2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|inw((sc)->sc_iobase + (r))
end_define

begin_define
define|#
directive|define
name|UREAD4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|inl((sc)->sc_iobase + (r))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UHCICMD
parameter_list|(
name|sc
parameter_list|,
name|cmd
parameter_list|)
value|UWRITE2(sc, UHCI_CMD, cmd)
end_define

begin_define
define|#
directive|define
name|UHCISTS
parameter_list|(
name|sc
parameter_list|)
value|UREAD2(sc, UHCI_STS)
end_define

begin_define
define|#
directive|define
name|UHCI_RESET_TIMEOUT
value|100
end_define

begin_comment
comment|/* reset timeout */
end_comment

begin_define
define|#
directive|define
name|UHCI_CURFRAME
parameter_list|(
name|sc
parameter_list|)
value|(UREAD2(sc, UHCI_FRNUM)& UHCI_FRNUM_MASK)
end_define

begin_define
define|#
directive|define
name|UHCI_INTR_ENDPT
value|1
end_define

begin_decl_stmt
name|struct
name|usbd_methods
name|uhci_root_ctrl_methods
init|=
block|{
name|uhci_root_ctrl_transfer
block|,
name|uhci_root_ctrl_start
block|,
name|uhci_root_ctrl_abort
block|,
name|uhci_root_ctrl_close
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_methods
name|uhci_root_intr_methods
init|=
block|{
name|uhci_root_intr_transfer
block|,
name|uhci_root_intr_start
block|,
name|uhci_root_intr_abort
block|,
name|uhci_root_intr_close
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_methods
name|uhci_device_ctrl_methods
init|=
block|{
name|uhci_device_ctrl_transfer
block|,
name|uhci_device_ctrl_start
block|,
name|uhci_device_ctrl_abort
block|,
name|uhci_device_ctrl_close
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_methods
name|uhci_device_intr_methods
init|=
block|{
name|uhci_device_intr_transfer
block|,
name|uhci_device_intr_start
block|,
name|uhci_device_intr_abort
block|,
name|uhci_device_intr_close
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_methods
name|uhci_device_bulk_methods
init|=
block|{
name|uhci_device_bulk_transfer
block|,
name|uhci_device_bulk_start
block|,
name|uhci_device_bulk_abort
block|,
name|uhci_device_bulk_close
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_methods
name|uhci_device_isoc_methods
init|=
block|{
name|uhci_device_isoc_transfer
block|,
name|uhci_device_isoc_start
block|,
name|uhci_device_isoc_abort
block|,
name|uhci_device_isoc_close
block|,
name|uhci_device_isoc_setbuf
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|uhci_busreset
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD_GRESET
argument_list|)
expr_stmt|;
comment|/* global reset */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_BUS_RESET_DELAY
argument_list|)
expr_stmt|;
comment|/* wait a little */
name|UHCICMD
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* do nothing */
block|}
end_function

begin_function
name|usbd_status
name|uhci_init
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|usbd_status
name|r
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|csqh
decl_stmt|,
modifier|*
name|bsqh
decl_stmt|,
modifier|*
name|sqh
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
specifier|static
name|int
name|uhci_global_init_done
init|=
literal|0
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_init: start\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uhci_global_init_done
condition|)
block|{
name|uhci_global_init_done
operator|=
literal|1
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|uhci_ii_free
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|USB_DEBUG
argument_list|)
if|if
condition|(
name|uhcidebug
operator|>
literal|2
condition|)
name|uhci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uhci_run
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* stop the controller */
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
comment|/* Allocate and initialize real frame array. */
name|r
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|UHCI_FRAMELIST_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|uhci_physaddr_t
argument_list|)
argument_list|,
name|UHCI_FRAMELIST_ALIGN
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|sc
operator|->
name|sc_pframes
operator|=
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_FRNUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set frame number to 0 */
name|UWRITE4
argument_list|(
name|sc
argument_list|,
name|UHCI_FLBASEADDR
argument_list|,
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set frame list */
name|uhci_busreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Allocate the dummy QH where bulk traffic will be queued. */
name|bsqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bsqh
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|bsqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|UHCI_PTR_T
expr_stmt|;
comment|/* end of QH chain */
name|bsqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|UHCI_PTR_T
expr_stmt|;
name|sc
operator|->
name|sc_bulk_start
operator|=
name|sc
operator|->
name|sc_bulk_end
operator|=
name|bsqh
expr_stmt|;
comment|/* Allocate the dummy QH where control traffic will be queued. */
name|csqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|csqh
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|csqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|bsqh
expr_stmt|;
name|csqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|bsqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_Q
expr_stmt|;
name|csqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|UHCI_PTR_T
expr_stmt|;
name|sc
operator|->
name|sc_ctl_start
operator|=
name|sc
operator|->
name|sc_ctl_end
operator|=
name|csqh
expr_stmt|;
comment|/*  	 * Make all (virtual) frame list pointers point to the interrupt 	 * queue heads and the interrupt queue heads at the control 	 * queue head and point the physical frame list to the virtual. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|std
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|std
operator|||
operator|!
name|sqh
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|sqh
operator|=
name|sqh
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_link
operator|=
name|sqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_Q
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_status
operator|=
name|UHCI_TD_IOS
expr_stmt|;
comment|/* iso, inactive */
name|std
operator|->
name|td
operator|->
name|td_token
operator|=
literal|0
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_buffer
operator|=
literal|0
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|csqh
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|csqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_Q
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|elink
operator|=
literal|0
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|UHCI_PTR_T
expr_stmt|;
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|htd
operator|=
name|std
expr_stmt|;
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|etd
operator|=
name|std
expr_stmt|;
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|hqh
operator|=
name|sqh
expr_stmt|;
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|eqh
operator|=
name|sqh
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|UHCI_FRAMELIST_COUNT
condition|;
name|j
operator|+=
name|UHCI_VFRAMELIST_COUNT
control|)
name|sc
operator|->
name|sc_pframes
index|[
name|j
index|]
operator|=
name|std
operator|->
name|physaddr
expr_stmt|;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|)
expr_stmt|;
comment|/* Set up the bus struct. */
name|sc
operator|->
name|sc_bus
operator|.
name|open_pipe
operator|=
name|uhci_open
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|pipe_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uhci_pipe
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|do_poll
operator|=
name|uhci_poll
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_init: enabling\n"
operator|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|,
name|UHCI_INTR_TOCRCIE
operator||
name|UHCI_INTR_RIE
operator||
name|UHCI_INTR_IOCE
operator||
name|UHCI_INTR_SPIE
argument_list|)
expr_stmt|;
comment|/* enable interrupts */
return|return
operator|(
name|uhci_run
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|)
return|;
comment|/* and here we go... */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|uhci_dumpregs
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%s; regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, "
literal|"flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD
argument_list|)
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|)
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_FRNUM
argument_list|)
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_FLBASEADDR
argument_list|)
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_SOF
argument_list|)
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC1
argument_list|)
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|uhci_longtd
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|uhci_dump_td
parameter_list|(
name|p
parameter_list|)
name|uhci_soft_td_t
modifier|*
name|p
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"TD(%p) at %08lx = 0x%08lx 0x%08lx 0x%08lx 0x%08lx\n"
argument_list|,
name|p
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|physaddr
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|td
operator|->
name|td_link
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|td
operator|->
name|td_status
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|td
operator|->
name|td_token
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|td
operator|->
name|td_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|uhci_longtd
condition|)
name|printf
argument_list|(
literal|"  %b %b,errcnt=%d,actlen=%d pid=%02x,addr=%d,endpt=%d,"
literal|"D=%d,maxlen=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|td
operator|->
name|td_link
argument_list|,
literal|"\20\1T\2Q\3VF"
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|td
operator|->
name|td_status
argument_list|,
literal|"\20\22BITSTUFF\23CRCTO\24NAK\25BABBLE\26DBUFFER\27"
literal|"STALLED\30ACTIVE\31IOC\32ISO\33LS\36SPD"
argument_list|,
name|UHCI_TD_GET_ERRCNT
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_status
argument_list|)
argument_list|,
name|UHCI_TD_GET_ACTLEN
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_status
argument_list|)
argument_list|,
name|UHCI_TD_GET_PID
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_token
argument_list|)
argument_list|,
name|UHCI_TD_GET_DEVADDR
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_token
argument_list|)
argument_list|,
name|UHCI_TD_GET_ENDPT
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_token
argument_list|)
argument_list|,
name|UHCI_TD_GET_DT
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_token
argument_list|)
argument_list|,
name|UHCI_TD_GET_MAXLEN
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_token
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_dump_qh
parameter_list|(
name|p
parameter_list|)
name|uhci_soft_qh_t
modifier|*
name|p
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"QH(%p) at %08x: hlink=%08x elink=%08x\n"
argument_list|,
name|p
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|physaddr
argument_list|,
name|p
operator|->
name|qh
operator|->
name|qh_hlink
argument_list|,
name|p
operator|->
name|qh
operator|->
name|qh_elink
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void uhci_dump() { 	uhci_softc_t *sc = uhci;  	uhci_dumpregs(sc); 	printf("intrs=%d\n", sc->sc_intrs); 	printf("framelist[i].link = %08x\n", sc->sc_framelist[0].link); 	uhci_dump_qh(sc->sc_ctl_start->qh->hlink); }
endif|#
directive|endif
end_endif

begin_function
name|void
name|uhci_dump_tds
parameter_list|(
name|std
parameter_list|)
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
block|{
name|uhci_soft_td_t
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|std
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|td
operator|->
name|link
operator|.
name|std
control|)
name|uhci_dump_td
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This routine is executed periodically and simulates interrupts  * from the root controller interrupt pipe for port status change.  */
end_comment

begin_function
name|void
name|uhci_timo
parameter_list|(
name|addr
parameter_list|)
name|void
modifier|*
name|addr
decl_stmt|;
block|{
name|usbd_request_handle
name|reqh
init|=
name|addr
decl_stmt|;
name|usbd_pipe_handle
name|pipe
init|=
name|reqh
operator|->
name|pipe
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"uhci_timo\n"
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|KERNADDR
argument_list|(
operator|&
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|datadma
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC1
argument_list|)
operator|&
operator|(
name|UHCI_PORTSC_CSC
operator||
name|UHCI_PORTSC_OCIC
operator|)
condition|)
name|p
index|[
literal|0
index|]
operator||=
literal|1
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC2
argument_list|)
operator|&
operator|(
name|UHCI_PORTSC_CSC
operator||
name|UHCI_PORTSC_OCIC
operator|)
condition|)
name|p
index|[
literal|0
index|]
operator||=
literal|1
operator|<<
literal|2
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|reqh
operator|->
name|actlen
operator|=
literal|1
expr_stmt|;
name|reqh
operator|->
name|status
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|reqh
operator|->
name|xfercb
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reqh
operator|->
name|pipe
operator|->
name|intrreqh
operator|==
name|reqh
condition|)
block|{
name|usb_timeout
argument_list|(
name|uhci_timo
argument_list|,
name|reqh
argument_list|,
name|sc
operator|->
name|sc_ival
argument_list|,
name|reqh
operator|->
name|timo_handle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
operator|&
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|datadma
argument_list|)
expr_stmt|;
name|usb_start_next
argument_list|(
name|reqh
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_lock_frames
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|s
init|=
name|splusb
argument_list|()
decl_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_vflock
condition|)
block|{
name|sc
operator|->
name|sc_vflock
operator||=
name|UHCI_WANT_LOCK
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_vflock
argument_list|,
name|PRIBIO
argument_list|,
literal|"uhcqhl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_vflock
operator|=
name|UHCI_HAS_LOCK
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_unlock_frames
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|s
init|=
name|splusb
argument_list|()
decl_stmt|;
name|sc
operator|->
name|sc_vflock
operator|&=
operator|~
name|UHCI_HAS_LOCK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_vflock
operator|&
name|UHCI_WANT_LOCK
condition|)
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_vflock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate an interrupt information struct.  A free list is kept  * for fast allocation.  */
end_comment

begin_function
name|uhci_intr_info_t
modifier|*
name|uhci_alloc_intr_info
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
name|ii
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|uhci_ii_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
condition|)
name|LIST_REMOVE
argument_list|(
name|ii
argument_list|,
name|list
argument_list|)
expr_stmt|;
else|else
block|{
name|ii
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uhci_intr_info_t
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
name|ii
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
return|return
name|ii
return|;
block|}
end_function

begin_function
name|void
name|uhci_free_intr_info
parameter_list|(
name|ii
parameter_list|)
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|uhci_ii_free
argument_list|,
name|ii
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* and put on free list */
block|}
end_function

begin_comment
comment|/* Add control QH, called at splusb(). */
end_comment

begin_function
name|void
name|uhci_add_ctrl
parameter_list|(
name|sc
parameter_list|,
name|sqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
block|{
name|uhci_qh_t
modifier|*
name|eqh
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_add_ctrl: sqh=%p\n"
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
name|eqh
operator|=
name|sc
operator|->
name|sc_ctl_end
operator|->
name|qh
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|eqh
operator|->
name|hlink
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|eqh
operator|->
name|qh_hlink
expr_stmt|;
name|eqh
operator|->
name|hlink
operator|=
name|sqh
expr_stmt|;
name|eqh
operator|->
name|qh_hlink
operator|=
name|sqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_Q
expr_stmt|;
name|sc
operator|->
name|sc_ctl_end
operator|=
name|sqh
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove control QH, called at splusb(). */
end_comment

begin_function
name|void
name|uhci_remove_ctrl
parameter_list|(
name|sc
parameter_list|,
name|sqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
block|{
name|uhci_soft_qh_t
modifier|*
name|pqh
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_remove_ctrl: sqh=%p\n"
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pqh
operator|=
name|sc
operator|->
name|sc_ctl_start
init|;
name|pqh
operator|->
name|qh
operator|->
name|hlink
operator|!=
name|sqh
condition|;
name|pqh
operator|=
name|pqh
operator|->
name|qh
operator|->
name|hlink
control|)
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|||
name|defined
argument_list|(
name|USB_DEBUG
argument_list|)
if|if
condition|(
name|pqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|&
name|UHCI_PTR_T
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_remove_ctrl: QH not found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
name|pqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|sqh
operator|->
name|qh
operator|->
name|hlink
expr_stmt|;
name|pqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|sqh
operator|->
name|qh
operator|->
name|qh_hlink
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ctl_end
operator|==
name|sqh
condition|)
name|sc
operator|->
name|sc_ctl_end
operator|=
name|pqh
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add bulk QH, called at splusb(). */
end_comment

begin_function
name|void
name|uhci_add_bulk
parameter_list|(
name|sc
parameter_list|,
name|sqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
block|{
name|uhci_qh_t
modifier|*
name|eqh
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_add_bulk: sqh=%p\n"
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
name|eqh
operator|=
name|sc
operator|->
name|sc_bulk_end
operator|->
name|qh
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|eqh
operator|->
name|hlink
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|eqh
operator|->
name|qh_hlink
expr_stmt|;
name|eqh
operator|->
name|hlink
operator|=
name|sqh
expr_stmt|;
name|eqh
operator|->
name|qh_hlink
operator|=
name|sqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_Q
expr_stmt|;
name|sc
operator|->
name|sc_bulk_end
operator|=
name|sqh
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove bulk QH, called at splusb(). */
end_comment

begin_function
name|void
name|uhci_remove_bulk
parameter_list|(
name|sc
parameter_list|,
name|sqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
block|{
name|uhci_soft_qh_t
modifier|*
name|pqh
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_remove_bulk: sqh=%p\n"
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pqh
operator|=
name|sc
operator|->
name|sc_bulk_start
init|;
name|pqh
operator|->
name|qh
operator|->
name|hlink
operator|!=
name|sqh
condition|;
name|pqh
operator|=
name|pqh
operator|->
name|qh
operator|->
name|hlink
control|)
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|||
name|defined
argument_list|(
name|USB_DEBUG
argument_list|)
if|if
condition|(
name|pqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|&
name|UHCI_PTR_T
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_remove_bulk: QH not found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
name|pqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|sqh
operator|->
name|qh
operator|->
name|hlink
expr_stmt|;
name|pqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|sqh
operator|->
name|qh
operator|->
name|qh_hlink
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bulk_end
operator|==
name|sqh
condition|)
name|sc
operator|->
name|sc_bulk_end
operator|=
name|pqh
expr_stmt|;
block|}
end_function

begin_function
name|int
name|uhci_intr
parameter_list|(
name|p
parameter_list|)
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|p
decl_stmt|;
name|int
name|status
decl_stmt|,
name|ret
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
name|sc
operator|->
name|sc_intrs
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USB_DEBUG
argument_list|)
if|if
condition|(
name|uhcidebug
operator|>
literal|9
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_intr %p\n"
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|uhci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|status
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|UHCI_STS_USBINT
condition|)
block|{
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|,
name|UHCI_STS_USBINT
argument_list|)
expr_stmt|;
comment|/* acknowledge */
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_STS_USBEI
condition|)
block|{
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|,
name|UHCI_STS_USBEI
argument_list|)
expr_stmt|;
comment|/* acknowledge */
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_STS_RD
condition|)
block|{
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|,
name|UHCI_STS_RD
argument_list|)
expr_stmt|;
comment|/* acknowledge */
name|printf
argument_list|(
literal|"%s: resume detect\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_STS_HSE
condition|)
block|{
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|,
name|UHCI_STS_HSE
argument_list|)
expr_stmt|;
comment|/* acknowledge */
name|printf
argument_list|(
literal|"%s: Host System Error\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_STS_HCPE
condition|)
block|{
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|,
name|UHCI_STS_HCPE
argument_list|)
expr_stmt|;
comment|/* acknowledge */
name|printf
argument_list|(
literal|"%s: Host System Error\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_STS_HCH
condition|)
name|printf
argument_list|(
literal|"%s: controller halted\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
literal|0
return|;
comment|/* 	 * Interrupts on UHCI really suck.  When the host controller 	 * interrupts because a transfer is completed there is no 	 * way of knowing which transfer it was.  You can scan down 	 * the TDs and QHs of the previous frame to limit the search, 	 * but that assumes that the interrupt was not delayed by more 	 * than 1 ms, which may not always be true (e.g. after debug 	 * output on a slow console). 	 * We scan all interrupt descriptors to see if any have 	 * completed. 	 */
for|for
control|(
name|ii
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|)
init|;
name|ii
condition|;
name|ii
operator|=
name|LIST_NEXT
argument_list|(
name|ii
argument_list|,
name|list
argument_list|)
control|)
name|uhci_check_intr
argument_list|(
name|sc
argument_list|,
name|ii
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_intr: exit\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check for an interrupt. */
end_comment

begin_function
name|void
name|uhci_check_intr
parameter_list|(
name|sc
parameter_list|,
name|ii
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|lstd
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"uhci_check_intr: ii=%p\n"
operator|,
name|ii
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|ii
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_check_intr: no ii? %p\n"
argument_list|,
name|ii
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|ii
operator|->
name|stdstart
condition|)
return|return;
name|lstd
operator|=
name|ii
operator|->
name|stdend
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|lstd
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_check_intr: std==0\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* If the last TD is still active the whole transfer probably is. */
if|if
condition|(
name|lstd
operator|->
name|td
operator|->
name|td_status
operator|&
name|UHCI_TD_ACTIVE
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"uhci_check_intr: active ii=%p\n"
operator|,
name|ii
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|std
operator|=
name|ii
operator|->
name|stdstart
init|;
name|std
operator|!=
name|lstd
condition|;
name|std
operator|=
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
control|)
block|{
name|status
operator|=
name|std
operator|->
name|td
operator|->
name|td_status
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|UHCI_TD_STALLED
operator|)
operator|||
operator|(
name|status
operator|&
operator|(
name|UHCI_TD_SPD
operator||
name|UHCI_TD_ACTIVE
operator|)
operator|)
operator|==
name|UHCI_TD_SPD
condition|)
goto|goto
name|done
goto|;
block|}
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"uhci_check_intr: ii=%p std=%p still active\n"
operator|,
name|ii
operator|,
name|ii
operator|->
name|stdstart
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|done
label|:
name|upipe
operator|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|ii
operator|->
name|reqh
operator|->
name|pipe
expr_stmt|;
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|toggle
operator|=
name|upipe
operator|->
name|newtoggle
expr_stmt|;
name|uhci_ii_done
argument_list|(
name|ii
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usb_untimeout
argument_list|(
name|uhci_timeout
argument_list|,
name|ii
argument_list|,
name|ii
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_ii_done
parameter_list|(
name|ii
parameter_list|,
name|timo
parameter_list|)
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
name|int
name|timo
decl_stmt|;
block|{
name|usbd_request_handle
name|reqh
init|=
name|ii
operator|->
name|reqh
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|u_int32_t
name|tst
decl_stmt|;
name|int
name|len
decl_stmt|,
name|status
decl_stmt|,
name|attr
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_ii_done: ii=%p ready %d\n"
operator|,
name|ii
operator|,
name|timo
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
if|if
condition|(
name|ii
operator|->
name|isdone
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_ii_done: is done!\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|ii
operator|->
name|isdone
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* The transfer is done, compute length and status. */
comment|/* XXX Should stop at first inactive to get toggle right. */
comment|/* XXX Is this correct for control xfers? */
for|for
control|(
name|len
operator|=
name|status
operator|=
literal|0
operator|,
name|std
operator|=
name|ii
operator|->
name|stdstart
init|;
name|std
operator|!=
literal|0
condition|;
name|std
operator|=
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
control|)
block|{
name|tst
operator|=
name|std
operator|->
name|td
operator|->
name|td_status
expr_stmt|;
name|status
operator||=
name|tst
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
operator|(
name|tst
operator|&
name|UHCI_TD_ERROR
operator|)
operator|&&
name|uhcidebug
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_ii_done: intr error TD:\n"
argument_list|)
expr_stmt|;
name|uhci_dump_td
argument_list|(
name|std
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|UHCI_TD_GET_PID
argument_list|(
name|std
operator|->
name|td
operator|->
name|td_token
argument_list|)
operator|!=
name|UHCI_TD_PID_SETUP
condition|)
name|len
operator|+=
name|UHCI_TD_GET_ACTLEN
argument_list|(
name|tst
argument_list|)
expr_stmt|;
block|}
name|status
operator|&=
name|UHCI_TD_ERROR
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_check_intr: len=%d, status=0x%x\n"
operator|,
name|len
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
operator|+
operator|(
name|status
operator|==
name|UHCI_TD_STALLED
operator|)
argument_list|,
operator|(
literal|"uhci_ii_done: error, addr=%d, endpt=0x%02x, "
literal|"status 0x%b\n"
operator|,
name|reqh
operator|->
name|pipe
operator|->
name|device
operator|->
name|address
operator|,
name|reqh
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|,
operator|(
name|int
operator|)
name|status
operator|,
literal|"\20\22BITSTUFF\23CRCTO\24NAK\25BABBLE\26DBUFFER\27"
literal|"STALLED\30ACTIVE"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|UHCI_TD_STALLED
condition|)
name|reqh
operator|->
name|status
operator|=
name|USBD_STALLED
expr_stmt|;
else|else
name|reqh
operator|->
name|status
operator|=
name|USBD_IOERROR
expr_stmt|;
comment|/* more info XXX */
name|reqh
operator|->
name|actlen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|reqh
operator|->
name|status
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|reqh
operator|->
name|actlen
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|timo
condition|)
block|{
comment|/* We got a timeout.  Make sure transaction is not active. */
name|reqh
operator|->
name|status
operator|=
name|USBD_TIMEOUT
expr_stmt|;
for|for
control|(
name|std
operator|=
name|ii
operator|->
name|stdstart
init|;
name|std
operator|!=
literal|0
condition|;
name|std
operator|=
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
control|)
name|std
operator|->
name|td
operator|->
name|td_status
operator|&=
operator|~
name|UHCI_TD_ACTIVE
expr_stmt|;
comment|/* XXX should we wait 1 ms */
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_ii_done: calling handler ii=%p\n"
operator|,
name|ii
operator|)
argument_list|)
expr_stmt|;
name|attr
operator|=
name|reqh
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bmAttributes
expr_stmt|;
switch|switch
condition|(
name|attr
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_CONTROL
case|:
name|uhci_ctrl_done
argument_list|(
name|ii
argument_list|)
expr_stmt|;
name|usb_start_next
argument_list|(
name|reqh
operator|->
name|pipe
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
name|uhci_isoc_done
argument_list|(
name|ii
argument_list|)
expr_stmt|;
name|usb_start_next
argument_list|(
name|reqh
operator|->
name|pipe
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_BULK
case|:
name|uhci_bulk_done
argument_list|(
name|ii
argument_list|)
expr_stmt|;
name|usb_start_next
argument_list|(
name|reqh
operator|->
name|pipe
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_INTERRUPT
case|:
name|uhci_intr_done
argument_list|(
name|ii
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* And finally execute callback. */
name|reqh
operator|->
name|xfercb
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when a request does not complete.  */
end_comment

begin_function
name|void
name|uhci_timeout
parameter_list|(
name|addr
parameter_list|)
name|void
modifier|*
name|addr
decl_stmt|;
block|{
name|uhci_intr_info_t
modifier|*
name|ii
init|=
name|addr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_timeout: ii=%p\n"
operator|,
name|ii
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|uhci_ii_done
argument_list|(
name|ii
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait here until controller claims to have an interrupt.  * Then call uhci_intr and return.  Use timeout to avoid waiting  * too long.  * Only used during boot when interrupts are not enabled yet.  */
end_comment

begin_function
name|void
name|uhci_waitintr
parameter_list|(
name|sc
parameter_list|,
name|reqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|int
name|timo
init|=
name|reqh
operator|->
name|timeout
decl_stmt|;
name|int
name|usecs
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_waitintr: timeout = %ds\n"
operator|,
name|timo
operator|)
argument_list|)
expr_stmt|;
name|reqh
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
for|for
control|(
name|usecs
operator|=
name|timo
operator|*
literal|1000000
operator|/
name|hz
init|;
name|usecs
operator|>
literal|0
condition|;
name|usecs
operator|-=
literal|1000
control|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_waitintr: 0x%04x\n"
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
name|UHCI_STS_USBINT
condition|)
block|{
name|uhci_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqh
operator|->
name|status
operator|!=
name|USBD_IN_PROGRESS
condition|)
return|return;
block|}
block|}
comment|/* Timeout */
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_waitintr: timeout\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|)
init|;
name|ii
operator|&&
name|ii
operator|->
name|reqh
operator|!=
name|reqh
condition|;
name|ii
operator|=
name|LIST_NEXT
argument_list|(
name|ii
argument_list|,
name|list
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|ii
condition|)
name|uhci_ii_done
argument_list|(
name|ii
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"uhci_waitintr: lost intr_info\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_poll
parameter_list|(
name|bus
parameter_list|)
name|struct
name|usbd_bus
modifier|*
name|bus
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|bus
decl_stmt|;
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
name|UHCI_STS_USBINT
condition|)
name|uhci_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|void uhci_reset(p) 	void *p; { 	uhci_softc_t *sc = p; 	int n;  	UHCICMD(sc, UHCI_CMD_HCRESET);
comment|/* The reset bit goes low when the controller is done. */
end_comment

begin_endif
unit|for (n = 0; n< UHCI_RESET_TIMEOUT&&  		    (UREAD2(sc, UHCI_CMD)& UHCI_CMD_HCRESET); n++) 		delay(100); 	if (n>= UHCI_RESET_TIMEOUT) 		printf("%s: controller did not reset\n",  		       USBDEVNAME(sc->sc_bus.bdev)); }
endif|#
directive|endif
end_endif

begin_function
name|usbd_status
name|uhci_run
parameter_list|(
name|sc
parameter_list|,
name|run
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|run
decl_stmt|;
block|{
name|int
name|s
decl_stmt|,
name|n
decl_stmt|,
name|running
decl_stmt|;
name|run
operator|=
name|run
operator|!=
literal|0
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|running
operator|=
operator|!
operator|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
name|UHCI_STS_HCH
operator|)
expr_stmt|;
if|if
condition|(
name|run
operator|==
name|running
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD
argument_list|,
name|run
condition|?
name|UHCI_CMD_RS
else|:
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|10
condition|;
name|n
operator|++
control|)
block|{
name|running
operator|=
operator|!
operator|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
name|UHCI_STS_HCH
operator|)
expr_stmt|;
comment|/* return when we've entered the state we want */
if|if
condition|(
name|run
operator|==
name|running
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: cannot %s\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|,
name|run
condition|?
literal|"start"
else|:
literal|"stop"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Memory management routines.  *  uhci_alloc_std allocates TDs  *  uhci_alloc_sqh allocates QHs  * These two routines do their own free list management,  * partly for speed, partly because allocating DMAable memory  * has page size granularaity so much memory would be wasted if  * only one TD/QH (32 bytes) was placed in each allocated chunk.  */
end_comment

begin_function
name|uhci_soft_td_t
modifier|*
name|uhci_alloc_std
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_freetds
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_alloc_std: allocating chunk\n"
operator|)
argument_list|)
expr_stmt|;
name|std
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uhci_soft_td_t
argument_list|)
operator|*
name|UHCI_TD_CHUNK
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|std
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|UHCI_TD_SIZE
operator|*
name|UHCI_TD_CHUNK
argument_list|,
name|UHCI_TD_ALIGN
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|free
argument_list|(
name|std
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_TD_CHUNK
condition|;
name|i
operator|++
operator|,
name|std
operator|++
control|)
block|{
name|std
operator|->
name|physaddr
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|)
operator|+
name|i
operator|*
name|UHCI_TD_SIZE
expr_stmt|;
name|std
operator|->
name|td
operator|=
operator|(
name|uhci_td_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|)
operator|+
name|i
operator|*
name|UHCI_TD_SIZE
operator|)
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
expr_stmt|;
block|}
block|}
name|std
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
expr_stmt|;
name|memset
argument_list|(
name|std
operator|->
name|td
argument_list|,
literal|0
argument_list|,
name|UHCI_TD_SIZE
argument_list|)
expr_stmt|;
return|return
name|std
return|;
block|}
end_function

begin_function
name|void
name|uhci_free_std
parameter_list|(
name|sc
parameter_list|,
name|std
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
define|#
directive|define
name|TD_IS_FREE
value|0x12345678
if|if
condition|(
name|std
operator|->
name|td
operator|->
name|td_token
operator|==
name|TD_IS_FREE
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_free_std: freeing free TD %p\n"
argument_list|,
name|std
argument_list|)
expr_stmt|;
return|return;
block|}
name|std
operator|->
name|td
operator|->
name|td_token
operator|=
name|TD_IS_FREE
expr_stmt|;
endif|#
directive|endif
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
expr_stmt|;
block|}
end_function

begin_function
name|uhci_soft_qh_t
modifier|*
name|uhci_alloc_sqh
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offs
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_freeqhs
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_alloc_sqh: allocating chunk\n"
operator|)
argument_list|)
expr_stmt|;
name|sqh
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uhci_soft_qh_t
argument_list|)
operator|*
name|UHCI_QH_CHUNK
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sqh
condition|)
return|return
literal|0
return|;
name|r
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|UHCI_QH_SIZE
operator|*
name|UHCI_QH_CHUNK
argument_list|,
name|UHCI_QH_ALIGN
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|free
argument_list|(
name|sqh
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_QH_CHUNK
condition|;
name|i
operator|++
operator|,
name|sqh
operator|++
control|)
block|{
name|offs
operator|=
name|i
operator|*
name|UHCI_QH_SIZE
expr_stmt|;
name|sqh
operator|->
name|physaddr
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|)
operator|+
name|offs
expr_stmt|;
name|sqh
operator|->
name|qh
operator|=
operator|(
name|uhci_qh_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|)
operator|+
name|offs
operator|)
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|sc
operator|->
name|sc_freeqhs
expr_stmt|;
name|sc
operator|->
name|sc_freeqhs
operator|=
name|sqh
expr_stmt|;
block|}
block|}
name|sqh
operator|=
name|sc
operator|->
name|sc_freeqhs
expr_stmt|;
name|sc
operator|->
name|sc_freeqhs
operator|=
name|sqh
operator|->
name|qh
operator|->
name|hlink
expr_stmt|;
name|memset
argument_list|(
name|sqh
operator|->
name|qh
argument_list|,
literal|0
argument_list|,
name|UHCI_QH_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|sqh
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_free_sqh
parameter_list|(
name|sc
parameter_list|,
name|sqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
block|{
name|sqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|sc
operator|->
name|sc_freeqhs
expr_stmt|;
name|sc
operator|->
name|sc_freeqhs
operator|=
name|sqh
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*   * Enter a list of transfers onto a control queue.  * Called at splusb()   */
end_comment

begin_endif
unit|void uhci_enter_ctl_q(sc, sqh, ii) 	uhci_softc_t *sc; 	uhci_soft_qh_t *sqh; 	uhci_intr_info_t *ii; { 	DPRINTFN(5, ("uhci_enter_ctl_q: sqh=%p\n", sqh));  }
endif|#
directive|endif
end_endif

begin_function
name|void
name|uhci_free_std_chain
parameter_list|(
name|sc
parameter_list|,
name|std
parameter_list|,
name|stdend
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|stdend
decl_stmt|;
block|{
name|uhci_soft_td_t
modifier|*
name|p
decl_stmt|;
for|for
control|(
init|;
name|std
operator|!=
name|stdend
condition|;
name|std
operator|=
name|p
control|)
block|{
name|p
operator|=
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|usbd_status
name|uhci_alloc_std_chain
parameter_list|(
name|upipe
parameter_list|,
name|sc
parameter_list|,
name|len
parameter_list|,
name|rd
parameter_list|,
name|spd
parameter_list|,
name|dma
parameter_list|,
name|sp
parameter_list|,
name|ep
parameter_list|)
name|struct
name|uhci_pipe
modifier|*
name|upipe
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|len
decl_stmt|,
name|rd
decl_stmt|,
name|spd
decl_stmt|;
name|usb_dma_t
modifier|*
name|dma
decl_stmt|;
name|uhci_soft_td_t
modifier|*
modifier|*
name|sp
decl_stmt|,
decl|*
modifier|*
name|ep
decl_stmt|;
end_function

begin_block
block|{
name|uhci_soft_td_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|lastp
decl_stmt|;
name|uhci_physaddr_t
name|lastlink
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ntd
decl_stmt|,
name|l
decl_stmt|,
name|tog
decl_stmt|,
name|maxp
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|int
name|addr
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|address
decl_stmt|;
name|int
name|endpt
init|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d "
literal|"spd=%d\n"
operator|,
name|addr
operator|,
name|endpt
operator|,
name|len
operator|,
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|lowspeed
operator|,
name|spd
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
operator|*
name|sp
operator|=
operator|*
name|ep
operator|=
literal|0
expr_stmt|;
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"uhci_alloc_std_chain: len=0\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
name|maxp
operator|=
name|UGETW
argument_list|(
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_alloc_std_chain: maxp=0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
name|ntd
operator|=
operator|(
name|len
operator|+
name|maxp
operator|-
literal|1
operator|)
operator|/
name|maxp
expr_stmt|;
name|tog
operator|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|toggle
expr_stmt|;
if|if
condition|(
name|ntd
operator|%
literal|2
operator|==
literal|0
condition|)
name|tog
operator|^=
literal|1
expr_stmt|;
name|upipe
operator|->
name|newtoggle
operator|=
name|tog
operator|^
literal|1
expr_stmt|;
name|lastp
operator|=
literal|0
expr_stmt|;
name|lastlink
operator|=
name|UHCI_PTR_T
expr_stmt|;
name|ntd
operator|--
expr_stmt|;
name|status
operator|=
name|UHCI_TD_SET_ERRCNT
argument_list|(
literal|2
argument_list|)
operator||
name|UHCI_TD_ACTIVE
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|lowspeed
condition|)
name|status
operator||=
name|UHCI_TD_LS
expr_stmt|;
if|if
condition|(
name|spd
condition|)
name|status
operator||=
name|UHCI_TD_SPD
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntd
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|p
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|uhci_free_std_chain
argument_list|(
name|sc
argument_list|,
name|lastp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
name|p
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|=
name|lastp
expr_stmt|;
name|p
operator|->
name|td
operator|->
name|td_link
operator|=
name|lastlink
expr_stmt|;
name|lastp
operator|=
name|p
expr_stmt|;
name|lastlink
operator|=
name|p
operator|->
name|physaddr
expr_stmt|;
name|p
operator|->
name|td
operator|->
name|td_status
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ntd
condition|)
block|{
comment|/* last TD */
name|l
operator|=
name|len
operator|%
name|maxp
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
name|l
operator|=
name|maxp
expr_stmt|;
operator|*
name|ep
operator|=
name|p
expr_stmt|;
block|}
else|else
name|l
operator|=
name|maxp
expr_stmt|;
name|p
operator|->
name|td
operator|->
name|td_token
operator|=
name|rd
condition|?
name|UHCI_TD_IN
argument_list|(
name|l
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
name|tog
argument_list|)
else|:
name|UHCI_TD_OUT
argument_list|(
name|l
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
name|tog
argument_list|)
expr_stmt|;
name|p
operator|->
name|td
operator|->
name|td_buffer
operator|=
name|DMAADDR
argument_list|(
name|dma
argument_list|)
operator|+
name|i
operator|*
name|maxp
expr_stmt|;
name|tog
operator|^=
literal|1
expr_stmt|;
block|}
operator|*
name|sp
operator|=
name|lastp
expr_stmt|;
comment|/*upipe->pipe.endpoint->toggle = tog;*/
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_alloc_std_chain: oldtog=%d newtog=%d\n"
operator|,
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|toggle
operator|,
name|upipe
operator|->
name|newtoggle
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_block

begin_function
name|usbd_status
name|uhci_device_bulk_transfer
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|r
operator|=
name|usb_insert_transfer
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|r
operator|)
return|;
else|else
return|return
operator|(
name|uhci_device_bulk_start
argument_list|(
name|reqh
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_bulk_start
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
init|=
name|upipe
operator|->
name|iinfo
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|xfer
decl_stmt|,
modifier|*
name|xferend
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usb_dma_t
modifier|*
name|dmap
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|int
name|len
decl_stmt|,
name|isread
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_device_bulk_transfer: reqh=%p buf=%p len=%d "
literal|"flags=%d\n"
operator|,
name|reqh
operator|,
name|reqh
operator|->
name|buffer
operator|,
name|reqh
operator|->
name|length
operator|,
name|reqh
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqh
operator|->
name|isreq
condition|)
name|panic
argument_list|(
literal|"uhci_device_bulk_transfer: a request\n"
argument_list|)
expr_stmt|;
name|len
operator|=
name|reqh
operator|->
name|length
expr_stmt|;
name|dmap
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|datadma
expr_stmt|;
name|isread
operator|=
name|reqh
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|UE_IN
expr_stmt|;
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|isread
operator|=
name|isread
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|r
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
goto|goto
name|ret1
goto|;
name|r
operator|=
name|uhci_alloc_std_chain
argument_list|(
name|upipe
argument_list|,
name|sc
argument_list|,
name|len
argument_list|,
name|isread
argument_list|,
name|reqh
operator|->
name|flags
operator|&
name|USBD_SHORT_XFER_OK
argument_list|,
name|dmap
argument_list|,
operator|&
name|xfer
argument_list|,
operator|&
name|xferend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
goto|goto
name|ret2
goto|;
name|xferend
operator|->
name|td
operator|->
name|td_status
operator||=
name|UHCI_TD_IOC
expr_stmt|;
if|if
condition|(
operator|!
name|isread
operator|&&
name|len
operator|!=
literal|0
condition|)
name|memcpy
argument_list|(
name|KERNADDR
argument_list|(
name|dmap
argument_list|)
argument_list|,
name|reqh
operator|->
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_device_bulk_transfer: xfer(1)\n"
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Set up interrupt info. */
name|ii
operator|->
name|reqh
operator|=
name|reqh
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
name|xfer
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|xferend
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|ii
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|sqh
operator|->
name|qh
operator|->
name|elink
operator|=
name|xfer
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|xfer
operator|->
name|physaddr
expr_stmt|;
name|sqh
operator|->
name|intr_info
operator|=
name|ii
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|uhci_add_bulk
argument_list|(
name|sc
argument_list|,
name|sqh
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|,
name|ii
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqh
operator|->
name|timeout
operator|&&
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|usb_timeout
argument_list|(
name|uhci_timeout
argument_list|,
name|ii
argument_list|,
name|MS_TO_TICKS
argument_list|(
name|reqh
operator|->
name|timeout
argument_list|)
argument_list|,
name|ii
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_device_bulk_transfer: xfer(2)\n"
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
name|ret2
label|:
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
name|ret1
label|:
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a device bulk request. */
end_comment

begin_function
name|void
name|uhci_device_bulk_abort
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
comment|/* XXX inactivate */
name|usb_delay_ms
argument_list|(
name|reqh
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* make sure it is done */
comment|/* XXX call done */
block|}
end_function

begin_comment
comment|/* Close a device bulk pipe. */
end_comment

begin_function
name|void
name|uhci_device_bulk_close
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
argument_list|)
expr_stmt|;
name|uhci_free_intr_info
argument_list|(
name|upipe
operator|->
name|iinfo
argument_list|)
expr_stmt|;
comment|/* XXX free other resources */
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_ctrl_transfer
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|r
operator|=
name|usb_insert_transfer
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|r
operator|)
return|;
else|else
return|return
operator|(
name|uhci_device_ctrl_start
argument_list|(
name|reqh
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_ctrl_start
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|reqh
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|reqh
operator|->
name|isreq
condition|)
name|panic
argument_list|(
literal|"uhci_device_ctrl_transfer: not a request\n"
argument_list|)
expr_stmt|;
name|r
operator|=
name|uhci_device_request
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
name|uhci_waitintr
argument_list|(
name|sc
argument_list|,
name|reqh
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_intr_transfer
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|r
operator|=
name|usb_insert_transfer
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|r
operator|)
return|;
else|else
return|return
operator|(
name|uhci_device_intr_start
argument_list|(
name|reqh
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_intr_start
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
init|=
name|upipe
operator|->
name|iinfo
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|xfer
decl_stmt|,
modifier|*
name|xferend
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usb_dma_t
modifier|*
name|dmap
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_device_intr_transfer: reqh=%p buf=%p len=%d "
literal|"flags=%d\n"
operator|,
name|reqh
operator|,
name|reqh
operator|->
name|buffer
operator|,
name|reqh
operator|->
name|length
operator|,
name|reqh
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqh
operator|->
name|isreq
condition|)
name|panic
argument_list|(
literal|"uhci_device_intr_transfer: a request\n"
argument_list|)
expr_stmt|;
name|len
operator|=
name|reqh
operator|->
name|length
expr_stmt|;
name|dmap
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|datadma
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
comment|/* XXX should it be? */
name|r
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
goto|goto
name|ret1
goto|;
name|r
operator|=
name|uhci_alloc_std_chain
argument_list|(
name|upipe
argument_list|,
name|sc
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|reqh
operator|->
name|flags
operator|&
name|USBD_SHORT_XFER_OK
argument_list|,
name|dmap
argument_list|,
operator|&
name|xfer
argument_list|,
operator|&
name|xferend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
goto|goto
name|ret2
goto|;
name|xferend
operator|->
name|td
operator|->
name|td_status
operator||=
name|UHCI_TD_IOC
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_device_intr_transfer: xfer(1)\n"
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
comment|/* Set up interrupt info. */
name|ii
operator|->
name|reqh
operator|=
name|reqh
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
name|xfer
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|xferend
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|ii
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_device_intr_transfer: qhs[0]=%p\n"
operator|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|npoll
condition|;
name|i
operator|++
control|)
block|{
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|elink
operator|=
name|xfer
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|xfer
operator|->
name|physaddr
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_device_intr_transfer: xfer(2)\n"
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
name|ret2
label|:
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
name|ret1
label|:
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a device control request. */
end_comment

begin_function
name|void
name|uhci_device_ctrl_abort
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
comment|/* XXX inactivate */
name|usb_delay_ms
argument_list|(
name|reqh
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* make sure it is done */
comment|/* XXX call done */
block|}
end_function

begin_comment
comment|/* Close a device control pipe. */
end_comment

begin_function
name|void
name|uhci_device_ctrl_close
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|uhci_free_intr_info
argument_list|(
name|upipe
operator|->
name|iinfo
argument_list|)
expr_stmt|;
comment|/* XXX free other resources */
block|}
end_function

begin_comment
comment|/* Abort a device interrupt request. */
end_comment

begin_function
name|void
name|uhci_device_intr_abort
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_device_intr_abort: reqh=%p\n"
operator|,
name|reqh
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX inactivate */
name|usb_delay_ms
argument_list|(
name|reqh
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* make sure it is done */
if|if
condition|(
name|reqh
operator|->
name|pipe
operator|->
name|intrreqh
operator|==
name|reqh
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_device_intr_abort: remove\n"
operator|)
argument_list|)
expr_stmt|;
name|reqh
operator|->
name|pipe
operator|->
name|intrreqh
operator|=
literal|0
expr_stmt|;
name|upipe
operator|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
expr_stmt|;
name|uhci_intr_done
argument_list|(
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
literal|0
index|]
operator|->
name|intr_info
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Close a device interrupt pipe. */
end_comment

begin_function
name|void
name|uhci_device_intr_close
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|npoll
decl_stmt|;
name|upipe
operator|->
name|iinfo
operator|->
name|stdstart
operator|=
literal|0
expr_stmt|;
comment|/* inactive */
comment|/* Unlink descriptors from controller data structures. */
name|npoll
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|npoll
expr_stmt|;
name|uhci_lock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
name|uhci_remove_intr
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
operator|->
name|pos
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|uhci_unlock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*  	 * We now have to wait for any activity on the physical 	 * descriptors to stop. 	 */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|upipe
operator|->
name|iinfo
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* remove from active list */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|uhci_free_intr_info
argument_list|(
name|upipe
operator|->
name|iinfo
argument_list|)
expr_stmt|;
comment|/* XXX free other resources */
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_request
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
decl_stmt|;
name|usb_device_request_t
modifier|*
name|req
init|=
operator|&
name|reqh
operator|->
name|request
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|int
name|addr
init|=
name|dev
operator|->
name|address
decl_stmt|;
name|int
name|endpt
init|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
init|=
name|upipe
operator|->
name|iinfo
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|setup
decl_stmt|,
modifier|*
name|xfer
decl_stmt|,
modifier|*
name|stat
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|xferend
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usb_dma_t
modifier|*
name|dmap
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_int32_t
name|ls
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|int
name|isread
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_device_control type=0x%02x, request=0x%02x, "
literal|"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\n"
operator|,
name|req
operator|->
name|bmRequestType
operator|,
name|req
operator|->
name|bRequest
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
operator|,
name|addr
operator|,
name|endpt
operator|)
argument_list|)
expr_stmt|;
name|ls
operator|=
name|dev
operator|->
name|lowspeed
condition|?
name|UHCI_TD_LS
else|:
literal|0
expr_stmt|;
name|isread
operator|=
name|req
operator|->
name|bmRequestType
operator|&
name|UT_READ
expr_stmt|;
name|len
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
expr_stmt|;
name|setup
operator|=
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
expr_stmt|;
name|stat
operator|=
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|stat
expr_stmt|;
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
expr_stmt|;
name|dmap
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|datadma
expr_stmt|;
comment|/* Set up data transaction */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
goto|goto
name|ret1
goto|;
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|toggle
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|uhci_alloc_std_chain
argument_list|(
name|upipe
argument_list|,
name|sc
argument_list|,
name|len
argument_list|,
name|isread
argument_list|,
name|reqh
operator|->
name|flags
operator|&
name|USBD_SHORT_XFER_OK
argument_list|,
name|dmap
argument_list|,
operator|&
name|xfer
argument_list|,
operator|&
name|xferend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
goto|goto
name|ret2
goto|;
name|next
operator|=
name|xfer
expr_stmt|;
name|xferend
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|=
name|stat
expr_stmt|;
name|xferend
operator|->
name|td
operator|->
name|td_link
operator|=
name|stat
operator|->
name|physaddr
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|stat
expr_stmt|;
block|}
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|KERNADDR
argument_list|(
operator|&
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|)
argument_list|,
name|req
argument_list|,
sizeof|sizeof
expr|*
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isread
operator|&&
name|len
operator|!=
literal|0
condition|)
name|memcpy
argument_list|(
name|KERNADDR
argument_list|(
name|dmap
argument_list|)
argument_list|,
name|reqh
operator|->
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|setup
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|=
name|next
expr_stmt|;
name|setup
operator|->
name|td
operator|->
name|td_link
operator|=
name|next
operator|->
name|physaddr
expr_stmt|;
name|setup
operator|->
name|td
operator|->
name|td_status
operator|=
name|UHCI_TD_SET_ERRCNT
argument_list|(
literal|2
argument_list|)
operator||
name|ls
operator||
name|UHCI_TD_ACTIVE
expr_stmt|;
name|setup
operator|->
name|td
operator|->
name|td_token
operator|=
name|UHCI_TD_SETUP
argument_list|(
sizeof|sizeof
expr|*
name|req
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|setup
operator|->
name|td
operator|->
name|td_buffer
operator|=
name|DMAADDR
argument_list|(
operator|&
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|)
expr_stmt|;
name|stat
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|=
literal|0
expr_stmt|;
name|stat
operator|->
name|td
operator|->
name|td_link
operator|=
name|UHCI_PTR_T
expr_stmt|;
name|stat
operator|->
name|td
operator|->
name|td_status
operator|=
name|UHCI_TD_SET_ERRCNT
argument_list|(
literal|2
argument_list|)
operator||
name|ls
operator||
name|UHCI_TD_ACTIVE
operator||
name|UHCI_TD_IOC
expr_stmt|;
name|stat
operator|->
name|td
operator|->
name|td_token
operator|=
name|isread
condition|?
name|UHCI_TD_OUT
argument_list|(
literal|0
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
else|:
name|UHCI_TD_IN
argument_list|(
literal|0
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stat
operator|->
name|td
operator|->
name|td_buffer
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|20
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_device_request: setup\n"
argument_list|)
expr_stmt|;
name|uhci_dump_td
argument_list|(
name|setup
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"uhci_device_request: stat\n"
argument_list|)
expr_stmt|;
name|uhci_dump_td
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Set up interrupt info. */
name|ii
operator|->
name|reqh
operator|=
name|reqh
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
name|setup
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|stat
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|ii
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|sqh
operator|->
name|qh
operator|->
name|elink
operator|=
name|setup
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|setup
operator|->
name|physaddr
expr_stmt|;
name|sqh
operator|->
name|intr_info
operator|=
name|ii
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|uhci_add_ctrl
argument_list|(
name|sc
argument_list|,
name|sqh
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|,
name|ii
argument_list|,
name|list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|12
condition|)
block|{
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|xqh
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sxqh
decl_stmt|;
name|int
name|maxqh
init|=
literal|0
decl_stmt|;
name|uhci_physaddr_t
name|link
decl_stmt|;
name|printf
argument_list|(
literal|"uhci_enter_ctl_q: follow from [0]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|std
operator|=
name|sc
operator|->
name|sc_vframes
index|[
literal|0
index|]
operator|.
name|htd
operator|,
name|link
operator|=
literal|0
init|;
operator|(
name|link
operator|&
name|UHCI_PTR_Q
operator|)
operator|==
literal|0
condition|;
name|std
operator|=
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
control|)
block|{
name|link
operator|=
name|std
operator|->
name|td
operator|->
name|td_link
expr_stmt|;
name|uhci_dump_td
argument_list|(
name|std
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sxqh
operator|=
name|xqh
operator|=
operator|(
name|uhci_soft_qh_t
operator|*
operator|)
name|std
init|;
name|xqh
condition|;
name|xqh
operator|=
operator|(
name|maxqh
operator|++
operator|==
literal|5
operator|||
name|xqh
operator|->
name|qh
operator|->
name|hlink
operator|==
name|sxqh
operator|||
name|xqh
operator|->
name|qh
operator|->
name|hlink
operator|==
name|xqh
condition|?
name|NULL
else|:
name|xqh
operator|->
name|qh
operator|->
name|hlink
operator|)
control|)
block|{
name|uhci_dump_qh
argument_list|(
name|xqh
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|sxqh
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Enqueued QH:\n"
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|sqh
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|sqh
operator|->
name|qh
operator|->
name|elink
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|reqh
operator|->
name|timeout
operator|&&
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|usb_timeout
argument_list|(
name|uhci_timeout
argument_list|,
name|ii
argument_list|,
name|MS_TO_TICKS
argument_list|(
name|reqh
operator|->
name|timeout
argument_list|)
argument_list|,
name|ii
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|ret2
label|:
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
name|ret1
label|:
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_isoc_transfer
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
decl_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_device_isoc_transfer: sc=%p\n"
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|iso
operator|.
name|bufsize
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
comment|/* XXX copy data */
return|return
operator|(
name|USBD_XXX
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_isoc_start
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
return|return
operator|(
name|USBD_XXX
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_device_isoc_abort
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
comment|/* XXX Can't abort a single request. */
block|}
end_function

begin_function
name|void
name|uhci_device_isoc_close
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|struct
name|iso
modifier|*
name|iso
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Make sure all TDs are marked as inactive. 	 * Wait for completion. 	 * Unschedule. 	 * Deallocate. 	 */
name|iso
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|iso
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
name|iso
operator|->
name|stds
index|[
name|i
index|]
operator|->
name|td
operator|->
name|td_status
operator|&=
operator|~
name|UHCI_TD_ACTIVE
expr_stmt|;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* wait for completion */
name|uhci_lock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|vstd
decl_stmt|;
name|std
operator|=
name|iso
operator|->
name|stds
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|vstd
operator|=
name|sc
operator|->
name|sc_vframes
index|[
name|i
operator|%
name|UHCI_VFRAMELIST_COUNT
index|]
operator|.
name|htd
init|;
name|vstd
operator|&&
name|vstd
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|!=
name|std
condition|;
name|vstd
operator|=
name|vstd
operator|->
name|td
operator|->
name|link
operator|.
name|std
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|vstd
condition|)
block|{
comment|/*panic*/
name|printf
argument_list|(
literal|"uhci_device_isoc_close: %p not found\n"
argument_list|,
name|std
argument_list|)
expr_stmt|;
name|uhci_unlock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|vstd
operator|->
name|td
operator|->
name|link
operator|=
name|std
operator|->
name|td
operator|->
name|link
expr_stmt|;
name|vstd
operator|->
name|td
operator|->
name|td_link
operator|=
name|std
operator|->
name|td
operator|->
name|td_link
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
block|}
name|uhci_unlock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iso
operator|->
name|nbuf
condition|;
name|i
operator|++
control|)
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
operator|&
name|iso
operator|->
name|bufs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso
operator|->
name|stds
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso
operator|->
name|bufs
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
comment|/* XXX what else? */
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_isoc_setbuf
parameter_list|(
name|pipe
parameter_list|,
name|bufsize
parameter_list|,
name|nbuf
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
name|u_int
name|bufsize
decl_stmt|;
name|u_int
name|nbuf
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|int
name|addr
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|address
decl_stmt|;
name|int
name|endpt
init|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
decl_stmt|;
name|int
name|rd
init|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|UE_IN
decl_stmt|;
name|struct
name|iso
modifier|*
name|iso
decl_stmt|;
name|int
name|i
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
comment|/*  	 * For simplicity the number of buffers must fit nicely in the frame 	 * list. 	 */
if|if
condition|(
name|UHCI_VFRAMELIST_COUNT
operator|%
name|nbuf
operator|!=
literal|0
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|iso
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|iso
expr_stmt|;
name|iso
operator|->
name|bufsize
operator|=
name|bufsize
expr_stmt|;
name|iso
operator|->
name|nbuf
operator|=
name|nbuf
expr_stmt|;
comment|/* Allocate memory for buffers. */
name|iso
operator|->
name|bufs
operator|=
name|malloc
argument_list|(
name|nbuf
operator|*
sizeof|sizeof
argument_list|(
name|usb_dma_t
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|iso
operator|->
name|stds
operator|=
name|malloc
argument_list|(
name|UHCI_VFRAMELIST_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|uhci_soft_td_t
operator|*
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|bufsize
argument_list|,
literal|0
argument_list|,
operator|&
name|iso
operator|->
name|bufs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|nbuf
operator|=
name|i
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
block|}
comment|/* Allocate the TDs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|iso
operator|->
name|stds
index|[
name|i
index|]
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso
operator|->
name|stds
index|[
name|i
index|]
operator|==
literal|0
condition|)
goto|goto
name|bad2
goto|;
block|}
comment|/* XXX check schedule */
comment|/* XXX interrupts */
comment|/* Insert TDs into schedule, all marked inactive. */
name|uhci_lock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|vstd
decl_stmt|;
name|std
operator|=
name|iso
operator|->
name|stds
index|[
name|i
index|]
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_status
operator|=
name|UHCI_TD_IOS
expr_stmt|;
comment|/* iso, inactive */
name|std
operator|->
name|td
operator|->
name|td_token
operator|=
name|rd
condition|?
name|UHCI_TD_IN
argument_list|(
literal|0
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
else|:
name|UHCI_TD_OUT
argument_list|(
literal|0
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_buffer
operator|=
name|DMAADDR
argument_list|(
operator|&
name|iso
operator|->
name|bufs
index|[
name|i
operator|%
name|nbuf
index|]
argument_list|)
expr_stmt|;
name|vstd
operator|=
name|sc
operator|->
name|sc_vframes
index|[
name|i
operator|%
name|UHCI_VFRAMELIST_COUNT
index|]
operator|.
name|htd
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|link
operator|=
name|vstd
operator|->
name|td
operator|->
name|link
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_link
operator|=
name|vstd
operator|->
name|td
operator|->
name|td_link
expr_stmt|;
name|vstd
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|=
name|std
expr_stmt|;
name|vstd
operator|->
name|td
operator|->
name|td_link
operator|=
name|std
operator|->
name|physaddr
expr_stmt|;
block|}
name|uhci_unlock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad2
label|:
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|iso
operator|->
name|stds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bad1
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
operator|&
name|iso
operator|->
name|bufs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso
operator|->
name|stds
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso
operator|->
name|bufs
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_isoc_done
parameter_list|(
name|ii
parameter_list|)
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|uhci_intr_done
parameter_list|(
name|ii
parameter_list|)
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|ii
operator|->
name|sc
decl_stmt|;
name|usbd_request_handle
name|reqh
init|=
name|ii
operator|->
name|reqh
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
decl_stmt|;
name|usb_dma_t
modifier|*
name|dma
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|int
name|i
decl_stmt|,
name|npoll
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_intr_done: length=%d\n"
operator|,
name|reqh
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
name|dma
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|datadma
expr_stmt|;
name|memcpy
argument_list|(
name|reqh
operator|->
name|buffer
argument_list|,
name|KERNADDR
argument_list|(
name|dma
argument_list|)
argument_list|,
name|reqh
operator|->
name|actlen
argument_list|)
expr_stmt|;
name|npoll
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|npoll
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
block|{
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|elink
operator|=
literal|0
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|UHCI_PTR_T
expr_stmt|;
block|}
name|uhci_free_std_chain
argument_list|(
name|sc
argument_list|,
name|ii
operator|->
name|stdstart
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX Wasteful. */
if|if
condition|(
name|reqh
operator|->
name|pipe
operator|->
name|intrreqh
operator|==
name|reqh
condition|)
block|{
name|uhci_soft_td_t
modifier|*
name|xfer
decl_stmt|,
modifier|*
name|xferend
decl_stmt|;
comment|/* This alloc cannot fail since we freed the chain above. */
name|uhci_alloc_std_chain
argument_list|(
name|upipe
argument_list|,
name|sc
argument_list|,
name|reqh
operator|->
name|length
argument_list|,
literal|1
argument_list|,
name|reqh
operator|->
name|flags
operator|&
name|USBD_SHORT_XFER_OK
argument_list|,
name|dma
argument_list|,
operator|&
name|xfer
argument_list|,
operator|&
name|xferend
argument_list|)
expr_stmt|;
name|xferend
operator|->
name|td
operator|->
name|td_status
operator||=
name|UHCI_TD_IOC
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_device_intr_done: xfer(1)\n"
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ii
operator|->
name|stdstart
operator|=
name|xfer
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|xferend
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|ii
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
block|{
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|elink
operator|=
name|xfer
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|xfer
operator|->
name|physaddr
expr_stmt|;
block|}
block|}
else|else
block|{
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|dma
argument_list|)
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
literal|0
expr_stmt|;
comment|/* mark as inactive */
name|usb_start_next
argument_list|(
name|reqh
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Deallocate request data structures */
end_comment

begin_function
name|void
name|uhci_ctrl_done
parameter_list|(
name|ii
parameter_list|)
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|ii
operator|->
name|sc
decl_stmt|;
name|usbd_request_handle
name|reqh
init|=
name|ii
operator|->
name|reqh
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
decl_stmt|;
name|u_int
name|len
init|=
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|length
decl_stmt|;
name|usb_dma_t
modifier|*
name|dma
decl_stmt|;
name|uhci_td_t
modifier|*
name|htd
init|=
name|ii
operator|->
name|stdstart
operator|->
name|td
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|reqh
operator|->
name|isreq
condition|)
name|panic
argument_list|(
literal|"uhci_ctrl_done: not a request\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LIST_REMOVE
argument_list|(
name|ii
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* remove from active list */
name|uhci_remove_ctrl
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|dma
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|datadma
expr_stmt|;
if|if
condition|(
name|reqh
operator|->
name|request
operator|.
name|bmRequestType
operator|&
name|UT_READ
condition|)
name|memcpy
argument_list|(
name|reqh
operator|->
name|buffer
argument_list|,
name|KERNADDR
argument_list|(
name|dma
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|uhci_free_std_chain
argument_list|(
name|sc
argument_list|,
name|htd
operator|->
name|link
operator|.
name|std
argument_list|,
name|ii
operator|->
name|stdend
argument_list|)
expr_stmt|;
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|dma
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_ctrl_done: length=%d\n"
operator|,
name|reqh
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deallocate request data structures */
end_comment

begin_function
name|void
name|uhci_bulk_done
parameter_list|(
name|ii
parameter_list|)
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|ii
operator|->
name|sc
decl_stmt|;
name|usbd_request_handle
name|reqh
init|=
name|ii
operator|->
name|reqh
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
decl_stmt|;
name|u_int
name|len
init|=
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|length
decl_stmt|;
name|usb_dma_t
modifier|*
name|dma
decl_stmt|;
name|uhci_td_t
modifier|*
name|htd
init|=
name|ii
operator|->
name|stdstart
operator|->
name|td
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|ii
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* remove from active list */
name|uhci_remove_bulk
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|dma
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|datadma
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|isread
operator|&&
name|len
operator|!=
literal|0
condition|)
name|memcpy
argument_list|(
name|reqh
operator|->
name|buffer
argument_list|,
name|KERNADDR
argument_list|(
name|dma
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|uhci_free_std_chain
argument_list|(
name|sc
argument_list|,
name|htd
operator|->
name|link
operator|.
name|std
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|dma
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"uhci_bulk_done: length=%d\n"
operator|,
name|reqh
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX compute new toggle */
block|}
end_function

begin_comment
comment|/* Add interrupt QH, called with vflock. */
end_comment

begin_function
name|void
name|uhci_add_intr
parameter_list|(
name|sc
parameter_list|,
name|n
parameter_list|,
name|sqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
block|{
name|struct
name|uhci_vframe
modifier|*
name|vf
init|=
operator|&
name|sc
operator|->
name|sc_vframes
index|[
name|n
index|]
decl_stmt|;
name|uhci_qh_t
modifier|*
name|eqh
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"uhci_add_intr: n=%d sqh=%p\n"
operator|,
name|n
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
name|eqh
operator|=
name|vf
operator|->
name|eqh
operator|->
name|qh
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|eqh
operator|->
name|hlink
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|eqh
operator|->
name|qh_hlink
expr_stmt|;
name|eqh
operator|->
name|hlink
operator|=
name|sqh
expr_stmt|;
name|eqh
operator|->
name|qh_hlink
operator|=
name|sqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_Q
expr_stmt|;
name|vf
operator|->
name|eqh
operator|=
name|sqh
expr_stmt|;
name|vf
operator|->
name|bandwidth
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove interrupt QH, called with vflock. */
end_comment

begin_function
name|void
name|uhci_remove_intr
parameter_list|(
name|sc
parameter_list|,
name|n
parameter_list|,
name|sqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
block|{
name|struct
name|uhci_vframe
modifier|*
name|vf
init|=
operator|&
name|sc
operator|->
name|sc_vframes
index|[
name|n
index|]
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|pqh
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"uhci_remove_intr: n=%d sqh=%p\n"
operator|,
name|n
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pqh
operator|=
name|vf
operator|->
name|hqh
init|;
name|pqh
operator|->
name|qh
operator|->
name|hlink
operator|!=
name|sqh
condition|;
name|pqh
operator|=
name|pqh
operator|->
name|qh
operator|->
name|hlink
control|)
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|||
name|defined
argument_list|(
name|USB_DEBUG
argument_list|)
if|if
condition|(
name|pqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|&
name|UHCI_PTR_T
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_remove_intr: QH not found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
name|pqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|sqh
operator|->
name|qh
operator|->
name|hlink
expr_stmt|;
name|pqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|sqh
operator|->
name|qh
operator|->
name|qh_hlink
expr_stmt|;
if|if
condition|(
name|vf
operator|->
name|eqh
operator|==
name|sqh
condition|)
name|vf
operator|->
name|eqh
operator|=
name|pqh
expr_stmt|;
name|vf
operator|->
name|bandwidth
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_setintr
parameter_list|(
name|sc
parameter_list|,
name|upipe
parameter_list|,
name|ival
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
decl_stmt|;
name|int
name|ival
decl_stmt|;
block|{
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|int
name|i
decl_stmt|,
name|npoll
decl_stmt|,
name|s
decl_stmt|;
name|u_int
name|bestbw
decl_stmt|,
name|bw
decl_stmt|,
name|bestoffs
decl_stmt|,
name|offs
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_setintr: pipe=%p\n"
operator|,
name|upipe
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ival
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_setintr: 0 interval\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
if|if
condition|(
name|ival
operator|>
name|UHCI_VFRAMELIST_COUNT
condition|)
name|ival
operator|=
name|UHCI_VFRAMELIST_COUNT
expr_stmt|;
name|npoll
operator|=
operator|(
name|UHCI_VFRAMELIST_COUNT
operator|+
name|ival
operator|-
literal|1
operator|)
operator|/
name|ival
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_setintr: ival=%d npoll=%d\n"
operator|,
name|ival
operator|,
name|npoll
operator|)
argument_list|)
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|npoll
operator|=
name|npoll
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
operator|=
name|malloc
argument_list|(
name|npoll
operator|*
sizeof|sizeof
argument_list|(
name|uhci_soft_qh_t
operator|*
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/*  	 * Figure out which offset in the schedule that has most 	 * bandwidth left over. 	 */
define|#
directive|define
name|MOD
parameter_list|(
name|i
parameter_list|)
value|((i)& (UHCI_VFRAMELIST_COUNT-1))
for|for
control|(
name|bestoffs
operator|=
name|offs
operator|=
literal|0
operator|,
name|bestbw
operator|=
operator|~
literal|0
init|;
name|offs
operator|<
name|ival
condition|;
name|offs
operator|++
control|)
block|{
for|for
control|(
name|bw
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
name|bw
operator|+=
name|sc
operator|->
name|sc_vframes
index|[
name|MOD
argument_list|(
name|i
operator|*
name|ival
operator|+
name|offs
argument_list|)
index|]
operator|.
name|bandwidth
expr_stmt|;
if|if
condition|(
name|bw
operator|<
name|bestbw
condition|)
block|{
name|bestbw
operator|=
name|bw
expr_stmt|;
name|bestoffs
operator|=
name|offs
expr_stmt|;
block|}
block|}
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_setintr: bw=%d offs=%d\n"
operator|,
name|bestbw
operator|,
name|bestoffs
operator|)
argument_list|)
expr_stmt|;
name|upipe
operator|->
name|iinfo
operator|->
name|stdstart
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
block|{
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
operator|=
name|sqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|elink
operator|=
literal|0
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|UHCI_PTR_T
expr_stmt|;
name|sqh
operator|->
name|pos
operator|=
name|MOD
argument_list|(
name|i
operator|*
name|ival
operator|+
name|bestoffs
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|intr_info
operator|=
name|upipe
operator|->
name|iinfo
expr_stmt|;
block|}
undef|#
directive|undef
name|MOD
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|,
name|upipe
operator|->
name|iinfo
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|uhci_lock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enter QHs into the controller data structures. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
name|uhci_add_intr
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
operator|->
name|pos
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|uhci_unlock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_setintr: returns %p\n"
operator|,
name|upipe
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Open a new pipe. */
end_comment

begin_function
name|usbd_status
name|uhci_open
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
init|=
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_open: pipe=%p, addr=%d, endpt=%d (%d)\n"
operator|,
name|pipe
operator|,
name|pipe
operator|->
name|device
operator|->
name|address
operator|,
name|ed
operator|->
name|bEndpointAddress
operator|,
name|sc
operator|->
name|sc_addr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|->
name|device
operator|->
name|address
operator|==
name|sc
operator|->
name|sc_addr
condition|)
block|{
switch|switch
condition|(
name|ed
operator|->
name|bEndpointAddress
condition|)
block|{
case|case
name|USB_CONTROL_ENDPOINT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_root_ctrl_methods
expr_stmt|;
break|break;
case|case
name|UE_IN
operator||
name|UHCI_INTR_ENDPT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_root_intr_methods
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
block|}
else|else
block|{
name|upipe
operator|->
name|iinfo
operator|=
name|uhci_alloc_intr_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|iinfo
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
switch|switch
condition|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_CONTROL
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_device_ctrl_methods
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
operator|==
literal|0
condition|)
block|{
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|stat
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|stat
operator|==
literal|0
condition|)
block|{
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
argument_list|)
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|r
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
sizeof|sizeof
argument_list|(
name|usb_device_request_t
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
argument_list|)
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
argument_list|)
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|stat
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
break|break;
case|case
name|UE_INTERRUPT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_device_intr_methods
expr_stmt|;
return|return
operator|(
name|uhci_device_setintr
argument_list|(
name|sc
argument_list|,
name|upipe
argument_list|,
name|ed
operator|->
name|bInterval
argument_list|)
operator|)
return|;
case|case
name|UE_ISOCHRONOUS
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_device_isoc_methods
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|iso
operator|.
name|nbuf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
case|case
name|UE_BULK
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_device_bulk_methods
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
break|break;
block|}
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad
label|:
name|uhci_free_intr_info
argument_list|(
name|upipe
operator|->
name|iinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Data structures and routines to emulate the root hub.  */
end_comment

begin_decl_stmt
name|usb_device_descriptor_t
name|uhci_devd
init|=
block|{
name|USB_DEVICE_DESCRIPTOR_SIZE
block|,
name|UDESC_DEVICE
block|,
comment|/* type */
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* USB version */
name|UCLASS_HUB
block|,
comment|/* class */
name|USUBCLASS_HUB
block|,
comment|/* subclass */
literal|0
block|,
comment|/* protocol */
literal|64
block|,
comment|/* max packet */
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* device id */
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* string indicies */
literal|1
comment|/* # of configurations */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usb_config_descriptor_t
name|uhci_confd
init|=
block|{
name|USB_CONFIG_DESCRIPTOR_SIZE
block|,
name|UDESC_CONFIG
block|,
block|{
name|USB_CONFIG_DESCRIPTOR_SIZE
operator|+
name|USB_INTERFACE_DESCRIPTOR_SIZE
operator|+
name|USB_ENDPOINT_DESCRIPTOR_SIZE
block|}
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|UC_SELF_POWERED
block|,
literal|0
comment|/* max power */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usb_interface_descriptor_t
name|uhci_ifcd
init|=
block|{
name|USB_INTERFACE_DESCRIPTOR_SIZE
block|,
name|UDESC_INTERFACE
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
name|UCLASS_HUB
block|,
name|USUBCLASS_HUB
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usb_endpoint_descriptor_t
name|uhci_endpd
init|=
block|{
name|USB_ENDPOINT_DESCRIPTOR_SIZE
block|,
name|UDESC_ENDPOINT
block|,
name|UE_IN
operator||
name|UHCI_INTR_ENDPT
block|,
name|UE_INTERRUPT
block|,
block|{
literal|8
block|}
block|,
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usb_hub_descriptor_t
name|uhci_hubd_piix
init|=
block|{
name|USB_HUB_DESCRIPTOR_SIZE
block|,
name|UDESC_HUB
block|,
literal|2
block|,
block|{
name|UHD_PWR_NO_SWITCH
operator||
name|UHD_OC_INDIVIDUAL
block|,
literal|0
block|}
block|,
literal|50
block|,
comment|/* power on to power good */
literal|0
block|,
block|{
literal|0x00
block|}
block|,
comment|/* both ports are removable */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|uhci_str
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|,
name|s
parameter_list|)
name|usb_string_descriptor_t
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|->
name|bLength
operator|=
literal|2
operator|*
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|p
operator|->
name|bDescriptorType
operator|=
name|UDESC_STRING
expr_stmt|;
name|l
operator|-=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
index|[
name|i
index|]
operator|&&
name|l
operator|>
literal|1
condition|;
name|i
operator|++
operator|,
name|l
operator|-=
literal|2
control|)
name|USETW2
argument_list|(
name|p
operator|->
name|bString
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|*
name|i
operator|+
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simulate a hardware hub by handling all the necessary requests.  */
end_comment

begin_function
name|usbd_status
name|uhci_root_ctrl_transfer
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|r
operator|=
name|usb_insert_transfer
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|r
operator|)
return|;
else|else
return|return
operator|(
name|uhci_root_ctrl_start
argument_list|(
name|reqh
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_root_ctrl_start
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|reqh
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|usb_device_request_t
modifier|*
name|req
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|port
decl_stmt|,
name|x
decl_stmt|;
name|int
name|len
decl_stmt|,
name|value
decl_stmt|,
name|index
decl_stmt|,
name|status
decl_stmt|,
name|change
decl_stmt|,
name|l
decl_stmt|,
name|totlen
init|=
literal|0
decl_stmt|;
name|usb_port_status_t
name|ps
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|reqh
operator|->
name|isreq
condition|)
name|panic
argument_list|(
literal|"uhci_root_ctrl_transfer: not a request\n"
argument_list|)
expr_stmt|;
name|req
operator|=
operator|&
name|reqh
operator|->
name|request
expr_stmt|;
name|buf
operator|=
name|reqh
operator|->
name|buffer
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_root_ctrl_control type=0x%02x request=%02x\n"
operator|,
name|req
operator|->
name|bmRequestType
operator|,
name|req
operator|->
name|bRequest
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
expr_stmt|;
name|value
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
expr_stmt|;
name|index
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
expr_stmt|;
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) | ((y)<< 8))
switch|switch
condition|(
name|C
argument_list|(
name|req
operator|->
name|bRequest
argument_list|,
name|req
operator|->
name|bmRequestType
argument_list|)
condition|)
block|{
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
comment|/*  		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops 		 * for the integrated root hub. 		 */
break|break;
case|case
name|C
argument_list|(
name|UR_GET_CONFIG
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
name|sc
operator|->
name|sc_conf
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_root_ctrl_control wValue=0x%04x\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
operator|>>
literal|8
condition|)
block|{
case|case
name|UDESC_DEVICE
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|totlen
operator|=
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_DEVICE_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_devd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESC_CONFIG
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|totlen
operator|=
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_CONFIG_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_confd
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_INTERFACE_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_ifcd
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_ENDPOINT_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_endpd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESC_STRING
case|:
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
literal|0
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
case|case
literal|1
case|:
comment|/* Vendor */
name|totlen
operator|=
name|uhci_str
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|sc
operator|->
name|sc_vendor
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Product */
name|totlen
operator|=
name|uhci_str
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"UHCI root hub"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_INTERFACE
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
literal|0
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|USETW
argument_list|(
operator|(
operator|(
name|usb_status_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|wStatus
argument_list|,
name|UDS_SELF_POWERED
argument_list|)
expr_stmt|;
name|totlen
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_ENDPOINT
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|USETW
argument_list|(
operator|(
operator|(
name|usb_status_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|wStatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|totlen
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_SET_ADDRESS
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|>=
name|USB_MAX_DEVICES
condition|)
block|{
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|sc
operator|->
name|sc_addr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_CONFIG
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|value
operator|!=
literal|1
condition|)
block|{
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|sc
operator|->
name|sc_conf
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|C
argument_list|(
name|UR_SET_INTERFACE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SYNCH_FRAME
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
break|break;
comment|/* Hub requests */
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_root_ctrl_control: UR_CLEAR_PORT_FEATURE "
literal|"port=%d feature=%d\n"
operator|,
name|index
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_PE
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_SUSP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_RESET
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_PR
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONNECTION
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_CSC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_ENABLE
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_POEDC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_OCIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_RESET
case|:
name|sc
operator|->
name|sc_isreset
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|UHF_PORT_CONNECTION
case|:
case|case
name|UHF_PORT_OVER_CURRENT
case|:
case|case
name|UHF_PORT_POWER
case|:
case|case
name|UHF_PORT_LOW_SPEED
case|:
case|case
name|UHF_C_PORT_SUSPEND
case|:
default|default:
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_BUS_STATE
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
operator|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|&
name|UHCI_PORTSC_LS
operator|)
operator|>>
name|UHCI_PORTSC_LS_SHIFT
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_HUB_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_hubd_piix
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|!=
literal|4
condition|)
block|{
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|len
operator|!=
literal|4
condition|)
block|{
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|status
operator|=
name|change
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_CCS
condition|)
name|status
operator||=
name|UPS_CURRENT_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_CSC
condition|)
name|change
operator||=
name|UPS_C_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_PE
condition|)
name|status
operator||=
name|UPS_PORT_ENABLED
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_POEDC
condition|)
name|change
operator||=
name|UPS_C_PORT_ENABLED
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_OCI
condition|)
name|status
operator||=
name|UPS_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_OCIC
condition|)
name|change
operator||=
name|UPS_C_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_SUSP
condition|)
name|status
operator||=
name|UPS_SUSPEND
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_LSDA
condition|)
name|status
operator||=
name|UPS_LOW_SPEED
expr_stmt|;
name|status
operator||=
name|UPS_PORT_POWER
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_isreset
condition|)
name|change
operator||=
name|UPS_C_PORT_RESET
expr_stmt|;
name|USETW
argument_list|(
name|ps
operator|.
name|wPortStatus
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|ps
operator|.
name|wPortChange
argument_list|,
name|change
argument_list|)
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
sizeof|sizeof
name|ps
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ps
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|l
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_PE
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_SUSP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_RESET
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_PR
argument_list|)
expr_stmt|;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_PR
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_PE
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci port %d reset, status = 0x%04x\n"
operator|,
name|index
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_isreset
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONNECTION
case|:
case|case
name|UHF_C_PORT_ENABLE
case|:
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
case|case
name|UHF_PORT_CONNECTION
case|:
case|case
name|UHF_PORT_OVER_CURRENT
case|:
case|case
name|UHF_PORT_POWER
case|:
case|case
name|UHF_PORT_LOW_SPEED
case|:
case|case
name|UHF_C_PORT_SUSPEND
case|:
case|case
name|UHF_C_PORT_RESET
case|:
default|default:
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
break|break;
default|default:
name|r
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|reqh
operator|->
name|actlen
operator|=
name|totlen
expr_stmt|;
name|r
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|ret
label|:
name|reqh
operator|->
name|status
operator|=
name|r
expr_stmt|;
name|reqh
operator|->
name|xfercb
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
name|usb_start_next
argument_list|(
name|reqh
operator|->
name|pipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a root control request. */
end_comment

begin_function
name|void
name|uhci_root_ctrl_abort
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
comment|/* Nothing to do, all transfers are syncronous. */
block|}
end_function

begin_comment
comment|/* Close the root pipe. */
end_comment

begin_function
name|void
name|uhci_root_ctrl_close
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|usb_untimeout
argument_list|(
name|uhci_timo
argument_list|,
name|pipe
operator|->
name|intrreqh
argument_list|,
name|pipe
operator|->
name|intrreqh
operator|->
name|timo_handle
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_root_ctrl_close\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Abort a root interrupt request. */
end_comment

begin_function
name|void
name|uhci_root_intr_abort
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|usb_untimeout
argument_list|(
name|uhci_timo
argument_list|,
name|reqh
argument_list|,
name|reqh
operator|->
name|timo_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_root_intr_transfer
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|r
operator|=
name|usb_insert_transfer
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|r
operator|)
return|;
else|else
return|return
operator|(
name|uhci_root_intr_start
argument_list|(
name|reqh
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Start a transfer on the root interrupt pipe */
end_comment

begin_function
name|usbd_status
name|uhci_root_intr_start
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|usbd_pipe_handle
name|pipe
init|=
name|reqh
operator|->
name|pipe
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|usb_dma_t
modifier|*
name|dmap
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|int
name|len
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_root_intr_transfer: reqh=%p buf=%p len=%d "
literal|"flags=%d\n"
operator|,
name|reqh
operator|,
name|reqh
operator|->
name|buffer
operator|,
name|reqh
operator|->
name|length
operator|,
name|reqh
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|reqh
operator|->
name|length
expr_stmt|;
name|dmap
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|datadma
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
comment|/* XXX should it be? */
name|r
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|sc
operator|->
name|sc_ival
operator|=
name|MS_TO_TICKS
argument_list|(
name|reqh
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bInterval
argument_list|)
expr_stmt|;
name|usb_timeout
argument_list|(
name|uhci_timo
argument_list|,
name|reqh
argument_list|,
name|sc
operator|->
name|sc_ival
argument_list|,
name|reqh
operator|->
name|timo_handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Close the root interrupt pipe. */
end_comment

begin_function
name|void
name|uhci_root_intr_close
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|usb_untimeout
argument_list|(
name|uhci_timo
argument_list|,
name|pipe
operator|->
name|intrreqh
argument_list|,
name|pipe
operator|->
name|intrreqh
operator|->
name|timo_handle
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_root_intr_close\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

