begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: uhci.c,v 1.24 1999/02/20 23:26:16 augustss Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (augustss@carlstedt.se) at  * Carlstedt Research& Technology.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * USB Universal Host Controller driver.  * Handles PIIX3 and PIIX4.  *  * Data sheets: ftp://download.intel.com/design/intarch/datashts/29055002.pdf  *              ftp://download.intel.com/design/intarch/datashts/29056201.pdf  * UHCI spec: http://www.intel.com/design/usb/uhci11d.pdf  * USB spec: http://www.usb.org/cgi-usb/mailmerge.cgi/home/usb/docs/developers/ cgiform.tpl  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_mem.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_quirks.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/uhcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/uhcivar.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_define
define|#
directive|define
name|delay
parameter_list|(
name|d
parameter_list|)
value|DELAY(d)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UHCI_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (uhcidebug) logprintf x
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (uhcidebug>(n)) logprintf x
end_define

begin_decl_stmt
name|int
name|uhcidebug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MS_TO_TICKS
parameter_list|(
name|ms
parameter_list|)
value|((ms) * hz / 1000)
end_define

begin_struct
struct|struct
name|uhci_pipe
block|{
name|struct
name|usbd_pipe
name|pipe
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|iinfo
decl_stmt|;
name|int
name|nexttoggle
decl_stmt|;
union|union
block|{
comment|/* Control pipe */
struct|struct
block|{
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usb_dma_t
name|reqdma
decl_stmt|;
name|usb_dma_t
name|datadma
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|setup
decl_stmt|,
modifier|*
name|stat
decl_stmt|;
name|u_int
name|length
decl_stmt|;
block|}
name|ctl
struct|;
comment|/* Interrupt pipe */
struct|struct
block|{
name|usb_dma_t
name|datadma
decl_stmt|;
name|int
name|npoll
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
modifier|*
name|qhs
decl_stmt|;
block|}
name|intr
struct|;
comment|/* Bulk pipe */
struct|struct
block|{
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usb_dma_t
name|datadma
decl_stmt|;
name|u_int
name|length
decl_stmt|;
name|int
name|isread
decl_stmt|;
block|}
name|bulk
struct|;
comment|/* Iso pipe */
struct|struct
name|iso
block|{
name|u_int
name|bufsize
decl_stmt|;
name|u_int
name|nbuf
decl_stmt|;
name|usb_dma_t
modifier|*
name|bufs
decl_stmt|;
name|uhci_soft_td_t
modifier|*
modifier|*
name|stds
decl_stmt|;
block|}
name|iso
struct|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/*   * The uhci_intr_info free list can be global since they contain  * no dma specific data. The other free lists do.  */
end_comment

begin_macro
name|LIST_HEAD
argument_list|(
argument_list|,
argument|uhci_intr_info
argument_list|)
end_macro

begin_expr_stmt
name|uhci_ii_free
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|uhci_ii_free
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* initialisation */
end_comment

begin_decl_stmt
name|usbd_status
name|uhci_init_framelist
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* modification of the host controller's status */
end_comment

begin_decl_stmt
name|void
name|uhci_busreset
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_run
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
name|int
name|run
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* resource management */
end_comment

begin_decl_stmt
name|uhci_soft_td_t
modifier|*
name|uhci_alloc_std
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_free_std
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
name|uhci_soft_td_t
operator|*
name|std
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_alloc_std_chain
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
expr|struct
name|uhci_pipe
operator|*
name|upipe
operator|,
name|int
name|datalen
operator|,
name|int
name|isread
operator|,
name|int
name|spd
operator|,
name|usb_dma_t
operator|*
name|dma
operator|,
name|uhci_soft_td_t
operator|*
operator|*
name|std
operator|,
name|uhci_soft_td_t
operator|*
operator|*
name|stdend
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_free_std_chain
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
name|uhci_soft_td_t
operator|*
name|std
operator|,
name|uhci_soft_td_t
operator|*
name|stdend
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uhci_soft_qh_t
modifier|*
name|uhci_alloc_sqh
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_free_sqh
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
name|uhci_soft_qh_t
operator|*
name|sqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uhci_intr_info_t
modifier|*
name|uhci_alloc_intr_info
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_free_intr_info
name|__P
argument_list|(
operator|(
name|uhci_intr_info_t
operator|*
name|ii
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* locking of the framelist */
end_comment

begin_decl_stmt
name|void
name|uhci_lock_frames
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_unlock_frames
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handling of interrupts */
end_comment

begin_decl_stmt
name|void
name|uhci_poll
name|__P
argument_list|(
operator|(
expr|struct
name|usbd_bus
operator|*
name|bus
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_waitintr
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_timeout
name|__P
argument_list|(
operator|(
name|void
operator|*
name|priv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* check the list of TDs for an interrupt */
end_comment

begin_decl_stmt
name|void
name|uhci_check_intr
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
name|uhci_intr_info_t
operator|*
name|ii
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle a completed request */
end_comment

begin_decl_stmt
name|void
name|uhci_ii_done
name|__P
argument_list|(
operator|(
name|uhci_intr_info_t
operator|*
name|ii
operator|,
name|int
name|timedout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_ctrl_done
name|__P
argument_list|(
operator|(
name|uhci_intr_info_t
operator|*
name|ii
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_bulk_done
name|__P
argument_list|(
operator|(
name|uhci_intr_info_t
operator|*
name|ii
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_intr_done
name|__P
argument_list|(
operator|(
name|uhci_intr_info_t
operator|*
name|ii
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_isoc_done
name|__P
argument_list|(
operator|(
name|uhci_intr_info_t
operator|*
name|ii
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pipe methods for devices and root hub; the latter doesn't use iso or bulk */
end_comment

begin_decl_stmt
name|usbd_status
name|uhci_open
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
name|pipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_request
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_ctrl_transfer
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_ctrl_start
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_ctrl_abort
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_ctrl_close
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
name|pipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_bulk_transfer
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_bulk_start
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_bulk_abort
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_bulk_close
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
name|pipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_intr_transfer
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_intr_start
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_intr_abort
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_intr_close
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
name|pipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_intr_interval
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
expr|struct
name|uhci_pipe
operator|*
name|upipe
operator|,
name|int
name|ival
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_isoc_transfer
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_isoc_start
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_isoc_abort
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_device_isoc_close
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
name|pipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_device_isoc_setbuf
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
name|pipe
operator|,
name|u_int
name|bufsize
operator|,
name|u_int
name|nbuf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_root_ctrl_transfer
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_root_ctrl_start
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_root_ctrl_abort
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_root_ctrl_close
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
name|pipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_root_intr_transfer
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_root_intr_start
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_root_intr_abort
name|__P
argument_list|(
operator|(
name|usbd_request_handle
name|reqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_root_intr_close
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
name|pipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_root_intr_sim
name|__P
argument_list|(
operator|(
name|void
operator|*
name|priv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_add_ctrl
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
name|uhci_soft_qh_t
operator|*
name|sqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_remove_ctrl
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
name|uhci_soft_qh_t
operator|*
name|sqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_add_bulk
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
name|uhci_soft_qh_t
operator|*
name|sqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_remove_bulk
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
name|uhci_soft_qh_t
operator|*
name|sqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_add_intr
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|,
name|int
name|pos
operator|,
name|uhci_soft_qh_t
operator|*
name|sqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_remove_intr
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|,
name|int
name|pos
operator|,
name|uhci_soft_qh_t
operator|*
name|sqh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* isochroneous mode transfers not yet supported */
end_comment

begin_comment
comment|/* the simulated root hub */
end_comment

begin_decl_stmt
name|usbd_status
name|uhci_roothub_ctrl_transfer
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
name|usb_device_request_t
operator|*
name|req
operator|,
name|void
operator|*
name|buf
operator|,
name|int
operator|*
name|actlen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|uhci_roothub_intr_transfer
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
name|sc
operator|,
name|u_int8_t
operator|*
name|buf
operator|,
name|int
name|buflen
operator|,
name|int
operator|*
name|actlen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|uhci_roothub_string_descriptor
name|__P
argument_list|(
operator|(
name|usb_string_descriptor_t
operator|*
name|sd
operator|,
name|int
name|datalen
operator|,
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UHCI_DEBUG
end_ifdef

begin_decl_stmt
name|void
name|uhci_dumpregs
name|__P
argument_list|(
operator|(
name|uhci_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_dump_tds
name|__P
argument_list|(
operator|(
name|uhci_soft_td_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_dump_qh
name|__P
argument_list|(
operator|(
name|uhci_soft_qh_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_dump
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|uhci_dump_td
name|__P
argument_list|(
operator|(
name|uhci_soft_td_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|UWRITE2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
value|bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x))
end_define

begin_define
define|#
directive|define
name|UWRITE4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
value|bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x))
end_define

begin_define
define|#
directive|define
name|UREAD2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|bus_space_read_2((sc)->iot, (sc)->ioh, (r))
end_define

begin_define
define|#
directive|define
name|UREAD4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|bus_space_read_4((sc)->iot, (sc)->ioh, (r))
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|UWRITE2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
value|bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x))
end_define

begin_define
define|#
directive|define
name|UWRITE4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
value|bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x))
end_define

begin_define
define|#
directive|define
name|UREAD1
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|bus_space_read_1((sc)->iot, (sc)->ioh, (r))
end_define

begin_define
define|#
directive|define
name|UREAD2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|bus_space_read_2((sc)->iot, (sc)->ioh, (r))
end_define

begin_define
define|#
directive|define
name|UREAD4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|bus_space_read_4((sc)->iot, (sc)->ioh, (r))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UHCICMD
parameter_list|(
name|sc
parameter_list|,
name|cmd
parameter_list|)
value|UWRITE2(sc, UHCI_CMD, cmd)
end_define

begin_define
define|#
directive|define
name|UHCISTS
parameter_list|(
name|sc
parameter_list|)
value|UREAD2(sc, UHCI_STS)
end_define

begin_define
define|#
directive|define
name|UHCI_RESET_TIMEOUT
value|100
end_define

begin_comment
comment|/* reset timeout */
end_comment

begin_define
define|#
directive|define
name|UHCI_CURFRAME
parameter_list|(
name|sc
parameter_list|)
value|(UREAD2(sc, UHCI_FRNUM)& UHCI_FRNUM_MASK)
end_define

begin_define
define|#
directive|define
name|UHCI_INTR_ENDPT
value|1
end_define

begin_function
name|usbd_status
name|uhci_init
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_init: start\n"
operator|)
argument_list|)
expr_stmt|;
name|uhci_run
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* stop the controller */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* 	 * FreeBSD does this in the probe of the chip. Otherwise we 	 * get spurious interrupts 	 */
endif|#
directive|endif
name|uhci_busreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize real frame array. */
name|err
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|UHCI_FRAMELIST_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|uhci_physaddr_t
argument_list|)
argument_list|,
name|UHCI_FRAMELIST_ALIGN
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|sc
operator|->
name|sc_pframes
operator|=
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flbase
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|)
expr_stmt|;
name|err
operator|=
name|uhci_init_framelist
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|)
expr_stmt|;
comment|/* Set up the bus struct. */
name|sc
operator|->
name|sc_bus
operator|.
name|open_pipe
operator|=
name|uhci_open
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|pipe_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uhci_pipe
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|do_poll
operator|=
name|uhci_poll
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_init: enabling\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|uhci_reset
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_init_framelist
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uhci_soft_qh_t
modifier|*
name|csqh
decl_stmt|,
modifier|*
name|bsqh
decl_stmt|,
modifier|*
name|sqh
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* see uhcivar.h for an explanation of the queuing used */
comment|/* Allocate the QH where bulk traffic will be queued. */
name|bsqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bsqh
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|bsqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|UHCI_PTR_T
expr_stmt|;
comment|/* end of QH chain */
name|bsqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|UHCI_PTR_T
expr_stmt|;
name|sc
operator|->
name|sc_bulk_start
operator|=
name|sc
operator|->
name|sc_bulk_end
operator|=
name|bsqh
expr_stmt|;
comment|/* Allocate the QH where control traffic will be queued. */
name|csqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|csqh
condition|)
block|{
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|bsqh
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
name|csqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|bsqh
expr_stmt|;
comment|/* link to bulk QH */
name|csqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|bsqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_Q
expr_stmt|;
name|csqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|UHCI_PTR_T
expr_stmt|;
name|sc
operator|->
name|sc_ctl_start
operator|=
name|sc
operator|->
name|sc_ctl_end
operator|=
name|csqh
expr_stmt|;
comment|/*  	 * Make all (virtual) frame list pointers point to the interrupt 	 * queue heads and the interrupt queue heads point to the control 	 * queue head. Insert the elements for the virtual frame list multiple 	 * times in the physical framelist 	 * (UHCI_FRAMELIST_COUNT/UHCI_VFRAMELIST_COUNT times). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
comment|/* Allocate the iso TD and the interrupt QH */
name|std
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|std
operator|||
operator|!
name|sqh
condition|)
block|{
comment|/* not allocated -> free the lot we've done previously */
if|if
condition|(
name|std
condition|)
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|std
operator|=
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|htd
expr_stmt|;
name|sqh
operator|=
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|sqh
expr_stmt|;
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|sqh
argument_list|)
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
block|}
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|csqh
argument_list|)
expr_stmt|;
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|bsqh
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
comment|/* QH for interrupt transfers */
name|sqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|csqh
expr_stmt|;
comment|/* link to control QH */
name|sqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|csqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_Q
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|elink
operator|=
name|NULL
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|UHCI_PTR_T
expr_stmt|;
comment|/* dummy TD for isochroneous transfers */
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|sqh
operator|=
name|sqh
expr_stmt|;
comment|/* link to inter. QH */
name|std
operator|->
name|td
operator|->
name|td_link
operator|=
name|sqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_Q
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_status
operator|=
name|UHCI_TD_IOS
expr_stmt|;
comment|/* iso, inactive */
name|std
operator|->
name|td
operator|->
name|td_token
operator|=
literal|0
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_buffer
operator|=
name|NULL
expr_stmt|;
comment|/* enter the iso TD in the virtual frame list */
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|htd
operator|=
name|std
expr_stmt|;
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|etd
operator|=
name|std
expr_stmt|;
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|hqh
operator|=
name|sqh
expr_stmt|;
name|sc
operator|->
name|sc_vframes
index|[
name|i
index|]
operator|.
name|eqh
operator|=
name|sqh
expr_stmt|;
comment|/* 		 * copy the entry in the virtual frame list 		 * UHCI_FRAMELIST_COUNT/UHCI_VFRAMELIST_COUNT times 		 */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|UHCI_FRAMELIST_COUNT
condition|;
name|j
operator|+=
name|UHCI_VFRAMELIST_COUNT
control|)
name|sc
operator|->
name|sc_pframes
index|[
name|j
index|]
operator|=
name|std
operator|->
name|physaddr
expr_stmt|;
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_busreset
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD_GRESET
argument_list|)
expr_stmt|;
comment|/* global reset */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_BUS_RESET_DELAY
argument_list|)
expr_stmt|;
comment|/* wait a little */
name|UHCICMD
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* do nothing */
block|}
end_function

begin_function
name|usbd_status
name|uhci_reset
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
comment|/* Reset the host controller */
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD_HCRESET
argument_list|)
expr_stmt|;
comment|/* The reset bit goes low when the controller is done. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|UHCI_RESET_TIMEOUT
operator|&&
operator|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD
argument_list|)
operator|&
name|UHCI_CMD_HCRESET
operator|)
condition|;
name|n
operator|++
control|)
name|delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|UHCI_RESET_TIMEOUT
condition|)
name|printf
argument_list|(
literal|"%s: controller did not reset\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_FRNUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set frame number to 0 */
name|UWRITE4
argument_list|(
name|sc
argument_list|,
name|UHCI_FLBASEADDR
argument_list|,
name|sc
operator|->
name|sc_flbase
argument_list|)
expr_stmt|;
comment|/* set frame list address */
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|,
name|UHCI_INTR_TOCRCIE
operator||
name|UHCI_INTR_RIE
operator||
name|UHCI_INTR_IOCE
operator||
name|UHCI_INTR_SPIE
argument_list|)
expr_stmt|;
comment|/* enable interrupts */
return|return
operator|(
name|uhci_run
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|)
return|;
comment|/* and here we go... */
block|}
end_function

begin_function
name|usbd_status
name|uhci_run
parameter_list|(
name|sc
parameter_list|,
name|run
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|run
decl_stmt|;
block|{
name|int
name|s
decl_stmt|,
name|n
decl_stmt|,
name|running
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|running
operator|=
operator|(
operator|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
name|UHCI_STS_HCH
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|run
operator|==
name|running
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD
argument_list|,
name|run
condition|?
name|UHCI_CMD_RS
else|:
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|10
condition|;
name|n
operator|++
control|)
block|{
name|running
operator|=
operator|(
operator|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
name|UHCI_STS_HCH
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* return when we've entered the state we want */
if|if
condition|(
name|run
operator|==
name|running
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: cannot %s\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|,
name|run
condition|?
literal|"start"
else|:
literal|"stop"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * check whether the host controller has flagged an  * interrupt.  */
end_comment

begin_function
name|void
name|uhci_poll
parameter_list|(
name|bus
parameter_list|)
name|struct
name|usbd_bus
modifier|*
name|bus
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|bus
decl_stmt|;
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
name|UHCI_STS_USBINT
condition|)
name|uhci_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait here until controller claims to have an interrupt.  * Then call uhci_intr and return.  Use timeout to avoid waiting  * too long.  * Only used during boot when interrupts are not enabled yet.  * XXX this function is not re-entrant *  */
end_comment

begin_function
name|void
name|uhci_waitintr
parameter_list|(
name|sc
parameter_list|,
name|reqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|int
name|timeout
init|=
name|reqh
operator|->
name|timeout
decl_stmt|;
name|int
name|usecs
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"uhci_waitintr: timeout = %ds\n"
operator|,
name|timeout
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX NWH setting status here might give race condition */
name|reqh
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
for|for
control|(
name|usecs
operator|=
name|timeout
operator|*
literal|1000000
operator|/
name|hz
init|;
name|usecs
operator|>
literal|0
condition|;
name|usecs
operator|-=
literal|1000
control|)
block|{
name|uhci_poll
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqh
operator|->
name|status
operator|!=
name|USBD_IN_PROGRESS
condition|)
return|return;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Timeout */
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_waitintr: timeout\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Find the intr info in the queue */
for|for
control|(
name|ii
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|)
init|;
name|ii
operator|&&
name|ii
operator|->
name|reqh
operator|!=
name|reqh
condition|;
name|ii
operator|=
name|LIST_NEXT
argument_list|(
name|ii
argument_list|,
name|list
argument_list|)
control|)
comment|/* noop */
empty_stmt|;
if|if
condition|(
name|ii
condition|)
name|uhci_ii_done
argument_list|(
name|ii
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* this can only happen if there are 2 or more tasks 		 * polling or interrupts are enabled. This is not 		 * possible during boot. 		 * In that case the request has been handled already. 		 * If it does happen this should be non-fatal. 		 */
ifdef|#
directive|ifdef
name|UHCI_DEBUG
name|panic
argument_list|(
literal|"lost intr_info\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"lost intr_info\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Called when a request does not complete.  */
end_comment

begin_function
name|void
name|uhci_timeout
parameter_list|(
name|priv
parameter_list|)
name|void
modifier|*
name|priv
decl_stmt|;
block|{
name|uhci_intr_info_t
modifier|*
name|ii
init|=
name|priv
decl_stmt|;
name|uhci_ii_done
argument_list|(
name|ii
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle interrupt from the host controller. We search the list of TDs  * for completed ones and call uhci_ii_done for those.  */
end_comment

begin_function
name|int
name|uhci_intr
parameter_list|(
name|priv
parameter_list|)
name|void
modifier|*
name|priv
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|priv
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|ack
init|=
literal|0
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
name|sc
operator|->
name|sc_intrs
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|UHCI_DEBUG
argument_list|)
if|if
condition|(
name|uhcidebug
operator|>
literal|15
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: uhci_intr\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|uhci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|status
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|UHCI_STS_USBINT
condition|)
name|ack
operator||=
name|UHCI_STS_USBINT
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|UHCI_STS_USBEI
condition|)
name|ack
operator||=
name|UHCI_STS_USBEI
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|UHCI_STS_RD
condition|)
block|{
name|ack
operator||=
name|UHCI_STS_RD
expr_stmt|;
name|printf
argument_list|(
literal|"%s: resume detect\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_STS_HSE
condition|)
block|{
name|ack
operator||=
name|UHCI_STS_HSE
expr_stmt|;
name|printf
argument_list|(
literal|"%s: host controller process error\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_STS_HCPE
condition|)
block|{
name|ack
operator||=
name|UHCI_STS_HCPE
expr_stmt|;
name|printf
argument_list|(
literal|"%s: host system error\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_STS_HCH
condition|)
block|{
comment|/* no acknowledge needed */
name|printf
argument_list|(
literal|"%s: host controller halted\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ack
condition|)
comment|/* acknowledge the ints */
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|,
name|ack
argument_list|)
expr_stmt|;
else|else
comment|/* nothing to acknowledge */
return|return
literal|0
return|;
comment|/* 	 * Interrupts on UHCI really suck.  When the host controller 	 * interrupts because a transfer is completed there is no 	 * way of knowing which transfer it was.  You can scan down 	 * the TDs and QHs of the previous frame to limit the search, 	 * but that assumes that the interrupt was not delayed by more 	 * than 1 ms, which may not always be true (e.g. after debug 	 * output on a slow console). 	 * We scan all interrupt descriptors to see if any have 	 * completed. 	 */
for|for
control|(
name|ii
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|)
init|;
name|ii
condition|;
name|ii
operator|=
name|LIST_NEXT
argument_list|(
name|ii
argument_list|,
name|list
argument_list|)
control|)
name|uhci_check_intr
argument_list|(
name|sc
argument_list|,
name|ii
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_intr: exit\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Check the list of TDs for completeness.  * If there is an error in the middle of the list of TDs or  * a short packet, retire the list and call uhci_ii_done for the ii  */
end_comment

begin_function
name|void
name|uhci_check_intr
parameter_list|(
name|sc
parameter_list|,
name|ii
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
block|{
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"uhci_check_intr: ii=%p\n"
operator|,
name|ii
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|ii
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_check_intr: no ii? %p\n"
argument_list|,
name|ii
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ii
operator|->
name|stdend
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_check_intr: ii->stdend==0\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|ii
operator|->
name|stdstart
condition|)
return|return;
if|if
condition|(
name|ii
operator|->
name|stdend
operator|->
name|td
operator|->
name|td_status
operator|&
name|UHCI_TD_ACTIVE
condition|)
block|{
comment|/* 		 * If the last TD is still active we need to check whether there 		 * is a an error somewhere in the middle or whether there was a 		 * short packet (SPD and not ACTIVE). 		 */
for|for
control|(
name|std
operator|=
name|ii
operator|->
name|stdstart
init|;
name|std
operator|!=
name|ii
operator|->
name|stdend
condition|;
name|std
operator|=
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
control|)
block|{
name|status
operator|=
name|std
operator|->
name|td
operator|->
name|td_status
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|UHCI_TD_STALLED
operator|)
operator|||
operator|(
name|status
operator|&
operator|(
name|UHCI_TD_SPD
operator||
name|UHCI_TD_ACTIVE
operator|)
operator|)
operator|==
name|UHCI_TD_SPD
condition|)
goto|goto
name|done
goto|;
block|}
return|return;
block|}
name|done
label|:
name|usb_untimeout
argument_list|(
name|uhci_timeout
argument_list|,
name|ii
argument_list|,
name|ii
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
name|uhci_ii_done
argument_list|(
name|ii
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_ii_done
parameter_list|(
name|ii
parameter_list|,
name|timedout
parameter_list|)
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
name|int
name|timedout
decl_stmt|;
comment|/* timeout that triggered function call? */
block|{
name|usbd_request_handle
name|reqh
init|=
name|ii
operator|->
name|reqh
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
comment|/* error status of last inactive transfer */
name|usbd_status
name|err
init|=
name|USBD_NORMAL_COMPLETION
decl_stmt|;
name|int
name|actlen
init|=
literal|0
decl_stmt|;
comment|/* accumulated actual length for queue */
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
block|{
comment|/* avoid finishing a transfer more than once */
name|int
name|s
init|=
name|splusb
argument_list|()
decl_stmt|;
if|if
condition|(
name|ii
operator|->
name|isdone
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"uhci_ii_done: is done!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ii
operator|->
name|isdone
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * The transfer is done; compute actual length and status 	 * XXX Is this correct for control transfers? Should not 	 * only the data stage be calculated? 	 */
for|for
control|(
name|std
operator|=
name|ii
operator|->
name|stdstart
init|;
name|std
condition|;
name|std
operator|=
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
control|)
block|{
if|if
condition|(
name|std
operator|->
name|td
operator|->
name|td_status
operator|&
name|UHCI_TD_ACTIVE
condition|)
break|break;
comment|/* error status of last TD for error handling below */
name|err
operator|=
name|std
operator|->
name|td
operator|->
name|td_status
operator|&
name|UHCI_TD_ERROR
expr_stmt|;
if|if
condition|(
name|UHCI_TD_GET_PID
argument_list|(
name|std
operator|->
name|td
operator|->
name|td_token
argument_list|)
operator|!=
name|UHCI_TD_PID_SETUP
condition|)
name|actlen
operator|+=
name|UHCI_TD_GET_ACTLEN
argument_list|(
name|std
operator|->
name|td
operator|->
name|td_status
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_ii_done: ii=%p%s, actlen=%d err=0x%x\n"
operator|,
name|ii
operator|,
name|timedout
condition|?
literal|" timed out"
else|:
literal|""
operator|,
name|actlen
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UHCI_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
operator|&&
operator|(
name|err
operator|||
name|timedout
operator|)
condition|)
name|uhci_dump_tds
argument_list|(
name|ii
operator|->
name|stdstart
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
operator|+
operator|(
operator|(
name|err
operator|&
operator|~
name|UHCI_TD_STALLED
operator|)
operator|!=
literal|0
operator|)
argument_list|,
operator|(
literal|"uhci_ii_done: error, addr=%d, endpt=0x%02x, "
literal|"err=0x%b\n"
operator|,
name|reqh
operator|->
name|pipe
operator|->
name|device
operator|->
name|address
operator|,
name|reqh
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|,
operator|(
name|int
operator|)
name|err
operator|,
literal|"\20\22BITSTUFF\23CRCTO\24NAK\25BABBLE\26DBUFFER\27"
literal|"STALLED\30ACTIVE"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&
operator|~
name|UHCI_TD_STALLED
condition|)
block|{
comment|/* more then STALLED, like +BABBLE or +CRC/TIMEOUT */
name|reqh
operator|->
name|status
operator|=
name|USBD_IOERROR
expr_stmt|;
comment|/* more info XXX */
block|}
else|else
block|{
name|reqh
operator|->
name|status
operator|=
name|USBD_STALLED
expr_stmt|;
block|}
block|}
else|else
block|{
name|reqh
operator|->
name|status
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
block|}
name|reqh
operator|->
name|actlen
operator|=
name|actlen
expr_stmt|;
if|if
condition|(
name|timedout
condition|)
block|{
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
comment|/* We got a timeout.  Make sure transaction is not active. */
for|for
control|(
name|std
operator|=
name|ii
operator|->
name|stdstart
init|;
name|std
operator|!=
literal|0
condition|;
name|std
operator|=
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
control|)
name|std
operator|->
name|td
operator|->
name|td_status
operator|&=
operator|~
name|UHCI_TD_ACTIVE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* XXX should we wait 1 ms */
name|reqh
operator|->
name|status
operator|=
name|USBD_TIMEOUT
expr_stmt|;
block|}
comment|/* select the proper type termination of the transfer 	 * based on the transfer type for the queue 	 */
switch|switch
condition|(
name|reqh
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_CONTROL
case|:
name|uhci_ctrl_done
argument_list|(
name|ii
argument_list|)
expr_stmt|;
name|usb_start_next
argument_list|(
name|reqh
operator|->
name|pipe
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_BULK
case|:
name|uhci_bulk_done
argument_list|(
name|ii
argument_list|)
expr_stmt|;
name|usb_start_next
argument_list|(
name|reqh
operator|->
name|pipe
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_INTERRUPT
case|:
name|uhci_intr_done
argument_list|(
name|ii
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
name|uhci_isoc_done
argument_list|(
name|ii
argument_list|)
expr_stmt|;
name|usb_start_next
argument_list|(
name|reqh
operator|->
name|pipe
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* And finally execute callback. */
name|reqh
operator|->
name|xfercb
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deallocate request data structures */
end_comment

begin_function
name|void
name|uhci_ctrl_done
parameter_list|(
name|ii
parameter_list|)
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|ii
operator|->
name|sc
decl_stmt|;
name|usbd_request_handle
name|reqh
init|=
name|ii
operator|->
name|reqh
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
decl_stmt|;
name|u_int
name|datalen
init|=
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|length
decl_stmt|;
name|usb_dma_t
modifier|*
name|dma
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|reqh
operator|->
name|isreq
condition|)
name|panic
argument_list|(
literal|"uhci_ctrl_done: not a request\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LIST_REMOVE
argument_list|(
name|ii
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* remove from active list */
name|uhci_remove_ctrl
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
block|{
comment|/* there was a data stage */
name|dma
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|datadma
expr_stmt|;
if|if
condition|(
name|reqh
operator|->
name|request
operator|.
name|bmRequestType
operator|&
name|UT_READ
condition|)
name|memcpy
argument_list|(
name|reqh
operator|->
name|buffer
argument_list|,
name|KERNADDR
argument_list|(
name|dma
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
comment|/* 		 * when freeing the chain skip the first (setup) and last 		 * (status) TD. 		 */
name|uhci_free_std_chain
argument_list|(
name|sc
argument_list|,
name|ii
operator|->
name|stdstart
operator|->
name|td
operator|->
name|link
operator|.
name|std
argument_list|,
name|ii
operator|->
name|stdend
argument_list|)
expr_stmt|;
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|dma
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_ctrl_done: length=%d\n"
operator|,
name|reqh
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deallocate request data structures */
end_comment

begin_function
name|void
name|uhci_bulk_done
parameter_list|(
name|ii
parameter_list|)
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|ii
operator|->
name|sc
decl_stmt|;
name|usbd_request_handle
name|reqh
init|=
name|ii
operator|->
name|reqh
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|u_int
name|datalen
init|=
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|length
decl_stmt|;
name|usb_dma_t
modifier|*
name|dma
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|ii
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* remove from active list */
name|uhci_remove_bulk
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
argument_list|)
expr_stmt|;
comment|/* find the toggle for the last transfer and invert it */
for|for
control|(
name|std
operator|=
name|ii
operator|->
name|stdstart
init|;
name|std
condition|;
name|std
operator|=
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
control|)
block|{
if|if
condition|(
name|std
operator|->
name|td
operator|->
name|td_status
operator|&
name|UHCI_TD_ACTIVE
condition|)
break|break;
name|upipe
operator|->
name|nexttoggle
operator|=
name|UHCI_TD_GET_DT
argument_list|(
name|std
operator|->
name|td
operator|->
name|td_token
argument_list|)
expr_stmt|;
block|}
name|upipe
operator|->
name|nexttoggle
operator|^=
literal|1
expr_stmt|;
comment|/* copy the data from dma memory to userland storage */
name|dma
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|datadma
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|isread
condition|)
name|memcpy
argument_list|(
name|reqh
operator|->
name|buffer
argument_list|,
name|KERNADDR
argument_list|(
name|dma
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
comment|/* free the whole chain of TDs */
name|uhci_free_std_chain
argument_list|(
name|sc
argument_list|,
name|ii
operator|->
name|stdstart
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_intr_done
parameter_list|(
name|ii
parameter_list|)
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|ii
operator|->
name|sc
decl_stmt|;
name|usbd_request_handle
name|reqh
init|=
name|ii
operator|->
name|reqh
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
decl_stmt|;
name|usb_dma_t
modifier|*
name|dma
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|int
name|i
decl_stmt|,
name|npoll
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_intr_done: length=%d\n"
operator|,
name|reqh
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
name|dma
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|datadma
expr_stmt|;
name|memcpy
argument_list|(
name|reqh
operator|->
name|buffer
argument_list|,
name|KERNADDR
argument_list|(
name|dma
argument_list|)
argument_list|,
name|reqh
operator|->
name|actlen
argument_list|)
expr_stmt|;
name|npoll
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|npoll
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
block|{
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|elink
operator|=
literal|0
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|UHCI_PTR_T
expr_stmt|;
block|}
name|uhci_free_std_chain
argument_list|(
name|sc
argument_list|,
name|ii
operator|->
name|stdstart
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX Wasteful. */
if|if
condition|(
name|reqh
operator|->
name|pipe
operator|->
name|intrreqh
operator|==
name|reqh
operator|&&
name|reqh
operator|->
name|status
operator|==
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|stdend
decl_stmt|;
comment|/* This alloc cannot fail since we freed the chain above. */
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|toggle
operator|=
name|upipe
operator|->
name|nexttoggle
expr_stmt|;
name|uhci_alloc_std_chain
argument_list|(
name|sc
argument_list|,
name|upipe
argument_list|,
name|reqh
operator|->
name|length
argument_list|,
literal|1
argument_list|,
name|reqh
operator|->
name|flags
operator|&
name|USBD_SHORT_XFER_OK
argument_list|,
name|dma
argument_list|,
operator|&
name|std
argument_list|,
operator|&
name|stdend
argument_list|)
expr_stmt|;
name|stdend
operator|->
name|td
operator|->
name|td_status
operator||=
name|UHCI_TD_IOC
expr_stmt|;
ifdef|#
directive|ifdef
name|UHCI_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_device_intr_done: xfer\n"
operator|)
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|std
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ii
operator|->
name|stdstart
operator|=
name|std
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|stdend
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|ii
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
block|{
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|elink
operator|=
name|std
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|std
operator|->
name|physaddr
expr_stmt|;
block|}
block|}
else|else
block|{
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|dma
argument_list|)
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
name|NULL
expr_stmt|;
comment|/* mark as inactive */
block|}
block|}
end_function

begin_function
name|void
name|uhci_isoc_done
parameter_list|(
name|ii
parameter_list|)
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/*  * Memory management routines.  *  uhci_alloc_std allocates TDs  *  uhci_alloc_std_chain allocates a chain of TDs  *  uhci_alloc_sqh allocates QHs  * These two routines do their own free list management,  * partly for speed, partly because allocating DMAable memory  * has page size granularaity so much memory would be wasted if  * only one TD/QH (32 bytes) was placed in each allocated chunk.  */
end_comment

begin_function
name|uhci_soft_td_t
modifier|*
name|uhci_alloc_std
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_freetds
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_alloc_std: allocating chunk\n"
operator|)
argument_list|)
expr_stmt|;
name|std
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uhci_soft_td_t
argument_list|)
operator|*
name|UHCI_TD_CHUNK
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|std
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|UHCI_TD_SIZE
operator|*
name|UHCI_TD_CHUNK
argument_list|,
name|UHCI_TD_ALIGN
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|free
argument_list|(
name|std
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_TD_CHUNK
condition|;
name|i
operator|++
operator|,
name|std
operator|++
control|)
block|{
name|std
operator|->
name|physaddr
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|)
operator|+
name|i
operator|*
name|UHCI_TD_SIZE
expr_stmt|;
name|std
operator|->
name|td
operator|=
operator|(
name|uhci_td_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|)
operator|+
name|i
operator|*
name|UHCI_TD_SIZE
operator|)
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
expr_stmt|;
block|}
block|}
name|std
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
expr_stmt|;
name|memset
argument_list|(
name|std
operator|->
name|td
argument_list|,
literal|0
argument_list|,
name|UHCI_TD_SIZE
argument_list|)
expr_stmt|;
return|return
name|std
return|;
block|}
end_function

begin_function
name|void
name|uhci_free_std
parameter_list|(
name|sc
parameter_list|,
name|std
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|std
condition|)
ifdef|#
directive|ifdef
name|UHCI_DEBUG
name|panic
argument_list|(
literal|"invalid TD to be freed, std=%p"
argument_list|,
name|std
argument_list|)
expr_stmt|;
else|#
directive|else
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
define|#
directive|define
name|TD_IS_FREE
value|0x12345678
if|if
condition|(
name|std
operator|->
name|td
operator|->
name|td_token
operator|==
name|TD_IS_FREE
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_free_std: freeing free TD %p\n"
argument_list|,
name|std
argument_list|)
expr_stmt|;
return|return;
block|}
name|std
operator|->
name|td
operator|->
name|td_token
operator|=
name|TD_IS_FREE
expr_stmt|;
endif|#
directive|endif
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
expr_stmt|;
block|}
end_function

begin_comment
comment|/* allocates and prepares a chain of TDs */
end_comment

begin_function
name|usbd_status
name|uhci_alloc_std_chain
parameter_list|(
name|sc
parameter_list|,
name|upipe
parameter_list|,
name|datalen
parameter_list|,
name|isread
parameter_list|,
name|spd
parameter_list|,
name|dma
parameter_list|,
name|rstd
parameter_list|,
name|rstdend
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|int
name|isread
decl_stmt|,
name|spd
decl_stmt|;
name|usb_dma_t
modifier|*
name|dma
decl_stmt|;
name|uhci_soft_td_t
modifier|*
modifier|*
name|rstd
decl_stmt|,
decl|*
modifier|*
name|rstdend
decl_stmt|;
end_function

begin_block
block|{
name|uhci_soft_td_t
modifier|*
name|std
init|=
name|NULL
decl_stmt|;
comment|/* soft TD we are working on */
name|uhci_soft_td_t
modifier|*
name|stdprev
init|=
name|NULL
decl_stmt|;
comment|/* std from prev iteration */
name|uhci_physaddr_t
name|linkprev
init|=
name|UHCI_PTR_T
decl_stmt|;
comment|/* links real TDs together */
name|int
name|i
decl_stmt|;
comment|/* index over TDs */
name|int
name|ntd
decl_stmt|;
comment|/* number of TDs */
name|int
name|l
decl_stmt|;
comment|/* len of data in current std */
name|int
name|tog
decl_stmt|;
comment|/* current data toggle */
name|int
name|maxpacketsize
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
comment|/* pre computed status for TD */
name|int
name|addr
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|address
decl_stmt|;
comment|/* shortcuts */
name|int
name|endpt
init|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
decl_stmt|;
name|maxpacketsize
operator|=
name|UGETW
argument_list|(
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxpacketsize
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_alloc_std_chain: maxpacketsize = 0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
name|ntd
operator|=
operator|(
name|datalen
operator|+
name|maxpacketsize
operator|-
literal|1
operator|)
operator|/
name|maxpacketsize
operator|-
literal|1
expr_stmt|;
name|tog
operator|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|toggle
expr_stmt|;
if|if
condition|(
name|ntd
operator|%
literal|2
operator|==
literal|1
condition|)
comment|/* toggle for last TD, list of TDs is initialised backwards */
name|tog
operator|^=
literal|1
expr_stmt|;
comment|/* 	 * save the toggle for the first TD of the next transfer so we can 	 * simply copy the value in transfers that transfer all the TDs.  Bulk 	 * with n out of m TDs transferrred have to recompute though. 	 */
name|upipe
operator|->
name|nexttoggle
operator|=
name|tog
operator|^
literal|1
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_alloc_std_chain: addr=%d endpt=%d datalen=%d "
literal|"toggle=%d, nexttoggle=%d, %s%s%s\n"
operator|,
name|addr
operator|,
name|endpt
operator|,
name|datalen
operator|,
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|toggle
operator|,
name|upipe
operator|->
name|nexttoggle
operator|,
name|isread
condition|?
literal|"read"
else|:
literal|"write"
operator|,
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|lowspeed
condition|?
literal|", lowspeed"
else|:
literal|""
operator|,
name|spd
condition|?
literal|", short packet"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
operator|==
literal|0
condition|)
block|{
operator|*
name|rstd
operator|=
operator|*
name|rstdend
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
name|status
operator|=
name|UHCI_TD_SET_ERRCNT
argument_list|(
literal|3
argument_list|)
operator||
name|UHCI_TD_ACTIVE
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|lowspeed
condition|)
name|status
operator||=
name|UHCI_TD_LOWSPEED
expr_stmt|;
if|if
condition|(
name|spd
condition|)
name|status
operator||=
name|UHCI_TD_SPD
expr_stmt|;
comment|/* 	 * create a list of std's, backwards. stdprev contains the std 	 * from the previous iteration. 	 */
for|for
control|(
name|i
operator|=
name|ntd
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|std
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|std
condition|)
block|{
name|uhci_free_std_chain
argument_list|(
name|sc
argument_list|,
name|stdprev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|=
name|stdprev
expr_stmt|;
name|stdprev
operator|=
name|std
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_link
operator|=
name|linkprev
expr_stmt|;
name|linkprev
operator|=
name|std
operator|->
name|physaddr
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_status
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ntd
condition|)
block|{
comment|/* compute length of TD */
comment|/* last TD is 0> l>= maxPacketSize */
name|l
operator|=
name|datalen
operator|%
name|maxpacketsize
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
name|l
operator|=
name|maxpacketsize
expr_stmt|;
operator|*
name|rstdend
operator|=
name|std
expr_stmt|;
comment|/* end of list of TDs */
block|}
else|else
comment|/* all other TDs should be max size */
name|l
operator|=
name|maxpacketsize
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_token
operator|=
name|isread
condition|?
name|UHCI_TD_IN
argument_list|(
name|l
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
name|tog
argument_list|)
else|:
name|UHCI_TD_OUT
argument_list|(
name|l
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
name|tog
argument_list|)
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_buffer
operator|=
name|DMAADDR
argument_list|(
name|dma
argument_list|)
operator|+
name|i
operator|*
name|maxpacketsize
expr_stmt|;
name|tog
operator|^=
literal|1
expr_stmt|;
block|}
operator|*
name|rstd
operator|=
name|stdprev
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_block

begin_function
name|void
name|uhci_free_std_chain
parameter_list|(
name|sc
parameter_list|,
name|std
parameter_list|,
name|stdend
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|stdend
decl_stmt|;
block|{
name|uhci_soft_td_t
modifier|*
name|std_link
decl_stmt|;
comment|/* temp store of next pointer */
comment|/* removes the chain up to (but excluding) the element stdend */
if|if
condition|(
operator|!
name|std
condition|)
ifdef|#
directive|ifdef
name|UHCI_DEBUG
name|panic
argument_list|(
literal|"invalid TD chain to be freed, std=%p"
argument_list|,
name|std
argument_list|)
expr_stmt|;
else|#
directive|else
return|return;
endif|#
directive|endif
for|for
control|(
init|;
name|std
operator|!=
name|stdend
condition|;
name|std
operator|=
name|std_link
control|)
block|{
name|std_link
operator|=
name|std
operator|->
name|td
operator|->
name|link
operator|.
name|std
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|uhci_soft_qh_t
modifier|*
name|uhci_alloc_sqh
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offs
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_freeqhs
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_alloc_sqh: allocating chunk\n"
operator|)
argument_list|)
expr_stmt|;
name|sqh
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uhci_soft_qh_t
argument_list|)
operator|*
name|UHCI_QH_CHUNK
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sqh
condition|)
return|return
name|NULL
return|;
name|err
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|UHCI_QH_SIZE
operator|*
name|UHCI_QH_CHUNK
argument_list|,
name|UHCI_QH_ALIGN
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|free
argument_list|(
name|sqh
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_QH_CHUNK
condition|;
name|i
operator|++
operator|,
name|sqh
operator|++
control|)
block|{
name|offs
operator|=
name|i
operator|*
name|UHCI_QH_SIZE
expr_stmt|;
name|sqh
operator|->
name|physaddr
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|)
operator|+
name|offs
expr_stmt|;
name|sqh
operator|->
name|qh
operator|=
operator|(
name|uhci_qh_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|)
operator|+
name|offs
operator|)
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|sc
operator|->
name|sc_freeqhs
expr_stmt|;
name|sc
operator|->
name|sc_freeqhs
operator|=
name|sqh
expr_stmt|;
block|}
block|}
name|sqh
operator|=
name|sc
operator|->
name|sc_freeqhs
expr_stmt|;
name|sc
operator|->
name|sc_freeqhs
operator|=
name|sqh
operator|->
name|qh
operator|->
name|hlink
expr_stmt|;
name|memset
argument_list|(
name|sqh
operator|->
name|qh
argument_list|,
literal|0
argument_list|,
name|UHCI_QH_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|sqh
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_free_sqh
parameter_list|(
name|sc
parameter_list|,
name|sqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|sqh
condition|)
comment|/* safety net */
ifdef|#
directive|ifdef
name|UHCI_DEBUG
name|panic
argument_list|(
literal|"invalid QH to be freed, sqh=%p"
argument_list|,
name|sqh
argument_list|)
expr_stmt|;
else|#
directive|else
return|return;
endif|#
directive|endif
name|sqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|sc
operator|->
name|sc_freeqhs
expr_stmt|;
name|sc
operator|->
name|sc_freeqhs
operator|=
name|sqh
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate an interrupt information struct.  A free list is kept  * for fast allocation.  */
end_comment

begin_function
name|uhci_intr_info_t
modifier|*
name|uhci_alloc_intr_info
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
name|ii
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|uhci_ii_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
condition|)
name|LIST_REMOVE
argument_list|(
name|ii
argument_list|,
name|list
argument_list|)
expr_stmt|;
else|else
block|{
name|ii
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uhci_intr_info_t
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
name|ii
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|callout_handle_init
argument_list|(
operator|&
name|ii
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ii
return|;
block|}
end_function

begin_function
name|void
name|uhci_free_intr_info
parameter_list|(
name|ii
parameter_list|)
name|uhci_intr_info_t
modifier|*
name|ii
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|ii
condition|)
ifdef|#
directive|ifdef
name|UHCI_DEBUG
name|panic
argument_list|(
literal|"invalid intr info to be freed, ii=%p"
argument_list|,
name|ii
argument_list|)
expr_stmt|;
else|#
directive|else
return|return;
endif|#
directive|endif
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|uhci_ii_free
argument_list|,
name|ii
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* and put on free list */
block|}
end_function

begin_comment
comment|/*  * request and release lock on the frames list  */
end_comment

begin_function
name|void
name|uhci_lock_frames
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|s
init|=
name|splusb
argument_list|()
decl_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_vflock
condition|)
block|{
name|sc
operator|->
name|sc_vflock
operator||=
name|UHCI_WANT_LOCK
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_vflock
argument_list|,
name|PRIBIO
argument_list|,
literal|"uhcqhl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_vflock
operator|=
name|UHCI_HAS_LOCK
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_unlock_frames
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|s
init|=
name|splusb
argument_list|()
decl_stmt|;
name|sc
operator|->
name|sc_vflock
operator|&=
operator|~
name|UHCI_HAS_LOCK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_vflock
operator|&
name|UHCI_WANT_LOCK
condition|)
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_vflock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usbd_methods
name|uhci_device_ctrl_methods
init|=
block|{
name|uhci_device_ctrl_transfer
block|,
name|uhci_device_ctrl_start
block|,
name|uhci_device_ctrl_abort
block|,
name|uhci_device_ctrl_close
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_methods
name|uhci_device_bulk_methods
init|=
block|{
name|uhci_device_bulk_transfer
block|,
name|uhci_device_bulk_start
block|,
name|uhci_device_bulk_abort
block|,
name|uhci_device_bulk_close
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_methods
name|uhci_device_intr_methods
init|=
block|{
name|uhci_device_intr_transfer
block|,
name|uhci_device_intr_start
block|,
name|uhci_device_intr_abort
block|,
name|uhci_device_intr_close
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_methods
name|uhci_device_isoc_methods
init|=
block|{
name|uhci_device_isoc_transfer
block|,
name|uhci_device_isoc_start
block|,
name|uhci_device_isoc_abort
block|,
name|uhci_device_isoc_close
block|,
name|uhci_device_isoc_setbuf
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_methods
name|uhci_root_ctrl_methods
init|=
block|{
name|uhci_root_ctrl_transfer
block|,
name|uhci_root_ctrl_start
block|,
name|uhci_root_ctrl_abort
block|,
name|uhci_root_ctrl_close
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usbd_methods
name|uhci_root_intr_methods
init|=
block|{
name|uhci_root_intr_transfer
block|,
name|uhci_root_intr_start
block|,
name|uhci_root_intr_abort
block|,
name|uhci_root_intr_close
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|usbd_status
name|uhci_open
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
init|=
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_open: pipe=%p, addr=%d, endpt=%d (%d)\n"
operator|,
name|pipe
operator|,
name|pipe
operator|->
name|device
operator|->
name|address
operator|,
name|ed
operator|->
name|bEndpointAddress
operator|,
name|sc
operator|->
name|sc_addr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|->
name|device
operator|->
name|address
operator|==
name|sc
operator|->
name|sc_addr
condition|)
block|{
comment|/* root hub */
switch|switch
condition|(
name|ed
operator|->
name|bEndpointAddress
condition|)
block|{
case|case
name|USB_CONTROL_ENDPOINT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_root_ctrl_methods
expr_stmt|;
break|break;
case|case
name|UE_IN
operator||
name|UHCI_INTR_ENDPT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_root_intr_methods
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
block|}
else|else
block|{
name|upipe
operator|->
name|iinfo
operator|=
name|uhci_alloc_intr_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|iinfo
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|upipe
operator|->
name|nexttoggle
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_CONTROL
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_device_ctrl_methods
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
operator|==
literal|0
condition|)
block|{
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|stat
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|stat
operator|==
literal|0
condition|)
block|{
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
argument_list|)
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|err
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
sizeof|sizeof
argument_list|(
name|usb_device_request_t
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
argument_list|)
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
argument_list|)
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|stat
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
break|break;
case|case
name|UE_INTERRUPT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_device_intr_methods
expr_stmt|;
return|return
operator|(
name|uhci_device_intr_interval
argument_list|(
name|sc
argument_list|,
name|upipe
argument_list|,
name|ed
operator|->
name|bInterval
argument_list|)
operator|)
return|;
case|case
name|UE_ISOCHRONOUS
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_device_isoc_methods
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|iso
operator|.
name|nbuf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
case|case
name|UE_BULK
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|uhci_device_bulk_methods
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
break|break;
block|}
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad
label|:
name|uhci_free_intr_info
argument_list|(
name|upipe
operator|->
name|iinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Control transfers are slightly more complicated as they consist of three  * phases. This subroutine creates the three phases and schedules the chain  */
end_comment

begin_function
name|usbd_status
name|uhci_device_request
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
decl_stmt|;
name|usb_device_request_t
modifier|*
name|req
init|=
operator|&
name|reqh
operator|->
name|request
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|int
name|addr
init|=
name|dev
operator|->
name|address
decl_stmt|;
name|int
name|endpt
init|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
init|=
name|upipe
operator|->
name|iinfo
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|stdend
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|setup
decl_stmt|,
modifier|*
name|stat
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usb_dma_t
modifier|*
name|dmap
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_int32_t
name|ls
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|isread
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_device_request: bmRequestType=0x%02x, bRequest=0x%02x, "
literal|"wValue=0x%04x, wIndex=0x%04x, wLength=%d, addr=%d, endpt=%d\n"
operator|,
name|req
operator|->
name|bmRequestType
operator|,
name|req
operator|->
name|bRequest
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
operator|,
name|addr
operator|,
name|endpt
operator|)
argument_list|)
expr_stmt|;
name|ls
operator|=
name|dev
operator|->
name|lowspeed
condition|?
name|UHCI_TD_LOWSPEED
else|:
literal|0
expr_stmt|;
name|isread
operator|=
name|req
operator|->
name|bmRequestType
operator|&
name|UT_READ
expr_stmt|;
name|datalen
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
expr_stmt|;
name|setup
operator|=
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|setup
expr_stmt|;
name|stat
operator|=
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|stat
expr_stmt|;
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|sqh
expr_stmt|;
name|dmap
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|datadma
expr_stmt|;
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
block|{
comment|/* initialise the data stage */
name|err
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|datalen
argument_list|,
literal|0
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 		 * data toggle starts at 0 with control requests, so first 		 * data packet has toggle 1 		 */
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|toggle
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|uhci_alloc_std_chain
argument_list|(
name|sc
argument_list|,
name|upipe
argument_list|,
name|datalen
argument_list|,
name|isread
argument_list|,
name|reqh
operator|->
name|flags
operator|&
name|USBD_SHORT_XFER_OK
argument_list|,
name|dmap
argument_list|,
operator|&
name|std
argument_list|,
operator|&
name|stdend
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|isread
condition|)
name|memcpy
argument_list|(
name|KERNADDR
argument_list|(
name|dmap
argument_list|)
argument_list|,
name|reqh
operator|->
name|buffer
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|stdend
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|=
name|stat
expr_stmt|;
name|stdend
operator|->
name|td
operator|->
name|td_link
operator|=
name|stat
operator|->
name|physaddr
expr_stmt|;
name|next
operator|=
name|std
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|stat
expr_stmt|;
block|}
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|length
operator|=
name|datalen
expr_stmt|;
comment|/* 	 * initialise the setup stage and link it to either the data stage 	 * or the status stage (in the case where there is no data stage) 	 */
name|setup
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|=
name|next
expr_stmt|;
name|setup
operator|->
name|td
operator|->
name|td_link
operator|=
name|next
operator|->
name|physaddr
expr_stmt|;
name|setup
operator|->
name|td
operator|->
name|td_status
operator|=
name|UHCI_TD_SET_ERRCNT
argument_list|(
literal|3
argument_list|)
operator||
name|ls
operator||
name|UHCI_TD_ACTIVE
expr_stmt|;
name|setup
operator|->
name|td
operator|->
name|td_token
operator|=
name|UHCI_TD_SETUP
argument_list|(
sizeof|sizeof
expr|*
name|req
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|setup
operator|->
name|td
operator|->
name|td_buffer
operator|=
name|DMAADDR
argument_list|(
operator|&
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|KERNADDR
argument_list|(
operator|&
name|upipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|)
argument_list|,
name|req
argument_list|,
sizeof|sizeof
expr|*
name|req
argument_list|)
expr_stmt|;
comment|/* initialise the status stage */
name|stat
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|=
literal|0
expr_stmt|;
name|stat
operator|->
name|td
operator|->
name|td_link
operator|=
name|UHCI_PTR_T
expr_stmt|;
name|stat
operator|->
name|td
operator|->
name|td_status
operator|=
name|UHCI_TD_SET_ERRCNT
argument_list|(
literal|3
argument_list|)
operator||
name|ls
operator||
name|UHCI_TD_ACTIVE
operator||
name|UHCI_TD_IOC
expr_stmt|;
name|stat
operator|->
name|td
operator|->
name|td_token
operator|=
name|isread
condition|?
name|UHCI_TD_OUT
argument_list|(
literal|0
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
else|:
name|UHCI_TD_IN
argument_list|(
literal|0
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stat
operator|->
name|td
operator|->
name|td_buffer
operator|=
literal|0
expr_stmt|;
comment|/* initialise interrupt info. */
name|ii
operator|->
name|reqh
operator|=
name|reqh
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
name|setup
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|stat
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|callout_handle_init
argument_list|(
operator|&
name|ii
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|ii
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UHCI_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
name|uhci_dump_tds
argument_list|(
name|setup
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sqh
operator|->
name|qh
operator|->
name|elink
operator|=
name|setup
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|setup
operator|->
name|physaddr
expr_stmt|;
name|sqh
operator|->
name|intr_info
operator|=
name|ii
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|uhci_add_ctrl
argument_list|(
name|sc
argument_list|,
name|sqh
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|,
name|ii
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqh
operator|->
name|timeout
operator|&&
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|usb_timeout
argument_list|(
name|uhci_timeout
argument_list|,
name|ii
argument_list|,
name|MS_TO_TICKS
argument_list|(
name|reqh
operator|->
name|timeout
argument_list|)
argument_list|,
name|ii
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_ctrl_transfer
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|err
operator|)
return|;
else|else
return|return
operator|(
name|uhci_device_ctrl_start
argument_list|(
name|reqh
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_ctrl_start
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|reqh
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|reqh
operator|->
name|isreq
condition|)
name|panic
argument_list|(
literal|"uhci_device_ctrl_start: not a request\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|uhci_device_request
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
name|uhci_waitintr
argument_list|(
name|sc
argument_list|,
name|reqh
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_device_ctrl_abort
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
comment|/* XXX inactivate */
name|usb_delay_ms
argument_list|(
name|reqh
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* make sure it is done */
comment|/* XXX call done */
block|}
end_function

begin_function
name|void
name|uhci_device_ctrl_close
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|uhci_free_intr_info
argument_list|(
name|upipe
operator|->
name|iinfo
argument_list|)
expr_stmt|;
comment|/* XXX free other resources */
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_bulk_transfer
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|err
operator|)
return|;
else|else
return|return
operator|(
name|uhci_device_bulk_start
argument_list|(
name|reqh
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_bulk_start
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
init|=
name|upipe
operator|->
name|iinfo
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|stdend
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usb_dma_t
modifier|*
name|dmap
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|datalen
decl_stmt|,
name|isread
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_device_bulk_start: reqh=%p buf=%p datalen=%d "
literal|"flags=%d\n"
operator|,
name|reqh
operator|,
name|reqh
operator|->
name|buffer
operator|,
name|reqh
operator|->
name|length
operator|,
name|reqh
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqh
operator|->
name|isreq
condition|)
name|panic
argument_list|(
literal|"uhci_device_bulk_start: a request\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqh
operator|->
name|length
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|datalen
operator|=
name|reqh
operator|->
name|length
expr_stmt|;
name|dmap
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|datadma
expr_stmt|;
name|isread
operator|=
name|reqh
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|UE_IN
expr_stmt|;
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|isread
operator|=
name|isread
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|length
operator|=
name|datalen
expr_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|datalen
argument_list|,
literal|0
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|toggle
operator|=
name|upipe
operator|->
name|nexttoggle
expr_stmt|;
name|err
operator|=
name|uhci_alloc_std_chain
argument_list|(
name|sc
argument_list|,
name|upipe
argument_list|,
name|datalen
argument_list|,
name|isread
argument_list|,
name|reqh
operator|->
name|flags
operator|&
name|USBD_SHORT_XFER_OK
argument_list|,
name|dmap
argument_list|,
operator|&
name|std
argument_list|,
operator|&
name|stdend
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|stdend
operator|->
name|td
operator|->
name|td_status
operator||=
name|UHCI_TD_IOC
expr_stmt|;
if|if
condition|(
operator|!
name|isread
condition|)
name|memcpy
argument_list|(
name|KERNADDR
argument_list|(
name|dmap
argument_list|)
argument_list|,
name|reqh
operator|->
name|buffer
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UHCI_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_device_bulk_start: xfer\n"
operator|)
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|std
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Set up interrupt info. */
name|ii
operator|->
name|reqh
operator|=
name|reqh
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
name|std
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|stdend
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|callout_handle_init
argument_list|(
operator|&
name|ii
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|ii
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|sqh
operator|->
name|qh
operator|->
name|elink
operator|=
name|std
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|std
operator|->
name|physaddr
expr_stmt|;
name|sqh
operator|->
name|intr_info
operator|=
name|ii
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|uhci_add_bulk
argument_list|(
name|sc
argument_list|,
name|sqh
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|,
name|ii
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqh
operator|->
name|timeout
operator|&&
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|usb_timeout
argument_list|(
name|uhci_timeout
argument_list|,
name|ii
argument_list|,
name|MS_TO_TICKS
argument_list|(
name|reqh
operator|->
name|timeout
argument_list|)
argument_list|,
name|ii
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_device_bulk_abort
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
comment|/* XXX inactivate */
name|usb_delay_ms
argument_list|(
name|reqh
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* make sure it is done */
comment|/* XXX call done */
block|}
end_function

begin_function
name|void
name|uhci_device_bulk_close
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|sqh
argument_list|)
expr_stmt|;
name|uhci_free_intr_info
argument_list|(
name|upipe
operator|->
name|iinfo
argument_list|)
expr_stmt|;
comment|/* XXX free other resources */
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_intr_transfer
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|err
operator|)
return|;
else|else
return|return
operator|(
name|uhci_device_intr_start
argument_list|(
name|reqh
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_intr_start
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|uhci_intr_info_t
modifier|*
name|ii
init|=
name|upipe
operator|->
name|iinfo
decl_stmt|;
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|stdend
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usb_dma_t
modifier|*
name|dmap
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|datalen
decl_stmt|,
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_device_intr_start: reqh=%p buf=%p datalen=%d "
literal|"flags=%d\n"
operator|,
name|reqh
operator|,
name|reqh
operator|->
name|buffer
operator|,
name|reqh
operator|->
name|length
operator|,
name|reqh
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqh
operator|->
name|isreq
condition|)
name|panic
argument_list|(
literal|"uhci_device_intr_start: a request\n"
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|reqh
operator|->
name|length
expr_stmt|;
name|dmap
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|datadma
expr_stmt|;
if|if
condition|(
name|datalen
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
comment|/* XXX should it be? */
name|err
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|datalen
argument_list|,
literal|0
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|toggle
operator|=
name|upipe
operator|->
name|nexttoggle
expr_stmt|;
name|err
operator|=
name|uhci_alloc_std_chain
argument_list|(
name|sc
argument_list|,
name|upipe
argument_list|,
name|datalen
argument_list|,
literal|1
argument_list|,
name|reqh
operator|->
name|flags
operator|&
name|USBD_SHORT_XFER_OK
argument_list|,
name|dmap
argument_list|,
operator|&
name|std
argument_list|,
operator|&
name|stdend
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|stdend
operator|->
name|td
operator|->
name|td_status
operator||=
name|UHCI_TD_IOC
expr_stmt|;
ifdef|#
directive|ifdef
name|UHCI_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_device_intr_start: xfer\n"
operator|)
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|std
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
comment|/* Set up interrupt info. */
name|ii
operator|->
name|reqh
operator|=
name|reqh
expr_stmt|;
name|ii
operator|->
name|stdstart
operator|=
name|std
expr_stmt|;
name|ii
operator|->
name|stdend
operator|=
name|stdend
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|ii
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_device_intr_start: qhs[0]=%p\n"
operator|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|npoll
condition|;
name|i
operator|++
control|)
block|{
name|sqh
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|elink
operator|=
name|std
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|std
operator|->
name|physaddr
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_device_intr_abort
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_device_intr_abort: reqh=%p\n"
operator|,
name|reqh
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqh
operator|->
name|pipe
operator|->
name|intrreqh
operator|==
name|reqh
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_device_intr_abort: remove\n"
operator|)
argument_list|)
expr_stmt|;
name|reqh
operator|->
name|pipe
operator|->
name|intrreqh
operator|=
literal|0
expr_stmt|;
comment|/* make sure it is done */
name|usb_delay_ms
argument_list|(
name|reqh
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|uhci_device_intr_close
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|npoll
decl_stmt|;
name|upipe
operator|->
name|iinfo
operator|->
name|stdstart
operator|=
literal|0
expr_stmt|;
comment|/* inactive */
comment|/* Unlink descriptors from controller data structures. */
name|npoll
operator|=
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|npoll
expr_stmt|;
name|uhci_lock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
name|uhci_remove_intr
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
operator|->
name|pos
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|uhci_unlock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*  	 * We now have to wait for any activity on the physical 	 * descriptors to stop. 	 */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
name|uhci_free_sqh
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|upipe
operator|->
name|iinfo
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* remove from active list */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|uhci_free_intr_info
argument_list|(
name|upipe
operator|->
name|iinfo
argument_list|)
expr_stmt|;
comment|/* XXX free other resources */
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_isoc_transfer
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|reqh
operator|->
name|pipe
decl_stmt|;
ifdef|#
directive|ifdef
name|UHCI_DEBUG
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_device_isoc_transfer: sc=%p\n"
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|upipe
operator|->
name|u
operator|.
name|iso
operator|.
name|bufsize
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
comment|/* XXX copy data */
return|return
operator|(
name|USBD_XXX
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_isoc_start
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
return|return
operator|(
name|USBD_XXX
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_device_isoc_abort
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
comment|/* XXX Can't abort a single request. */
block|}
end_function

begin_function
name|void
name|uhci_device_isoc_close
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|struct
name|iso
modifier|*
name|iso
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Make sure all TDs are marked as inactive. 	 * Wait for completion. 	 * Unschedule. 	 * Deallocate. 	 */
name|iso
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|iso
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
name|iso
operator|->
name|stds
index|[
name|i
index|]
operator|->
name|td
operator|->
name|td_status
operator|&=
operator|~
name|UHCI_TD_ACTIVE
expr_stmt|;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* wait for completion */
name|uhci_lock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|vstd
decl_stmt|;
name|std
operator|=
name|iso
operator|->
name|stds
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|vstd
operator|=
name|sc
operator|->
name|sc_vframes
index|[
name|i
operator|%
name|UHCI_VFRAMELIST_COUNT
index|]
operator|.
name|htd
init|;
name|vstd
operator|&&
name|vstd
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|!=
name|std
condition|;
name|vstd
operator|=
name|vstd
operator|->
name|td
operator|->
name|link
operator|.
name|std
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|vstd
condition|)
block|{
comment|/*panic*/
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_device_isoc_close: %p not found\n"
operator|,
name|std
operator|)
argument_list|)
expr_stmt|;
name|uhci_unlock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|vstd
operator|->
name|td
operator|->
name|link
operator|=
name|std
operator|->
name|td
operator|->
name|link
expr_stmt|;
name|vstd
operator|->
name|td
operator|->
name|td_link
operator|=
name|std
operator|->
name|td
operator|->
name|td_link
expr_stmt|;
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
block|}
name|uhci_unlock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iso
operator|->
name|nbuf
condition|;
name|i
operator|++
control|)
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
operator|&
name|iso
operator|->
name|bufs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso
operator|->
name|stds
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso
operator|->
name|bufs
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
comment|/* XXX what else? */
block|}
end_function

begin_function
name|usbd_status
name|uhci_device_isoc_setbuf
parameter_list|(
name|pipe
parameter_list|,
name|bufsize
parameter_list|,
name|nbuf
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
name|u_int
name|bufsize
decl_stmt|;
name|u_int
name|nbuf
decl_stmt|;
block|{
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|int
name|addr
init|=
name|upipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|address
decl_stmt|;
name|int
name|endpt
init|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
decl_stmt|;
name|int
name|isread
init|=
name|upipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|UE_IN
decl_stmt|;
name|struct
name|iso
modifier|*
name|iso
decl_stmt|;
name|int
name|i
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
comment|/*  	 * For simplicity the number of buffers must fit nicely in the frame 	 * list. 	 */
if|if
condition|(
name|UHCI_VFRAMELIST_COUNT
operator|%
name|nbuf
operator|!=
literal|0
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|iso
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|iso
expr_stmt|;
name|iso
operator|->
name|bufsize
operator|=
name|bufsize
expr_stmt|;
name|iso
operator|->
name|nbuf
operator|=
name|nbuf
expr_stmt|;
comment|/* Allocate memory for buffers. */
name|iso
operator|->
name|bufs
operator|=
name|malloc
argument_list|(
name|nbuf
operator|*
sizeof|sizeof
argument_list|(
name|usb_dma_t
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|iso
operator|->
name|stds
operator|=
name|malloc
argument_list|(
name|UHCI_VFRAMELIST_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|uhci_soft_td_t
operator|*
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|bufsize
argument_list|,
literal|0
argument_list|,
operator|&
name|iso
operator|->
name|bufs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|nbuf
operator|=
name|i
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
block|}
comment|/* Allocate the TDs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|iso
operator|->
name|stds
index|[
name|i
index|]
operator|=
name|uhci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso
operator|->
name|stds
index|[
name|i
index|]
operator|==
literal|0
condition|)
goto|goto
name|bad2
goto|;
block|}
comment|/* XXX check schedule */
comment|/* XXX interrupts */
comment|/* Insert TDs into schedule, all marked inactive. */
name|uhci_lock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|vstd
decl_stmt|;
name|std
operator|=
name|iso
operator|->
name|stds
index|[
name|i
index|]
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_status
operator|=
name|UHCI_TD_IOS
expr_stmt|;
comment|/* iso, inactive */
name|std
operator|->
name|td
operator|->
name|td_token
operator|=
name|isread
condition|?
name|UHCI_TD_IN
argument_list|(
literal|0
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
else|:
name|UHCI_TD_OUT
argument_list|(
literal|0
argument_list|,
name|endpt
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_buffer
operator|=
name|DMAADDR
argument_list|(
operator|&
name|iso
operator|->
name|bufs
index|[
name|i
operator|%
name|nbuf
index|]
argument_list|)
expr_stmt|;
name|vstd
operator|=
name|sc
operator|->
name|sc_vframes
index|[
name|i
operator|%
name|UHCI_VFRAMELIST_COUNT
index|]
operator|.
name|htd
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|link
operator|=
name|vstd
operator|->
name|td
operator|->
name|link
expr_stmt|;
name|std
operator|->
name|td
operator|->
name|td_link
operator|=
name|vstd
operator|->
name|td
operator|->
name|td_link
expr_stmt|;
name|vstd
operator|->
name|td
operator|->
name|link
operator|.
name|std
operator|=
name|std
expr_stmt|;
name|vstd
operator|->
name|td
operator|->
name|td_link
operator|=
name|std
operator|->
name|physaddr
expr_stmt|;
block|}
name|uhci_unlock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad2
label|:
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|uhci_free_std
argument_list|(
name|sc
argument_list|,
name|iso
operator|->
name|stds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bad1
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
operator|&
name|iso
operator|->
name|bufs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso
operator|->
name|stds
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso
operator|->
name|bufs
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set interval for interrupt transfer */
end_comment

begin_function
name|usbd_status
name|uhci_device_intr_interval
parameter_list|(
name|sc
parameter_list|,
name|upipe
parameter_list|,
name|ival
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
decl_stmt|;
name|int
name|ival
decl_stmt|;
block|{
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|int
name|i
decl_stmt|,
name|npoll
decl_stmt|,
name|s
decl_stmt|;
name|u_int
name|bestbw
decl_stmt|,
name|bw
decl_stmt|,
name|bestoffs
decl_stmt|,
name|offs
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_setintr: pipe=%p\n"
operator|,
name|upipe
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ival
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_setintr: 0 interval\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
if|if
condition|(
name|ival
operator|>
name|UHCI_VFRAMELIST_COUNT
condition|)
name|ival
operator|=
name|UHCI_VFRAMELIST_COUNT
expr_stmt|;
name|npoll
operator|=
operator|(
name|UHCI_VFRAMELIST_COUNT
operator|+
name|ival
operator|-
literal|1
operator|)
operator|/
name|ival
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_setintr: ival=%d npoll=%d\n"
operator|,
name|ival
operator|,
name|npoll
operator|)
argument_list|)
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|npoll
operator|=
name|npoll
expr_stmt|;
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
operator|=
name|malloc
argument_list|(
name|npoll
operator|*
sizeof|sizeof
argument_list|(
name|uhci_soft_qh_t
operator|*
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/*  	 * Figure out which offset in the schedule that has most 	 * bandwidth left over. 	 */
define|#
directive|define
name|MOD
parameter_list|(
name|i
parameter_list|)
value|((i)& (UHCI_VFRAMELIST_COUNT-1))
for|for
control|(
name|bestoffs
operator|=
name|offs
operator|=
literal|0
operator|,
name|bestbw
operator|=
operator|~
literal|0
init|;
name|offs
operator|<
name|ival
condition|;
name|offs
operator|++
control|)
block|{
for|for
control|(
name|bw
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
name|bw
operator|+=
name|sc
operator|->
name|sc_vframes
index|[
name|MOD
argument_list|(
name|i
operator|*
name|ival
operator|+
name|offs
argument_list|)
index|]
operator|.
name|bandwidth
expr_stmt|;
if|if
condition|(
name|bw
operator|<
name|bestbw
condition|)
block|{
name|bestbw
operator|=
name|bw
expr_stmt|;
name|bestoffs
operator|=
name|offs
expr_stmt|;
block|}
block|}
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uhci_setintr: bw=%d offs=%d\n"
operator|,
name|bestbw
operator|,
name|bestoffs
operator|)
argument_list|)
expr_stmt|;
name|upipe
operator|->
name|iinfo
operator|->
name|stdstart
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
block|{
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
operator|=
name|sqh
operator|=
name|uhci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|elink
operator|=
literal|0
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_elink
operator|=
name|UHCI_PTR_T
expr_stmt|;
name|sqh
operator|->
name|pos
operator|=
name|MOD
argument_list|(
name|i
operator|*
name|ival
operator|+
name|bestoffs
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|intr_info
operator|=
name|upipe
operator|->
name|iinfo
expr_stmt|;
block|}
undef|#
directive|undef
name|MOD
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|,
name|upipe
operator|->
name|iinfo
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|uhci_lock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enter QHs into the controller data structures. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoll
condition|;
name|i
operator|++
control|)
name|uhci_add_intr
argument_list|(
name|sc
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
operator|->
name|pos
argument_list|,
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|qhs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|uhci_unlock_frames
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uhci_setintr: returns %p\n"
operator|,
name|upipe
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_root_ctrl_transfer
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|err
operator|)
return|;
else|else
return|return
operator|(
name|uhci_root_ctrl_start
argument_list|(
name|reqh
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_root_ctrl_start
parameter_list|(
name|usbd_request_handle
name|reqh
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|reqh
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
if|if
condition|(
operator|!
name|reqh
operator|->
name|isreq
condition|)
name|panic
argument_list|(
literal|"uhci_root_ctrl_transfer: not a request\n"
argument_list|)
expr_stmt|;
name|reqh
operator|->
name|status
operator|=
name|uhci_roothub_ctrl_transfer
argument_list|(
name|sc
argument_list|,
operator|&
name|reqh
operator|->
name|request
argument_list|,
name|reqh
operator|->
name|buffer
argument_list|,
operator|&
name|reqh
operator|->
name|actlen
argument_list|)
expr_stmt|;
name|reqh
operator|->
name|xfercb
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
name|usb_start_next
argument_list|(
name|reqh
operator|->
name|pipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_root_ctrl_abort
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
comment|/* Nothing to do, all transfers are syncronous. */
block|}
end_function

begin_function
name|void
name|uhci_root_ctrl_close
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|usb_untimeout
argument_list|(
name|uhci_root_intr_sim
argument_list|,
name|pipe
operator|->
name|intrreqh
argument_list|,
name|pipe
operator|->
name|intrreqh
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_root_ctrl_close\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_root_intr_transfer
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|err
operator|)
return|;
else|else
return|return
operator|(
name|uhci_root_intr_start
argument_list|(
name|reqh
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Start a transfer on the root interrupt pipe */
end_comment

begin_function
name|usbd_status
name|uhci_root_intr_start
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|usbd_pipe_handle
name|pipe
init|=
name|reqh
operator|->
name|pipe
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|usb_dma_t
modifier|*
name|dmap
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_root_intr_transfer: reqh=%p buf=%p datalen=%d "
literal|"flags=%d\n"
operator|,
name|reqh
operator|,
name|reqh
operator|->
name|buffer
operator|,
name|reqh
operator|->
name|length
operator|,
name|reqh
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|reqh
operator|->
name|length
expr_stmt|;
name|dmap
operator|=
operator|&
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|datadma
expr_stmt|;
if|if
condition|(
name|datalen
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
comment|/* XXX should it be? */
name|err
operator|=
name|usb_allocmem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|datalen
argument_list|,
literal|0
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|sc
operator|->
name|sc_ival
operator|=
name|MS_TO_TICKS
argument_list|(
name|reqh
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bInterval
argument_list|)
expr_stmt|;
name|usb_timeout
argument_list|(
name|uhci_root_intr_sim
argument_list|,
name|reqh
argument_list|,
name|sc
operator|->
name|sc_ival
argument_list|,
name|reqh
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a root interrupt request. */
end_comment

begin_function
name|void
name|uhci_root_intr_abort
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|usb_untimeout
argument_list|(
name|uhci_root_intr_sim
argument_list|,
name|reqh
argument_list|,
name|reqh
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close the root interrupt pipe. */
end_comment

begin_function
name|void
name|uhci_root_intr_close
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|usb_untimeout
argument_list|(
name|uhci_root_intr_sim
argument_list|,
name|pipe
operator|->
name|intrreqh
argument_list|,
name|pipe
operator|->
name|intrreqh
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is executed periodically and simulates interrupts  * from the root controller interrupt pipe for port status change.  */
end_comment

begin_function
name|void
name|uhci_root_intr_sim
parameter_list|(
name|priv
parameter_list|)
name|void
modifier|*
name|priv
decl_stmt|;
block|{
name|usbd_request_handle
name|reqh
init|=
name|priv
decl_stmt|;
name|usbd_pipe_handle
name|pipe
init|=
name|reqh
operator|->
name|pipe
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
operator|(
name|uhci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|struct
name|uhci_pipe
modifier|*
name|upipe
init|=
operator|(
expr|struct
name|uhci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|actlen
decl_stmt|;
name|u_int8_t
modifier|*
name|buf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|buf
operator|=
name|KERNADDR
argument_list|(
operator|&
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|datadma
argument_list|)
expr_stmt|;
name|err
operator|=
name|uhci_roothub_intr_transfer
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|reqh
operator|->
name|length
argument_list|,
operator|&
name|actlen
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|reqh
operator|->
name|status
operator|=
name|err
expr_stmt|;
block|}
else|else
block|{
name|reqh
operator|->
name|actlen
operator|=
name|actlen
expr_stmt|;
name|reqh
operator|->
name|status
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|reqh
operator|->
name|xfercb
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reqh
operator|->
name|pipe
operator|->
name|intrreqh
operator|==
name|reqh
condition|)
block|{
name|usb_timeout
argument_list|(
name|uhci_root_intr_sim
argument_list|,
name|reqh
argument_list|,
name|sc
operator|->
name|sc_ival
argument_list|,
name|reqh
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usb_freemem
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
operator|&
name|upipe
operator|->
name|u
operator|.
name|intr
operator|.
name|datadma
argument_list|)
expr_stmt|;
name|usb_start_next
argument_list|(
name|reqh
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add control QH, called at splusb(). */
end_comment

begin_function
name|void
name|uhci_add_ctrl
parameter_list|(
name|sc
parameter_list|,
name|sqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
block|{
name|uhci_qh_t
modifier|*
name|eqh
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_add_ctrl: sqh=%p\n"
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
name|eqh
operator|=
name|sc
operator|->
name|sc_ctl_end
operator|->
name|qh
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|eqh
operator|->
name|hlink
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|eqh
operator|->
name|qh_hlink
expr_stmt|;
name|eqh
operator|->
name|hlink
operator|=
name|sqh
expr_stmt|;
name|eqh
operator|->
name|qh_hlink
operator|=
name|sqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_Q
expr_stmt|;
name|sc
operator|->
name|sc_ctl_end
operator|=
name|sqh
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove control QH, called at splusb(). */
end_comment

begin_function
name|void
name|uhci_remove_ctrl
parameter_list|(
name|sc
parameter_list|,
name|sqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
block|{
name|uhci_soft_qh_t
modifier|*
name|pqh
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_remove_ctrl: sqh=%p\n"
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pqh
operator|=
name|sc
operator|->
name|sc_ctl_start
init|;
name|pqh
operator|->
name|qh
operator|->
name|hlink
operator|!=
name|sqh
condition|;
name|pqh
operator|=
name|pqh
operator|->
name|qh
operator|->
name|hlink
control|)
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|||
name|defined
argument_list|(
name|UHCI_DEBUG
argument_list|)
if|if
condition|(
name|pqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|&
name|UHCI_PTR_T
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uhci_remove_ctrl: QH not found\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
name|pqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|sqh
operator|->
name|qh
operator|->
name|hlink
expr_stmt|;
name|pqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|sqh
operator|->
name|qh
operator|->
name|qh_hlink
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ctl_end
operator|==
name|sqh
condition|)
name|sc
operator|->
name|sc_ctl_end
operator|=
name|pqh
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add bulk QH, called at splusb(). */
end_comment

begin_function
name|void
name|uhci_add_bulk
parameter_list|(
name|sc
parameter_list|,
name|sqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
block|{
name|uhci_qh_t
modifier|*
name|eqh
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_add_bulk: sqh=%p\n"
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
name|eqh
operator|=
name|sc
operator|->
name|sc_bulk_end
operator|->
name|qh
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|eqh
operator|->
name|hlink
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|eqh
operator|->
name|qh_hlink
expr_stmt|;
name|eqh
operator|->
name|hlink
operator|=
name|sqh
expr_stmt|;
name|eqh
operator|->
name|qh_hlink
operator|=
name|sqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_Q
expr_stmt|;
name|sc
operator|->
name|sc_bulk_end
operator|=
name|sqh
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove bulk QH, called at splusb(). */
end_comment

begin_function
name|void
name|uhci_remove_bulk
parameter_list|(
name|sc
parameter_list|,
name|sqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
block|{
name|uhci_soft_qh_t
modifier|*
name|pqh
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"uhci_remove_bulk: sqh=%p\n"
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pqh
operator|=
name|sc
operator|->
name|sc_bulk_start
init|;
name|pqh
operator|->
name|qh
operator|->
name|hlink
operator|!=
name|sqh
condition|;
name|pqh
operator|=
name|pqh
operator|->
name|qh
operator|->
name|hlink
control|)
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
if|if
condition|(
name|pqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|&
name|UHCI_PTR_T
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_remove_bulk: QH not found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
name|pqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|sqh
operator|->
name|qh
operator|->
name|hlink
expr_stmt|;
name|pqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|sqh
operator|->
name|qh
operator|->
name|qh_hlink
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bulk_end
operator|==
name|sqh
condition|)
name|sc
operator|->
name|sc_bulk_end
operator|=
name|pqh
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add interrupt QH, called with vflock. */
end_comment

begin_function
name|void
name|uhci_add_intr
parameter_list|(
name|sc
parameter_list|,
name|pos
parameter_list|,
name|sqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
block|{
name|struct
name|uhci_vframe
modifier|*
name|vf
init|=
operator|&
name|sc
operator|->
name|sc_vframes
index|[
name|pos
index|]
decl_stmt|;
name|uhci_qh_t
modifier|*
name|eqh
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"uhci_add_intr: pos=%d sqh=%p\n"
operator|,
name|pos
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
name|eqh
operator|=
name|vf
operator|->
name|eqh
operator|->
name|qh
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|eqh
operator|->
name|hlink
expr_stmt|;
name|sqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|eqh
operator|->
name|qh_hlink
expr_stmt|;
name|eqh
operator|->
name|hlink
operator|=
name|sqh
expr_stmt|;
name|eqh
operator|->
name|qh_hlink
operator|=
name|sqh
operator|->
name|physaddr
operator||
name|UHCI_PTR_Q
expr_stmt|;
name|vf
operator|->
name|eqh
operator|=
name|sqh
expr_stmt|;
name|vf
operator|->
name|bandwidth
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove interrupt QH, called with vflock. */
end_comment

begin_function
name|void
name|uhci_remove_intr
parameter_list|(
name|sc
parameter_list|,
name|pos
parameter_list|,
name|sqh
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
block|{
name|struct
name|uhci_vframe
modifier|*
name|vf
init|=
operator|&
name|sc
operator|->
name|sc_vframes
index|[
name|pos
index|]
decl_stmt|;
name|uhci_soft_qh_t
modifier|*
name|pqh
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"uhci_remove_intr: pos=%d sqh=%p\n"
operator|,
name|pos
operator|,
name|sqh
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pqh
operator|=
name|vf
operator|->
name|hqh
init|;
name|pqh
operator|->
name|qh
operator|->
name|hlink
operator|!=
name|sqh
condition|;
name|pqh
operator|=
name|pqh
operator|->
name|qh
operator|->
name|hlink
control|)
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
if|if
condition|(
name|pqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|&
name|UHCI_PTR_T
condition|)
block|{
name|printf
argument_list|(
literal|"uhci_remove_intr: QH not found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
name|pqh
operator|->
name|qh
operator|->
name|hlink
operator|=
name|sqh
operator|->
name|qh
operator|->
name|hlink
expr_stmt|;
name|pqh
operator|->
name|qh
operator|->
name|qh_hlink
operator|=
name|sqh
operator|->
name|qh
operator|->
name|qh_hlink
expr_stmt|;
if|if
condition|(
name|vf
operator|->
name|eqh
operator|==
name|sqh
condition|)
name|vf
operator|->
name|eqh
operator|=
name|pqh
expr_stmt|;
name|vf
operator|->
name|bandwidth
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The simulated root hub  */
end_comment

begin_comment
comment|/* Data structures */
end_comment

begin_decl_stmt
name|usb_device_descriptor_t
name|uhci_devd
init|=
block|{
name|USB_DEVICE_DESCRIPTOR_SIZE
block|,
name|UDESC_DEVICE
block|,
comment|/* type */
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* USB version */
name|UCLASS_HUB
block|,
comment|/* class */
name|USUBCLASS_HUB
block|,
comment|/* subclass */
literal|0
block|,
comment|/* protocol */
literal|64
block|,
comment|/* max packet */
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* device id */
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* string indicies */
literal|1
comment|/* # of configurations */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usb_config_descriptor_t
name|uhci_confd
init|=
block|{
name|USB_CONFIG_DESCRIPTOR_SIZE
block|,
name|UDESC_CONFIG
block|,
block|{
name|USB_CONFIG_DESCRIPTOR_SIZE
operator|+
name|USB_INTERFACE_DESCRIPTOR_SIZE
operator|+
name|USB_ENDPOINT_DESCRIPTOR_SIZE
block|}
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|UC_SELF_POWERED
block|,
literal|0
comment|/* max power */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usb_interface_descriptor_t
name|uhci_ifcd
init|=
block|{
name|USB_INTERFACE_DESCRIPTOR_SIZE
block|,
name|UDESC_INTERFACE
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
name|UCLASS_HUB
block|,
name|USUBCLASS_HUB
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usb_endpoint_descriptor_t
name|uhci_endpd
init|=
block|{
name|USB_ENDPOINT_DESCRIPTOR_SIZE
block|,
name|UDESC_ENDPOINT
block|,
name|UE_IN
operator||
name|UHCI_INTR_ENDPT
block|,
name|UE_INTERRUPT
block|,
block|{
literal|8
block|}
block|,
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usb_hub_descriptor_t
name|uhci_hubd_piix
init|=
block|{
name|USB_HUB_DESCRIPTOR_SIZE
block|,
name|UDESC_HUB
block|,
literal|2
block|,
block|{
name|UHD_PWR_NO_SWITCH
operator||
name|UHD_OC_INDIVIDUAL
block|,
literal|0
block|}
block|,
literal|50
block|,
comment|/* power on to power good */
literal|0
block|,
block|{
literal|0x00
block|}
block|,
comment|/* both ports are removable */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * creates the UNICODE-ified string descriptor for the root hub  * returns the length copied  */
end_comment

begin_function
name|int
name|uhci_roothub_string_descriptor
parameter_list|(
name|sd
parameter_list|,
name|datalen
parameter_list|,
name|string
parameter_list|)
name|usb_string_descriptor_t
modifier|*
name|sd
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|datalen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sd
operator|->
name|bLength
operator|=
literal|2
operator|*
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|datalen
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sd
operator|->
name|bDescriptorType
operator|=
name|UDESC_STRING
expr_stmt|;
name|datalen
operator|-=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string
index|[
name|i
index|]
operator|&&
name|datalen
operator|>
literal|1
condition|;
name|i
operator|++
operator|,
name|datalen
operator|-=
literal|2
control|)
name|USETW2
argument_list|(
name|sd
operator|->
name|bString
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|*
name|i
operator|+
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* function handling all requests for the root hub */
end_comment

begin_function
name|usbd_status
name|uhci_roothub_ctrl_transfer
parameter_list|(
name|sc
parameter_list|,
name|req
parameter_list|,
name|buf
parameter_list|,
name|actlen
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|usb_device_request_t
modifier|*
name|req
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|actlen
decl_stmt|;
block|{
name|int
name|port
decl_stmt|;
comment|/* port number */
name|int
name|x
decl_stmt|;
comment|/* temp storage for read register */
name|int
name|datalen
decl_stmt|,
name|value
decl_stmt|,
name|index
decl_stmt|;
comment|/* values in request */
name|int
name|l
decl_stmt|;
comment|/* temp storage for length to be copied */
operator|*
name|actlen
operator|=
literal|0
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|12
argument_list|,
operator|(
literal|"uhci_root_ctrl_control type=0x%02x request=%02x\n"
operator|,
name|req
operator|->
name|bmRequestType
operator|,
name|req
operator|->
name|bRequest
operator|)
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
expr_stmt|;
name|value
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
expr_stmt|;
name|index
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
expr_stmt|;
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) | ((y)<< 8))
switch|switch
condition|(
name|C
argument_list|(
name|req
operator|->
name|bRequest
argument_list|,
name|req
operator|->
name|bmRequestType
argument_list|)
condition|)
block|{
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
comment|/*  		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops 		 * for the integrated root hub. 		 */
break|break;
case|case
name|C
argument_list|(
name|UR_GET_CONFIG
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
if|if
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
name|sc
operator|->
name|sc_conf
expr_stmt|;
operator|*
name|actlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uhci_root_ctrl_control wValue=0x%04x\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
operator|>>
literal|8
condition|)
block|{
case|case
name|UDESC_DEVICE
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|USBD_IOERROR
return|;
block|}
operator|*
name|actlen
operator|=
name|l
operator|=
name|min
argument_list|(
name|datalen
argument_list|,
name|USB_DEVICE_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_devd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESC_CONFIG
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|USBD_IOERROR
return|;
block|}
operator|*
name|actlen
operator|=
name|l
operator|=
name|min
argument_list|(
name|datalen
argument_list|,
name|USB_CONFIG_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_confd
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|l
expr_stmt|;
name|datalen
operator|-=
name|l
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|datalen
argument_list|,
name|USB_INTERFACE_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
operator|*
name|actlen
operator|+=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_ifcd
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|l
expr_stmt|;
name|datalen
operator|-=
name|l
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|datalen
argument_list|,
name|USB_ENDPOINT_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
operator|*
name|actlen
operator|+=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_endpd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESC_STRING
case|:
if|if
condition|(
name|datalen
operator|==
literal|0
condition|)
break|break;
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
literal|0
expr_stmt|;
operator|*
name|actlen
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
case|case
literal|1
case|:
comment|/* Vendor */
operator|*
name|actlen
operator|=
name|uhci_roothub_string_descriptor
argument_list|(
name|buf
argument_list|,
name|datalen
argument_list|,
name|sc
operator|->
name|sc_vendor
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Product */
operator|*
name|actlen
operator|=
name|uhci_roothub_string_descriptor
argument_list|(
name|buf
argument_list|,
name|datalen
argument_list|,
literal|"UHCI root hub"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
return|return
name|USBD_IOERROR
return|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_INTERFACE
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
if|if
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
literal|0
expr_stmt|;
operator|*
name|actlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
if|if
condition|(
name|datalen
operator|>
literal|1
condition|)
block|{
name|USETW
argument_list|(
operator|(
operator|(
name|usb_status_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|wStatus
argument_list|,
name|UDS_SELF_POWERED
argument_list|)
expr_stmt|;
operator|*
name|actlen
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_ENDPOINT
argument_list|)
case|:
if|if
condition|(
name|datalen
operator|>
literal|1
condition|)
block|{
name|USETW
argument_list|(
operator|(
operator|(
name|usb_status_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|wStatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|actlen
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_SET_ADDRESS
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|>=
name|USB_MAX_DEVICES
condition|)
block|{
return|return
name|USBD_IOERROR
return|;
block|}
name|sc
operator|->
name|sc_addr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_CONFIG
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|value
operator|!=
literal|1
condition|)
block|{
return|return
name|USBD_IOERROR
return|;
block|}
name|sc
operator|->
name|sc_conf
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
return|return
name|USBD_IOERROR
return|;
case|case
name|C
argument_list|(
name|UR_SET_INTERFACE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SYNCH_FRAME
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
break|break;
comment|/* Hub requests */
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci_root_ctrl_control: UR_CLEAR_PORT_FEATURE "
literal|"port=%d feature=%d\n"
operator|,
name|index
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
return|return
name|USBD_IOERROR
return|;
block|}
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_PE
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_SUSP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_RESET
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_PR
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONNECTION
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_CSC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_ENABLE
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_POEDC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_OCIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_RESET
case|:
name|sc
operator|->
name|sc_isreset
operator|=
literal|0
expr_stmt|;
return|return
name|USBD_NORMAL_COMPLETION
return|;
case|case
name|UHF_PORT_CONNECTION
case|:
case|case
name|UHF_PORT_OVER_CURRENT
case|:
case|case
name|UHF_PORT_POWER
case|:
case|case
name|UHF_PORT_LOW_SPEED
case|:
case|case
name|UHF_C_PORT_SUSPEND
case|:
default|default:
return|return
name|USBD_IOERROR
return|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_BUS_STATE
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
return|return
name|USBD_IOERROR
return|;
block|}
if|if
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
operator|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|&
name|UHCI_PORTSC_LS
operator|)
operator|>>
name|UHCI_PORTSC_LS_SHIFT
expr_stmt|;
operator|*
name|actlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
return|return
name|USBD_IOERROR
return|;
block|}
name|l
operator|=
name|min
argument_list|(
name|datalen
argument_list|,
name|USB_HUB_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
operator|*
name|actlen
operator|=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|uhci_hubd_piix
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
name|datalen
operator|!=
literal|4
condition|)
block|{
return|return
name|USBD_IOERROR
return|;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
operator|*
name|actlen
operator|=
name|datalen
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
block|{
name|int
name|status
decl_stmt|,
name|change
decl_stmt|;
name|usb_port_status_t
name|ps
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
return|return
name|USBD_IOERROR
return|;
block|}
if|if
condition|(
name|datalen
operator|!=
literal|4
condition|)
block|{
return|return
name|USBD_IOERROR
return|;
block|}
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|status
operator|=
name|change
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_CCS
condition|)
name|status
operator||=
name|UPS_CURRENT_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_CSC
condition|)
name|change
operator||=
name|UPS_C_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_PE
condition|)
name|status
operator||=
name|UPS_PORT_ENABLED
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_POEDC
condition|)
name|change
operator||=
name|UPS_C_PORT_ENABLED
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_OCI
condition|)
name|status
operator||=
name|UPS_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_OCIC
condition|)
name|change
operator||=
name|UPS_C_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_SUSP
condition|)
name|status
operator||=
name|UPS_SUSPEND
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_LSDA
condition|)
name|status
operator||=
name|UPS_LOW_SPEED
expr_stmt|;
name|status
operator||=
name|UPS_PORT_POWER
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_isreset
condition|)
name|change
operator||=
name|UPS_C_PORT_RESET
expr_stmt|;
name|USETW
argument_list|(
name|ps
operator|.
name|wPortStatus
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|ps
operator|.
name|wPortChange
argument_list|,
name|change
argument_list|)
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|datalen
argument_list|,
sizeof|sizeof
name|ps
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ps
argument_list|,
name|l
argument_list|)
expr_stmt|;
operator|*
name|actlen
operator|=
name|l
expr_stmt|;
break|break;
block|}
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
return|return
name|USBD_IOERROR
return|;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
return|return
name|USBD_IOERROR
return|;
block|}
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_PE
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_SUSP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_RESET
case|:
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_PR
argument_list|)
expr_stmt|;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_PR
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_PE
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uhci port %d reset, status = 0x%04x\n"
operator|,
name|index
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_isreset
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONNECTION
case|:
case|case
name|UHF_C_PORT_ENABLE
case|:
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
case|case
name|UHF_PORT_CONNECTION
case|:
case|case
name|UHF_PORT_OVER_CURRENT
case|:
case|case
name|UHF_PORT_POWER
case|:
case|case
name|UHF_PORT_LOW_SPEED
case|:
case|case
name|UHF_C_PORT_SUSPEND
case|:
case|case
name|UHF_C_PORT_RESET
case|:
default|default:
return|return
name|USBD_IOERROR
return|;
block|}
break|break;
default|default:
return|return
name|USBD_IOERROR
return|;
block|}
return|return
name|USBD_NORMAL_COMPLETION
return|;
block|}
end_function

begin_function
name|usbd_status
name|uhci_roothub_intr_transfer
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|,
name|int
modifier|*
name|actlen
parameter_list|)
block|{
if|if
condition|(
name|buflen
operator|<
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: buffer too small, %d< 1\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|,
name|buflen
operator|)
argument_list|)
expr_stmt|;
return|return
name|USBD_IOERROR
return|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
operator|(
name|UHCI_STS_RD
operator|)
condition|)
name|buf
index|[
literal|0
index|]
operator||=
literal|1
operator|<<
literal|0
expr_stmt|;
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC1
argument_list|)
operator|&
operator|(
name|UHCI_PORTSC_CSC
operator||
name|UHCI_PORTSC_OCIC
operator|)
condition|)
name|buf
index|[
literal|0
index|]
operator||=
literal|1
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC2
argument_list|)
operator|&
operator|(
name|UHCI_PORTSC_CSC
operator||
name|UHCI_PORTSC_OCIC
operator|)
condition|)
name|buf
index|[
literal|0
index|]
operator||=
literal|1
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
operator|*
name|actlen
operator|=
literal|1
expr_stmt|;
else|else
name|actlen
operator|=
literal|0
expr_stmt|;
return|return
name|USBD_NORMAL_COMPLETION
return|;
block|}
end_function

begin_comment
comment|/*  * debugging functions  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UHCI_DEBUG
end_ifdef

begin_function
name|void
name|uhci_dumpregs
parameter_list|(
name|sc
parameter_list|)
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, "
literal|"flbase=%08x, sof=%02x, portsc1=%04x, portsc2=%04x\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD
argument_list|)
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|)
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_FRNUM
argument_list|)
operator|,
name|UREAD4
argument_list|(
name|sc
argument_list|,
name|UHCI_FLBASEADDR
argument_list|)
operator|,
name|UREAD1
argument_list|(
name|sc
argument_list|,
name|UHCI_SOF
argument_list|)
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC1
argument_list|)
operator|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|uhci_longtd
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|uhci_dump_td
parameter_list|(
name|p
parameter_list|)
name|uhci_soft_td_t
modifier|*
name|p
decl_stmt|;
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"TD(%p) at %08lx link=0x%08lx st=0x%08lx tok=0x%08lx "
literal|"buf=0x%08lx\n"
operator|,
name|p
operator|,
operator|(
name|long
operator|)
name|p
operator|->
name|physaddr
operator|,
operator|(
name|long
operator|)
name|p
operator|->
name|td
operator|->
name|td_link
operator|,
operator|(
name|long
operator|)
name|p
operator|->
name|td
operator|->
name|td_status
operator|,
operator|(
name|long
operator|)
name|p
operator|->
name|td
operator|->
name|td_token
operator|,
operator|(
name|long
operator|)
name|p
operator|->
name|td
operator|->
name|td_buffer
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uhci_longtd
condition|)
name|DPRINTF
argument_list|(
operator|(
literal|" %b %b,errcnt=%d,actlen=%d pid=%02x,addr=%d,endpt=%d,"
literal|"D=%d,maxlen=%d\n"
operator|,
operator|(
name|int
operator|)
name|p
operator|->
name|td
operator|->
name|td_link
operator|,
literal|"\20\1T\2Q\3VF"
operator|,
operator|(
name|int
operator|)
name|p
operator|->
name|td
operator|->
name|td_status
operator|,
literal|"\20\22BITSTUFF\23CRCTO\24NAK\25BABBLE\26DBUFFER\27"
literal|"STALLED\30ACTIVE\31IOC\32ISO\33LS\36SPD"
operator|,
name|UHCI_TD_GET_ERRCNT
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_status
argument_list|)
operator|,
name|UHCI_TD_GET_ACTLEN
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_status
argument_list|)
operator|,
name|UHCI_TD_GET_PID
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_token
argument_list|)
operator|,
name|UHCI_TD_GET_DEVADDR
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_token
argument_list|)
operator|,
name|UHCI_TD_GET_ENDPT
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_token
argument_list|)
operator|,
name|UHCI_TD_GET_DT
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_token
argument_list|)
operator|,
name|UHCI_TD_GET_MAXLEN
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_token
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_dump_qh
parameter_list|(
name|p
parameter_list|)
name|uhci_soft_qh_t
modifier|*
name|p
decl_stmt|;
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"QH(%p) at %08x: hlink=%08x elink=%08x\n"
operator|,
name|p
operator|,
operator|(
name|int
operator|)
name|p
operator|->
name|physaddr
operator|,
name|p
operator|->
name|qh
operator|->
name|qh_hlink
operator|,
name|p
operator|->
name|qh
operator|->
name|qh_elink
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_dump_tds
parameter_list|(
name|std
parameter_list|)
name|uhci_soft_td_t
modifier|*
name|std
decl_stmt|;
block|{
name|uhci_soft_td_t
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|std
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|td
operator|->
name|link
operator|.
name|std
control|)
name|uhci_dump_td
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

