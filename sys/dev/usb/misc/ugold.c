begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: ugold.c,v 1.7 2014/12/11 18:39:27 mpi Exp $   */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013 Takayoshi SASANO<sasano@openbsd.org>  * Copyright (c) 2013 Martin Pieuchot<mpi@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* Driver for Microdia's HID based TEMPer Temperature sensor */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbhid.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|usb_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_define
define|#
directive|define
name|UGOLD_INNER
value|0
end_define

begin_define
define|#
directive|define
name|UGOLD_OUTER
value|1
end_define

begin_define
define|#
directive|define
name|UGOLD_MAX_SENSORS
value|2
end_define

begin_define
define|#
directive|define
name|UGOLD_CMD_DATA
value|0x80
end_define

begin_define
define|#
directive|define
name|UGOLD_CMD_INIT
value|0x82
end_define

begin_enum
enum|enum
block|{
name|UGOLD_INTR_DT
block|,
name|UGOLD_N_TRANSFER
block|, }
enum|;
end_enum

begin_comment
comment|/*  * This driver only uses two of the three known commands for the  * TEMPerV1.2 device.  *  * The first byte of the answer corresponds to the command and the  * second one seems to be the size (in bytes) of the answer.  *  * The device always sends 8 bytes and if the length of the answer  * is less than that, it just leaves the last bytes untouched.  That  * is why most of the time the last n bytes of the answers are the  * same.  *  * The third command below seems to generate two answers with a  * string corresponding to the device, for example:  *	'TEMPer1F' and '1.1Per1F' (here Per1F is repeated).  */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|cmd_data
index|[
literal|8
index|]
init|=
block|{
literal|0x01
block|,
literal|0x80
block|,
literal|0x33
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|cmd_init
index|[
literal|8
index|]
init|=
block|{
literal|0x01
block|,
literal|0x82
block|,
literal|0x77
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static uint8_t cmd_type[8] = {0x01, 0x86, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00};
endif|#
directive|endif
end_endif

begin_struct_decl
struct_decl|struct
name|ugold_softc
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|ugold_readout_msg
block|{
name|struct
name|usb_proc_msg
name|hdr
decl_stmt|;
name|struct
name|ugold_softc
modifier|*
name|sc
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ugold_softc
block|{
name|struct
name|usb_device
modifier|*
name|sc_udev
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|sc_xfer
index|[
name|UGOLD_N_TRANSFER
index|]
decl_stmt|;
name|struct
name|callout
name|sc_callout
decl_stmt|;
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
name|struct
name|ugold_readout_msg
name|sc_readout_msg
index|[
literal|2
index|]
decl_stmt|;
name|int
name|sc_num_sensors
decl_stmt|;
name|int
name|sc_sensor
index|[
name|UGOLD_MAX_SENSORS
index|]
decl_stmt|;
name|int
name|sc_calib
index|[
name|UGOLD_MAX_SENSORS
index|]
decl_stmt|;
name|int
name|sc_valid
index|[
name|UGOLD_MAX_SENSORS
index|]
decl_stmt|;
name|uint8_t
name|sc_report_id
decl_stmt|;
name|uint8_t
name|sc_iface_index
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* prototypes */
end_comment

begin_decl_stmt
specifier|static
name|device_probe_t
name|ugold_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|ugold_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|ugold_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_proc_callback_t
name|ugold_readout_msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|ugold_intr_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ugold_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ugold_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ugold_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ugold_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ugold_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ugold_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"ugold"
block|,
operator|.
name|methods
operator|=
name|ugold_methods
block|,
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ugold_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|STRUCT_USB_HOST_ID
name|ugold_devs
index|[]
init|=
block|{
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_CHICONY2
argument_list|,
argument|USB_PRODUCT_CHICONY2_TEMPER
argument_list|,
literal|0
argument_list|)
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ugold
argument_list|,
name|uhub
argument_list|,
name|ugold_driver
argument_list|,
name|ugold_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ugold
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ugold
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|USB_PNP_HOST_INFO
argument_list|(
name|ugold_devs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|ugold_config
index|[
name|UGOLD_N_TRANSFER
index|]
init|=
block|{
index|[
name|UGOLD_INTR_DT
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_INTERRUPT
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use wMaxPacketSize */
operator|.
name|callback
operator|=
operator|&
name|ugold_intr_callback
block|,
operator|.
name|if_index
operator|=
literal|1
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ugold_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ugold_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|usb_proc_explore_lock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|usb_proc_explore_msignal
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_readout_msg
index|[
literal|0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|sc_readout_msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usb_proc_explore_unlock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
literal|6
operator|*
name|hz
argument_list|,
operator|&
name|ugold_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ugold_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
decl_stmt|;
name|uaa
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bInterfaceClass
operator|!=
name|UICLASS_HID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|usbd_lookup_id_by_uaa
argument_list|(
name|ugold_devs
argument_list|,
sizeof|sizeof
argument_list|(
name|ugold_devs
argument_list|)
argument_list|,
name|uaa
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ugold_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ugold_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sensor_tree
decl_stmt|;
name|uint16_t
name|d_len
decl_stmt|;
name|void
modifier|*
name|d_ptr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
name|sc
operator|->
name|sc_readout_msg
index|[
literal|0
index|]
operator|.
name|hdr
operator|.
name|pm_callback
operator|=
operator|&
name|ugold_readout_msg
expr_stmt|;
name|sc
operator|->
name|sc_readout_msg
index|[
literal|0
index|]
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_readout_msg
index|[
literal|1
index|]
operator|.
name|hdr
operator|.
name|pm_callback
operator|=
operator|&
name|ugold_readout_msg
expr_stmt|;
name|sc
operator|->
name|sc_readout_msg
index|[
literal|1
index|]
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_iface_index
index|[
literal|0
index|]
operator|=
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
expr_stmt|;
name|sc
operator|->
name|sc_iface_index
index|[
literal|1
index|]
operator|=
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
operator|+
literal|1
expr_stmt|;
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|"ugold lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* grab all interfaces from other drivers */
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
condition|)
continue|continue;
if|if
condition|(
name|usbd_get_iface
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|i
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|usbd_set_parent_iface
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|i
argument_list|,
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|)
expr_stmt|;
block|}
comment|/* figure out report ID */
name|error
operator|=
name|usbd_req_get_hid_desc
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|NULL
argument_list|,
operator|&
name|d_ptr
argument_list|,
operator|&
name|d_len
argument_list|,
name|M_TEMP
argument_list|,
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|detach
goto|;
operator|(
name|void
operator|)
name|hid_report_size
argument_list|(
name|d_ptr
argument_list|,
name|d_len
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_report_id
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d_ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|sc
operator|->
name|sc_iface_index
argument_list|,
name|sc
operator|->
name|sc_xfer
argument_list|,
name|ugold_config
argument_list|,
name|UGOLD_N_TRANSFER
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|detach
goto|;
name|sensor_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sensors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|sensor_tree
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sensor_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"inner"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sc_sensor
index|[
name|UGOLD_INNER
index|]
argument_list|,
literal|0
argument_list|,
literal|"Inner temperature in microCelcius"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sensor_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"inner_valid"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sc_valid
index|[
name|UGOLD_INNER
index|]
argument_list|,
literal|0
argument_list|,
literal|"Inner temperature is valid"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sensor_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"inner_calib"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|sc
operator|->
name|sc_calib
index|[
name|UGOLD_INNER
index|]
argument_list|,
literal|0
argument_list|,
literal|"Inner calibration temperature in microCelcius"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sensor_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"outer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sc_sensor
index|[
name|UGOLD_OUTER
index|]
argument_list|,
literal|0
argument_list|,
literal|"Outer temperature in microCelcius"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sensor_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"outer_calib"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|sc
operator|->
name|sc_calib
index|[
name|UGOLD_OUTER
index|]
argument_list|,
literal|0
argument_list|,
literal|"Outer calibration temperature in microCelcius"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sensor_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"outer_valid"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sc_valid
index|[
name|UGOLD_OUTER
index|]
argument_list|,
literal|0
argument_list|,
literal|"Outer temperature is valid"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UGOLD_INTR_DT
index|]
argument_list|)
expr_stmt|;
name|ugold_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|detach
label|:
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|ugold_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ugold_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ugold_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
name|usb_proc_explore_lock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
name|usb_proc_explore_mwait
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_readout_msg
index|[
literal|0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|sc_readout_msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usb_proc_explore_unlock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|UGOLD_N_TRANSFER
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ugold_ds75_temp
parameter_list|(
name|uint8_t
name|msb
parameter_list|,
name|uint8_t
name|lsb
parameter_list|)
block|{
comment|/* DS75: 12bit precision mode : 0.0625 degrees Celsius ticks */
comment|/* NOTE: MSB has a sign bit for negative temperatures */
name|int32_t
name|temp
init|=
operator|(
name|msb
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|lsb
operator|&
literal|0xF0
operator|)
operator|<<
literal|16
operator|)
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|int64_t
operator|)
name|temp
operator|*
operator|(
name|int64_t
operator|)
literal|1000000LL
operator|)
operator|>>
literal|24
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ugold_intr_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|ugold_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|MIN
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
name|UGOLD_CMD_INIT
case|:
if|if
condition|(
name|sc
operator|->
name|sc_num_sensors
condition|)
break|break;
name|sc
operator|->
name|sc_num_sensors
operator|=
name|MIN
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|,
name|UGOLD_MAX_SENSORS
argument_list|)
comment|/* XXX */
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%d sensor%s type ds75/12bit (temperature)\n"
argument_list|,
name|sc
operator|->
name|sc_num_sensors
argument_list|,
operator|(
name|sc
operator|->
name|sc_num_sensors
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UGOLD_CMD_DATA
case|:
switch|switch
condition|(
name|buf
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|4
case|:
name|temp
operator|=
name|ugold_ds75_temp
argument_list|(
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sensor
index|[
name|UGOLD_OUTER
index|]
operator|=
name|temp
operator|+
name|sc
operator|->
name|sc_calib
index|[
name|UGOLD_OUTER
index|]
expr_stmt|;
name|sc
operator|->
name|sc_valid
index|[
name|UGOLD_OUTER
index|]
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|temp
operator|=
name|ugold_ds75_temp
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sensor
index|[
name|UGOLD_INNER
index|]
operator|=
name|temp
operator|+
name|sc
operator|->
name|sc_calib
index|[
name|UGOLD_INNER
index|]
expr_stmt|;
name|sc
operator|->
name|sc_valid
index|[
name|UGOLD_INNER
index|]
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"invalid data length (%d bytes)\n"
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"unknown command 0x%02x\n"
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Error */
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* try clear stall first */
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ugold_issue_cmd
parameter_list|(
name|struct
name|ugold_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|cmd
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
operator|(
name|usbd_req_set_report
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|cmd
argument_list|,
name|len
argument_list|,
name|sc
operator|->
name|sc_iface_index
index|[
literal|1
index|]
argument_list|,
name|UHID_OUTPUT_REPORT
argument_list|,
name|sc
operator|->
name|sc_report_id
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ugold_readout_msg
parameter_list|(
name|struct
name|usb_proc_msg
modifier|*
name|pm
parameter_list|)
block|{
name|struct
name|ugold_softc
modifier|*
name|sc
init|=
operator|(
operator|(
expr|struct
name|ugold_readout_msg
operator|*
operator|)
name|pm
operator|)
operator|->
name|sc
decl_stmt|;
name|usb_proc_explore_unlock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_num_sensors
operator|==
literal|0
condition|)
name|ugold_issue_cmd
argument_list|(
name|sc
argument_list|,
name|cmd_init
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd_init
argument_list|)
argument_list|)
expr_stmt|;
name|ugold_issue_cmd
argument_list|(
name|sc
argument_list|,
name|cmd_data
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd_data
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|usb_proc_explore_lock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

