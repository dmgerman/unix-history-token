begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: ohci.c,v 1.74 2000/02/29 21:37:00 augustss Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (lennart@augustsson.net) at  * Carlstedt Research& Technology.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * USB Open Host Controller driver.  *  * OHCI spec: ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.exe  * USB spec: http://www.usb.org/developers/data/usb11.pdf  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/endian.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_mem.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_quirks.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/ohcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/ohcivar.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_define
define|#
directive|define
name|delay
parameter_list|(
name|d
parameter_list|)
value|DELAY(d)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_decl_stmt
name|struct
name|cfdriver
name|ohci_cd
init|=
block|{
name|NULL
block|,
literal|"ohci"
block|,
name|DV_DULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OHCI_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (ohcidebug) logprintf x
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (ohcidebug>(n)) logprintf x
end_define

begin_decl_stmt
name|int
name|ohcidebug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct_decl
struct_decl|struct
name|ohci_pipe
struct_decl|;
end_struct_decl

begin_function_decl
name|Static
name|ohci_soft_ed_t
modifier|*
name|ohci_alloc_sed
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_free_sed
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_soft_ed_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|ohci_soft_td_t
modifier|*
name|ohci_alloc_std
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_free_std
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_soft_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|ohci_soft_itd_t
modifier|*
name|ohci_alloc_sitd
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_free_sitd
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_soft_itd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|Static void		ohci_free_std_chain(ohci_softc_t *, ohci_soft_td_t *, 					    ohci_soft_td_t *);
endif|#
directive|endif
end_endif

begin_function_decl
name|Static
name|usbd_status
name|ohci_alloc_std_chain
parameter_list|(
name|struct
name|ohci_pipe
modifier|*
parameter_list|,
name|ohci_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|u_int16_t
parameter_list|,
name|usb_dma_t
modifier|*
parameter_list|,
name|ohci_soft_td_t
modifier|*
parameter_list|,
name|ohci_soft_td_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function_decl
name|Static
name|void
name|ohci_shutdown
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_power
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|Static
name|usbd_status
name|ohci_open
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_poll
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_softintr
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_waitintr
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_rhsc
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_request
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_add_ed
parameter_list|(
name|ohci_soft_ed_t
modifier|*
parameter_list|,
name|ohci_soft_ed_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_rem_ed
parameter_list|(
name|ohci_soft_ed_t
modifier|*
parameter_list|,
name|ohci_soft_ed_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_hash_add_td
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_soft_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_hash_rem_td
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_soft_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|ohci_soft_td_t
modifier|*
name|ohci_hash_find_td
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_physaddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_setup_isoc
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_isoc_enter
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_allocm
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|,
name|usb_dma_t
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_freem
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|,
name|usb_dma_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_xfer_handle
name|ohci_allocx
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_freex
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|,
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_root_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_root_ctrl_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_root_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_root_ctrl_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_root_ctrl_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_root_intr_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_root_intr_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_root_intr_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_root_intr_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_root_intr_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_ctrl_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_ctrl_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_ctrl_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_bulk_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_bulk_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_bulk_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_bulk_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_bulk_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_intr_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_intr_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_intr_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_intr_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_intr_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_isoc_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_isoc_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_isoc_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_isoc_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_isoc_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_setintr
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ohci_pipe
modifier|*
name|pipe
parameter_list|,
name|int
name|ival
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|ohci_str
parameter_list|(
name|usb_string_descriptor_t
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_rhsc_able
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_close_pipe
parameter_list|(
name|usbd_pipe_handle
parameter_list|,
name|ohci_soft_ed_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_abort_xfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|,
name|usbd_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_abort_xfer_end
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_clear_toggle
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_noop
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|OHCI_DEBUG
end_ifdef

begin_function_decl
name|Static
name|void
name|ohci_dumpregs
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_dump_tds
parameter_list|(
name|ohci_soft_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_dump_td
parameter_list|(
name|ohci_soft_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_dump_ed
parameter_list|(
name|ohci_soft_ed_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OWRITE4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
value|bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x))
end_define

begin_define
define|#
directive|define
name|OREAD4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|bus_space_read_4((sc)->iot, (sc)->ioh, (r))
end_define

begin_define
define|#
directive|define
name|OREAD2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|bus_space_read_2((sc)->iot, (sc)->ioh, (r))
end_define

begin_comment
comment|/* Reverse the bits in a value 0 .. 31 */
end_comment

begin_decl_stmt
name|Static
name|u_int8_t
name|revbits
index|[
name|OHCI_NO_INTRS
index|]
init|=
block|{
literal|0x00
block|,
literal|0x10
block|,
literal|0x08
block|,
literal|0x18
block|,
literal|0x04
block|,
literal|0x14
block|,
literal|0x0c
block|,
literal|0x1c
block|,
literal|0x02
block|,
literal|0x12
block|,
literal|0x0a
block|,
literal|0x1a
block|,
literal|0x06
block|,
literal|0x16
block|,
literal|0x0e
block|,
literal|0x1e
block|,
literal|0x01
block|,
literal|0x11
block|,
literal|0x09
block|,
literal|0x19
block|,
literal|0x05
block|,
literal|0x15
block|,
literal|0x0d
block|,
literal|0x1d
block|,
literal|0x03
block|,
literal|0x13
block|,
literal|0x0b
block|,
literal|0x1b
block|,
literal|0x07
block|,
literal|0x17
block|,
literal|0x0f
block|,
literal|0x1f
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ohci_pipe
block|{
name|struct
name|usbd_pipe
name|pipe
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
union|union
block|{
name|ohci_soft_td_t
modifier|*
name|td
decl_stmt|;
name|ohci_soft_itd_t
modifier|*
name|itd
decl_stmt|;
block|}
name|tail
union|;
comment|/* Info needed for different pipe kinds. */
union|union
block|{
comment|/* Control pipe */
struct|struct
block|{
name|usb_dma_t
name|reqdma
decl_stmt|;
name|u_int
name|length
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|setup
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|stat
decl_stmt|;
block|}
name|ctl
struct|;
comment|/* Interrupt pipe */
struct|struct
block|{
name|int
name|nslots
decl_stmt|;
name|int
name|pos
decl_stmt|;
block|}
name|intr
struct|;
comment|/* Bulk pipe */
struct|struct
block|{
name|u_int
name|length
decl_stmt|;
name|int
name|isread
decl_stmt|;
block|}
name|bulk
struct|;
comment|/* Iso pipe */
struct|struct
name|iso
block|{
name|int
name|next
decl_stmt|,
name|inuse
decl_stmt|;
block|}
name|iso
struct|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|OHCI_INTR_ENDPT
value|1
end_define

begin_decl_stmt
name|Static
name|struct
name|usbd_bus_methods
name|ohci_bus_methods
init|=
block|{
name|ohci_open
block|,
name|ohci_softintr
block|,
name|ohci_poll
block|,
name|ohci_allocm
block|,
name|ohci_freem
block|,
name|ohci_allocx
block|,
name|ohci_freex
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|usbd_pipe_methods
name|ohci_root_ctrl_methods
init|=
block|{
name|ohci_root_ctrl_transfer
block|,
name|ohci_root_ctrl_start
block|,
name|ohci_root_ctrl_abort
block|,
name|ohci_root_ctrl_close
block|,
name|ohci_noop
block|,
name|ohci_root_ctrl_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|usbd_pipe_methods
name|ohci_root_intr_methods
init|=
block|{
name|ohci_root_intr_transfer
block|,
name|ohci_root_intr_start
block|,
name|ohci_root_intr_abort
block|,
name|ohci_root_intr_close
block|,
name|ohci_noop
block|,
name|ohci_root_intr_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|usbd_pipe_methods
name|ohci_device_ctrl_methods
init|=
block|{
name|ohci_device_ctrl_transfer
block|,
name|ohci_device_ctrl_start
block|,
name|ohci_device_ctrl_abort
block|,
name|ohci_device_ctrl_close
block|,
name|ohci_noop
block|,
name|ohci_device_ctrl_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|usbd_pipe_methods
name|ohci_device_intr_methods
init|=
block|{
name|ohci_device_intr_transfer
block|,
name|ohci_device_intr_start
block|,
name|ohci_device_intr_abort
block|,
name|ohci_device_intr_close
block|,
name|ohci_device_clear_toggle
block|,
name|ohci_device_intr_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|usbd_pipe_methods
name|ohci_device_bulk_methods
init|=
block|{
name|ohci_device_bulk_transfer
block|,
name|ohci_device_bulk_start
block|,
name|ohci_device_bulk_abort
block|,
name|ohci_device_bulk_close
block|,
name|ohci_device_clear_toggle
block|,
name|ohci_device_bulk_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|usbd_pipe_methods
name|ohci_device_isoc_methods
init|=
block|{
name|ohci_device_isoc_transfer
block|,
name|ohci_device_isoc_start
block|,
name|ohci_device_isoc_abort
block|,
name|ohci_device_isoc_close
block|,
name|ohci_noop
block|,
name|ohci_device_isoc_done
block|, }
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|int
name|ohci_activate
parameter_list|(
name|device_ptr_t
name|self
parameter_list|,
name|enum
name|devact
name|act
parameter_list|)
block|{
name|struct
name|ohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ohci_softc
operator|*
operator|)
name|self
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|act
condition|)
block|{
case|case
name|DVACT_ACTIVATE
case|:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
case|case
name|DVACT_DEACTIVATE
case|:
if|if
condition|(
name|sc
operator|->
name|sc_child
operator|!=
name|NULL
condition|)
name|rv
operator|=
name|config_deactivate
argument_list|(
name|sc
operator|->
name|sc_child
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ohci_detach
parameter_list|(
name|struct
name|ohci_softc
modifier|*
name|sc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|rv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_child
operator|!=
name|NULL
condition|)
name|rv
operator|=
name|config_detach
argument_list|(
name|sc
operator|->
name|sc_child
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|powerhook_disestablish
argument_list|(
name|sc
operator|->
name|sc_powerhook
argument_list|)
expr_stmt|;
name|shutdownhook_disestablish
argument_list|(
name|sc
operator|->
name|sc_shutdownhook
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* free data structures XXX */
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|ohci_soft_ed_t
modifier|*
name|ohci_alloc_sed
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offs
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_freeeds
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_alloc_sed: allocating chunk\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|OHCI_SED_SIZE
operator|*
name|OHCI_SED_CHUNK
argument_list|,
name|OHCI_ED_ALIGN
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_SED_CHUNK
condition|;
name|i
operator|++
control|)
block|{
name|offs
operator|=
name|i
operator|*
name|OHCI_SED_SIZE
expr_stmt|;
name|sed
operator|=
operator|(
name|ohci_soft_ed_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
operator|)
expr_stmt|;
name|sed
operator|->
name|physaddr
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|sed
operator|->
name|next
operator|=
name|sc
operator|->
name|sc_freeeds
expr_stmt|;
name|sc
operator|->
name|sc_freeeds
operator|=
name|sed
expr_stmt|;
block|}
block|}
name|sed
operator|=
name|sc
operator|->
name|sc_freeeds
expr_stmt|;
name|sc
operator|->
name|sc_freeeds
operator|=
name|sed
operator|->
name|next
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sed
operator|->
name|ed
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ohci_ed_t
argument_list|)
argument_list|)
expr_stmt|;
name|sed
operator|->
name|next
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sed
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_free_sed
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_soft_ed_t
modifier|*
name|sed
parameter_list|)
block|{
name|sed
operator|->
name|next
operator|=
name|sc
operator|->
name|sc_freeeds
expr_stmt|;
name|sc
operator|->
name|sc_freeeds
operator|=
name|sed
expr_stmt|;
block|}
end_function

begin_function
name|ohci_soft_td_t
modifier|*
name|ohci_alloc_std
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|ohci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offs
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_freetds
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_alloc_std: allocating chunk\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|OHCI_STD_SIZE
operator|*
name|OHCI_STD_CHUNK
argument_list|,
name|OHCI_TD_ALIGN
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_STD_CHUNK
condition|;
name|i
operator|++
control|)
block|{
name|offs
operator|=
name|i
operator|*
name|OHCI_STD_SIZE
expr_stmt|;
name|std
operator|=
operator|(
name|ohci_soft_td_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
operator|)
expr_stmt|;
name|std
operator|->
name|physaddr
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|std
operator|->
name|nexttd
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|std
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
operator|->
name|nexttd
expr_stmt|;
name|memset
argument_list|(
operator|&
name|std
operator|->
name|td
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ohci_td_t
argument_list|)
argument_list|)
expr_stmt|;
name|std
operator|->
name|nexttd
operator|=
name|NULL
expr_stmt|;
name|ohci_hash_add_td
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|std
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_free_std
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_soft_td_t
modifier|*
name|std
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ohci_hash_rem_td
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
name|std
operator|->
name|nexttd
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|ohci_alloc_std_chain
parameter_list|(
name|struct
name|ohci_pipe
modifier|*
name|opipe
parameter_list|,
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|rd
parameter_list|,
name|u_int16_t
name|flags
parameter_list|,
name|usb_dma_t
modifier|*
name|dma
parameter_list|,
name|ohci_soft_td_t
modifier|*
name|std
parameter_list|,
name|ohci_soft_td_t
modifier|*
modifier|*
name|rstd
parameter_list|)
block|{
name|ohci_soft_td_t
modifier|*
name|next
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|ohci_physaddr_t
name|dataphys
decl_stmt|,
name|dataphysend
decl_stmt|;
name|u_int32_t
name|intr
decl_stmt|,
name|tdflags
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|curlen
decl_stmt|;
name|DPRINTFN
argument_list|(
name|len
operator|<
literal|4096
argument_list|,
operator|(
literal|"ohci_alloc_std_chain: start len=%d\n"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|std
expr_stmt|;
name|dataphysend
operator|=
name|DMAADDR
argument_list|(
name|dma
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tdflags
operator|=
operator|(
name|rd
condition|?
name|OHCI_TD_IN
else|:
name|OHCI_TD_OUT
operator|)
operator||
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_TOGGLE_CARRY
operator||
operator|(
name|flags
operator|&
name|USBD_SHORT_XFER_OK
condition|?
name|OHCI_TD_R
else|:
literal|0
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|next
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|dataphys
operator|=
name|DMAADDR
argument_list|(
name|dma
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* The OHCI hardware can handle at most one page crossing. */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
if|if
condition|(
name|OHCI_PAGE
argument_list|(
name|dataphys
argument_list|)
operator|==
name|OHCI_PAGE
argument_list|(
name|dataphysend
argument_list|)
operator|||
name|OHCI_PAGE
argument_list|(
name|dataphys
argument_list|)
operator|+
name|OHCI_PAGE_SIZE
operator|==
name|OHCI_PAGE
argument_list|(
name|dataphysend
argument_list|)
condition|)
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* XXX This is pretty broken: Because we do not allocate 		 * a contiguous buffer (contiguous in physical pages) we 		 * can only transfer one page in one go. 		 * So check whether the start and end of the buffer are on 		 * the same page. 		 */
if|if
condition|(
name|OHCI_PAGE
argument_list|(
name|dataphys
argument_list|)
operator|==
name|OHCI_PAGE
argument_list|(
name|dataphysend
argument_list|)
condition|)
endif|#
directive|endif
block|{
comment|/* we can handle it in this TD */
name|curlen
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX The calculation below is wrong and could 			 * result in a packet that is not a multiple of the 			 * MaxPacketSize in the case where the buffer does not 			 * start on an appropriate address (like for example in 			 * the case of an mbuf cluster). You'll get an early 			 * short packet. 			 */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
comment|/* must use multiple TDs, fill as much as possible. */
name|curlen
operator|=
literal|2
operator|*
name|OHCI_PAGE_SIZE
operator|-
name|OHCI_PAGE_MASK
argument_list|(
name|dataphys
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* See comment above (XXX) */
name|curlen
operator|=
name|OHCI_PAGE_SIZE
operator|-
name|OHCI_PAGE_MASK
argument_list|(
name|dataphys
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ohci_alloc_std_chain: dataphys=0x%08x "
literal|"dataphysend=0x%08x len=%d curlen=%d\n"
operator|,
name|dataphys
operator|,
name|dataphysend
operator|,
name|len
operator|,
name|curlen
operator|)
argument_list|)
expr_stmt|;
name|len
operator|-=
name|curlen
expr_stmt|;
name|intr
operator|=
name|len
operator|==
literal|0
condition|?
name|OHCI_TD_SET_DI
argument_list|(
literal|1
argument_list|)
else|:
name|OHCI_TD_NOINTR
expr_stmt|;
name|cur
operator|->
name|td
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
name|tdflags
operator||
name|intr
argument_list|)
expr_stmt|;
name|cur
operator|->
name|td
operator|.
name|td_cbp
operator|=
name|htole32
argument_list|(
name|dataphys
argument_list|)
expr_stmt|;
name|cur
operator|->
name|nexttd
operator|=
name|next
expr_stmt|;
name|cur
operator|->
name|td
operator|.
name|td_nexttd
operator|=
name|htole32
argument_list|(
name|next
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|cur
operator|->
name|td
operator|.
name|td_be
operator|=
name|htole32
argument_list|(
name|dataphys
operator|+
name|curlen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|->
name|len
operator|=
name|curlen
expr_stmt|;
name|cur
operator|->
name|flags
operator|=
name|OHCI_ADD_LEN
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\n"
operator|,
name|dataphys
operator|,
name|dataphys
operator|+
name|curlen
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_alloc_std_chain: extend chain\n"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|curlen
expr_stmt|;
name|cur
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|USBD_FORCE_SHORT_XFER
operator|)
operator|&&
name|len
operator|%
name|UGETW
argument_list|(
name|opipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Force a 0 length transfer at the end. */
name|next
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|cur
operator|->
name|td
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
name|tdflags
operator||
name|OHCI_TD_SET_DI
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|->
name|td
operator|.
name|td_cbp
operator|=
literal|0
expr_stmt|;
comment|/* indicate 0 length packet */
name|cur
operator|->
name|nexttd
operator|=
name|next
expr_stmt|;
name|cur
operator|->
name|td
operator|.
name|td_nexttd
operator|=
name|htole32
argument_list|(
name|next
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|cur
operator|->
name|td
operator|.
name|td_be
operator|=
name|htole32
argument_list|(
name|dataphys
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|cur
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
name|next
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_alloc_std_chain: add 0 xfer\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|cur
operator|->
name|flags
operator|=
name|OHCI_CALL_DONE
operator||
name|OHCI_ADD_LEN
expr_stmt|;
operator|*
name|rstd
operator|=
name|next
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|nomem
label|:
comment|/* XXX free chain */
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|Static void ohci_free_std_chain(ohci_softc_t *sc, ohci_soft_td_t *std, 		    ohci_soft_td_t *stdend) { 	ohci_soft_td_t *p;  	for (; std != stdend; std = p) { 		p = std->nexttd; 		ohci_free_std(sc, std); 	} }
endif|#
directive|endif
end_endif

begin_function
name|ohci_soft_itd_t
modifier|*
name|ohci_alloc_sitd
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|ohci_soft_itd_t
modifier|*
name|sitd
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offs
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_freeitds
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_alloc_sitd: allocating chunk\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|OHCI_STD_SIZE
operator|*
name|OHCI_STD_CHUNK
argument_list|,
name|OHCI_TD_ALIGN
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_STD_CHUNK
condition|;
name|i
operator|++
control|)
block|{
name|offs
operator|=
name|i
operator|*
name|OHCI_STD_SIZE
expr_stmt|;
name|sitd
operator|=
operator|(
name|ohci_soft_itd_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
operator|)
expr_stmt|;
name|sitd
operator|->
name|physaddr
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|nextitd
operator|=
name|sc
operator|->
name|sc_freeitds
expr_stmt|;
name|sc
operator|->
name|sc_freeitds
operator|=
name|sitd
expr_stmt|;
block|}
block|}
name|sitd
operator|=
name|sc
operator|->
name|sc_freeitds
expr_stmt|;
name|sc
operator|->
name|sc_freeitds
operator|=
name|sitd
operator|->
name|nextitd
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sitd
operator|->
name|itd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ohci_itd_t
argument_list|)
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|nextitd
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sitd
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_free_sitd
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_soft_itd_t
modifier|*
name|sitd
parameter_list|)
block|{
name|sitd
operator|->
name|nextitd
operator|=
name|sc
operator|->
name|sc_freeitds
expr_stmt|;
name|sc
operator|->
name|sc_freeitds
operator|=
name|sitd
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|ohci_init
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|,
modifier|*
name|psed
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int32_t
name|s
decl_stmt|,
name|ctl
decl_stmt|,
name|ival
decl_stmt|,
name|hcr
decl_stmt|,
name|fm
decl_stmt|,
name|per
decl_stmt|,
name|rev
decl_stmt|,
name|desca
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_init: start\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rev
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_REVISION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" OHCI version %d.%d%s\n"
argument_list|,
name|OHCI_REV_HI
argument_list|(
name|rev
argument_list|)
argument_list|,
name|OHCI_REV_LO
argument_list|(
name|rev
argument_list|)
argument_list|,
name|OHCI_REV_LEGACY
argument_list|(
name|rev
argument_list|)
condition|?
literal|", legacy support"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|OHCI_REV_HI
argument_list|(
name|rev
argument_list|)
operator|!=
literal|1
operator|||
name|OHCI_REV_LO
argument_list|(
name|rev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unsupported OHCI revision\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|usbrev
operator|=
name|USBREV_UNKNOWN
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
name|sc
operator|->
name|sc_bus
operator|.
name|usbrev
operator|=
name|USBREV_1_0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_HASH_SIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_hash_tds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SIMPLEQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|)
expr_stmt|;
comment|/* XXX determine alignment by R/W */
comment|/* Allocate the HCCA area. */
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|OHCI_HCCA_SIZE
argument_list|,
name|OHCI_HCCA_ALIGN
argument_list|,
operator|&
name|sc
operator|->
name|sc_hccadma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|sc
operator|->
name|sc_hcca
operator|=
operator|(
expr|struct
name|ohci_hcca
operator|*
operator|)
name|KERNADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_hccadma
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_hcca
argument_list|,
literal|0
argument_list|,
name|OHCI_HCCA_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_eintrs
operator|=
name|OHCI_NORMAL_INTRS
expr_stmt|;
comment|/* Allocate dummy ED that starts the control list. */
name|sc
operator|->
name|sc_ctrl_head
operator|=
name|ohci_alloc_sed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ctrl_head
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
name|sc
operator|->
name|sc_ctrl_head
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* Allocate dummy ED that starts the bulk list. */
name|sc
operator|->
name|sc_bulk_head
operator|=
name|ohci_alloc_sed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bulk_head
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|sc
operator|->
name|sc_bulk_head
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* Allocate dummy ED that starts the isochronous list. */
name|sc
operator|->
name|sc_isoc_head
operator|=
name|ohci_alloc_sed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_isoc_head
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad3
goto|;
block|}
name|sc
operator|->
name|sc_isoc_head
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* Allocate all the dummy EDs that make up the interrupt tree. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_NO_EDS
condition|;
name|i
operator|++
control|)
block|{
name|sed
operator|=
name|ohci_alloc_sed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sed
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_eds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad4
goto|;
block|}
comment|/* All ED fields are set to 0. */
name|sc
operator|->
name|sc_eds
index|[
name|i
index|]
operator|=
name|sed
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|psed
operator|=
name|sc
operator|->
name|sc_eds
index|[
operator|(
name|i
operator|-
literal|1
operator|)
operator|/
literal|2
index|]
expr_stmt|;
else|else
name|psed
operator|=
name|sc
operator|->
name|sc_isoc_head
expr_stmt|;
name|sed
operator|->
name|next
operator|=
name|psed
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_nexted
operator|=
name|htole32
argument_list|(
name|psed
operator|->
name|physaddr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill HCCA interrupt table.  The bit reversal is to get 	 * the tree set up properly to spread the interrupts. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_NO_INTRS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_hcca
operator|->
name|hcca_interrupt_table
index|[
name|revbits
index|[
name|i
index|]
index|]
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_eds
index|[
name|OHCI_NO_EDS
operator|-
name|OHCI_NO_INTRS
operator|+
name|i
index|]
operator|->
name|physaddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OHCI_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|15
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_NO_EDS
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"ed#%d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sc
operator|->
name|sc_eds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"iso "
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sc
operator|->
name|sc_isoc_head
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Determine in what context we are running. */
name|ctl
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&
name|OHCI_IR
condition|)
block|{
comment|/* SMM active, request change */
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_init: SMM active, request owner change\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|s
operator||
name|OHCI_OCR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
operator|&&
operator|(
name|ctl
operator|&
name|OHCI_IR
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ctl
operator|&
name|OHCI_IR
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SMM does not respond, resetting\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_RESET
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ctl
operator|&
name|OHCI_HCFS_MASK
operator|)
operator|!=
name|OHCI_HCFS_RESET
condition|)
block|{
comment|/* BIOS started controller. */
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_init: BIOS active\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctl
operator|&
name|OHCI_HCFS_MASK
operator|)
operator|!=
name|OHCI_HCFS_OPERATIONAL
condition|)
block|{
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_OPERATIONAL
argument_list|)
expr_stmt|;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_RESUME_DELAY
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_init: cold started\n"
operator|)
argument_list|)
expr_stmt|;
name|reset
label|:
comment|/* Controller was cold started. */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_BUS_RESET_DELAY
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This reset should not be necessary according to the OHCI spec, but 	 * without it some controllers do not start. 	 */
name|DPRINTF
argument_list|(
operator|(
literal|"%s: resetting\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_RESET
argument_list|)
expr_stmt|;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_BUS_RESET_DELAY
argument_list|)
expr_stmt|;
comment|/* We now own the host controller and the bus has been reset. */
name|ival
operator|=
name|OHCI_GET_IVAL
argument_list|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_INTERVAL
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_HCR
argument_list|)
expr_stmt|;
comment|/* Reset HC */
comment|/* Nominal time for a reset is 10 us. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|hcr
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|)
operator|&
name|OHCI_HCR
expr_stmt|;
if|if
condition|(
operator|!
name|hcr
condition|)
break|break;
block|}
if|if
condition|(
name|hcr
condition|)
block|{
name|printf
argument_list|(
literal|"%s: reset timeout\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|bad5
goto|;
block|}
ifdef|#
directive|ifdef
name|OHCI_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|15
condition|)
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The controller is now in SUSPEND state, we have 2ms to finish. */
comment|/* Set up HC registers. */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCA
argument_list|,
name|DMAADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_hccadma
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL_HEAD_ED
argument_list|,
name|sc
operator|->
name|sc_ctrl_head
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_BULK_HEAD_ED
argument_list|,
name|sc
operator|->
name|sc_bulk_head
operator|->
name|physaddr
argument_list|)
expr_stmt|;
comment|/* disable all interrupts and then switch on all desired interrupts */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|,
name|OHCI_ALL_INTRS
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_ENABLE
argument_list|,
name|sc
operator|->
name|sc_eintrs
operator||
name|OHCI_MIE
argument_list|)
expr_stmt|;
comment|/* switch on desired functional features */
name|ctl
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
operator|(
name|OHCI_CBSR_MASK
operator||
name|OHCI_LES
operator||
name|OHCI_HCFS_MASK
operator||
name|OHCI_IR
operator|)
expr_stmt|;
name|ctl
operator||=
name|OHCI_PLE
operator||
name|OHCI_IE
operator||
name|OHCI_CLE
operator||
name|OHCI_BLE
operator||
name|OHCI_RATIO_1_4
operator||
name|OHCI_HCFS_OPERATIONAL
expr_stmt|;
comment|/* And finally start it! */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
comment|/* 	 * The controller is now OPERATIONAL.  Set a some final 	 * registers that should be set earlier, but that the 	 * controller ignores when in the SUSPEND state. 	 */
name|fm
operator|=
operator|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_INTERVAL
argument_list|)
operator|&
name|OHCI_FIT
operator|)
operator|^
name|OHCI_FIT
expr_stmt|;
name|fm
operator||=
name|OHCI_FSMPS
argument_list|(
name|ival
argument_list|)
operator||
name|ival
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_INTERVAL
argument_list|,
name|fm
argument_list|)
expr_stmt|;
name|per
operator|=
name|OHCI_PERIODIC
argument_list|(
name|ival
argument_list|)
expr_stmt|;
comment|/* 90% periodic */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_PERIODIC_START
argument_list|,
name|per
argument_list|)
expr_stmt|;
comment|/* Fiddle the No OverCurrent Protection bit to avoid chip bug. */
name|desca
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|,
name|desca
operator||
name|OHCI_NOCP
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_STATUS
argument_list|,
name|OHCI_LPSC
argument_list|)
expr_stmt|;
comment|/* Enable port power */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|,
name|desca
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_noport
operator|=
name|OHCI_GET_NDP
argument_list|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OHCI_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|5
condition|)
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set up the bus struct. */
name|sc
operator|->
name|sc_bus
operator|.
name|methods
operator|=
operator|&
name|ohci_bus_methods
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|pipe_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ohci_pipe
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OPENBSD__
argument_list|)
name|sc
operator|->
name|sc_powerhook
operator|=
name|powerhook_establish
argument_list|(
name|ohci_power
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_shutdownhook
operator|=
name|shutdownhook_establish
argument_list|(
name|ohci_shutdown
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad5
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_NO_EDS
condition|;
name|i
operator|++
control|)
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_eds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bad4
label|:
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_isoc_head
argument_list|)
expr_stmt|;
name|bad3
label|:
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ctrl_head
argument_list|)
expr_stmt|;
name|bad2
label|:
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_bulk_head
argument_list|)
expr_stmt|;
name|bad1
label|:
name|usb_freemem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hccadma
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|ohci_allocm
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|,
name|usb_dma_t
modifier|*
name|dma
parameter_list|,
name|u_int32_t
name|size
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|struct
name|ohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ohci_softc
operator|*
operator|)
name|bus
decl_stmt|;
endif|#
directive|endif
return|return
operator|(
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|dma
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_freem
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|,
name|usb_dma_t
modifier|*
name|dma
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|struct
name|ohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ohci_softc
operator|*
operator|)
name|bus
decl_stmt|;
endif|#
directive|endif
name|usb_freemem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_xfer_handle
name|ohci_allocx
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|ohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ohci_softc
operator|*
operator|)
name|bus
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|xfer
operator|=
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|!=
name|NULL
condition|)
name|SIMPLEQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|,
name|xfer
argument_list|,
name|next
argument_list|)
expr_stmt|;
else|else
name|xfer
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xfer
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|xfer
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_freex
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ohci_softc
operator|*
operator|)
name|bus
decl_stmt|;
name|SIMPLEQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|,
name|xfer
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shut down the controller when the system is going down.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|void
name|ohci_shutdown
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_shutdown: stopping the HC\n"
operator|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle suspend/resume.  *  * We need to switch to polling mode here, because this routine is  * called from an intterupt context.  This is all right since we  * are almost suspended anyway.  */
end_comment

begin_function
name|void
name|ohci_power
parameter_list|(
name|int
name|why
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OHCI_DEBUG
name|ohci_softc_t
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_power: sc=%p, why=%d\n"
operator|,
name|sc
operator|,
name|why
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX should suspend/resume */
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OHCI_DEBUG
end_ifdef

begin_function
name|void
name|ohci_dumpregs
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_REVISION
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"               intrstat=0x%08x intre=0x%08x intrd=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_ENABLE
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCA
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_PERIOD_CURRENT_ED
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL_HEAD_ED
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL_CURRENT_ED
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_BULK_HEAD_ED
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_BULK_CURRENT_ED
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"               done=0x%08x fmival=0x%08x fmrem=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_DONE_HEAD
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_INTERVAL
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_REMAINING
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_NUMBER
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_PERIODIC_START
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_LS_THRESHOLD
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"               desca=0x%08x descb=0x%08x stat=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_B
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_STATUS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"               port1=0x%08x port2=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_PORT_STATUS
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_PORT_STATUS
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"         HCCA: frame_number=0x%04x done_head=0x%08x\n"
operator|,
name|le32toh
argument_list|(
name|sc
operator|->
name|sc_hcca
operator|->
name|hcca_frame_number
argument_list|)
operator|,
name|le32toh
argument_list|(
name|sc
operator|->
name|sc_hcca
operator|->
name|hcca_done_head
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|Static
name|int
name|ohci_intr1
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|ohci_intr
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|p
decl_stmt|;
comment|/* If we get an interrupt while polling, then just ignore it. */
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"ohci_intr: ignored interrupt while polling\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ohci_intr1
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|int
name|ohci_intr1
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|intrs
decl_stmt|,
name|eintrs
decl_stmt|;
name|ohci_physaddr_t
name|done
decl_stmt|;
comment|/* In case the interrupt occurs before initialization has completed. */
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|sc_hcca
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"ohci_intr: sc->sc_hcca == NULL\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|intrs
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|sc_hcca
operator|->
name|hcca_done_head
argument_list|)
expr_stmt|;
comment|/* The LSb of done is used to inform the HC Driver that an interrupt 	 * condition exists for both the Done list and for another event 	 * recorded in HcInterruptStatus. On an interrupt from the HC, the HC 	 * Driver checks the HccaDoneHead Value. If this value is 0, then the 	 * interrupt was caused by other than the HccaDoneHead update and the 	 * HcInterruptStatus register needs to be accessed to determine that 	 * exact interrupt cause. If HccaDoneHead is nonzero, then a Done list 	 * update interrupt is indicated and if the LSb of done is nonzero, 	 * then an additional interrupt event is indicated and 	 * HcInterruptStatus should be checked to determine its cause. 	 */
if|if
condition|(
name|done
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|done
operator|&
operator|~
name|OHCI_DONE_INTRS
condition|)
name|intrs
operator|=
name|OHCI_WDH
expr_stmt|;
if|if
condition|(
name|done
operator|&
name|OHCI_DONE_INTRS
condition|)
block|{
name|intrs
operator||=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
expr_stmt|;
name|done
operator|&=
operator|~
name|OHCI_DONE_INTRS
expr_stmt|;
block|}
block|}
else|else
block|{
name|intrs
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intrs
operator|==
literal|0
condition|)
comment|/* nothing to be done (PCI shared interrupt) */
return|return
operator|(
literal|0
operator|)
return|;
name|intrs
operator|&=
operator|~
name|OHCI_MIE
expr_stmt|;
comment|/* mask out Master Interrupt Enable */
comment|/* Acknowledge any interrupts that have happened */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|,
name|intrs
argument_list|)
expr_stmt|;
comment|/* Any interrupts we had enabled? */
name|eintrs
operator|=
name|intrs
operator|&
name|sc
operator|->
name|sc_eintrs
expr_stmt|;
if|if
condition|(
operator|!
name|eintrs
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|no_intrs
operator|++
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|7
argument_list|,
operator|(
literal|"ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n"
operator|,
name|sc
operator|,
operator|(
name|u_int
operator|)
name|intrs
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
operator|,
operator|(
name|u_int
operator|)
name|eintrs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eintrs
operator|&
name|OHCI_SO
condition|)
block|{
name|printf
argument_list|(
literal|"%s: scheduling overrun\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX do what */
name|intrs
operator|&=
operator|~
name|OHCI_SO
expr_stmt|;
block|}
if|if
condition|(
name|eintrs
operator|&
name|OHCI_WDH
condition|)
block|{
name|done
operator|&=
operator|~
name|OHCI_DONE_INTRS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_done
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_done
operator|=
name|done
expr_stmt|;
else|else
block|{
comment|/* Tack on at the end of sc_done. */
name|ohci_physaddr_t
name|ldone
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|ldone
operator|=
name|sc
operator|->
name|sc_done
expr_stmt|;
comment|/* always non 0 */
do|do
block|{
name|std
operator|=
name|ohci_hash_find_td
argument_list|(
name|sc
argument_list|,
name|ldone
argument_list|)
expr_stmt|;
name|ldone
operator|=
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_nexttd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ldone
operator|!=
literal|0
condition|)
do|;
name|std
operator|->
name|td
operator|.
name|td_nexttd
operator|=
name|le32toh
argument_list|(
name|done
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_hcca
operator|->
name|hcca_done_head
operator|=
literal|0
expr_stmt|;
name|usb_schedsoftintr
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|intrs
operator|&=
operator|~
name|OHCI_WDH
expr_stmt|;
block|}
if|if
condition|(
name|eintrs
operator|&
name|OHCI_RD
condition|)
block|{
name|printf
argument_list|(
literal|"%s: resume detect\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX process resume detect */
block|}
if|if
condition|(
name|eintrs
operator|&
name|OHCI_UE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unrecoverable error, controller halted\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_RESET
argument_list|)
expr_stmt|;
comment|/* XXX what else */
block|}
if|if
condition|(
name|eintrs
operator|&
name|OHCI_RHSC
condition|)
block|{
name|ohci_rhsc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_intrxfer
argument_list|)
expr_stmt|;
name|intrs
operator|&=
operator|~
name|OHCI_RHSC
expr_stmt|;
comment|/* 		 * Disable RHSC interrupt for now, because it will be 		 * on until the port has been reset. 		 */
name|ohci_rhsc_able
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|--
expr_stmt|;
comment|/* Block unprocessed interrupts. XXX */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|,
name|intrs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_eintrs
operator|&=
operator|~
name|intrs
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_rhsc_able
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ohci_rhsc_able: on=%d\n"
operator|,
name|on
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
name|sc
operator|->
name|sc_eintrs
operator||=
name|OHCI_RHSC
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_ENABLE
argument_list|,
name|OHCI_RHSC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_eintrs
operator|&=
operator|~
name|OHCI_RHSC
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|,
name|OHCI_RHSC
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OHCI_DEBUG
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|ohci_cc_strs
index|[]
init|=
block|{
literal|"NO_ERROR"
block|,
literal|"CRC"
block|,
literal|"BIT_STUFFING"
block|,
literal|"DATA_TOGGLE_MISMATCH"
block|,
literal|"STALL"
block|,
literal|"DEVICE_NOT_RESPONDING"
block|,
literal|"PID_CHECK_FAILURE"
block|,
literal|"UNEXPECTED_PID"
block|,
literal|"DATA_OVERRUN"
block|,
literal|"DATA_UNDERRUN"
block|,
literal|"BUFFER_OVERRUN"
block|,
literal|"BUFFER_UNDERRUN"
block|,
literal|"reserved"
block|,
literal|"reserved"
block|,
literal|"NOT_ACCESSED"
block|,
literal|"NOT_ACCESSED"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|ohci_softintr
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|bus
decl_stmt|;
name|ohci_physaddr_t
name|done
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|sdone
decl_stmt|,
modifier|*
name|stdnext
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|int
name|len
decl_stmt|,
name|cc
decl_stmt|,
name|s
decl_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|++
expr_stmt|;
name|s
operator|=
name|splhardusb
argument_list|()
expr_stmt|;
name|done
operator|=
name|sc
operator|->
name|sc_done
expr_stmt|;
name|sc
operator|->
name|sc_done
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_process_done: done=0x%08lx\n"
operator|,
operator|(
name|u_long
operator|)
name|done
operator|)
argument_list|)
expr_stmt|;
comment|/* Reverse the done list and store the reversed list in sdone */
name|sdone
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|done
condition|;
name|done
operator|=
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_nexttd
argument_list|)
control|)
block|{
name|std
operator|=
name|ohci_hash_find_td
argument_list|(
name|sc
argument_list|,
name|done
operator|&
name|htole32
argument_list|(
name|OHCI_HEADMASK
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|OHCI_DEBUG
name|DPRINTF
argument_list|(
operator|(
literal|"%s: Invalid done queue 0x%08x"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|,
name|done
operator|)
argument_list|)
expr_stmt|;
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX Should we compare the list of active TDs with 			 * the list of TDs queued at EDs to handle the ones that 			 * are not listed on any of the ED queues and therefore 			 * must be finished? 			 */
return|return;
block|}
name|std
operator|->
name|dnext
operator|=
name|sdone
expr_stmt|;
name|sdone
operator|=
name|std
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OHCI_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_process_done: TD done:\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|std
operator|=
name|sdone
init|;
name|std
condition|;
name|std
operator|=
name|std
operator|->
name|dnext
control|)
name|ohci_dump_td
argument_list|(
name|sdone
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|std
operator|=
name|sdone
init|;
name|std
condition|;
name|std
operator|=
name|stdnext
control|)
block|{
name|xfer
operator|=
name|std
operator|->
name|xfer
expr_stmt|;
name|stdnext
operator|=
name|std
operator|->
name|dnext
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ohci_process_done: std=%p xfer=%p hcpriv=%p\n"
operator|,
name|std
operator|,
name|xfer
operator|,
operator|(
name|xfer
condition|?
name|xfer
operator|->
name|hcpriv
else|:
name|NULL
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
operator|||
operator|(
name|std
operator|->
name|flags
operator|&
name|OHCI_TD_HANDLED
operator|)
condition|)
block|{
comment|/* xfer == NULL: There seems to be no xfer associated 			 * with this TD. It is tailp that happened to end up on 			 * the done queue. 			 * flags& OHCI_TD_HANDLED: The TD has already been 			 * handled by process_done and should not be done again. 			 */
continue|continue;
block|}
name|cc
operator|=
name|OHCI_TD_GET_CC
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_flags
argument_list|)
argument_list|)
expr_stmt|;
name|usb_untimeout
argument_list|(
name|ohci_timeout
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|timo_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|status
operator|==
name|USBD_CANCELLED
operator|||
name|xfer
operator|->
name|status
operator|==
name|USBD_TIMEOUT
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_process_done: cancel/timeout, xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled by abort routine. */
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
name|OHCI_CC_NO_ERROR
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"ohci_process_done: no error, xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|std
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|std
operator|->
name|td
operator|.
name|td_cbp
operator|!=
literal|0
condition|)
name|len
operator|-=
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_be
argument_list|)
operator|-
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_cbp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|std
operator|->
name|flags
operator|&
name|OHCI_ADD_LEN
condition|)
name|xfer
operator|->
name|actlen
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|std
operator|->
name|flags
operator|&
name|OHCI_CALL_DONE
condition|)
block|{
name|xfer
operator|->
name|status
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Endpoint is halted.  First unlink all the TDs 			 * belonging to the failed transfer, and then restart 			 * the endpoint. 			 */
name|ohci_soft_td_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_process_done: err cc=%d (%s), xfer=%p\n"
operator|,
name|OHCI_TD_GET_CC
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_flags
argument_list|)
argument_list|)
operator|,
name|ohci_cc_strs
index|[
name|OHCI_TD_GET_CC
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_flags
argument_list|)
argument_list|)
index|]
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
comment|/* Mark all the TDs in the done queue for the current 			 * xfer as handled 			 */
for|for
control|(
name|p
operator|=
name|stdnext
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|dnext
control|)
block|{
if|if
condition|(
name|p
operator|->
name|xfer
operator|==
name|xfer
condition|)
name|p
operator|->
name|flags
operator||=
name|OHCI_TD_HANDLED
expr_stmt|;
block|}
comment|/* remove TDs for the current xfer from the ED */
for|for
control|(
name|p
operator|=
name|std
init|;
name|p
operator|->
name|xfer
operator|==
name|xfer
condition|;
name|p
operator|=
name|n
control|)
block|{
name|n
operator|=
name|p
operator|->
name|nexttd
expr_stmt|;
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|opipe
operator|->
name|sed
operator|->
name|ed
operator|.
name|ed_headp
operator|=
name|htole32
argument_list|(
name|p
operator|->
name|physaddr
argument_list|)
expr_stmt|;
comment|/* XXX why is this being done? Why not OHCI_BLF too */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_CLF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
name|OHCI_CC_STALL
condition|)
name|xfer
operator|->
name|status
operator|=
name|USBD_STALLED
expr_stmt|;
else|else
name|xfer
operator|->
name|status
operator|=
name|USBD_IOERROR
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_device_ctrl_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_ctrl_done: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"ohci_ctrl_done: not a request\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|xfer
operator|->
name|hcpriv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_device_intr_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|opipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
init|=
name|opipe
operator|->
name|sed
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_intr_done: xfer=%p, actlen=%d\n"
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|hcpriv
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|pipe
operator|->
name|repeat
condition|)
block|{
name|data
operator|=
name|opipe
operator|->
name|tail
operator|.
name|td
expr_stmt|;
name|tail
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX should reuse TD */
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|xfer
operator|->
name|status
operator|=
name|USBD_NOMEM
expr_stmt|;
return|return;
block|}
name|tail
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
name|OHCI_TD_IN
operator||
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_SET_DI
argument_list|(
literal|1
argument_list|)
operator||
name|OHCI_TD_TOGGLE_CARRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags
operator|&
name|USBD_SHORT_XFER_OK
condition|)
name|data
operator|->
name|td
operator|.
name|td_flags
operator||=
name|htole32
argument_list|(
name|OHCI_TD_R
argument_list|)
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_cbp
operator|=
name|htole32
argument_list|(
name|DMAADDR
argument_list|(
operator|&
name|xfer
operator|->
name|dmabuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|nexttd
operator|=
name|tail
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_nexttd
operator|=
name|htole32
argument_list|(
name|tail
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_be
operator|=
name|htole32
argument_list|(
name|htole32
argument_list|(
name|data
operator|->
name|td
operator|.
name|td_cbp
argument_list|)
operator|+
name|xfer
operator|->
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|data
operator|->
name|len
operator|=
name|xfer
operator|->
name|length
expr_stmt|;
name|data
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|data
operator|->
name|flags
operator|=
name|OHCI_CALL_DONE
operator||
name|OHCI_ADD_LEN
expr_stmt|;
name|xfer
operator|->
name|hcpriv
operator|=
name|data
expr_stmt|;
name|xfer
operator|->
name|actlen
operator|=
literal|0
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
operator|=
name|htole32
argument_list|(
name|tail
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|opipe
operator|->
name|tail
operator|.
name|td
operator|=
name|tail
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ohci_device_bulk_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_bulk_done: xfer=%p, actlen=%d\n"
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|hcpriv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_rhsc
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_pipe_handle
name|pipe
decl_stmt|;
name|struct
name|ohci_pipe
modifier|*
name|opipe
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|m
decl_stmt|;
name|int
name|hstatus
decl_stmt|;
name|hstatus
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_STATUS
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\n"
operator|,
name|sc
operator|,
name|xfer
operator|,
name|hstatus
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
comment|/* Just ignore the change. */
return|return;
block|}
name|pipe
operator|=
name|xfer
operator|->
name|pipe
expr_stmt|;
name|opipe
operator|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
expr_stmt|;
name|p
operator|=
name|KERNADDR
argument_list|(
operator|&
name|xfer
operator|->
name|dmabuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m
operator|=
name|min
argument_list|(
name|sc
operator|->
name|sc_noport
argument_list|,
name|xfer
operator|->
name|length
operator|*
literal|8
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|xfer
operator|->
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|m
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_PORT_STATUS
argument_list|(
name|i
argument_list|)
argument_list|)
operator|>>
literal|16
condition|)
name|p
index|[
name|i
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_rhsc: change=0x%02x\n"
operator|,
operator|*
name|p
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|actlen
operator|=
name|xfer
operator|->
name|length
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_root_intr_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|xfer
operator|->
name|hcpriv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_root_ctrl_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|xfer
operator|->
name|hcpriv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait here until controller claims to have an interrupt.  * Then call ohci_intr and return.  Use timeout to avoid waiting  * too long.  */
end_comment

begin_function
name|void
name|ohci_waitintr
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|int
name|timo
init|=
name|xfer
operator|->
name|timeout
decl_stmt|;
name|int
name|usecs
decl_stmt|;
name|u_int32_t
name|intrs
decl_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
for|for
control|(
name|usecs
operator|=
name|timo
operator|*
literal|1000000
operator|/
name|hz
init|;
name|usecs
operator|>
literal|0
condition|;
name|usecs
operator|-=
literal|1000
control|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intrs
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
operator|&
name|sc
operator|->
name|sc_eintrs
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"ohci_waitintr: 0x%04x\n"
operator|,
name|intrs
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OHCI_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|15
condition|)
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|intrs
condition|)
block|{
name|ohci_intr1
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|status
operator|!=
name|USBD_IN_PROGRESS
condition|)
return|return;
block|}
block|}
comment|/* Timeout */
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_waitintr: timeout\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OHCI_DEBUG
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xfer
operator|->
name|status
operator|=
name|USBD_TIMEOUT
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* XXX should free TD */
block|}
end_function

begin_function
name|void
name|ohci_poll
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|bus
decl_stmt|;
if|if
condition|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
operator|&
name|sc
operator|->
name|sc_eintrs
condition|)
name|ohci_intr1
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|ohci_device_request
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usb_device_request_t
modifier|*
name|req
init|=
operator|&
name|xfer
operator|->
name|request
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|opipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|int
name|addr
init|=
name|dev
operator|->
name|address
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|setup
decl_stmt|,
modifier|*
name|data
init|=
literal|0
decl_stmt|,
modifier|*
name|stat
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
name|int
name|isread
decl_stmt|;
name|int
name|len
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|s
decl_stmt|;
name|isread
operator|=
name|req
operator|->
name|bmRequestType
operator|&
name|UT_READ
expr_stmt|;
name|len
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"ohci_device_control type=0x%02x, request=0x%02x, "
literal|"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\n"
operator|,
name|req
operator|->
name|bmRequestType
operator|,
name|req
operator|->
name|bRequest
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
operator|,
name|len
operator|,
name|addr
operator|,
name|opipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|)
argument_list|)
expr_stmt|;
name|setup
operator|=
name|opipe
operator|->
name|tail
operator|.
name|td
expr_stmt|;
name|stat
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
name|tail
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|tail
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|sed
operator|=
name|opipe
operator|->
name|sed
expr_stmt|;
name|opipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|length
operator|=
name|len
expr_stmt|;
comment|/* Update device address and length since they may have changed. */
comment|/* XXX This only needs to be done once, but it's too early in open. */
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|=
name|htole32
argument_list|(
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_flags
argument_list|)
operator|&
operator|~
operator|(
name|OHCI_ED_ADDRMASK
operator||
name|OHCI_ED_MAXPMASK
operator|)
operator|)
operator||
name|OHCI_ED_SET_FA
argument_list|(
name|addr
argument_list|)
operator||
name|OHCI_ED_SET_MAXP
argument_list|(
name|UGETW
argument_list|(
name|opipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up data transaction */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|data
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad3
goto|;
block|}
name|data
operator|->
name|td
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
operator|(
name|isread
condition|?
name|OHCI_TD_IN
else|:
name|OHCI_TD_OUT
operator|)
operator||
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_TOGGLE_1
operator||
name|OHCI_TD_NOINTR
operator||
operator|(
name|xfer
operator|->
name|flags
operator|&
name|USBD_SHORT_XFER_OK
condition|?
name|OHCI_TD_R
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_cbp
operator|=
name|htole32
argument_list|(
name|DMAADDR
argument_list|(
operator|&
name|xfer
operator|->
name|dmabuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|nexttd
operator|=
name|stat
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_nexttd
operator|=
name|htole32
argument_list|(
name|stat
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_be
operator|=
name|htole32
argument_list|(
name|le32toh
argument_list|(
name|data
operator|->
name|td
operator|.
name|td_cbp
argument_list|)
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|data
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|data
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|data
operator|->
name|flags
operator|=
name|OHCI_ADD_LEN
expr_stmt|;
name|next
operator|=
name|data
expr_stmt|;
name|stat
operator|->
name|flags
operator|=
name|OHCI_CALL_DONE
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|stat
expr_stmt|;
comment|/* XXX ADD_LEN? */
name|stat
operator|->
name|flags
operator|=
name|OHCI_CALL_DONE
operator||
name|OHCI_ADD_LEN
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|KERNADDR
argument_list|(
operator|&
name|opipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|,
literal|0
argument_list|)
argument_list|,
name|req
argument_list|,
sizeof|sizeof
expr|*
name|req
argument_list|)
expr_stmt|;
name|setup
operator|->
name|td
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
name|OHCI_TD_SETUP
operator||
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_TOGGLE_0
operator||
name|OHCI_TD_NOINTR
argument_list|)
expr_stmt|;
name|setup
operator|->
name|td
operator|.
name|td_cbp
operator|=
name|htole32
argument_list|(
name|DMAADDR
argument_list|(
operator|&
name|opipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|setup
operator|->
name|nexttd
operator|=
name|next
expr_stmt|;
name|setup
operator|->
name|td
operator|.
name|td_nexttd
operator|=
name|htole32
argument_list|(
name|next
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|setup
operator|->
name|td
operator|.
name|td_be
operator|=
name|htole32
argument_list|(
name|le32toh
argument_list|(
name|setup
operator|->
name|td
operator|.
name|td_cbp
argument_list|)
operator|+
sizeof|sizeof
expr|*
name|req
operator|-
literal|1
argument_list|)
expr_stmt|;
name|setup
operator|->
name|len
operator|=
literal|0
expr_stmt|;
comment|/* XXX The number of byte we count */
name|setup
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|setup
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|hcpriv
operator|=
name|setup
expr_stmt|;
name|stat
operator|->
name|td
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
operator|(
name|isread
condition|?
name|OHCI_TD_OUT
else|:
name|OHCI_TD_IN
operator|)
operator||
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_TOGGLE_1
operator||
name|OHCI_TD_SET_DI
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|stat
operator|->
name|td
operator|.
name|td_cbp
operator|=
literal|0
expr_stmt|;
name|stat
operator|->
name|nexttd
operator|=
name|tail
expr_stmt|;
name|stat
operator|->
name|td
operator|.
name|td_nexttd
operator|=
name|htole32
argument_list|(
name|tail
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|stat
operator|->
name|td
operator|.
name|td_be
operator|=
literal|0
expr_stmt|;
name|stat
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|stat
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
ifdef|#
directive|ifdef
name|OHCI_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|5
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_request:\n"
operator|)
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sed
argument_list|)
expr_stmt|;
name|ohci_dump_tds
argument_list|(
name|setup
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Insert ED in schedule */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
operator|=
name|htole32
argument_list|(
name|tail
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|opipe
operator|->
name|tail
operator|.
name|td
operator|=
name|tail
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_CLF
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|&&
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|usb_timeout
argument_list|(
name|ohci_timeout
argument_list|,
name|xfer
argument_list|,
name|MS_TO_TICKS
argument_list|(
name|xfer
operator|->
name|timeout
argument_list|)
argument_list|,
name|xfer
operator|->
name|timo_handle
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OHCI_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|25
condition|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_request: status=%x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sed
argument_list|)
expr_stmt|;
name|ohci_dump_tds
argument_list|(
name|setup
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad3
label|:
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|bad2
label|:
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|bad1
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an ED to the schedule.  Called at splusb().  */
end_comment

begin_function
name|void
name|ohci_add_ed
parameter_list|(
name|ohci_soft_ed_t
modifier|*
name|sed
parameter_list|,
name|ohci_soft_ed_t
modifier|*
name|head
parameter_list|)
block|{
name|SPLUSBCHECK
expr_stmt|;
name|sed
operator|->
name|next
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_nexted
operator|=
name|head
operator|->
name|ed
operator|.
name|ed_nexted
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|sed
expr_stmt|;
name|head
operator|->
name|ed
operator|.
name|ed_nexted
operator|=
name|htole32
argument_list|(
name|sed
operator|->
name|physaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove an ED from the schedule.  Called at splusb().  */
end_comment

begin_function
name|void
name|ohci_rem_ed
parameter_list|(
name|ohci_soft_ed_t
modifier|*
name|sed
parameter_list|,
name|ohci_soft_ed_t
modifier|*
name|head
parameter_list|)
block|{
name|ohci_soft_ed_t
modifier|*
name|p
decl_stmt|;
name|SPLUSBCHECK
expr_stmt|;
comment|/* XXX */
for|for
control|(
name|p
operator|=
name|head
init|;
name|p
operator|==
name|NULL
operator|&&
name|p
operator|->
name|next
operator|!=
name|sed
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ohci_rem_ed: ED not found\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|sed
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|ed
operator|.
name|ed_nexted
operator|=
name|sed
operator|->
name|ed
operator|.
name|ed_nexted
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When a transfer is completed the TD is added to the done queue by  * the host controller.  This queue is the processed by software.  * Unfortunately the queue contains the physical address of the TD  * and we have no simple way to translate this back to a kernel address.  * To make the translation possible (and fast) we use a hash table of  * TDs currently in the schedule.  The physical address is used as the  * hash value.  */
end_comment

begin_define
define|#
directive|define
name|HASH
parameter_list|(
name|a
parameter_list|)
value|(((a)>> 4) % OHCI_HASH_SIZE)
end_define

begin_comment
comment|/* Called at splusb() */
end_comment

begin_function
name|void
name|ohci_hash_add_td
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_soft_td_t
modifier|*
name|std
parameter_list|)
block|{
name|int
name|h
init|=
name|HASH
argument_list|(
name|std
operator|->
name|physaddr
argument_list|)
decl_stmt|;
name|SPLUSBCHECK
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_hash_tds
index|[
name|h
index|]
argument_list|,
name|std
argument_list|,
name|hnext
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at splusb() */
end_comment

begin_function
name|void
name|ohci_hash_rem_td
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_soft_td_t
modifier|*
name|std
parameter_list|)
block|{
name|SPLUSBCHECK
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|std
argument_list|,
name|hnext
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ohci_soft_td_t
modifier|*
name|ohci_hash_find_td
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_physaddr_t
name|a
parameter_list|)
block|{
name|int
name|h
init|=
name|HASH
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|std
decl_stmt|;
comment|/* if these are present they should be masked out at an earlier 	 * stage. 	 */
name|KASSERT
argument_list|(
operator|(
name|a
operator|&
operator|~
name|OHCI_HEADMASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: 0x%b has lower bits set\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|,
operator|(
name|int
operator|)
name|a
operator|,
literal|"\20\1HALT\2TOGGLE"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|std
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_hash_tds
index|[
name|h
index|]
argument_list|)
init|;
name|std
operator|!=
name|NULL
condition|;
name|std
operator|=
name|LIST_NEXT
argument_list|(
name|std
argument_list|,
name|hnext
argument_list|)
control|)
if|if
condition|(
name|std
operator|->
name|physaddr
operator|==
name|a
condition|)
return|return
operator|(
name|std
operator|)
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: ohci_hash_find_td: addr 0x%08lx not found\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|a
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|ohci_timeout
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|usbd_xfer_handle
name|xfer
init|=
name|addr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_timeout: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|xfer
operator|->
name|device
operator|->
name|bus
operator|->
name|intr_context
operator|++
expr_stmt|;
name|ohci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_TIMEOUT
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|device
operator|->
name|bus
operator|->
name|intr_context
operator|--
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OHCI_DEBUG
end_ifdef

begin_function
name|void
name|ohci_dump_tds
parameter_list|(
name|ohci_soft_td_t
modifier|*
name|std
parameter_list|)
block|{
for|for
control|(
init|;
name|std
condition|;
name|std
operator|=
name|std
operator|->
name|nexttd
control|)
name|ohci_dump_td
argument_list|(
name|std
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_dump_td
parameter_list|(
name|ohci_soft_td_t
modifier|*
name|std
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"TD(%p) at %08lx: %b delay=%d ec=%d cc=%d\ncbp=0x%08lx "
literal|"nexttd=0x%08lx be=0x%08lx\n"
operator|,
name|std
operator|,
operator|(
name|u_long
operator|)
name|std
operator|->
name|physaddr
operator|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_flags
argument_list|)
operator|,
literal|"\20\23R\24OUT\25IN\31TOG1\32SETTOGGLE"
operator|,
name|OHCI_TD_GET_DI
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_flags
argument_list|)
argument_list|)
operator|,
name|OHCI_TD_GET_EC
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_flags
argument_list|)
argument_list|)
operator|,
name|OHCI_TD_GET_CC
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_flags
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_cbp
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_nexttd
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_be
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_dump_ed
parameter_list|(
name|ohci_soft_ed_t
modifier|*
name|sed
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\ntailp=0x%08lx "
literal|"headflags=%b headp=0x%08lx nexted=0x%08lx\n"
operator|,
name|sed
operator|,
operator|(
name|u_long
operator|)
name|sed
operator|->
name|physaddr
operator|,
name|OHCI_ED_GET_FA
argument_list|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_flags
argument_list|)
argument_list|)
operator|,
name|OHCI_ED_GET_EN
argument_list|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_flags
argument_list|)
argument_list|)
operator|,
name|OHCI_ED_GET_MAXP
argument_list|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_flags
argument_list|)
argument_list|)
operator|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_flags
argument_list|)
operator|,
literal|"\20\14OUT\15IN\16LOWSPEED\17SKIP\20ISO"
operator|,
operator|(
name|int
operator|)
operator|(
name|uintptr_t
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
argument_list|)
operator|,
literal|"\20\1BIT1\2BIT2"
operator|,
operator|(
name|int
operator|)
operator|(
name|uintptr_t
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
operator|,
literal|"\20\1HALT\2CARRY"
operator|,
operator|(
name|u_long
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_nexted
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|usbd_status
name|ohci_open
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|usbd_device_handle
name|dev
init|=
name|pipe
operator|->
name|device
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
init|=
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
decl_stmt|;
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|u_int8_t
name|addr
init|=
name|dev
operator|->
name|address
decl_stmt|;
name|u_int8_t
name|xfertype
init|=
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|std
init|=
name|NULL
decl_stmt|;
name|ohci_soft_itd_t
modifier|*
name|sitd
decl_stmt|;
name|ohci_physaddr_t
name|tdphys
decl_stmt|;
name|u_int32_t
name|fmt
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|ival
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ohci_open: pipe=%p, addr=%d, endpt=%d (%d)\n"
operator|,
name|pipe
operator|,
name|addr
operator|,
name|ed
operator|->
name|bEndpointAddress
operator|,
name|sc
operator|->
name|sc_addr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|sc
operator|->
name|sc_addr
condition|)
block|{
switch|switch
condition|(
name|ed
operator|->
name|bEndpointAddress
condition|)
block|{
case|case
name|USB_CONTROL_ENDPOINT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ohci_root_ctrl_methods
expr_stmt|;
break|break;
case|case
name|UE_DIR_IN
operator||
name|OHCI_INTR_ENDPT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ohci_root_intr_methods
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
block|}
else|else
block|{
name|sed
operator|=
name|ohci_alloc_sed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sed
operator|==
name|NULL
condition|)
goto|goto
name|bad0
goto|;
name|opipe
operator|->
name|sed
operator|=
name|sed
expr_stmt|;
if|if
condition|(
name|xfertype
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
name|sitd
operator|=
name|ohci_alloc_sitd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sitd
operator|==
name|NULL
condition|)
block|{
name|ohci_free_sitd
argument_list|(
name|sc
argument_list|,
name|sitd
argument_list|)
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
name|opipe
operator|->
name|tail
operator|.
name|itd
operator|=
name|sitd
expr_stmt|;
name|tdphys
operator|=
name|sitd
operator|->
name|physaddr
expr_stmt|;
name|fmt
operator|=
name|OHCI_ED_FORMAT_ISO
expr_stmt|;
block|}
else|else
block|{
name|std
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|==
name|NULL
condition|)
block|{
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
name|opipe
operator|->
name|tail
operator|.
name|td
operator|=
name|std
expr_stmt|;
name|tdphys
operator|=
name|std
operator|->
name|physaddr
expr_stmt|;
name|fmt
operator|=
name|OHCI_ED_FORMAT_GEN
expr_stmt|;
block|}
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|=
name|htole32
argument_list|(
name|OHCI_ED_SET_FA
argument_list|(
name|addr
argument_list|)
operator||
name|OHCI_ED_SET_EN
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator||
name|OHCI_ED_DIR_TD
operator||
operator|(
name|dev
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|?
name|OHCI_ED_SPEED
else|:
literal|0
operator|)
operator||
name|fmt
operator||
name|OHCI_ED_SET_MAXP
argument_list|(
name|UGETW
argument_list|(
name|ed
operator|->
name|wMaxPacketSize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_headp
operator|=
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
operator|=
name|htole32
argument_list|(
name|tdphys
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|xfertype
condition|)
block|{
case|case
name|UE_CONTROL
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ohci_device_ctrl_methods
expr_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
sizeof|sizeof
argument_list|(
name|usb_device_request_t
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|opipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|bad
goto|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ohci_add_ed
argument_list|(
name|sed
argument_list|,
name|sc
operator|->
name|sc_ctrl_head
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_INTERRUPT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ohci_device_intr_methods
expr_stmt|;
name|ival
operator|=
name|pipe
operator|->
name|interval
expr_stmt|;
if|if
condition|(
name|ival
operator|==
name|USBD_DEFAULT_INTERVAL
condition|)
name|ival
operator|=
name|ed
operator|->
name|bInterval
expr_stmt|;
return|return
operator|(
name|ohci_device_setintr
argument_list|(
name|sc
argument_list|,
name|opipe
argument_list|,
name|ival
argument_list|)
operator|)
return|;
case|case
name|UE_ISOCHRONOUS
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ohci_device_isoc_methods
expr_stmt|;
return|return
operator|(
name|ohci_setup_isoc
argument_list|(
name|pipe
argument_list|)
operator|)
return|;
case|case
name|UE_BULK
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ohci_device_bulk_methods
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ohci_add_ed
argument_list|(
name|sed
argument_list|,
name|sc
operator|->
name|sc_bulk_head
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad
label|:
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
name|bad1
label|:
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|sed
argument_list|)
expr_stmt|;
name|bad0
label|:
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close a reqular pipe.  * Assumes that there are no pending transactions.  */
end_comment

begin_function
name|void
name|ohci_close_pipe
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|,
name|ohci_soft_ed_t
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
init|=
name|opipe
operator|->
name|sed
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
operator|!=
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
condition|)
block|{
name|ohci_physaddr_t
name|td
init|=
name|sed
operator|->
name|ed
operator|.
name|ed_headp
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|std
decl_stmt|;
for|for
control|(
name|std
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_hash_tds
index|[
name|HASH
argument_list|(
name|td
argument_list|)
index|]
argument_list|)
init|;
name|std
operator|!=
name|NULL
condition|;
name|std
operator|=
name|LIST_NEXT
argument_list|(
name|std
argument_list|,
name|hnext
argument_list|)
control|)
if|if
condition|(
name|std
operator|->
name|physaddr
operator|==
name|td
condition|)
break|break;
name|printf
argument_list|(
literal|"ohci_close_pipe: pipe not empty sed=%p hd=0x%x "
literal|"tl=0x%x pipe=%p, std=%p\n"
argument_list|,
name|sed
argument_list|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
argument_list|)
argument_list|,
name|pipe
argument_list|,
name|std
argument_list|)
expr_stmt|;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
operator|!=
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
condition|)
name|printf
argument_list|(
literal|"ohci_close_pipe: pipe still not empty\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ohci_rem_ed
argument_list|(
name|sed
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|opipe
operator|->
name|sed
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Abort a device request.  * If this routine is called at splusb() it guarantees that the request  * will be removed from the hardware scheduling and that the callback  * for it will be called with USBD_CANCELLED status.  * It's impossible to guarantee that the requested transfer will not  * have happened since the hardware runs concurrently.  * If the transaction has already happened we rely on the ordinary  * interrupt processing to process it.  */
end_comment

begin_function
name|void
name|ohci_abort_xfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_status
name|status
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_abort_xfer: xfer=%p pipe=%p\n"
operator|,
name|xfer
operator|,
name|opipe
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|status
expr_stmt|;
name|usb_untimeout
argument_list|(
name|ohci_timeout
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|timo_handle
argument_list|)
expr_stmt|;
name|sed
operator|=
name|opipe
operator|->
name|sed
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* force hardware skip */
ifdef|#
directive|ifdef
name|OHCI_DEBUG
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ohci_abort_xfer: stop ed=%p\n"
operator|,
name|sed
operator|)
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sed
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|1
if|if
condition|(
name|xfer
operator|->
name|device
operator|->
name|bus
operator|->
name|intr_context
condition|)
block|{
comment|/* We have no process context, so we can't use tsleep(). */
name|timeout
argument_list|(
name|ohci_abort_xfer_end
argument_list|,
name|xfer
argument_list|,
name|hz
operator|/
name|USB_FRAMES_PER_SECOND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|KASSERT
argument_list|(
name|curthread
operator|->
name|td_intr_nesting_level
operator|==
literal|0
argument_list|,
operator|(
literal|"ohci_abort_req in interrupt context"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usb_delay_ms
argument_list|(
name|opipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ohci_abort_xfer_end
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|delay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|ohci_abort_xfer_end
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ohci_abort_xfer_end
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|usbd_xfer_handle
name|xfer
init|=
name|v
decl_stmt|;
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|opipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|p
operator|=
name|xfer
operator|->
name|hcpriv
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ohci_abort_xfer: hcpriv==0\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
for|for
control|(
init|;
name|p
operator|->
name|xfer
operator|==
name|xfer
condition|;
name|p
operator|=
name|n
control|)
block|{
name|n
operator|=
name|p
operator|->
name|nexttd
expr_stmt|;
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|sed
operator|=
name|opipe
operator|->
name|sed
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_abort_xfer: set hd=%x, tl=%x\n"
operator|,
operator|(
name|int
operator|)
name|p
operator|->
name|physaddr
operator|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_headp
operator|=
name|htole32
argument_list|(
name|p
operator|->
name|physaddr
argument_list|)
expr_stmt|;
comment|/* unlink TDs */
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* remove hardware skip */
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Data structures and routines to emulate the root hub.  */
end_comment

begin_decl_stmt
name|Static
name|usb_device_descriptor_t
name|ohci_devd
init|=
block|{
name|USB_DEVICE_DESCRIPTOR_SIZE
block|,
name|UDESC_DEVICE
block|,
comment|/* type */
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* USB version */
name|UDCLASS_HUB
block|,
comment|/* class */
name|UDSUBCLASS_HUB
block|,
comment|/* subclass */
literal|0
block|,
comment|/* protocol */
literal|64
block|,
comment|/* max packet */
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* device id */
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* string indicies */
literal|1
comment|/* # of configurations */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|usb_config_descriptor_t
name|ohci_confd
init|=
block|{
name|USB_CONFIG_DESCRIPTOR_SIZE
block|,
name|UDESC_CONFIG
block|,
block|{
name|USB_CONFIG_DESCRIPTOR_SIZE
operator|+
name|USB_INTERFACE_DESCRIPTOR_SIZE
operator|+
name|USB_ENDPOINT_DESCRIPTOR_SIZE
block|}
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|UC_SELF_POWERED
block|,
literal|0
comment|/* max power */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|usb_interface_descriptor_t
name|ohci_ifcd
init|=
block|{
name|USB_INTERFACE_DESCRIPTOR_SIZE
block|,
name|UDESC_INTERFACE
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
name|UICLASS_HUB
block|,
name|UISUBCLASS_HUB
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|usb_endpoint_descriptor_t
name|ohci_endpd
init|=
block|{
name|USB_ENDPOINT_DESCRIPTOR_SIZE
block|,
name|UDESC_ENDPOINT
block|,
name|UE_DIR_IN
operator||
name|OHCI_INTR_ENDPT
block|,
name|UE_INTERRUPT
block|,
block|{
literal|8
block|,
literal|0
block|}
block|,
comment|/* max packet */
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|usb_hub_descriptor_t
name|ohci_hubd
init|=
block|{
name|USB_HUB_DESCRIPTOR_SIZE
block|,
name|UDESC_HUB
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|Static
name|int
name|ohci_str
parameter_list|(
name|usb_string_descriptor_t
modifier|*
name|p
parameter_list|,
name|int
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|->
name|bLength
operator|=
literal|2
operator|*
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|p
operator|->
name|bDescriptorType
operator|=
name|UDESC_STRING
expr_stmt|;
name|l
operator|-=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
index|[
name|i
index|]
operator|&&
name|l
operator|>
literal|1
condition|;
name|i
operator|++
operator|,
name|l
operator|-=
literal|2
control|)
name|USETW2
argument_list|(
name|p
operator|->
name|bString
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|*
name|i
operator|+
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simulate a hardware hub by handling all the necessary requests.  */
end_comment

begin_function
name|Static
name|usbd_status
name|ohci_root_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Pipe isn't running, start first */
return|return
operator|(
name|ohci_root_ctrl_start
argument_list|(
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_root_ctrl_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|xfer
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|usb_device_request_t
modifier|*
name|req
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|port
decl_stmt|,
name|i
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|,
name|value
decl_stmt|,
name|index
decl_stmt|,
name|l
decl_stmt|,
name|totlen
init|=
literal|0
decl_stmt|;
name|usb_port_status_t
name|ps
decl_stmt|;
name|usb_hub_descriptor_t
name|hubd
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
operator|)
condition|)
comment|/* XXX panic */
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
endif|#
directive|endif
name|req
operator|=
operator|&
name|xfer
operator|->
name|request
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ohci_root_ctrl_control type=0x%02x request=%02x\n"
operator|,
name|req
operator|->
name|bmRequestType
operator|,
name|req
operator|->
name|bRequest
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
expr_stmt|;
name|value
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
expr_stmt|;
name|index
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|buf
operator|=
name|KERNADDR
argument_list|(
operator|&
name|xfer
operator|->
name|dmabuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) | ((y)<< 8))
switch|switch
condition|(
name|C
argument_list|(
name|req
operator|->
name|bRequest
argument_list|,
name|req
operator|->
name|bmRequestType
argument_list|)
condition|)
block|{
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
comment|/* 		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops 		 * for the integrated root hub. 		 */
break|break;
case|case
name|C
argument_list|(
name|UR_GET_CONFIG
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
name|sc
operator|->
name|sc_conf
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ohci_root_ctrl_control wValue=0x%04x\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
operator|>>
literal|8
condition|)
block|{
case|case
name|UDESC_DEVICE
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|totlen
operator|=
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_DEVICE_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|ohci_devd
operator|.
name|idVendor
argument_list|,
name|sc
operator|->
name|sc_id_vendor
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ohci_devd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESC_CONFIG
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|totlen
operator|=
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_CONFIG_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ohci_confd
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_INTERFACE_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ohci_ifcd
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_ENDPOINT_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ohci_endpd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESC_STRING
case|:
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
literal|0
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
case|case
literal|1
case|:
comment|/* Vendor */
name|totlen
operator|=
name|ohci_str
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|sc
operator|->
name|sc_vendor
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Product */
name|totlen
operator|=
name|ohci_str
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"OHCI root hub"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_INTERFACE
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
literal|0
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|USETW
argument_list|(
operator|(
operator|(
name|usb_status_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|wStatus
argument_list|,
name|UDS_SELF_POWERED
argument_list|)
expr_stmt|;
name|totlen
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_ENDPOINT
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|USETW
argument_list|(
operator|(
operator|(
name|usb_status_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|wStatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|totlen
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_SET_ADDRESS
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|>=
name|USB_MAX_DEVICES
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|sc
operator|->
name|sc_addr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_CONFIG
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|value
operator|!=
literal|1
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|sc
operator|->
name|sc_conf
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|C
argument_list|(
name|UR_SET_INTERFACE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SYNCH_FRAME
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
break|break;
comment|/* Hub requests */
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ohci_root_ctrl_control: UR_CLEAR_PORT_FEATURE "
literal|"port=%d feature=%d\n"
operator|,
name|index
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|1
operator|||
name|index
operator|>
name|sc
operator|->
name|sc_noport
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|port
operator|=
name|OHCI_RH_PORT_STATUS
argument_list|(
name|index
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_CURRENT_CONNECT_STATUS
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_OVERCURRENT_INDICATOR
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_POWER
case|:
comment|/* Yes, writing to the LOW_SPEED bit clears power. */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_LOW_SPEED
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONNECTION
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_CONNECT_STATUS
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_ENABLE
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_PORT_ENABLED
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_SUSPEND
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_SUSPEND
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_OVERCURRENT_INDICATOR
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_RESET
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_PORT_RESET
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_C_PORT_CONNECTION
case|:
case|case
name|UHF_C_PORT_ENABLE
case|:
case|case
name|UHF_C_PORT_SUSPEND
case|:
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
case|case
name|UHF_C_PORT_RESET
case|:
comment|/* Enable RHSC interrupt if condition is cleared. */
if|if
condition|(
operator|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|>>
literal|16
operator|)
operator|==
literal|0
condition|)
name|ohci_rhsc_able
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|v
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|)
expr_stmt|;
name|hubd
operator|=
name|ohci_hubd
expr_stmt|;
name|hubd
operator|.
name|bNbrPorts
operator|=
name|sc
operator|->
name|sc_noport
expr_stmt|;
name|USETW
argument_list|(
name|hubd
operator|.
name|wHubCharacteristics
argument_list|,
operator|(
name|v
operator|&
name|OHCI_NPS
condition|?
name|UHD_PWR_NO_SWITCH
else|:
name|v
operator|&
name|OHCI_PSM
condition|?
name|UHD_PWR_GANGED
else|:
name|UHD_PWR_INDIVIDUAL
operator|)
comment|/* XXX overcurrent */
argument_list|)
expr_stmt|;
name|hubd
operator|.
name|bPwrOn2PwrGood
operator|=
name|OHCI_GET_POTPGT
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_B
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|l
operator|=
name|sc
operator|->
name|sc_noport
init|;
name|l
operator|>
literal|0
condition|;
name|i
operator|++
operator|,
name|l
operator|-=
literal|8
operator|,
name|v
operator|>>=
literal|8
control|)
name|hubd
operator|.
name|DeviceRemovable
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|v
expr_stmt|;
name|hubd
operator|.
name|bDescLength
operator|=
name|USB_HUB_DESCRIPTOR_SIZE
operator|+
name|i
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|hubd
operator|.
name|bDescLength
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|hubd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|!=
literal|4
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* ? XXX */
name|totlen
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ohci_root_ctrl_transfer: get port status i=%d\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|1
operator|||
name|index
operator|>
name|sc
operator|->
name|sc_noport
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|len
operator|!=
literal|4
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|v
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_PORT_STATUS
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ohci_root_ctrl_transfer: port status=0x%04x\n"
operator|,
name|v
operator|)
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|ps
operator|.
name|wPortStatus
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|ps
operator|.
name|wPortChange
argument_list|,
name|v
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
sizeof|sizeof
name|ps
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ps
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|l
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
name|index
operator|<
literal|1
operator|||
name|index
operator|>
name|sc
operator|->
name|sc_noport
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|port
operator|=
name|OHCI_RH_PORT_STATUS
argument_list|(
name|index
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_PORT_ENABLED
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_SUSPEND
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_RESET
case|:
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ohci_root_ctrl_transfer: reset port %d\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_PORT_ROOT_RESET_DELAY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|&
name|UPS_RESET
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ohci port %d reset, status = 0x%04x\n"
operator|,
name|index
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_POWER
case|:
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_root_ctrl_transfer: set port power "
literal|"%d\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_PORT_POWER
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
break|break;
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|xfer
operator|->
name|actlen
operator|=
name|totlen
expr_stmt|;
name|err
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|ret
label|:
name|xfer
operator|->
name|status
operator|=
name|err
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a root control request. */
end_comment

begin_function
name|Static
name|void
name|ohci_root_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
comment|/* Nothing to do, all transfers are synchronous. */
block|}
end_function

begin_comment
comment|/* Close the root pipe. */
end_comment

begin_function
name|Static
name|void
name|ohci_root_ctrl_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_root_ctrl_close\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Nothing to do. */
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_root_intr_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Pipe isn't running, start first */
return|return
operator|(
name|ohci_root_intr_start
argument_list|(
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_root_intr_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_pipe_handle
name|pipe
init|=
name|xfer
operator|->
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|sc
operator|->
name|sc_intrxfer
operator|=
name|xfer
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a root interrupt request. */
end_comment

begin_function
name|Static
name|void
name|ohci_root_intr_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|==
name|xfer
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_root_intr_abort: remove\n"
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|=
name|NULL
expr_stmt|;
block|}
name|xfer
operator|->
name|status
operator|=
name|USBD_CANCELLED
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close the root pipe. */
end_comment

begin_function
name|Static
name|void
name|ohci_root_intr_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_root_intr_close\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intrxfer
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************/
end_comment

begin_function
name|Static
name|usbd_status
name|ohci_device_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Pipe isn't running, start first */
return|return
operator|(
name|ohci_device_ctrl_start
argument_list|(
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_device_ctrl_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|xfer
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
operator|)
condition|)
block|{
comment|/* XXX panic */
name|printf
argument_list|(
literal|"ohci_device_ctrl_transfer: not a request\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
endif|#
directive|endif
name|err
operator|=
name|ohci_device_request
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
name|ohci_waitintr
argument_list|(
name|sc
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a device control request. */
end_comment

begin_function
name|Static
name|void
name|ohci_device_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_ctrl_abort: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
name|ohci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close a device control pipe. */
end_comment

begin_function
name|Static
name|void
name|ohci_device_ctrl_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_ctrl_close: pipe=%p\n"
operator|,
name|pipe
operator|)
argument_list|)
expr_stmt|;
name|ohci_close_pipe
argument_list|(
name|pipe
argument_list|,
name|sc
operator|->
name|sc_ctrl_head
argument_list|)
expr_stmt|;
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|opipe
operator|->
name|tail
operator|.
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************/
end_comment

begin_function
name|Static
name|void
name|ohci_device_clear_toggle
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|opipe
operator|->
name|sed
operator|->
name|ed
operator|.
name|ed_headp
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_TOGGLECARRY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Static
name|void
name|ohci_noop
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{ }
end_function

begin_function
name|Static
name|usbd_status
name|ohci_device_bulk_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Pipe isn't running, start first */
return|return
operator|(
name|ohci_device_bulk_start
argument_list|(
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_device_bulk_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|opipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|int
name|addr
init|=
name|dev
operator|->
name|address
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|tail
decl_stmt|,
modifier|*
name|tdp
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|,
name|isread
decl_stmt|,
name|endpt
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
condition|)
block|{
comment|/* XXX panic */
name|printf
argument_list|(
literal|"ohci_device_bulk_start: a request\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
endif|#
directive|endif
name|len
operator|=
name|xfer
operator|->
name|length
expr_stmt|;
name|endpt
operator|=
name|xfer
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
name|isread
operator|=
name|UE_GET_DIR
argument_list|(
name|endpt
argument_list|)
operator|==
name|UE_DIR_IN
expr_stmt|;
name|sed
operator|=
name|opipe
operator|->
name|sed
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ohci_device_bulk_start: xfer=%p len=%d isread=%d "
literal|"flags=%d endpt=%d\n"
operator|,
name|xfer
operator|,
name|len
operator|,
name|isread
operator|,
name|xfer
operator|->
name|flags
operator|,
name|endpt
operator|)
argument_list|)
expr_stmt|;
name|opipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|isread
operator|=
name|isread
expr_stmt|;
name|opipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|length
operator|=
name|len
expr_stmt|;
comment|/* Update device address */
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|=
name|htole32
argument_list|(
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_flags
argument_list|)
operator|&
operator|~
name|OHCI_ED_ADDRMASK
operator|)
operator||
name|OHCI_ED_SET_FA
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate a chain of new TDs (including a new tail). */
name|data
operator|=
name|opipe
operator|->
name|tail
operator|.
name|td
expr_stmt|;
name|err
operator|=
name|ohci_alloc_std_chain
argument_list|(
name|opipe
argument_list|,
name|sc
argument_list|,
name|len
argument_list|,
name|isread
argument_list|,
name|xfer
operator|->
name|flags
argument_list|,
operator|&
name|xfer
operator|->
name|dmabuf
argument_list|,
name|data
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|tail
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|xfer
operator|->
name|hcpriv
operator|=
name|data
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ohci_device_bulk_start: ed_flags=0x%08x td_flags=0x%08x "
literal|"td_cbp=0x%08x td_be=0x%08x\n"
operator|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_flags
argument_list|)
operator|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|data
operator|->
name|td
operator|.
name|td_flags
argument_list|)
operator|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|data
operator|->
name|td
operator|.
name|td_cbp
argument_list|)
operator|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|data
operator|->
name|td
operator|.
name|td_be
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OHCI_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|4
condition|)
block|{
name|ohci_dump_ed
argument_list|(
name|sed
argument_list|)
expr_stmt|;
name|ohci_dump_tds
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Insert ED in schedule */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|tdp
operator|=
name|data
init|;
name|tdp
operator|!=
name|tail
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|nexttd
control|)
block|{
name|tdp
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
block|}
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
operator|=
name|htole32
argument_list|(
name|tail
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|opipe
operator|->
name|tail
operator|.
name|td
operator|=
name|tail
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_BLF
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|&&
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|usb_timeout
argument_list|(
name|ohci_timeout
argument_list|,
name|xfer
argument_list|,
name|MS_TO_TICKS
argument_list|(
name|xfer
operator|->
name|timeout
argument_list|)
argument_list|,
name|xfer
operator|->
name|timo_handle
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This goes wrong if we are too slow. */
block|if (ohcidebug> 5) { 		usb_delay_ms(&sc->sc_bus, 5); 		DPRINTF(("ohci_device_intr_transfer: status=%x\n", 			 OREAD4(sc, OHCI_COMMAND_STATUS))); 		ohci_dump_ed(sed); 		ohci_dump_tds(data); 	}
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|void
name|ohci_device_bulk_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_bulk_abort: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
name|ohci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close a device bulk pipe.  */
end_comment

begin_function
name|Static
name|void
name|ohci_device_bulk_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_bulk_close: pipe=%p\n"
operator|,
name|pipe
operator|)
argument_list|)
expr_stmt|;
name|ohci_close_pipe
argument_list|(
name|pipe
argument_list|,
name|sc
operator|->
name|sc_bulk_head
argument_list|)
expr_stmt|;
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|opipe
operator|->
name|tail
operator|.
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************/
end_comment

begin_function
name|Static
name|usbd_status
name|ohci_device_intr_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Pipe isn't running, start first */
return|return
operator|(
name|ohci_device_intr_start
argument_list|(
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_device_intr_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|opipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
init|=
name|opipe
operator|->
name|sed
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"ohci_device_intr_transfer: xfer=%p len=%d "
literal|"flags=%d priv=%p\n"
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|length
operator|,
name|xfer
operator|->
name|flags
operator|,
name|xfer
operator|->
name|priv
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
condition|)
name|panic
argument_list|(
literal|"ohci_device_intr_transfer: a request\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|xfer
operator|->
name|length
expr_stmt|;
name|data
operator|=
name|opipe
operator|->
name|tail
operator|.
name|td
expr_stmt|;
name|tail
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|tail
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
name|OHCI_TD_IN
operator||
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_SET_DI
argument_list|(
literal|1
argument_list|)
operator||
name|OHCI_TD_TOGGLE_CARRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags
operator|&
name|USBD_SHORT_XFER_OK
condition|)
name|data
operator|->
name|td
operator|.
name|td_flags
operator||=
name|htole32
argument_list|(
name|OHCI_TD_R
argument_list|)
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_cbp
operator|=
name|htole32
argument_list|(
name|DMAADDR
argument_list|(
operator|&
name|xfer
operator|->
name|dmabuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|nexttd
operator|=
name|tail
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_nexttd
operator|=
name|htole32
argument_list|(
name|tail
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_be
operator|=
name|htole32
argument_list|(
name|le32toh
argument_list|(
name|data
operator|->
name|td
operator|.
name|td_cbp
argument_list|)
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|data
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|data
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|data
operator|->
name|flags
operator|=
name|OHCI_CALL_DONE
operator||
name|OHCI_ADD_LEN
expr_stmt|;
name|xfer
operator|->
name|hcpriv
operator|=
name|data
expr_stmt|;
ifdef|#
directive|ifdef
name|OHCI_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|5
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_intr_transfer:\n"
operator|)
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sed
argument_list|)
expr_stmt|;
name|ohci_dump_tds
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Insert ED in schedule */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
operator|=
name|htole32
argument_list|(
name|tail
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|opipe
operator|->
name|tail
operator|.
name|td
operator|=
name|tail
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/*  * This goes horribly wrong, printing thousands of descriptors,  * because false references are followed due to the fact that the  * TD is gone.  */
block|if (ohcidebug> 5) { 		usb_delay_ms(&sc->sc_bus, 5); 		DPRINTF(("ohci_device_intr_transfer: status=%x\n", 			 OREAD4(sc, OHCI_COMMAND_STATUS))); 		ohci_dump_ed(sed); 		ohci_dump_tds(data); 	}
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a device control request. */
end_comment

begin_function
name|Static
name|void
name|ohci_device_intr_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
if|if
condition|(
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|==
name|xfer
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_intr_abort: remove\n"
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|=
name|NULL
expr_stmt|;
block|}
name|ohci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close a device interrupt pipe. */
end_comment

begin_function
name|Static
name|void
name|ohci_device_intr_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|int
name|nslots
init|=
name|opipe
operator|->
name|u
operator|.
name|intr
operator|.
name|nslots
decl_stmt|;
name|int
name|pos
init|=
name|opipe
operator|->
name|u
operator|.
name|intr
operator|.
name|pos
decl_stmt|;
name|int
name|j
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|sed
init|=
name|opipe
operator|->
name|sed
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ohci_device_intr_close: pipe=%p nslots=%d pos=%d\n"
operator|,
name|pipe
operator|,
name|nslots
operator|,
name|pos
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
operator|!=
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
condition|)
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
operator|!=
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
condition|)
name|panic
argument_list|(
literal|"%s: Intr pipe %p still has TDs queued\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|sc
operator|->
name|sc_eds
index|[
name|pos
index|]
init|;
name|p
operator|&&
name|p
operator|->
name|next
operator|!=
name|sed
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ohci_device_intr_close: ED not found\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|next
operator|=
name|sed
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|ed
operator|.
name|ed_nexted
operator|=
name|sed
operator|->
name|ed
operator|.
name|ed_nexted
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nslots
condition|;
name|j
operator|++
control|)
operator|--
name|sc
operator|->
name|sc_bws
index|[
operator|(
name|pos
operator|*
name|nslots
operator|+
name|j
operator|)
operator|%
name|OHCI_NO_INTRS
index|]
expr_stmt|;
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|opipe
operator|->
name|tail
operator|.
name|td
argument_list|)
expr_stmt|;
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|opipe
operator|->
name|sed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_device_setintr
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ohci_pipe
modifier|*
name|opipe
parameter_list|,
name|int
name|ival
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|s
decl_stmt|,
name|best
decl_stmt|;
name|u_int
name|npoll
decl_stmt|,
name|slow
decl_stmt|,
name|shigh
decl_stmt|,
name|nslots
decl_stmt|;
name|u_int
name|bestbw
decl_stmt|,
name|bw
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|hsed
decl_stmt|,
modifier|*
name|sed
init|=
name|opipe
operator|->
name|sed
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_setintr: pipe=%p\n"
operator|,
name|opipe
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ival
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ohci_setintr: 0 interval\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
name|npoll
operator|=
name|OHCI_NO_INTRS
expr_stmt|;
while|while
condition|(
name|npoll
operator|>
name|ival
condition|)
name|npoll
operator|/=
literal|2
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_setintr: ival=%d npoll=%d\n"
operator|,
name|ival
operator|,
name|npoll
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We now know which level in the tree the ED must go into. 	 * Figure out which slot has most bandwidth left over. 	 * Slots to examine: 	 * npoll 	 * 1	0 	 * 2	1 2 	 * 4	3 4 5 6 	 * 8	7 8 9 10 11 12 13 14 	 * N    (N-1) .. (N-1+N-1) 	 */
name|slow
operator|=
name|npoll
operator|-
literal|1
expr_stmt|;
name|shigh
operator|=
name|slow
operator|+
name|npoll
expr_stmt|;
name|nslots
operator|=
name|OHCI_NO_INTRS
operator|/
name|npoll
expr_stmt|;
for|for
control|(
name|best
operator|=
name|i
operator|=
name|slow
operator|,
name|bestbw
operator|=
operator|~
literal|0
init|;
name|i
operator|<
name|shigh
condition|;
name|i
operator|++
control|)
block|{
name|bw
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nslots
condition|;
name|j
operator|++
control|)
name|bw
operator|+=
name|sc
operator|->
name|sc_bws
index|[
operator|(
name|i
operator|*
name|nslots
operator|+
name|j
operator|)
operator|%
name|OHCI_NO_INTRS
index|]
expr_stmt|;
if|if
condition|(
name|bw
operator|<
name|bestbw
condition|)
block|{
name|best
operator|=
name|i
expr_stmt|;
name|bestbw
operator|=
name|bw
expr_stmt|;
block|}
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_setintr: best=%d(%d..%d) bestbw=%d\n"
operator|,
name|best
operator|,
name|slow
operator|,
name|shigh
operator|,
name|bestbw
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|hsed
operator|=
name|sc
operator|->
name|sc_eds
index|[
name|best
index|]
expr_stmt|;
name|sed
operator|->
name|next
operator|=
name|hsed
operator|->
name|next
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_nexted
operator|=
name|hsed
operator|->
name|ed
operator|.
name|ed_nexted
expr_stmt|;
name|hsed
operator|->
name|next
operator|=
name|sed
expr_stmt|;
name|hsed
operator|->
name|ed
operator|.
name|ed_nexted
operator|=
name|htole32
argument_list|(
name|sed
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nslots
condition|;
name|j
operator|++
control|)
operator|++
name|sc
operator|->
name|sc_bws
index|[
operator|(
name|best
operator|*
name|nslots
operator|+
name|j
operator|)
operator|%
name|OHCI_NO_INTRS
index|]
expr_stmt|;
name|opipe
operator|->
name|u
operator|.
name|intr
operator|.
name|nslots
operator|=
name|nslots
expr_stmt|;
name|opipe
operator|->
name|u
operator|.
name|intr
operator|.
name|pos
operator|=
name|best
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ohci_setintr: returns %p\n"
operator|,
name|opipe
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************/
end_comment

begin_function
name|usbd_status
name|ohci_device_isoc_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ohci_device_isoc_transfer: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
comment|/* Put it on our queue, */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* bail out on error, */
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
name|USBD_IN_PROGRESS
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* XXX should check inuse here */
comment|/* insert into schedule, */
name|ohci_device_isoc_enter
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* and put on interrupt list if the pipe wasn't running */
if|if
condition|(
operator|!
name|err
condition|)
name|ohci_device_isoc_start
argument_list|(
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_device_isoc_enter
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|opipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
init|=
name|opipe
operator|->
name|sed
decl_stmt|;
name|struct
name|iso
modifier|*
name|iso
init|=
operator|&
name|opipe
operator|->
name|u
operator|.
name|iso
decl_stmt|;
name|ohci_soft_itd_t
modifier|*
name|sitd
decl_stmt|,
modifier|*
name|nsitd
decl_stmt|;
name|ohci_physaddr_t
name|buf
decl_stmt|,
name|offs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ncur
decl_stmt|,
name|nframes
decl_stmt|;
name|int
name|ncross
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sitd
operator|=
name|opipe
operator|->
name|tail
operator|.
name|itd
expr_stmt|;
name|buf
operator|=
name|DMAADDR
argument_list|(
operator|&
name|xfer
operator|->
name|dmabuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|itd
operator|.
name|itd_bp0
operator|=
name|htole32
argument_list|(
name|buf
operator|&
name|OHCI_ITD_PAGE_MASK
argument_list|)
expr_stmt|;
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
name|offs
operator|=
name|buf
operator|&
name|OHCI_ITD_OFFSET_MASK
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ncur
operator|=
literal|0
init|;
name|i
operator|<
name|nframes
condition|;
name|i
operator|++
operator|,
name|ncur
operator|++
control|)
block|{
if|if
condition|(
name|ncur
operator|==
name|OHCI_ITD_NOFFSET
operator|||
comment|/* all offsets used */
name|ncross
operator|>
literal|1
condition|)
block|{
comment|/* too many page crossings */
name|nsitd
operator|=
name|ohci_alloc_sitd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsitd
operator|==
name|NULL
condition|)
block|{
comment|/* XXX what now? */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|sitd
operator|->
name|nextitd
operator|=
name|nsitd
expr_stmt|;
name|sitd
operator|->
name|itd
operator|.
name|itd_nextitd
operator|=
name|htole32
argument_list|(
name|nsitd
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|itd
operator|.
name|itd_flags
operator|=
name|htole32
argument_list|(
name|OHCI_ITD_NOCC
operator||
name|OHCI_ITD_SET_SF
argument_list|(
name|iso
operator|->
name|next
argument_list|)
operator||
name|OHCI_ITD_NOINTR
operator||
name|OHCI_ITD_SET_FC
argument_list|(
name|OHCI_ITD_NOFFSET
argument_list|)
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|itd
operator|.
name|itd_be
operator|=
name|htole32
argument_list|(
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd
operator|.
name|itd_bp0
argument_list|)
operator|+
name|offs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|nsitd
operator|->
name|itd
operator|.
name|itd_bp0
operator|=
name|htole32
argument_list|(
operator|(
name|buf
operator|+
name|offs
operator|)
operator|&
name|OHCI_ITD_PAGE_MASK
argument_list|)
expr_stmt|;
name|sitd
operator|=
name|nsitd
expr_stmt|;
name|iso
operator|->
name|next
operator|=
name|iso
operator|->
name|next
operator|+
name|ncur
expr_stmt|;
name|ncur
operator|=
literal|0
expr_stmt|;
name|ncross
operator|=
literal|0
expr_stmt|;
block|}
comment|/* XXX byte order */
name|sitd
operator|->
name|itd
operator|.
name|itd_offset
index|[
name|i
index|]
operator|=
name|offs
operator||
operator|(
name|ncross
operator|==
literal|1
condition|?
name|OHCI_ITD_PAGE_SELECT
else|:
literal|0
operator|)
expr_stmt|;
name|offs
operator|+=
name|xfer
operator|->
name|frlengths
index|[
name|i
index|]
expr_stmt|;
comment|/* XXX update ncross */
block|}
name|nsitd
operator|=
name|ohci_alloc_sitd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsitd
operator|==
name|NULL
condition|)
block|{
comment|/* XXX what now? */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|sitd
operator|->
name|nextitd
operator|=
name|nsitd
expr_stmt|;
name|sitd
operator|->
name|itd
operator|.
name|itd_nextitd
operator|=
name|htole32
argument_list|(
name|nsitd
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|itd
operator|.
name|itd_flags
operator|=
name|le32toh
argument_list|(
name|OHCI_ITD_NOCC
operator||
name|OHCI_ITD_SET_SF
argument_list|(
name|iso
operator|->
name|next
argument_list|)
operator||
name|OHCI_ITD_SET_DI
argument_list|(
literal|0
argument_list|)
operator||
name|OHCI_ITD_SET_FC
argument_list|(
name|ncur
argument_list|)
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|itd
operator|.
name|itd_be
operator|=
name|htole32
argument_list|(
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd
operator|.
name|itd_bp0
argument_list|)
operator|+
name|offs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iso
operator|->
name|next
operator|=
name|iso
operator|->
name|next
operator|+
name|ncur
expr_stmt|;
name|opipe
operator|->
name|tail
operator|.
name|itd
operator|=
name|nsitd
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
operator|=
name|htole32
argument_list|(
name|nsitd
operator|->
name|physaddr
argument_list|)
expr_stmt|;
comment|/* XXX update ED */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|ohci_device_isoc_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|printf
argument_list|(
literal|"ohci_device_isoc_start: not implemented\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_device_isoc_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ohci_device_isoc_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|printf
argument_list|(
literal|"ohci_device_isoc_done: not implemented\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|ohci_setup_isoc
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|struct
name|iso
modifier|*
name|iso
init|=
operator|&
name|opipe
operator|->
name|u
operator|.
name|iso
decl_stmt|;
name|iso
operator|->
name|next
operator|=
operator|-
literal|1
expr_stmt|;
name|iso
operator|->
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_device_isoc_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_isoc_close: pipe=%p\n"
operator|,
name|pipe
operator|)
argument_list|)
expr_stmt|;
name|ohci_close_pipe
argument_list|(
name|pipe
argument_list|,
name|sc
operator|->
name|sc_isoc_head
argument_list|)
expr_stmt|;
name|ohci_free_sitd
argument_list|(
name|sc
argument_list|,
name|opipe
operator|->
name|tail
operator|.
name|itd
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

