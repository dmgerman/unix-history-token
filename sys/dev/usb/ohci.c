begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: ohci.c,v 1.138 2003/02/08 03:32:50 ichiro Exp $	*/
end_comment

begin_comment
comment|/* Also, already ported:  *	$NetBSD: ohci.c,v 1.140 2003/05/13 04:42:00 gson Exp $  *	$NetBSD: ohci.c,v 1.141 2003/09/10 20:08:29 mycroft Exp $  *	$NetBSD: ohci.c,v 1.142 2003/10/11 03:04:26 toshii Exp $  *	$NetBSD: ohci.c,v 1.143 2003/10/18 04:50:35 simonb Exp $  *	$NetBSD: ohci.c,v 1.144 2003/11/23 19:18:06 augustss Exp $  *	$NetBSD: ohci.c,v 1.145 2003/11/23 19:20:25 augustss Exp $  *	$NetBSD: ohci.c,v 1.146 2003/12/29 08:17:10 toshii Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (lennart@augustsson.net) at  * Carlstedt Research& Technology.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * USB Open Host Controller driver.  *  * OHCI spec: http://www.compaq.com/productinfo/development/openhci.html  * USB spec: http://www.usb.org/developers/docs/usbspec.zip  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/endian.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_mem.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_quirks.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/ohcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/ohcivar.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_define
define|#
directive|define
name|delay
parameter_list|(
name|d
parameter_list|)
value|DELAY(d)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_decl_stmt
name|struct
name|cfdriver
name|ohci_cd
init|=
block|{
name|NULL
block|,
literal|"ohci"
block|,
name|DV_DULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (ohcidebug) logprintf x
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (ohcidebug>(n)) logprintf x
end_define

begin_decl_stmt
name|int
name|ohcidebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|ohci
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB ohci"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_ohci
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ohcidebug
argument_list|,
literal|0
argument_list|,
literal|"ohci debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__NetBSD__
end_ifndef

begin_define
define|#
directive|define
name|bitmask_snprintf
parameter_list|(
name|q
parameter_list|,
name|f
parameter_list|,
name|b
parameter_list|,
name|l
parameter_list|)
value|snprintf((b), (l), "%b", (q), (f))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The OHCI controller is little endian, so on big endian machines  * the data strored in memory needs to be swapped.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
end_if

begin_define
define|#
directive|define
name|htole32
parameter_list|(
name|x
parameter_list|)
value|(bswap32(x))
end_define

begin_define
define|#
directive|define
name|le32toh
parameter_list|(
name|x
parameter_list|)
value|(bswap32(x))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|htole32
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_define
define|#
directive|define
name|le32toh
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_struct_decl
struct_decl|struct
name|ohci_pipe
struct_decl|;
end_struct_decl

begin_function_decl
name|Static
name|ohci_soft_ed_t
modifier|*
name|ohci_alloc_sed
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_free_sed
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_soft_ed_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|ohci_soft_td_t
modifier|*
name|ohci_alloc_std
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_free_std
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_soft_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|ohci_soft_itd_t
modifier|*
name|ohci_alloc_sitd
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_free_sitd
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_soft_itd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|Static void		ohci_free_std_chain(ohci_softc_t *, ohci_soft_td_t *, 					    ohci_soft_td_t *);
endif|#
directive|endif
end_endif

begin_function_decl
name|Static
name|usbd_status
name|ohci_alloc_std_chain
parameter_list|(
name|struct
name|ohci_pipe
modifier|*
parameter_list|,
name|ohci_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|usbd_xfer_handle
parameter_list|,
name|ohci_soft_td_t
modifier|*
parameter_list|,
name|ohci_soft_td_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function_decl
name|Static
name|void
name|ohci_shutdown
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_power
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|Static
name|usbd_status
name|ohci_open
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_poll
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_softintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_waitintr
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_add_done
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_physaddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_rhsc
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_request
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_add_ed
parameter_list|(
name|ohci_soft_ed_t
modifier|*
parameter_list|,
name|ohci_soft_ed_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_rem_ed
parameter_list|(
name|ohci_soft_ed_t
modifier|*
parameter_list|,
name|ohci_soft_ed_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_hash_add_td
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_soft_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_hash_rem_td
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_soft_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|ohci_soft_td_t
modifier|*
name|ohci_hash_find_td
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_physaddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_hash_add_itd
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_soft_itd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_hash_rem_itd
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_soft_itd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|ohci_soft_itd_t
modifier|*
name|ohci_hash_find_itd
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|ohci_physaddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_setup_isoc
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_isoc_enter
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_allocm
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|,
name|usb_dma_t
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_freem
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|,
name|usb_dma_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_xfer_handle
name|ohci_allocx
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_freex
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|,
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_root_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_root_ctrl_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_root_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_root_ctrl_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_root_ctrl_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_root_intr_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_root_intr_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_root_intr_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_root_intr_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_root_intr_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_ctrl_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_ctrl_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_ctrl_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_bulk_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_bulk_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_bulk_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_bulk_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_bulk_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_intr_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_intr_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_intr_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_intr_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_intr_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_isoc_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_isoc_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_isoc_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_isoc_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_isoc_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_device_setintr
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ohci_pipe
modifier|*
name|pipe
parameter_list|,
name|int
name|ival
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|ohci_str
parameter_list|(
name|usb_string_descriptor_t
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_timeout_task
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_rhsc_able
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_rhsc_enable
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_close_pipe
parameter_list|(
name|usbd_pipe_handle
parameter_list|,
name|ohci_soft_ed_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_abort_xfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|,
name|usbd_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_device_clear_toggle
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_noop
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|ohci_controller_init
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function_decl
name|Static
name|void
name|ohci_dumpregs
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_dump_tds
parameter_list|(
name|ohci_soft_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_dump_td
parameter_list|(
name|ohci_soft_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_dump_ed
parameter_list|(
name|ohci_soft_ed_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_dump_itd
parameter_list|(
name|ohci_soft_itd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|ohci_dump_itds
parameter_list|(
name|ohci_soft_itd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OBARR
parameter_list|(
name|sc
parameter_list|)
value|bus_space_barrier((sc)->iot, (sc)->ioh, 0, (sc)->sc_size, \ 			BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE)
end_define

begin_define
define|#
directive|define
name|OWRITE1
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
define|\
value|do { OBARR(sc); bus_space_write_1((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
end_define

begin_define
define|#
directive|define
name|OWRITE2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
define|\
value|do { OBARR(sc); bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
end_define

begin_define
define|#
directive|define
name|OWRITE4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
define|\
value|do { OBARR(sc); bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
end_define

begin_define
define|#
directive|define
name|OREAD1
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|(OBARR(sc), bus_space_read_1((sc)->iot, (sc)->ioh, (r)))
end_define

begin_define
define|#
directive|define
name|OREAD2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|(OBARR(sc), bus_space_read_2((sc)->iot, (sc)->ioh, (r)))
end_define

begin_define
define|#
directive|define
name|OREAD4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|(OBARR(sc), bus_space_read_4((sc)->iot, (sc)->ioh, (r)))
end_define

begin_comment
comment|/* Reverse the bits in a value 0 .. 31 */
end_comment

begin_decl_stmt
name|Static
name|u_int8_t
name|revbits
index|[
name|OHCI_NO_INTRS
index|]
init|=
block|{
literal|0x00
block|,
literal|0x10
block|,
literal|0x08
block|,
literal|0x18
block|,
literal|0x04
block|,
literal|0x14
block|,
literal|0x0c
block|,
literal|0x1c
block|,
literal|0x02
block|,
literal|0x12
block|,
literal|0x0a
block|,
literal|0x1a
block|,
literal|0x06
block|,
literal|0x16
block|,
literal|0x0e
block|,
literal|0x1e
block|,
literal|0x01
block|,
literal|0x11
block|,
literal|0x09
block|,
literal|0x19
block|,
literal|0x05
block|,
literal|0x15
block|,
literal|0x0d
block|,
literal|0x1d
block|,
literal|0x03
block|,
literal|0x13
block|,
literal|0x0b
block|,
literal|0x1b
block|,
literal|0x07
block|,
literal|0x17
block|,
literal|0x0f
block|,
literal|0x1f
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ohci_pipe
block|{
name|struct
name|usbd_pipe
name|pipe
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
name|u_int32_t
name|aborting
decl_stmt|;
union|union
block|{
name|ohci_soft_td_t
modifier|*
name|td
decl_stmt|;
name|ohci_soft_itd_t
modifier|*
name|itd
decl_stmt|;
block|}
name|tail
union|;
comment|/* Info needed for different pipe kinds. */
union|union
block|{
comment|/* Control pipe */
struct|struct
block|{
name|usb_dma_t
name|reqdma
decl_stmt|;
name|u_int
name|length
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|setup
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|stat
decl_stmt|;
block|}
name|ctl
struct|;
comment|/* Interrupt pipe */
struct|struct
block|{
name|int
name|nslots
decl_stmt|;
name|int
name|pos
decl_stmt|;
block|}
name|intr
struct|;
comment|/* Bulk pipe */
struct|struct
block|{
name|u_int
name|length
decl_stmt|;
name|int
name|isread
decl_stmt|;
block|}
name|bulk
struct|;
comment|/* Iso pipe */
struct|struct
name|iso
block|{
name|int
name|next
decl_stmt|,
name|inuse
decl_stmt|;
block|}
name|iso
struct|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|OHCI_INTR_ENDPT
value|1
end_define

begin_decl_stmt
name|Static
name|struct
name|usbd_bus_methods
name|ohci_bus_methods
init|=
block|{
name|ohci_open
block|,
name|ohci_softintr
block|,
name|ohci_poll
block|,
name|ohci_allocm
block|,
name|ohci_freem
block|,
name|ohci_allocx
block|,
name|ohci_freex
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|usbd_pipe_methods
name|ohci_root_ctrl_methods
init|=
block|{
name|ohci_root_ctrl_transfer
block|,
name|ohci_root_ctrl_start
block|,
name|ohci_root_ctrl_abort
block|,
name|ohci_root_ctrl_close
block|,
name|ohci_noop
block|,
name|ohci_root_ctrl_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|usbd_pipe_methods
name|ohci_root_intr_methods
init|=
block|{
name|ohci_root_intr_transfer
block|,
name|ohci_root_intr_start
block|,
name|ohci_root_intr_abort
block|,
name|ohci_root_intr_close
block|,
name|ohci_noop
block|,
name|ohci_root_intr_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|usbd_pipe_methods
name|ohci_device_ctrl_methods
init|=
block|{
name|ohci_device_ctrl_transfer
block|,
name|ohci_device_ctrl_start
block|,
name|ohci_device_ctrl_abort
block|,
name|ohci_device_ctrl_close
block|,
name|ohci_noop
block|,
name|ohci_device_ctrl_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|usbd_pipe_methods
name|ohci_device_intr_methods
init|=
block|{
name|ohci_device_intr_transfer
block|,
name|ohci_device_intr_start
block|,
name|ohci_device_intr_abort
block|,
name|ohci_device_intr_close
block|,
name|ohci_device_clear_toggle
block|,
name|ohci_device_intr_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|usbd_pipe_methods
name|ohci_device_bulk_methods
init|=
block|{
name|ohci_device_bulk_transfer
block|,
name|ohci_device_bulk_start
block|,
name|ohci_device_bulk_abort
block|,
name|ohci_device_bulk_close
block|,
name|ohci_device_clear_toggle
block|,
name|ohci_device_bulk_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|usbd_pipe_methods
name|ohci_device_isoc_methods
init|=
block|{
name|ohci_device_isoc_transfer
block|,
name|ohci_device_isoc_start
block|,
name|ohci_device_isoc_abort
block|,
name|ohci_device_isoc_close
block|,
name|ohci_noop
block|,
name|ohci_device_isoc_done
block|, }
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|int
name|ohci_activate
parameter_list|(
name|device_ptr_t
name|self
parameter_list|,
name|enum
name|devact
name|act
parameter_list|)
block|{
name|struct
name|ohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ohci_softc
operator|*
operator|)
name|self
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|act
condition|)
block|{
case|case
name|DVACT_ACTIVATE
case|:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
case|case
name|DVACT_DEACTIVATE
case|:
if|if
condition|(
name|sc
operator|->
name|sc_child
operator|!=
name|NULL
condition|)
name|rv
operator|=
name|config_deactivate
argument_list|(
name|sc
operator|->
name|sc_child
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ohci_detach
parameter_list|(
name|struct
name|ohci_softc
modifier|*
name|sc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|rv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_child
operator|!=
name|NULL
condition|)
name|rv
operator|=
name|config_detach
argument_list|(
name|sc
operator|->
name|sc_child
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|usb_uncallout
argument_list|(
name|sc
operator|->
name|sc_tmo_rhsc
argument_list|,
name|ohci_rhsc_enable
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|powerhook_disestablish
argument_list|(
name|sc
operator|->
name|sc_powerhook
argument_list|)
expr_stmt|;
name|shutdownhook_disestablish
argument_list|(
name|sc
operator|->
name|sc_shutdownhook
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|300
argument_list|)
expr_stmt|;
comment|/* XXX let stray task complete */
comment|/* free data structures XXX */
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|ohci_soft_ed_t
modifier|*
name|ohci_alloc_sed
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offs
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_freeeds
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_alloc_sed: allocating chunk\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|OHCI_SED_SIZE
operator|*
name|OHCI_SED_CHUNK
argument_list|,
name|OHCI_ED_ALIGN
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_SED_CHUNK
condition|;
name|i
operator|++
control|)
block|{
name|offs
operator|=
name|i
operator|*
name|OHCI_SED_SIZE
expr_stmt|;
name|sed
operator|=
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|sed
operator|->
name|physaddr
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|sed
operator|->
name|next
operator|=
name|sc
operator|->
name|sc_freeeds
expr_stmt|;
name|sc
operator|->
name|sc_freeeds
operator|=
name|sed
expr_stmt|;
block|}
block|}
name|sed
operator|=
name|sc
operator|->
name|sc_freeeds
expr_stmt|;
name|sc
operator|->
name|sc_freeeds
operator|=
name|sed
operator|->
name|next
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sed
operator|->
name|ed
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ohci_ed_t
argument_list|)
argument_list|)
expr_stmt|;
name|sed
operator|->
name|next
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sed
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_free_sed
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_soft_ed_t
modifier|*
name|sed
parameter_list|)
block|{
name|sed
operator|->
name|next
operator|=
name|sc
operator|->
name|sc_freeeds
expr_stmt|;
name|sc
operator|->
name|sc_freeeds
operator|=
name|sed
expr_stmt|;
block|}
end_function

begin_function
name|ohci_soft_td_t
modifier|*
name|ohci_alloc_std
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|ohci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offs
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_freetds
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_alloc_std: allocating chunk\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|OHCI_STD_SIZE
operator|*
name|OHCI_STD_CHUNK
argument_list|,
name|OHCI_TD_ALIGN
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_STD_CHUNK
condition|;
name|i
operator|++
control|)
block|{
name|offs
operator|=
name|i
operator|*
name|OHCI_STD_SIZE
expr_stmt|;
name|std
operator|=
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|std
operator|->
name|physaddr
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|std
operator|->
name|nexttd
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|std
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
operator|->
name|nexttd
expr_stmt|;
name|memset
argument_list|(
operator|&
name|std
operator|->
name|td
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ohci_td_t
argument_list|)
argument_list|)
expr_stmt|;
name|std
operator|->
name|nexttd
operator|=
name|NULL
expr_stmt|;
name|std
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|ohci_hash_add_td
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|std
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_free_std
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_soft_td_t
modifier|*
name|std
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ohci_hash_rem_td
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
name|std
operator|->
name|nexttd
operator|=
name|sc
operator|->
name|sc_freetds
expr_stmt|;
name|sc
operator|->
name|sc_freetds
operator|=
name|std
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|ohci_alloc_std_chain
parameter_list|(
name|struct
name|ohci_pipe
modifier|*
name|opipe
parameter_list|,
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|alen
parameter_list|,
name|int
name|rd
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|ohci_soft_td_t
modifier|*
name|sp
parameter_list|,
name|ohci_soft_td_t
modifier|*
modifier|*
name|ep
parameter_list|)
block|{
name|ohci_soft_td_t
modifier|*
name|next
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|ohci_physaddr_t
name|dataphys
decl_stmt|;
name|u_int32_t
name|tdflags
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|,
name|curlen
decl_stmt|;
name|usb_dma_t
modifier|*
name|dma
init|=
operator|&
name|xfer
operator|->
name|dmabuf
decl_stmt|;
name|u_int16_t
name|flags
init|=
name|xfer
operator|->
name|flags
decl_stmt|;
name|DPRINTFN
argument_list|(
name|alen
operator|<
literal|4096
argument_list|,
operator|(
literal|"ohci_alloc_std_chain: start len=%d\n"
operator|,
name|alen
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|alen
expr_stmt|;
name|cur
operator|=
name|sp
expr_stmt|;
name|tdflags
operator|=
name|htole32
argument_list|(
operator|(
name|rd
condition|?
name|OHCI_TD_IN
else|:
name|OHCI_TD_OUT
operator|)
operator||
operator|(
name|flags
operator|&
name|USBD_SHORT_XFER_OK
condition|?
name|OHCI_TD_R
else|:
literal|0
operator|)
operator||
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_TOGGLE_CARRY
operator||
name|OHCI_TD_NOINTR
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|next
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
name|dataphys
operator|=
name|DMAADDR
argument_list|(
name|dma
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* 		 * The OHCI hardware can handle at most one 4k crossing. 		 * XXX - currently we only allocate contigous buffers, but 		 * the OHCI spec says: If during the data transfer the buffer 		 * address contained in the HC's working copy of 		 * CurrentBufferPointer crosses a 4K boundary, the upper 20 		 * bits of Buffer End are copied to the working value of 		 * CurrentBufferPointer causing the next buffer address to 		 * be the 0th byte in the same 4K page that contains the 		 * last byte of the buffer (the 4K boundary crossing may 		 * occur within a data packet transfer.) 		 * 		 * If/when dma has multiple segments, this will need to 		 * properly handle fragmenting TD's. 		 * 		 * We can describe the above using maxsegsz = 4k and nsegs = 2 		 * in the future. 		 */
if|if
condition|(
name|OHCI_PAGE
argument_list|(
name|dataphys
argument_list|)
operator|==
name|OHCI_PAGE
argument_list|(
name|DMAADDR
argument_list|(
name|dma
argument_list|,
name|offset
operator|+
name|len
operator|-
literal|1
argument_list|)
argument_list|)
operator|||
name|len
operator|-
operator|(
name|OHCI_PAGE_SIZE
operator|-
name|OHCI_PAGE_OFFSET
argument_list|(
name|dataphys
argument_list|)
operator|)
operator|<=
name|OHCI_PAGE_SIZE
condition|)
block|{
comment|/* we can handle it in this TD */
name|curlen
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX The calculation below is wrong and could 			 * result in a packet that is not a multiple of the 			 * MaxPacketSize in the case where the buffer does not 			 * start on an appropriate address (like for example in 			 * the case of an mbuf cluster). You'll get an early 			 * short packet. 			 */
comment|/* must use multiple TDs, fill as much as possible. */
name|curlen
operator|=
literal|2
operator|*
name|OHCI_PAGE_SIZE
operator|-
name|OHCI_PAGE_OFFSET
argument_list|(
name|dataphys
argument_list|)
expr_stmt|;
comment|/* the length must be a multiple of the max size */
name|curlen
operator|-=
name|curlen
operator|%
name|UGETW
argument_list|(
name|opipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|curlen
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ohci_alloc_std: curlen == 0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ohci_alloc_std_chain: dataphys=0x%08x "
literal|"len=%d curlen=%d\n"
operator|,
name|dataphys
operator|,
name|len
operator|,
name|curlen
operator|)
argument_list|)
expr_stmt|;
name|len
operator|-=
name|curlen
expr_stmt|;
name|cur
operator|->
name|td
operator|.
name|td_flags
operator|=
name|tdflags
expr_stmt|;
name|cur
operator|->
name|td
operator|.
name|td_cbp
operator|=
name|htole32
argument_list|(
name|dataphys
argument_list|)
expr_stmt|;
name|cur
operator|->
name|nexttd
operator|=
name|next
expr_stmt|;
name|cur
operator|->
name|td
operator|.
name|td_nexttd
operator|=
name|htole32
argument_list|(
name|next
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|cur
operator|->
name|td
operator|.
name|td_be
operator|=
name|htole32
argument_list|(
name|DMAADDR
argument_list|(
name|dma
argument_list|,
name|offset
operator|+
name|curlen
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|->
name|len
operator|=
name|curlen
expr_stmt|;
name|cur
operator|->
name|flags
operator|=
name|OHCI_ADD_LEN
expr_stmt|;
name|cur
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\n"
operator|,
name|dataphys
operator|,
name|dataphys
operator|+
name|curlen
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"Length went negative: %d curlen %d dma %p offset %08x"
argument_list|,
name|len
argument_list|,
name|curlen
argument_list|,
name|dma
argument_list|,
operator|(
name|int
operator|)
literal|0
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_alloc_std_chain: extend chain\n"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|curlen
expr_stmt|;
name|cur
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|USBD_FORCE_SHORT_XFER
operator|)
operator|&&
name|alen
operator|%
name|UGETW
argument_list|(
name|opipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Force a 0 length transfer at the end. */
name|cur
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
name|cur
operator|->
name|td
operator|.
name|td_flags
operator|=
name|tdflags
expr_stmt|;
name|cur
operator|->
name|td
operator|.
name|td_cbp
operator|=
literal|0
expr_stmt|;
comment|/* indicate 0 length packet */
name|cur
operator|->
name|nexttd
operator|=
name|next
expr_stmt|;
name|cur
operator|->
name|td
operator|.
name|td_nexttd
operator|=
name|htole32
argument_list|(
name|next
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|cur
operator|->
name|td
operator|.
name|td_be
operator|=
operator|~
literal|0
expr_stmt|;
name|cur
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|cur
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cur
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_alloc_std_chain: add 0 xfer\n"
operator|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|ep
operator|=
name|cur
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|nomem
label|:
comment|/* XXX free chain */
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|Static void ohci_free_std_chain(ohci_softc_t *sc, ohci_soft_td_t *std, 		    ohci_soft_td_t *stdend) { 	ohci_soft_td_t *p;  	for (; std != stdend; std = p) { 		p = std->nexttd; 		ohci_free_std(sc, std); 	} }
endif|#
directive|endif
end_endif

begin_function
name|ohci_soft_itd_t
modifier|*
name|ohci_alloc_sitd
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|ohci_soft_itd_t
modifier|*
name|sitd
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|offs
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_freeitds
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_alloc_sitd: allocating chunk\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|OHCI_SITD_SIZE
operator|*
name|OHCI_SITD_CHUNK
argument_list|,
name|OHCI_ITD_ALIGN
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_SITD_CHUNK
condition|;
name|i
operator|++
control|)
block|{
name|offs
operator|=
name|i
operator|*
name|OHCI_SITD_SIZE
expr_stmt|;
name|sitd
operator|=
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|physaddr
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|nextitd
operator|=
name|sc
operator|->
name|sc_freeitds
expr_stmt|;
name|sc
operator|->
name|sc_freeitds
operator|=
name|sitd
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sitd
operator|=
name|sc
operator|->
name|sc_freeitds
expr_stmt|;
name|sc
operator|->
name|sc_freeitds
operator|=
name|sitd
operator|->
name|nextitd
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sitd
operator|->
name|itd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ohci_itd_t
argument_list|)
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|nextitd
operator|=
name|NULL
expr_stmt|;
name|sitd
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|ohci_hash_add_itd
argument_list|(
name|sc
argument_list|,
name|sitd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|sitd
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|sitd
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_free_sitd
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_soft_itd_t
modifier|*
name|sitd
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_free_sitd: sitd=%p\n"
operator|,
name|sitd
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|sitd
operator|->
name|isdone
condition|)
block|{
name|panic
argument_list|(
literal|"ohci_free_sitd: sitd=%p not done"
argument_list|,
name|sitd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Warn double free */
name|sitd
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ohci_hash_rem_itd
argument_list|(
name|sc
argument_list|,
name|sitd
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|nextitd
operator|=
name|sc
operator|->
name|sc_freeitds
expr_stmt|;
name|sc
operator|->
name|sc_freeitds
operator|=
name|sitd
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|ohci_init
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|,
modifier|*
name|psed
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int32_t
name|rev
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_init: start\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rev
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_REVISION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" OHCI version %d.%d%s\n"
argument_list|,
name|OHCI_REV_HI
argument_list|(
name|rev
argument_list|)
argument_list|,
name|OHCI_REV_LO
argument_list|(
name|rev
argument_list|)
argument_list|,
name|OHCI_REV_LEGACY
argument_list|(
name|rev
argument_list|)
condition|?
literal|", legacy support"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|OHCI_REV_HI
argument_list|(
name|rev
argument_list|)
operator|!=
literal|1
operator|||
name|OHCI_REV_LO
argument_list|(
name|rev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unsupported OHCI revision\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|usbrev
operator|=
name|USBREV_UNKNOWN
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
name|sc
operator|->
name|sc_bus
operator|.
name|usbrev
operator|=
name|USBREV_1_0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_HASH_SIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_hash_tds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_HASH_SIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_hash_itds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SIMPLEQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|)
expr_stmt|;
comment|/* XXX determine alignment by R/W */
comment|/* Allocate the HCCA area. */
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|OHCI_HCCA_SIZE
argument_list|,
name|OHCI_HCCA_ALIGN
argument_list|,
operator|&
name|sc
operator|->
name|sc_hccadma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|sc
operator|->
name|sc_hcca
operator|=
name|KERNADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_hccadma
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_hcca
argument_list|,
literal|0
argument_list|,
name|OHCI_HCCA_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_eintrs
operator|=
name|OHCI_NORMAL_INTRS
expr_stmt|;
comment|/* Allocate dummy ED that starts the control list. */
name|sc
operator|->
name|sc_ctrl_head
operator|=
name|ohci_alloc_sed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ctrl_head
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
name|sc
operator|->
name|sc_ctrl_head
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* Allocate dummy ED that starts the bulk list. */
name|sc
operator|->
name|sc_bulk_head
operator|=
name|ohci_alloc_sed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bulk_head
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|sc
operator|->
name|sc_bulk_head
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* Allocate dummy ED that starts the isochronous list. */
name|sc
operator|->
name|sc_isoc_head
operator|=
name|ohci_alloc_sed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_isoc_head
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad3
goto|;
block|}
name|sc
operator|->
name|sc_isoc_head
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* Allocate all the dummy EDs that make up the interrupt tree. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_NO_EDS
condition|;
name|i
operator|++
control|)
block|{
name|sed
operator|=
name|ohci_alloc_sed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sed
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_eds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad4
goto|;
block|}
comment|/* All ED fields are set to 0. */
name|sc
operator|->
name|sc_eds
index|[
name|i
index|]
operator|=
name|sed
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|psed
operator|=
name|sc
operator|->
name|sc_eds
index|[
operator|(
name|i
operator|-
literal|1
operator|)
operator|/
literal|2
index|]
expr_stmt|;
else|else
name|psed
operator|=
name|sc
operator|->
name|sc_isoc_head
expr_stmt|;
name|sed
operator|->
name|next
operator|=
name|psed
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_nexted
operator|=
name|htole32
argument_list|(
name|psed
operator|->
name|physaddr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill HCCA interrupt table.  The bit reversal is to get 	 * the tree set up properly to spread the interrupts. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_NO_INTRS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_hcca
operator|->
name|hcca_interrupt_table
index|[
name|revbits
index|[
name|i
index|]
index|]
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_eds
index|[
name|OHCI_NO_EDS
operator|-
name|OHCI_NO_INTRS
operator|+
name|i
index|]
operator|->
name|physaddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|15
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_NO_EDS
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"ed#%d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sc
operator|->
name|sc_eds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"iso "
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sc
operator|->
name|sc_isoc_head
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|err
operator|=
name|ohci_controller_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
goto|goto
name|bad5
goto|;
comment|/* Set up the bus struct. */
name|sc
operator|->
name|sc_bus
operator|.
name|methods
operator|=
operator|&
name|ohci_bus_methods
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|pipe_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ohci_pipe
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|sc
operator|->
name|sc_control
operator|=
name|sc
operator|->
name|sc_intre
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_powerhook
operator|=
name|powerhook_establish
argument_list|(
name|ohci_power
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_shutdownhook
operator|=
name|shutdownhook_establish
argument_list|(
name|ohci_shutdown
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usb_callout_init
argument_list|(
name|sc
operator|->
name|sc_tmo_rhsc
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad5
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_NO_EDS
condition|;
name|i
operator|++
control|)
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_eds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bad4
label|:
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_isoc_head
argument_list|)
expr_stmt|;
name|bad3
label|:
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_bulk_head
argument_list|)
expr_stmt|;
name|bad2
label|:
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ctrl_head
argument_list|)
expr_stmt|;
name|bad1
label|:
name|usb_freemem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hccadma
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_controller_init
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|s
decl_stmt|,
name|ctl
decl_stmt|,
name|ival
decl_stmt|,
name|hcr
decl_stmt|,
name|fm
decl_stmt|,
name|per
decl_stmt|,
name|desca
decl_stmt|;
comment|/* Determine in what context we are running. */
name|ctl
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&
name|OHCI_IR
condition|)
block|{
comment|/* SMM active, request change */
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_init: SMM active, request owner change\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|s
operator||
name|OHCI_OCR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
operator|&&
operator|(
name|ctl
operator|&
name|OHCI_IR
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ctl
operator|&
name|OHCI_IR
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SMM does not respond, resetting\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_RESET
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
if|#
directive|if
literal|0
comment|/* Don't bother trying to reuse the BIOS init, we'll reset it anyway. */
block|} else if ((ctl& OHCI_HCFS_MASK) != OHCI_HCFS_RESET) {
comment|/* BIOS started controller. */
block|DPRINTF(("ohci_init: BIOS active\n")); 		if ((ctl& OHCI_HCFS_MASK) != OHCI_HCFS_OPERATIONAL) { 			OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_OPERATIONAL); 			usb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY); 		}
endif|#
directive|endif
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_init: cold started\n"
operator|)
argument_list|)
expr_stmt|;
name|reset
label|:
comment|/* Controller was cold started. */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_BUS_RESET_DELAY
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This reset should not be necessary according to the OHCI spec, but 	 * without it some controllers do not start. 	 */
name|DPRINTF
argument_list|(
operator|(
literal|"%s: resetting\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_RESET
argument_list|)
expr_stmt|;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_BUS_RESET_DELAY
argument_list|)
expr_stmt|;
comment|/* We now own the host controller and the bus has been reset. */
name|ival
operator|=
name|OHCI_GET_IVAL
argument_list|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_INTERVAL
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_HCR
argument_list|)
expr_stmt|;
comment|/* Reset HC */
comment|/* Nominal time for a reset is 10 us. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|hcr
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|)
operator|&
name|OHCI_HCR
expr_stmt|;
if|if
condition|(
operator|!
name|hcr
condition|)
break|break;
block|}
if|if
condition|(
name|hcr
condition|)
block|{
name|printf
argument_list|(
literal|"%s: reset timeout\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|15
condition|)
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The controller is now in SUSPEND state, we have 2ms to finish. */
comment|/* Set up HC registers. */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCA
argument_list|,
name|DMAADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_hccadma
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL_HEAD_ED
argument_list|,
name|sc
operator|->
name|sc_ctrl_head
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_BULK_HEAD_ED
argument_list|,
name|sc
operator|->
name|sc_bulk_head
operator|->
name|physaddr
argument_list|)
expr_stmt|;
comment|/* disable all interrupts and then switch on all desired interrupts */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|,
name|OHCI_ALL_INTRS
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_ENABLE
argument_list|,
name|sc
operator|->
name|sc_eintrs
operator||
name|OHCI_MIE
argument_list|)
expr_stmt|;
comment|/* switch on desired functional features */
name|ctl
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
operator|(
name|OHCI_CBSR_MASK
operator||
name|OHCI_LES
operator||
name|OHCI_HCFS_MASK
operator||
name|OHCI_IR
operator|)
expr_stmt|;
name|ctl
operator||=
name|OHCI_PLE
operator||
name|OHCI_IE
operator||
name|OHCI_CLE
operator||
name|OHCI_BLE
operator||
name|OHCI_RATIO_1_4
operator||
name|OHCI_HCFS_OPERATIONAL
expr_stmt|;
comment|/* And finally start it! */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
comment|/* 	 * The controller is now OPERATIONAL.  Set a some final 	 * registers that should be set earlier, but that the 	 * controller ignores when in the SUSPEND state. 	 */
name|fm
operator|=
operator|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_INTERVAL
argument_list|)
operator|&
name|OHCI_FIT
operator|)
operator|^
name|OHCI_FIT
expr_stmt|;
name|fm
operator||=
name|OHCI_FSMPS
argument_list|(
name|ival
argument_list|)
operator||
name|ival
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_INTERVAL
argument_list|,
name|fm
argument_list|)
expr_stmt|;
name|per
operator|=
name|OHCI_PERIODIC
argument_list|(
name|ival
argument_list|)
expr_stmt|;
comment|/* 90% periodic */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_PERIODIC_START
argument_list|,
name|per
argument_list|)
expr_stmt|;
comment|/* Fiddle the No OverCurrent Protection bit to avoid chip bug. */
name|desca
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|,
name|desca
operator||
name|OHCI_NOCP
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_STATUS
argument_list|,
name|OHCI_LPSC
argument_list|)
expr_stmt|;
comment|/* Enable port power */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|OHCI_ENABLE_POWER_DELAY
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|,
name|desca
argument_list|)
expr_stmt|;
comment|/* 	 * The AMD756 requires a delay before re-reading the register, 	 * otherwise it will occasionally report 0 ports. 	 */
name|sc
operator|->
name|sc_noport
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
operator|&&
name|sc
operator|->
name|sc_noport
operator|==
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|OHCI_READ_DESC_DELAY
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_noport
operator|=
name|OHCI_GET_NDP
argument_list|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|5
condition|)
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|ohci_allocm
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|,
name|usb_dma_t
modifier|*
name|dma
parameter_list|,
name|u_int32_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|usb_allocmem
argument_list|(
name|bus
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|dma
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_freem
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|,
name|usb_dma_t
modifier|*
name|dma
parameter_list|)
block|{
name|usb_freemem
argument_list|(
name|bus
argument_list|,
name|dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_xfer_handle
name|ohci_allocx
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|ohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ohci_softc
operator|*
operator|)
name|bus
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|xfer
operator|=
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|!=
name|NULL
condition|)
block|{
name|SIMPLEQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|,
name|next
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|busy_free
operator|!=
name|XFER_FREE
condition|)
block|{
name|printf
argument_list|(
literal|"ohci_allocx: xfer=%p not free, 0x%08x\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|busy_free
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|xfer
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ohci_xfer
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xfer
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ohci_xfer
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|xfer
operator|->
name|busy_free
operator|=
name|XFER_BUSY
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|xfer
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_freex
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ohci_softc
operator|*
operator|)
name|bus
decl_stmt|;
name|struct
name|ohci_xfer
modifier|*
name|oxfer
init|=
operator|(
expr|struct
name|ohci_xfer
operator|*
operator|)
name|xfer
decl_stmt|;
name|ohci_soft_itd_t
modifier|*
name|sitd
decl_stmt|;
if|if
condition|(
name|oxfer
operator|->
name|ohci_xfer_flags
operator|&
name|OHCI_ISOC_DIRTY
condition|)
block|{
for|for
control|(
name|sitd
operator|=
name|xfer
operator|->
name|hcpriv
init|;
name|sitd
operator|!=
name|NULL
operator|&&
name|sitd
operator|->
name|xfer
operator|==
name|xfer
condition|;
name|sitd
operator|=
name|sitd
operator|->
name|nextitd
control|)
name|ohci_free_sitd
argument_list|(
name|sc
argument_list|,
name|sitd
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|busy_free
operator|!=
name|XFER_BUSY
condition|)
block|{
name|printf
argument_list|(
literal|"ohci_freex: xfer=%p not busy, 0x%08x\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|busy_free
argument_list|)
expr_stmt|;
return|return;
block|}
name|xfer
operator|->
name|busy_free
operator|=
name|XFER_FREE
expr_stmt|;
endif|#
directive|endif
name|SIMPLEQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|,
name|xfer
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shut down the controller when the system is going down.  */
end_comment

begin_function
name|void
name|ohci_shutdown
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_shutdown: stopping the HC\n"
operator|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle suspend/resume.  *  * We need to switch to polling mode here, because this routine is  * called from an intterupt context.  This is all right since we  * are almost suspended anyway.  */
end_comment

begin_function
name|void
name|ohci_power
parameter_list|(
name|int
name|why
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|u_int32_t
name|ctl
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_power: sc=%p, why=%d\n"
operator|,
name|sc
operator|,
name|why
operator|)
argument_list|)
expr_stmt|;
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splhardusb
argument_list|()
expr_stmt|;
if|if
condition|(
name|why
operator|!=
name|PWR_RESUME
condition|)
block|{
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
operator|++
expr_stmt|;
name|ctl
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
operator|&
operator|~
name|OHCI_HCFS_MASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_control
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Preserve register values, in case that APM BIOS 			 * does not recover them. 			 */
name|sc
operator|->
name|sc_control
operator|=
name|ctl
expr_stmt|;
name|sc
operator|->
name|sc_intre
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_ENABLE
argument_list|)
expr_stmt|;
block|}
name|ctl
operator||=
name|OHCI_HCFS_SUSPEND
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_RESUME_WAIT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
operator|--
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
operator|++
expr_stmt|;
comment|/* Some broken BIOSes never initialize Controller chip */
name|ohci_controller_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_intre
condition|)
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_ENABLE
argument_list|,
name|sc
operator|->
name|sc_intre
operator|&
operator|(
name|OHCI_ALL_INTRS
operator||
name|OHCI_MIE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_control
condition|)
name|ctl
operator|=
name|sc
operator|->
name|sc_control
expr_stmt|;
else|else
name|ctl
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
name|ctl
operator||=
name|OHCI_HCFS_RESUME
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_RESUME_DELAY
argument_list|)
expr_stmt|;
name|ctl
operator|=
operator|(
name|ctl
operator|&
operator|~
name|OHCI_HCFS_MASK
operator|)
operator||
name|OHCI_HCFS_OPERATIONAL
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_RESUME_RECOVERY
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_control
operator|=
name|sc
operator|->
name|sc_intre
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
operator|--
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function
name|void
name|ohci_dumpregs
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_REVISION
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"               intrstat=0x%08x intre=0x%08x intrd=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_ENABLE
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCA
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_PERIOD_CURRENT_ED
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL_HEAD_ED
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL_CURRENT_ED
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_BULK_HEAD_ED
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_BULK_CURRENT_ED
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"               done=0x%08x fmival=0x%08x fmrem=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_DONE_HEAD
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_INTERVAL
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_REMAINING
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_NUMBER
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_PERIODIC_START
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_LS_THRESHOLD
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"               desca=0x%08x descb=0x%08x stat=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_B
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_STATUS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"               port1=0x%08x port2=0x%08x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_PORT_STATUS
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_PORT_STATUS
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"         HCCA: frame_number=0x%04x done_head=0x%08x\n"
operator|,
name|le32toh
argument_list|(
name|sc
operator|->
name|sc_hcca
operator|->
name|hcca_frame_number
argument_list|)
operator|,
name|le32toh
argument_list|(
name|sc
operator|->
name|sc_hcca
operator|->
name|hcca_done_head
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|Static
name|int
name|ohci_intr1
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|ohci_intr
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|p
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If we get an interrupt while polling, then just ignore it. */
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"ohci_intr: ignored interrupt while polling\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ohci_intr1
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|int
name|ohci_intr1
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|intrs
decl_stmt|,
name|eintrs
decl_stmt|;
name|ohci_physaddr_t
name|done
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|14
argument_list|,
operator|(
literal|"ohci_intr1: enter\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* In case the interrupt occurs before initialization has completed. */
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|sc_hcca
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"ohci_intr: sc->sc_hcca == NULL\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|intrs
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|sc_hcca
operator|->
name|hcca_done_head
argument_list|)
expr_stmt|;
comment|/* The LSb of done is used to inform the HC Driver that an interrupt 	 * condition exists for both the Done list and for another event 	 * recorded in HcInterruptStatus. On an interrupt from the HC, the HC 	 * Driver checks the HccaDoneHead Value. If this value is 0, then the 	 * interrupt was caused by other than the HccaDoneHead update and the 	 * HcInterruptStatus register needs to be accessed to determine that 	 * exact interrupt cause. If HccaDoneHead is nonzero, then a Done list 	 * update interrupt is indicated and if the LSb of done is nonzero, 	 * then an additional interrupt event is indicated and 	 * HcInterruptStatus should be checked to determine its cause. 	 */
if|if
condition|(
name|done
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|done
operator|&
operator|~
name|OHCI_DONE_INTRS
condition|)
name|intrs
operator|=
name|OHCI_WDH
expr_stmt|;
if|if
condition|(
name|done
operator|&
name|OHCI_DONE_INTRS
condition|)
block|{
name|intrs
operator||=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
expr_stmt|;
name|done
operator|&=
operator|~
name|OHCI_DONE_INTRS
expr_stmt|;
block|}
name|sc
operator|->
name|sc_hcca
operator|->
name|hcca_done_head
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|intrs
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
operator|&
operator|~
name|OHCI_WDH
expr_stmt|;
if|if
condition|(
name|intrs
operator|==
literal|0
condition|)
comment|/* nothing to be done (PCI shared interrupt) */
return|return
operator|(
literal|0
operator|)
return|;
name|intrs
operator|&=
operator|~
name|OHCI_MIE
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|,
name|intrs
argument_list|)
expr_stmt|;
comment|/* Acknowledge */
name|eintrs
operator|=
name|intrs
operator|&
name|sc
operator|->
name|sc_eintrs
expr_stmt|;
if|if
condition|(
operator|!
name|eintrs
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|no_intrs
operator|++
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|7
argument_list|,
operator|(
literal|"ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n"
operator|,
name|sc
operator|,
operator|(
name|u_int
operator|)
name|intrs
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
operator|,
operator|(
name|u_int
operator|)
name|eintrs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eintrs
operator|&
name|OHCI_SO
condition|)
block|{
name|sc
operator|->
name|sc_overrun_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|usbd_ratecheck
argument_list|(
operator|&
name|sc
operator|->
name|sc_overrun_ntc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %u scheduling overruns\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_overrun_cnt
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_overrun_cnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* XXX do what */
name|eintrs
operator|&=
operator|~
name|OHCI_SO
expr_stmt|;
block|}
if|if
condition|(
name|eintrs
operator|&
name|OHCI_WDH
condition|)
block|{
name|ohci_add_done
argument_list|(
name|sc
argument_list|,
name|done
operator|&
operator|~
name|OHCI_DONE_INTRS
argument_list|)
expr_stmt|;
name|usb_schedsoftintr
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|eintrs
operator|&=
operator|~
name|OHCI_WDH
expr_stmt|;
block|}
if|if
condition|(
name|eintrs
operator|&
name|OHCI_RD
condition|)
block|{
name|printf
argument_list|(
literal|"%s: resume detect\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX process resume detect */
block|}
if|if
condition|(
name|eintrs
operator|&
name|OHCI_UE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unrecoverable error, controller halted\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_RESET
argument_list|)
expr_stmt|;
comment|/* XXX what else */
block|}
if|if
condition|(
name|eintrs
operator|&
name|OHCI_RHSC
condition|)
block|{
name|ohci_rhsc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_intrxfer
argument_list|)
expr_stmt|;
comment|/* 		 * Disable RHSC interrupt for now, because it will be 		 * on until the port has been reset. 		 */
name|ohci_rhsc_able
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do not allow RHSC interrupts> 1 per second */
name|usb_callout
argument_list|(
name|sc
operator|->
name|sc_tmo_rhsc
argument_list|,
name|hz
argument_list|,
name|ohci_rhsc_enable
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|eintrs
operator|&=
operator|~
name|OHCI_RHSC
expr_stmt|;
block|}
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|--
expr_stmt|;
if|if
condition|(
name|eintrs
operator|!=
literal|0
condition|)
block|{
comment|/* Block unprocessed interrupts. XXX */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|,
name|eintrs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_eintrs
operator|&=
operator|~
name|eintrs
expr_stmt|;
name|printf
argument_list|(
literal|"%s: blocking intrs 0x%x\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|,
name|eintrs
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_rhsc_able
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ohci_rhsc_able: on=%d\n"
operator|,
name|on
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
name|sc
operator|->
name|sc_eintrs
operator||=
name|OHCI_RHSC
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_ENABLE
argument_list|,
name|OHCI_RHSC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_eintrs
operator|&=
operator|~
name|OHCI_RHSC
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|,
name|OHCI_RHSC
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ohci_rhsc_enable
parameter_list|(
name|void
modifier|*
name|v_sc
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|v_sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhardusb
argument_list|()
expr_stmt|;
name|ohci_rhsc_able
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|ohci_cc_strs
index|[]
init|=
block|{
literal|"NO_ERROR"
block|,
literal|"CRC"
block|,
literal|"BIT_STUFFING"
block|,
literal|"DATA_TOGGLE_MISMATCH"
block|,
literal|"STALL"
block|,
literal|"DEVICE_NOT_RESPONDING"
block|,
literal|"PID_CHECK_FAILURE"
block|,
literal|"UNEXPECTED_PID"
block|,
literal|"DATA_OVERRUN"
block|,
literal|"DATA_UNDERRUN"
block|,
literal|"BUFFER_OVERRUN"
block|,
literal|"BUFFER_UNDERRUN"
block|,
literal|"reserved"
block|,
literal|"reserved"
block|,
literal|"NOT_ACCESSED"
block|,
literal|"NOT_ACCESSED"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|ohci_add_done
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_physaddr_t
name|done
parameter_list|)
block|{
name|ohci_soft_itd_t
modifier|*
name|sitd
decl_stmt|,
modifier|*
name|sidone
decl_stmt|,
modifier|*
modifier|*
name|ip
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|sdone
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
comment|/* Reverse the done list. */
for|for
control|(
name|sdone
operator|=
name|NULL
operator|,
name|sidone
operator|=
name|NULL
init|;
name|done
operator|!=
literal|0
condition|;
control|)
block|{
name|std
operator|=
name|ohci_hash_find_td
argument_list|(
name|sc
argument_list|,
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|!=
name|NULL
condition|)
block|{
name|std
operator|->
name|dnext
operator|=
name|sdone
expr_stmt|;
name|done
operator|=
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_nexttd
argument_list|)
expr_stmt|;
name|sdone
operator|=
name|std
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"add TD %p\n"
operator|,
name|std
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sitd
operator|=
name|ohci_hash_find_itd
argument_list|(
name|sc
argument_list|,
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|sitd
operator|!=
name|NULL
condition|)
block|{
name|sitd
operator|->
name|dnext
operator|=
name|sidone
expr_stmt|;
name|done
operator|=
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd
operator|.
name|itd_nextitd
argument_list|)
expr_stmt|;
name|sidone
operator|=
name|sitd
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"add ITD %p\n"
operator|,
name|sitd
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|panic
argument_list|(
literal|"ohci_add_done: addr 0x%08lx not found"
argument_list|,
operator|(
name|u_long
operator|)
name|done
argument_list|)
expr_stmt|;
block|}
comment|/* sdone& sidone now hold the done lists. */
comment|/* Put them on the already processed lists. */
for|for
control|(
name|p
operator|=
operator|&
name|sc
operator|->
name|sc_sdone
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|dnext
control|)
empty_stmt|;
operator|*
name|p
operator|=
name|sdone
expr_stmt|;
for|for
control|(
name|ip
operator|=
operator|&
name|sc
operator|->
name|sc_sidone
init|;
operator|*
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
operator|&
operator|(
operator|*
name|ip
operator|)
operator|->
name|dnext
control|)
empty_stmt|;
operator|*
name|ip
operator|=
name|sidone
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_softintr
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|ohci_soft_itd_t
modifier|*
name|sitd
decl_stmt|,
modifier|*
name|sidone
decl_stmt|,
modifier|*
name|sitdnext
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|std
decl_stmt|,
modifier|*
name|sdone
decl_stmt|,
modifier|*
name|stdnext
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|struct
name|ohci_pipe
modifier|*
name|opipe
decl_stmt|;
name|int
name|len
decl_stmt|,
name|cc
decl_stmt|,
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_softintr: enter\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|++
expr_stmt|;
name|s
operator|=
name|splhardusb
argument_list|()
expr_stmt|;
name|sdone
operator|=
name|sc
operator|->
name|sc_sdone
expr_stmt|;
name|sc
operator|->
name|sc_sdone
operator|=
name|NULL
expr_stmt|;
name|sidone
operator|=
name|sc
operator|->
name|sc_sidone
expr_stmt|;
name|sc
operator|->
name|sc_sidone
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_softintr: sdone=%p sidone=%p\n"
operator|,
name|sdone
operator|,
name|sidone
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_process_done: TD done:\n"
operator|)
argument_list|)
expr_stmt|;
name|ohci_dump_tds
argument_list|(
name|sdone
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|std
operator|=
name|sdone
init|;
name|std
condition|;
name|std
operator|=
name|stdnext
control|)
block|{
name|xfer
operator|=
name|std
operator|->
name|xfer
expr_stmt|;
name|stdnext
operator|=
name|std
operator|->
name|dnext
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_process_done: std=%p xfer=%p hcpriv=%p\n"
operator|,
name|std
operator|,
name|xfer
operator|,
operator|(
name|xfer
condition|?
name|xfer
operator|->
name|hcpriv
else|:
name|NULL
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
operator|||
operator|(
name|std
operator|->
name|flags
operator|&
name|OHCI_TD_HANDLED
operator|)
condition|)
block|{
comment|/* 			 * xfer == NULL: There seems to be no xfer associated 			 * with this TD. It is tailp that happened to end up on 			 * the done queue. 			 * flags& OHCI_TD_HANDLED: The TD has already been 			 * handled by process_done and should not be done again. 			 * Shouldn't happen, but some chips are broken(?). 			 */
continue|continue;
block|}
if|if
condition|(
name|xfer
operator|->
name|status
operator|==
name|USBD_CANCELLED
operator|||
name|xfer
operator|->
name|status
operator|==
name|USBD_TIMEOUT
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_process_done: cancel/timeout %p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled by abort routine. */
continue|continue;
block|}
name|usb_uncallout
argument_list|(
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|ohci_timeout
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|len
operator|=
name|std
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|std
operator|->
name|td
operator|.
name|td_cbp
operator|!=
literal|0
condition|)
name|len
operator|-=
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_be
argument_list|)
operator|-
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_cbp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_process_done: len=%d, flags=0x%x\n"
operator|,
name|len
operator|,
name|std
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|->
name|flags
operator|&
name|OHCI_ADD_LEN
condition|)
name|xfer
operator|->
name|actlen
operator|+=
name|len
expr_stmt|;
name|cc
operator|=
name|OHCI_TD_GET_CC
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
name|OHCI_CC_NO_ERROR
condition|)
block|{
if|if
condition|(
name|std
operator|->
name|flags
operator|&
name|OHCI_CALL_DONE
condition|)
block|{
name|xfer
operator|->
name|status
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Endpoint is halted.  First unlink all the TDs 			 * belonging to the failed transfer, and then restart 			 * the endpoint. 			 */
name|ohci_soft_td_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|opipe
operator|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"ohci_process_done: error cc=%d (%s)\n"
operator|,
name|OHCI_TD_GET_CC
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_flags
argument_list|)
argument_list|)
operator|,
name|ohci_cc_strs
index|[
name|OHCI_TD_GET_CC
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_flags
argument_list|)
argument_list|)
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* Mark all the TDs in the done queue for the current 			 * xfer as handled 			 */
for|for
control|(
name|p
operator|=
name|stdnext
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|dnext
control|)
block|{
if|if
condition|(
name|p
operator|->
name|xfer
operator|==
name|xfer
condition|)
name|p
operator|->
name|flags
operator||=
name|OHCI_TD_HANDLED
expr_stmt|;
block|}
comment|/* remove TDs */
for|for
control|(
name|p
operator|=
name|std
init|;
name|p
operator|->
name|xfer
operator|==
name|xfer
condition|;
name|p
operator|=
name|n
control|)
block|{
name|n
operator|=
name|p
operator|->
name|nexttd
expr_stmt|;
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* clear halt */
name|opipe
operator|->
name|sed
operator|->
name|ed
operator|.
name|ed_headp
operator|=
name|htole32
argument_list|(
name|p
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_CLF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
name|OHCI_CC_STALL
condition|)
name|xfer
operator|->
name|status
operator|=
name|USBD_STALLED
expr_stmt|;
else|else
name|xfer
operator|->
name|status
operator|=
name|USBD_IOERROR
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_softintr: ITD done:\n"
operator|)
argument_list|)
expr_stmt|;
name|ohci_dump_itds
argument_list|(
name|sidone
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|sitd
operator|=
name|sidone
init|;
name|sitd
operator|!=
name|NULL
condition|;
name|sitd
operator|=
name|sitdnext
control|)
block|{
name|xfer
operator|=
name|sitd
operator|->
name|xfer
expr_stmt|;
name|sitdnext
operator|=
name|sitd
operator|->
name|dnext
expr_stmt|;
name|sitd
operator|->
name|flags
operator||=
name|OHCI_ITD_INTFIN
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ohci_process_done: sitd=%p xfer=%p hcpriv=%p\n"
operator|,
name|sitd
operator|,
name|xfer
operator|,
name|xfer
condition|?
name|xfer
operator|->
name|hcpriv
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|xfer
operator|->
name|status
operator|==
name|USBD_CANCELLED
operator|||
name|xfer
operator|->
name|status
operator|==
name|USBD_TIMEOUT
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_process_done: cancel/timeout %p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled by abort routine. */
continue|continue;
block|}
if|if
condition|(
name|xfer
operator|->
name|pipe
condition|)
if|if
condition|(
name|xfer
operator|->
name|pipe
operator|->
name|aborting
condition|)
continue|continue;
comment|/*Ignore.*/
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sitd
operator|->
name|isdone
condition|)
name|printf
argument_list|(
literal|"ohci_softintr: sitd=%p is done\n"
argument_list|,
name|sitd
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|isdone
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|opipe
operator|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
expr_stmt|;
if|if
condition|(
name|opipe
operator|->
name|aborting
condition|)
continue|continue;
name|cc
operator|=
name|OHCI_ITD_GET_CC
argument_list|(
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd
operator|.
name|itd_flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
name|OHCI_CC_NO_ERROR
condition|)
block|{
comment|/* XXX compute length for input */
if|if
condition|(
name|sitd
operator|->
name|flags
operator|&
name|OHCI_CALL_DONE
condition|)
block|{
name|opipe
operator|->
name|u
operator|.
name|iso
operator|.
name|inuse
operator|-=
name|xfer
operator|->
name|nframes
expr_stmt|;
comment|/* XXX update frlengths with actual length */
comment|/* XXX xfer->actlen = actlen; */
name|xfer
operator|->
name|status
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* XXX Do more */
name|xfer
operator|->
name|status
operator|=
name|USBD_IOERROR
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|USB_USE_SOFTINTR
if|if
condition|(
name|sc
operator|->
name|sc_softwake
condition|)
block|{
name|sc
operator|->
name|sc_softwake
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_softwake
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USB_USE_SOFTINTR */
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|--
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_softintr: done:\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_device_ctrl_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_device_ctrl_done: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"ohci_device_ctrl_done: not a request"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|xfer
operator|->
name|hcpriv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_device_intr_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|opipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
init|=
name|opipe
operator|->
name|sed
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_device_intr_done: xfer=%p, actlen=%d\n"
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|hcpriv
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|pipe
operator|->
name|repeat
condition|)
block|{
name|data
operator|=
name|opipe
operator|->
name|tail
operator|.
name|td
expr_stmt|;
name|tail
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX should reuse TD */
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|xfer
operator|->
name|status
operator|=
name|USBD_NOMEM
expr_stmt|;
return|return;
block|}
name|tail
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
name|OHCI_TD_IN
operator||
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_SET_DI
argument_list|(
literal|1
argument_list|)
operator||
name|OHCI_TD_TOGGLE_CARRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags
operator|&
name|USBD_SHORT_XFER_OK
condition|)
name|data
operator|->
name|td
operator|.
name|td_flags
operator||=
name|htole32
argument_list|(
name|OHCI_TD_R
argument_list|)
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_cbp
operator|=
name|htole32
argument_list|(
name|DMAADDR
argument_list|(
operator|&
name|xfer
operator|->
name|dmabuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|nexttd
operator|=
name|tail
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_nexttd
operator|=
name|htole32
argument_list|(
name|tail
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_be
operator|=
name|htole32
argument_list|(
name|le32toh
argument_list|(
name|data
operator|->
name|td
operator|.
name|td_cbp
argument_list|)
operator|+
name|xfer
operator|->
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|data
operator|->
name|len
operator|=
name|xfer
operator|->
name|length
expr_stmt|;
name|data
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|data
operator|->
name|flags
operator|=
name|OHCI_CALL_DONE
operator||
name|OHCI_ADD_LEN
expr_stmt|;
name|xfer
operator|->
name|hcpriv
operator|=
name|data
expr_stmt|;
name|xfer
operator|->
name|actlen
operator|=
literal|0
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
operator|=
name|htole32
argument_list|(
name|tail
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|opipe
operator|->
name|tail
operator|.
name|td
operator|=
name|tail
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ohci_device_bulk_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_device_bulk_done: xfer=%p, actlen=%d\n"
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|hcpriv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_rhsc
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_pipe_handle
name|pipe
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|m
decl_stmt|;
name|int
name|hstatus
decl_stmt|;
name|hstatus
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_STATUS
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\n"
operator|,
name|sc
operator|,
name|xfer
operator|,
name|hstatus
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
comment|/* Just ignore the change. */
return|return;
block|}
name|pipe
operator|=
name|xfer
operator|->
name|pipe
expr_stmt|;
name|p
operator|=
name|KERNADDR
argument_list|(
operator|&
name|xfer
operator|->
name|dmabuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m
operator|=
name|min
argument_list|(
name|sc
operator|->
name|sc_noport
argument_list|,
name|xfer
operator|->
name|length
operator|*
literal|8
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|xfer
operator|->
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|m
condition|;
name|i
operator|++
control|)
block|{
comment|/* Pick out CHANGE bits from the status reg. */
if|if
condition|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_PORT_STATUS
argument_list|(
name|i
argument_list|)
argument_list|)
operator|>>
literal|16
condition|)
name|p
index|[
name|i
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_rhsc: change=0x%02x\n"
operator|,
operator|*
name|p
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|actlen
operator|=
name|xfer
operator|->
name|length
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_root_intr_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|xfer
operator|->
name|hcpriv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_root_ctrl_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|xfer
operator|->
name|hcpriv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait here until controller claims to have an interrupt.  * Then call ohci_intr and return.  Use timeout to avoid waiting  * too long.  */
end_comment

begin_function
name|void
name|ohci_waitintr
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|int
name|timo
init|=
name|xfer
operator|->
name|timeout
decl_stmt|;
name|int
name|usecs
decl_stmt|;
name|u_int32_t
name|intrs
decl_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
for|for
control|(
name|usecs
operator|=
name|timo
operator|*
literal|1000000
operator|/
name|hz
init|;
name|usecs
operator|>
literal|0
condition|;
name|usecs
operator|-=
literal|1000
control|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
break|break;
name|intrs
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
operator|&
name|sc
operator|->
name|sc_eintrs
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"ohci_waitintr: 0x%04x\n"
operator|,
name|intrs
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|15
condition|)
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|intrs
condition|)
block|{
name|ohci_intr1
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|status
operator|!=
name|USBD_IN_PROGRESS
condition|)
return|return;
block|}
block|}
comment|/* Timeout */
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_waitintr: timeout\n"
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_TIMEOUT
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* XXX should free TD */
block|}
end_function

begin_function
name|void
name|ohci_poll
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|bus
decl_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
specifier|static
name|int
name|last
decl_stmt|;
name|int
name|new
decl_stmt|;
name|new
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|last
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_poll: intrs=0x%04x\n"
operator|,
name|new
operator|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|new
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
operator|&
name|sc
operator|->
name|sc_eintrs
condition|)
name|ohci_intr1
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|ohci_device_request
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usb_device_request_t
modifier|*
name|req
init|=
operator|&
name|xfer
operator|->
name|request
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|opipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|int
name|addr
init|=
name|dev
operator|->
name|address
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|setup
decl_stmt|,
modifier|*
name|stat
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
name|int
name|isread
decl_stmt|;
name|int
name|len
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|s
decl_stmt|;
name|isread
operator|=
name|req
operator|->
name|bmRequestType
operator|&
name|UT_READ
expr_stmt|;
name|len
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"ohci_device_control type=0x%02x, request=0x%02x, "
literal|"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\n"
operator|,
name|req
operator|->
name|bmRequestType
operator|,
name|req
operator|->
name|bRequest
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
operator|,
name|len
operator|,
name|addr
operator|,
name|opipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|)
argument_list|)
expr_stmt|;
name|setup
operator|=
name|opipe
operator|->
name|tail
operator|.
name|td
expr_stmt|;
name|stat
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
name|tail
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|tail
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|sed
operator|=
name|opipe
operator|->
name|sed
expr_stmt|;
name|opipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|length
operator|=
name|len
expr_stmt|;
comment|/* Update device address and length since they may have changed. */
comment|/* XXX This only needs to be done once, but it's too early in open. */
comment|/* XXXX Should not touch ED here! */
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|=
name|htole32
argument_list|(
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_flags
argument_list|)
operator|&
operator|~
operator|(
name|OHCI_ED_ADDRMASK
operator||
name|OHCI_ED_MAXPMASK
operator|)
operator|)
operator||
name|OHCI_ED_SET_FA
argument_list|(
name|addr
argument_list|)
operator||
name|OHCI_ED_SET_MAXP
argument_list|(
name|UGETW
argument_list|(
name|opipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|=
name|stat
expr_stmt|;
comment|/* Set up data transaction */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|ohci_soft_td_t
modifier|*
name|std
init|=
name|stat
decl_stmt|;
name|err
operator|=
name|ohci_alloc_std_chain
argument_list|(
name|opipe
argument_list|,
name|sc
argument_list|,
name|len
argument_list|,
name|isread
argument_list|,
name|xfer
argument_list|,
name|std
argument_list|,
operator|&
name|stat
argument_list|)
expr_stmt|;
name|stat
operator|=
name|stat
operator|->
name|nexttd
expr_stmt|;
comment|/* point at free TD */
if|if
condition|(
name|err
condition|)
goto|goto
name|bad3
goto|;
comment|/* Start toggle at 1 and then use the carried toggle. */
name|std
operator|->
name|td
operator|.
name|td_flags
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_TD_TOGGLE_MASK
argument_list|)
expr_stmt|;
name|std
operator|->
name|td
operator|.
name|td_flags
operator||=
name|htole32
argument_list|(
name|OHCI_TD_TOGGLE_1
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|KERNADDR
argument_list|(
operator|&
name|opipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|,
literal|0
argument_list|)
argument_list|,
name|req
argument_list|,
sizeof|sizeof
expr|*
name|req
argument_list|)
expr_stmt|;
name|setup
operator|->
name|td
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
name|OHCI_TD_SETUP
operator||
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_TOGGLE_0
operator||
name|OHCI_TD_NOINTR
argument_list|)
expr_stmt|;
name|setup
operator|->
name|td
operator|.
name|td_cbp
operator|=
name|htole32
argument_list|(
name|DMAADDR
argument_list|(
operator|&
name|opipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|setup
operator|->
name|nexttd
operator|=
name|next
expr_stmt|;
name|setup
operator|->
name|td
operator|.
name|td_nexttd
operator|=
name|htole32
argument_list|(
name|next
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|setup
operator|->
name|td
operator|.
name|td_be
operator|=
name|htole32
argument_list|(
name|le32toh
argument_list|(
name|setup
operator|->
name|td
operator|.
name|td_cbp
argument_list|)
operator|+
sizeof|sizeof
expr|*
name|req
operator|-
literal|1
argument_list|)
expr_stmt|;
name|setup
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|setup
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|setup
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|hcpriv
operator|=
name|setup
expr_stmt|;
name|stat
operator|->
name|td
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
operator|(
name|isread
condition|?
name|OHCI_TD_OUT
else|:
name|OHCI_TD_IN
operator|)
operator||
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_TOGGLE_1
operator||
name|OHCI_TD_SET_DI
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|stat
operator|->
name|td
operator|.
name|td_cbp
operator|=
literal|0
expr_stmt|;
name|stat
operator|->
name|nexttd
operator|=
name|tail
expr_stmt|;
name|stat
operator|->
name|td
operator|.
name|td_nexttd
operator|=
name|htole32
argument_list|(
name|tail
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|stat
operator|->
name|td
operator|.
name|td_be
operator|=
literal|0
expr_stmt|;
name|stat
operator|->
name|flags
operator|=
name|OHCI_CALL_DONE
expr_stmt|;
name|stat
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|stat
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|5
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_request:\n"
operator|)
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sed
argument_list|)
expr_stmt|;
name|ohci_dump_tds
argument_list|(
name|setup
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Insert ED in schedule */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
operator|=
name|htole32
argument_list|(
name|tail
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|opipe
operator|->
name|tail
operator|.
name|td
operator|=
name|tail
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_CLF
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|&&
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|usb_callout
argument_list|(
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|MS_TO_TICKS
argument_list|(
name|xfer
operator|->
name|timeout
argument_list|)
argument_list|,
name|ohci_timeout
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|20
condition|)
block|{
name|delay
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_request: status=%x\n"
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ctrl head:\n"
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sc
operator|->
name|sc_ctrl_head
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sed:\n"
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sed
argument_list|)
expr_stmt|;
name|ohci_dump_tds
argument_list|(
name|setup
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad3
label|:
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|bad2
label|:
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|bad1
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an ED to the schedule.  Called at splusb().  */
end_comment

begin_function
name|void
name|ohci_add_ed
parameter_list|(
name|ohci_soft_ed_t
modifier|*
name|sed
parameter_list|,
name|ohci_soft_ed_t
modifier|*
name|head
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ohci_add_ed: sed=%p head=%p\n"
operator|,
name|sed
operator|,
name|head
operator|)
argument_list|)
expr_stmt|;
name|SPLUSBCHECK
expr_stmt|;
name|sed
operator|->
name|next
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_nexted
operator|=
name|head
operator|->
name|ed
operator|.
name|ed_nexted
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|sed
expr_stmt|;
name|head
operator|->
name|ed
operator|.
name|ed_nexted
operator|=
name|htole32
argument_list|(
name|sed
operator|->
name|physaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove an ED from the schedule.  Called at splusb().  */
end_comment

begin_function
name|void
name|ohci_rem_ed
parameter_list|(
name|ohci_soft_ed_t
modifier|*
name|sed
parameter_list|,
name|ohci_soft_ed_t
modifier|*
name|head
parameter_list|)
block|{
name|ohci_soft_ed_t
modifier|*
name|p
decl_stmt|;
name|SPLUSBCHECK
expr_stmt|;
comment|/* XXX */
for|for
control|(
name|p
operator|=
name|head
init|;
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|next
operator|!=
name|sed
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ohci_rem_ed: ED not found"
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|sed
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|ed
operator|.
name|ed_nexted
operator|=
name|sed
operator|->
name|ed
operator|.
name|ed_nexted
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When a transfer is completed the TD is added to the done queue by  * the host controller.  This queue is the processed by software.  * Unfortunately the queue contains the physical address of the TD  * and we have no simple way to translate this back to a kernel address.  * To make the translation possible (and fast) we use a hash table of  * TDs currently in the schedule.  The physical address is used as the  * hash value.  */
end_comment

begin_define
define|#
directive|define
name|HASH
parameter_list|(
name|a
parameter_list|)
value|(((a)>> 4) % OHCI_HASH_SIZE)
end_define

begin_comment
comment|/* Called at splusb() */
end_comment

begin_function
name|void
name|ohci_hash_add_td
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_soft_td_t
modifier|*
name|std
parameter_list|)
block|{
name|int
name|h
init|=
name|HASH
argument_list|(
name|std
operator|->
name|physaddr
argument_list|)
decl_stmt|;
name|SPLUSBCHECK
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_hash_tds
index|[
name|h
index|]
argument_list|,
name|std
argument_list|,
name|hnext
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at splusb() */
end_comment

begin_function
name|void
name|ohci_hash_rem_td
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_soft_td_t
modifier|*
name|std
parameter_list|)
block|{
name|SPLUSBCHECK
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|std
argument_list|,
name|hnext
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ohci_soft_td_t
modifier|*
name|ohci_hash_find_td
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_physaddr_t
name|a
parameter_list|)
block|{
name|int
name|h
init|=
name|HASH
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|std
decl_stmt|;
comment|/* if these are present they should be masked out at an earlier 	 * stage. 	 */
name|KASSERT
argument_list|(
operator|(
name|a
operator|&
operator|~
name|OHCI_HEADMASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: 0x%b has lower bits set\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|,
operator|(
name|int
operator|)
name|a
operator|,
literal|"\20\1HALT\2TOGGLE"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|std
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_hash_tds
index|[
name|h
index|]
argument_list|)
init|;
name|std
operator|!=
name|NULL
condition|;
name|std
operator|=
name|LIST_NEXT
argument_list|(
name|std
argument_list|,
name|hnext
argument_list|)
control|)
if|if
condition|(
name|std
operator|->
name|physaddr
operator|==
name|a
condition|)
return|return
operator|(
name|std
operator|)
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: ohci_hash_find_td: addr 0x%08lx not found\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|a
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Called at splusb() */
end_comment

begin_function
name|void
name|ohci_hash_add_itd
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_soft_itd_t
modifier|*
name|sitd
parameter_list|)
block|{
name|int
name|h
init|=
name|HASH
argument_list|(
name|sitd
operator|->
name|physaddr
argument_list|)
decl_stmt|;
name|SPLUSBCHECK
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_hash_add_itd: sitd=%p physaddr=0x%08lx\n"
operator|,
name|sitd
operator|,
operator|(
name|u_long
operator|)
name|sitd
operator|->
name|physaddr
operator|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_hash_itds
index|[
name|h
index|]
argument_list|,
name|sitd
argument_list|,
name|hnext
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at splusb() */
end_comment

begin_function
name|void
name|ohci_hash_rem_itd
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_soft_itd_t
modifier|*
name|sitd
parameter_list|)
block|{
name|SPLUSBCHECK
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ohci_hash_rem_itd: sitd=%p physaddr=0x%08lx\n"
operator|,
name|sitd
operator|,
operator|(
name|u_long
operator|)
name|sitd
operator|->
name|physaddr
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sitd
argument_list|,
name|hnext
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ohci_soft_itd_t
modifier|*
name|ohci_hash_find_itd
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|ohci_physaddr_t
name|a
parameter_list|)
block|{
name|int
name|h
init|=
name|HASH
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|ohci_soft_itd_t
modifier|*
name|sitd
decl_stmt|;
for|for
control|(
name|sitd
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_hash_itds
index|[
name|h
index|]
argument_list|)
init|;
name|sitd
operator|!=
name|NULL
condition|;
name|sitd
operator|=
name|LIST_NEXT
argument_list|(
name|sitd
argument_list|,
name|hnext
argument_list|)
control|)
if|if
condition|(
name|sitd
operator|->
name|physaddr
operator|==
name|a
condition|)
return|return
operator|(
name|sitd
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_timeout
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|ohci_xfer
modifier|*
name|oxfer
init|=
name|addr
decl_stmt|;
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|oxfer
operator|->
name|xfer
operator|.
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|opipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_timeout: oxfer=%p\n"
operator|,
name|oxfer
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
block|{
name|ohci_abort_xfer
argument_list|(
operator|&
name|oxfer
operator|->
name|xfer
argument_list|,
name|USBD_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Execute the abort in a process context. */
name|usb_init_task
argument_list|(
operator|&
name|oxfer
operator|->
name|abort_task
argument_list|,
name|ohci_timeout_task
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|usb_add_task
argument_list|(
name|oxfer
operator|->
name|xfer
operator|.
name|pipe
operator|->
name|device
argument_list|,
operator|&
name|oxfer
operator|->
name|abort_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_timeout_task
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|usbd_xfer_handle
name|xfer
init|=
name|addr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_timeout_task: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ohci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_TIMEOUT
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function
name|void
name|ohci_dump_tds
parameter_list|(
name|ohci_soft_td_t
modifier|*
name|std
parameter_list|)
block|{
for|for
control|(
init|;
name|std
condition|;
name|std
operator|=
name|std
operator|->
name|nexttd
control|)
name|ohci_dump_td
argument_list|(
name|std
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_dump_td
parameter_list|(
name|ohci_soft_td_t
modifier|*
name|std
parameter_list|)
block|{
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
name|bitmask_snprintf
argument_list|(
operator|(
name|u_int32_t
operator|)
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_flags
argument_list|)
argument_list|,
literal|"\20\23R\24OUT\25IN\31TOG1\32SETTOGGLE"
argument_list|,
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TD(%p) at %08lx: %s delay=%d ec=%d cc=%d\ncbp=0x%08lx "
literal|"nexttd=0x%08lx be=0x%08lx\n"
argument_list|,
name|std
argument_list|,
operator|(
name|u_long
operator|)
name|std
operator|->
name|physaddr
argument_list|,
name|sbuf
argument_list|,
name|OHCI_TD_GET_DI
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_flags
argument_list|)
argument_list|)
argument_list|,
name|OHCI_TD_GET_EC
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_flags
argument_list|)
argument_list|)
argument_list|,
name|OHCI_TD_GET_CC
argument_list|(
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_flags
argument_list|)
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_cbp
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_nexttd
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|le32toh
argument_list|(
name|std
operator|->
name|td
operator|.
name|td_be
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_dump_itd
parameter_list|(
name|ohci_soft_itd_t
modifier|*
name|sitd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"ITD(%p) at %08lx: sf=%d di=%d fc=%d cc=%d\n"
literal|"bp0=0x%08lx next=0x%08lx be=0x%08lx\n"
argument_list|,
name|sitd
argument_list|,
operator|(
name|u_long
operator|)
name|sitd
operator|->
name|physaddr
argument_list|,
name|OHCI_ITD_GET_SF
argument_list|(
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd
operator|.
name|itd_flags
argument_list|)
argument_list|)
argument_list|,
name|OHCI_ITD_GET_DI
argument_list|(
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd
operator|.
name|itd_flags
argument_list|)
argument_list|)
argument_list|,
name|OHCI_ITD_GET_FC
argument_list|(
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd
operator|.
name|itd_flags
argument_list|)
argument_list|)
argument_list|,
name|OHCI_ITD_GET_CC
argument_list|(
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd
operator|.
name|itd_flags
argument_list|)
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd
operator|.
name|itd_bp0
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd
operator|.
name|itd_nextitd
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd
operator|.
name|itd_be
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_ITD_NOFFSET
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"offs[%d]=0x%04x "
argument_list|,
name|i
argument_list|,
operator|(
name|u_int
operator|)
name|le16toh
argument_list|(
name|sitd
operator|->
name|itd
operator|.
name|itd_offset
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_dump_itds
parameter_list|(
name|ohci_soft_itd_t
modifier|*
name|sitd
parameter_list|)
block|{
for|for
control|(
init|;
name|sitd
condition|;
name|sitd
operator|=
name|sitd
operator|->
name|nextitd
control|)
name|ohci_dump_itd
argument_list|(
name|sitd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_dump_ed
parameter_list|(
name|ohci_soft_ed_t
modifier|*
name|sed
parameter_list|)
block|{
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|,
name|sbuf2
index|[
literal|128
index|]
decl_stmt|;
name|bitmask_snprintf
argument_list|(
operator|(
name|u_int32_t
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_flags
argument_list|)
argument_list|,
literal|"\20\14OUT\15IN\16LOWSPEED\17SKIP\20ISO"
argument_list|,
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
name|bitmask_snprintf
argument_list|(
operator|(
name|u_int32_t
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
argument_list|,
literal|"\20\1HALT\2CARRY"
argument_list|,
name|sbuf2
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d flags=%s\ntailp=0x%08lx "
literal|"headflags=%s headp=0x%08lx nexted=0x%08lx\n"
argument_list|,
name|sed
argument_list|,
operator|(
name|u_long
operator|)
name|sed
operator|->
name|physaddr
argument_list|,
name|OHCI_ED_GET_FA
argument_list|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_flags
argument_list|)
argument_list|)
argument_list|,
name|OHCI_ED_GET_EN
argument_list|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_flags
argument_list|)
argument_list|)
argument_list|,
name|OHCI_ED_GET_MAXP
argument_list|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_flags
argument_list|)
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|(
name|u_long
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
argument_list|)
argument_list|,
name|sbuf2
argument_list|,
operator|(
name|u_long
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_nexted
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|usbd_status
name|ohci_open
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|usbd_device_handle
name|dev
init|=
name|pipe
operator|->
name|device
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
init|=
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
decl_stmt|;
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|u_int8_t
name|addr
init|=
name|dev
operator|->
name|address
decl_stmt|;
name|u_int8_t
name|xfertype
init|=
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|ohci_soft_itd_t
modifier|*
name|sitd
decl_stmt|;
name|ohci_physaddr_t
name|tdphys
decl_stmt|;
name|u_int32_t
name|fmt
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|ival
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ohci_open: pipe=%p, addr=%d, endpt=%d (%d)\n"
operator|,
name|pipe
operator|,
name|addr
operator|,
name|ed
operator|->
name|bEndpointAddress
operator|,
name|sc
operator|->
name|sc_addr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
name|std
operator|=
name|NULL
expr_stmt|;
name|sed
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|sc
operator|->
name|sc_addr
condition|)
block|{
switch|switch
condition|(
name|ed
operator|->
name|bEndpointAddress
condition|)
block|{
case|case
name|USB_CONTROL_ENDPOINT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ohci_root_ctrl_methods
expr_stmt|;
break|break;
case|case
name|UE_DIR_IN
operator||
name|OHCI_INTR_ENDPT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ohci_root_intr_methods
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
block|}
else|else
block|{
name|sed
operator|=
name|ohci_alloc_sed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sed
operator|==
name|NULL
condition|)
goto|goto
name|bad0
goto|;
name|opipe
operator|->
name|sed
operator|=
name|sed
expr_stmt|;
if|if
condition|(
name|xfertype
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
name|sitd
operator|=
name|ohci_alloc_sitd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sitd
operator|==
name|NULL
condition|)
goto|goto
name|bad1
goto|;
name|opipe
operator|->
name|tail
operator|.
name|itd
operator|=
name|sitd
expr_stmt|;
name|opipe
operator|->
name|aborting
operator|=
literal|0
expr_stmt|;
name|tdphys
operator|=
name|sitd
operator|->
name|physaddr
expr_stmt|;
name|fmt
operator|=
name|OHCI_ED_FORMAT_ISO
expr_stmt|;
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
name|fmt
operator||=
name|OHCI_ED_DIR_IN
expr_stmt|;
else|else
name|fmt
operator||=
name|OHCI_ED_DIR_OUT
expr_stmt|;
block|}
else|else
block|{
name|std
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|==
name|NULL
condition|)
goto|goto
name|bad1
goto|;
name|opipe
operator|->
name|tail
operator|.
name|td
operator|=
name|std
expr_stmt|;
name|tdphys
operator|=
name|std
operator|->
name|physaddr
expr_stmt|;
name|fmt
operator|=
name|OHCI_ED_FORMAT_GEN
operator||
name|OHCI_ED_DIR_TD
expr_stmt|;
block|}
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|=
name|htole32
argument_list|(
name|OHCI_ED_SET_FA
argument_list|(
name|addr
argument_list|)
operator||
name|OHCI_ED_SET_EN
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator||
operator|(
name|dev
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|?
name|OHCI_ED_SPEED
else|:
literal|0
operator|)
operator||
name|fmt
operator||
name|OHCI_ED_SET_MAXP
argument_list|(
name|UGETW
argument_list|(
name|ed
operator|->
name|wMaxPacketSize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_headp
operator|=
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
operator|=
name|htole32
argument_list|(
name|tdphys
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|xfertype
condition|)
block|{
case|case
name|UE_CONTROL
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ohci_device_ctrl_methods
expr_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
sizeof|sizeof
argument_list|(
name|usb_device_request_t
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|opipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|bad
goto|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ohci_add_ed
argument_list|(
name|sed
argument_list|,
name|sc
operator|->
name|sc_ctrl_head
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_INTERRUPT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ohci_device_intr_methods
expr_stmt|;
name|ival
operator|=
name|pipe
operator|->
name|interval
expr_stmt|;
if|if
condition|(
name|ival
operator|==
name|USBD_DEFAULT_INTERVAL
condition|)
name|ival
operator|=
name|ed
operator|->
name|bInterval
expr_stmt|;
return|return
operator|(
name|ohci_device_setintr
argument_list|(
name|sc
argument_list|,
name|opipe
argument_list|,
name|ival
argument_list|)
operator|)
return|;
case|case
name|UE_ISOCHRONOUS
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ohci_device_isoc_methods
expr_stmt|;
return|return
operator|(
name|ohci_setup_isoc
argument_list|(
name|pipe
argument_list|)
operator|)
return|;
case|case
name|UE_BULK
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ohci_device_bulk_methods
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ohci_add_ed
argument_list|(
name|sed
argument_list|,
name|sc
operator|->
name|sc_bulk_head
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|std
operator|!=
name|NULL
condition|)
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|std
argument_list|)
expr_stmt|;
name|bad1
label|:
if|if
condition|(
name|sed
operator|!=
name|NULL
condition|)
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|sed
argument_list|)
expr_stmt|;
name|bad0
label|:
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close a reqular pipe.  * Assumes that there are no pending transactions.  */
end_comment

begin_function
name|void
name|ohci_close_pipe
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|,
name|ohci_soft_ed_t
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
init|=
name|opipe
operator|->
name|sed
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
operator|!=
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
condition|)
block|{
name|ohci_soft_td_t
modifier|*
name|std
decl_stmt|;
name|std
operator|=
name|ohci_hash_find_td
argument_list|(
name|sc
argument_list|,
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ohci_close_pipe: pipe not empty sed=%p hd=0x%x "
literal|"tl=0x%x pipe=%p, std=%p\n"
argument_list|,
name|sed
argument_list|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
argument_list|)
argument_list|,
name|pipe
argument_list|,
name|std
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|usbd_dump_pipe
argument_list|(
operator|&
name|opipe
operator|->
name|pipe
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USB_DEBUG
name|ohci_dump_ed
argument_list|(
name|sed
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
condition|)
name|ohci_dump_td
argument_list|(
name|std
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
operator|!=
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
condition|)
name|printf
argument_list|(
literal|"ohci_close_pipe: pipe still not empty\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ohci_rem_ed
argument_list|(
name|sed
argument_list|,
name|head
argument_list|)
expr_stmt|;
comment|/* Make sure the host controller is not touching this ED */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|opipe
operator|->
name|sed
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Abort a device request.  * If this routine is called at splusb() it guarantees that the request  * will be removed from the hardware scheduling and that the callback  * for it will be called with USBD_CANCELLED status.  * It's impossible to guarantee that the requested transfer will not  * have happened since the hardware runs concurrently.  * If the transaction has already happened we rely on the ordinary  * interrupt processing to process it.  */
end_comment

begin_function
name|void
name|ohci_abort_xfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_status
name|status
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|opipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
init|=
name|opipe
operator|->
name|sed
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|ohci_physaddr_t
name|headp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|hit
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_abort_xfer: xfer=%p pipe=%p sed=%p\n"
operator|,
name|xfer
operator|,
name|opipe
operator|,
name|sed
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
block|{
comment|/* If we're dying, just do the software part. */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|status
expr_stmt|;
comment|/* make software ignore it */
name|usb_uncallout
argument_list|(
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|ohci_timeout
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xfer
operator|->
name|device
operator|->
name|bus
operator|->
name|intr_context
operator|||
operator|!
name|curproc
condition|)
name|panic
argument_list|(
literal|"ohci_abort_xfer: not in process context"
argument_list|)
expr_stmt|;
comment|/* 	 * Step 1: Make interrupt routine and hardware ignore xfer. 	 */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|status
expr_stmt|;
comment|/* make software ignore it */
name|usb_uncallout
argument_list|(
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|ohci_timeout
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ohci_abort_xfer: stop ed=%p\n"
operator|,
name|sed
operator|)
argument_list|)
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* force hardware skip */
comment|/* 	 * Step 2: Wait until we know hardware has finished any possible 	 * use of the xfer.  Also make sure the soft interrupt routine 	 * has run. 	 */
name|usb_delay_ms
argument_list|(
name|opipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
argument_list|,
literal|20
argument_list|)
expr_stmt|;
comment|/* Hardware finishes in 1ms */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_USE_SOFTINTR
name|sc
operator|->
name|sc_softwake
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* USB_USE_SOFTINTR */
name|usb_schedsoftintr
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_USE_SOFTINTR
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_softwake
argument_list|,
name|PZERO
argument_list|,
literal|"ohciab"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USB_USE_SOFTINTR */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Step 3: Remove any vestiges of the xfer from the hardware. 	 * The complication here is that the hardware may have executed 	 * beyond the xfer we're trying to abort.  So as we're scanning 	 * the TDs of this xfer we check if the hardware points to 	 * any of them. 	 */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
comment|/* XXX why? */
name|p
operator|=
name|xfer
operator|->
name|hcpriv
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ohci_abort_xfer: hcpriv is NULL\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_abort_xfer: sed=\n"
operator|)
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sed
argument_list|)
expr_stmt|;
name|ohci_dump_tds
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|headp
operator|=
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
operator|&
name|OHCI_HEADMASK
expr_stmt|;
name|hit
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|p
operator|->
name|xfer
operator|==
name|xfer
condition|;
name|p
operator|=
name|n
control|)
block|{
name|hit
operator||=
name|headp
operator|==
name|p
operator|->
name|physaddr
expr_stmt|;
name|n
operator|=
name|p
operator|->
name|nexttd
expr_stmt|;
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Zap headp register if hardware pointed inside the xfer. */
if|if
condition|(
name|hit
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ohci_abort_xfer: set hd=0x08%x, tl=0x%08x\n"
operator|,
operator|(
name|int
operator|)
name|p
operator|->
name|physaddr
operator|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_headp
operator|=
name|htole32
argument_list|(
name|p
operator|->
name|physaddr
argument_list|)
expr_stmt|;
comment|/* unlink TDs */
block|}
else|else
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ohci_abort_xfer: no hit\n"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Step 4: Turn on hardware again. 	 */
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* remove hardware skip */
comment|/* 	 * Step 5: Execute callback. 	 */
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Data structures and routines to emulate the root hub.  */
end_comment

begin_decl_stmt
name|Static
name|usb_device_descriptor_t
name|ohci_devd
init|=
block|{
name|USB_DEVICE_DESCRIPTOR_SIZE
block|,
name|UDESC_DEVICE
block|,
comment|/* type */
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* USB version */
name|UDCLASS_HUB
block|,
comment|/* class */
name|UDSUBCLASS_HUB
block|,
comment|/* subclass */
name|UDPROTO_FSHUB
block|,
comment|/* protocol */
literal|64
block|,
comment|/* max packet */
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* device id */
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* string indicies */
literal|1
comment|/* # of configurations */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|usb_config_descriptor_t
name|ohci_confd
init|=
block|{
name|USB_CONFIG_DESCRIPTOR_SIZE
block|,
name|UDESC_CONFIG
block|,
block|{
name|USB_CONFIG_DESCRIPTOR_SIZE
operator|+
name|USB_INTERFACE_DESCRIPTOR_SIZE
operator|+
name|USB_ENDPOINT_DESCRIPTOR_SIZE
block|}
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|UC_SELF_POWERED
block|,
literal|0
comment|/* max power */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|usb_interface_descriptor_t
name|ohci_ifcd
init|=
block|{
name|USB_INTERFACE_DESCRIPTOR_SIZE
block|,
name|UDESC_INTERFACE
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
name|UICLASS_HUB
block|,
name|UISUBCLASS_HUB
block|,
name|UIPROTO_FSHUB
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|usb_endpoint_descriptor_t
name|ohci_endpd
init|=
block|{
name|USB_ENDPOINT_DESCRIPTOR_SIZE
block|,
name|UDESC_ENDPOINT
block|,
name|UE_DIR_IN
operator||
name|OHCI_INTR_ENDPT
block|,
name|UE_INTERRUPT
block|,
block|{
literal|8
block|,
literal|0
block|}
block|,
comment|/* max packet */
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|usb_hub_descriptor_t
name|ohci_hubd
init|=
block|{
name|USB_HUB_DESCRIPTOR_SIZE
block|,
name|UDESC_HUB
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|Static
name|int
name|ohci_str
parameter_list|(
name|usb_string_descriptor_t
modifier|*
name|p
parameter_list|,
name|int
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|->
name|bLength
operator|=
literal|2
operator|*
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|p
operator|->
name|bDescriptorType
operator|=
name|UDESC_STRING
expr_stmt|;
name|l
operator|-=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
index|[
name|i
index|]
operator|&&
name|l
operator|>
literal|1
condition|;
name|i
operator|++
operator|,
name|l
operator|-=
literal|2
control|)
name|USETW2
argument_list|(
name|p
operator|->
name|bString
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|*
name|i
operator|+
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simulate a hardware hub by handling all the necessary requests.  */
end_comment

begin_function
name|Static
name|usbd_status
name|ohci_root_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Pipe isn't running, start first */
return|return
operator|(
name|ohci_root_ctrl_start
argument_list|(
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_root_ctrl_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|xfer
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|usb_device_request_t
modifier|*
name|req
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|port
decl_stmt|,
name|i
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|,
name|value
decl_stmt|,
name|index
decl_stmt|,
name|l
decl_stmt|,
name|totlen
init|=
literal|0
decl_stmt|;
name|usb_port_status_t
name|ps
decl_stmt|;
name|usb_hub_descriptor_t
name|hubd
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
operator|)
condition|)
comment|/* XXX panic */
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
endif|#
directive|endif
name|req
operator|=
operator|&
name|xfer
operator|->
name|request
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ohci_root_ctrl_control type=0x%02x request=%02x\n"
operator|,
name|req
operator|->
name|bmRequestType
operator|,
name|req
operator|->
name|bRequest
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
expr_stmt|;
name|value
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
expr_stmt|;
name|index
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|buf
operator|=
name|KERNADDR
argument_list|(
operator|&
name|xfer
operator|->
name|dmabuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) | ((y)<< 8))
switch|switch
condition|(
name|C
argument_list|(
name|req
operator|->
name|bRequest
argument_list|,
name|req
operator|->
name|bmRequestType
argument_list|)
condition|)
block|{
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
comment|/* 		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops 		 * for the integrated root hub. 		 */
break|break;
case|case
name|C
argument_list|(
name|UR_GET_CONFIG
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
name|sc
operator|->
name|sc_conf
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ohci_root_ctrl_control wValue=0x%04x\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
operator|>>
literal|8
condition|)
block|{
case|case
name|UDESC_DEVICE
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|totlen
operator|=
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_DEVICE_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|ohci_devd
operator|.
name|idVendor
argument_list|,
name|sc
operator|->
name|sc_id_vendor
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ohci_devd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESC_CONFIG
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|totlen
operator|=
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_CONFIG_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ohci_confd
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_INTERFACE_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ohci_ifcd
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_ENDPOINT_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ohci_endpd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESC_STRING
case|:
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
literal|0
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
case|case
literal|1
case|:
comment|/* Vendor */
name|totlen
operator|=
name|ohci_str
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|sc
operator|->
name|sc_vendor
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Product */
name|totlen
operator|=
name|ohci_str
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"OHCI root hub"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_INTERFACE
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
literal|0
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|USETW
argument_list|(
operator|(
operator|(
name|usb_status_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|wStatus
argument_list|,
name|UDS_SELF_POWERED
argument_list|)
expr_stmt|;
name|totlen
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_ENDPOINT
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|USETW
argument_list|(
operator|(
operator|(
name|usb_status_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|wStatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|totlen
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_SET_ADDRESS
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|>=
name|USB_MAX_DEVICES
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|sc
operator|->
name|sc_addr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_CONFIG
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|value
operator|!=
literal|1
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|sc
operator|->
name|sc_conf
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|C
argument_list|(
name|UR_SET_INTERFACE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SYNCH_FRAME
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
break|break;
comment|/* Hub requests */
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ohci_root_ctrl_control: UR_CLEAR_PORT_FEATURE "
literal|"port=%d feature=%d\n"
operator|,
name|index
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|1
operator|||
name|index
operator|>
name|sc
operator|->
name|sc_noport
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|port
operator|=
name|OHCI_RH_PORT_STATUS
argument_list|(
name|index
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_CURRENT_CONNECT_STATUS
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_OVERCURRENT_INDICATOR
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_POWER
case|:
comment|/* Yes, writing to the LOW_SPEED bit clears power. */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_LOW_SPEED
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONNECTION
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_CONNECT_STATUS
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_ENABLE
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_PORT_ENABLED
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_SUSPEND
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_SUSPEND
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_OVERCURRENT_INDICATOR
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_RESET
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_PORT_RESET
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_C_PORT_CONNECTION
case|:
case|case
name|UHF_C_PORT_ENABLE
case|:
case|case
name|UHF_C_PORT_SUSPEND
case|:
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
case|case
name|UHF_C_PORT_RESET
case|:
comment|/* Enable RHSC interrupt if condition is cleared. */
if|if
condition|(
operator|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|>>
literal|16
operator|)
operator|==
literal|0
condition|)
name|ohci_rhsc_able
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|v
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|)
expr_stmt|;
name|hubd
operator|=
name|ohci_hubd
expr_stmt|;
name|hubd
operator|.
name|bNbrPorts
operator|=
name|sc
operator|->
name|sc_noport
expr_stmt|;
name|USETW
argument_list|(
name|hubd
operator|.
name|wHubCharacteristics
argument_list|,
operator|(
name|v
operator|&
name|OHCI_NPS
condition|?
name|UHD_PWR_NO_SWITCH
else|:
name|v
operator|&
name|OHCI_PSM
condition|?
name|UHD_PWR_GANGED
else|:
name|UHD_PWR_INDIVIDUAL
operator|)
comment|/* XXX overcurrent */
argument_list|)
expr_stmt|;
name|hubd
operator|.
name|bPwrOn2PwrGood
operator|=
name|OHCI_GET_POTPGT
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_B
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|l
operator|=
name|sc
operator|->
name|sc_noport
init|;
name|l
operator|>
literal|0
condition|;
name|i
operator|++
operator|,
name|l
operator|-=
literal|8
operator|,
name|v
operator|>>=
literal|8
control|)
name|hubd
operator|.
name|DeviceRemovable
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|v
expr_stmt|;
name|hubd
operator|.
name|bDescLength
operator|=
name|USB_HUB_DESCRIPTOR_SIZE
operator|+
name|i
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|hubd
operator|.
name|bDescLength
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|hubd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|!=
literal|4
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* ? XXX */
name|totlen
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ohci_root_ctrl_transfer: get port status i=%d\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|1
operator|||
name|index
operator|>
name|sc
operator|->
name|sc_noport
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|len
operator|!=
literal|4
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|v
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_PORT_STATUS
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ohci_root_ctrl_transfer: port status=0x%04x\n"
operator|,
name|v
operator|)
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|ps
operator|.
name|wPortStatus
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|ps
operator|.
name|wPortChange
argument_list|,
name|v
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
sizeof|sizeof
name|ps
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ps
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|l
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
name|index
operator|<
literal|1
operator|||
name|index
operator|>
name|sc
operator|->
name|sc_noport
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|port
operator|=
name|OHCI_RH_PORT_STATUS
argument_list|(
name|index
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_PORT_ENABLED
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_SUSPEND
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_RESET
case|:
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ohci_root_ctrl_transfer: reset port %d\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_PORT_ROOT_RESET_DELAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
operator|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|&
name|UPS_RESET
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ohci port %d reset, status = 0x%04x\n"
operator|,
name|index
operator|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_POWER
case|:
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_root_ctrl_transfer: set port power "
literal|"%d\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_PORT_POWER
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
break|break;
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|xfer
operator|->
name|actlen
operator|=
name|totlen
expr_stmt|;
name|err
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|ret
label|:
name|xfer
operator|->
name|status
operator|=
name|err
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a root control request. */
end_comment

begin_function
name|Static
name|void
name|ohci_root_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
comment|/* Nothing to do, all transfers are synchronous. */
block|}
end_function

begin_comment
comment|/* Close the root pipe. */
end_comment

begin_function
name|Static
name|void
name|ohci_root_ctrl_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_root_ctrl_close\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Nothing to do. */
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_root_intr_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Pipe isn't running, start first */
return|return
operator|(
name|ohci_root_intr_start
argument_list|(
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_root_intr_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_pipe_handle
name|pipe
init|=
name|xfer
operator|->
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
name|sc
operator|->
name|sc_intrxfer
operator|=
name|xfer
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a root interrupt request. */
end_comment

begin_function
name|Static
name|void
name|ohci_root_intr_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|==
name|xfer
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_root_intr_abort: remove\n"
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|=
name|NULL
expr_stmt|;
block|}
name|xfer
operator|->
name|status
operator|=
name|USBD_CANCELLED
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close the root pipe. */
end_comment

begin_function
name|Static
name|void
name|ohci_root_intr_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_root_intr_close\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intrxfer
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************/
end_comment

begin_function
name|Static
name|usbd_status
name|ohci_device_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Pipe isn't running, start first */
return|return
operator|(
name|ohci_device_ctrl_start
argument_list|(
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_device_ctrl_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|xfer
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
operator|)
condition|)
block|{
comment|/* XXX panic */
name|printf
argument_list|(
literal|"ohci_device_ctrl_transfer: not a request\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
endif|#
directive|endif
name|err
operator|=
name|ohci_device_request
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
name|ohci_waitintr
argument_list|(
name|sc
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a device control request. */
end_comment

begin_function
name|Static
name|void
name|ohci_device_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_ctrl_abort: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
name|ohci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close a device control pipe. */
end_comment

begin_function
name|Static
name|void
name|ohci_device_ctrl_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_ctrl_close: pipe=%p\n"
operator|,
name|pipe
operator|)
argument_list|)
expr_stmt|;
name|ohci_close_pipe
argument_list|(
name|pipe
argument_list|,
name|sc
operator|->
name|sc_ctrl_head
argument_list|)
expr_stmt|;
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|opipe
operator|->
name|tail
operator|.
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************/
end_comment

begin_function
name|Static
name|void
name|ohci_device_clear_toggle
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|opipe
operator|->
name|sed
operator|->
name|ed
operator|.
name|ed_headp
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_TOGGLECARRY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Static
name|void
name|ohci_noop
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{ }
end_function

begin_function
name|Static
name|usbd_status
name|ohci_device_bulk_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Pipe isn't running, start first */
return|return
operator|(
name|ohci_device_bulk_start
argument_list|(
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_device_bulk_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|opipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|int
name|addr
init|=
name|dev
operator|->
name|address
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|tail
decl_stmt|,
modifier|*
name|tdp
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|,
name|isread
decl_stmt|,
name|endpt
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
condition|)
block|{
comment|/* XXX panic */
name|printf
argument_list|(
literal|"ohci_device_bulk_start: a request\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
endif|#
directive|endif
name|len
operator|=
name|xfer
operator|->
name|length
expr_stmt|;
name|endpt
operator|=
name|xfer
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
name|isread
operator|=
name|UE_GET_DIR
argument_list|(
name|endpt
argument_list|)
operator|==
name|UE_DIR_IN
expr_stmt|;
name|sed
operator|=
name|opipe
operator|->
name|sed
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ohci_device_bulk_start: xfer=%p len=%d isread=%d "
literal|"flags=%d endpt=%d\n"
operator|,
name|xfer
operator|,
name|len
operator|,
name|isread
operator|,
name|xfer
operator|->
name|flags
operator|,
name|endpt
operator|)
argument_list|)
expr_stmt|;
name|opipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|isread
operator|=
name|isread
expr_stmt|;
name|opipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|length
operator|=
name|len
expr_stmt|;
comment|/* Update device address */
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|=
name|htole32
argument_list|(
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_flags
argument_list|)
operator|&
operator|~
name|OHCI_ED_ADDRMASK
operator|)
operator||
name|OHCI_ED_SET_FA
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate a chain of new TDs (including a new tail). */
name|data
operator|=
name|opipe
operator|->
name|tail
operator|.
name|td
expr_stmt|;
name|err
operator|=
name|ohci_alloc_std_chain
argument_list|(
name|opipe
argument_list|,
name|sc
argument_list|,
name|len
argument_list|,
name|isread
argument_list|,
name|xfer
argument_list|,
name|data
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
comment|/* We want interrupt at the end of the transfer. */
name|tail
operator|->
name|td
operator|.
name|td_flags
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_TD_INTR_MASK
argument_list|)
expr_stmt|;
name|tail
operator|->
name|td
operator|.
name|td_flags
operator||=
name|htole32
argument_list|(
name|OHCI_TD_SET_DI
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tail
operator|->
name|flags
operator||=
name|OHCI_CALL_DONE
expr_stmt|;
name|tail
operator|=
name|tail
operator|->
name|nexttd
expr_stmt|;
comment|/* point at sentinel */
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|tail
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|xfer
operator|->
name|hcpriv
operator|=
name|data
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ohci_device_bulk_start: ed_flags=0x%08x td_flags=0x%08x "
literal|"td_cbp=0x%08x td_be=0x%08x\n"
operator|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_flags
argument_list|)
operator|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|data
operator|->
name|td
operator|.
name|td_flags
argument_list|)
operator|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|data
operator|->
name|td
operator|.
name|td_cbp
argument_list|)
operator|,
operator|(
name|int
operator|)
name|le32toh
argument_list|(
name|data
operator|->
name|td
operator|.
name|td_be
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|5
condition|)
block|{
name|ohci_dump_ed
argument_list|(
name|sed
argument_list|)
expr_stmt|;
name|ohci_dump_tds
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Insert ED in schedule */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|tdp
operator|=
name|data
init|;
name|tdp
operator|!=
name|tail
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|nexttd
control|)
block|{
name|tdp
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
block|}
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
operator|=
name|htole32
argument_list|(
name|tail
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|opipe
operator|->
name|tail
operator|.
name|td
operator|=
name|tail
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_BLF
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|&&
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|usb_callout
argument_list|(
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|MS_TO_TICKS
argument_list|(
name|xfer
operator|->
name|timeout
argument_list|)
argument_list|,
name|ohci_timeout
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This goes wrong if we are too slow. */
block|if (ohcidebug> 10) { 		delay(10000); 		DPRINTF(("ohci_device_intr_transfer: status=%x\n", 			 OREAD4(sc, OHCI_COMMAND_STATUS))); 		ohci_dump_ed(sed); 		ohci_dump_tds(data); 	}
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|void
name|ohci_device_bulk_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_bulk_abort: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
name|ohci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close a device bulk pipe.  */
end_comment

begin_function
name|Static
name|void
name|ohci_device_bulk_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_bulk_close: pipe=%p\n"
operator|,
name|pipe
operator|)
argument_list|)
expr_stmt|;
name|ohci_close_pipe
argument_list|(
name|pipe
argument_list|,
name|sc
operator|->
name|sc_bulk_head
argument_list|)
expr_stmt|;
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|opipe
operator|->
name|tail
operator|.
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************/
end_comment

begin_function
name|Static
name|usbd_status
name|ohci_device_intr_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Pipe isn't running, start first */
return|return
operator|(
name|ohci_device_intr_start
argument_list|(
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_device_intr_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|opipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
init|=
name|opipe
operator|->
name|sed
decl_stmt|;
name|ohci_soft_td_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"ohci_device_intr_transfer: xfer=%p len=%d "
literal|"flags=%d priv=%p\n"
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|length
operator|,
name|xfer
operator|->
name|flags
operator|,
name|xfer
operator|->
name|priv
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
condition|)
name|panic
argument_list|(
literal|"ohci_device_intr_transfer: a request"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|xfer
operator|->
name|length
expr_stmt|;
name|data
operator|=
name|opipe
operator|->
name|tail
operator|.
name|td
expr_stmt|;
name|tail
operator|=
name|ohci_alloc_std
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|tail
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
name|OHCI_TD_IN
operator||
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_SET_DI
argument_list|(
literal|1
argument_list|)
operator||
name|OHCI_TD_TOGGLE_CARRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags
operator|&
name|USBD_SHORT_XFER_OK
condition|)
name|data
operator|->
name|td
operator|.
name|td_flags
operator||=
name|htole32
argument_list|(
name|OHCI_TD_R
argument_list|)
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_cbp
operator|=
name|htole32
argument_list|(
name|DMAADDR
argument_list|(
operator|&
name|xfer
operator|->
name|dmabuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|nexttd
operator|=
name|tail
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_nexttd
operator|=
name|htole32
argument_list|(
name|tail
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|data
operator|->
name|td
operator|.
name|td_be
operator|=
name|htole32
argument_list|(
name|le32toh
argument_list|(
name|data
operator|->
name|td
operator|.
name|td_cbp
argument_list|)
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|data
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|data
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|data
operator|->
name|flags
operator|=
name|OHCI_CALL_DONE
operator||
name|OHCI_ADD_LEN
expr_stmt|;
name|xfer
operator|->
name|hcpriv
operator|=
name|data
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|5
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_intr_transfer:\n"
operator|)
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sed
argument_list|)
expr_stmt|;
name|ohci_dump_tds
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Insert ED in schedule */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
operator|=
name|htole32
argument_list|(
name|tail
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|opipe
operator|->
name|tail
operator|.
name|td
operator|=
name|tail
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/*  * This goes horribly wrong, printing thousands of descriptors,  * because false references are followed due to the fact that the  * TD is gone.  */
block|if (ohcidebug> 5) { 		usb_delay_ms(&sc->sc_bus, 5); 		DPRINTF(("ohci_device_intr_transfer: status=%x\n", 			 OREAD4(sc, OHCI_COMMAND_STATUS))); 		ohci_dump_ed(sed); 		ohci_dump_tds(data); 	}
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a device control request. */
end_comment

begin_function
name|Static
name|void
name|ohci_device_intr_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
if|if
condition|(
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|==
name|xfer
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_intr_abort: remove\n"
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|=
name|NULL
expr_stmt|;
block|}
name|ohci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close a device interrupt pipe. */
end_comment

begin_function
name|Static
name|void
name|ohci_device_intr_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|int
name|nslots
init|=
name|opipe
operator|->
name|u
operator|.
name|intr
operator|.
name|nslots
decl_stmt|;
name|int
name|pos
init|=
name|opipe
operator|->
name|u
operator|.
name|intr
operator|.
name|pos
decl_stmt|;
name|int
name|j
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|sed
init|=
name|opipe
operator|->
name|sed
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ohci_device_intr_close: pipe=%p nslots=%d pos=%d\n"
operator|,
name|pipe
operator|,
name|nslots
operator|,
name|pos
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
operator|!=
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
condition|)
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
operator|!=
operator|(
name|le32toh
argument_list|(
name|sed
operator|->
name|ed
operator|.
name|ed_headp
argument_list|)
operator|&
name|OHCI_HEADMASK
operator|)
condition|)
name|panic
argument_list|(
literal|"%s: Intr pipe %p still has TDs queued"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|sc
operator|->
name|sc_eds
index|[
name|pos
index|]
init|;
name|p
operator|&&
name|p
operator|->
name|next
operator|!=
name|sed
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ohci_device_intr_close: ED not found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|next
operator|=
name|sed
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|ed
operator|.
name|ed_nexted
operator|=
name|sed
operator|->
name|ed
operator|.
name|ed_nexted
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nslots
condition|;
name|j
operator|++
control|)
operator|--
name|sc
operator|->
name|sc_bws
index|[
operator|(
name|pos
operator|*
name|nslots
operator|+
name|j
operator|)
operator|%
name|OHCI_NO_INTRS
index|]
expr_stmt|;
name|ohci_free_std
argument_list|(
name|sc
argument_list|,
name|opipe
operator|->
name|tail
operator|.
name|td
argument_list|)
expr_stmt|;
name|ohci_free_sed
argument_list|(
name|sc
argument_list|,
name|opipe
operator|->
name|sed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Static
name|usbd_status
name|ohci_device_setintr
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ohci_pipe
modifier|*
name|opipe
parameter_list|,
name|int
name|ival
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|s
decl_stmt|,
name|best
decl_stmt|;
name|u_int
name|npoll
decl_stmt|,
name|slow
decl_stmt|,
name|shigh
decl_stmt|,
name|nslots
decl_stmt|;
name|u_int
name|bestbw
decl_stmt|,
name|bw
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|hsed
decl_stmt|,
modifier|*
name|sed
init|=
name|opipe
operator|->
name|sed
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_setintr: pipe=%p\n"
operator|,
name|opipe
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ival
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ohci_setintr: 0 interval\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
name|npoll
operator|=
name|OHCI_NO_INTRS
expr_stmt|;
while|while
condition|(
name|npoll
operator|>
name|ival
condition|)
name|npoll
operator|/=
literal|2
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_setintr: ival=%d npoll=%d\n"
operator|,
name|ival
operator|,
name|npoll
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We now know which level in the tree the ED must go into. 	 * Figure out which slot has most bandwidth left over. 	 * Slots to examine: 	 * npoll 	 * 1	0 	 * 2	1 2 	 * 4	3 4 5 6 	 * 8	7 8 9 10 11 12 13 14 	 * N    (N-1) .. (N-1+N-1) 	 */
name|slow
operator|=
name|npoll
operator|-
literal|1
expr_stmt|;
name|shigh
operator|=
name|slow
operator|+
name|npoll
expr_stmt|;
name|nslots
operator|=
name|OHCI_NO_INTRS
operator|/
name|npoll
expr_stmt|;
for|for
control|(
name|best
operator|=
name|i
operator|=
name|slow
operator|,
name|bestbw
operator|=
operator|~
literal|0
init|;
name|i
operator|<
name|shigh
condition|;
name|i
operator|++
control|)
block|{
name|bw
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nslots
condition|;
name|j
operator|++
control|)
name|bw
operator|+=
name|sc
operator|->
name|sc_bws
index|[
operator|(
name|i
operator|*
name|nslots
operator|+
name|j
operator|)
operator|%
name|OHCI_NO_INTRS
index|]
expr_stmt|;
if|if
condition|(
name|bw
operator|<
name|bestbw
condition|)
block|{
name|best
operator|=
name|i
expr_stmt|;
name|bestbw
operator|=
name|bw
expr_stmt|;
block|}
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_setintr: best=%d(%d..%d) bestbw=%d\n"
operator|,
name|best
operator|,
name|slow
operator|,
name|shigh
operator|,
name|bestbw
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|hsed
operator|=
name|sc
operator|->
name|sc_eds
index|[
name|best
index|]
expr_stmt|;
name|sed
operator|->
name|next
operator|=
name|hsed
operator|->
name|next
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_nexted
operator|=
name|hsed
operator|->
name|ed
operator|.
name|ed_nexted
expr_stmt|;
name|hsed
operator|->
name|next
operator|=
name|sed
expr_stmt|;
name|hsed
operator|->
name|ed
operator|.
name|ed_nexted
operator|=
name|htole32
argument_list|(
name|sed
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nslots
condition|;
name|j
operator|++
control|)
operator|++
name|sc
operator|->
name|sc_bws
index|[
operator|(
name|best
operator|*
name|nslots
operator|+
name|j
operator|)
operator|%
name|OHCI_NO_INTRS
index|]
expr_stmt|;
name|opipe
operator|->
name|u
operator|.
name|intr
operator|.
name|nslots
operator|=
name|nslots
expr_stmt|;
name|opipe
operator|->
name|u
operator|.
name|intr
operator|.
name|pos
operator|=
name|best
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ohci_setintr: returns %p\n"
operator|,
name|opipe
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************/
end_comment

begin_function
name|usbd_status
name|ohci_device_isoc_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ohci_device_isoc_transfer: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
comment|/* Put it on our queue, */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* bail out on error, */
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
name|USBD_IN_PROGRESS
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* XXX should check inuse here */
comment|/* insert into schedule, */
name|ohci_device_isoc_enter
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* and start if the pipe wasn't running */
if|if
condition|(
operator|!
name|err
condition|)
name|ohci_device_isoc_start
argument_list|(
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_device_isoc_enter
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|opipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
init|=
name|opipe
operator|->
name|sed
decl_stmt|;
name|struct
name|iso
modifier|*
name|iso
init|=
operator|&
name|opipe
operator|->
name|u
operator|.
name|iso
decl_stmt|;
name|struct
name|ohci_xfer
modifier|*
name|oxfer
init|=
operator|(
expr|struct
name|ohci_xfer
operator|*
operator|)
name|xfer
decl_stmt|;
name|ohci_soft_itd_t
modifier|*
name|sitd
decl_stmt|,
modifier|*
name|nsitd
decl_stmt|;
name|ohci_physaddr_t
name|buf
decl_stmt|,
name|offs
decl_stmt|,
name|noffs
decl_stmt|,
name|bp0
decl_stmt|,
name|tdphys
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ncur
decl_stmt|,
name|nframes
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ohci_device_isoc_enter: used=%d next=%d xfer=%p "
literal|"nframes=%d\n"
operator|,
name|iso
operator|->
name|inuse
operator|,
name|iso
operator|->
name|next
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|nframes
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return;
if|if
condition|(
name|iso
operator|->
name|next
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Not in use yet, schedule it a few frames ahead. */
name|iso
operator|->
name|next
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|sc_hcca
operator|->
name|hcca_frame_number
argument_list|)
operator|+
literal|5
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ohci_device_isoc_enter: start next=%d\n"
operator|,
name|iso
operator|->
name|next
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xfer
operator|->
name|hcpriv
condition|)
block|{
for|for
control|(
name|sitd
operator|=
name|xfer
operator|->
name|hcpriv
init|;
name|sitd
operator|!=
name|NULL
operator|&&
name|sitd
operator|->
name|xfer
operator|==
name|xfer
condition|;
name|sitd
operator|=
name|sitd
operator|->
name|nextitd
control|)
name|ohci_free_sitd
argument_list|(
name|sc
argument_list|,
name|sitd
argument_list|)
expr_stmt|;
comment|/* Free ITDs in prev xfer*/
if|if
condition|(
name|sitd
operator|==
name|NULL
condition|)
block|{
name|sitd
operator|=
name|ohci_alloc_sitd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sitd
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"cant alloc isoc"
argument_list|)
expr_stmt|;
name|opipe
operator|->
name|tail
operator|.
name|itd
operator|=
name|sitd
expr_stmt|;
name|tdphys
operator|=
name|sitd
operator|->
name|physaddr
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* Stop*/
name|sed
operator|->
name|ed
operator|.
name|ed_headp
operator|=
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
operator|=
name|htole32
argument_list|(
name|tdphys
argument_list|)
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* Start.*/
block|}
block|}
name|sitd
operator|=
name|opipe
operator|->
name|tail
operator|.
name|itd
expr_stmt|;
name|buf
operator|=
name|DMAADDR
argument_list|(
operator|&
name|xfer
operator|->
name|dmabuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp0
operator|=
name|OHCI_PAGE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|offs
operator|=
name|OHCI_PAGE_OFFSET
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
name|xfer
operator|->
name|hcpriv
operator|=
name|sitd
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ncur
operator|=
literal|0
init|;
name|i
operator|<
name|nframes
condition|;
name|i
operator|++
operator|,
name|ncur
operator|++
control|)
block|{
name|noffs
operator|=
name|offs
operator|+
name|xfer
operator|->
name|frlengths
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ncur
operator|==
name|OHCI_ITD_NOFFSET
operator|||
comment|/* all offsets used */
name|OHCI_PAGE
argument_list|(
name|buf
operator|+
name|noffs
argument_list|)
operator|>
name|bp0
operator|+
name|OHCI_PAGE_SIZE
condition|)
block|{
comment|/* too many page crossings */
comment|/* Allocate next ITD */
name|nsitd
operator|=
name|ohci_alloc_sitd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsitd
operator|==
name|NULL
condition|)
block|{
comment|/* XXX what now? */
name|printf
argument_list|(
literal|"%s: isoc TD alloc failed\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Fill current ITD */
name|sitd
operator|->
name|itd
operator|.
name|itd_flags
operator|=
name|htole32
argument_list|(
name|OHCI_ITD_NOCC
operator||
name|OHCI_ITD_SET_SF
argument_list|(
name|iso
operator|->
name|next
argument_list|)
operator||
name|OHCI_ITD_SET_DI
argument_list|(
literal|6
argument_list|)
operator||
comment|/* delay intr a little */
name|OHCI_ITD_SET_FC
argument_list|(
name|ncur
argument_list|)
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|itd
operator|.
name|itd_bp0
operator|=
name|htole32
argument_list|(
name|bp0
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|nextitd
operator|=
name|nsitd
expr_stmt|;
name|sitd
operator|->
name|itd
operator|.
name|itd_nextitd
operator|=
name|htole32
argument_list|(
name|nsitd
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|itd
operator|.
name|itd_be
operator|=
name|htole32
argument_list|(
name|bp0
operator|+
name|offs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|sitd
operator|->
name|flags
operator|=
name|OHCI_ITD_ACTIVE
expr_stmt|;
name|sitd
operator|=
name|nsitd
expr_stmt|;
name|iso
operator|->
name|next
operator|=
name|iso
operator|->
name|next
operator|+
name|ncur
expr_stmt|;
name|bp0
operator|=
name|OHCI_PAGE
argument_list|(
name|buf
operator|+
name|offs
argument_list|)
expr_stmt|;
name|ncur
operator|=
literal|0
expr_stmt|;
block|}
name|sitd
operator|->
name|itd
operator|.
name|itd_offset
index|[
name|ncur
index|]
operator|=
name|htole16
argument_list|(
name|OHCI_ITD_MK_OFFS
argument_list|(
name|offs
argument_list|)
argument_list|)
expr_stmt|;
name|offs
operator|=
name|noffs
expr_stmt|;
block|}
name|nsitd
operator|=
name|ohci_alloc_sitd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsitd
operator|==
name|NULL
condition|)
block|{
comment|/* XXX what now? */
name|printf
argument_list|(
literal|"%s: isoc TD alloc failed\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Fixup last used ITD */
name|sitd
operator|->
name|itd
operator|.
name|itd_flags
operator|=
name|htole32
argument_list|(
name|OHCI_ITD_NOCC
operator||
name|OHCI_ITD_SET_SF
argument_list|(
name|iso
operator|->
name|next
argument_list|)
operator||
name|OHCI_ITD_SET_DI
argument_list|(
literal|0
argument_list|)
operator||
name|OHCI_ITD_SET_FC
argument_list|(
name|ncur
argument_list|)
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|itd
operator|.
name|itd_bp0
operator|=
name|htole32
argument_list|(
name|bp0
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|nextitd
operator|=
name|nsitd
expr_stmt|;
name|sitd
operator|->
name|itd
operator|.
name|itd_nextitd
operator|=
name|htole32
argument_list|(
name|nsitd
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|itd
operator|.
name|itd_be
operator|=
name|htole32
argument_list|(
name|bp0
operator|+
name|offs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|sitd
operator|->
name|flags
operator|=
name|OHCI_CALL_DONE
operator||
name|OHCI_ITD_ACTIVE
expr_stmt|;
name|iso
operator|->
name|next
operator|=
name|iso
operator|->
name|next
operator|+
name|ncur
expr_stmt|;
name|iso
operator|->
name|inuse
operator|+=
name|nframes
expr_stmt|;
name|xfer
operator|->
name|actlen
operator|=
name|offs
expr_stmt|;
comment|/* XXX pretend we did it all */
name|xfer
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
name|oxfer
operator|->
name|ohci_xfer_flags
operator||=
name|OHCI_ISOC_DIRTY
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|5
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_isoc_enter: frame=%d\n"
operator|,
name|le32toh
argument_list|(
name|sc
operator|->
name|sc_hcca
operator|->
name|hcca_frame_number
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ohci_dump_itds
argument_list|(
name|xfer
operator|->
name|hcpriv
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sed
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|opipe
operator|->
name|tail
operator|.
name|itd
operator|=
name|nsitd
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_tailp
operator|=
name|htole32
argument_list|(
name|nsitd
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|5
condition|)
block|{
name|delay
argument_list|(
literal|150000
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_isoc_enter: after frame=%d\n"
operator|,
name|le32toh
argument_list|(
name|sc
operator|->
name|sc_hcca
operator|->
name|hcca_frame_number
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ohci_dump_itds
argument_list|(
name|xfer
operator|->
name|hcpriv
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sed
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|usbd_status
name|ohci_device_isoc_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|opipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ohci_device_isoc_start: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|status
operator|!=
name|USBD_IN_PROGRESS
condition|)
name|printf
argument_list|(
literal|"ohci_device_isoc_start: not in progress %p\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX anything to do? */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sed
operator|=
name|opipe
operator|->
name|sed
expr_stmt|;
comment|/*  Turn off ED skip-bit to start processing */
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* ED's ITD list.*/
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_device_isoc_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|opipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
name|ohci_soft_itd_t
modifier|*
name|sitd
decl_stmt|,
modifier|*
name|tmp_sitd
decl_stmt|;
name|int
name|s
decl_stmt|,
name|undone
decl_stmt|,
name|num_sitds
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|opipe
operator|->
name|aborting
operator|=
literal|1
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ohci_device_isoc_abort: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
comment|/* Transfer is already done. */
if|if
condition|(
name|xfer
operator|->
name|status
operator|!=
name|USBD_NOT_STARTED
operator|&&
name|xfer
operator|->
name|status
operator|!=
name|USBD_IN_PROGRESS
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ohci_device_isoc_abort: early return\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Give xfer the requested abort code. */
name|xfer
operator|->
name|status
operator|=
name|USBD_CANCELLED
expr_stmt|;
name|sed
operator|=
name|opipe
operator|->
name|sed
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* force hardware skip */
name|num_sitds
operator|=
literal|0
expr_stmt|;
name|sitd
operator|=
name|xfer
operator|->
name|hcpriv
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sitd
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ohci_device_isoc_abort: hcpriv==0\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
for|for
control|(
init|;
name|sitd
operator|!=
name|NULL
operator|&&
name|sitd
operator|->
name|xfer
operator|==
name|xfer
condition|;
name|sitd
operator|=
name|sitd
operator|->
name|nextitd
control|)
block|{
name|num_sitds
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"abort sets done sitd=%p\n"
operator|,
name|sitd
operator|)
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|isdone
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Each sitd has up to OHCI_ITD_NOFFSET transfers, each can 	 * take a usb 1ms cycle. Conservatively wait for it to drain. 	 * Even with DMA done, it can take awhile for the "batch" 	 * delivery of completion interrupts to occur thru the controller. 	 */
do|do
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|2
operator|*
operator|(
name|num_sitds
operator|*
name|OHCI_ITD_NOFFSET
operator|)
argument_list|)
expr_stmt|;
name|undone
operator|=
literal|0
expr_stmt|;
name|tmp_sitd
operator|=
name|xfer
operator|->
name|hcpriv
expr_stmt|;
for|for
control|(
init|;
name|tmp_sitd
operator|!=
name|NULL
operator|&&
name|tmp_sitd
operator|->
name|xfer
operator|==
name|xfer
condition|;
name|tmp_sitd
operator|=
name|tmp_sitd
operator|->
name|nextitd
control|)
block|{
if|if
condition|(
name|OHCI_CC_NO_ERROR
operator|==
name|OHCI_ITD_GET_CC
argument_list|(
name|le32toh
argument_list|(
name|tmp_sitd
operator|->
name|itd
operator|.
name|itd_flags
argument_list|)
argument_list|)
operator|&&
name|tmp_sitd
operator|->
name|flags
operator|&
name|OHCI_ITD_ACTIVE
operator|&&
operator|(
name|tmp_sitd
operator|->
name|flags
operator|&
name|OHCI_ITD_INTFIN
operator|)
operator|==
literal|0
condition|)
name|undone
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|undone
operator|!=
literal|0
condition|)
do|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
comment|/* Run callback. */
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sitd
operator|!=
name|NULL
condition|)
comment|/* 		 * Only if there is a `next' sitd in next xfer... 		 * unlink this xfer's sitds. 		 */
name|sed
operator|->
name|ed
operator|.
name|ed_headp
operator|=
name|htole32
argument_list|(
name|sitd
operator|->
name|physaddr
argument_list|)
expr_stmt|;
else|else
name|sed
operator|->
name|ed
operator|.
name|ed_headp
operator|=
literal|0
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* remove hardware skip */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_device_isoc_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
comment|/* This null routine corresponds to non-isoc "done()" routines 	 * that free the stds associated with an xfer after a completed 	 * xfer interrupt. However, in the case of isoc transfers, the 	 * sitds associated with the transfer have already been processed 	 * and reallocated for the next iteration by 	 * "ohci_device_isoc_transfer()". 	 * 	 * Routine "usb_transfer_complete()" is called at the end of every 	 * relevant usb interrupt. "usb_transfer_complete()" indirectly 	 * calls 1) "ohci_device_isoc_transfer()" (which keeps pumping the 	 * pipeline by setting up the next transfer iteration) and 2) then  	 * calls "ohci_device_isoc_done()". Isoc transfers have not been  	 * working for the ohci usb because this routine was trashing the 	 * xfer set up for the next iteration (thus, only the first  	 * UGEN_NISOREQS xfers outstanding on an open would work). Perhaps 	 * this could all be re-factored, but that's another pass... 	 */
block|}
end_function

begin_function
name|usbd_status
name|ohci_setup_isoc
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|struct
name|iso
modifier|*
name|iso
init|=
operator|&
name|opipe
operator|->
name|u
operator|.
name|iso
decl_stmt|;
name|int
name|s
decl_stmt|;
name|iso
operator|->
name|next
operator|=
operator|-
literal|1
expr_stmt|;
name|iso
operator|->
name|inuse
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ohci_add_ed
argument_list|(
name|opipe
operator|->
name|sed
argument_list|,
name|sc
operator|->
name|sc_isoc_head
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_device_isoc_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|ohci_pipe
modifier|*
name|opipe
init|=
operator|(
expr|struct
name|ohci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ohci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|ohci_soft_ed_t
modifier|*
name|sed
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ohci_device_isoc_close: pipe=%p\n"
operator|,
name|pipe
operator|)
argument_list|)
expr_stmt|;
name|sed
operator|=
name|opipe
operator|->
name|sed
expr_stmt|;
name|sed
operator|->
name|ed
operator|.
name|ed_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
comment|/* Stop device. */
name|ohci_close_pipe
argument_list|(
name|pipe
argument_list|,
name|sc
operator|->
name|sc_isoc_head
argument_list|)
expr_stmt|;
comment|/* Stop isoc list, free ED.*/
comment|/* up to NISOREQs xfers still outstanding. */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|opipe
operator|->
name|tail
operator|.
name|itd
operator|->
name|isdone
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|ohci_free_sitd
argument_list|(
name|sc
argument_list|,
name|opipe
operator|->
name|tail
operator|.
name|itd
argument_list|)
expr_stmt|;
comment|/* Next `avail free' sitd.*/
block|}
end_function

end_unit

