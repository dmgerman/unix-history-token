begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2006-2008 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  * usb_dev.c - An abstraction layer for creating devices under /dev/...  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USB_GLOBAL_INCLUDE_FILE
end_ifdef

begin_include
include|#
directive|include
include|USB_GLOBAL_INCLUDE_FILE
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|usb_fifo_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_dev.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_generic.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_dynamic.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttycom.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USB_GLOBAL_INCLUDE_FILE */
end_comment

begin_if
if|#
directive|if
name|USB_HAVE_UGEN
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|usb_fifo_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|dev
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB device"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_dev
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|usb_fifo_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug Level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.dev.debug"
argument_list|,
operator|&
name|usb_fifo_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
operator|(
name|__FreeBSD_version
operator|>=
literal|700001
operator|)
operator|||
operator|(
name|__FreeBSD_version
operator|==
literal|0
operator|)
operator|||
expr|\
operator|(
operator|(
name|__FreeBSD_version
operator|>=
literal|600034
operator|)
operator|&&
operator|(
name|__FreeBSD_version
operator|<
literal|700000
operator|)
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|USB_UCRED
value|struct ucred *ucred,
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USB_UCRED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|usb_fifo_open
parameter_list|(
name|struct
name|usb_cdev_privdata
modifier|*
parameter_list|,
name|struct
name|usb_fifo
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_fifo_close
parameter_list|(
name|struct
name|usb_fifo
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_dev_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_dev_init_post
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_dev_uninit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb_fifo_uiomove
parameter_list|(
name|struct
name|usb_fifo
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_fifo_check_methods
parameter_list|(
name|struct
name|usb_fifo_methods
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|usb_fifo
modifier|*
name|usb_fifo_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|usb_endpoint
modifier|*
name|usb_dev_get_ep
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_loc_fill
parameter_list|(
name|struct
name|usb_fs_privdata
modifier|*
parameter_list|,
name|struct
name|usb_cdev_privdata
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_close
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|usb_ref_device
parameter_list|(
name|struct
name|usb_cdev_privdata
modifier|*
parameter_list|,
name|struct
name|usb_cdev_refdata
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|usb_usb_ref_device
parameter_list|(
name|struct
name|usb_cdev_privdata
modifier|*
parameter_list|,
name|struct
name|usb_cdev_refdata
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_unref_device
parameter_list|(
name|struct
name|usb_cdev_privdata
modifier|*
parameter_list|,
name|struct
name|usb_cdev_refdata
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|usb_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|usb_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|usb_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|usb_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|usb_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|usb_static_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_fifo_open_t
name|usb_fifo_dummy_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_fifo_close_t
name|usb_fifo_dummy_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_fifo_ioctl_t
name|usb_fifo_dummy_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_fifo_cmd_t
name|usb_fifo_dummy_cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character device structure used for devices (/dev/ugenX.Y and /dev/uXXX) */
end_comment

begin_decl_stmt
name|struct
name|cdevsw
name|usb_devsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|usb_open
block|,
operator|.
name|d_ioctl
operator|=
name|usb_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"usbdev"
block|,
operator|.
name|d_flags
operator|=
name|D_TRACKCLOSE
block|,
operator|.
name|d_read
operator|=
name|usb_read
block|,
operator|.
name|d_write
operator|=
name|usb_write
block|,
operator|.
name|d_poll
operator|=
name|usb_poll
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|usb_dev
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character device structure used for /dev/usb */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|usb_static_devsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_ioctl
operator|=
name|usb_static_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"usb"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|usb_symlink
argument_list|)
name|usb_sym_head
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|usb_sym_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|usb_ref_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_loc_fill  *  * This is used to fill out a usb_cdev_privdata structure based on the  * device's address as contained in usb_fs_privdata.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_loc_fill
parameter_list|(
name|struct
name|usb_fs_privdata
modifier|*
name|pd
parameter_list|,
name|struct
name|usb_cdev_privdata
modifier|*
name|cpd
parameter_list|)
block|{
name|cpd
operator|->
name|bus_index
operator|=
name|pd
operator|->
name|bus_index
expr_stmt|;
name|cpd
operator|->
name|dev_index
operator|=
name|pd
operator|->
name|dev_index
expr_stmt|;
name|cpd
operator|->
name|ep_addr
operator|=
name|pd
operator|->
name|ep_addr
expr_stmt|;
name|cpd
operator|->
name|fifo_index
operator|=
name|pd
operator|->
name|fifo_index
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_ref_device  *  * This function is used to atomically refer an USB device by its  * device location. If this function returns success the USB device  * will not dissappear until the USB device is unreferenced.  *  * Return values:  *  0: Success, refcount incremented on the given USB device.  *  Else: Failure.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|usb_error_t
name|usb_ref_device
parameter_list|(
name|struct
name|usb_cdev_privdata
modifier|*
name|cpd
parameter_list|,
name|struct
name|usb_cdev_refdata
modifier|*
name|crd
parameter_list|,
name|int
name|need_uref
parameter_list|)
block|{
name|struct
name|usb_fifo
modifier|*
modifier|*
name|ppf
decl_stmt|;
name|struct
name|usb_fifo
modifier|*
name|f
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"cpd=%p need uref=%d\n"
argument_list|,
name|cpd
argument_list|,
name|need_uref
argument_list|)
expr_stmt|;
comment|/* clear all refs */
name|memset
argument_list|(
name|crd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|crd
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
name|cpd
operator|->
name|bus
operator|=
name|devclass_get_softc
argument_list|(
name|usb_devclass_ptr
argument_list|,
name|cpd
operator|->
name|bus_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpd
operator|->
name|bus
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"no bus at %u\n"
argument_list|,
name|cpd
operator|->
name|bus_index
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|cpd
operator|->
name|udev
operator|=
name|cpd
operator|->
name|bus
operator|->
name|devices
index|[
name|cpd
operator|->
name|dev_index
index|]
expr_stmt|;
if|if
condition|(
name|cpd
operator|->
name|udev
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"no device at %u\n"
argument_list|,
name|cpd
operator|->
name|dev_index
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|cpd
operator|->
name|udev
operator|->
name|state
operator|==
name|USB_STATE_DETACHED
operator|&&
operator|(
name|need_uref
operator|!=
literal|2
operator|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"device is detached\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|cpd
operator|->
name|udev
operator|->
name|refcount
operator|==
name|USB_DEV_REF_MAX
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"no dev ref\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|need_uref
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"ref udev - needed\n"
argument_list|)
expr_stmt|;
name|cpd
operator|->
name|udev
operator|->
name|refcount
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
comment|/* 		 * We need to grab the enumeration SX-lock before 		 * grabbing the FIFO refs to avoid deadlock at detach! 		 */
name|crd
operator|->
name|do_unlock
operator|=
name|usbd_enum_lock
argument_list|(
name|cpd
operator|->
name|udev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
comment|/*  		 * Set "is_uref" after grabbing the default SX lock 		 */
name|crd
operator|->
name|is_uref
operator|=
literal|1
expr_stmt|;
block|}
comment|/* check if we are doing an open */
if|if
condition|(
name|cpd
operator|->
name|fflags
operator|==
literal|0
condition|)
block|{
comment|/* use zero defaults */
block|}
else|else
block|{
comment|/* check for write */
if|if
condition|(
name|cpd
operator|->
name|fflags
operator|&
name|FWRITE
condition|)
block|{
name|ppf
operator|=
name|cpd
operator|->
name|udev
operator|->
name|fifo
expr_stmt|;
name|f
operator|=
name|ppf
index|[
name|cpd
operator|->
name|fifo_index
operator|+
name|USB_FIFO_TX
index|]
expr_stmt|;
name|crd
operator|->
name|txfifo
operator|=
name|f
expr_stmt|;
name|crd
operator|->
name|is_write
operator|=
literal|1
expr_stmt|;
comment|/* ref */
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|f
operator|->
name|refcount
operator|==
name|USB_FIFO_REF_MAX
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|f
operator|->
name|curr_cpd
operator|!=
name|cpd
condition|)
goto|goto
name|error
goto|;
comment|/* check if USB-FS is active */
if|if
condition|(
name|f
operator|->
name|fs_ep_max
operator|!=
literal|0
condition|)
block|{
name|crd
operator|->
name|is_usbfs
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* check for read */
if|if
condition|(
name|cpd
operator|->
name|fflags
operator|&
name|FREAD
condition|)
block|{
name|ppf
operator|=
name|cpd
operator|->
name|udev
operator|->
name|fifo
expr_stmt|;
name|f
operator|=
name|ppf
index|[
name|cpd
operator|->
name|fifo_index
operator|+
name|USB_FIFO_RX
index|]
expr_stmt|;
name|crd
operator|->
name|rxfifo
operator|=
name|f
expr_stmt|;
name|crd
operator|->
name|is_read
operator|=
literal|1
expr_stmt|;
comment|/* ref */
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|f
operator|->
name|refcount
operator|==
name|USB_FIFO_REF_MAX
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|f
operator|->
name|curr_cpd
operator|!=
name|cpd
condition|)
goto|goto
name|error
goto|;
comment|/* check if USB-FS is active */
if|if
condition|(
name|f
operator|->
name|fs_ep_max
operator|!=
literal|0
condition|)
block|{
name|crd
operator|->
name|is_usbfs
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* when everything is OK we increment the refcounts */
if|if
condition|(
name|crd
operator|->
name|is_write
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"ref write\n"
argument_list|)
expr_stmt|;
name|crd
operator|->
name|txfifo
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|crd
operator|->
name|is_read
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"ref read\n"
argument_list|)
expr_stmt|;
name|crd
operator|->
name|rxfifo
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
if|if
condition|(
name|crd
operator|->
name|do_unlock
condition|)
name|usbd_enum_unlock
argument_list|(
name|cpd
operator|->
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|crd
operator|->
name|is_uref
condition|)
block|{
if|if
condition|(
operator|--
operator|(
name|cpd
operator|->
name|udev
operator|->
name|refcount
operator|)
operator|==
literal|0
condition|)
block|{
name|cv_signal
argument_list|(
operator|&
name|cpd
operator|->
name|udev
operator|->
name|ref_cv
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"fail\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_usb_ref_device  *  * This function is used to upgrade an USB reference to include the  * USB device reference on a USB location.  *  * Return values:  *  0: Success, refcount incremented on the given USB device.  *  Else: Failure.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|usb_error_t
name|usb_usb_ref_device
parameter_list|(
name|struct
name|usb_cdev_privdata
modifier|*
name|cpd
parameter_list|,
name|struct
name|usb_cdev_refdata
modifier|*
name|crd
parameter_list|)
block|{
comment|/* 	 * Check if we already got an USB reference on this location: 	 */
if|if
condition|(
name|crd
operator|->
name|is_uref
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
comment|/* 	 * To avoid deadlock at detach we need to drop the FIFO ref 	 * and re-acquire a new ref! 	 */
name|usb_unref_device
argument_list|(
name|cpd
argument_list|,
name|crd
argument_list|)
expr_stmt|;
return|return
operator|(
name|usb_ref_device
argument_list|(
name|cpd
argument_list|,
name|crd
argument_list|,
literal|1
comment|/* need uref */
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_unref_device  *  * This function will release the reference count by one unit for the  * given USB device.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_unref_device
parameter_list|(
name|struct
name|usb_cdev_privdata
modifier|*
name|cpd
parameter_list|,
name|struct
name|usb_cdev_refdata
modifier|*
name|crd
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"cpd=%p is_uref=%d\n"
argument_list|,
name|cpd
argument_list|,
name|crd
operator|->
name|is_uref
argument_list|)
expr_stmt|;
if|if
condition|(
name|crd
operator|->
name|do_unlock
condition|)
name|usbd_enum_unlock
argument_list|(
name|cpd
operator|->
name|udev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|crd
operator|->
name|is_read
condition|)
block|{
if|if
condition|(
operator|--
operator|(
name|crd
operator|->
name|rxfifo
operator|->
name|refcount
operator|)
operator|==
literal|0
condition|)
block|{
name|cv_signal
argument_list|(
operator|&
name|crd
operator|->
name|rxfifo
operator|->
name|cv_drain
argument_list|)
expr_stmt|;
block|}
name|crd
operator|->
name|is_read
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|crd
operator|->
name|is_write
condition|)
block|{
if|if
condition|(
operator|--
operator|(
name|crd
operator|->
name|txfifo
operator|->
name|refcount
operator|)
operator|==
literal|0
condition|)
block|{
name|cv_signal
argument_list|(
operator|&
name|crd
operator|->
name|txfifo
operator|->
name|cv_drain
argument_list|)
expr_stmt|;
block|}
name|crd
operator|->
name|is_write
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|crd
operator|->
name|is_uref
condition|)
block|{
if|if
condition|(
operator|--
operator|(
name|cpd
operator|->
name|udev
operator|->
name|refcount
operator|)
operator|==
literal|0
condition|)
block|{
name|cv_signal
argument_list|(
operator|&
name|cpd
operator|->
name|udev
operator|->
name|ref_cv
argument_list|)
expr_stmt|;
block|}
name|crd
operator|->
name|is_uref
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|usb_fifo
modifier|*
name|usb_fifo_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|usb_fifo
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|cv_init
argument_list|(
operator|&
name|f
operator|->
name|cv_io
argument_list|,
literal|"FIFO-IO"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|f
operator|->
name|cv_drain
argument_list|,
literal|"FIFO-DRAIN"
argument_list|)
expr_stmt|;
name|f
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_fifo_create  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb_fifo_create
parameter_list|(
name|struct
name|usb_cdev_privdata
modifier|*
name|cpd
parameter_list|,
name|struct
name|usb_cdev_refdata
modifier|*
name|crd
parameter_list|)
block|{
name|struct
name|usb_device
modifier|*
name|udev
init|=
name|cpd
operator|->
name|udev
decl_stmt|;
name|struct
name|usb_fifo
modifier|*
name|f
decl_stmt|;
name|struct
name|usb_endpoint
modifier|*
name|ep
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|uint8_t
name|is_tx
decl_stmt|;
name|uint8_t
name|is_rx
decl_stmt|;
name|uint8_t
name|no_null
decl_stmt|;
name|uint8_t
name|is_busy
decl_stmt|;
name|int
name|e
init|=
name|cpd
operator|->
name|ep_addr
decl_stmt|;
name|is_tx
operator|=
operator|(
name|cpd
operator|->
name|fflags
operator|&
name|FWRITE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|is_rx
operator|=
operator|(
name|cpd
operator|->
name|fflags
operator|&
name|FREAD
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|no_null
operator|=
literal|1
expr_stmt|;
name|is_busy
operator|=
literal|0
expr_stmt|;
comment|/* Preallocated FIFO */
if|if
condition|(
name|e
operator|<
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"Preallocated FIFO\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_tx
condition|)
block|{
name|f
operator|=
name|udev
operator|->
name|fifo
index|[
name|cpd
operator|->
name|fifo_index
operator|+
name|USB_FIFO_TX
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|crd
operator|->
name|txfifo
operator|=
name|f
expr_stmt|;
block|}
if|if
condition|(
name|is_rx
condition|)
block|{
name|f
operator|=
name|udev
operator|->
name|fifo
index|[
name|cpd
operator|->
name|fifo_index
operator|+
name|USB_FIFO_RX
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|crd
operator|->
name|rxfifo
operator|=
name|f
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|e
operator|>=
literal|0
operator|&&
name|e
operator|<=
literal|15
argument_list|,
operator|(
literal|"endpoint %d out of range"
operator|,
name|e
operator|)
argument_list|)
expr_stmt|;
comment|/* search for a free FIFO slot */
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"Endpoint device, searching for 0x%02x\n"
argument_list|,
name|e
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
condition|;
name|n
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|n
operator|==
name|USB_FIFO_MAX
condition|)
block|{
if|if
condition|(
name|no_null
condition|)
block|{
name|no_null
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* end of FIFOs reached */
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"out of FIFOs\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
comment|/* Check for TX FIFO */
if|if
condition|(
name|is_tx
condition|)
block|{
name|f
operator|=
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_TX
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|dev_ep_index
operator|!=
name|e
condition|)
block|{
comment|/* wrong endpoint index */
continue|continue;
block|}
if|if
condition|(
name|f
operator|->
name|curr_cpd
operator|!=
name|NULL
condition|)
block|{
comment|/* FIFO is opened */
name|is_busy
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|no_null
condition|)
block|{
continue|continue;
block|}
block|}
comment|/* Check for RX FIFO */
if|if
condition|(
name|is_rx
condition|)
block|{
name|f
operator|=
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_RX
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|dev_ep_index
operator|!=
name|e
condition|)
block|{
comment|/* wrong endpoint index */
continue|continue;
block|}
if|if
condition|(
name|f
operator|->
name|curr_cpd
operator|!=
name|NULL
condition|)
block|{
comment|/* FIFO is opened */
name|is_busy
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|no_null
condition|)
block|{
continue|continue;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|no_null
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|>=
operator|(
name|USB_EP_MAX
operator|/
literal|2
operator|)
condition|)
block|{
comment|/* we don't create any endpoints in this range */
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"ep out of range\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|is_busy
condition|?
name|EBUSY
else|:
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|e
operator|!=
literal|0
operator|)
operator|&&
name|is_busy
condition|)
block|{
comment|/* 		 * Only the default control endpoint is allowed to be 		 * opened multiple times! 		 */
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"busy\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Check TX FIFO */
if|if
condition|(
name|is_tx
operator|&&
operator|(
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_TX
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
name|ep
operator|=
name|usb_dev_get_ep
argument_list|(
name|udev
argument_list|,
name|e
argument_list|,
name|USB_FIFO_TX
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dev_get_endpoint(%d, 0x%x)\n"
argument_list|,
name|e
argument_list|,
name|USB_FIFO_TX
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dev_get_endpoint returned NULL\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|f
operator|=
name|usb_fifo_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"could not alloc tx fifo\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* update some fields */
name|f
operator|->
name|fifo_index
operator|=
name|n
operator|+
name|USB_FIFO_TX
expr_stmt|;
name|f
operator|->
name|dev_ep_index
operator|=
name|e
expr_stmt|;
name|f
operator|->
name|priv_mtx
operator|=
operator|&
name|udev
operator|->
name|device_mtx
expr_stmt|;
name|f
operator|->
name|priv_sc0
operator|=
name|ep
expr_stmt|;
name|f
operator|->
name|methods
operator|=
operator|&
name|usb_ugen_methods
expr_stmt|;
name|f
operator|->
name|iface_index
operator|=
name|ep
operator|->
name|iface_index
expr_stmt|;
name|f
operator|->
name|udev
operator|=
name|udev
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_TX
index|]
operator|=
name|f
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
block|}
comment|/* Check RX FIFO */
if|if
condition|(
name|is_rx
operator|&&
operator|(
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_RX
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
name|ep
operator|=
name|usb_dev_get_ep
argument_list|(
name|udev
argument_list|,
name|e
argument_list|,
name|USB_FIFO_RX
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dev_get_endpoint(%d, 0x%x)\n"
argument_list|,
name|e
argument_list|,
name|USB_FIFO_RX
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dev_get_endpoint returned NULL\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|f
operator|=
name|usb_fifo_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"could not alloc rx fifo\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* update some fields */
name|f
operator|->
name|fifo_index
operator|=
name|n
operator|+
name|USB_FIFO_RX
expr_stmt|;
name|f
operator|->
name|dev_ep_index
operator|=
name|e
expr_stmt|;
name|f
operator|->
name|priv_mtx
operator|=
operator|&
name|udev
operator|->
name|device_mtx
expr_stmt|;
name|f
operator|->
name|priv_sc0
operator|=
name|ep
expr_stmt|;
name|f
operator|->
name|methods
operator|=
operator|&
name|usb_ugen_methods
expr_stmt|;
name|f
operator|->
name|iface_index
operator|=
name|ep
operator|->
name|iface_index
expr_stmt|;
name|f
operator|->
name|udev
operator|=
name|udev
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_RX
index|]
operator|=
name|f
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_tx
condition|)
block|{
name|crd
operator|->
name|txfifo
operator|=
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_TX
index|]
expr_stmt|;
block|}
if|if
condition|(
name|is_rx
condition|)
block|{
name|crd
operator|->
name|rxfifo
operator|=
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_RX
index|]
expr_stmt|;
block|}
comment|/* fill out fifo index */
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"fifo index = %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cpd
operator|->
name|fifo_index
operator|=
name|n
expr_stmt|;
comment|/* complete */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usb_fifo_free
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|)
block|{
name|uint8_t
name|n
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* be NULL safe */
return|return;
block|}
comment|/* destroy symlink devices, if any */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
literal|2
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|f
operator|->
name|symlink
index|[
name|n
index|]
condition|)
block|{
name|usb_free_symlink
argument_list|(
name|f
operator|->
name|symlink
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|f
operator|->
name|symlink
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
comment|/* delink ourselves to stop calls from userland */
if|if
condition|(
operator|(
name|f
operator|->
name|fifo_index
operator|<
name|USB_FIFO_MAX
operator|)
operator|&&
operator|(
name|f
operator|->
name|udev
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|f
operator|->
name|udev
operator|->
name|fifo
index|[
name|f
operator|->
name|fifo_index
index|]
operator|==
name|f
operator|)
condition|)
block|{
name|f
operator|->
name|udev
operator|->
name|fifo
index|[
name|f
operator|->
name|fifo_index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"USB FIFO %p has not been linked\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* decrease refcount */
name|f
operator|->
name|refcount
operator|--
expr_stmt|;
comment|/* prevent any write flush */
name|f
operator|->
name|flag_iserror
operator|=
literal|1
expr_stmt|;
comment|/* need to wait until all callers have exited */
while|while
condition|(
name|f
operator|->
name|refcount
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
comment|/* avoid LOR */
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
comment|/* get I/O thread out of any sleep state */
if|if
condition|(
name|f
operator|->
name|flag_sleeping
condition|)
block|{
name|f
operator|->
name|flag_sleeping
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|f
operator|->
name|cv_io
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Check if the "f->refcount" variable reached zero 		 * during the unlocked time before entering wait: 		 */
if|if
condition|(
name|f
operator|->
name|refcount
operator|==
literal|0
condition|)
break|break;
comment|/* wait for sync */
name|cv_wait
argument_list|(
operator|&
name|f
operator|->
name|cv_drain
argument_list|,
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
comment|/* take care of closing the device here, if any */
name|usb_fifo_close
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|f
operator|->
name|cv_io
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|f
operator|->
name|cv_drain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|usb_endpoint
modifier|*
name|usb_dev_get_ep
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|ep_index
parameter_list|,
name|uint8_t
name|dir
parameter_list|)
block|{
name|struct
name|usb_endpoint
modifier|*
name|ep
decl_stmt|;
name|uint8_t
name|ep_dir
decl_stmt|;
if|if
condition|(
name|ep_index
operator|==
literal|0
condition|)
block|{
name|ep
operator|=
operator|&
name|udev
operator|->
name|ctrl_ep
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dir
operator|==
name|USB_FIFO_RX
condition|)
block|{
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_HOST
condition|)
block|{
name|ep_dir
operator|=
name|UE_DIR_IN
expr_stmt|;
block|}
else|else
block|{
name|ep_dir
operator|=
name|UE_DIR_OUT
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_HOST
condition|)
block|{
name|ep_dir
operator|=
name|UE_DIR_OUT
expr_stmt|;
block|}
else|else
block|{
name|ep_dir
operator|=
name|UE_DIR_IN
expr_stmt|;
block|}
block|}
name|ep
operator|=
name|usbd_get_ep_by_addr
argument_list|(
name|udev
argument_list|,
name|ep_index
operator||
name|ep_dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
block|{
comment|/* if the endpoint does not exist then return */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|ep
operator|->
name|edesc
operator|==
name|NULL
condition|)
block|{
comment|/* invalid endpoint */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|ep
operator|)
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_fifo_open  *  * Returns:  * 0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb_fifo_open
parameter_list|(
name|struct
name|usb_cdev_privdata
modifier|*
name|cpd
parameter_list|,
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* no FIFO there */
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"no FIFO\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* remove FWRITE and FREAD flags */
name|fflags
operator|&=
operator|~
operator|(
name|FWRITE
operator||
name|FREAD
operator|)
expr_stmt|;
comment|/* set correct file flags */
if|if
condition|(
operator|(
name|f
operator|->
name|fifo_index
operator|&
literal|1
operator|)
operator|==
name|USB_FIFO_TX
condition|)
block|{
name|fflags
operator||=
name|FWRITE
expr_stmt|;
block|}
else|else
block|{
name|fflags
operator||=
name|FREAD
expr_stmt|;
block|}
comment|/* check if we are already opened */
comment|/* we don't need any locks when checking this variable */
if|if
condition|(
name|f
operator|->
name|curr_cpd
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* reset short flag before open */
name|f
operator|->
name|flag_short
operator|=
literal|0
expr_stmt|;
comment|/* call open method */
name|err
operator|=
call|(
name|f
operator|->
name|methods
operator|->
name|f_open
call|)
argument_list|(
name|f
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
comment|/* reset sleep flag */
name|f
operator|->
name|flag_sleeping
operator|=
literal|0
expr_stmt|;
comment|/* reset error flag */
name|f
operator|->
name|flag_iserror
operator|=
literal|0
expr_stmt|;
comment|/* reset complete flag */
name|f
operator|->
name|flag_iscomplete
operator|=
literal|0
expr_stmt|;
comment|/* reset select flag */
name|f
operator|->
name|flag_isselect
operator|=
literal|0
expr_stmt|;
comment|/* reset flushing flag */
name|f
operator|->
name|flag_flushing
operator|=
literal|0
expr_stmt|;
comment|/* reset ASYNC proc flag */
name|f
operator|->
name|async_p
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
comment|/* flag the fifo as opened to prevent others */
name|f
operator|->
name|curr_cpd
operator|=
name|cpd
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
comment|/* reset queue */
name|usb_fifo_reset
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
name|done
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_fifo_reset  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_fifo_reset
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|usb_mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|/* reset have fragment flag */
name|f
operator|->
name|flag_have_fragment
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_fifo_close  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_fifo_close
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* check if we are not opened */
if|if
condition|(
name|f
operator|->
name|curr_cpd
operator|==
name|NULL
condition|)
block|{
comment|/* nothing to do - already closed */
return|return;
block|}
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
comment|/* clear current cdev private data pointer */
name|f
operator|->
name|curr_cpd
operator|=
name|NULL
expr_stmt|;
comment|/* check if we are selected */
if|if
condition|(
name|f
operator|->
name|flag_isselect
condition|)
block|{
name|selwakeup
argument_list|(
operator|&
name|f
operator|->
name|selinfo
argument_list|)
expr_stmt|;
name|f
operator|->
name|flag_isselect
operator|=
literal|0
expr_stmt|;
block|}
comment|/* check if a thread wants SIGIO */
if|if
condition|(
name|f
operator|->
name|async_p
operator|!=
name|NULL
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|f
operator|->
name|async_p
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|f
operator|->
name|async_p
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|f
operator|->
name|async_p
argument_list|)
expr_stmt|;
name|f
operator|->
name|async_p
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* remove FWRITE and FREAD flags */
name|fflags
operator|&=
operator|~
operator|(
name|FWRITE
operator||
name|FREAD
operator|)
expr_stmt|;
comment|/* flush written data, if any */
if|if
condition|(
operator|(
name|f
operator|->
name|fifo_index
operator|&
literal|1
operator|)
operator|==
name|USB_FIFO_TX
condition|)
block|{
if|if
condition|(
operator|!
name|f
operator|->
name|flag_iserror
condition|)
block|{
comment|/* set flushing flag */
name|f
operator|->
name|flag_flushing
operator|=
literal|1
expr_stmt|;
comment|/* get the last packet in */
if|if
condition|(
name|f
operator|->
name|flag_have_fragment
condition|)
block|{
name|struct
name|usb_mbuf
modifier|*
name|m
decl_stmt|;
name|f
operator|->
name|flag_have_fragment
operator|=
literal|0
expr_stmt|;
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* start write transfer, if not already started */
call|(
name|f
operator|->
name|methods
operator|->
name|f_start_write
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* check if flushed already */
while|while
condition|(
name|f
operator|->
name|flag_flushing
operator|&&
operator|(
operator|!
name|f
operator|->
name|flag_iserror
operator|)
condition|)
block|{
comment|/* wait until all data has been written */
name|f
operator|->
name|flag_sleeping
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|f
operator|->
name|cv_io
argument_list|,
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"signal received\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|fflags
operator||=
name|FWRITE
expr_stmt|;
comment|/* stop write transfer, if not already stopped */
call|(
name|f
operator|->
name|methods
operator|->
name|f_stop_write
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fflags
operator||=
name|FREAD
expr_stmt|;
comment|/* stop write transfer, if not already stopped */
call|(
name|f
operator|->
name|methods
operator|->
name|f_stop_read
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* check if we are sleeping */
if|if
condition|(
name|f
operator|->
name|flag_sleeping
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"Sleeping at close!\n"
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
comment|/* call close method */
call|(
name|f
operator|->
name|methods
operator|->
name|f_close
call|)
argument_list|(
name|f
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"closed\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_open - cdev callback  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb_fs_privdata
modifier|*
name|pd
init|=
operator|(
expr|struct
name|usb_fs_privdata
operator|*
operator|)
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|struct
name|usb_cdev_refdata
name|refs
decl_stmt|;
name|struct
name|usb_cdev_privdata
modifier|*
name|cpd
decl_stmt|;
name|int
name|err
decl_stmt|,
name|ep
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"%s fflags=0x%08x\n"
argument_list|,
name|devtoname
argument_list|(
name|dev
argument_list|)
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|fflags
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
argument_list|,
operator|(
literal|"invalid open flags"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|fflags
operator|&
name|FREAD
operator|)
operator|&&
operator|!
operator|(
name|pd
operator|->
name|mode
operator|&
name|FREAD
operator|)
operator|)
operator|||
operator|(
operator|(
name|fflags
operator|&
name|FWRITE
operator|)
operator|&&
operator|!
operator|(
name|pd
operator|->
name|mode
operator|&
name|FWRITE
operator|)
operator|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"access mode not supported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|cpd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cpd
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ep
operator|=
name|cpd
operator|->
name|ep_addr
operator|=
name|pd
operator|->
name|ep_addr
expr_stmt|;
name|usb_loc_fill
argument_list|(
name|pd
argument_list|,
name|cpd
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_ref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"cannot ref device\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cpd
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|cpd
operator|->
name|fflags
operator|=
name|fflags
expr_stmt|;
comment|/* access mode for open lifetime */
comment|/* create FIFOs, if any */
name|err
operator|=
name|usb_fifo_create
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
comment|/* check for error */
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"cannot create fifo\n"
argument_list|)
expr_stmt|;
name|usb_unref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cpd
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
name|err
operator|=
name|usb_fifo_open
argument_list|(
name|cpd
argument_list|,
name|refs
operator|.
name|rxfifo
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"read open failed\n"
argument_list|)
expr_stmt|;
name|usb_unref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cpd
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fflags
operator|&
name|FWRITE
condition|)
block|{
name|err
operator|=
name|usb_fifo_open
argument_list|(
name|cpd
argument_list|,
name|refs
operator|.
name|txfifo
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"write open failed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
name|usb_fifo_close
argument_list|(
name|refs
operator|.
name|rxfifo
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
block|}
name|usb_unref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cpd
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
name|usb_unref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|devfs_set_cdevpriv
argument_list|(
name|cpd
argument_list|,
name|usb_close
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_close - cdev callback  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_close
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|usb_cdev_refdata
name|refs
decl_stmt|;
name|struct
name|usb_cdev_privdata
modifier|*
name|cpd
init|=
name|arg
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"cpd=%p\n"
argument_list|,
name|cpd
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_ref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|,
literal|2
comment|/* uref and allow detached state */
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Cannot grab USB reference when "
literal|"closing USB file handle\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|cpd
operator|->
name|fflags
operator|&
name|FREAD
condition|)
block|{
name|usb_fifo_close
argument_list|(
name|refs
operator|.
name|rxfifo
argument_list|,
name|cpd
operator|->
name|fflags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cpd
operator|->
name|fflags
operator|&
name|FWRITE
condition|)
block|{
name|usb_fifo_close
argument_list|(
name|refs
operator|.
name|txfifo
argument_list|,
name|cpd
operator|->
name|fflags
argument_list|)
expr_stmt|;
block|}
name|usb_unref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|cpd
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_dev_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|usb_ref_lock
argument_list|,
literal|"USB ref mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|usb_sym_lock
argument_list|,
literal|"USB sym mutex"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|usb_sym_head
argument_list|)
expr_stmt|;
comment|/* check the UGEN methods */
name|usb_fifo_check_methods
argument_list|(
operator|&
name|usb_ugen_methods
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|usb_dev_init
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|usb_dev_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|usb_dev_init_post
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* 	 * Create /dev/usb - this is needed for usbconfig(8), which 	 * needs a well-known device name to access. 	 */
name|usb_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|usb_static_devsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0644
argument_list|,
name|USB_DEVICE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb_dev
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Could not create usb bus device\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|usb_dev_init_post
argument_list|,
name|SI_SUB_KICK_SCHEDULER
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|usb_dev_init_post
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|usb_dev_uninit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|usb_dev
operator|!=
name|NULL
condition|)
block|{
name|destroy_dev
argument_list|(
name|usb_dev
argument_list|)
expr_stmt|;
name|usb_dev
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|usb_sym_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|usb_dev_uninit
argument_list|,
name|SI_SUB_KICK_SCHEDULER
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|usb_dev_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|usb_ioctl_f_sub
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIODTYPE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* character device */
break|break;
case|case
name|FIONBIO
case|:
comment|/* handled by upper FS layer */
break|break;
case|case
name|FIOASYNC
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|async_p
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|f
operator|->
name|async_p
operator|=
name|USB_TD_GET_PROC
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|->
name|async_p
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
comment|/* XXX this is not the most general solution */
case|case
name|TIOCSPGRP
case|:
if|if
condition|(
name|f
operator|->
name|async_p
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|!=
name|USB_PROC_GET_GID
argument_list|(
name|f
operator|->
name|async_p
argument_list|)
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
break|break;
default|default:
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"cmd 0x%lx = %d\n"
argument_list|,
name|cmd
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_ioctl - cdev callback  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb_cdev_refdata
name|refs
decl_stmt|;
name|struct
name|usb_cdev_privdata
modifier|*
name|cpd
decl_stmt|;
name|struct
name|usb_fifo
modifier|*
name|f
decl_stmt|;
name|int
name|fflags
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"cmd=0x%lx\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|err
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/*  	 * Performance optimisation: We try to check for IOCTL's that 	 * don't need the USB reference first. Then we grab the USB 	 * reference if we need it! 	 */
name|err
operator|=
name|usb_ref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|,
literal|0
comment|/* no uref */
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|fflags
operator|=
name|cpd
operator|->
name|fflags
expr_stmt|;
name|f
operator|=
name|NULL
expr_stmt|;
comment|/* set default value */
name|err
operator|=
name|ENOIOCTL
expr_stmt|;
comment|/* set default value */
if|if
condition|(
name|fflags
operator|&
name|FWRITE
condition|)
block|{
name|f
operator|=
name|refs
operator|.
name|txfifo
expr_stmt|;
name|err
operator|=
name|usb_ioctl_f_sub
argument_list|(
name|f
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
name|f
operator|=
name|refs
operator|.
name|rxfifo
expr_stmt|;
name|err
operator|=
name|usb_ioctl_f_sub
argument_list|(
name|f
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|f
operator|!=
name|NULL
argument_list|,
operator|(
literal|"fifo not found"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ENOIOCTL
condition|)
goto|goto
name|done
goto|;
name|err
operator|=
call|(
name|f
operator|->
name|methods
operator|->
name|f_ioctl
call|)
argument_list|(
name|f
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"f_ioctl cmd 0x%lx = %d\n"
argument_list|,
name|cmd
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ENOIOCTL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|usb_usb_ref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|err
operator|=
call|(
name|f
operator|->
name|methods
operator|->
name|f_ioctl_post
call|)
argument_list|(
name|f
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"f_ioctl_post cmd 0x%lx = %d\n"
argument_list|,
name|cmd
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOIOCTL
condition|)
name|err
operator|=
name|ENOTTY
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|done
goto|;
comment|/* Wait for re-enumeration, if any */
while|while
condition|(
name|f
operator|->
name|udev
operator|->
name|re_enumerate_wait
operator|!=
name|USB_RE_ENUM_DONE
condition|)
block|{
name|usb_unref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|hz
operator|/
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb_ref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|,
literal|1
comment|/* need uref */
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|usb_unref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|usb_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb_cdev_refdata
name|refs
decl_stmt|;
name|struct
name|usb_cdev_privdata
modifier|*
name|cpd
decl_stmt|;
name|struct
name|usb_fifo
modifier|*
name|f
decl_stmt|;
name|struct
name|usb_mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|fflags
decl_stmt|,
name|revents
decl_stmt|;
if|if
condition|(
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cpd
argument_list|)
operator|!=
literal|0
operator|||
name|usb_ref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|events
operator|&
operator|(
name|POLLHUP
operator||
name|POLLIN
operator||
name|POLLRDNORM
operator||
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
return|;
name|fflags
operator|=
name|cpd
operator|->
name|fflags
expr_stmt|;
comment|/* Figure out who needs service */
name|revents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
operator|&&
operator|(
name|fflags
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|f
operator|=
name|refs
operator|.
name|txfifo
expr_stmt|;
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refs
operator|.
name|is_usbfs
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|flag_iserror
condition|)
block|{
comment|/* we got an error */
name|m
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|f
operator|->
name|queue_data
operator|==
name|NULL
condition|)
block|{
comment|/* 					 * start write transfer, if not 					 * already started 					 */
call|(
name|f
operator|->
name|methods
operator|->
name|f_start_write
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* check if any packets are available */
name|USB_IF_POLL
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|f
operator|->
name|flag_iscomplete
condition|)
block|{
name|m
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
condition|)
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|->
name|flag_isselect
operator|=
literal|1
expr_stmt|;
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|f
operator|->
name|selinfo
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
operator|&&
operator|(
name|fflags
operator|&
name|FREAD
operator|)
condition|)
block|{
name|f
operator|=
name|refs
operator|.
name|rxfifo
expr_stmt|;
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refs
operator|.
name|is_usbfs
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|flag_iserror
condition|)
block|{
comment|/* we have and error */
name|m
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|f
operator|->
name|queue_data
operator|==
name|NULL
condition|)
block|{
comment|/* 					 * start read transfer, if not 					 * already started 					 */
call|(
name|f
operator|->
name|methods
operator|->
name|f_start_read
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* check if any packets are available */
name|USB_IF_POLL
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|f
operator|->
name|flag_iscomplete
condition|)
block|{
name|m
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
condition|)
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|->
name|flag_isselect
operator|=
literal|1
expr_stmt|;
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|f
operator|->
name|selinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refs
operator|.
name|is_usbfs
condition|)
block|{
comment|/* start reading data */
call|(
name|f
operator|->
name|methods
operator|->
name|f_start_read
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
block|}
name|usb_unref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|usb_cdev_refdata
name|refs
decl_stmt|;
name|struct
name|usb_cdev_privdata
modifier|*
name|cpd
decl_stmt|;
name|struct
name|usb_fifo
modifier|*
name|f
decl_stmt|;
name|struct
name|usb_mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|fflags
decl_stmt|;
name|int
name|resid
decl_stmt|;
name|int
name|io_len
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint8_t
name|tr_data
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|usb_ref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|,
literal|0
comment|/* no uref */
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|fflags
operator|=
name|cpd
operator|->
name|fflags
expr_stmt|;
name|f
operator|=
name|refs
operator|.
name|rxfifo
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* should not happen */
name|usb_unref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
comment|/* check for permanent read error */
if|if
condition|(
name|f
operator|->
name|flag_iserror
condition|)
block|{
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* check if USB-FS interface is active */
if|if
condition|(
name|refs
operator|.
name|is_usbfs
condition|)
block|{
comment|/* 		 * The queue is used for events that should be 		 * retrieved using the "USB_FS_COMPLETE" ioctl. 		 */
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* start read transfer, if not already started */
call|(
name|f
operator|->
name|methods
operator|->
name|f_start_read
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
block|{
if|if
condition|(
name|tr_data
condition|)
block|{
comment|/* return length before error */
break|break;
block|}
name|err
operator|=
name|EWOULDBLOCK
expr_stmt|;
break|break;
block|}
name|DPRINTF
argument_list|(
literal|"sleeping\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_fifo_wait
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
name|f
operator|->
name|methods
operator|->
name|f_filter_read
condition|)
block|{
comment|/* 			 * Sometimes it is convenient to process data at the 			 * expense of a userland process instead of a kernel 			 * process. 			 */
call|(
name|f
operator|->
name|methods
operator|->
name|f_filter_read
call|)
argument_list|(
name|f
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|tr_data
operator|=
literal|1
expr_stmt|;
name|io_len
operator|=
name|MIN
argument_list|(
name|m
operator|->
name|cur_data_len
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"transfer %d bytes from %p\n"
argument_list|,
name|io_len
argument_list|,
name|m
operator|->
name|cur_data_ptr
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_fifo_uiomove
argument_list|(
name|f
argument_list|,
name|m
operator|->
name|cur_data_ptr
argument_list|,
name|io_len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|m
operator|->
name|cur_data_len
operator|-=
name|io_len
expr_stmt|;
name|m
operator|->
name|cur_data_ptr
operator|+=
name|io_len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|cur_data_len
operator|==
literal|0
condition|)
block|{
name|uint8_t
name|last_packet
decl_stmt|;
name|last_packet
operator|=
name|m
operator|->
name|last_packet
expr_stmt|;
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_packet
condition|)
block|{
comment|/* keep framing */
break|break;
block|}
block|}
else|else
block|{
name|USB_IF_PREPEND
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
break|break;
block|}
block|}
name|done
label|:
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
name|usb_unref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|usb_cdev_refdata
name|refs
decl_stmt|;
name|struct
name|usb_cdev_privdata
modifier|*
name|cpd
decl_stmt|;
name|struct
name|usb_fifo
modifier|*
name|f
decl_stmt|;
name|struct
name|usb_mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|pdata
decl_stmt|;
name|int
name|fflags
decl_stmt|;
name|int
name|resid
decl_stmt|;
name|int
name|io_len
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint8_t
name|tr_data
init|=
literal|0
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|usb_ref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|,
literal|0
comment|/* no uref */
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|fflags
operator|=
name|cpd
operator|->
name|fflags
expr_stmt|;
name|f
operator|=
name|refs
operator|.
name|txfifo
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* should not happen */
name|usb_unref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
comment|/* check for permanent write error */
if|if
condition|(
name|f
operator|->
name|flag_iserror
condition|)
block|{
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* check if USB-FS interface is active */
if|if
condition|(
name|refs
operator|.
name|is_usbfs
condition|)
block|{
comment|/* 		 * The queue is used for events that should be 		 * retrieved using the "USB_FS_COMPLETE" ioctl. 		 */
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|f
operator|->
name|queue_data
operator|==
name|NULL
condition|)
block|{
comment|/* start write transfer, if not already started */
call|(
name|f
operator|->
name|methods
operator|->
name|f_start_write
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* we allow writing zero length data */
do|do
block|{
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
block|{
if|if
condition|(
name|tr_data
condition|)
block|{
comment|/* return length before error */
break|break;
block|}
name|err
operator|=
name|EWOULDBLOCK
expr_stmt|;
break|break;
block|}
name|DPRINTF
argument_list|(
literal|"sleeping\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_fifo_wait
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
break|break;
block|}
continue|continue;
block|}
name|tr_data
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|flag_have_fragment
operator|==
literal|0
condition|)
block|{
name|USB_MBUF_RESET
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|io_len
operator|=
name|m
operator|->
name|cur_data_len
expr_stmt|;
name|pdata
operator|=
name|m
operator|->
name|cur_data_ptr
expr_stmt|;
if|if
condition|(
name|io_len
operator|>
name|uio
operator|->
name|uio_resid
condition|)
name|io_len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|m
operator|->
name|cur_data_len
operator|=
name|io_len
expr_stmt|;
block|}
else|else
block|{
name|io_len
operator|=
name|m
operator|->
name|max_data_len
operator|-
name|m
operator|->
name|cur_data_len
expr_stmt|;
name|pdata
operator|=
name|m
operator|->
name|cur_data_ptr
operator|+
name|m
operator|->
name|cur_data_len
expr_stmt|;
if|if
condition|(
name|io_len
operator|>
name|uio
operator|->
name|uio_resid
condition|)
name|io_len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|m
operator|->
name|cur_data_len
operator|+=
name|io_len
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"transfer %d bytes to %p\n"
argument_list|,
name|io_len
argument_list|,
name|pdata
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_fifo_uiomove
argument_list|(
name|f
argument_list|,
name|pdata
argument_list|,
name|io_len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|f
operator|->
name|flag_have_fragment
operator|=
literal|0
expr_stmt|;
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check if the buffer is ready to be transmitted */
if|if
condition|(
operator|(
name|f
operator|->
name|flag_write_defrag
operator|==
literal|0
operator|)
operator|||
operator|(
name|m
operator|->
name|cur_data_len
operator|==
name|m
operator|->
name|max_data_len
operator|)
condition|)
block|{
name|f
operator|->
name|flag_have_fragment
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Check for write filter: 			 * 			 * Sometimes it is convenient to process data 			 * at the expense of a userland process 			 * instead of a kernel process. 			 */
if|if
condition|(
name|f
operator|->
name|methods
operator|->
name|f_filter_write
condition|)
block|{
call|(
name|f
operator|->
name|methods
operator|->
name|f_filter_write
call|)
argument_list|(
name|f
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Put USB mbuf in the used queue */
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Start writing data, if not already started */
call|(
name|f
operator|->
name|methods
operator|->
name|f_start_write
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Wait for more data or close */
name|f
operator|->
name|flag_have_fragment
operator|=
literal|1
expr_stmt|;
name|USB_IF_PREPEND
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
do|;
name|done
label|:
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
name|usb_unref_device
argument_list|(
name|cpd
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_static_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
union|union
block|{
name|struct
name|usb_read_dir
modifier|*
name|urd
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|}
name|u
union|;
name|int
name|err
decl_stmt|;
name|u
operator|.
name|data
operator|=
name|data
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|USB_READ_DIR
case|:
name|err
operator|=
name|usb_read_symlink
argument_list|(
name|u
operator|.
name|urd
operator|->
name|urd_data
argument_list|,
name|u
operator|.
name|urd
operator|->
name|urd_startentry
argument_list|,
name|u
operator|.
name|urd
operator|->
name|urd_maxlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_DEV_QUIRK_GET
case|:
case|case
name|USB_QUIRK_NAME_GET
case|:
case|case
name|USB_DEV_QUIRK_ADD
case|:
case|case
name|USB_DEV_QUIRK_REMOVE
case|:
name|err
operator|=
name|usb_quirk_ioctl_p
argument_list|(
name|cmd
argument_list|,
name|data
argument_list|,
name|fflag
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_GET_TEMPLATE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|usb_template
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|USB_SET_TEMPLATE
case|:
name|err
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|usb_template
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb_fifo_uiomove
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|cp
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * "uiomove()" can sleep so one needs to make a wrapper, 	 * exiting the mutex and checking things: 	 */
name|error
operator|=
name|uiomove
argument_list|(
name|cp
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_fifo_wait
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|mtx_assert
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|flag_iserror
condition|)
block|{
comment|/* we are gone */
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|f
operator|->
name|flag_sleeping
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|f
operator|->
name|cv_io
argument_list|,
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|flag_iserror
condition|)
block|{
comment|/* we are gone */
name|err
operator|=
name|EIO
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usb_fifo_signal
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|->
name|flag_sleeping
condition|)
block|{
name|f
operator|->
name|flag_sleeping
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|f
operator|->
name|cv_io
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|usb_fifo_wakeup
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|)
block|{
name|usb_fifo_signal
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|flag_isselect
condition|)
block|{
name|selwakeup
argument_list|(
operator|&
name|f
operator|->
name|selinfo
argument_list|)
expr_stmt|;
name|f
operator|->
name|flag_isselect
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|async_p
operator|!=
name|NULL
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|f
operator|->
name|async_p
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|f
operator|->
name|async_p
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|f
operator|->
name|async_p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|usb_fifo_dummy_open
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_fifo_dummy_close
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|usb_fifo_dummy_ioctl
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_fifo_dummy_cmd
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|fifo
operator|->
name|flag_flushing
operator|=
literal|0
expr_stmt|;
comment|/* not flushing */
block|}
end_function

begin_function
specifier|static
name|void
name|usb_fifo_check_methods
parameter_list|(
name|struct
name|usb_fifo_methods
modifier|*
name|pm
parameter_list|)
block|{
comment|/* check that all callback functions are OK */
if|if
condition|(
name|pm
operator|->
name|f_open
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_open
operator|=
operator|&
name|usb_fifo_dummy_open
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|f_close
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_close
operator|=
operator|&
name|usb_fifo_dummy_close
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|f_ioctl
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_ioctl
operator|=
operator|&
name|usb_fifo_dummy_ioctl
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|f_ioctl_post
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_ioctl_post
operator|=
operator|&
name|usb_fifo_dummy_ioctl
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|f_start_read
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_start_read
operator|=
operator|&
name|usb_fifo_dummy_cmd
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|f_stop_read
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_stop_read
operator|=
operator|&
name|usb_fifo_dummy_cmd
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|f_start_write
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_start_write
operator|=
operator|&
name|usb_fifo_dummy_cmd
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|f_stop_write
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_stop_write
operator|=
operator|&
name|usb_fifo_dummy_cmd
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_fifo_attach  *  * The following function will create a duplex FIFO.  *  * Return values:  * 0: Success.  * Else: Failure.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb_fifo_attach
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|void
modifier|*
name|priv_sc
parameter_list|,
name|struct
name|mtx
modifier|*
name|priv_mtx
parameter_list|,
name|struct
name|usb_fifo_methods
modifier|*
name|pm
parameter_list|,
name|struct
name|usb_fifo_sc
modifier|*
name|f_sc
parameter_list|,
name|uint16_t
name|unit
parameter_list|,
name|int16_t
name|subunit
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|usb_fifo
modifier|*
name|f_tx
decl_stmt|;
name|struct
name|usb_fifo
modifier|*
name|f_rx
decl_stmt|;
name|char
name|devname
index|[
literal|32
index|]
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_TX
index|]
operator|=
name|NULL
expr_stmt|;
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_RX
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* check the methods */
name|usb_fifo_check_methods
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv_mtx
operator|==
name|NULL
condition|)
name|priv_mtx
operator|=
operator|&
name|Giant
expr_stmt|;
comment|/* search for a free FIFO slot */
for|for
control|(
name|n
operator|=
literal|0
init|;
condition|;
name|n
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|n
operator|==
name|USB_FIFO_MAX
condition|)
block|{
comment|/* end of FIFOs reached */
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Check for TX FIFO */
if|if
condition|(
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_TX
index|]
operator|!=
name|NULL
condition|)
block|{
continue|continue;
block|}
comment|/* Check for RX FIFO */
if|if
condition|(
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_RX
index|]
operator|!=
name|NULL
condition|)
block|{
continue|continue;
block|}
break|break;
block|}
name|f_tx
operator|=
name|usb_fifo_alloc
argument_list|()
expr_stmt|;
name|f_rx
operator|=
name|usb_fifo_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|f_tx
operator|==
name|NULL
operator|)
operator|||
operator|(
name|f_rx
operator|==
name|NULL
operator|)
condition|)
block|{
name|usb_fifo_free
argument_list|(
name|f_tx
argument_list|)
expr_stmt|;
name|usb_fifo_free
argument_list|(
name|f_rx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* initialise FIFO structures */
name|f_tx
operator|->
name|fifo_index
operator|=
name|n
operator|+
name|USB_FIFO_TX
expr_stmt|;
name|f_tx
operator|->
name|dev_ep_index
operator|=
operator|-
literal|1
expr_stmt|;
name|f_tx
operator|->
name|priv_mtx
operator|=
name|priv_mtx
expr_stmt|;
name|f_tx
operator|->
name|priv_sc0
operator|=
name|priv_sc
expr_stmt|;
name|f_tx
operator|->
name|methods
operator|=
name|pm
expr_stmt|;
name|f_tx
operator|->
name|iface_index
operator|=
name|iface_index
expr_stmt|;
name|f_tx
operator|->
name|udev
operator|=
name|udev
expr_stmt|;
name|f_rx
operator|->
name|fifo_index
operator|=
name|n
operator|+
name|USB_FIFO_RX
expr_stmt|;
name|f_rx
operator|->
name|dev_ep_index
operator|=
operator|-
literal|1
expr_stmt|;
name|f_rx
operator|->
name|priv_mtx
operator|=
name|priv_mtx
expr_stmt|;
name|f_rx
operator|->
name|priv_sc0
operator|=
name|priv_sc
expr_stmt|;
name|f_rx
operator|->
name|methods
operator|=
name|pm
expr_stmt|;
name|f_rx
operator|->
name|iface_index
operator|=
name|iface_index
expr_stmt|;
name|f_rx
operator|->
name|udev
operator|=
name|udev
expr_stmt|;
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_TX
index|]
operator|=
name|f_tx
expr_stmt|;
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_RX
index|]
operator|=
name|f_rx
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
name|udev
operator|->
name|fifo
index|[
name|f_tx
operator|->
name|fifo_index
index|]
operator|=
name|f_tx
expr_stmt|;
name|udev
operator|->
name|fifo
index|[
name|f_rx
operator|->
name|fifo_index
index|]
operator|=
name|f_rx
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
literal|4
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|pm
operator|->
name|basename
index|[
name|n
index|]
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|subunit
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|snprintf
argument_list|(
name|devname
argument_list|,
sizeof|sizeof
argument_list|(
name|devname
argument_list|)
argument_list|,
literal|"%s%u%s"
argument_list|,
name|pm
operator|->
name|basename
index|[
name|n
index|]
argument_list|,
name|unit
argument_list|,
name|pm
operator|->
name|postfix
index|[
name|n
index|]
condition|?
name|pm
operator|->
name|postfix
index|[
name|n
index|]
else|:
literal|""
argument_list|)
condition|)
block|{
comment|/* ignore */
block|}
block|}
else|else
block|{
if|if
condition|(
name|snprintf
argument_list|(
name|devname
argument_list|,
sizeof|sizeof
argument_list|(
name|devname
argument_list|)
argument_list|,
literal|"%s%u.%d%s"
argument_list|,
name|pm
operator|->
name|basename
index|[
name|n
index|]
argument_list|,
name|unit
argument_list|,
name|subunit
argument_list|,
name|pm
operator|->
name|postfix
index|[
name|n
index|]
condition|?
name|pm
operator|->
name|postfix
index|[
name|n
index|]
else|:
literal|""
argument_list|)
condition|)
block|{
comment|/* ignore */
block|}
block|}
comment|/* 		 * Distribute the symbolic links into two FIFO structures: 		 */
if|if
condition|(
name|n
operator|&
literal|1
condition|)
block|{
name|f_rx
operator|->
name|symlink
index|[
name|n
operator|/
literal|2
index|]
operator|=
name|usb_alloc_symlink
argument_list|(
name|devname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f_tx
operator|->
name|symlink
index|[
name|n
operator|/
literal|2
index|]
operator|=
name|usb_alloc_symlink
argument_list|(
name|devname
argument_list|)
expr_stmt|;
block|}
comment|/* Create the device */
name|f_sc
operator|->
name|dev
operator|=
name|usb_make_dev
argument_list|(
name|udev
argument_list|,
name|devname
argument_list|,
operator|-
literal|1
argument_list|,
name|f_tx
operator|->
name|fifo_index
operator|&
name|f_rx
operator|->
name|fifo_index
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"attached %p/%p\n"
argument_list|,
name|f_tx
argument_list|,
name|f_rx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_fifo_alloc_buffer  *  * Return values:  * 0: Success  * Else failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb_fifo_alloc_buffer
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|,
name|usb_size_t
name|bufsize
parameter_list|,
name|uint16_t
name|nbuf
parameter_list|)
block|{
name|usb_fifo_free_buffer
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* allocate an endpoint */
name|f
operator|->
name|free_q
operator|.
name|ifq_maxlen
operator|=
name|nbuf
expr_stmt|;
name|f
operator|->
name|used_q
operator|.
name|ifq_maxlen
operator|=
name|nbuf
expr_stmt|;
name|f
operator|->
name|queue_data
operator|=
name|usb_alloc_mbufs
argument_list|(
name|M_USBDEV
argument_list|,
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|bufsize
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|queue_data
operator|==
name|NULL
operator|)
operator|&&
name|bufsize
operator|&&
name|nbuf
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_fifo_free_buffer  *  * This function will free the buffers associated with a FIFO. This  * function can be called multiple times in a row.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_fifo_free_buffer
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|->
name|queue_data
condition|)
block|{
comment|/* free old buffer */
name|free
argument_list|(
name|f
operator|->
name|queue_data
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
name|f
operator|->
name|queue_data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* reset queues */
name|memset
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|f
operator|->
name|free_q
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|f
operator|->
name|used_q
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usb_fifo_detach
parameter_list|(
name|struct
name|usb_fifo_sc
modifier|*
name|f_sc
parameter_list|)
block|{
if|if
condition|(
name|f_sc
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|usb_fifo_free
argument_list|(
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_TX
index|]
argument_list|)
expr_stmt|;
name|usb_fifo_free
argument_list|(
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_RX
index|]
argument_list|)
expr_stmt|;
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_TX
index|]
operator|=
name|NULL
expr_stmt|;
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_RX
index|]
operator|=
name|NULL
expr_stmt|;
name|usb_destroy_dev
argument_list|(
name|f_sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|f_sc
operator|->
name|dev
operator|=
name|NULL
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"detached %p\n"
argument_list|,
name|f_sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usb_size_t
name|usb_fifo_put_bytes_max
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|usb_mbuf
modifier|*
name|m
decl_stmt|;
name|usb_size_t
name|len
decl_stmt|;
name|USB_IF_POLL
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|len
operator|=
name|m
operator|->
name|max_data_len
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_fifo_put_data  *  * what:  *  0 - normal operation  *  1 - set last packet flag to enforce framing  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_fifo_put_data
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|,
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|,
name|usb_frlength_t
name|offset
parameter_list|,
name|usb_frlength_t
name|len
parameter_list|,
name|uint8_t
name|what
parameter_list|)
block|{
name|struct
name|usb_mbuf
modifier|*
name|m
decl_stmt|;
name|usb_frlength_t
name|io_len
decl_stmt|;
while|while
condition|(
name|len
operator|||
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|USB_MBUF_RESET
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|io_len
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|m
operator|->
name|cur_data_len
argument_list|)
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
name|offset
argument_list|,
name|m
operator|->
name|cur_data_ptr
argument_list|,
name|io_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|cur_data_len
operator|=
name|io_len
expr_stmt|;
name|offset
operator|+=
name|io_len
expr_stmt|;
name|len
operator|-=
name|io_len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|&&
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
name|m
operator|->
name|last_packet
operator|=
literal|1
expr_stmt|;
block|}
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|usb_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|usb_fifo_put_data_linear
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|usb_size_t
name|len
parameter_list|,
name|uint8_t
name|what
parameter_list|)
block|{
name|struct
name|usb_mbuf
modifier|*
name|m
decl_stmt|;
name|usb_size_t
name|io_len
decl_stmt|;
while|while
condition|(
name|len
operator|||
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|USB_MBUF_RESET
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|io_len
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|m
operator|->
name|cur_data_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|m
operator|->
name|cur_data_ptr
argument_list|,
name|ptr
argument_list|,
name|io_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|cur_data_len
operator|=
name|io_len
expr_stmt|;
name|ptr
operator|=
name|USB_ADD_BYTES
argument_list|(
name|ptr
argument_list|,
name|io_len
argument_list|)
expr_stmt|;
name|len
operator|-=
name|io_len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|&&
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
name|m
operator|->
name|last_packet
operator|=
literal|1
expr_stmt|;
block|}
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|usb_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
end_function

begin_function
name|uint8_t
name|usb_fifo_put_data_buffer
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|usb_size_t
name|len
parameter_list|)
block|{
name|struct
name|usb_mbuf
modifier|*
name|m
decl_stmt|;
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|m
operator|->
name|cur_data_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|cur_data_ptr
operator|=
name|ptr
expr_stmt|;
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|usb_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usb_fifo_put_data_error
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|)
block|{
name|f
operator|->
name|flag_iserror
operator|=
literal|1
expr_stmt|;
name|usb_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_fifo_get_data  *  * what:  *  0 - normal operation  *  1 - only get one "usb_mbuf"  *  * returns:  *  0 - no more data  *  1 - data in buffer  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usb_fifo_get_data
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|,
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|,
name|usb_frlength_t
name|offset
parameter_list|,
name|usb_frlength_t
name|len
parameter_list|,
name|usb_frlength_t
modifier|*
name|actlen
parameter_list|,
name|uint8_t
name|what
parameter_list|)
block|{
name|struct
name|usb_mbuf
modifier|*
name|m
decl_stmt|;
name|usb_frlength_t
name|io_len
decl_stmt|;
name|uint8_t
name|tr_data
init|=
literal|0
decl_stmt|;
name|actlen
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|tr_data
operator|=
literal|1
expr_stmt|;
name|io_len
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|m
operator|->
name|cur_data_len
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
name|offset
argument_list|,
name|m
operator|->
name|cur_data_ptr
argument_list|,
name|io_len
argument_list|)
expr_stmt|;
name|len
operator|-=
name|io_len
expr_stmt|;
name|offset
operator|+=
name|io_len
expr_stmt|;
name|actlen
index|[
literal|0
index|]
operator|+=
name|io_len
expr_stmt|;
name|m
operator|->
name|cur_data_ptr
operator|+=
name|io_len
expr_stmt|;
name|m
operator|->
name|cur_data_len
operator|-=
name|io_len
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|cur_data_len
operator|==
literal|0
operator|)
operator|||
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|usb_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|1
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
name|USB_IF_PREPEND
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tr_data
condition|)
block|{
comment|/* wait for data to be written out */
break|break;
block|}
if|if
condition|(
name|f
operator|->
name|flag_flushing
condition|)
block|{
comment|/* check if we should send a short packet */
if|if
condition|(
name|f
operator|->
name|flag_short
operator|!=
literal|0
condition|)
block|{
name|f
operator|->
name|flag_short
operator|=
literal|0
expr_stmt|;
name|tr_data
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* flushing complete */
name|f
operator|->
name|flag_flushing
operator|=
literal|0
expr_stmt|;
name|usb_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|tr_data
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|usb_fifo_get_data_linear
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|usb_size_t
name|len
parameter_list|,
name|usb_size_t
modifier|*
name|actlen
parameter_list|,
name|uint8_t
name|what
parameter_list|)
block|{
name|struct
name|usb_mbuf
modifier|*
name|m
decl_stmt|;
name|usb_size_t
name|io_len
decl_stmt|;
name|uint8_t
name|tr_data
init|=
literal|0
decl_stmt|;
name|actlen
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|tr_data
operator|=
literal|1
expr_stmt|;
name|io_len
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|m
operator|->
name|cur_data_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|m
operator|->
name|cur_data_ptr
argument_list|,
name|io_len
argument_list|)
expr_stmt|;
name|len
operator|-=
name|io_len
expr_stmt|;
name|ptr
operator|=
name|USB_ADD_BYTES
argument_list|(
name|ptr
argument_list|,
name|io_len
argument_list|)
expr_stmt|;
name|actlen
index|[
literal|0
index|]
operator|+=
name|io_len
expr_stmt|;
name|m
operator|->
name|cur_data_ptr
operator|+=
name|io_len
expr_stmt|;
name|m
operator|->
name|cur_data_len
operator|-=
name|io_len
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|cur_data_len
operator|==
literal|0
operator|)
operator|||
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|usb_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|1
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
name|USB_IF_PREPEND
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tr_data
condition|)
block|{
comment|/* wait for data to be written out */
break|break;
block|}
if|if
condition|(
name|f
operator|->
name|flag_flushing
condition|)
block|{
comment|/* check if we should send a short packet */
if|if
condition|(
name|f
operator|->
name|flag_short
operator|!=
literal|0
condition|)
block|{
name|f
operator|->
name|flag_short
operator|=
literal|0
expr_stmt|;
name|tr_data
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* flushing complete */
name|f
operator|->
name|flag_flushing
operator|=
literal|0
expr_stmt|;
name|usb_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|tr_data
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|usb_fifo_get_data_buffer
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|,
name|void
modifier|*
modifier|*
name|pptr
parameter_list|,
name|usb_size_t
modifier|*
name|plen
parameter_list|)
block|{
name|struct
name|usb_mbuf
modifier|*
name|m
decl_stmt|;
name|USB_IF_POLL
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
operator|*
name|plen
operator|=
name|m
operator|->
name|cur_data_len
expr_stmt|;
operator|*
name|pptr
operator|=
name|m
operator|->
name|cur_data_ptr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usb_fifo_get_data_error
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|)
block|{
name|f
operator|->
name|flag_iserror
operator|=
literal|1
expr_stmt|;
name|usb_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_alloc_symlink  *  * Return values:  * NULL: Failure  * Else: Pointer to symlink entry  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb_symlink
modifier|*
name|usb_alloc_symlink
parameter_list|(
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|usb_symlink
modifier|*
name|ps
decl_stmt|;
name|ps
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ps
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ps
operator|)
return|;
block|}
comment|/* XXX no longer needed */
name|strlcpy
argument_list|(
name|ps
operator|->
name|src_path
argument_list|,
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
operator|->
name|src_path
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|->
name|src_len
operator|=
name|strlen
argument_list|(
name|ps
operator|->
name|src_path
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ps
operator|->
name|dst_path
argument_list|,
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
operator|->
name|dst_path
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|->
name|dst_len
operator|=
name|strlen
argument_list|(
name|ps
operator|->
name|dst_path
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|usb_sym_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|usb_sym_head
argument_list|,
name|ps
argument_list|,
name|sym_entry
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|usb_sym_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ps
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_free_symlink  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_free_symlink
parameter_list|(
name|struct
name|usb_symlink
modifier|*
name|ps
parameter_list|)
block|{
if|if
condition|(
name|ps
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|sx_xlock
argument_list|(
operator|&
name|usb_sym_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|usb_sym_head
argument_list|,
name|ps
argument_list|,
name|sym_entry
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|usb_sym_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ps
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_read_symlink  *  * Return value:  * 0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb_read_symlink
parameter_list|(
name|uint8_t
modifier|*
name|user_ptr
parameter_list|,
name|uint32_t
name|startentry
parameter_list|,
name|uint32_t
name|user_len
parameter_list|)
block|{
name|struct
name|usb_symlink
modifier|*
name|ps
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|delta
init|=
literal|0
decl_stmt|;
name|uint8_t
name|len
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|usb_sym_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ps
argument_list|,
argument|&usb_sym_head
argument_list|,
argument|sym_entry
argument_list|)
block|{
comment|/* 		 * Compute total length of source and destination symlink 		 * strings pluss one length byte and two NUL bytes: 		 */
name|temp
operator|=
name|ps
operator|->
name|src_len
operator|+
name|ps
operator|->
name|dst_len
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|255
condition|)
block|{
comment|/* 			 * Skip entry because this length cannot fit 			 * into one byte: 			 */
continue|continue;
block|}
if|if
condition|(
name|startentry
operator|!=
literal|0
condition|)
block|{
comment|/* decrement read offset */
name|startentry
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|temp
operator|>
name|user_len
condition|)
block|{
comment|/* out of buffer space */
break|break;
block|}
name|len
operator|=
name|temp
expr_stmt|;
comment|/* copy out total length */
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|len
argument_list|,
name|USB_ADD_BYTES
argument_list|(
name|user_ptr
argument_list|,
name|delta
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|delta
operator|+=
literal|1
expr_stmt|;
comment|/* copy out source string */
name|error
operator|=
name|copyout
argument_list|(
name|ps
operator|->
name|src_path
argument_list|,
name|USB_ADD_BYTES
argument_list|(
name|user_ptr
argument_list|,
name|delta
argument_list|)
argument_list|,
name|ps
operator|->
name|src_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|len
operator|=
literal|0
expr_stmt|;
name|delta
operator|+=
name|ps
operator|->
name|src_len
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|len
argument_list|,
name|USB_ADD_BYTES
argument_list|(
name|user_ptr
argument_list|,
name|delta
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|delta
operator|+=
literal|1
expr_stmt|;
comment|/* copy out destination string */
name|error
operator|=
name|copyout
argument_list|(
name|ps
operator|->
name|dst_path
argument_list|,
name|USB_ADD_BYTES
argument_list|(
name|user_ptr
argument_list|,
name|delta
argument_list|)
argument_list|,
name|ps
operator|->
name|dst_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|len
operator|=
literal|0
expr_stmt|;
name|delta
operator|+=
name|ps
operator|->
name|dst_len
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|len
argument_list|,
name|USB_ADD_BYTES
argument_list|(
name|user_ptr
argument_list|,
name|delta
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|delta
operator|+=
literal|1
expr_stmt|;
name|user_len
operator|-=
name|temp
expr_stmt|;
block|}
comment|/* a zero length entry indicates the end */
if|if
condition|(
operator|(
name|user_len
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|error
operator|==
literal|0
operator|)
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|len
argument_list|,
name|USB_ADD_BYTES
argument_list|(
name|user_ptr
argument_list|,
name|delta
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sx_unlock
argument_list|(
operator|&
name|usb_sym_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usb_fifo_set_close_zlp
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|,
name|uint8_t
name|onoff
parameter_list|)
block|{
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return;
comment|/* send a Zero Length Packet, ZLP, before close */
name|f
operator|->
name|flag_short
operator|=
name|onoff
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usb_fifo_set_write_defrag
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|,
name|uint8_t
name|onoff
parameter_list|)
block|{
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return;
comment|/* defrag written data */
name|f
operator|->
name|flag_write_defrag
operator|=
name|onoff
expr_stmt|;
comment|/* reset defrag state */
name|f
operator|->
name|flag_have_fragment
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|usb_fifo_softc
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|f
parameter_list|)
block|{
return|return
operator|(
name|f
operator|->
name|priv_sc0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USB_HAVE_UGEN */
end_comment

end_unit

