begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2006-2008 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  * usb2_dev.c - An abstraction layer for creating devices under /dev/...  */
end_comment

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_mfunc.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_error.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|usb2_fifo_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_dev.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_generic.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_dynamic.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttycom.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_decl_stmt
specifier|static
name|int
name|usb2_fifo_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb2
argument_list|,
name|OID_AUTO
argument_list|,
name|dev
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB device"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb2_dev
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|usb2_fifo_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug Level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
operator|(
name|__FreeBSD_version
operator|>=
literal|700001
operator|)
operator|||
operator|(
name|__FreeBSD_version
operator|==
literal|0
operator|)
operator|||
expr|\
operator|(
operator|(
name|__FreeBSD_version
operator|>=
literal|600034
operator|)
operator|&&
operator|(
name|__FreeBSD_version
operator|<
literal|700000
operator|)
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|USB_UCRED
value|struct ucred *ucred,
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USB_UCRED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|uint32_t
name|usb2_path_convert_one
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|usb2_path_convert
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb2_check_access
parameter_list|(
name|int
parameter_list|,
name|struct
name|usb2_perm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb2_fifo_open
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
parameter_list|,
name|struct
name|file
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_fifo_close
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_dev_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_dev_init_post
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_dev_uninit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb2_fifo_uiomove
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_fifo_check_methods
parameter_list|(
name|struct
name|usb2_fifo_methods
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_clone
parameter_list|(
name|void
modifier|*
parameter_list|,
name|USB_UCRED
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|cdev
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|usb2_fifo
modifier|*
name|usb2_fifo_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|usb2_pipe
modifier|*
name|usb2_dev_get_pipe
parameter_list|(
name|struct
name|usb2_device
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_fdopen_t
name|usb2_fdopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|usb2_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|usb2_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_rdwr_t
name|usb2_read_f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_rdwr_t
name|usb2_write_f
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|800009
end_if

begin_decl_stmt
specifier|static
name|fo_truncate_t
name|usb2_truncate_f
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|fo_ioctl_t
name|usb2_ioctl_f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_poll_t
name|usb2_poll_f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_kqfilter_t
name|usb2_kqfilter_f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_stat_t
name|usb2_stat_f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_close_t
name|usb2_close_f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb2_fifo_open_t
name|usb2_fifo_dummy_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb2_fifo_close_t
name|usb2_fifo_dummy_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb2_fifo_ioctl_t
name|usb2_fifo_dummy_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb2_fifo_cmd_t
name|usb2_fifo_dummy_cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|usb2_perm
name|usb2_perm
init|=
block|{
operator|.
name|uid
operator|=
name|UID_ROOT
block|,
operator|.
name|gid
operator|=
name|GID_OPERATOR
block|,
operator|.
name|mode
operator|=
literal|0660
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|usb2_devsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_fdopen
operator|=
name|usb2_fdopen
block|,
operator|.
name|d_close
operator|=
name|usb2_close
block|,
operator|.
name|d_ioctl
operator|=
name|usb2_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"usb"
block|,
operator|.
name|d_flags
operator|=
name|D_TRACKCLOSE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fileops
name|usb2_ops_f
init|=
block|{
operator|.
name|fo_read
operator|=
name|usb2_read_f
block|,
operator|.
name|fo_write
operator|=
name|usb2_write_f
block|,
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|800009
operator|.
name|fo_truncate
operator|=
name|usb2_truncate_f
block|,
endif|#
directive|endif
operator|.
name|fo_ioctl
operator|=
name|usb2_ioctl_f
block|,
operator|.
name|fo_poll
operator|=
name|usb2_poll_f
block|,
operator|.
name|fo_kqfilter
operator|=
name|usb2_kqfilter_f
block|,
operator|.
name|fo_stat
operator|=
name|usb2_stat_f
block|,
operator|.
name|fo_close
operator|=
name|usb2_close_f
block|,
operator|.
name|fo_flags
operator|=
name|DFLAG_PASSABLE
operator||
name|DFLAG_SEEKABLE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|dev_clone_fn
name|usb2_clone_ptr
init|=
operator|&
name|usb2_clone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|usb2_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|usb2_last_devloc
init|=
literal|0
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|usb2_clone_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|usb2_old_f_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fileops
modifier|*
name|usb2_old_f_ops
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|usb2_symlink
argument_list|)
name|usb2_sym_head
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|usb2_sym_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|usb2_ref_lock
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint32_t
name|usb2_path_convert_one
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|uint32_t
name|temp
init|=
literal|0
decl_stmt|;
name|ptr
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|ptr
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|ptr
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|temp
operator|*=
literal|10
expr_stmt|;
name|temp
operator|+=
operator|(
operator|*
name|ptr
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
literal|1000000
condition|)
block|{
comment|/* catch overflow early */
return|return
operator|(
literal|0
operator|-
literal|1
operator|)
return|;
block|}
name|ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'.'
condition|)
block|{
comment|/* skip dot */
name|ptr
operator|++
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_path_convert  *  * Path format: "/dev/usb<bus>.<dev>.<iface>.<fifo>"  *  * Returns: Path converted into numerical format.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint32_t
name|usb2_path_convert
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|devloc
decl_stmt|;
name|devloc
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|usb2_path_convert_one
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
name|USB_BUS_MAX
condition|)
block|{
return|return
operator|(
literal|0
operator|-
literal|1
operator|)
return|;
block|}
name|devloc
operator|+=
name|temp
expr_stmt|;
name|temp
operator|=
name|usb2_path_convert_one
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
name|USB_DEV_MAX
condition|)
block|{
return|return
operator|(
literal|0
operator|-
literal|1
operator|)
return|;
block|}
name|devloc
operator|+=
operator|(
name|temp
operator|*
name|USB_BUS_MAX
operator|)
expr_stmt|;
name|temp
operator|=
name|usb2_path_convert_one
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
name|USB_IFACE_MAX
condition|)
block|{
return|return
operator|(
literal|0
operator|-
literal|1
operator|)
return|;
block|}
name|devloc
operator|+=
operator|(
name|temp
operator|*
name|USB_DEV_MAX
operator|*
name|USB_BUS_MAX
operator|)
expr_stmt|;
name|temp
operator|=
name|usb2_path_convert_one
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
operator|(
operator|(
name|USB_FIFO_MAX
operator|/
literal|2
operator|)
operator|+
operator|(
name|USB_EP_MAX
operator|/
literal|2
operator|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|-
literal|1
operator|)
return|;
block|}
name|devloc
operator|+=
operator|(
name|temp
operator|*
name|USB_IFACE_MAX
operator|*
name|USB_DEV_MAX
operator|*
name|USB_BUS_MAX
operator|)
expr_stmt|;
return|return
operator|(
name|devloc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_set_iface_perm  *  * This function will set the interface permissions.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb2_set_iface_perm
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint32_t
name|uid
parameter_list|,
name|uint32_t
name|gid
parameter_list|,
name|uint16_t
name|mode
parameter_list|)
block|{
name|struct
name|usb2_interface
modifier|*
name|iface
decl_stmt|;
name|iface
operator|=
name|usb2_get_iface
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|&&
name|iface
operator|->
name|idesc
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
name|iface
operator|->
name|perm
operator|.
name|uid
operator|=
name|uid
expr_stmt|;
name|iface
operator|->
name|perm
operator|.
name|gid
operator|=
name|gid
expr_stmt|;
name|iface
operator|->
name|perm
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_set_perm  *  * This function will set the permissions at the given level.  *  * Return values:  *    0: Success.  * Else: Failure.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb2_set_perm
parameter_list|(
name|struct
name|usb2_dev_perm
modifier|*
name|psrc
parameter_list|,
name|uint8_t
name|level
parameter_list|)
block|{
name|struct
name|usb2_location
name|loc
decl_stmt|;
name|struct
name|usb2_perm
modifier|*
name|pdst
decl_stmt|;
name|uint32_t
name|devloc
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* check if the current thread can change USB permissions. */
name|error
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_ROOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* range check device location */
if|if
condition|(
operator|(
name|psrc
operator|->
name|bus_index
operator|>=
name|USB_BUS_MAX
operator|)
operator|||
operator|(
name|psrc
operator|->
name|dev_index
operator|>=
name|USB_DEV_MAX
operator|)
operator|||
operator|(
name|psrc
operator|->
name|iface_index
operator|>=
name|USB_IFACE_MAX
operator|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|level
operator|==
literal|1
condition|)
name|devloc
operator|=
name|USB_BUS_MAX
expr_stmt|;
comment|/* use root-HUB to access bus */
else|else
name|devloc
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|level
condition|)
block|{
case|case
literal|3
case|:
name|devloc
operator|+=
name|psrc
operator|->
name|iface_index
operator|*
name|USB_DEV_MAX
operator|*
name|USB_BUS_MAX
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|devloc
operator|+=
name|psrc
operator|->
name|dev_index
operator|*
name|USB_BUS_MAX
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|devloc
operator|+=
name|psrc
operator|->
name|bus_index
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|level
operator|>
literal|0
operator|)
operator|&&
operator|(
name|level
operator|<
literal|4
operator|)
condition|)
block|{
name|error
operator|=
name|usb2_ref_device
argument_list|(
name|NULL
argument_list|,
operator|&
name|loc
argument_list|,
name|devloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|level
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|loc
operator|.
name|iface
operator|==
name|NULL
condition|)
block|{
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pdst
operator|=
operator|&
name|loc
operator|.
name|iface
operator|->
name|perm
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pdst
operator|=
operator|&
name|loc
operator|.
name|udev
operator|->
name|perm
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|pdst
operator|=
operator|&
name|loc
operator|.
name|bus
operator|->
name|perm
expr_stmt|;
break|break;
default|default:
name|pdst
operator|=
operator|&
name|usb2_perm
expr_stmt|;
break|break;
block|}
comment|/* all permissions are protected by "usb2_ref_lock" */
name|mtx_lock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
name|pdst
operator|->
name|uid
operator|=
name|psrc
operator|->
name|user_id
expr_stmt|;
name|pdst
operator|->
name|gid
operator|=
name|psrc
operator|->
name|group_id
expr_stmt|;
name|pdst
operator|->
name|mode
operator|=
name|psrc
operator|->
name|mode
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|level
operator|>
literal|0
operator|)
operator|&&
operator|(
name|level
operator|<
literal|4
operator|)
condition|)
block|{
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_get_perm  *  * This function will get the permissions at the given level.  *  * Return values:  *    0: Success.  * Else: Failure.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb2_get_perm
parameter_list|(
name|struct
name|usb2_dev_perm
modifier|*
name|pdst
parameter_list|,
name|uint8_t
name|level
parameter_list|)
block|{
name|struct
name|usb2_location
name|loc
decl_stmt|;
name|struct
name|usb2_perm
modifier|*
name|psrc
decl_stmt|;
name|uint32_t
name|devloc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|pdst
operator|->
name|bus_index
operator|>=
name|USB_BUS_MAX
operator|)
operator|||
operator|(
name|pdst
operator|->
name|dev_index
operator|>=
name|USB_DEV_MAX
operator|)
operator|||
operator|(
name|pdst
operator|->
name|iface_index
operator|>=
name|USB_IFACE_MAX
operator|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|level
operator|==
literal|1
condition|)
name|devloc
operator|=
name|USB_BUS_MAX
expr_stmt|;
comment|/* use root-HUB to access bus */
else|else
name|devloc
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|level
condition|)
block|{
case|case
literal|3
case|:
name|devloc
operator|+=
name|pdst
operator|->
name|iface_index
operator|*
name|USB_DEV_MAX
operator|*
name|USB_BUS_MAX
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|devloc
operator|+=
name|pdst
operator|->
name|dev_index
operator|*
name|USB_BUS_MAX
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|devloc
operator|+=
name|pdst
operator|->
name|bus_index
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|level
operator|>
literal|0
operator|)
operator|&&
operator|(
name|level
operator|<
literal|4
operator|)
condition|)
block|{
name|error
operator|=
name|usb2_ref_device
argument_list|(
name|NULL
argument_list|,
operator|&
name|loc
argument_list|,
name|devloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|level
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|loc
operator|.
name|iface
operator|==
name|NULL
condition|)
block|{
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|psrc
operator|=
operator|&
name|loc
operator|.
name|iface
operator|->
name|perm
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|psrc
operator|=
operator|&
name|loc
operator|.
name|udev
operator|->
name|perm
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|psrc
operator|=
operator|&
name|loc
operator|.
name|bus
operator|->
name|perm
expr_stmt|;
break|break;
default|default:
name|psrc
operator|=
operator|&
name|usb2_perm
expr_stmt|;
break|break;
block|}
comment|/* all permissions are protected by "usb2_ref_lock" */
name|mtx_lock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|psrc
operator|->
name|mode
operator|!=
literal|0
condition|)
block|{
name|pdst
operator|->
name|user_id
operator|=
name|psrc
operator|->
name|uid
expr_stmt|;
name|pdst
operator|->
name|group_id
operator|=
name|psrc
operator|->
name|gid
expr_stmt|;
name|pdst
operator|->
name|mode
operator|=
name|psrc
operator|->
name|mode
expr_stmt|;
block|}
else|else
block|{
comment|/* access entry at this level and location is not active */
name|pdst
operator|->
name|user_id
operator|=
literal|0
expr_stmt|;
name|pdst
operator|->
name|group_id
operator|=
literal|0
expr_stmt|;
name|pdst
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|level
operator|>
literal|0
operator|)
operator|&&
operator|(
name|level
operator|<
literal|4
operator|)
condition|)
block|{
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_check_access  *  * This function will verify the given access information.  *  * Return values:  * 0: Access granted.  * Else: No access granted.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb2_check_access
parameter_list|(
name|int
name|fflags
parameter_list|,
name|struct
name|usb2_perm
modifier|*
name|puser
parameter_list|)
block|{
name|mode_t
name|accmode
decl_stmt|;
if|if
condition|(
operator|(
name|fflags
operator|&
operator|(
name|FWRITE
operator||
name|FREAD
operator|)
operator|)
operator|&&
operator|(
name|puser
operator|->
name|mode
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* continue */
block|}
else|else
block|{
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* no access */
block|}
name|accmode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fflags
operator|&
name|FWRITE
condition|)
name|accmode
operator||=
name|VWRITE
expr_stmt|;
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
name|accmode
operator||=
name|VREAD
expr_stmt|;
return|return
operator|(
name|vaccess
argument_list|(
name|VCHR
argument_list|,
name|puser
operator|->
name|mode
argument_list|,
name|puser
operator|->
name|uid
argument_list|,
name|puser
operator|->
name|gid
argument_list|,
name|accmode
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_ref_device  *  * This function is used to atomically refer an USB device by its  * device location. If this function returns success the USB device  * will not dissappear until the USB device is unreferenced.  *  * Return values:  *  0: Success, refcount incremented on the given USB device.  *  Else: Failure.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb2_error_t
name|usb2_ref_device
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|usb2_location
modifier|*
name|ploc
parameter_list|,
name|uint32_t
name|devloc
parameter_list|)
block|{
name|struct
name|usb2_fifo
modifier|*
modifier|*
name|ppf
decl_stmt|;
name|struct
name|usb2_fifo
modifier|*
name|f
decl_stmt|;
name|int
name|fflags
decl_stmt|;
name|uint8_t
name|dev_ep_index
decl_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
comment|/* check if we need uref */
name|ploc
operator|->
name|is_uref
operator|=
name|devloc
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/* get devloc - already verified */
name|devloc
operator|=
name|USB_P2U
argument_list|(
name|fp
operator|->
name|f_data
argument_list|)
expr_stmt|;
comment|/* get file flags */
name|fflags
operator|=
name|fp
operator|->
name|f_flag
expr_stmt|;
block|}
else|else
block|{
comment|/* only ref device */
name|fflags
operator|=
literal|0
expr_stmt|;
comment|/* search for FIFO */
name|ploc
operator|->
name|is_uref
operator|=
literal|1
expr_stmt|;
comment|/* check "devloc" */
if|if
condition|(
name|devloc
operator|>=
operator|(
name|USB_BUS_MAX
operator|*
name|USB_DEV_MAX
operator|*
name|USB_IFACE_MAX
operator|*
operator|(
operator|(
name|USB_EP_MAX
operator|/
literal|2
operator|)
operator|+
operator|(
name|USB_FIFO_MAX
operator|/
literal|2
operator|)
operator|)
operator|)
condition|)
block|{
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
block|}
comment|/* store device location */
name|ploc
operator|->
name|devloc
operator|=
name|devloc
expr_stmt|;
name|ploc
operator|->
name|bus_index
operator|=
name|devloc
operator|%
name|USB_BUS_MAX
expr_stmt|;
name|ploc
operator|->
name|dev_index
operator|=
operator|(
name|devloc
operator|/
name|USB_BUS_MAX
operator|)
operator|%
name|USB_DEV_MAX
expr_stmt|;
name|ploc
operator|->
name|iface_index
operator|=
operator|(
name|devloc
operator|/
operator|(
name|USB_BUS_MAX
operator|*
name|USB_DEV_MAX
operator|)
operator|)
operator|%
name|USB_IFACE_MAX
expr_stmt|;
name|ploc
operator|->
name|fifo_index
operator|=
operator|(
name|devloc
operator|/
operator|(
name|USB_BUS_MAX
operator|*
name|USB_DEV_MAX
operator|*
name|USB_IFACE_MAX
operator|)
operator|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
name|ploc
operator|->
name|bus
operator|=
name|devclass_get_softc
argument_list|(
name|usb2_devclass_ptr
argument_list|,
name|ploc
operator|->
name|bus_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ploc
operator|->
name|bus
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"no bus at %u\n"
argument_list|,
name|ploc
operator|->
name|bus_index
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|ploc
operator|->
name|dev_index
operator|>=
name|ploc
operator|->
name|bus
operator|->
name|devices_max
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"invalid dev index, %u\n"
argument_list|,
name|ploc
operator|->
name|dev_index
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ploc
operator|->
name|udev
operator|=
name|ploc
operator|->
name|bus
operator|->
name|devices
index|[
name|ploc
operator|->
name|dev_index
index|]
expr_stmt|;
if|if
condition|(
name|ploc
operator|->
name|udev
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"no device at %u\n"
argument_list|,
name|ploc
operator|->
name|dev_index
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|ploc
operator|->
name|udev
operator|->
name|refcount
operator|==
name|USB_DEV_REF_MAX
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"no dev ref\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* check if we are doing an open */
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
comment|/* set defaults */
name|ploc
operator|->
name|txfifo
operator|=
name|NULL
expr_stmt|;
name|ploc
operator|->
name|rxfifo
operator|=
name|NULL
expr_stmt|;
name|ploc
operator|->
name|is_write
operator|=
literal|0
expr_stmt|;
name|ploc
operator|->
name|is_read
operator|=
literal|0
expr_stmt|;
name|ploc
operator|->
name|is_usbfs
operator|=
literal|0
expr_stmt|;
comment|/* NOTE: variable overloading: */
name|dev_ep_index
operator|=
name|ploc
operator|->
name|fifo_index
expr_stmt|;
block|}
else|else
block|{
comment|/* initialise "is_usbfs" flag */
name|ploc
operator|->
name|is_usbfs
operator|=
literal|0
expr_stmt|;
name|dev_ep_index
operator|=
literal|255
expr_stmt|;
comment|/* dummy */
comment|/* check for write */
if|if
condition|(
name|fflags
operator|&
name|FWRITE
condition|)
block|{
name|ppf
operator|=
name|ploc
operator|->
name|udev
operator|->
name|fifo
expr_stmt|;
name|f
operator|=
name|ppf
index|[
name|ploc
operator|->
name|fifo_index
operator|+
name|USB_FIFO_TX
index|]
expr_stmt|;
name|ploc
operator|->
name|txfifo
operator|=
name|f
expr_stmt|;
name|ploc
operator|->
name|is_write
operator|=
literal|1
expr_stmt|;
comment|/* ref */
if|if
condition|(
operator|(
name|f
operator|==
name|NULL
operator|)
operator|||
operator|(
name|f
operator|->
name|refcount
operator|==
name|USB_FIFO_REF_MAX
operator|)
operator|||
operator|(
name|f
operator|->
name|curr_file
operator|!=
name|fp
operator|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* check if USB-FS is active */
if|if
condition|(
name|f
operator|->
name|fs_ep_max
operator|!=
literal|0
condition|)
block|{
name|ploc
operator|->
name|is_usbfs
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 			 * Get real endpoint index associated with 			 * this FIFO: 			 */
name|dev_ep_index
operator|=
name|f
operator|->
name|dev_ep_index
expr_stmt|;
block|}
else|else
block|{
name|ploc
operator|->
name|txfifo
operator|=
name|NULL
expr_stmt|;
name|ploc
operator|->
name|is_write
operator|=
literal|0
expr_stmt|;
comment|/* no ref */
block|}
comment|/* check for read */
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
name|ppf
operator|=
name|ploc
operator|->
name|udev
operator|->
name|fifo
expr_stmt|;
name|f
operator|=
name|ppf
index|[
name|ploc
operator|->
name|fifo_index
operator|+
name|USB_FIFO_RX
index|]
expr_stmt|;
name|ploc
operator|->
name|rxfifo
operator|=
name|f
expr_stmt|;
name|ploc
operator|->
name|is_read
operator|=
literal|1
expr_stmt|;
comment|/* ref */
if|if
condition|(
operator|(
name|f
operator|==
name|NULL
operator|)
operator|||
operator|(
name|f
operator|->
name|refcount
operator|==
name|USB_FIFO_REF_MAX
operator|)
operator|||
operator|(
name|f
operator|->
name|curr_file
operator|!=
name|fp
operator|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* check if USB-FS is active */
if|if
condition|(
name|f
operator|->
name|fs_ep_max
operator|!=
literal|0
condition|)
block|{
name|ploc
operator|->
name|is_usbfs
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 			 * Get real endpoint index associated with 			 * this FIFO: 			 */
name|dev_ep_index
operator|=
name|f
operator|->
name|dev_ep_index
expr_stmt|;
block|}
else|else
block|{
name|ploc
operator|->
name|rxfifo
operator|=
name|NULL
expr_stmt|;
name|ploc
operator|->
name|is_read
operator|=
literal|0
expr_stmt|;
comment|/* no ref */
block|}
block|}
comment|/* check if we require an interface */
name|ploc
operator|->
name|iface
operator|=
name|usb2_get_iface
argument_list|(
name|ploc
operator|->
name|udev
argument_list|,
name|ploc
operator|->
name|iface_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_ep_index
operator|!=
literal|0
condition|)
block|{
comment|/* non control endpoint - we need an interface */
if|if
condition|(
name|ploc
operator|->
name|iface
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"no iface\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|ploc
operator|->
name|iface
operator|->
name|idesc
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"no idesc\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|/* when everything is OK we increment the refcounts */
if|if
condition|(
name|ploc
operator|->
name|is_write
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"ref write\n"
argument_list|)
expr_stmt|;
name|ploc
operator|->
name|txfifo
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ploc
operator|->
name|is_read
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"ref read\n"
argument_list|)
expr_stmt|;
name|ploc
operator|->
name|rxfifo
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ploc
operator|->
name|is_uref
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"ref udev - needed\n"
argument_list|)
expr_stmt|;
name|ploc
operator|->
name|udev
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ploc
operator|->
name|is_uref
condition|)
block|{
comment|/* 		 * We are about to alter the bus-state. Apply the 		 * required locks. 		 */
name|sx_xlock
argument_list|(
name|ploc
operator|->
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"fail\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_uref_location  *  * This function is used to upgrade an USB reference to include the  * USB device reference on a USB location.  *  * Return values:  *  0: Success, refcount incremented on the given USB device.  *  Else: Failure.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|usb2_error_t
name|usb2_uref_location
parameter_list|(
name|struct
name|usb2_location
modifier|*
name|ploc
parameter_list|)
block|{
comment|/* 	 * Check if we already got an USB reference on this location: 	 */
if|if
condition|(
name|ploc
operator|->
name|is_uref
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
name|mtx_lock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ploc
operator|->
name|bus
operator|!=
name|devclass_get_softc
argument_list|(
name|usb2_devclass_ptr
argument_list|,
name|ploc
operator|->
name|bus_index
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"bus changed at %u\n"
argument_list|,
name|ploc
operator|->
name|bus_index
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|ploc
operator|->
name|udev
operator|!=
name|ploc
operator|->
name|bus
operator|->
name|devices
index|[
name|ploc
operator|->
name|dev_index
index|]
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"device changed at %u\n"
argument_list|,
name|ploc
operator|->
name|dev_index
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|ploc
operator|->
name|udev
operator|->
name|refcount
operator|==
name|USB_DEV_REF_MAX
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"no dev ref\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"ref udev\n"
argument_list|)
expr_stmt|;
name|ploc
operator|->
name|udev
operator|->
name|refcount
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
comment|/* set "uref" */
name|ploc
operator|->
name|is_uref
operator|=
literal|1
expr_stmt|;
comment|/* 	 * We are about to alter the bus-state. Apply the 	 * required locks. 	 */
name|sx_xlock
argument_list|(
name|ploc
operator|->
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"fail\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_unref_device  *  * This function will release the reference count by one unit for the  * given USB device.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb2_unref_device
parameter_list|(
name|struct
name|usb2_location
modifier|*
name|ploc
parameter_list|)
block|{
if|if
condition|(
name|ploc
operator|->
name|is_uref
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* XXX */
name|sx_unlock
argument_list|(
name|ploc
operator|->
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ploc
operator|->
name|is_read
condition|)
block|{
if|if
condition|(
operator|--
operator|(
name|ploc
operator|->
name|rxfifo
operator|->
name|refcount
operator|)
operator|==
literal|0
condition|)
block|{
name|usb2_cv_signal
argument_list|(
operator|&
name|ploc
operator|->
name|rxfifo
operator|->
name|cv_drain
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ploc
operator|->
name|is_write
condition|)
block|{
if|if
condition|(
operator|--
operator|(
name|ploc
operator|->
name|txfifo
operator|->
name|refcount
operator|)
operator|==
literal|0
condition|)
block|{
name|usb2_cv_signal
argument_list|(
operator|&
name|ploc
operator|->
name|txfifo
operator|->
name|cv_drain
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ploc
operator|->
name|is_uref
condition|)
block|{
if|if
condition|(
operator|--
operator|(
name|ploc
operator|->
name|udev
operator|->
name|refcount
operator|)
operator|==
literal|0
condition|)
block|{
name|usb2_cv_signal
argument_list|(
name|ploc
operator|->
name|udev
operator|->
name|default_cv
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|usb2_fifo
modifier|*
name|usb2_fifo_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|usb2_fifo
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|usb2_cv_init
argument_list|(
operator|&
name|f
operator|->
name|cv_io
argument_list|,
literal|"FIFO-IO"
argument_list|)
expr_stmt|;
name|usb2_cv_init
argument_list|(
operator|&
name|f
operator|->
name|cv_drain
argument_list|,
literal|"FIFO-DRAIN"
argument_list|)
expr_stmt|;
name|f
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_fifo_create  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb2_fifo_create
parameter_list|(
name|struct
name|usb2_location
modifier|*
name|ploc
parameter_list|,
name|uint32_t
modifier|*
name|pdevloc
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
name|struct
name|usb2_device
modifier|*
name|udev
init|=
name|ploc
operator|->
name|udev
decl_stmt|;
name|struct
name|usb2_fifo
modifier|*
name|f
decl_stmt|;
name|struct
name|usb2_pipe
modifier|*
name|pipe
decl_stmt|;
name|uint8_t
name|iface_index
init|=
name|ploc
operator|->
name|iface_index
decl_stmt|;
comment|/* NOTE: variable overloading: */
name|uint8_t
name|dev_ep_index
init|=
name|ploc
operator|->
name|fifo_index
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|uint8_t
name|is_tx
decl_stmt|;
name|uint8_t
name|is_rx
decl_stmt|;
name|uint8_t
name|no_null
decl_stmt|;
name|uint8_t
name|is_busy
decl_stmt|;
name|is_tx
operator|=
operator|(
name|fflags
operator|&
name|FWRITE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|is_rx
operator|=
operator|(
name|fflags
operator|&
name|FREAD
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|no_null
operator|=
literal|1
expr_stmt|;
name|is_busy
operator|=
literal|0
expr_stmt|;
comment|/* search for a free FIFO slot */
for|for
control|(
name|n
operator|=
literal|0
init|;
condition|;
name|n
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|n
operator|==
name|USB_FIFO_MAX
condition|)
block|{
if|if
condition|(
name|no_null
condition|)
block|{
name|no_null
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* end of FIFOs reached */
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
comment|/* Check for TX FIFO */
if|if
condition|(
name|is_tx
condition|)
block|{
name|f
operator|=
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_TX
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|dev_ep_index
operator|!=
name|dev_ep_index
condition|)
block|{
comment|/* wrong endpoint index */
continue|continue;
block|}
if|if
condition|(
operator|(
name|dev_ep_index
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|f
operator|->
name|iface_index
operator|!=
name|iface_index
operator|)
condition|)
block|{
comment|/* wrong interface index */
continue|continue;
block|}
if|if
condition|(
name|f
operator|->
name|curr_file
operator|!=
name|NULL
condition|)
block|{
comment|/* FIFO is opened */
name|is_busy
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|no_null
condition|)
block|{
continue|continue;
block|}
block|}
comment|/* Check for RX FIFO */
if|if
condition|(
name|is_rx
condition|)
block|{
name|f
operator|=
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_RX
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|dev_ep_index
operator|!=
name|dev_ep_index
condition|)
block|{
comment|/* wrong endpoint index */
continue|continue;
block|}
if|if
condition|(
operator|(
name|dev_ep_index
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|f
operator|->
name|iface_index
operator|!=
name|iface_index
operator|)
condition|)
block|{
comment|/* wrong interface index */
continue|continue;
block|}
if|if
condition|(
name|f
operator|->
name|curr_file
operator|!=
name|NULL
condition|)
block|{
comment|/* FIFO is opened */
name|is_busy
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|no_null
condition|)
block|{
continue|continue;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|no_null
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dev_ep_index
operator|>=
operator|(
name|USB_EP_MAX
operator|/
literal|2
operator|)
condition|)
block|{
comment|/* we don't create any endpoints in this range */
return|return
operator|(
name|is_busy
condition|?
name|EBUSY
else|:
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* Check TX FIFO */
if|if
condition|(
name|is_tx
operator|&&
operator|(
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_TX
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
name|pipe
operator|=
name|usb2_dev_get_pipe
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|,
name|dev_ep_index
argument_list|,
name|USB_FIFO_TX
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|f
operator|=
name|usb2_fifo_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* update some fields */
name|f
operator|->
name|fifo_index
operator|=
name|n
operator|+
name|USB_FIFO_TX
expr_stmt|;
name|f
operator|->
name|dev_ep_index
operator|=
name|dev_ep_index
expr_stmt|;
name|f
operator|->
name|priv_mtx
operator|=
name|udev
operator|->
name|default_mtx
expr_stmt|;
name|f
operator|->
name|priv_sc0
operator|=
name|pipe
expr_stmt|;
name|f
operator|->
name|methods
operator|=
operator|&
name|usb2_ugen_methods
expr_stmt|;
name|f
operator|->
name|iface_index
operator|=
name|iface_index
expr_stmt|;
name|f
operator|->
name|udev
operator|=
name|udev
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_TX
index|]
operator|=
name|f
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
block|}
comment|/* Check RX FIFO */
if|if
condition|(
name|is_rx
operator|&&
operator|(
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_RX
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
name|pipe
operator|=
name|usb2_dev_get_pipe
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|,
name|dev_ep_index
argument_list|,
name|USB_FIFO_RX
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|f
operator|=
name|usb2_fifo_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* update some fields */
name|f
operator|->
name|fifo_index
operator|=
name|n
operator|+
name|USB_FIFO_RX
expr_stmt|;
name|f
operator|->
name|dev_ep_index
operator|=
name|dev_ep_index
expr_stmt|;
name|f
operator|->
name|priv_mtx
operator|=
name|udev
operator|->
name|default_mtx
expr_stmt|;
name|f
operator|->
name|priv_sc0
operator|=
name|pipe
expr_stmt|;
name|f
operator|->
name|methods
operator|=
operator|&
name|usb2_ugen_methods
expr_stmt|;
name|f
operator|->
name|iface_index
operator|=
name|iface_index
expr_stmt|;
name|f
operator|->
name|udev
operator|=
name|udev
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_RX
index|]
operator|=
name|f
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_tx
condition|)
block|{
name|ploc
operator|->
name|txfifo
operator|=
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_TX
index|]
expr_stmt|;
block|}
if|if
condition|(
name|is_rx
condition|)
block|{
name|ploc
operator|->
name|rxfifo
operator|=
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_RX
index|]
expr_stmt|;
block|}
comment|/* replace endpoint index by FIFO index */
operator|(
operator|*
name|pdevloc
operator|)
operator|%=
operator|(
name|USB_BUS_MAX
operator|*
name|USB_DEV_MAX
operator|*
name|USB_IFACE_MAX
operator|)
expr_stmt|;
operator|(
operator|*
name|pdevloc
operator|)
operator|+=
operator|(
name|USB_BUS_MAX
operator|*
name|USB_DEV_MAX
operator|*
name|USB_IFACE_MAX
operator|)
operator|*
name|n
expr_stmt|;
comment|/* complete */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usb2_fifo_free
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|)
block|{
name|uint8_t
name|n
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* be NULL safe */
return|return;
block|}
comment|/* destroy symlink devices, if any */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
literal|2
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|f
operator|->
name|symlink
index|[
name|n
index|]
condition|)
block|{
name|usb2_free_symlink
argument_list|(
name|f
operator|->
name|symlink
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|f
operator|->
name|symlink
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
comment|/* delink ourselves to stop calls from userland */
if|if
condition|(
operator|(
name|f
operator|->
name|fifo_index
operator|<
name|USB_FIFO_MAX
operator|)
operator|&&
operator|(
name|f
operator|->
name|udev
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|f
operator|->
name|udev
operator|->
name|fifo
index|[
name|f
operator|->
name|fifo_index
index|]
operator|==
name|f
operator|)
condition|)
block|{
name|f
operator|->
name|udev
operator|->
name|fifo
index|[
name|f
operator|->
name|fifo_index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"USB FIFO %p has not been linked!\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* decrease refcount */
name|f
operator|->
name|refcount
operator|--
expr_stmt|;
comment|/* prevent any write flush */
name|f
operator|->
name|flag_iserror
operator|=
literal|1
expr_stmt|;
comment|/* need to wait until all callers have exited */
while|while
condition|(
name|f
operator|->
name|refcount
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
comment|/* avoid LOR */
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
comment|/* get I/O thread out of any sleep state */
if|if
condition|(
name|f
operator|->
name|flag_sleeping
condition|)
block|{
name|f
operator|->
name|flag_sleeping
operator|=
literal|0
expr_stmt|;
name|usb2_cv_broadcast
argument_list|(
operator|&
name|f
operator|->
name|cv_io
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
comment|/* wait for sync */
name|usb2_cv_wait
argument_list|(
operator|&
name|f
operator|->
name|cv_drain
argument_list|,
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
comment|/* take care of closing the device here, if any */
name|usb2_fifo_close
argument_list|(
name|f
argument_list|,
name|curthread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usb2_cv_destroy
argument_list|(
operator|&
name|f
operator|->
name|cv_io
argument_list|)
expr_stmt|;
name|usb2_cv_destroy
argument_list|(
operator|&
name|f
operator|->
name|cv_drain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|usb2_pipe
modifier|*
name|usb2_dev_get_pipe
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|ep_index
parameter_list|,
name|uint8_t
name|dir
parameter_list|)
block|{
name|struct
name|usb2_pipe
modifier|*
name|pipe
decl_stmt|;
name|uint8_t
name|ep_dir
decl_stmt|;
if|if
condition|(
name|ep_index
operator|==
literal|0
condition|)
block|{
name|pipe
operator|=
operator|&
name|udev
operator|->
name|default_pipe
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dir
operator|==
name|USB_FIFO_RX
condition|)
block|{
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb2_mode
operator|==
name|USB_MODE_HOST
condition|)
block|{
name|ep_dir
operator|=
name|UE_DIR_IN
expr_stmt|;
block|}
else|else
block|{
name|ep_dir
operator|=
name|UE_DIR_OUT
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb2_mode
operator|==
name|USB_MODE_HOST
condition|)
block|{
name|ep_dir
operator|=
name|UE_DIR_OUT
expr_stmt|;
block|}
else|else
block|{
name|ep_dir
operator|=
name|UE_DIR_IN
expr_stmt|;
block|}
block|}
name|pipe
operator|=
name|usb2_get_pipe_by_addr
argument_list|(
name|udev
argument_list|,
name|ep_index
operator||
name|ep_dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipe
operator|==
name|NULL
condition|)
block|{
comment|/* if the pipe does not exist then return */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|pipe
operator|->
name|edesc
operator|==
name|NULL
condition|)
block|{
comment|/* invalid pipe */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|ep_index
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pipe
operator|->
name|iface_index
operator|!=
name|iface_index
condition|)
block|{
comment|/* 			 * Permissions violation - trying to access a 			 * pipe that does not belong to the interface. 			 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|pipe
operator|)
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_fifo_open  *  * Returns:  * 0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb2_fifo_open
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|,
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* no FIFO there */
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"no FIFO\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* remove FWRITE and FREAD flags */
name|fflags
operator|&=
operator|~
operator|(
name|FWRITE
operator||
name|FREAD
operator|)
expr_stmt|;
comment|/* set correct file flags */
if|if
condition|(
operator|(
name|f
operator|->
name|fifo_index
operator|&
literal|1
operator|)
operator|==
name|USB_FIFO_TX
condition|)
block|{
name|fflags
operator||=
name|FWRITE
expr_stmt|;
block|}
else|else
block|{
name|fflags
operator||=
name|FREAD
expr_stmt|;
block|}
comment|/* check if we are already opened */
comment|/* we don't need any locks when checking this variable */
if|if
condition|(
name|f
operator|->
name|curr_file
condition|)
block|{
name|err
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* call open method */
name|err
operator|=
call|(
name|f
operator|->
name|methods
operator|->
name|f_open
call|)
argument_list|(
name|f
argument_list|,
name|fflags
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
comment|/* reset sleep flag */
name|f
operator|->
name|flag_sleeping
operator|=
literal|0
expr_stmt|;
comment|/* reset error flag */
name|f
operator|->
name|flag_iserror
operator|=
literal|0
expr_stmt|;
comment|/* reset complete flag */
name|f
operator|->
name|flag_iscomplete
operator|=
literal|0
expr_stmt|;
comment|/* reset select flag */
name|f
operator|->
name|flag_isselect
operator|=
literal|0
expr_stmt|;
comment|/* reset flushing flag */
name|f
operator|->
name|flag_flushing
operator|=
literal|0
expr_stmt|;
comment|/* reset ASYNC proc flag */
name|f
operator|->
name|async_p
operator|=
name|NULL
expr_stmt|;
comment|/* set which file we belong to */
name|mtx_lock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
name|f
operator|->
name|curr_file
operator|=
name|fp
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
comment|/* reset queue */
name|usb2_fifo_reset
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
name|done
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_fifo_reset  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb2_fifo_reset
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|usb2_mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_fifo_close  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb2_fifo_close
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* check if we are not opened */
if|if
condition|(
operator|!
name|f
operator|->
name|curr_file
condition|)
block|{
comment|/* nothing to do - already closed */
return|return;
block|}
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
comment|/* clear current file flag */
name|f
operator|->
name|curr_file
operator|=
name|NULL
expr_stmt|;
comment|/* check if we are selected */
if|if
condition|(
name|f
operator|->
name|flag_isselect
condition|)
block|{
name|selwakeup
argument_list|(
operator|&
name|f
operator|->
name|selinfo
argument_list|)
expr_stmt|;
name|f
operator|->
name|flag_isselect
operator|=
literal|0
expr_stmt|;
block|}
comment|/* check if a thread wants SIGIO */
if|if
condition|(
name|f
operator|->
name|async_p
operator|!=
name|NULL
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|f
operator|->
name|async_p
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|f
operator|->
name|async_p
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|f
operator|->
name|async_p
argument_list|)
expr_stmt|;
name|f
operator|->
name|async_p
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* remove FWRITE and FREAD flags */
name|fflags
operator|&=
operator|~
operator|(
name|FWRITE
operator||
name|FREAD
operator|)
expr_stmt|;
comment|/* flush written data, if any */
if|if
condition|(
operator|(
name|f
operator|->
name|fifo_index
operator|&
literal|1
operator|)
operator|==
name|USB_FIFO_TX
condition|)
block|{
if|if
condition|(
operator|!
name|f
operator|->
name|flag_iserror
condition|)
block|{
comment|/* set flushing flag */
name|f
operator|->
name|flag_flushing
operator|=
literal|1
expr_stmt|;
comment|/* start write transfer, if not already started */
call|(
name|f
operator|->
name|methods
operator|->
name|f_start_write
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* check if flushed already */
while|while
condition|(
name|f
operator|->
name|flag_flushing
operator|&&
operator|(
operator|!
name|f
operator|->
name|flag_iserror
operator|)
condition|)
block|{
comment|/* wait until all data has been written */
name|f
operator|->
name|flag_sleeping
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|usb2_cv_wait_sig
argument_list|(
operator|&
name|f
operator|->
name|cv_io
argument_list|,
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"signal received\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|fflags
operator||=
name|FWRITE
expr_stmt|;
comment|/* stop write transfer, if not already stopped */
call|(
name|f
operator|->
name|methods
operator|->
name|f_stop_write
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fflags
operator||=
name|FREAD
expr_stmt|;
comment|/* stop write transfer, if not already stopped */
call|(
name|f
operator|->
name|methods
operator|->
name|f_stop_read
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* check if we are sleeping */
if|if
condition|(
name|f
operator|->
name|flag_sleeping
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"Sleeping at close!\n"
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
comment|/* call close method */
call|(
name|f
operator|->
name|methods
operator|->
name|f_close
call|)
argument_list|(
name|f
argument_list|,
name|fflags
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"closed\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_check_thread_perm  *  * Returns:  * 0: Has permission.  * Else: No permission.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb2_check_thread_perm
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fflags
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|ep_index
parameter_list|)
block|{
name|struct
name|usb2_interface
modifier|*
name|iface
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|ep_index
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Non-control endpoints are always 		 * associated with an interface: 		 */
name|iface
operator|=
name|usb2_get_iface
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|iface
operator|->
name|idesc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
name|iface
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* scan down the permissions tree */
if|if
condition|(
operator|(
name|iface
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|usb2_check_access
argument_list|(
name|fflags
argument_list|,
operator|&
name|iface
operator|->
name|perm
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* we got access through the interface */
name|err
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udev
operator|&&
operator|(
name|usb2_check_access
argument_list|(
name|fflags
argument_list|,
operator|&
name|udev
operator|->
name|perm
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* we got access through the device */
name|err
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udev
operator|->
name|bus
operator|&&
operator|(
name|usb2_check_access
argument_list|(
name|fflags
argument_list|,
operator|&
name|udev
operator|->
name|bus
operator|->
name|perm
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* we got access through the USB bus */
name|err
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usb2_check_access
argument_list|(
name|fflags
argument_list|,
operator|&
name|usb2_perm
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* we got general access */
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* no access */
name|err
operator|=
name|EPERM
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_fdopen - cdev callback  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb2_fdopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|xxx_oflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|usb2_location
name|loc
decl_stmt|;
name|uint32_t
name|devloc
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|fflags
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"oflags=0x%08x\n"
argument_list|,
name|xxx_oflags
argument_list|)
expr_stmt|;
name|devloc
operator|=
name|usb2_last_devloc
expr_stmt|;
name|usb2_last_devloc
operator|=
operator|(
literal|0
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* reset "usb2_last_devloc" */
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"fp == NULL\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|usb2_old_f_data
operator|!=
name|fp
operator|->
name|f_data
condition|)
block|{
if|if
condition|(
name|usb2_old_f_data
operator|!=
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"File data mismatch!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|usb2_old_f_data
operator|=
name|fp
operator|->
name|f_data
expr_stmt|;
block|}
if|if
condition|(
name|usb2_old_f_ops
operator|!=
name|fp
operator|->
name|f_ops
condition|)
block|{
if|if
condition|(
name|usb2_old_f_ops
operator|!=
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"File ops mismatch!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|usb2_old_f_ops
operator|=
name|fp
operator|->
name|f_ops
expr_stmt|;
block|}
name|fflags
operator|=
name|fp
operator|->
name|f_flag
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"fflags=0x%08x\n"
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fflags
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
operator|)
condition|)
block|{
comment|/* should not happen */
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
name|devloc
operator|==
call|(
name|uint32_t
call|)
argument_list|(
literal|0
operator|-
literal|2
argument_list|)
condition|)
block|{
comment|/* tried to open "/dev/usb" */
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|devloc
operator|==
call|(
name|uint32_t
call|)
argument_list|(
literal|0
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* tried to open "/dev/usb " */
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"no devloc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|err
operator|=
name|usb2_ref_device
argument_list|(
name|NULL
argument_list|,
operator|&
name|loc
argument_list|,
name|devloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"cannot ref device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * NOTE: Variable overloading. "usb2_fifo_create" will update 	 * the FIFO index. Right here we can assume that the 	 * "fifo_index" is the same like the endpoint number without 	 * direction mask, if the "fifo_index" is less than 16. 	 */
name|err
operator|=
name|usb2_check_thread_perm
argument_list|(
name|loc
operator|.
name|udev
argument_list|,
name|td
argument_list|,
name|fflags
argument_list|,
name|loc
operator|.
name|iface_index
argument_list|,
name|loc
operator|.
name|fifo_index
argument_list|)
expr_stmt|;
comment|/* check for error */
if|if
condition|(
name|err
condition|)
block|{
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* create FIFOs, if any */
name|err
operator|=
name|usb2_fifo_create
argument_list|(
operator|&
name|loc
argument_list|,
operator|&
name|devloc
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
comment|/* check for error */
if|if
condition|(
name|err
condition|)
block|{
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
name|err
operator|=
name|usb2_fifo_open
argument_list|(
name|loc
operator|.
name|rxfifo
argument_list|,
name|fp
argument_list|,
name|td
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"read open failed\n"
argument_list|)
expr_stmt|;
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fflags
operator|&
name|FWRITE
condition|)
block|{
name|err
operator|=
name|usb2_fifo_open
argument_list|(
name|loc
operator|.
name|txfifo
argument_list|,
name|fp
argument_list|,
name|td
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"write open failed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
name|usb2_fifo_close
argument_list|(
name|loc
operator|.
name|rxfifo
argument_list|,
name|td
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
block|}
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
comment|/* 	 * Take over the file so that we get all the callbacks 	 * directly and don't have to create another device: 	 */
name|finit
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|f_flag
argument_list|,
name|DTYPE_VNODE
argument_list|,
operator|(
operator|(
name|uint8_t
operator|*
operator|)
literal|0
operator|)
operator|+
name|devloc
argument_list|,
operator|&
name|usb2_ops_f
argument_list|)
expr_stmt|;
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"error=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_close - cdev callback  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb2_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nothing to do */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_close - cdev callback  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb2_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
union|union
block|{
name|struct
name|usb2_read_dir
modifier|*
name|urd
decl_stmt|;
name|struct
name|usb2_dev_perm
modifier|*
name|udp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|}
name|u
union|;
name|int
name|err
decl_stmt|;
name|u
operator|.
name|data
operator|=
name|data
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|USB_READ_DIR
case|:
name|err
operator|=
name|usb2_read_symlink
argument_list|(
name|u
operator|.
name|urd
operator|->
name|urd_data
argument_list|,
name|u
operator|.
name|urd
operator|->
name|urd_startentry
argument_list|,
name|u
operator|.
name|urd
operator|->
name|urd_maxlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_SET_IFACE_PERM
case|:
name|err
operator|=
name|usb2_set_perm
argument_list|(
name|u
operator|.
name|udp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_SET_DEVICE_PERM
case|:
name|err
operator|=
name|usb2_set_perm
argument_list|(
name|u
operator|.
name|udp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_SET_BUS_PERM
case|:
name|err
operator|=
name|usb2_set_perm
argument_list|(
name|u
operator|.
name|udp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_SET_ROOT_PERM
case|:
name|err
operator|=
name|usb2_set_perm
argument_list|(
name|u
operator|.
name|udp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_GET_IFACE_PERM
case|:
name|err
operator|=
name|usb2_get_perm
argument_list|(
name|u
operator|.
name|udp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_GET_DEVICE_PERM
case|:
name|err
operator|=
name|usb2_get_perm
argument_list|(
name|u
operator|.
name|udp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_GET_BUS_PERM
case|:
name|err
operator|=
name|usb2_get_perm
argument_list|(
name|u
operator|.
name|udp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_GET_ROOT_PERM
case|:
name|err
operator|=
name|usb2_get_perm
argument_list|(
name|u
operator|.
name|udp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_DEV_QUIRK_GET
case|:
case|case
name|USB_QUIRK_NAME_GET
case|:
case|case
name|USB_DEV_QUIRK_ADD
case|:
case|case
name|USB_DEV_QUIRK_REMOVE
case|:
name|err
operator|=
name|usb2_quirk_ioctl_p
argument_list|(
name|cmd
argument_list|,
name|data
argument_list|,
name|fflag
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_GET_TEMPLATE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|usb2_template
expr_stmt|;
break|break;
case|case
name|USB_SET_TEMPLATE
case|:
name|err
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_ROOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|usb2_template
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *      usb2_clone - cdev callback  *  * This function is the kernel clone callback for "/dev/usbX.Y".  *  * NOTE: This function assumes that the clone and device open  * operation is atomic.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb2_clone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|USB_UCRED
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|cdev
modifier|*
modifier|*
name|dev
parameter_list|)
block|{
enum|enum
block|{
name|USB_DNAME_LEN
init|=
sizeof|sizeof
argument_list|(
name|USB_DEVICE_NAME
argument_list|)
operator|-
literal|1
block|,
name|USB_GNAME_LEN
init|=
sizeof|sizeof
argument_list|(
name|USB_GENERIC_NAME
argument_list|)
operator|-
literal|1
block|, 	}
enum|;
if|if
condition|(
operator|*
name|dev
condition|)
block|{
comment|/* someone else has created a device */
return|return;
block|}
comment|/* reset device location */
name|usb2_last_devloc
operator|=
call|(
name|uint32_t
call|)
argument_list|(
literal|0
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we are matching "usb", "ugen" or an internal 	 * symbolic link: 	 */
if|if
condition|(
operator|(
name|namelen
operator|>=
name|USB_DNAME_LEN
operator|)
operator|&&
operator|(
name|bcmp
argument_list|(
name|name
argument_list|,
name|USB_DEVICE_NAME
argument_list|,
name|USB_DNAME_LEN
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|namelen
operator|==
name|USB_DNAME_LEN
condition|)
block|{
comment|/* USB management device location */
name|usb2_last_devloc
operator|=
call|(
name|uint32_t
call|)
argument_list|(
literal|0
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* USB endpoint */
name|usb2_last_devloc
operator|=
name|usb2_path_convert
argument_list|(
name|name
operator|+
name|USB_DNAME_LEN
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|namelen
operator|>=
name|USB_GNAME_LEN
operator|)
operator|&&
operator|(
name|bcmp
argument_list|(
name|name
argument_list|,
name|USB_GENERIC_NAME
argument_list|,
name|USB_GNAME_LEN
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|namelen
operator|==
name|USB_GNAME_LEN
condition|)
block|{
comment|/* USB management device location */
name|usb2_last_devloc
operator|=
call|(
name|uint32_t
call|)
argument_list|(
literal|0
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* USB endpoint */
name|usb2_last_devloc
operator|=
name|usb2_path_convert
argument_list|(
name|name
operator|+
name|USB_GNAME_LEN
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usb2_last_devloc
operator|==
call|(
name|uint32_t
call|)
argument_list|(
literal|0
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* Search for symbolic link */
name|usb2_last_devloc
operator|=
name|usb2_lookup_symlink
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usb2_last_devloc
operator|==
call|(
name|uint32_t
call|)
argument_list|(
literal|0
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* invalid location */
return|return;
block|}
name|dev_ref
argument_list|(
name|usb2_dev
argument_list|)
expr_stmt|;
operator|*
name|dev
operator|=
name|usb2_dev
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usb2_dev_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|,
literal|"USB ref mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|usb2_sym_lock
argument_list|,
literal|"USB sym mutex"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|usb2_sym_head
argument_list|)
expr_stmt|;
comment|/* check the UGEN methods */
name|usb2_fifo_check_methods
argument_list|(
operator|&
name|usb2_ugen_methods
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|usb2_dev_init
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|usb2_dev_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|usb2_dev_init_post
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* 	 * Create a dummy device so that we are visible. This device 	 * should never be opened. Therefore a space character is 	 * appended after the USB device name. 	 * 	 * NOTE: The permissions of this device is 0666, because we 	 * check the permissions again in the open routine against the 	 * real USB permissions which are not 0666. Else USB access 	 * will be limited to one user and one group. 	 */
name|usb2_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|usb2_devsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0666
argument_list|,
name|USB_DEVICE_NAME
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb2_dev
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Could not create usb bus device!\n"
argument_list|)
expr_stmt|;
block|}
name|usb2_clone_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_clone
argument_list|,
name|usb2_clone_ptr
argument_list|,
name|NULL
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb2_clone_tag
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Registering clone handler failed!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|usb2_dev_init_post
argument_list|,
name|SI_SUB_KICK_SCHEDULER
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|usb2_dev_init_post
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|usb2_dev_uninit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|usb2_clone_tag
condition|)
block|{
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|dev_clone
argument_list|,
name|usb2_clone_tag
argument_list|)
expr_stmt|;
name|usb2_clone_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|usb2_dev
condition|)
block|{
name|destroy_dev
argument_list|(
name|usb2_dev
argument_list|)
expr_stmt|;
name|usb2_dev
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|usb2_sym_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|usb2_dev_uninit
argument_list|,
name|SI_SUB_KICK_SCHEDULER
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|usb2_dev_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|usb2_close_f
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb2_location
name|loc
decl_stmt|;
name|int
name|fflags
decl_stmt|;
name|int
name|err
decl_stmt|;
name|fflags
operator|=
name|fp
operator|->
name|f_flag
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"fflags=%u\n"
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb2_ref_device
argument_list|(
name|fp
argument_list|,
operator|&
name|loc
argument_list|,
literal|0
comment|/* need uref */
argument_list|)
expr_stmt|;
empty_stmt|;
comment|/* restore some file variables */
name|fp
operator|->
name|f_ops
operator|=
name|usb2_old_f_ops
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
name|usb2_old_f_data
expr_stmt|;
comment|/* check for error */
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"could not ref\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
name|usb2_fifo_close
argument_list|(
name|loc
operator|.
name|rxfifo
argument_list|,
name|td
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflags
operator|&
name|FWRITE
condition|)
block|{
name|usb2_fifo_close
argument_list|(
name|loc
operator|.
name|txfifo
argument_list|,
name|td
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
block|}
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* call old close method */
name|USB_VNOPS_FO_CLOSE
argument_list|(
name|fp
argument_list|,
name|td
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb2_ioctl_f_sub
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIODTYPE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* character device */
break|break;
case|case
name|FIONBIO
case|:
comment|/* handled by upper FS layer */
break|break;
case|case
name|FIOASYNC
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|async_p
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|f
operator|->
name|async_p
operator|=
name|USB_TD_GET_PROC
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|->
name|async_p
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
comment|/* XXX this is not the most general solution */
case|case
name|TIOCSPGRP
case|:
if|if
condition|(
name|f
operator|->
name|async_p
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|!=
name|USB_PROC_GET_GID
argument_list|(
name|f
operator|->
name|async_p
argument_list|)
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
break|break;
default|default:
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb2_ioctl_f
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb2_location
name|loc
decl_stmt|;
name|struct
name|usb2_fifo
modifier|*
name|f
decl_stmt|;
name|int
name|fflags
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|usb2_ref_device
argument_list|(
name|fp
argument_list|,
operator|&
name|loc
argument_list|,
literal|1
comment|/* no uref */
argument_list|)
expr_stmt|;
empty_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|fflags
operator|=
name|fp
operator|->
name|f_flag
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"fflags=%u, cmd=0x%lx\n"
argument_list|,
name|fflags
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|f
operator|=
name|NULL
expr_stmt|;
comment|/* set default value */
name|err
operator|=
name|ENOIOCTL
expr_stmt|;
comment|/* set default value */
if|if
condition|(
name|fflags
operator|&
name|FWRITE
condition|)
block|{
name|f
operator|=
name|loc
operator|.
name|txfifo
expr_stmt|;
name|err
operator|=
name|usb2_ioctl_f_sub
argument_list|(
name|f
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
name|f
operator|=
name|loc
operator|.
name|rxfifo
expr_stmt|;
name|err
operator|=
name|usb2_ioctl_f_sub
argument_list|(
name|f
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|ENOIOCTL
condition|)
block|{
name|err
operator|=
call|(
name|f
operator|->
name|methods
operator|->
name|f_ioctl
call|)
argument_list|(
name|f
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|fflags
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOIOCTL
condition|)
block|{
if|if
condition|(
name|usb2_uref_location
argument_list|(
operator|&
name|loc
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|err
operator|=
call|(
name|f
operator|->
name|methods
operator|->
name|f_ioctl_post
call|)
argument_list|(
name|f
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|fflags
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|==
name|ENOIOCTL
condition|)
block|{
name|err
operator|=
name|ENOTTY
expr_stmt|;
block|}
name|done
label|:
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|usb2_kqfilter_f
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|usb2_poll_f
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb2_location
name|loc
decl_stmt|;
name|struct
name|usb2_fifo
modifier|*
name|f
decl_stmt|;
name|struct
name|usb2_mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|fflags
decl_stmt|;
name|int
name|revents
decl_stmt|;
name|revents
operator|=
name|usb2_ref_device
argument_list|(
name|fp
argument_list|,
operator|&
name|loc
argument_list|,
literal|1
comment|/* no uref */
argument_list|)
expr_stmt|;
empty_stmt|;
if|if
condition|(
name|revents
condition|)
block|{
return|return
operator|(
name|POLLHUP
operator|)
return|;
block|}
name|fflags
operator|=
name|fp
operator|->
name|f_flag
expr_stmt|;
comment|/* Figure out who needs service */
if|if
condition|(
operator|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
operator|&&
operator|(
name|fflags
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|f
operator|=
name|loc
operator|.
name|txfifo
expr_stmt|;
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loc
operator|.
name|is_usbfs
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|flag_iserror
condition|)
block|{
comment|/* we got an error */
name|m
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|f
operator|->
name|queue_data
operator|==
name|NULL
condition|)
block|{
comment|/* 					 * start write transfer, if not 					 * already started 					 */
call|(
name|f
operator|->
name|methods
operator|->
name|f_start_write
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* check if any packets are available */
name|USB_IF_POLL
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|f
operator|->
name|flag_iscomplete
condition|)
block|{
name|m
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
condition|)
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|->
name|flag_isselect
operator|=
literal|1
expr_stmt|;
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|f
operator|->
name|selinfo
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
operator|&&
operator|(
name|fflags
operator|&
name|FREAD
operator|)
condition|)
block|{
name|f
operator|=
name|loc
operator|.
name|rxfifo
expr_stmt|;
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loc
operator|.
name|is_usbfs
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|flag_iserror
condition|)
block|{
comment|/* we have and error */
name|m
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|f
operator|->
name|queue_data
operator|==
name|NULL
condition|)
block|{
comment|/* 					 * start read transfer, if not 					 * already started 					 */
call|(
name|f
operator|->
name|methods
operator|->
name|f_start_read
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* check if any packets are available */
name|USB_IF_POLL
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|f
operator|->
name|flag_iscomplete
condition|)
block|{
name|m
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
condition|)
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|->
name|flag_isselect
operator|=
literal|1
expr_stmt|;
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|f
operator|->
name|selinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loc
operator|.
name|is_usbfs
condition|)
block|{
comment|/* start reading data */
call|(
name|f
operator|->
name|methods
operator|->
name|f_start_read
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
block|}
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|usb2_read_f
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb2_location
name|loc
decl_stmt|;
name|struct
name|usb2_fifo
modifier|*
name|f
decl_stmt|;
name|struct
name|usb2_mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|fflags
decl_stmt|;
name|int
name|resid
decl_stmt|;
name|int
name|io_len
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint8_t
name|tr_data
init|=
literal|0
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflags
operator|=
name|fp
operator|->
name|f_flag
operator|&
operator|(
name|O_NONBLOCK
operator||
name|O_DIRECT
operator||
name|FREAD
operator||
name|FWRITE
operator|)
expr_stmt|;
if|if
condition|(
name|fflags
operator|&
name|O_DIRECT
condition|)
name|fflags
operator||=
name|IO_DIRECT
expr_stmt|;
name|err
operator|=
name|usb2_ref_device
argument_list|(
name|fp
argument_list|,
operator|&
name|loc
argument_list|,
literal|1
comment|/* no uref */
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|f
operator|=
name|loc
operator|.
name|rxfifo
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* should not happen */
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FOF_OFFSET
operator|)
operator|==
literal|0
condition|)
name|uio
operator|->
name|uio_offset
operator|=
name|fp
operator|->
name|f_offset
expr_stmt|;
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
comment|/* check for permanent read error */
if|if
condition|(
name|f
operator|->
name|flag_iserror
condition|)
block|{
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* check if USB-FS interface is active */
if|if
condition|(
name|loc
operator|.
name|is_usbfs
condition|)
block|{
comment|/* 		 * The queue is used for events that should be 		 * retrieved using the "USB_FS_COMPLETE" ioctl. 		 */
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* start read transfer, if not already started */
call|(
name|f
operator|->
name|methods
operator|->
name|f_start_read
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflags
operator|&
name|O_NONBLOCK
condition|)
block|{
if|if
condition|(
name|tr_data
condition|)
block|{
comment|/* return length before error */
break|break;
block|}
name|err
operator|=
name|EWOULDBLOCK
expr_stmt|;
break|break;
block|}
name|DPRINTF
argument_list|(
literal|"sleeping\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb2_fifo_wait
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
name|f
operator|->
name|methods
operator|->
name|f_filter_read
condition|)
block|{
comment|/* 			 * Sometimes it is convenient to process data at the 			 * expense of a userland process instead of a kernel 			 * process. 			 */
call|(
name|f
operator|->
name|methods
operator|->
name|f_filter_read
call|)
argument_list|(
name|f
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|tr_data
operator|=
literal|1
expr_stmt|;
name|io_len
operator|=
name|MIN
argument_list|(
name|m
operator|->
name|cur_data_len
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"transfer %d bytes from %p\n"
argument_list|,
name|io_len
argument_list|,
name|m
operator|->
name|cur_data_ptr
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb2_fifo_uiomove
argument_list|(
name|f
argument_list|,
name|m
operator|->
name|cur_data_ptr
argument_list|,
name|io_len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|m
operator|->
name|cur_data_len
operator|-=
name|io_len
expr_stmt|;
name|m
operator|->
name|cur_data_ptr
operator|+=
name|io_len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|cur_data_len
operator|==
literal|0
condition|)
block|{
name|uint8_t
name|last_packet
decl_stmt|;
name|last_packet
operator|=
name|m
operator|->
name|last_packet
expr_stmt|;
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_packet
condition|)
block|{
comment|/* keep framing */
break|break;
block|}
block|}
else|else
block|{
name|USB_IF_PREPEND
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
break|break;
block|}
block|}
name|done
label|:
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FOF_OFFSET
operator|)
operator|==
literal|0
condition|)
name|fp
operator|->
name|f_offset
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
name|fp
operator|->
name|f_nextoff
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb2_stat_f
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|USB_VNOPS_FO_STAT
argument_list|(
name|fp
argument_list|,
name|sb
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|800009
end_if

begin_function
specifier|static
name|int
name|usb2_truncate_f
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|off_t
name|length
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|USB_VNOPS_FO_TRUNCATE
argument_list|(
name|fp
argument_list|,
name|length
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|usb2_write_f
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb2_location
name|loc
decl_stmt|;
name|struct
name|usb2_fifo
modifier|*
name|f
decl_stmt|;
name|struct
name|usb2_mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|fflags
decl_stmt|;
name|int
name|resid
decl_stmt|;
name|int
name|io_len
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint8_t
name|tr_data
init|=
literal|0
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflags
operator|=
name|fp
operator|->
name|f_flag
operator|&
operator|(
name|O_NONBLOCK
operator||
name|O_DIRECT
operator||
name|FREAD
operator||
name|FWRITE
operator||
name|O_FSYNC
operator|)
expr_stmt|;
if|if
condition|(
name|fflags
operator|&
name|O_DIRECT
condition|)
name|fflags
operator||=
name|IO_DIRECT
expr_stmt|;
name|err
operator|=
name|usb2_ref_device
argument_list|(
name|fp
argument_list|,
operator|&
name|loc
argument_list|,
literal|1
comment|/* no uref */
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|f
operator|=
name|loc
operator|.
name|txfifo
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* should not happen */
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FOF_OFFSET
operator|)
operator|==
literal|0
condition|)
name|uio
operator|->
name|uio_offset
operator|=
name|fp
operator|->
name|f_offset
expr_stmt|;
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
comment|/* check for permanent write error */
if|if
condition|(
name|f
operator|->
name|flag_iserror
condition|)
block|{
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* check if USB-FS interface is active */
if|if
condition|(
name|loc
operator|.
name|is_usbfs
condition|)
block|{
comment|/* 		 * The queue is used for events that should be 		 * retrieved using the "USB_FS_COMPLETE" ioctl. 		 */
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|f
operator|->
name|queue_data
operator|==
name|NULL
condition|)
block|{
comment|/* start write transfer, if not already started */
call|(
name|f
operator|->
name|methods
operator|->
name|f_start_write
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* we allow writing zero length data */
do|do
block|{
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fflags
operator|&
name|O_NONBLOCK
condition|)
block|{
if|if
condition|(
name|tr_data
condition|)
block|{
comment|/* return length before error */
break|break;
block|}
name|err
operator|=
name|EWOULDBLOCK
expr_stmt|;
break|break;
block|}
name|DPRINTF
argument_list|(
literal|"sleeping\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb2_fifo_wait
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
break|break;
block|}
continue|continue;
block|}
name|tr_data
operator|=
literal|1
expr_stmt|;
name|USB_MBUF_RESET
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|io_len
operator|=
name|MIN
argument_list|(
name|m
operator|->
name|cur_data_len
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|m
operator|->
name|cur_data_len
operator|=
name|io_len
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"transfer %d bytes to %p\n"
argument_list|,
name|io_len
argument_list|,
name|m
operator|->
name|cur_data_ptr
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb2_fifo_uiomove
argument_list|(
name|f
argument_list|,
name|m
operator|->
name|cur_data_ptr
argument_list|,
name|io_len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|f
operator|->
name|methods
operator|->
name|f_filter_write
condition|)
block|{
comment|/* 			 * Sometimes it is convenient to process data at the 			 * expense of a userland process instead of a kernel 			 * process. 			 */
call|(
name|f
operator|->
name|methods
operator|->
name|f_filter_write
call|)
argument_list|(
name|f
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
call|(
name|f
operator|->
name|methods
operator|->
name|f_start_write
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
do|;
name|done
label|:
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
name|usb2_unref_device
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FOF_OFFSET
operator|)
operator|==
literal|0
condition|)
name|fp
operator|->
name|f_offset
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
name|fp
operator|->
name|f_nextoff
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb2_fifo_uiomove
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|cp
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * "uiomove()" can sleep so one needs to make a wrapper, 	 * exiting the mutex and checking things: 	 */
name|error
operator|=
name|uiomove
argument_list|(
name|cp
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb2_fifo_wait
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|mtx_assert
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|flag_iserror
condition|)
block|{
comment|/* we are gone */
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|f
operator|->
name|flag_sleeping
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|usb2_cv_wait_sig
argument_list|(
operator|&
name|f
operator|->
name|cv_io
argument_list|,
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|flag_iserror
condition|)
block|{
comment|/* we are gone */
name|err
operator|=
name|EIO
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usb2_fifo_signal
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|->
name|flag_sleeping
condition|)
block|{
name|f
operator|->
name|flag_sleeping
operator|=
literal|0
expr_stmt|;
name|usb2_cv_broadcast
argument_list|(
operator|&
name|f
operator|->
name|cv_io
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|usb2_fifo_wakeup
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|)
block|{
name|usb2_fifo_signal
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|flag_isselect
condition|)
block|{
name|selwakeup
argument_list|(
operator|&
name|f
operator|->
name|selinfo
argument_list|)
expr_stmt|;
name|f
operator|->
name|flag_isselect
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|async_p
operator|!=
name|NULL
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|f
operator|->
name|async_p
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|f
operator|->
name|async_p
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|f
operator|->
name|async_p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_fifo_opened  *  * Returns:  * 0: FIFO not opened.  * Else: FIFO is opened.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usb2_fifo_opened
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|)
block|{
name|uint8_t
name|temp
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* be NULL safe */
block|}
if|if
condition|(
name|mtx_owned
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
condition|)
block|{
name|do_unlock
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|do_unlock
operator|=
literal|1
expr_stmt|;
name|mtx_lock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|f
operator|->
name|curr_file
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|do_unlock
condition|)
block|{
name|mtx_unlock
argument_list|(
name|f
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb2_fifo_dummy_open
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|fifo
parameter_list|,
name|int
name|fflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usb2_fifo_dummy_close
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|fifo
parameter_list|,
name|int
name|fflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|usb2_fifo_dummy_ioctl
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|fifo
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|fflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usb2_fifo_dummy_cmd
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|fifo
operator|->
name|flag_flushing
operator|=
literal|0
expr_stmt|;
comment|/* not flushing */
block|}
end_function

begin_function
specifier|static
name|void
name|usb2_fifo_check_methods
parameter_list|(
name|struct
name|usb2_fifo_methods
modifier|*
name|pm
parameter_list|)
block|{
comment|/* check that all callback functions are OK */
if|if
condition|(
name|pm
operator|->
name|f_open
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_open
operator|=
operator|&
name|usb2_fifo_dummy_open
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|f_close
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_close
operator|=
operator|&
name|usb2_fifo_dummy_close
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|f_ioctl
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_ioctl
operator|=
operator|&
name|usb2_fifo_dummy_ioctl
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|f_ioctl_post
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_ioctl_post
operator|=
operator|&
name|usb2_fifo_dummy_ioctl
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|f_start_read
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_start_read
operator|=
operator|&
name|usb2_fifo_dummy_cmd
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|f_stop_read
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_stop_read
operator|=
operator|&
name|usb2_fifo_dummy_cmd
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|f_start_write
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_start_write
operator|=
operator|&
name|usb2_fifo_dummy_cmd
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|f_stop_write
operator|==
name|NULL
condition|)
name|pm
operator|->
name|f_stop_write
operator|=
operator|&
name|usb2_fifo_dummy_cmd
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_fifo_attach  *  * The following function will create a duplex FIFO.  *  * Return values:  * 0: Success.  * Else: Failure.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb2_fifo_attach
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|void
modifier|*
name|priv_sc
parameter_list|,
name|struct
name|mtx
modifier|*
name|priv_mtx
parameter_list|,
name|struct
name|usb2_fifo_methods
modifier|*
name|pm
parameter_list|,
name|struct
name|usb2_fifo_sc
modifier|*
name|f_sc
parameter_list|,
name|uint16_t
name|unit
parameter_list|,
name|uint16_t
name|subunit
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|)
block|{
name|struct
name|usb2_fifo
modifier|*
name|f_tx
decl_stmt|;
name|struct
name|usb2_fifo
modifier|*
name|f_rx
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|char
name|src
index|[
literal|32
index|]
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_TX
index|]
operator|=
name|NULL
expr_stmt|;
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_RX
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* check the methods */
name|usb2_fifo_check_methods
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv_mtx
operator|==
name|NULL
condition|)
name|priv_mtx
operator|=
operator|&
name|Giant
expr_stmt|;
comment|/* search for a free FIFO slot */
for|for
control|(
name|n
operator|=
literal|0
init|;
condition|;
name|n
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|n
operator|==
name|USB_FIFO_MAX
condition|)
block|{
comment|/* end of FIFOs reached */
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Check for TX FIFO */
if|if
condition|(
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_TX
index|]
operator|!=
name|NULL
condition|)
block|{
continue|continue;
block|}
comment|/* Check for RX FIFO */
if|if
condition|(
name|udev
operator|->
name|fifo
index|[
name|n
operator|+
name|USB_FIFO_RX
index|]
operator|!=
name|NULL
condition|)
block|{
continue|continue;
block|}
break|break;
block|}
name|f_tx
operator|=
name|usb2_fifo_alloc
argument_list|()
expr_stmt|;
name|f_rx
operator|=
name|usb2_fifo_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|f_tx
operator|==
name|NULL
operator|)
operator|||
operator|(
name|f_rx
operator|==
name|NULL
operator|)
condition|)
block|{
name|usb2_fifo_free
argument_list|(
name|f_tx
argument_list|)
expr_stmt|;
name|usb2_fifo_free
argument_list|(
name|f_rx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* initialise FIFO structures */
name|f_tx
operator|->
name|fifo_index
operator|=
name|n
operator|+
name|USB_FIFO_TX
expr_stmt|;
name|f_tx
operator|->
name|dev_ep_index
operator|=
operator|(
name|n
operator|/
literal|2
operator|)
operator|+
operator|(
name|USB_EP_MAX
operator|/
literal|2
operator|)
expr_stmt|;
name|f_tx
operator|->
name|priv_mtx
operator|=
name|priv_mtx
expr_stmt|;
name|f_tx
operator|->
name|priv_sc0
operator|=
name|priv_sc
expr_stmt|;
name|f_tx
operator|->
name|methods
operator|=
name|pm
expr_stmt|;
name|f_tx
operator|->
name|iface_index
operator|=
name|iface_index
expr_stmt|;
name|f_tx
operator|->
name|udev
operator|=
name|udev
expr_stmt|;
name|f_rx
operator|->
name|fifo_index
operator|=
name|n
operator|+
name|USB_FIFO_RX
expr_stmt|;
name|f_rx
operator|->
name|dev_ep_index
operator|=
operator|(
name|n
operator|/
literal|2
operator|)
operator|+
operator|(
name|USB_EP_MAX
operator|/
literal|2
operator|)
expr_stmt|;
name|f_rx
operator|->
name|priv_mtx
operator|=
name|priv_mtx
expr_stmt|;
name|f_rx
operator|->
name|priv_sc0
operator|=
name|priv_sc
expr_stmt|;
name|f_rx
operator|->
name|methods
operator|=
name|pm
expr_stmt|;
name|f_rx
operator|->
name|iface_index
operator|=
name|iface_index
expr_stmt|;
name|f_rx
operator|->
name|udev
operator|=
name|udev
expr_stmt|;
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_TX
index|]
operator|=
name|f_tx
expr_stmt|;
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_RX
index|]
operator|=
name|f_rx
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
name|udev
operator|->
name|fifo
index|[
name|f_tx
operator|->
name|fifo_index
index|]
operator|=
name|f_tx
expr_stmt|;
name|udev
operator|->
name|fifo
index|[
name|f_rx
operator|->
name|fifo_index
index|]
operator|=
name|f_rx
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|snprintf
argument_list|(
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|src
argument_list|)
argument_list|,
name|USB_DEVICE_NAME
literal|"%u.%u.%u.%u"
argument_list|,
name|device_get_unit
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
argument_list|,
name|udev
operator|->
name|device_index
argument_list|,
name|iface_index
argument_list|,
name|f_tx
operator|->
name|dev_ep_index
argument_list|)
condition|)
block|{
comment|/* ignore */
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
literal|4
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|pm
operator|->
name|basename
index|[
name|n
index|]
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|subunit
operator|==
literal|0xFFFF
condition|)
block|{
if|if
condition|(
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%u%s"
argument_list|,
name|pm
operator|->
name|basename
index|[
name|n
index|]
argument_list|,
name|unit
argument_list|,
name|pm
operator|->
name|postfix
index|[
name|n
index|]
condition|?
name|pm
operator|->
name|postfix
index|[
name|n
index|]
else|:
literal|""
argument_list|)
condition|)
block|{
comment|/* ignore */
block|}
block|}
else|else
block|{
if|if
condition|(
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%u.%u%s"
argument_list|,
name|pm
operator|->
name|basename
index|[
name|n
index|]
argument_list|,
name|unit
argument_list|,
name|subunit
argument_list|,
name|pm
operator|->
name|postfix
index|[
name|n
index|]
condition|?
name|pm
operator|->
name|postfix
index|[
name|n
index|]
else|:
literal|""
argument_list|)
condition|)
block|{
comment|/* ignore */
block|}
block|}
comment|/* 		 * Distribute the symbolic links into two FIFO structures: 		 */
if|if
condition|(
name|n
operator|&
literal|1
condition|)
block|{
name|f_rx
operator|->
name|symlink
index|[
name|n
operator|/
literal|2
index|]
operator|=
name|usb2_alloc_symlink
argument_list|(
name|src
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f_tx
operator|->
name|symlink
index|[
name|n
operator|/
literal|2
index|]
operator|=
name|usb2_alloc_symlink
argument_list|(
name|src
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Symlink: %s -> %s\n"
argument_list|,
name|buf
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"attached %p/%p\n"
argument_list|,
name|f_tx
argument_list|,
name|f_rx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_fifo_alloc_buffer  *  * Return values:  * 0: Success  * Else failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb2_fifo_alloc_buffer
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|,
name|uint32_t
name|bufsize
parameter_list|,
name|uint16_t
name|nbuf
parameter_list|)
block|{
name|usb2_fifo_free_buffer
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* allocate an endpoint */
name|f
operator|->
name|free_q
operator|.
name|ifq_maxlen
operator|=
name|nbuf
expr_stmt|;
name|f
operator|->
name|used_q
operator|.
name|ifq_maxlen
operator|=
name|nbuf
expr_stmt|;
name|f
operator|->
name|queue_data
operator|=
name|usb2_alloc_mbufs
argument_list|(
name|M_USBDEV
argument_list|,
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|bufsize
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|queue_data
operator|==
name|NULL
operator|)
operator|&&
name|bufsize
operator|&&
name|nbuf
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_fifo_free_buffer  *  * This function will free the buffers associated with a FIFO. This  * function can be called multiple times in a row.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb2_fifo_free_buffer
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|->
name|queue_data
condition|)
block|{
comment|/* free old buffer */
name|free
argument_list|(
name|f
operator|->
name|queue_data
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
name|f
operator|->
name|queue_data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* reset queues */
name|bzero
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
sizeof|sizeof
argument_list|(
name|f
operator|->
name|free_q
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
sizeof|sizeof
argument_list|(
name|f
operator|->
name|used_q
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usb2_fifo_detach
parameter_list|(
name|struct
name|usb2_fifo_sc
modifier|*
name|f_sc
parameter_list|)
block|{
if|if
condition|(
name|f_sc
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|usb2_fifo_free
argument_list|(
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_TX
index|]
argument_list|)
expr_stmt|;
name|usb2_fifo_free
argument_list|(
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_RX
index|]
argument_list|)
expr_stmt|;
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_TX
index|]
operator|=
name|NULL
expr_stmt|;
name|f_sc
operator|->
name|fp
index|[
name|USB_FIFO_RX
index|]
operator|=
name|NULL
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"detached %p\n"
argument_list|,
name|f_sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|usb2_fifo_put_bytes_max
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|usb2_mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|USB_IF_POLL
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|len
operator|=
name|m
operator|->
name|max_data_len
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_fifo_put_data  *  * what:  *  0 - normal operation  *  1 - set last packet flag to enforce framing  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb2_fifo_put_data
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|,
name|struct
name|usb2_page_cache
modifier|*
name|pc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint8_t
name|what
parameter_list|)
block|{
name|struct
name|usb2_mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|io_len
decl_stmt|;
while|while
condition|(
name|len
operator|||
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|USB_MBUF_RESET
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|io_len
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|m
operator|->
name|cur_data_len
argument_list|)
expr_stmt|;
name|usb2_copy_out
argument_list|(
name|pc
argument_list|,
name|offset
argument_list|,
name|m
operator|->
name|cur_data_ptr
argument_list|,
name|io_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|cur_data_len
operator|=
name|io_len
expr_stmt|;
name|offset
operator|+=
name|io_len
expr_stmt|;
name|len
operator|-=
name|io_len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|&&
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
name|m
operator|->
name|last_packet
operator|=
literal|1
expr_stmt|;
block|}
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|usb2_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|usb2_fifo_put_data_linear
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint8_t
name|what
parameter_list|)
block|{
name|struct
name|usb2_mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|io_len
decl_stmt|;
while|while
condition|(
name|len
operator|||
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|USB_MBUF_RESET
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|io_len
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|m
operator|->
name|cur_data_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ptr
argument_list|,
name|m
operator|->
name|cur_data_ptr
argument_list|,
name|io_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|cur_data_len
operator|=
name|io_len
expr_stmt|;
name|ptr
operator|=
name|USB_ADD_BYTES
argument_list|(
name|ptr
argument_list|,
name|io_len
argument_list|)
expr_stmt|;
name|len
operator|-=
name|io_len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|&&
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
name|m
operator|->
name|last_packet
operator|=
literal|1
expr_stmt|;
block|}
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|usb2_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
end_function

begin_function
name|uint8_t
name|usb2_fifo_put_data_buffer
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|struct
name|usb2_mbuf
modifier|*
name|m
decl_stmt|;
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|m
operator|->
name|cur_data_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|cur_data_ptr
operator|=
name|ptr
expr_stmt|;
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|usb2_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usb2_fifo_put_data_error
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|)
block|{
name|f
operator|->
name|flag_iserror
operator|=
literal|1
expr_stmt|;
name|usb2_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_fifo_get_data  *  * what:  *  0 - normal operation  *  1 - only get one "usb2_mbuf"  *  * returns:  *  0 - no more data  *  1 - data in buffer  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usb2_fifo_get_data
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|,
name|struct
name|usb2_page_cache
modifier|*
name|pc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint32_t
modifier|*
name|actlen
parameter_list|,
name|uint8_t
name|what
parameter_list|)
block|{
name|struct
name|usb2_mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|io_len
decl_stmt|;
name|uint8_t
name|tr_data
init|=
literal|0
decl_stmt|;
name|actlen
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|tr_data
operator|=
literal|1
expr_stmt|;
name|io_len
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|m
operator|->
name|cur_data_len
argument_list|)
expr_stmt|;
name|usb2_copy_in
argument_list|(
name|pc
argument_list|,
name|offset
argument_list|,
name|m
operator|->
name|cur_data_ptr
argument_list|,
name|io_len
argument_list|)
expr_stmt|;
name|len
operator|-=
name|io_len
expr_stmt|;
name|offset
operator|+=
name|io_len
expr_stmt|;
name|actlen
index|[
literal|0
index|]
operator|+=
name|io_len
expr_stmt|;
name|m
operator|->
name|cur_data_ptr
operator|+=
name|io_len
expr_stmt|;
name|m
operator|->
name|cur_data_len
operator|-=
name|io_len
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|cur_data_len
operator|==
literal|0
operator|)
operator|||
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|usb2_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|1
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
name|USB_IF_PREPEND
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tr_data
condition|)
block|{
comment|/* wait for data to be written out */
break|break;
block|}
if|if
condition|(
name|f
operator|->
name|flag_flushing
condition|)
block|{
name|f
operator|->
name|flag_flushing
operator|=
literal|0
expr_stmt|;
name|usb2_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|tr_data
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|usb2_fifo_get_data_linear
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint32_t
modifier|*
name|actlen
parameter_list|,
name|uint8_t
name|what
parameter_list|)
block|{
name|struct
name|usb2_mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|io_len
decl_stmt|;
name|uint8_t
name|tr_data
init|=
literal|0
decl_stmt|;
name|actlen
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|USB_IF_DEQUEUE
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|tr_data
operator|=
literal|1
expr_stmt|;
name|io_len
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|m
operator|->
name|cur_data_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|m
operator|->
name|cur_data_ptr
argument_list|,
name|ptr
argument_list|,
name|io_len
argument_list|)
expr_stmt|;
name|len
operator|-=
name|io_len
expr_stmt|;
name|ptr
operator|=
name|USB_ADD_BYTES
argument_list|(
name|ptr
argument_list|,
name|io_len
argument_list|)
expr_stmt|;
name|actlen
index|[
literal|0
index|]
operator|+=
name|io_len
expr_stmt|;
name|m
operator|->
name|cur_data_ptr
operator|+=
name|io_len
expr_stmt|;
name|m
operator|->
name|cur_data_len
operator|-=
name|io_len
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|cur_data_len
operator|==
literal|0
operator|)
operator|||
operator|(
name|what
operator|==
literal|1
operator|)
condition|)
block|{
name|USB_IF_ENQUEUE
argument_list|(
operator|&
name|f
operator|->
name|free_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|usb2_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|1
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
name|USB_IF_PREPEND
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tr_data
condition|)
block|{
comment|/* wait for data to be written out */
break|break;
block|}
if|if
condition|(
name|f
operator|->
name|flag_flushing
condition|)
block|{
name|f
operator|->
name|flag_flushing
operator|=
literal|0
expr_stmt|;
name|usb2_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|tr_data
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|usb2_fifo_get_data_buffer
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|,
name|void
modifier|*
modifier|*
name|pptr
parameter_list|,
name|uint32_t
modifier|*
name|plen
parameter_list|)
block|{
name|struct
name|usb2_mbuf
modifier|*
name|m
decl_stmt|;
name|USB_IF_POLL
argument_list|(
operator|&
name|f
operator|->
name|used_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
operator|*
name|plen
operator|=
name|m
operator|->
name|cur_data_len
expr_stmt|;
operator|*
name|pptr
operator|=
name|m
operator|->
name|cur_data_ptr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usb2_fifo_get_data_error
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|f
parameter_list|)
block|{
name|f
operator|->
name|flag_iserror
operator|=
literal|1
expr_stmt|;
name|usb2_fifo_wakeup
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_alloc_symlink  *  * Return values:  * NULL: Failure  * Else: Pointer to symlink entry  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb2_symlink
modifier|*
name|usb2_alloc_symlink
parameter_list|(
specifier|const
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|usb2_symlink
modifier|*
name|ps
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|ps
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ps
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ps
operator|)
return|;
block|}
name|strlcpy
argument_list|(
name|ps
operator|->
name|dst_path
argument_list|,
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
operator|->
name|dst_path
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|->
name|dst_len
operator|=
name|strlen
argument_list|(
name|ps
operator|->
name|dst_path
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnrprintf
argument_list|(
name|ps
operator|->
name|src_path
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
operator|->
name|src_path
argument_list|)
argument_list|,
literal|32
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ps
operator|->
name|src_len
operator|=
name|strlen
argument_list|(
name|ps
operator|->
name|src_path
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|usb2_sym_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|usb2_sym_head
argument_list|,
name|ps
argument_list|,
name|sym_entry
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|usb2_sym_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ps
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_free_symlink  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb2_free_symlink
parameter_list|(
name|struct
name|usb2_symlink
modifier|*
name|ps
parameter_list|)
block|{
if|if
condition|(
name|ps
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|sx_xlock
argument_list|(
operator|&
name|usb2_sym_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|usb2_sym_head
argument_list|,
name|ps
argument_list|,
name|sym_entry
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|usb2_sym_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ps
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_lookup_symlink  *  * Return value:  * Numerical device location  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint32_t
name|usb2_lookup_symlink
parameter_list|(
specifier|const
name|char
modifier|*
name|src_ptr
parameter_list|,
name|uint8_t
name|src_len
parameter_list|)
block|{
enum|enum
block|{
name|USB_DNAME_LEN
init|=
sizeof|sizeof
argument_list|(
name|USB_DEVICE_NAME
argument_list|)
operator|-
literal|1
block|, 	}
enum|;
name|struct
name|usb2_symlink
modifier|*
name|ps
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|usb2_sym_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ps
argument_list|,
argument|&usb2_sym_head
argument_list|,
argument|sym_entry
argument_list|)
block|{
if|if
condition|(
name|src_len
operator|!=
name|ps
operator|->
name|src_len
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|ps
operator|->
name|src_path
argument_list|,
name|src_ptr
argument_list|,
name|src_len
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|USB_DNAME_LEN
operator|>
name|ps
operator|->
name|dst_len
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|ps
operator|->
name|dst_path
argument_list|,
name|USB_DEVICE_NAME
argument_list|,
name|USB_DNAME_LEN
argument_list|)
condition|)
continue|continue;
name|temp
operator|=
name|usb2_path_convert
argument_list|(
name|ps
operator|->
name|dst_path
operator|+
name|USB_DNAME_LEN
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|usb2_sym_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
name|sx_unlock
argument_list|(
operator|&
name|usb2_sym_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_read_symlink  *  * Return value:  * 0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb2_read_symlink
parameter_list|(
name|uint8_t
modifier|*
name|user_ptr
parameter_list|,
name|uint32_t
name|startentry
parameter_list|,
name|uint32_t
name|user_len
parameter_list|)
block|{
name|struct
name|usb2_symlink
modifier|*
name|ps
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|delta
init|=
literal|0
decl_stmt|;
name|uint8_t
name|len
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|usb2_sym_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ps
argument_list|,
argument|&usb2_sym_head
argument_list|,
argument|sym_entry
argument_list|)
block|{
comment|/* 		 * Compute total length of source and destination symlink 		 * strings pluss one length byte and two NUL bytes: 		 */
name|temp
operator|=
name|ps
operator|->
name|src_len
operator|+
name|ps
operator|->
name|dst_len
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|255
condition|)
block|{
comment|/* 			 * Skip entry because this length cannot fit 			 * into one byte: 			 */
continue|continue;
block|}
if|if
condition|(
name|startentry
operator|!=
literal|0
condition|)
block|{
comment|/* decrement read offset */
name|startentry
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|temp
operator|>
name|user_len
condition|)
block|{
comment|/* out of buffer space */
break|break;
block|}
name|len
operator|=
name|temp
expr_stmt|;
comment|/* copy out total length */
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|len
argument_list|,
name|USB_ADD_BYTES
argument_list|(
name|user_ptr
argument_list|,
name|delta
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|delta
operator|+=
literal|1
expr_stmt|;
comment|/* copy out source string */
name|error
operator|=
name|copyout
argument_list|(
name|ps
operator|->
name|src_path
argument_list|,
name|USB_ADD_BYTES
argument_list|(
name|user_ptr
argument_list|,
name|delta
argument_list|)
argument_list|,
name|ps
operator|->
name|src_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|len
operator|=
literal|0
expr_stmt|;
name|delta
operator|+=
name|ps
operator|->
name|src_len
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|len
argument_list|,
name|USB_ADD_BYTES
argument_list|(
name|user_ptr
argument_list|,
name|delta
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|delta
operator|+=
literal|1
expr_stmt|;
comment|/* copy out destination string */
name|error
operator|=
name|copyout
argument_list|(
name|ps
operator|->
name|dst_path
argument_list|,
name|USB_ADD_BYTES
argument_list|(
name|user_ptr
argument_list|,
name|delta
argument_list|)
argument_list|,
name|ps
operator|->
name|dst_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|len
operator|=
literal|0
expr_stmt|;
name|delta
operator|+=
name|ps
operator|->
name|dst_len
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|len
argument_list|,
name|USB_ADD_BYTES
argument_list|(
name|user_ptr
argument_list|,
name|delta
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|delta
operator|+=
literal|1
expr_stmt|;
name|user_len
operator|-=
name|temp
expr_stmt|;
block|}
comment|/* a zero length entry indicates the end */
if|if
condition|(
operator|(
name|user_len
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|error
operator|==
literal|0
operator|)
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|len
argument_list|,
name|USB_ADD_BYTES
argument_list|(
name|user_ptr
argument_list|,
name|delta
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sx_unlock
argument_list|(
operator|&
name|usb2_sym_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

