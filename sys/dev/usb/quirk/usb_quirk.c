begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1998 The NetBSD Foundation, Inc. All rights reserved.  * Copyright (c) 1998 Lennart Augustsson. All rights reserved.  * Copyright (c) 2008 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|usb_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_dynamic.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/quirk/usb_quirk.h>
end_include

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|usb_quirk
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|usb_quirk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The following macro adds one or more quirks for a USB device:  */
end_comment

begin_define
define|#
directive|define
name|USB_QUIRK_ENTRY
parameter_list|(
name|v
parameter_list|,
name|p
parameter_list|,
name|l
parameter_list|,
name|h
parameter_list|,
modifier|...
parameter_list|)
define|\
value|.vid = (v), .pid = (p), .lo_rev = (l), .hi_rev = (h), .quirks = { __VA_ARGS__ }
end_define

begin_define
define|#
directive|define
name|USB_DEV_QUIRKS_MAX
value|128
end_define

begin_define
define|#
directive|define
name|USB_SUB_QUIRKS_MAX
value|8
end_define

begin_struct
struct|struct
name|usb_quirk_entry
block|{
name|uint16_t
name|vid
decl_stmt|;
name|uint16_t
name|pid
decl_stmt|;
name|uint16_t
name|lo_rev
decl_stmt|;
name|uint16_t
name|hi_rev
decl_stmt|;
name|uint16_t
name|quirks
index|[
name|USB_SUB_QUIRKS_MAX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|usb_quirk_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|usb_quirk_entry
name|usb_quirks
index|[
name|USB_DEV_QUIRKS_MAX
index|]
init|=
block|{
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_ASUS
argument_list|,
argument|USB_PRODUCT_ASUS_LCM
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_HID_IGNORE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_INSIDEOUT
argument_list|,
argument|USB_PRODUCT_INSIDEOUT_EDGEPORT4
argument_list|,
literal|0x094
argument_list|,
literal|0x094
argument_list|,
argument|UQ_SWAP_UNICODE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_DALLAS
argument_list|,
argument|USB_PRODUCT_DALLAS_J6502
argument_list|,
literal|0x0a2
argument_list|,
literal|0x0a2
argument_list|,
argument|UQ_BAD_ADC
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_DALLAS
argument_list|,
argument|USB_PRODUCT_DALLAS_J6502
argument_list|,
literal|0x0a2
argument_list|,
literal|0x0a2
argument_list|,
argument|UQ_AU_NO_XU
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_ALTEC
argument_list|,
argument|USB_PRODUCT_ALTEC_ADA70
argument_list|,
literal|0x103
argument_list|,
literal|0x103
argument_list|,
argument|UQ_BAD_ADC
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_ALTEC
argument_list|,
argument|USB_PRODUCT_ALTEC_ASC495
argument_list|,
literal|0x000
argument_list|,
literal|0x000
argument_list|,
argument|UQ_BAD_AUDIO
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_QTRONIX
argument_list|,
argument|USB_PRODUCT_QTRONIX_980N
argument_list|,
literal|0x110
argument_list|,
literal|0x110
argument_list|,
argument|UQ_SPUR_BUT_UP
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_ALCOR2
argument_list|,
argument|USB_PRODUCT_ALCOR2_KBD_HUB
argument_list|,
literal|0x001
argument_list|,
literal|0x001
argument_list|,
argument|UQ_SPUR_BUT_UP
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_MCT
argument_list|,
argument|USB_PRODUCT_MCT_HUB0100
argument_list|,
literal|0x102
argument_list|,
literal|0x102
argument_list|,
argument|UQ_BUS_POWERED
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_MCT
argument_list|,
argument|USB_PRODUCT_MCT_USB232
argument_list|,
literal|0x102
argument_list|,
literal|0x102
argument_list|,
argument|UQ_BUS_POWERED
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_TI
argument_list|,
argument|USB_PRODUCT_TI_UTUSB41
argument_list|,
literal|0x110
argument_list|,
literal|0x110
argument_list|,
argument|UQ_POWER_CLAIM
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_TELEX
argument_list|,
argument|USB_PRODUCT_TELEX_MIC1
argument_list|,
literal|0x009
argument_list|,
literal|0x009
argument_list|,
argument|UQ_AU_NO_FRAC
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_SILICONPORTALS
argument_list|,
argument|USB_PRODUCT_SILICONPORTALS_YAPPHONE
argument_list|,
literal|0x100
argument_list|,
literal|0x100
argument_list|,
argument|UQ_AU_INP_ASYNC
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_LOGITECH
argument_list|,
argument|USB_PRODUCT_LOGITECH_UN53B
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_NO_STRINGS
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_ELSA
argument_list|,
argument|USB_PRODUCT_ELSA_MODEM1
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_CFG_INDEX_1
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
comment|/* 	 * XXX The following quirks should have a more specific revision 	 * number: 	 */
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_HP
argument_list|,
argument|USB_PRODUCT_HP_895C
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_BROKEN_BIDIR
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_HP
argument_list|,
argument|USB_PRODUCT_HP_880C
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_BROKEN_BIDIR
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_HP
argument_list|,
argument|USB_PRODUCT_HP_815C
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_BROKEN_BIDIR
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_HP
argument_list|,
argument|USB_PRODUCT_HP_810C
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_BROKEN_BIDIR
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_HP
argument_list|,
argument|USB_PRODUCT_HP_830C
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_BROKEN_BIDIR
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_HP
argument_list|,
argument|USB_PRODUCT_HP_1220C
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_BROKEN_BIDIR
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_XEROX
argument_list|,
argument|USB_PRODUCT_XEROX_WCM15
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_BROKEN_BIDIR
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
comment|/* Devices which should be ignored by uhid */
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_APC
argument_list|,
argument|USB_PRODUCT_APC_UPS
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_HID_IGNORE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_BELKIN
argument_list|,
argument|USB_PRODUCT_BELKIN_F6C550AVR
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_HID_IGNORE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_CYBERPOWER
argument_list|,
argument|USB_PRODUCT_CYBERPOWER_1500CAVRLCD
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_HID_IGNORE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_DELORME
argument_list|,
argument|USB_PRODUCT_DELORME_EARTHMATE
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_HID_IGNORE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_ITUNERNET
argument_list|,
argument|USB_PRODUCT_ITUNERNET_USBLCD2X20
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_HID_IGNORE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_ITUNERNET
argument_list|,
argument|USB_PRODUCT_ITUNERNET_USBLCD4X20
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_HID_IGNORE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_MGE
argument_list|,
argument|USB_PRODUCT_MGE_UPS1
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_HID_IGNORE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_MGE
argument_list|,
argument|USB_PRODUCT_MGE_UPS2
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_HID_IGNORE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
argument|USB_PRODUCT_APPLE_IPHONE
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_HID_IGNORE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
argument|USB_PRODUCT_APPLE_IPHONE_3G
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_HID_IGNORE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
comment|/* Devices which should be ignored by both ukbd and uhid */
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_CYPRESS
argument_list|,
argument|USB_PRODUCT_CYPRESS_WISPY1A
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_KBD_IGNORE
argument_list|,
argument|UQ_HID_IGNORE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_METAGEEK
argument_list|,
argument|USB_PRODUCT_METAGEEK_WISPY1B
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_KBD_IGNORE
argument_list|,
argument|UQ_HID_IGNORE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_TENX
argument_list|,
argument|USB_PRODUCT_TENX_UAUDIO0
argument_list|,
literal|0x0101
argument_list|,
literal|0x0101
argument_list|,
argument|UQ_AUDIO_SWAP_LR
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
comment|/* MS keyboards do weird things */
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_MICROSOFT
argument_list|,
argument|USB_PRODUCT_MICROSOFT_WLINTELLIMOUSE
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_MS_LEADING_BYTE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|,
block|{
name|USB_QUIRK_ENTRY
argument_list|(
argument|USB_VENDOR_METAGEEK
argument_list|,
argument|USB_PRODUCT_METAGEEK_WISPY24X
argument_list|,
literal|0x0000
argument_list|,
literal|0xFFFF
argument_list|,
argument|UQ_KBD_IGNORE
argument_list|,
argument|UQ_HID_IGNORE
argument_list|,
argument|UQ_NONE
argument_list|)
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|usb_quirk_str
index|[
name|USB_QUIRK_MAX
index|]
init|=
block|{
index|[
name|UQ_NONE
index|]
operator|=
literal|"UQ_NONE"
block|,
index|[
name|UQ_AUDIO_SWAP_LR
index|]
operator|=
literal|"UQ_AUDIO_SWAP_LR"
block|,
index|[
name|UQ_AU_INP_ASYNC
index|]
operator|=
literal|"UQ_AU_INP_ASYNC"
block|,
index|[
name|UQ_AU_NO_FRAC
index|]
operator|=
literal|"UQ_AU_NO_FRAC"
block|,
index|[
name|UQ_AU_NO_XU
index|]
operator|=
literal|"UQ_AU_NO_XU"
block|,
index|[
name|UQ_BAD_ADC
index|]
operator|=
literal|"UQ_BAD_ADC"
block|,
index|[
name|UQ_BAD_AUDIO
index|]
operator|=
literal|"UQ_BAD_AUDIO"
block|,
index|[
name|UQ_BROKEN_BIDIR
index|]
operator|=
literal|"UQ_BROKEN_BIDIR"
block|,
index|[
name|UQ_BUS_POWERED
index|]
operator|=
literal|"UQ_BUS_POWERED"
block|,
index|[
name|UQ_HID_IGNORE
index|]
operator|=
literal|"UQ_HID_IGNORE"
block|,
index|[
name|UQ_KBD_IGNORE
index|]
operator|=
literal|"UQ_KBD_IGNORE"
block|,
index|[
name|UQ_MS_BAD_CLASS
index|]
operator|=
literal|"UQ_MS_BAD_CLASS"
block|,
index|[
name|UQ_MS_LEADING_BYTE
index|]
operator|=
literal|"UQ_MS_LEADING_BYTE"
block|,
index|[
name|UQ_MS_REVZ
index|]
operator|=
literal|"UQ_MS_REVZ"
block|,
index|[
name|UQ_NO_STRINGS
index|]
operator|=
literal|"UQ_NO_STRINGS"
block|,
index|[
name|UQ_OPEN_CLEARSTALL
index|]
operator|=
literal|"UQ_OPEN_CLEARSTALL"
block|,
index|[
name|UQ_POWER_CLAIM
index|]
operator|=
literal|"UQ_POWER_CLAIM"
block|,
index|[
name|UQ_SPUR_BUT_UP
index|]
operator|=
literal|"UQ_SPUR_BUT_UP"
block|,
index|[
name|UQ_SWAP_UNICODE
index|]
operator|=
literal|"UQ_SWAP_UNICODE"
block|,
index|[
name|UQ_CFG_INDEX_1
index|]
operator|=
literal|"UQ_CFG_INDEX_1"
block|,
index|[
name|UQ_CFG_INDEX_2
index|]
operator|=
literal|"UQ_CFG_INDEX_2"
block|,
index|[
name|UQ_CFG_INDEX_3
index|]
operator|=
literal|"UQ_CFG_INDEX_3"
block|,
index|[
name|UQ_CFG_INDEX_4
index|]
operator|=
literal|"UQ_CFG_INDEX_4"
block|,
index|[
name|UQ_CFG_INDEX_0
index|]
operator|=
literal|"UQ_CFG_INDEX_0"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_quirkstr  *  * This function converts an USB quirk code into a string.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|usb_quirkstr
parameter_list|(
name|uint16_t
name|quirk
parameter_list|)
block|{
return|return
operator|(
operator|(
name|quirk
operator|<
name|USB_QUIRK_MAX
operator|)
condition|?
name|usb_quirk_str
index|[
name|quirk
index|]
else|:
literal|"USB_QUIRK_UNKNOWN"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_test_quirk_by_info  *  * Returns:  * 0: Quirk not found  * Else: Quirk found  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|usb_test_quirk_by_info
parameter_list|(
specifier|const
name|struct
name|usbd_lookup_info
modifier|*
name|info
parameter_list|,
name|uint16_t
name|quirk
parameter_list|)
block|{
name|uint16_t
name|x
decl_stmt|;
name|uint16_t
name|y
decl_stmt|;
if|if
condition|(
name|quirk
operator|==
name|UQ_NONE
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|usb_quirk_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|USB_DEV_QUIRKS_MAX
condition|;
name|x
operator|++
control|)
block|{
comment|/* see if quirk information does not match */
if|if
condition|(
operator|(
name|usb_quirks
index|[
name|x
index|]
operator|.
name|vid
operator|!=
name|info
operator|->
name|idVendor
operator|)
operator|||
operator|(
name|usb_quirks
index|[
name|x
index|]
operator|.
name|pid
operator|!=
name|info
operator|->
name|idProduct
operator|)
operator|||
operator|(
name|usb_quirks
index|[
name|x
index|]
operator|.
name|lo_rev
operator|>
name|info
operator|->
name|bcdDevice
operator|)
operator|||
operator|(
name|usb_quirks
index|[
name|x
index|]
operator|.
name|hi_rev
operator|<
name|info
operator|->
name|bcdDevice
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* lookup quirk */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|!=
name|USB_SUB_QUIRKS_MAX
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|usb_quirks
index|[
name|x
index|]
operator|.
name|quirks
index|[
name|y
index|]
operator|==
name|quirk
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|usb_quirk_mtx
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Found quirk '%s'.\n"
argument_list|,
name|usb_quirkstr
argument_list|(
name|quirk
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* no quirk found */
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|usb_quirk_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|usb_quirk_entry
modifier|*
name|usb_quirk_get_entry
parameter_list|(
name|uint16_t
name|vid
parameter_list|,
name|uint16_t
name|pid
parameter_list|,
name|uint16_t
name|lo_rev
parameter_list|,
name|uint16_t
name|hi_rev
parameter_list|,
name|uint8_t
name|do_alloc
parameter_list|)
block|{
name|uint16_t
name|x
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|usb_quirk_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vid
operator||
name|pid
operator||
name|lo_rev
operator||
name|hi_rev
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* all zero - special case */
return|return
operator|(
name|usb_quirks
operator|+
name|USB_DEV_QUIRKS_MAX
operator|-
literal|1
operator|)
return|;
block|}
comment|/* search for an existing entry */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|USB_DEV_QUIRKS_MAX
condition|;
name|x
operator|++
control|)
block|{
comment|/* see if quirk information does not match */
if|if
condition|(
operator|(
name|usb_quirks
index|[
name|x
index|]
operator|.
name|vid
operator|!=
name|vid
operator|)
operator|||
operator|(
name|usb_quirks
index|[
name|x
index|]
operator|.
name|pid
operator|!=
name|pid
operator|)
operator|||
operator|(
name|usb_quirks
index|[
name|x
index|]
operator|.
name|lo_rev
operator|!=
name|lo_rev
operator|)
operator|||
operator|(
name|usb_quirks
index|[
name|x
index|]
operator|.
name|hi_rev
operator|!=
name|hi_rev
operator|)
condition|)
block|{
continue|continue;
block|}
return|return
operator|(
name|usb_quirks
operator|+
name|x
operator|)
return|;
block|}
if|if
condition|(
name|do_alloc
operator|==
literal|0
condition|)
block|{
comment|/* no match */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* search for a free entry */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|USB_DEV_QUIRKS_MAX
condition|;
name|x
operator|++
control|)
block|{
comment|/* see if quirk information does not match */
if|if
condition|(
operator|(
name|usb_quirks
index|[
name|x
index|]
operator|.
name|vid
operator||
name|usb_quirks
index|[
name|x
index|]
operator|.
name|pid
operator||
name|usb_quirks
index|[
name|x
index|]
operator|.
name|lo_rev
operator||
name|usb_quirks
index|[
name|x
index|]
operator|.
name|hi_rev
operator|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
name|usb_quirks
index|[
name|x
index|]
operator|.
name|vid
operator|=
name|vid
expr_stmt|;
name|usb_quirks
index|[
name|x
index|]
operator|.
name|pid
operator|=
name|pid
expr_stmt|;
name|usb_quirks
index|[
name|x
index|]
operator|.
name|lo_rev
operator|=
name|lo_rev
expr_stmt|;
name|usb_quirks
index|[
name|x
index|]
operator|.
name|hi_rev
operator|=
name|hi_rev
expr_stmt|;
return|return
operator|(
name|usb_quirks
operator|+
name|x
operator|)
return|;
block|}
comment|/* no entry found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_quirk_ioctl - handle quirk IOCTLs  *  * Returns:  * 0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb_quirk_ioctl
parameter_list|(
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb_gen_quirk
modifier|*
name|pgq
decl_stmt|;
name|struct
name|usb_quirk_entry
modifier|*
name|pqe
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|uint32_t
name|y
decl_stmt|;
name|int
name|err
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|USB_DEV_QUIRK_GET
case|:
name|pgq
operator|=
operator|(
name|void
operator|*
operator|)
name|data
expr_stmt|;
name|x
operator|=
name|pgq
operator|->
name|index
operator|%
name|USB_SUB_QUIRKS_MAX
expr_stmt|;
name|y
operator|=
name|pgq
operator|->
name|index
operator|/
name|USB_SUB_QUIRKS_MAX
expr_stmt|;
if|if
condition|(
name|y
operator|>=
name|USB_DEV_QUIRKS_MAX
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|usb_quirk_mtx
argument_list|)
expr_stmt|;
comment|/* copy out data */
name|pgq
operator|->
name|vid
operator|=
name|usb_quirks
index|[
name|y
index|]
operator|.
name|vid
expr_stmt|;
name|pgq
operator|->
name|pid
operator|=
name|usb_quirks
index|[
name|y
index|]
operator|.
name|pid
expr_stmt|;
name|pgq
operator|->
name|bcdDeviceLow
operator|=
name|usb_quirks
index|[
name|y
index|]
operator|.
name|lo_rev
expr_stmt|;
name|pgq
operator|->
name|bcdDeviceHigh
operator|=
name|usb_quirks
index|[
name|y
index|]
operator|.
name|hi_rev
expr_stmt|;
name|strlcpy
argument_list|(
name|pgq
operator|->
name|quirkname
argument_list|,
name|usb_quirkstr
argument_list|(
name|usb_quirks
index|[
name|y
index|]
operator|.
name|quirks
index|[
name|x
index|]
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pgq
operator|->
name|quirkname
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usb_quirk_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
case|case
name|USB_QUIRK_NAME_GET
case|:
name|pgq
operator|=
operator|(
name|void
operator|*
operator|)
name|data
expr_stmt|;
name|x
operator|=
name|pgq
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|USB_QUIRK_MAX
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|strlcpy
argument_list|(
name|pgq
operator|->
name|quirkname
argument_list|,
name|usb_quirkstr
argument_list|(
name|x
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pgq
operator|->
name|quirkname
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
case|case
name|USB_DEV_QUIRK_ADD
case|:
name|pgq
operator|=
operator|(
name|void
operator|*
operator|)
name|data
expr_stmt|;
comment|/* check privileges */
name|err
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* convert quirk string into numerical */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|!=
name|USB_DEV_QUIRKS_MAX
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pgq
operator|->
name|quirkname
argument_list|,
name|usb_quirkstr
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|y
operator|==
name|USB_DEV_QUIRKS_MAX
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|y
operator|==
name|UQ_NONE
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|usb_quirk_mtx
argument_list|)
expr_stmt|;
name|pqe
operator|=
name|usb_quirk_get_entry
argument_list|(
name|pgq
operator|->
name|vid
argument_list|,
name|pgq
operator|->
name|pid
argument_list|,
name|pgq
operator|->
name|bcdDeviceLow
argument_list|,
name|pgq
operator|->
name|bcdDeviceHigh
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|USB_SUB_QUIRKS_MAX
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|pqe
operator|->
name|quirks
index|[
name|x
index|]
operator|==
name|UQ_NONE
condition|)
block|{
name|pqe
operator|->
name|quirks
index|[
name|x
index|]
operator|=
name|y
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|usb_quirk_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|USB_SUB_QUIRKS_MAX
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
case|case
name|USB_DEV_QUIRK_REMOVE
case|:
name|pgq
operator|=
operator|(
name|void
operator|*
operator|)
name|data
expr_stmt|;
comment|/* check privileges */
name|err
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* convert quirk string into numerical */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|!=
name|USB_DEV_QUIRKS_MAX
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pgq
operator|->
name|quirkname
argument_list|,
name|usb_quirkstr
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|y
operator|==
name|USB_DEV_QUIRKS_MAX
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|y
operator|==
name|UQ_NONE
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|usb_quirk_mtx
argument_list|)
expr_stmt|;
name|pqe
operator|=
name|usb_quirk_get_entry
argument_list|(
name|pgq
operator|->
name|vid
argument_list|,
name|pgq
operator|->
name|pid
argument_list|,
name|pgq
operator|->
name|bcdDeviceLow
argument_list|,
name|pgq
operator|->
name|bcdDeviceHigh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|USB_SUB_QUIRKS_MAX
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|pqe
operator|->
name|quirks
index|[
name|x
index|]
operator|==
name|y
condition|)
block|{
name|pqe
operator|->
name|quirks
index|[
name|x
index|]
operator|=
name|UQ_NONE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|x
operator|==
name|USB_SUB_QUIRKS_MAX
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|usb_quirk_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|USB_SUB_QUIRKS_MAX
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|pqe
operator|->
name|quirks
index|[
name|x
index|]
operator|!=
name|UQ_NONE
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|x
operator|==
name|USB_SUB_QUIRKS_MAX
condition|)
block|{
comment|/* all quirk entries are unused - release */
name|memset
argument_list|(
name|pqe
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pqe
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|usb_quirk_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
default|default:
break|break;
block|}
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_quirk_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* initialize mutex */
name|mtx_init
argument_list|(
operator|&
name|usb_quirk_mtx
argument_list|,
literal|"USB quirk"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* register our function */
name|usb_test_quirk_p
operator|=
operator|&
name|usb_test_quirk_by_info
expr_stmt|;
name|usb_quirk_ioctl_p
operator|=
operator|&
name|usb_quirk_ioctl
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_quirk_uninit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|usb_quirk_unload
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* destroy mutex */
name|mtx_destroy
argument_list|(
operator|&
name|usb_quirk_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|usb_quirk_init
argument_list|,
name|SI_SUB_LOCK
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|usb_quirk_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|usb_quirk_uninit
argument_list|,
name|SI_SUB_LOCK
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|usb_quirk_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

