begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010 Lev Serebryakov<lev@FreeBSD.org>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This driver supports several multiport USB-to-RS232 serial adapters driven  * by MosChip mos7820 and mos7840, bridge chips.  * The adapters are sold under many different brand names.  *  * Datasheets are available at MosChip www site at  * http://www.moschip.com.  The datasheets don't contain full  * programming information for the chip.  *  * It is nornal to have only two enabled ports in devices, based on  * quad-port mos7840.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_cdc.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|umcs_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/serial/usb_serial.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/serial/umcs.h>
end_include

begin_define
define|#
directive|define
name|UMCS7840_MODVER
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|umcs_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|umcs
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB umcs quadport serial adapter"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_umcs
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|umcs_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USB_DEBUG */
end_comment

begin_comment
comment|/*  * Two-port devices (both with 7820 chip and 7840 chip configured as two-port)  * have ports 0 and 2, with ports 1 and 3 omitted.  * So,PHYSICAL port numbers (indexes) on two-port device will be 0 and 2.  * This driver trys to use physical numbers as much as possible.  */
end_comment

begin_comment
comment|/*  * Indexed by PHYSICAL port number.  * Pack non-regular registers to array to easier if-less access.  */
end_comment

begin_struct
struct|struct
name|umcs7840_port_registers
block|{
name|uint8_t
name|reg_sp
decl_stmt|;
comment|/* SP register. */
name|uint8_t
name|reg_control
decl_stmt|;
comment|/* CONTROL register. */
name|uint8_t
name|reg_dcr
decl_stmt|;
comment|/* DCR0 register. DCR1& DCR2 can be 					 * calculated */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|umcs7840_port_registers
name|umcs7840_port_registers
index|[
name|UMCS7840_MAX_PORTS
index|]
init|=
block|{
block|{
operator|.
name|reg_sp
operator|=
name|MCS7840_DEV_REG_SP1
block|,
operator|.
name|reg_control
operator|=
name|MCS7840_DEV_REG_CONTROL1
block|,
operator|.
name|reg_dcr
operator|=
name|MCS7840_DEV_REG_DCR0_1
block|}
block|,
block|{
operator|.
name|reg_sp
operator|=
name|MCS7840_DEV_REG_SP2
block|,
operator|.
name|reg_control
operator|=
name|MCS7840_DEV_REG_CONTROL2
block|,
operator|.
name|reg_dcr
operator|=
name|MCS7840_DEV_REG_DCR0_2
block|}
block|,
block|{
operator|.
name|reg_sp
operator|=
name|MCS7840_DEV_REG_SP3
block|,
operator|.
name|reg_control
operator|=
name|MCS7840_DEV_REG_CONTROL3
block|,
operator|.
name|reg_dcr
operator|=
name|MCS7840_DEV_REG_DCR0_3
block|}
block|,
block|{
operator|.
name|reg_sp
operator|=
name|MCS7840_DEV_REG_SP4
block|,
operator|.
name|reg_control
operator|=
name|MCS7840_DEV_REG_CONTROL4
block|,
operator|.
name|reg_dcr
operator|=
name|MCS7840_DEV_REG_DCR0_4
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|UMCS7840_BULK_RD_EP
block|,
name|UMCS7840_BULK_WR_EP
block|,
name|UMCS7840_N_TRANSFERS
block|}
enum|;
end_enum

begin_struct
struct|struct
name|umcs7840_softc_oneport
block|{
name|struct
name|usb_xfer
modifier|*
name|sc_xfer
index|[
name|UMCS7840_N_TRANSFERS
index|]
decl_stmt|;
comment|/* Control structures 							 * for two transfers */
name|uint8_t
name|sc_lcr
decl_stmt|;
comment|/* local line control register */
name|uint8_t
name|sc_mcr
decl_stmt|;
comment|/* local modem control register */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|umcs7840_softc
block|{
name|struct
name|ucom_super_softc
name|sc_super_ucom
decl_stmt|;
name|struct
name|ucom_softc
name|sc_ucom
index|[
name|UMCS7840_MAX_PORTS
index|]
decl_stmt|;
comment|/* Need to be continuous 							 * array, so indexed by 							 * LOGICAL port 							 * (subunit) number */
name|struct
name|usb_xfer
modifier|*
name|sc_intr_xfer
decl_stmt|;
comment|/* Interrupt endpoint */
name|device_t
name|sc_dev
decl_stmt|;
comment|/* Device for error prints */
name|struct
name|usb_device
modifier|*
name|sc_udev
decl_stmt|;
comment|/* USB Device for all operations */
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
comment|/* ucom requires this */
name|uint8_t
name|sc_driver_done
decl_stmt|;
comment|/* Flag when enumeration is finished */
name|uint8_t
name|sc_numports
decl_stmt|;
comment|/* Number of ports (subunits) */
name|struct
name|umcs7840_softc_oneport
name|sc_ports
index|[
name|UMCS7840_MAX_PORTS
index|]
decl_stmt|;
comment|/* Indexed by PHYSICAL 									 * port number. */
block|}
struct|;
end_struct

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|usb_error_t
name|umcs7840_get_reg_sync
parameter_list|(
name|struct
name|umcs7840_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|umcs7840_set_reg_sync
parameter_list|(
name|struct
name|umcs7840_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|umcs7840_get_UART_reg_sync
parameter_list|(
name|struct
name|umcs7840_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|umcs7840_set_UART_reg_sync
parameter_list|(
name|struct
name|umcs7840_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|umcs7840_set_baudrate
parameter_list|(
name|struct
name|umcs7840_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|umcs7840_calc_baudrate
parameter_list|(
name|uint32_t
name|rate
parameter_list|,
name|uint16_t
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umcs7840_free
parameter_list|(
name|struct
name|ucom_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umcs7840_cfg_get_status
parameter_list|(
name|struct
name|ucom_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umcs7840_cfg_set_dtr
parameter_list|(
name|struct
name|ucom_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umcs7840_cfg_set_rts
parameter_list|(
name|struct
name|ucom_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umcs7840_cfg_set_break
parameter_list|(
name|struct
name|ucom_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umcs7840_cfg_param
parameter_list|(
name|struct
name|ucom_softc
modifier|*
parameter_list|,
name|struct
name|termios
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umcs7840_cfg_open
parameter_list|(
name|struct
name|ucom_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umcs7840_cfg_close
parameter_list|(
name|struct
name|ucom_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umcs7840_pre_param
parameter_list|(
name|struct
name|ucom_softc
modifier|*
parameter_list|,
name|struct
name|termios
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umcs7840_start_read
parameter_list|(
name|struct
name|ucom_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umcs7840_stop_read
parameter_list|(
name|struct
name|ucom_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umcs7840_start_write
parameter_list|(
name|struct
name|ucom_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umcs7840_stop_write
parameter_list|(
name|struct
name|ucom_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umcs7840_poll
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_probe_t
name|umcs7840_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|umcs7840_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|umcs7840_detach
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|umcs7840_free_softc
parameter_list|(
name|struct
name|umcs7840_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umcs7840_intr_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umcs7840_read_callback1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umcs7840_read_callback2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umcs7840_read_callback3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umcs7840_read_callback4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umcs7840_write_callback1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umcs7840_write_callback2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umcs7840_write_callback3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umcs7840_write_callback4
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|umcs7840_read_callbackN
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|,
name|usb_error_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umcs7840_write_callbackN
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|,
name|usb_error_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Indexed by LOGICAL port number (subunit), so two-port device uses 0& 1 */
end_comment

begin_decl_stmt
specifier|static
name|usb_callback_t
modifier|*
name|umcs7840_rw_callbacks
index|[
name|UMCS7840_MAX_PORTS
index|]
index|[
name|UMCS7840_N_TRANSFERS
index|]
init|=
block|{
block|{
operator|&
name|umcs7840_read_callback1
block|,
operator|&
name|umcs7840_write_callback1
block|}
block|,
block|{
operator|&
name|umcs7840_read_callback2
block|,
operator|&
name|umcs7840_write_callback2
block|}
block|,
block|{
operator|&
name|umcs7840_read_callback3
block|,
operator|&
name|umcs7840_write_callback3
block|}
block|,
block|{
operator|&
name|umcs7840_read_callback4
block|,
operator|&
name|umcs7840_write_callback4
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|umcs7840_bulk_config_data
index|[
name|UMCS7840_N_TRANSFERS
index|]
init|=
block|{
index|[
name|UMCS7840_BULK_RD_EP
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
literal|0x01
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use wMaxPacketSize */
operator|.
name|callback
operator|=
operator|&
name|umcs7840_read_callback1
block|,
operator|.
name|if_index
operator|=
literal|0
block|, 	}
block|,
index|[
name|UMCS7840_BULK_WR_EP
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
literal|0x02
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use wMaxPacketSize */
operator|.
name|callback
operator|=
operator|&
name|umcs7840_write_callback1
block|,
operator|.
name|if_index
operator|=
literal|0
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|umcs7840_intr_config_data
index|[
literal|1
index|]
init|=
block|{
index|[
literal|0
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_INTERRUPT
block|,
operator|.
name|endpoint
operator|=
literal|0x09
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use wMaxPacketSize */
operator|.
name|callback
operator|=
operator|&
name|umcs7840_intr_callback
block|,
operator|.
name|if_index
operator|=
literal|0
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ucom_callback
name|umcs7840_callback
init|=
block|{
operator|.
name|ucom_cfg_get_status
operator|=
operator|&
name|umcs7840_cfg_get_status
block|,
operator|.
name|ucom_cfg_set_dtr
operator|=
operator|&
name|umcs7840_cfg_set_dtr
block|,
operator|.
name|ucom_cfg_set_rts
operator|=
operator|&
name|umcs7840_cfg_set_rts
block|,
operator|.
name|ucom_cfg_set_break
operator|=
operator|&
name|umcs7840_cfg_set_break
block|,
operator|.
name|ucom_cfg_param
operator|=
operator|&
name|umcs7840_cfg_param
block|,
operator|.
name|ucom_cfg_open
operator|=
operator|&
name|umcs7840_cfg_open
block|,
operator|.
name|ucom_cfg_close
operator|=
operator|&
name|umcs7840_cfg_close
block|,
operator|.
name|ucom_pre_param
operator|=
operator|&
name|umcs7840_pre_param
block|,
operator|.
name|ucom_start_read
operator|=
operator|&
name|umcs7840_start_read
block|,
operator|.
name|ucom_stop_read
operator|=
operator|&
name|umcs7840_stop_read
block|,
operator|.
name|ucom_start_write
operator|=
operator|&
name|umcs7840_start_write
block|,
operator|.
name|ucom_stop_write
operator|=
operator|&
name|umcs7840_stop_write
block|,
operator|.
name|ucom_poll
operator|=
operator|&
name|umcs7840_poll
block|,
operator|.
name|ucom_free
operator|=
operator|&
name|umcs7840_free
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|STRUCT_USB_HOST_ID
name|umcs7840_devs
index|[]
init|=
block|{
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_MOSCHIP
argument_list|,
argument|USB_PRODUCT_MOSCHIP_MCS7820
argument_list|,
literal|0
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_MOSCHIP
argument_list|,
argument|USB_PRODUCT_MOSCHIP_MCS7840
argument_list|,
literal|0
argument_list|)
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|umcs7840_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|umcs7840_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|umcs7840_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|umcs7840_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|umcs7840_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|umcs7840_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"umcs7840"
block|,
operator|.
name|methods
operator|=
name|umcs7840_methods
block|,
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|umcs7840_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|umcs7840
argument_list|,
name|uhub
argument_list|,
name|umcs7840_driver
argument_list|,
name|umcs7840_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|umcs7840
argument_list|,
name|ucom
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|umcs7840
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|umcs7840
argument_list|,
name|UMCS7840_MODVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|umcs7840_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bConfigIndex
operator|!=
name|MCS7840_CONFIG_INDEX
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
operator|!=
name|MCS7840_IFACE_INDEX
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|usbd_lookup_id_by_uaa
argument_list|(
name|umcs7840_devs
argument_list|,
sizeof|sizeof
argument_list|(
name|umcs7840_devs
argument_list|)
argument_list|,
name|uaa
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|umcs7840_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_config
name|umcs7840_config_tmp
index|[
name|UMCS7840_N_TRANSFERS
index|]
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint8_t
name|iface_index
init|=
name|MCS7840_IFACE_INDEX
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|subunit
decl_stmt|;
name|int
name|n
decl_stmt|;
name|uint8_t
name|data
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|UMCS7840_N_TRANSFERS
condition|;
operator|++
name|n
control|)
name|umcs7840_config_tmp
index|[
name|n
index|]
operator|=
name|umcs7840_bulk_config_data
index|[
name|n
index|]
expr_stmt|;
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|"umcs7840"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ucom_ref
argument_list|(
operator|&
name|sc
operator|->
name|sc_super_ucom
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
comment|/* 	 * Get number of ports 	 * Documentation (full datasheet) says, that number of ports is 	 * set as MCS7840_DEV_MODE_SELECT24S bit in MODE R/Only 	 * register. But vendor driver uses these undocumented 	 * register& bit. 	 * 	 * Experiments show, that MODE register can have `0' 	 * (4 ports) bit on 2-port device, so use vendor driver's way. 	 * 	 * Also, see notes in header file for these constants. 	 */
name|umcs7840_get_reg_sync
argument_list|(
name|sc
argument_list|,
name|MCS7840_DEV_REG_GPIO
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|MCS7840_DEV_GPIO_4PORTS
condition|)
block|{
name|sc
operator|->
name|sc_numports
operator|=
literal|4
expr_stmt|;
comment|/* Store physical port numbers in sc_portno */
name|sc
operator|->
name|sc_ucom
index|[
literal|0
index|]
operator|.
name|sc_portno
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ucom
index|[
literal|1
index|]
operator|.
name|sc_portno
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_ucom
index|[
literal|2
index|]
operator|.
name|sc_portno
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|sc_ucom
index|[
literal|3
index|]
operator|.
name|sc_portno
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_numports
operator|=
literal|2
expr_stmt|;
comment|/* Store physical port numbers in sc_portno */
name|sc
operator|->
name|sc_ucom
index|[
literal|0
index|]
operator|.
name|sc_portno
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ucom
index|[
literal|1
index|]
operator|.
name|sc_portno
operator|=
literal|2
expr_stmt|;
comment|/* '1' is skipped */
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Chip mcs%04x, found %d active ports\n"
argument_list|,
name|uaa
operator|->
name|info
operator|.
name|idProduct
argument_list|,
name|sc
operator|->
name|sc_numports
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|umcs7840_get_reg_sync
argument_list|(
name|sc
argument_list|,
name|MCS7840_DEV_REG_MODE
argument_list|,
operator|&
name|data
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"On-die confguration: RST: active %s, HRD: %s, PLL: %s, POR: %s, Ports: %s, EEPROM write %s, IrDA is %savailable\n"
argument_list|,
operator|(
name|data
operator|&
name|MCS7840_DEV_MODE_RESET
operator|)
condition|?
literal|"low"
else|:
literal|"high"
argument_list|,
operator|(
name|data
operator|&
name|MCS7840_DEV_MODE_SER_PRSNT
operator|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
operator|(
name|data
operator|&
name|MCS7840_DEV_MODE_PLLBYPASS
operator|)
condition|?
literal|"bypassed"
else|:
literal|"avail"
argument_list|,
operator|(
name|data
operator|&
name|MCS7840_DEV_MODE_PORBYPASS
operator|)
condition|?
literal|"bypassed"
else|:
literal|"avail"
argument_list|,
operator|(
name|data
operator|&
name|MCS7840_DEV_MODE_SELECT24S
operator|)
condition|?
literal|"2"
else|:
literal|"4"
argument_list|,
operator|(
name|data
operator|&
name|MCS7840_DEV_MODE_EEPROMWR
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
name|data
operator|&
name|MCS7840_DEV_MODE_IRDA
operator|)
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
block|}
comment|/* Setup all transfers */
for|for
control|(
name|subunit
operator|=
literal|0
init|;
name|subunit
operator|<
name|sc
operator|->
name|sc_numports
condition|;
operator|++
name|subunit
control|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|UMCS7840_N_TRANSFERS
condition|;
operator|++
name|n
control|)
block|{
comment|/* Set endpoint address */
name|umcs7840_config_tmp
index|[
name|n
index|]
operator|.
name|endpoint
operator|=
name|umcs7840_bulk_config_data
index|[
name|n
index|]
operator|.
name|endpoint
operator|+
literal|2
operator|*
name|sc
operator|->
name|sc_ucom
index|[
name|subunit
index|]
operator|.
name|sc_portno
expr_stmt|;
name|umcs7840_config_tmp
index|[
name|n
index|]
operator|.
name|callback
operator|=
name|umcs7840_rw_callbacks
index|[
name|subunit
index|]
index|[
name|n
index|]
expr_stmt|;
block|}
name|error
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|iface_index
argument_list|,
name|sc
operator|->
name|sc_ports
index|[
name|sc
operator|->
name|sc_ucom
index|[
name|subunit
index|]
operator|.
name|sc_portno
index|]
operator|.
name|sc_xfer
argument_list|,
name|umcs7840_config_tmp
argument_list|,
name|UMCS7840_N_TRANSFERS
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"allocating USB transfers failed for subunit %d of %d\n"
argument_list|,
name|subunit
operator|+
literal|1
argument_list|,
name|sc
operator|->
name|sc_numports
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
block|}
name|error
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|iface_index
argument_list|,
operator|&
name|sc
operator|->
name|sc_intr_xfer
argument_list|,
name|umcs7840_intr_config_data
argument_list|,
literal|1
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"allocating USB transfers failed for interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
comment|/* clear stall at first run */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|subunit
operator|=
literal|0
init|;
name|subunit
operator|<
name|sc
operator|->
name|sc_numports
condition|;
operator|++
name|subunit
control|)
block|{
name|usbd_xfer_set_stall
argument_list|(
name|sc
operator|->
name|sc_ports
index|[
name|sc
operator|->
name|sc_ucom
index|[
name|subunit
index|]
operator|.
name|sc_portno
index|]
operator|.
name|sc_xfer
index|[
name|UMCS7840_BULK_RD_EP
index|]
argument_list|)
expr_stmt|;
name|usbd_xfer_set_stall
argument_list|(
name|sc
operator|->
name|sc_ports
index|[
name|sc
operator|->
name|sc_ucom
index|[
name|subunit
index|]
operator|.
name|sc_portno
index|]
operator|.
name|sc_xfer
index|[
name|UMCS7840_BULK_WR_EP
index|]
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|ucom_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_super_ucom
argument_list|,
name|sc
operator|->
name|sc_ucom
argument_list|,
name|sc
operator|->
name|sc_numports
argument_list|,
name|sc
argument_list|,
operator|&
name|umcs7840_callback
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|detach
goto|;
name|ucom_set_pnpinfo_usb
argument_list|(
operator|&
name|sc
operator|->
name|sc_super_ucom
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|detach
label|:
name|umcs7840_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|umcs7840_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|subunit
decl_stmt|;
name|ucom_detach
argument_list|(
operator|&
name|sc
operator|->
name|sc_super_ucom
argument_list|,
name|sc
operator|->
name|sc_ucom
argument_list|)
expr_stmt|;
for|for
control|(
name|subunit
operator|=
literal|0
init|;
name|subunit
operator|<
name|sc
operator|->
name|sc_numports
condition|;
operator|++
name|subunit
control|)
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_ports
index|[
name|sc
operator|->
name|sc_ucom
index|[
name|subunit
index|]
operator|.
name|sc_portno
index|]
operator|.
name|sc_xfer
argument_list|,
name|UMCS7840_N_TRANSFERS
argument_list|)
expr_stmt|;
name|usbd_transfer_unsetup
argument_list|(
operator|&
name|sc
operator|->
name|sc_intr_xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|device_claim_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|umcs7840_free_softc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|UCOM_UNLOAD_DRAIN
argument_list|(
name|umcs7840
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|umcs7840_free_softc
parameter_list|(
name|struct
name|umcs7840_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|ucom_unref
argument_list|(
operator|&
name|sc
operator|->
name|sc_super_ucom
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|device_free_softc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_free
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|)
block|{
name|umcs7840_free_softc
argument_list|(
name|ucom
operator|->
name|sc_parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_cfg_open
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|ucom
operator|->
name|sc_parent
decl_stmt|;
name|uint16_t
name|pn
init|=
name|ucom
operator|->
name|sc_portno
decl_stmt|;
name|uint8_t
name|data
decl_stmt|;
comment|/* If it very first open, finish global configuration */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_driver_done
condition|)
block|{
comment|/* 		 * USB enumeration is finished, pass internal memory to FIFOs 		 * If it is done in the end of "attach", kernel panics. 		 */
if|if
condition|(
name|umcs7840_get_reg_sync
argument_list|(
name|sc
argument_list|,
name|MCS7840_DEV_REG_CONTROL1
argument_list|,
operator|&
name|data
argument_list|)
condition|)
return|return;
name|data
operator||=
name|MCS7840_DEV_CONTROL1_DRIVER_DONE
expr_stmt|;
if|if
condition|(
name|umcs7840_set_reg_sync
argument_list|(
name|sc
argument_list|,
name|MCS7840_DEV_REG_CONTROL1
argument_list|,
name|data
argument_list|)
condition|)
return|return;
name|sc
operator|->
name|sc_driver_done
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Toggle reset bit on-off */
if|if
condition|(
name|umcs7840_get_reg_sync
argument_list|(
name|sc
argument_list|,
name|umcs7840_port_registers
index|[
name|pn
index|]
operator|.
name|reg_sp
argument_list|,
operator|&
name|data
argument_list|)
condition|)
return|return;
name|data
operator||=
name|MCS7840_DEV_SPx_UART_RESET
expr_stmt|;
if|if
condition|(
name|umcs7840_set_reg_sync
argument_list|(
name|sc
argument_list|,
name|umcs7840_port_registers
index|[
name|pn
index|]
operator|.
name|reg_sp
argument_list|,
name|data
argument_list|)
condition|)
return|return;
name|data
operator|&=
operator|~
name|MCS7840_DEV_SPx_UART_RESET
expr_stmt|;
if|if
condition|(
name|umcs7840_set_reg_sync
argument_list|(
name|sc
argument_list|,
name|umcs7840_port_registers
index|[
name|pn
index|]
operator|.
name|reg_sp
argument_list|,
name|data
argument_list|)
condition|)
return|return;
comment|/* Set RS-232 mode */
if|if
condition|(
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_SCRATCHPAD
argument_list|,
name|MCS7840_UART_SCRATCHPAD_RS232
argument_list|)
condition|)
return|return;
comment|/* Disable RX on time of initialization */
if|if
condition|(
name|umcs7840_get_reg_sync
argument_list|(
name|sc
argument_list|,
name|umcs7840_port_registers
index|[
name|pn
index|]
operator|.
name|reg_control
argument_list|,
operator|&
name|data
argument_list|)
condition|)
return|return;
name|data
operator||=
name|MCS7840_DEV_CONTROLx_RX_DISABLE
expr_stmt|;
if|if
condition|(
name|umcs7840_set_reg_sync
argument_list|(
name|sc
argument_list|,
name|umcs7840_port_registers
index|[
name|pn
index|]
operator|.
name|reg_control
argument_list|,
name|data
argument_list|)
condition|)
return|return;
comment|/* Disable all interrupts */
if|if
condition|(
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_IER
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* Reset FIFO -- documented */
if|if
condition|(
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_FCR
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_FCR
argument_list|,
name|MCS7840_UART_FCR_ENABLE
operator||
name|MCS7840_UART_FCR_FLUSHRHR
operator||
name|MCS7840_UART_FCR_FLUSHTHR
operator||
name|MCS7840_UART_FCR_RTL_1_14
argument_list|)
condition|)
return|return;
comment|/* Set 8 bit, no parity, 1 stop bit -- documented */
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_lcr
operator|=
name|MCS7840_UART_LCR_DATALEN8
operator||
name|MCS7840_UART_LCR_STOPB1
expr_stmt|;
if|if
condition|(
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_LCR
argument_list|,
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_lcr
argument_list|)
condition|)
return|return;
comment|/* 	 * Enable DTR/RTS on modem control, enable modem interrupts -- 	 * documented 	 */
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_mcr
operator|=
name|MCS7840_UART_MCR_DTR
operator||
name|MCS7840_UART_MCR_RTS
operator||
name|MCS7840_UART_MCR_IE
expr_stmt|;
if|if
condition|(
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_MCR
argument_list|,
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_mcr
argument_list|)
condition|)
return|return;
comment|/* Clearing Bulkin and Bulkout FIFO */
if|if
condition|(
name|umcs7840_get_reg_sync
argument_list|(
name|sc
argument_list|,
name|umcs7840_port_registers
index|[
name|pn
index|]
operator|.
name|reg_sp
argument_list|,
operator|&
name|data
argument_list|)
condition|)
return|return;
name|data
operator||=
name|MCS7840_DEV_SPx_RESET_OUT_FIFO
operator||
name|MCS7840_DEV_SPx_RESET_IN_FIFO
expr_stmt|;
if|if
condition|(
name|umcs7840_set_reg_sync
argument_list|(
name|sc
argument_list|,
name|umcs7840_port_registers
index|[
name|pn
index|]
operator|.
name|reg_sp
argument_list|,
name|data
argument_list|)
condition|)
return|return;
name|data
operator|&=
operator|~
operator|(
name|MCS7840_DEV_SPx_RESET_OUT_FIFO
operator||
name|MCS7840_DEV_SPx_RESET_IN_FIFO
operator|)
expr_stmt|;
if|if
condition|(
name|umcs7840_set_reg_sync
argument_list|(
name|sc
argument_list|,
name|umcs7840_port_registers
index|[
name|pn
index|]
operator|.
name|reg_sp
argument_list|,
name|data
argument_list|)
condition|)
return|return;
comment|/* Set speed 9600 */
if|if
condition|(
name|umcs7840_set_baudrate
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
literal|9600
argument_list|)
condition|)
return|return;
comment|/* Finally enable all interrupts -- documented */
comment|/* 	 * Copied from vendor driver, I don't know why we should read LCR 	 * here 	 */
if|if
condition|(
name|umcs7840_get_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_LCR
argument_list|,
operator|&
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_lcr
argument_list|)
condition|)
return|return;
if|if
condition|(
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_IER
argument_list|,
name|MCS7840_UART_IER_RXSTAT
operator||
name|MCS7840_UART_IER_MODEM
argument_list|)
condition|)
return|return;
comment|/* Enable RX */
if|if
condition|(
name|umcs7840_get_reg_sync
argument_list|(
name|sc
argument_list|,
name|umcs7840_port_registers
index|[
name|pn
index|]
operator|.
name|reg_control
argument_list|,
operator|&
name|data
argument_list|)
condition|)
return|return;
name|data
operator|&=
operator|~
name|MCS7840_DEV_CONTROLx_RX_DISABLE
expr_stmt|;
if|if
condition|(
name|umcs7840_set_reg_sync
argument_list|(
name|sc
argument_list|,
name|umcs7840_port_registers
index|[
name|pn
index|]
operator|.
name|reg_control
argument_list|,
name|data
argument_list|)
condition|)
return|return;
name|DPRINTF
argument_list|(
literal|"Port %d has been opened\n"
argument_list|,
name|pn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_cfg_close
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|ucom
operator|->
name|sc_parent
decl_stmt|;
name|uint16_t
name|pn
init|=
name|ucom
operator|->
name|sc_portno
decl_stmt|;
name|uint8_t
name|data
decl_stmt|;
name|umcs7840_stop_read
argument_list|(
name|ucom
argument_list|)
expr_stmt|;
name|umcs7840_stop_write
argument_list|(
name|ucom
argument_list|)
expr_stmt|;
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_MCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_IER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable RX */
if|if
condition|(
name|umcs7840_get_reg_sync
argument_list|(
name|sc
argument_list|,
name|umcs7840_port_registers
index|[
name|pn
index|]
operator|.
name|reg_control
argument_list|,
operator|&
name|data
argument_list|)
condition|)
return|return;
name|data
operator||=
name|MCS7840_DEV_CONTROLx_RX_DISABLE
expr_stmt|;
if|if
condition|(
name|umcs7840_set_reg_sync
argument_list|(
name|sc
argument_list|,
name|umcs7840_port_registers
index|[
name|pn
index|]
operator|.
name|reg_control
argument_list|,
name|data
argument_list|)
condition|)
return|return;
name|DPRINTF
argument_list|(
literal|"Port %d has been closed\n"
argument_list|,
name|pn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_cfg_set_dtr
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|,
name|uint8_t
name|onoff
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|ucom
operator|->
name|sc_parent
decl_stmt|;
name|uint8_t
name|pn
init|=
name|ucom
operator|->
name|sc_portno
decl_stmt|;
if|if
condition|(
name|onoff
condition|)
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_mcr
operator||=
name|MCS7840_UART_MCR_DTR
expr_stmt|;
else|else
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_mcr
operator|&=
operator|~
name|MCS7840_UART_MCR_DTR
expr_stmt|;
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_MCR
argument_list|,
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_mcr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Port %d DTR set to: %s\n"
argument_list|,
name|pn
argument_list|,
name|onoff
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_cfg_set_rts
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|,
name|uint8_t
name|onoff
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|ucom
operator|->
name|sc_parent
decl_stmt|;
name|uint8_t
name|pn
init|=
name|ucom
operator|->
name|sc_portno
decl_stmt|;
if|if
condition|(
name|onoff
condition|)
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_mcr
operator||=
name|MCS7840_UART_MCR_RTS
expr_stmt|;
else|else
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_mcr
operator|&=
operator|~
name|MCS7840_UART_MCR_RTS
expr_stmt|;
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_MCR
argument_list|,
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_mcr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Port %d RTS set to: %s\n"
argument_list|,
name|pn
argument_list|,
name|onoff
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_cfg_set_break
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|,
name|uint8_t
name|onoff
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|ucom
operator|->
name|sc_parent
decl_stmt|;
name|uint8_t
name|pn
init|=
name|ucom
operator|->
name|sc_portno
decl_stmt|;
if|if
condition|(
name|onoff
condition|)
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_lcr
operator||=
name|MCS7840_UART_LCR_BREAK
expr_stmt|;
else|else
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_lcr
operator|&=
operator|~
name|MCS7840_UART_LCR_BREAK
expr_stmt|;
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_LCR
argument_list|,
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_lcr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Port %d BREAK set to: %s\n"
argument_list|,
name|pn
argument_list|,
name|onoff
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_cfg_param
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|ucom
operator|->
name|sc_parent
decl_stmt|;
name|uint8_t
name|pn
init|=
name|ucom
operator|->
name|sc_portno
decl_stmt|;
name|uint8_t
name|lcr
init|=
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_lcr
decl_stmt|;
name|uint8_t
name|mcr
init|=
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_mcr
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"Port %d config:\n"
argument_list|,
name|pn
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|CSTOPB
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"  2 stop bits\n"
argument_list|)
expr_stmt|;
name|lcr
operator||=
name|MCS7840_UART_LCR_STOPB2
expr_stmt|;
block|}
else|else
block|{
name|lcr
operator||=
name|MCS7840_UART_LCR_STOPB1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"  1 stop bit\n"
argument_list|)
expr_stmt|;
block|}
name|lcr
operator|&=
operator|~
name|MCS7840_UART_LCR_PARITYMASK
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|PARENB
condition|)
block|{
name|lcr
operator||=
name|MCS7840_UART_LCR_PARITYON
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|PARODD
condition|)
block|{
name|lcr
operator|=
name|MCS7840_UART_LCR_PARITYODD
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"  parity on - odd\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lcr
operator|=
name|MCS7840_UART_LCR_PARITYEVEN
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"  parity on - even\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lcr
operator|&=
operator|~
name|MCS7840_UART_LCR_PARITYON
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"  parity off\n"
argument_list|)
expr_stmt|;
block|}
name|lcr
operator|&=
operator|~
name|MCS7840_UART_LCR_DATALENMASK
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS5
case|:
name|lcr
operator||=
name|MCS7840_UART_LCR_DATALEN5
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"  5 bit\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|lcr
operator||=
name|MCS7840_UART_LCR_DATALEN6
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"  6 bit\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|lcr
operator||=
name|MCS7840_UART_LCR_DATALEN7
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"  7 bit\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS8
case|:
name|lcr
operator||=
name|MCS7840_UART_LCR_DATALEN8
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"  8 bit\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|CRTSCTS
condition|)
block|{
name|mcr
operator||=
name|MCS7840_UART_MCR_CTSRTS
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"  CTS/RTS\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|mcr
operator|&=
operator|~
name|MCS7840_UART_MCR_CTSRTS
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
operator|(
name|CDTR_IFLOW
operator||
name|CDSR_OFLOW
operator|)
condition|)
block|{
name|mcr
operator||=
name|MCS7840_UART_MCR_DTRDSR
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"  DTR/DSR\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|mcr
operator|&=
operator|~
name|MCS7840_UART_MCR_DTRDSR
expr_stmt|;
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_lcr
operator|=
name|lcr
expr_stmt|;
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_LCR
argument_list|,
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_lcr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Port %d LCR=%02x\n"
argument_list|,
name|pn
argument_list|,
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_lcr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_mcr
operator|=
name|mcr
expr_stmt|;
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_MCR
argument_list|,
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_mcr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Port %d MCR=%02x\n"
argument_list|,
name|pn
argument_list|,
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_mcr
argument_list|)
expr_stmt|;
name|umcs7840_set_baudrate
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|t
operator|->
name|c_ospeed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|umcs7840_pre_param
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|uint8_t
name|clk
decl_stmt|;
name|uint16_t
name|divisor
decl_stmt|;
if|if
condition|(
name|umcs7840_calc_baudrate
argument_list|(
name|t
operator|->
name|c_ospeed
argument_list|,
operator|&
name|divisor
argument_list|,
operator|&
name|clk
argument_list|)
operator|||
operator|!
name|divisor
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_start_read
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|ucom
operator|->
name|sc_parent
decl_stmt|;
name|uint8_t
name|pn
init|=
name|ucom
operator|->
name|sc_portno
decl_stmt|;
comment|/* Start interrupt transfer */
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_intr_xfer
argument_list|)
expr_stmt|;
comment|/* Start read transfer */
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_xfer
index|[
name|UMCS7840_BULK_RD_EP
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_stop_read
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|ucom
operator|->
name|sc_parent
decl_stmt|;
name|uint8_t
name|pn
init|=
name|ucom
operator|->
name|sc_portno
decl_stmt|;
comment|/* Stop read transfer */
name|usbd_transfer_stop
argument_list|(
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_xfer
index|[
name|UMCS7840_BULK_RD_EP
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_start_write
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|ucom
operator|->
name|sc_parent
decl_stmt|;
name|uint8_t
name|pn
init|=
name|ucom
operator|->
name|sc_portno
decl_stmt|;
comment|/* Start interrupt transfer */
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_intr_xfer
argument_list|)
expr_stmt|;
comment|/* Start write transfer */
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_xfer
index|[
name|UMCS7840_BULK_WR_EP
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_stop_write
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|ucom
operator|->
name|sc_parent
decl_stmt|;
name|uint8_t
name|pn
init|=
name|ucom
operator|->
name|sc_portno
decl_stmt|;
comment|/* Stop write transfer */
name|usbd_transfer_stop
argument_list|(
name|sc
operator|->
name|sc_ports
index|[
name|pn
index|]
operator|.
name|sc_xfer
index|[
name|UMCS7840_BULK_WR_EP
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_cfg_get_status
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|,
name|uint8_t
modifier|*
name|lsr
parameter_list|,
name|uint8_t
modifier|*
name|msr
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|ucom
operator|->
name|sc_parent
decl_stmt|;
name|uint8_t
name|pn
init|=
name|ucom
operator|->
name|sc_portno
decl_stmt|;
name|uint8_t
name|hw_lsr
init|=
literal|0
decl_stmt|;
comment|/* local line status register */
name|uint8_t
name|hw_msr
init|=
literal|0
decl_stmt|;
comment|/* local modem status register */
comment|/* Read LSR& MSR */
name|umcs7840_get_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_LSR
argument_list|,
operator|&
name|hw_lsr
argument_list|)
expr_stmt|;
name|umcs7840_get_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|pn
argument_list|,
name|MCS7840_UART_REG_MSR
argument_list|,
operator|&
name|hw_msr
argument_list|)
expr_stmt|;
operator|*
name|lsr
operator|=
name|hw_lsr
expr_stmt|;
operator|*
name|msr
operator|=
name|hw_msr
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Port %d status: LSR=%02x MSR=%02x\n"
argument_list|,
name|ucom
operator|->
name|sc_portno
argument_list|,
operator|*
name|lsr
argument_list|,
operator|*
name|msr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_intr_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|13
index|]
decl_stmt|;
name|int
name|actlen
decl_stmt|;
name|int
name|subunit
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
if|if
condition|(
name|actlen
operator|==
literal|5
operator|||
name|actlen
operator|==
literal|13
condition|)
block|{
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
comment|/* Check status of all ports */
for|for
control|(
name|subunit
operator|=
literal|0
init|;
name|subunit
operator|<
name|sc
operator|->
name|sc_numports
condition|;
operator|++
name|subunit
control|)
block|{
name|uint8_t
name|pn
init|=
name|sc
operator|->
name|sc_ucom
index|[
name|subunit
index|]
operator|.
name|sc_portno
decl_stmt|;
if|if
condition|(
name|buf
index|[
name|pn
index|]
operator|&
name|MCS7840_UART_ISR_NOPENDING
condition|)
continue|continue;
name|DPRINTF
argument_list|(
literal|"Port %d has pending interrupt: %02x (FIFO: %02x)\n"
argument_list|,
name|pn
argument_list|,
name|buf
index|[
name|pn
index|]
operator|&
name|MCS7840_UART_ISR_INTMASK
argument_list|,
name|buf
index|[
name|pn
index|]
operator|&
operator|(
operator|~
name|MCS7840_UART_ISR_INTMASK
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
name|pn
index|]
operator|&
name|MCS7840_UART_ISR_INTMASK
condition|)
block|{
case|case
name|MCS7840_UART_ISR_RXERR
case|:
case|case
name|MCS7840_UART_ISR_RXHASDATA
case|:
case|case
name|MCS7840_UART_ISR_RXTIMEOUT
case|:
case|case
name|MCS7840_UART_ISR_MSCHANGE
case|:
name|ucom_status_change
argument_list|(
operator|&
name|sc
operator|->
name|sc_ucom
index|[
name|subunit
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
break|break;
block|}
block|}
block|}
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Invalid interrupt data length %d"
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Error */
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* try to clear stall first */
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_read_callback1
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umcs7840_read_callbackN
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_read_callback2
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umcs7840_read_callbackN
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_read_callback3
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umcs7840_read_callbackN
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_read_callback4
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umcs7840_read_callbackN
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_read_callbackN
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|,
name|uint8_t
name|subunit
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|ucom_softc
modifier|*
name|ucom
init|=
operator|&
name|sc
operator|->
name|sc_ucom
index|[
name|subunit
index|]
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|int
name|actlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Port %d read, state = %d, data length = %d\n"
argument_list|,
name|ucom
operator|->
name|sc_portno
argument_list|,
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ucom_put_data
argument_list|(
name|ucom
argument_list|,
name|pc
argument_list|,
literal|0
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Error */
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* try to clear stall first */
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_write_callback1
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umcs7840_write_callbackN
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_write_callback2
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umcs7840_write_callbackN
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_write_callback3
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umcs7840_write_callbackN
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_write_callback4
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umcs7840_write_callbackN
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_write_callbackN
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|,
name|uint8_t
name|subunit
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|ucom_softc
modifier|*
name|ucom
init|=
operator|&
name|sc
operator|->
name|sc_ucom
index|[
name|subunit
index|]
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint32_t
name|actlen
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"Port %d write, state = %d\n"
argument_list|,
name|ucom
operator|->
name|sc_portno
argument_list|,
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_SETUP
case|:
case|case
name|USB_ST_TRANSFERRED
case|:
name|tr_setup
label|:
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucom_get_data
argument_list|(
name|ucom
argument_list|,
name|pc
argument_list|,
literal|0
argument_list|,
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|,
operator|&
name|actlen
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Port %d write, has %d bytes\n"
argument_list|,
name|ucom
operator|->
name|sc_portno
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
comment|/* Error */
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* try to clear stall first */
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umcs7840_poll
parameter_list|(
name|struct
name|ucom_softc
modifier|*
name|ucom
parameter_list|)
block|{
name|struct
name|umcs7840_softc
modifier|*
name|sc
init|=
name|ucom
operator|->
name|sc_parent
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"Port %d poll\n"
argument_list|,
name|ucom
operator|->
name|sc_portno
argument_list|)
expr_stmt|;
name|usbd_transfer_poll
argument_list|(
name|sc
operator|->
name|sc_ports
index|[
name|ucom
operator|->
name|sc_portno
index|]
operator|.
name|sc_xfer
argument_list|,
name|UMCS7840_N_TRANSFERS
argument_list|)
expr_stmt|;
name|usbd_transfer_poll
argument_list|(
operator|&
name|sc
operator|->
name|sc_intr_xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|umcs7840_get_reg_sync
parameter_list|(
name|struct
name|umcs7840_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_READ_VENDOR_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|MCS7840_RDREQ
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|UMCS7840_READ_LENGTH
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_do_request_proc
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_super_ucom
operator|.
name|sc_tq
argument_list|,
operator|&
name|req
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
literal|0
argument_list|,
operator|&
name|len
argument_list|,
name|UMCS7840_CTRL_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|USB_ERR_NORMAL_COMPLETION
operator|&&
name|len
operator|!=
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Reading register %d failed: invalid length %d\n"
argument_list|,
name|reg
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Reading register %d failed: %s\n"
argument_list|,
name|reg
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|umcs7840_set_reg_sync
parameter_list|(
name|struct
name|umcs7840_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
name|uint8_t
name|data
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_VENDOR_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|MCS7840_WRREQ
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_do_request_proc
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_super_ucom
operator|.
name|sc_tq
argument_list|,
operator|&
name|req
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|UMCS7840_CTRL_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Writing register %d failed: %s\n"
argument_list|,
name|reg
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|umcs7840_get_UART_reg_sync
parameter_list|(
name|struct
name|umcs7840_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|portno
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|uint16_t
name|wVal
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
comment|/* portno is port number */
name|wVal
operator|=
operator|(
call|(
name|uint16_t
call|)
argument_list|(
name|portno
operator|+
literal|1
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_READ_VENDOR_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|MCS7840_RDREQ
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|wVal
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|UMCS7840_READ_LENGTH
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_do_request_proc
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_super_ucom
operator|.
name|sc_tq
argument_list|,
operator|&
name|req
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
literal|0
argument_list|,
operator|&
name|len
argument_list|,
name|UMCS7840_CTRL_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|USB_ERR_NORMAL_COMPLETION
operator|&&
name|len
operator|!=
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Reading UART%d register %d failed: invalid length %d\n"
argument_list|,
name|portno
argument_list|,
name|reg
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Reading UART%d register %d failed: %s\n"
argument_list|,
name|portno
argument_list|,
name|reg
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|umcs7840_set_UART_reg_sync
parameter_list|(
name|struct
name|umcs7840_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|portno
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
name|uint8_t
name|data
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|uint16_t
name|wVal
decl_stmt|;
comment|/* portno is port number */
name|wVal
operator|=
operator|(
call|(
name|uint16_t
call|)
argument_list|(
name|portno
operator|+
literal|1
argument_list|)
operator|)
operator|<<
literal|8
operator||
name|data
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_VENDOR_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|MCS7840_WRREQ
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|wVal
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_do_request_proc
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_super_ucom
operator|.
name|sc_tq
argument_list|,
operator|&
name|req
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|UMCS7840_CTRL_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Writing UART%d register %d failed: %s\n"
argument_list|,
name|portno
argument_list|,
name|reg
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|umcs7840_set_baudrate
parameter_list|(
name|struct
name|umcs7840_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|portno
parameter_list|,
name|uint32_t
name|rate
parameter_list|)
block|{
name|usb_error_t
name|err
decl_stmt|;
name|uint16_t
name|divisor
decl_stmt|;
name|uint8_t
name|clk
decl_stmt|;
name|uint8_t
name|data
decl_stmt|;
if|if
condition|(
name|umcs7840_calc_baudrate
argument_list|(
name|rate
argument_list|,
operator|&
name|divisor
argument_list|,
operator|&
name|clk
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Port %d bad speed: %d\n"
argument_list|,
name|portno
argument_list|,
name|rate
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|divisor
operator|==
literal|0
operator|||
operator|(
name|clk
operator|&
name|MCS7840_DEV_SPx_CLOCK_MASK
operator|)
operator|!=
name|clk
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Port %d bad speed calculation: %d\n"
argument_list|,
name|portno
argument_list|,
name|rate
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
literal|"Port %d set speed: %d (%02x / %d)\n"
argument_list|,
name|portno
argument_list|,
name|rate
argument_list|,
name|clk
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
comment|/* Set clock source for standard BAUD frequences */
name|err
operator|=
name|umcs7840_get_reg_sync
argument_list|(
name|sc
argument_list|,
name|umcs7840_port_registers
index|[
name|portno
index|]
operator|.
name|reg_sp
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|data
operator|&=
name|MCS7840_DEV_SPx_CLOCK_MASK
expr_stmt|;
name|data
operator||=
name|clk
expr_stmt|;
name|err
operator|=
name|umcs7840_set_reg_sync
argument_list|(
name|sc
argument_list|,
name|umcs7840_port_registers
index|[
name|portno
index|]
operator|.
name|reg_sp
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Set divider */
name|sc
operator|->
name|sc_ports
index|[
name|portno
index|]
operator|.
name|sc_lcr
operator||=
name|MCS7840_UART_LCR_DIVISORS
expr_stmt|;
name|err
operator|=
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|portno
argument_list|,
name|MCS7840_UART_REG_LCR
argument_list|,
name|sc
operator|->
name|sc_ports
index|[
name|portno
index|]
operator|.
name|sc_lcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|portno
argument_list|,
name|MCS7840_UART_REG_DLL
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
name|divisor
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|portno
argument_list|,
name|MCS7840_UART_REG_DLM
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|divisor
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Turn off access to DLL/DLM registers of UART */
name|sc
operator|->
name|sc_ports
index|[
name|portno
index|]
operator|.
name|sc_lcr
operator|&=
operator|~
name|MCS7840_UART_LCR_DIVISORS
expr_stmt|;
name|err
operator|=
name|umcs7840_set_UART_reg_sync
argument_list|(
name|sc
argument_list|,
name|portno
argument_list|,
name|MCS7840_UART_REG_LCR
argument_list|,
name|sc
operator|->
name|sc_ports
index|[
name|portno
index|]
operator|.
name|sc_lcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Maximum speeds for standard frequences, when PLL is not used */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|umcs7840_baudrate_divisors
index|[]
init|=
block|{
literal|0
block|,
literal|115200
block|,
literal|230400
block|,
literal|403200
block|,
literal|460800
block|,
literal|806400
block|,
literal|921600
block|,
literal|1572864
block|,
literal|3145728
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|umcs7840_baudrate_divisors_len
init|=
sizeof|sizeof
argument_list|(
name|umcs7840_baudrate_divisors
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|umcs7840_baudrate_divisors
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|usb_error_t
name|umcs7840_calc_baudrate
parameter_list|(
name|uint32_t
name|rate
parameter_list|,
name|uint16_t
modifier|*
name|divisor
parameter_list|,
name|uint8_t
modifier|*
name|clk
parameter_list|)
block|{
name|uint8_t
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rate
operator|>
name|umcs7840_baudrate_divisors
index|[
name|umcs7840_baudrate_divisors_len
operator|-
literal|1
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|umcs7840_baudrate_divisors_len
operator|-
literal|1
operator|&&
operator|!
operator|(
name|rate
operator|>
name|umcs7840_baudrate_divisors
index|[
name|i
index|]
operator|&&
name|rate
operator|<=
name|umcs7840_baudrate_divisors
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|;
operator|++
name|i
control|)
empty_stmt|;
if|if
condition|(
name|rate
operator|==
literal|0
condition|)
operator|*
name|divisor
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
else|else
operator|*
name|divisor
operator|=
name|umcs7840_baudrate_divisors
index|[
name|i
operator|+
literal|1
index|]
operator|/
name|rate
expr_stmt|;
comment|/* 0x00 .. 0x70 */
operator|*
name|clk
operator|=
name|i
operator|<<
name|MCS7840_DEV_SPx_CLOCK_SHIFT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

