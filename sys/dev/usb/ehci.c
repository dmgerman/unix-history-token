begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: ehci.c,v 1.91 2005/02/27 00:27:51 perry Exp $ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2004 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (lennart@augustsson.net) and by Charles M. Hannum.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * USB Enhanced Host Controller Driver, a.k.a. USB 2.0 controller.  *  * The EHCI 1.0 spec can be found at  * http://developer.intel.com/technology/usb/download/ehci-r10.pdf  * and the USB 2.0 spec at  * http://www.usb.org/developers/docs/usb_20.zip  *  */
end_comment

begin_comment
comment|/*  * TODO:  * 1) The EHCI driver lacks support for isochronous transfers, so  *    devices using them don't work.  *  * 2) Interrupt transfer scheduling does not manage the time available  *    in each frame, so it is possible for the transfers to overrun  *    the end of the frame.  *  * 3) Command failures are not recovered correctly.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/lockmgr.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/endian.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_mem.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_quirks.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/ehcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/ehcivar.h>
end_include

begin_define
define|#
directive|define
name|delay
parameter_list|(
name|d
parameter_list|)
value|DELAY(d)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|EHCI_DEBUG
value|USB_DEBUG
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|do { if (ehcidebug) printf x; } while (0)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|do { if (ehcidebug>(n)) printf x; } while (0)
end_define

begin_decl_stmt
name|int
name|ehcidebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|ehci
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB ehci"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_ehci
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ehcidebug
argument_list|,
literal|0
argument_list|,
literal|"ehci debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|bitmask_snprintf
parameter_list|(
name|q
parameter_list|,
name|f
parameter_list|,
name|b
parameter_list|,
name|l
parameter_list|)
value|snprintf((b), (l), "%b", (q), (f))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|ehci_pipe
block|{
name|struct
name|usbd_pipe
name|pipe
decl_stmt|;
name|ehci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
union|union
block|{
name|ehci_soft_qtd_t
modifier|*
name|qtd
decl_stmt|;
comment|/* ehci_soft_itd_t *itd; */
block|}
name|tail
union|;
union|union
block|{
comment|/* Control pipe */
struct|struct
block|{
name|usb_dma_t
name|reqdma
decl_stmt|;
name|u_int
name|length
decl_stmt|;
comment|/*ehci_soft_qtd_t *setup, *data, *stat;*/
block|}
name|ctl
struct|;
comment|/* Interrupt pipe */
struct|struct
block|{
name|u_int
name|length
decl_stmt|;
block|}
name|intr
struct|;
comment|/* Bulk pipe */
struct|struct
block|{
name|u_int
name|length
decl_stmt|;
block|}
name|bulk
struct|;
comment|/* Iso pipe */
comment|/* XXX */
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|usbd_status
name|ehci_open
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_poll
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_softintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ehci_intr1
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_waitintr
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|,
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_check_intr
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|,
name|struct
name|ehci_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_idone
parameter_list|(
name|struct
name|ehci_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_timeout_task
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_intrlist_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_allocm
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|,
name|usb_dma_t
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_freem
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|,
name|usb_dma_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_xfer_handle
name|ehci_allocx
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_freex
parameter_list|(
name|struct
name|usbd_bus
modifier|*
parameter_list|,
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_root_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_root_ctrl_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_root_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_root_ctrl_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_root_ctrl_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_root_intr_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_root_intr_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_root_intr_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_root_intr_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_root_intr_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_device_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_device_ctrl_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_device_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_device_ctrl_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_device_ctrl_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_device_bulk_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_device_bulk_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_device_bulk_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_device_bulk_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_device_bulk_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_device_intr_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_device_intr_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_device_intr_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_device_intr_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_device_intr_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_device_isoc_transfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_device_isoc_start
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_device_isoc_abort
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_device_isoc_close
parameter_list|(
name|usbd_pipe_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_device_isoc_done
parameter_list|(
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_device_clear_toggle
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_noop
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ehci_str
parameter_list|(
name|usb_string_descriptor_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_pcd
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|,
name|usbd_xfer_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_pcd_able
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_pcd_enable
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_disown
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ehci_soft_qh_t
modifier|*
name|ehci_alloc_sqh
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_free_sqh
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|,
name|ehci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ehci_soft_qtd_t
modifier|*
name|ehci_alloc_sqtd
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_free_sqtd
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_alloc_sqtd_chain
parameter_list|(
name|struct
name|ehci_pipe
modifier|*
parameter_list|,
name|ehci_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|usbd_xfer_handle
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
modifier|*
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_free_sqtd_chain
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|,
name|ehci_soft_qh_t
modifier|*
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_device_request
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|ehci_device_setintr
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|,
name|ehci_soft_qh_t
modifier|*
parameter_list|,
name|int
name|ival
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_add_qh
parameter_list|(
name|ehci_soft_qh_t
modifier|*
parameter_list|,
name|ehci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_rem_qh
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|,
name|ehci_soft_qh_t
modifier|*
parameter_list|,
name|ehci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_activate_qh
parameter_list|(
name|ehci_soft_qh_t
modifier|*
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_sync_hc
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_close_pipe
parameter_list|(
name|usbd_pipe_handle
parameter_list|,
name|ehci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_abort_xfer
parameter_list|(
name|usbd_xfer_handle
parameter_list|,
name|usbd_status
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|EHCI_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|ehci_dump_regs
parameter_list|(
name|ehci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ehci_dump
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|ehci_softc_t
modifier|*
name|theehci
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ehci_dump_link
parameter_list|(
name|ehci_link_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_dump_sqtds
parameter_list|(
name|ehci_soft_qtd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_dump_sqtd
parameter_list|(
name|ehci_soft_qtd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_dump_qtd
parameter_list|(
name|ehci_qtd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_dump_sqh
parameter_list|(
name|ehci_soft_qh_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_function_decl
specifier|static
name|void
name|ehci_dump_exfer
parameter_list|(
name|struct
name|ehci_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EHCI_NULL
value|htole32(EHCI_LINK_TERMINATE)
end_define

begin_define
define|#
directive|define
name|EHCI_INTR_ENDPT
value|1
end_define

begin_define
define|#
directive|define
name|ehci_add_intr_list
parameter_list|(
name|sc
parameter_list|,
name|ex
parameter_list|)
define|\
value|LIST_INSERT_HEAD(&(sc)->sc_intrhead, (ex), inext);
end_define

begin_define
define|#
directive|define
name|ehci_del_intr_list
parameter_list|(
name|ex
parameter_list|)
define|\
value|do { \ 		LIST_REMOVE((ex), inext); \ 		(ex)->inext.le_prev = NULL; \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|ehci_active_intr_list
parameter_list|(
name|ex
parameter_list|)
value|((ex)->inext.le_prev != NULL)
end_define

begin_decl_stmt
specifier|static
name|struct
name|usbd_bus_methods
name|ehci_bus_methods
init|=
block|{
name|ehci_open
block|,
name|ehci_softintr
block|,
name|ehci_poll
block|,
name|ehci_allocm
block|,
name|ehci_freem
block|,
name|ehci_allocx
block|,
name|ehci_freex
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|usbd_pipe_methods
name|ehci_root_ctrl_methods
init|=
block|{
name|ehci_root_ctrl_transfer
block|,
name|ehci_root_ctrl_start
block|,
name|ehci_root_ctrl_abort
block|,
name|ehci_root_ctrl_close
block|,
name|ehci_noop
block|,
name|ehci_root_ctrl_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|usbd_pipe_methods
name|ehci_root_intr_methods
init|=
block|{
name|ehci_root_intr_transfer
block|,
name|ehci_root_intr_start
block|,
name|ehci_root_intr_abort
block|,
name|ehci_root_intr_close
block|,
name|ehci_noop
block|,
name|ehci_root_intr_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|usbd_pipe_methods
name|ehci_device_ctrl_methods
init|=
block|{
name|ehci_device_ctrl_transfer
block|,
name|ehci_device_ctrl_start
block|,
name|ehci_device_ctrl_abort
block|,
name|ehci_device_ctrl_close
block|,
name|ehci_noop
block|,
name|ehci_device_ctrl_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|usbd_pipe_methods
name|ehci_device_intr_methods
init|=
block|{
name|ehci_device_intr_transfer
block|,
name|ehci_device_intr_start
block|,
name|ehci_device_intr_abort
block|,
name|ehci_device_intr_close
block|,
name|ehci_device_clear_toggle
block|,
name|ehci_device_intr_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|usbd_pipe_methods
name|ehci_device_bulk_methods
init|=
block|{
name|ehci_device_bulk_transfer
block|,
name|ehci_device_bulk_start
block|,
name|ehci_device_bulk_abort
block|,
name|ehci_device_bulk_close
block|,
name|ehci_device_clear_toggle
block|,
name|ehci_device_bulk_done
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|usbd_pipe_methods
name|ehci_device_isoc_methods
init|=
block|{
name|ehci_device_isoc_transfer
block|,
name|ehci_device_isoc_start
block|,
name|ehci_device_isoc_abort
block|,
name|ehci_device_isoc_close
block|,
name|ehci_noop
block|,
name|ehci_device_isoc_done
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|usbd_status
name|ehci_init
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|version
decl_stmt|,
name|sparams
decl_stmt|,
name|cparams
decl_stmt|,
name|hcr
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|ehci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|u_int
name|ncomp
decl_stmt|;
name|int
name|lev
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_init: start\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
name|theehci
operator|=
name|sc
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_offs
operator|=
name|EREAD1
argument_list|(
name|sc
argument_list|,
name|EHCI_CAPLENGTH
argument_list|)
expr_stmt|;
name|version
operator|=
name|EREAD2
argument_list|(
name|sc
argument_list|,
name|EHCI_HCIVERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: EHCI version %x.%x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|,
name|version
operator|>>
literal|8
argument_list|,
name|version
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sparams
operator|=
name|EREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_HCSPARAMS
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_init: sparams=0x%x\n"
operator|,
name|sparams
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_npcomp
operator|=
name|EHCI_HCS_N_PCC
argument_list|(
name|sparams
argument_list|)
expr_stmt|;
name|ncomp
operator|=
name|EHCI_HCS_N_CC
argument_list|(
name|sparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncomp
operator|!=
name|sc
operator|->
name|sc_ncomp
condition|)
block|{
name|printf
argument_list|(
literal|"%s: wrong number of companions (%d != %d)\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|,
name|ncomp
argument_list|,
name|sc
operator|->
name|sc_ncomp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncomp
operator|<
name|sc
operator|->
name|sc_ncomp
condition|)
name|sc
operator|->
name|sc_ncomp
operator|=
name|ncomp
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ncomp
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: companion controller%s, %d port%s each:"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_ncomp
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|EHCI_HCS_N_PCC
argument_list|(
name|sparams
argument_list|)
argument_list|,
name|EHCI_HCS_N_PCC
argument_list|(
name|sparams
argument_list|)
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_ncomp
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_comps
index|[
name|i
index|]
operator|->
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_noport
operator|=
name|EHCI_HCS_N_PORTS
argument_list|(
name|sparams
argument_list|)
expr_stmt|;
name|cparams
operator|=
name|EREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_HCCPARAMS
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_init: cparams=0x%x\n"
operator|,
name|cparams
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EHCI_HCC_64BIT
argument_list|(
name|cparams
argument_list|)
condition|)
block|{
comment|/* MUST clear segment register if 64 bit capable. */
name|EWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_CTRLDSSEGMENT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_bus
operator|.
name|usbrev
operator|=
name|USBREV_2_0
expr_stmt|;
comment|/* Reset the controller */
name|DPRINTF
argument_list|(
operator|(
literal|"%s: resetting\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Halt controller */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|EHCI_CMD_HCRESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hcr
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
operator|&
name|EHCI_CMD_HCRESET
expr_stmt|;
if|if
condition|(
operator|!
name|hcr
condition|)
break|break;
block|}
if|if
condition|(
name|hcr
condition|)
block|{
name|printf
argument_list|(
literal|"%s: reset timeout\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
block|}
comment|/* frame list size at default, read back what we got and use that */
switch|switch
condition|(
name|EHCI_CMD_FLS
argument_list|(
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|sc
operator|->
name|sc_flsize
operator|=
literal|1024
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sc
operator|->
name|sc_flsize
operator|=
literal|512
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sc
operator|->
name|sc_flsize
operator|=
literal|256
expr_stmt|;
break|break;
case|case
literal|3
case|:
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
block|}
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|sc
operator|->
name|sc_flsize
operator|*
sizeof|sizeof
argument_list|(
name|ehci_link_t
argument_list|)
argument_list|,
name|EHCI_FLALIGN_ALIGN
argument_list|,
operator|&
name|sc
operator|->
name|sc_fldma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: flsize=%d\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|,
name|sc
operator|->
name|sc_flsize
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flist
operator|=
name|KERNADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_fldma
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_PERIODICLISTBASE
argument_list|,
name|DMAADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_fldma
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the bus struct. */
name|sc
operator|->
name|sc_bus
operator|.
name|methods
operator|=
operator|&
name|ehci_bus_methods
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|pipe_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ehci_pipe
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|sc
operator|->
name|sc_powerhook
operator|=
name|powerhook_establish
argument_list|(
name|ehci_power
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_shutdownhook
operator|=
name|shutdownhook_establish
argument_list|(
name|ehci_shutdown
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_eintrs
operator|=
name|EHCI_NORMAL_INTRS
expr_stmt|;
comment|/* 	 * Allocate the interrupt dummy QHs. These are arranged to give 	 * poll intervals that are powers of 2 times 1ms. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EHCI_INTRQHS
condition|;
name|i
operator|++
control|)
block|{
name|sqh
operator|=
name|ehci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqh
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
name|sc
operator|->
name|sc_islots
index|[
name|i
index|]
operator|.
name|sqh
operator|=
name|sqh
expr_stmt|;
block|}
name|lev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EHCI_INTRQHS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|EHCI_IQHIDX
argument_list|(
name|lev
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|lev
operator|++
expr_stmt|;
name|sqh
operator|=
name|sc
operator|->
name|sc_islots
index|[
name|i
index|]
operator|.
name|sqh
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* The last (1ms) QH terminates. */
name|sqh
operator|->
name|qh
operator|.
name|qh_link
operator|=
name|EHCI_NULL
expr_stmt|;
name|sqh
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise the next QH has half the poll interval */
name|sqh
operator|->
name|next
operator|=
name|sc
operator|->
name|sc_islots
index|[
name|EHCI_IQHIDX
argument_list|(
name|lev
operator|-
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
index|]
operator|.
name|sqh
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_link
operator|=
name|htole32
argument_list|(
name|sqh
operator|->
name|next
operator|->
name|physaddr
operator||
name|EHCI_LINK_QH
argument_list|)
expr_stmt|;
block|}
name|sqh
operator|->
name|qh
operator|.
name|qh_endp
operator|=
name|htole32
argument_list|(
name|EHCI_QH_SET_EPS
argument_list|(
name|EHCI_QH_SPEED_HIGH
argument_list|)
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_endphub
operator|=
name|htole32
argument_list|(
name|EHCI_QH_SET_MULT
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_curqtd
operator|=
name|EHCI_NULL
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_next
operator|=
name|EHCI_NULL
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_altnext
operator|=
name|EHCI_NULL
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_status
operator|=
name|htole32
argument_list|(
name|EHCI_QTD_HALTED
argument_list|)
expr_stmt|;
block|}
comment|/* Point the frame list at the last level (128ms). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_flsize
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_flist
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|EHCI_LINK_QH
operator||
name|sc
operator|->
name|sc_islots
index|[
name|EHCI_IQHIDX
argument_list|(
name|EHCI_IPOLLRATES
operator|-
literal|1
argument_list|,
name|i
argument_list|)
index|]
operator|.
name|sqh
operator|->
name|physaddr
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate dummy QH that starts the async list. */
name|sqh
operator|=
name|ehci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqh
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
comment|/* Fill the QH */
name|sqh
operator|->
name|qh
operator|.
name|qh_endp
operator|=
name|htole32
argument_list|(
name|EHCI_QH_SET_EPS
argument_list|(
name|EHCI_QH_SPEED_HIGH
argument_list|)
operator||
name|EHCI_QH_HRECL
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_link
operator|=
name|htole32
argument_list|(
name|sqh
operator|->
name|physaddr
operator||
name|EHCI_LINK_QH
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_curqtd
operator|=
name|EHCI_NULL
expr_stmt|;
name|sqh
operator|->
name|prev
operator|=
name|sqh
expr_stmt|;
comment|/*It's a circular list.. */
name|sqh
operator|->
name|next
operator|=
name|sqh
expr_stmt|;
comment|/* Fill the overlay qTD */
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_next
operator|=
name|EHCI_NULL
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_altnext
operator|=
name|EHCI_NULL
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_status
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
if|if
condition|(
name|ehcidebug
condition|)
block|{
name|ehci_dump_sqh
argument_list|(
name|sqh
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Point to async list */
name|sc
operator|->
name|sc_async_head
operator|=
name|sqh
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_ASYNCLISTADDR
argument_list|,
name|sqh
operator|->
name|physaddr
operator||
name|EHCI_LINK_QH
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_pcd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_intrlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lockinit
argument_list|(
operator|&
name|sc
operator|->
name|sc_doorbell_lock
argument_list|,
name|PZERO
argument_list|,
literal|"ehcidb"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable interrupts */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBINTR
argument_list|,
name|sc
operator|->
name|sc_eintrs
argument_list|)
expr_stmt|;
comment|/* Turn on controller */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|EHCI_CMD_ITC_2
operator||
comment|/* 2 microframes interrupt delay */
operator|(
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
operator|&
name|EHCI_CMD_FLS_M
operator|)
operator||
name|EHCI_CMD_ASE
operator||
name|EHCI_CMD_PSE
operator||
name|EHCI_CMD_RS
argument_list|)
expr_stmt|;
comment|/* Take over port ownership */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_CONFIGFLAG
argument_list|,
name|EHCI_CONF_CF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hcr
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
operator|&
name|EHCI_STS_HCH
expr_stmt|;
if|if
condition|(
operator|!
name|hcr
condition|)
break|break;
block|}
if|if
condition|(
name|hcr
condition|)
block|{
name|printf
argument_list|(
literal|"%s: run timeout\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
if|#
directive|if
literal|0
block|bad2: 	ehci_free_sqh(sc, sc->sc_async_head);
endif|#
directive|endif
name|bad1
label|:
name|usb_freemem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_fldma
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ehci_intr
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|v
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If we get an interrupt while polling, then just ignore it. */
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|u_int32_t
name|intrs
init|=
name|EHCI_STS_INTRS
argument_list|(
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|intrs
condition|)
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|,
name|intrs
argument_list|)
expr_stmt|;
comment|/* Acknowledge */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|DPRINTFN
argument_list|(
literal|16
argument_list|,
operator|(
literal|"ehci_intr: ignored interrupt while polling\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ehci_intr1
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ehci_intr1
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|intrs
decl_stmt|,
name|eintrs
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ehci_intr1: enter\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* In case the interrupt occurs before initialization has completed. */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"ehci_intr1: sc == NULL\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|intrs
operator|=
name|EHCI_STS_INTRS
argument_list|(
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intrs
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|eintrs
operator|=
name|intrs
operator|&
name|sc
operator|->
name|sc_eintrs
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|7
argument_list|,
operator|(
literal|"ehci_intr1: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n"
operator|,
name|sc
operator|,
operator|(
name|u_int
operator|)
name|intrs
operator|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
operator|,
operator|(
name|u_int
operator|)
name|eintrs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eintrs
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|,
name|intrs
argument_list|)
expr_stmt|;
comment|/* Acknowledge */
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|no_intrs
operator|++
expr_stmt|;
if|if
condition|(
name|eintrs
operator|&
name|EHCI_STS_IAA
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_intr1: door bell\n"
operator|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_async_head
argument_list|)
expr_stmt|;
name|eintrs
operator|&=
operator|~
name|EHCI_STS_IAA
expr_stmt|;
block|}
if|if
condition|(
name|eintrs
operator|&
operator|(
name|EHCI_STS_INT
operator||
name|EHCI_STS_ERRINT
operator|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ehci_intr1: %s %s\n"
operator|,
name|eintrs
operator|&
name|EHCI_STS_INT
condition|?
literal|"INT"
else|:
literal|""
operator|,
name|eintrs
operator|&
name|EHCI_STS_ERRINT
condition|?
literal|"ERRINT"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|usb_schedsoftintr
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|eintrs
operator|&=
operator|~
operator|(
name|EHCI_STS_INT
operator||
name|EHCI_STS_ERRINT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|eintrs
operator|&
name|EHCI_STS_HSE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unrecoverable error, controller halted\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX what else */
block|}
if|if
condition|(
name|eintrs
operator|&
name|EHCI_STS_PCD
condition|)
block|{
name|ehci_pcd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_intrxfer
argument_list|)
expr_stmt|;
comment|/* 		 * Disable PCD interrupt for now, because it will be 		 * on until the port has been reset. 		 */
name|ehci_pcd_able
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do not allow RHSC interrupts> 1 per second */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_pcd
argument_list|,
name|hz
argument_list|,
name|ehci_pcd_enable
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|eintrs
operator|&=
operator|~
name|EHCI_STS_PCD
expr_stmt|;
block|}
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|--
expr_stmt|;
if|if
condition|(
name|eintrs
operator|!=
literal|0
condition|)
block|{
comment|/* Block unprocessed interrupts. */
name|sc
operator|->
name|sc_eintrs
operator|&=
operator|~
name|eintrs
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBINTR
argument_list|,
name|sc
operator|->
name|sc_eintrs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: blocking intrs 0x%x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|,
name|eintrs
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ehci_pcd_able
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ehci_pcd_able: on=%d\n"
operator|,
name|on
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|sc
operator|->
name|sc_eintrs
operator||=
name|EHCI_STS_PCD
expr_stmt|;
else|else
name|sc
operator|->
name|sc_eintrs
operator|&=
operator|~
name|EHCI_STS_PCD
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBINTR
argument_list|,
name|sc
operator|->
name|sc_eintrs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ehci_pcd_enable
parameter_list|(
name|void
modifier|*
name|v_sc
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|v_sc
decl_stmt|;
name|ehci_pcd_able
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ehci_pcd
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_pipe_handle
name|pipe
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|m
decl_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
comment|/* Just ignore the change. */
return|return;
block|}
name|pipe
operator|=
name|xfer
operator|->
name|pipe
expr_stmt|;
name|p
operator|=
name|xfer
operator|->
name|buffer
expr_stmt|;
name|m
operator|=
name|min
argument_list|(
name|sc
operator|->
name|sc_noport
argument_list|,
name|xfer
operator|->
name|length
operator|*
literal|8
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|xfer
operator|->
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|m
condition|;
name|i
operator|++
control|)
block|{
comment|/* Pick out CHANGE bits from the status reg. */
if|if
condition|(
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&
name|EHCI_PS_CLEAR
condition|)
name|p
index|[
name|i
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_pcd: change=0x%02x\n"
operator|,
operator|*
name|p
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|actlen
operator|=
name|xfer
operator|->
name|length
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ehci_softintr
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|struct
name|ehci_xfer
modifier|*
name|ex
decl_stmt|,
modifier|*
name|nextex
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"%s: ehci_softintr (%d)\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
operator|,
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|++
expr_stmt|;
comment|/* 	 * The only explanation I can think of for why EHCI is as brain dead 	 * as UHCI interrupt-wise is that Intel was involved in both. 	 * An interrupt just tells us that something is done, we have no 	 * clue what, so we need to scan through all active transfers. :-( 	 */
for|for
control|(
name|ex
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|)
init|;
name|ex
condition|;
name|ex
operator|=
name|nextex
control|)
block|{
name|nextex
operator|=
name|LIST_NEXT
argument_list|(
name|ex
argument_list|,
name|inext
argument_list|)
expr_stmt|;
name|ehci_check_intr
argument_list|(
name|sc
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
comment|/* Schedule a callout to catch any dropped transactions. */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|EHCI_SCFLG_LOSTINTRBUG
operator|)
operator|&&
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_intrhead
argument_list|)
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_intrlist
argument_list|,
name|hz
operator|/
literal|5
argument_list|,
name|ehci_intrlist_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_USE_SOFTINTR
if|if
condition|(
name|sc
operator|->
name|sc_softwake
condition|)
block|{
name|sc
operator|->
name|sc_softwake
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_softwake
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USB_USE_SOFTINTR */
name|sc
operator|->
name|sc_bus
operator|.
name|intr_context
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check for an interrupt. */
end_comment

begin_function
name|void
name|ehci_check_intr
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ehci_xfer
modifier|*
name|ex
parameter_list|)
block|{
name|ehci_soft_qtd_t
modifier|*
name|sqtd
decl_stmt|,
modifier|*
name|lsqtd
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|DPRINTFN
argument_list|(
comment|/*15*/
literal|2
argument_list|,
operator|(
literal|"ehci_check_intr: ex=%p\n"
operator|,
name|ex
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|->
name|sqtdstart
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ehci_check_intr: sqtdstart=NULL\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lsqtd
operator|=
name|ex
operator|->
name|sqtdend
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|lsqtd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ehci_check_intr: lsqtd==0\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * If the last TD is still active we need to check whether there 	 * is a an error somewhere in the middle, or whether there was a 	 * short packet (SPD and not ACTIVE). 	 */
if|if
condition|(
name|le32toh
argument_list|(
name|lsqtd
operator|->
name|qtd
operator|.
name|qtd_status
argument_list|)
operator|&
name|EHCI_QTD_ACTIVE
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|12
argument_list|,
operator|(
literal|"ehci_check_intr: active ex=%p\n"
operator|,
name|ex
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|sqtd
operator|=
name|ex
operator|->
name|sqtdstart
init|;
name|sqtd
operator|!=
name|lsqtd
condition|;
name|sqtd
operator|=
name|sqtd
operator|->
name|nextqtd
control|)
block|{
name|status
operator|=
name|le32toh
argument_list|(
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_status
argument_list|)
expr_stmt|;
comment|/* If there's an active QTD the xfer isn't done. */
if|if
condition|(
name|status
operator|&
name|EHCI_QTD_ACTIVE
condition|)
break|break;
comment|/* Any kind of error makes the xfer done. */
if|if
condition|(
name|status
operator|&
name|EHCI_QTD_HALTED
condition|)
goto|goto
name|done
goto|;
comment|/* We want short packets, and it is short: it's done */
if|if
condition|(
name|EHCI_QTD_GET_BYTES
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
name|DPRINTFN
argument_list|(
literal|12
argument_list|,
operator|(
literal|"ehci_check_intr: ex=%p std=%p still active\n"
operator|,
name|ex
operator|,
name|ex
operator|->
name|sqtdstart
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|done
label|:
name|DPRINTFN
argument_list|(
literal|12
argument_list|,
operator|(
literal|"ehci_check_intr: ex=%p done\n"
operator|,
name|ex
operator|)
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|ex
operator|->
name|xfer
operator|.
name|timeout_handle
argument_list|)
expr_stmt|;
name|usb_rem_task
argument_list|(
name|ex
operator|->
name|xfer
operator|.
name|pipe
operator|->
name|device
argument_list|,
operator|&
name|ex
operator|->
name|abort_task
argument_list|)
expr_stmt|;
name|ehci_idone
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ehci_idone
parameter_list|(
name|struct
name|ehci_xfer
modifier|*
name|ex
parameter_list|)
block|{
name|usbd_xfer_handle
name|xfer
init|=
operator|&
name|ex
operator|->
name|xfer
decl_stmt|;
name|struct
name|ehci_pipe
modifier|*
name|epipe
init|=
operator|(
expr|struct
name|ehci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|ehci_soft_qtd_t
modifier|*
name|sqtd
decl_stmt|,
modifier|*
name|lsqtd
decl_stmt|;
name|u_int32_t
name|status
init|=
literal|0
decl_stmt|,
name|nstatus
init|=
literal|0
decl_stmt|;
name|ehci_physaddr_t
name|nextphys
decl_stmt|,
name|altnextphys
decl_stmt|;
name|int
name|actlen
decl_stmt|,
name|cerr
decl_stmt|;
name|DPRINTFN
argument_list|(
comment|/*12*/
literal|2
argument_list|,
operator|(
literal|"ehci_idone: ex=%p\n"
operator|,
name|ex
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
if|if
condition|(
name|ex
operator|->
name|isdone
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
name|printf
argument_list|(
literal|"ehci_idone: ex is done!\n   "
argument_list|)
expr_stmt|;
name|ehci_dump_exfer
argument_list|(
name|ex
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"ehci_idone: ex=%p is done!\n"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|ex
operator|->
name|isdone
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|xfer
operator|->
name|status
operator|==
name|USBD_CANCELLED
operator|||
name|xfer
operator|->
name|status
operator|==
name|USBD_TIMEOUT
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_idone: aborted xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|EHCI_DEBUG
name|DPRINTFN
argument_list|(
comment|/*10*/
literal|2
argument_list|,
operator|(
literal|"ehci_idone: xfer=%p, pipe=%p ready\n"
operator|,
name|xfer
operator|,
name|epipe
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ehcidebug
operator|>
literal|10
condition|)
name|ehci_dump_sqtds
argument_list|(
name|ex
operator|->
name|sqtdstart
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Make sure that the QH overlay qTD does not reference any 	 * of the qTDs we are about to free. This is probably only 	 * necessary if the transfer is marked as HALTED. 	 */
name|nextphys
operator|=
name|EHCI_LINK_ADDR
argument_list|(
name|le32toh
argument_list|(
name|epipe
operator|->
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_next
argument_list|)
argument_list|)
expr_stmt|;
name|altnextphys
operator|=
name|EHCI_LINK_ADDR
argument_list|(
name|le32toh
argument_list|(
name|epipe
operator|->
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_altnext
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|sqtd
operator|=
name|ex
operator|->
name|sqtdstart
init|;
name|sqtd
operator|!=
name|ex
operator|->
name|sqtdend
operator|->
name|nextqtd
condition|;
name|sqtd
operator|=
name|sqtd
operator|->
name|nextqtd
control|)
block|{
if|if
condition|(
name|sqtd
operator|->
name|physaddr
operator|==
name|nextphys
condition|)
block|{
name|epipe
operator|->
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_next
operator|=
name|htole32
argument_list|(
name|ex
operator|->
name|sqtdend
operator|->
name|nextqtd
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ehci_idone: updated overlay next ptr\n"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sqtd
operator|->
name|physaddr
operator|==
name|altnextphys
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ehci_idone: updated overlay altnext ptr\n"
operator|)
argument_list|)
expr_stmt|;
name|epipe
operator|->
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_altnext
operator|=
name|htole32
argument_list|(
name|ex
operator|->
name|sqtdend
operator|->
name|nextqtd
operator|->
name|physaddr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The transfer is done, compute actual length and status. */
name|lsqtd
operator|=
name|ex
operator|->
name|sqtdend
expr_stmt|;
name|actlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sqtd
operator|=
name|ex
operator|->
name|sqtdstart
init|;
name|sqtd
operator|!=
name|lsqtd
operator|->
name|nextqtd
condition|;
name|sqtd
operator|=
name|sqtd
operator|->
name|nextqtd
control|)
block|{
name|nstatus
operator|=
name|le32toh
argument_list|(
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstatus
operator|&
name|EHCI_QTD_ACTIVE
condition|)
break|break;
name|status
operator|=
name|nstatus
expr_stmt|;
comment|/* halt is ok if descriptor is last, and complete */
if|if
condition|(
name|sqtd
operator|==
name|lsqtd
operator|&&
name|EHCI_QTD_GET_BYTES
argument_list|(
name|status
argument_list|)
operator|==
literal|0
condition|)
name|status
operator|&=
operator|~
name|EHCI_QTD_HALTED
expr_stmt|;
if|if
condition|(
name|EHCI_QTD_GET_PID
argument_list|(
name|status
argument_list|)
operator|!=
name|EHCI_QTD_PID_SETUP
condition|)
name|actlen
operator|+=
name|sqtd
operator|->
name|len
operator|-
name|EHCI_QTD_GET_BYTES
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
name|cerr
operator|=
name|EHCI_QTD_GET_CERR
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
comment|/*10*/
literal|2
argument_list|,
operator|(
literal|"ehci_idone: len=%d, actlen=%d, cerr=%d, "
literal|"status=0x%x\n"
operator|,
name|xfer
operator|->
name|length
operator|,
name|actlen
operator|,
name|cerr
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|actlen
operator|=
name|actlen
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|EHCI_QTD_HALTED
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EHCI_DEBUG
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
name|bitmask_snprintf
argument_list|(
operator|(
name|u_int32_t
operator|)
name|status
argument_list|,
literal|"\20\7HALTED\6BUFERR\5BABBLE\4XACTERR"
literal|"\3MISSED\2SPLIT\1PING"
argument_list|,
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_idone: error, addr=%d, endpt=0x%02x, "
literal|"status 0x%s\n"
operator|,
name|xfer
operator|->
name|pipe
operator|->
name|device
operator|->
name|address
operator|,
name|xfer
operator|->
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|,
name|sbuf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ehcidebug
operator|>
literal|2
condition|)
block|{
name|ehci_dump_sqh
argument_list|(
name|epipe
operator|->
name|sqh
argument_list|)
expr_stmt|;
name|ehci_dump_sqtds
argument_list|(
name|ex
operator|->
name|sqtdstart
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|status
operator|&
name|EHCI_QTD_BABBLE
operator|)
operator|==
literal|0
operator|&&
name|cerr
operator|>
literal|0
condition|)
name|xfer
operator|->
name|status
operator|=
name|USBD_STALLED
expr_stmt|;
else|else
name|xfer
operator|->
name|status
operator|=
name|USBD_IOERROR
expr_stmt|;
comment|/* more info XXX */
block|}
else|else
block|{
name|xfer
operator|->
name|status
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
block|}
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
comment|/*12*/
literal|2
argument_list|,
operator|(
literal|"ehci_idone: ex=%p done\n"
operator|,
name|ex
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait here until controller claims to have an interrupt.  * Then call ehci_intr and return.  Use timeout to avoid waiting  * too long.  */
end_comment

begin_function
name|void
name|ehci_waitintr
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|int
name|timo
init|=
name|xfer
operator|->
name|timeout
decl_stmt|;
name|int
name|usecs
decl_stmt|;
name|u_int32_t
name|intrs
decl_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
for|for
control|(
name|usecs
operator|=
name|timo
operator|*
literal|1000000
operator|/
name|hz
init|;
name|usecs
operator|>
literal|0
condition|;
name|usecs
operator|-=
literal|1000
control|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
break|break;
name|intrs
operator|=
name|EHCI_STS_INTRS
argument_list|(
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
argument_list|)
operator|&
name|sc
operator|->
name|sc_eintrs
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"ehci_waitintr: 0x%04x\n"
operator|,
name|intrs
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|15
condition|)
name|ehci_dump_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|intrs
condition|)
block|{
name|ehci_intr1
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|status
operator|!=
name|USBD_IN_PROGRESS
condition|)
return|return;
block|}
block|}
comment|/* Timeout */
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_waitintr: timeout\n"
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_TIMEOUT
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* XXX should free TD */
block|}
end_function

begin_function
name|void
name|ehci_poll
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|bus
decl_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
specifier|static
name|int
name|last
decl_stmt|;
name|int
name|new
decl_stmt|;
name|new
operator|=
name|EHCI_STS_INTRS
argument_list|(
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|last
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ehci_poll: intrs=0x%04x\n"
operator|,
name|new
operator|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|new
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
operator|&
name|sc
operator|->
name|sc_eintrs
condition|)
name|ehci_intr1
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ehci_detach
parameter_list|(
name|struct
name|ehci_softc
modifier|*
name|sc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBINTR
argument_list|,
name|sc
operator|->
name|sc_eintrs
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|EHCI_CMD_HCRESET
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_intrlist
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_pcd
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_powerhook
operator|!=
name|NULL
condition|)
name|powerhook_disestablish
argument_list|(
name|sc
operator|->
name|sc_powerhook
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_shutdownhook
operator|!=
name|NULL
condition|)
name|shutdownhook_disestablish
argument_list|(
name|sc
operator|->
name|sc_shutdownhook
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|300
argument_list|)
expr_stmt|;
comment|/* XXX let stray task complete */
name|usb_freemem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_fldma
argument_list|)
expr_stmt|;
comment|/* XXX free other data structures XXX */
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle suspend/resume.  *  * We need to switch to polling mode here, because this routine is  * called from an interrupt context.  This is all right since we  * are almost suspended anyway.  */
end_comment

begin_function
name|void
name|ehci_power
parameter_list|(
name|int
name|why
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|,
name|hcr
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_power: sc=%p, why=%d\n"
operator|,
name|sc
operator|,
name|why
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ehcidebug
operator|>
literal|0
condition|)
name|ehci_dump_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splhardusb
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|PWR_SUSPEND
case|:
case|case
name|PWR_STANDBY
case|:
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|sc
operator|->
name|sc_noport
condition|;
name|i
operator|++
control|)
block|{
name|cmd
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
name|EHCI_PS_PO
operator|)
operator|==
literal|0
operator|&&
operator|(
name|cmd
operator|&
name|EHCI_PS_PE
operator|)
operator|==
name|EHCI_PS_PE
condition|)
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|,
name|cmd
operator||
name|EHCI_PS_SUSP
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_cmd
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|sc
operator|->
name|sc_cmd
operator|&
operator|~
operator|(
name|EHCI_CMD_ASE
operator||
name|EHCI_CMD_PSE
operator|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|hcr
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
operator|&
operator|(
name|EHCI_STS_ASS
operator||
name|EHCI_STS_PSS
operator|)
expr_stmt|;
if|if
condition|(
name|hcr
operator|==
literal|0
condition|)
break|break;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hcr
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: reset timeout\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|&=
operator|~
name|EHCI_CMD_RS
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|hcr
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
operator|&
name|EHCI_STS_HCH
expr_stmt|;
if|if
condition|(
name|hcr
operator|==
name|EHCI_STS_HCH
condition|)
break|break;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hcr
operator|!=
name|EHCI_STS_HCH
condition|)
block|{
name|printf
argument_list|(
literal|"%s: config timeout\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
operator|--
expr_stmt|;
break|break;
case|case
name|PWR_RESUME
case|:
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
operator|++
expr_stmt|;
comment|/* restore things in case the bios sucks */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_CTRLDSSEGMENT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_PERIODICLISTBASE
argument_list|,
name|DMAADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_fldma
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_ASYNCLISTADDR
argument_list|,
name|sc
operator|->
name|sc_async_head
operator|->
name|physaddr
operator||
name|EHCI_LINK_QH
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBINTR
argument_list|,
name|sc
operator|->
name|sc_eintrs
argument_list|)
expr_stmt|;
name|hcr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|sc
operator|->
name|sc_noport
condition|;
name|i
operator|++
control|)
block|{
name|cmd
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
name|EHCI_PS_PO
operator|)
operator|==
literal|0
operator|&&
operator|(
name|cmd
operator|&
name|EHCI_PS_SUSP
operator|)
operator|==
name|EHCI_PS_SUSP
condition|)
block|{
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|,
name|cmd
operator||
name|EHCI_PS_FPR
argument_list|)
expr_stmt|;
name|hcr
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hcr
condition|)
block|{
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_RESUME_WAIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|sc
operator|->
name|sc_noport
condition|;
name|i
operator|++
control|)
block|{
name|cmd
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
name|EHCI_PS_PO
operator|)
operator|==
literal|0
operator|&&
operator|(
name|cmd
operator|&
name|EHCI_PS_SUSP
operator|)
operator|==
name|EHCI_PS_SUSP
condition|)
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|,
name|cmd
operator|&
operator|~
name|EHCI_PS_FPR
argument_list|)
expr_stmt|;
block|}
block|}
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|sc
operator|->
name|sc_cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|hcr
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
operator|&
name|EHCI_STS_HCH
expr_stmt|;
if|if
condition|(
name|hcr
operator|!=
name|EHCI_STS_HCH
condition|)
break|break;
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hcr
operator|==
name|EHCI_STS_HCH
condition|)
block|{
name|printf
argument_list|(
literal|"%s: config timeout\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_RESUME_WAIT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
operator|--
expr_stmt|;
break|break;
case|case
name|PWR_SOFTSUSPEND
case|:
case|case
name|PWR_SOFTSTANDBY
case|:
case|case
name|PWR_SOFTRESUME
case|:
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_power: sc=%p\n"
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ehcidebug
operator|>
literal|0
condition|)
name|ehci_dump_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Shut down the controller when the system is going down.  */
end_comment

begin_function
name|void
name|ehci_shutdown
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_shutdown: stopping the HC\n"
operator|)
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Halt controller */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|EHCI_CMD_HCRESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|ehci_allocm
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|,
name|usb_dma_t
modifier|*
name|dma
parameter_list|,
name|u_int32_t
name|size
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
name|bus
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|dma
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
if|if
condition|(
name|err
condition|)
name|printf
argument_list|(
literal|"ehci_allocm: usb_allocmem()=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ehci_freem
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|,
name|usb_dma_t
modifier|*
name|dma
parameter_list|)
block|{
name|usb_freemem
argument_list|(
name|bus
argument_list|,
name|dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_xfer_handle
name|ehci_allocx
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|ehci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ehci_softc
operator|*
operator|)
name|bus
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|,
name|next
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|busy_free
operator|!=
name|XFER_FREE
condition|)
block|{
name|printf
argument_list|(
literal|"ehci_allocx: xfer=%p not free, 0x%08x\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|busy_free
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|xfer
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ehci_xfer
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xfer
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ehci_xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usb_init_task
argument_list|(
operator|&
name|EXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|abort_task
argument_list|,
name|ehci_timeout_task
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|EXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|ehci_xfer_flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|EXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|isdone
operator|=
literal|1
expr_stmt|;
name|xfer
operator|->
name|busy_free
operator|=
name|XFER_BUSY
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|xfer
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ehci_freex
parameter_list|(
name|struct
name|usbd_bus
modifier|*
name|bus
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ehci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ehci_softc
operator|*
operator|)
name|bus
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|busy_free
operator|!=
name|XFER_BUSY
condition|)
block|{
name|printf
argument_list|(
literal|"ehci_freex: xfer=%p not busy, 0x%08x\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|busy_free
argument_list|)
expr_stmt|;
return|return;
block|}
name|xfer
operator|->
name|busy_free
operator|=
name|XFER_FREE
expr_stmt|;
if|if
condition|(
operator|!
name|EXFER
argument_list|(
name|xfer
argument_list|)
operator|->
name|isdone
condition|)
block|{
name|printf
argument_list|(
literal|"ehci_freex: !isdone\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_xfers
argument_list|,
name|xfer
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_clear_toggle
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|struct
name|ehci_pipe
modifier|*
name|epipe
init|=
operator|(
expr|struct
name|ehci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_device_clear_toggle: epipe=%p status=0x%x\n"
operator|,
name|epipe
operator|,
name|epipe
operator|->
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_status
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ehcidebug
condition|)
name|usbd_dump_pipe
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
operator|(
name|epipe
operator|->
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_status
operator|&
name|htole32
argument_list|(
name|EHCI_QTD_ACTIVE
argument_list|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"ehci_device_clear_toggle: queue active"
operator|)
argument_list|)
expr_stmt|;
name|epipe
operator|->
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_status
operator|&=
name|htole32
argument_list|(
operator|~
name|EHCI_QTD_TOGGLE_MASK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_noop
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{ }
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EHCI_DEBUG
end_ifdef

begin_function
name|void
name|ehci_dump_regs
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"cmd=0x%08x, sts=0x%08x, ien=0x%08x\n"
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBINTR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"frindex=0x%08x ctrdsegm=0x%08x periodic=0x%08x async=0x%08x\n"
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_FRINDEX
argument_list|)
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_CTRLDSSEGMENT
argument_list|)
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_PERIODICLISTBASE
argument_list|)
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_ASYNCLISTADDR
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|sc
operator|->
name|sc_noport
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"port %d status=0x%08x\n"
argument_list|,
name|i
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unused function - this is meant to be called from a kernel  * debugger.  */
end_comment

begin_function
name|void
name|ehci_dump
parameter_list|()
block|{
name|ehci_dump_regs
argument_list|(
name|theehci
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ehci_dump_link
parameter_list|(
name|ehci_link_t
name|link
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|link
operator|=
name|le32toh
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%08x"
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|&
name|EHCI_LINK_TERMINATE
condition|)
name|printf
argument_list|(
literal|"<T>"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
switch|switch
condition|(
name|EHCI_LINK_TYPE
argument_list|(
name|link
argument_list|)
condition|)
block|{
case|case
name|EHCI_LINK_ITD
case|:
name|printf
argument_list|(
literal|"ITD"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EHCI_LINK_QH
case|:
name|printf
argument_list|(
literal|"QH"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EHCI_LINK_SITD
case|:
name|printf
argument_list|(
literal|"SITD"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EHCI_LINK_FSTN
case|:
name|printf
argument_list|(
literal|"FSTN"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ehci_dump_sqtds
parameter_list|(
name|ehci_soft_qtd_t
modifier|*
name|sqtd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|stop
decl_stmt|;
name|stop
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sqtd
operator|&&
name|i
operator|<
literal|20
operator|&&
operator|!
name|stop
condition|;
name|sqtd
operator|=
name|sqtd
operator|->
name|nextqtd
operator|,
name|i
operator|++
control|)
block|{
name|ehci_dump_sqtd
argument_list|(
name|sqtd
argument_list|)
expr_stmt|;
name|stop
operator|=
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_next
operator|&
name|htole32
argument_list|(
name|EHCI_LINK_TERMINATE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sqtd
condition|)
name|printf
argument_list|(
literal|"dump aborted, too many TDs\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ehci_dump_sqtd
parameter_list|(
name|ehci_soft_qtd_t
modifier|*
name|sqtd
parameter_list|)
block|{
name|printf
argument_list|(
literal|"QTD(%p) at 0x%08x:\n"
argument_list|,
name|sqtd
argument_list|,
name|sqtd
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|ehci_dump_qtd
argument_list|(
operator|&
name|sqtd
operator|->
name|qtd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ehci_dump_qtd
parameter_list|(
name|ehci_qtd_t
modifier|*
name|qtd
parameter_list|)
block|{
name|u_int32_t
name|s
decl_stmt|;
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"  next="
argument_list|)
expr_stmt|;
name|ehci_dump_link
argument_list|(
name|qtd
operator|->
name|qtd_next
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" altnext="
argument_list|)
expr_stmt|;
name|ehci_dump_link
argument_list|(
name|qtd
operator|->
name|qtd_altnext
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|le32toh
argument_list|(
name|qtd
operator|->
name|qtd_status
argument_list|)
expr_stmt|;
name|bitmask_snprintf
argument_list|(
name|EHCI_QTD_GET_STATUS
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"\20\10ACTIVE\7HALTED\6BUFERR\5BABBLE\4XACTERR"
literal|"\3MISSED\2SPLIT\1PING"
argument_list|,
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  status=0x%08x: toggle=%d bytes=0x%x ioc=%d c_page=0x%x\n"
argument_list|,
name|s
argument_list|,
name|EHCI_QTD_GET_TOGGLE
argument_list|(
name|s
argument_list|)
argument_list|,
name|EHCI_QTD_GET_BYTES
argument_list|(
name|s
argument_list|)
argument_list|,
name|EHCI_QTD_GET_IOC
argument_list|(
name|s
argument_list|)
argument_list|,
name|EHCI_QTD_GET_C_PAGE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cerr=%d pid=%d stat=0x%s\n"
argument_list|,
name|EHCI_QTD_GET_CERR
argument_list|(
name|s
argument_list|)
argument_list|,
name|EHCI_QTD_GET_PID
argument_list|(
name|s
argument_list|)
argument_list|,
name|sbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
literal|5
condition|;
name|s
operator|++
control|)
name|printf
argument_list|(
literal|"  buffer[%d]=0x%08x\n"
argument_list|,
name|s
argument_list|,
name|le32toh
argument_list|(
name|qtd
operator|->
name|qtd_buffer
index|[
name|s
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ehci_dump_sqh
parameter_list|(
name|ehci_soft_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|ehci_qh_t
modifier|*
name|qh
init|=
operator|&
name|sqh
operator|->
name|qh
decl_stmt|;
name|u_int32_t
name|endp
decl_stmt|,
name|endphub
decl_stmt|;
name|printf
argument_list|(
literal|"QH(%p) at 0x%08x:\n"
argument_list|,
name|sqh
argument_list|,
name|sqh
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  sqtd=%p inactivesqtd=%p\n"
argument_list|,
name|sqh
operator|->
name|sqtd
argument_list|,
name|sqh
operator|->
name|inactivesqtd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  link="
argument_list|)
expr_stmt|;
name|ehci_dump_link
argument_list|(
name|qh
operator|->
name|qh_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|endp
operator|=
name|le32toh
argument_list|(
name|qh
operator|->
name|qh_endp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  endp=0x%08x\n"
argument_list|,
name|endp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    addr=0x%02x inact=%d endpt=%d eps=%d dtc=%d hrecl=%d\n"
argument_list|,
name|EHCI_QH_GET_ADDR
argument_list|(
name|endp
argument_list|)
argument_list|,
name|EHCI_QH_GET_INACT
argument_list|(
name|endp
argument_list|)
argument_list|,
name|EHCI_QH_GET_ENDPT
argument_list|(
name|endp
argument_list|)
argument_list|,
name|EHCI_QH_GET_EPS
argument_list|(
name|endp
argument_list|)
argument_list|,
name|EHCI_QH_GET_DTC
argument_list|(
name|endp
argument_list|)
argument_list|,
name|EHCI_QH_GET_HRECL
argument_list|(
name|endp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    mpl=0x%x ctl=%d nrl=%d\n"
argument_list|,
name|EHCI_QH_GET_MPL
argument_list|(
name|endp
argument_list|)
argument_list|,
name|EHCI_QH_GET_CTL
argument_list|(
name|endp
argument_list|)
argument_list|,
name|EHCI_QH_GET_NRL
argument_list|(
name|endp
argument_list|)
argument_list|)
expr_stmt|;
name|endphub
operator|=
name|le32toh
argument_list|(
name|qh
operator|->
name|qh_endphub
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  endphub=0x%08x\n"
argument_list|,
name|endphub
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    smask=0x%02x cmask=0x%02x huba=0x%02x port=%d mult=%d\n"
argument_list|,
name|EHCI_QH_GET_SMASK
argument_list|(
name|endphub
argument_list|)
argument_list|,
name|EHCI_QH_GET_CMASK
argument_list|(
name|endphub
argument_list|)
argument_list|,
name|EHCI_QH_GET_HUBA
argument_list|(
name|endphub
argument_list|)
argument_list|,
name|EHCI_QH_GET_PORT
argument_list|(
name|endphub
argument_list|)
argument_list|,
name|EHCI_QH_GET_MULT
argument_list|(
name|endphub
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  curqtd="
argument_list|)
expr_stmt|;
name|ehci_dump_link
argument_list|(
name|qh
operator|->
name|qh_curqtd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Overlay qTD:\n"
argument_list|)
expr_stmt|;
name|ehci_dump_qtd
argument_list|(
operator|&
name|qh
operator|->
name|qh_qtd
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_function
specifier|static
name|void
name|ehci_dump_exfer
parameter_list|(
name|struct
name|ehci_xfer
modifier|*
name|ex
parameter_list|)
block|{
name|printf
argument_list|(
literal|"ehci_dump_exfer: ex=%p\n"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|usbd_status
name|ehci_open
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|usbd_device_handle
name|dev
init|=
name|pipe
operator|->
name|device
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
init|=
name|pipe
operator|->
name|endpoint
operator|->
name|edesc
decl_stmt|;
name|u_int8_t
name|addr
init|=
name|dev
operator|->
name|address
decl_stmt|;
name|u_int8_t
name|xfertype
init|=
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
decl_stmt|;
name|struct
name|ehci_pipe
modifier|*
name|epipe
init|=
operator|(
expr|struct
name|ehci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|ehci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|ival
decl_stmt|,
name|speed
decl_stmt|,
name|naks
decl_stmt|;
name|int
name|hshubaddr
decl_stmt|,
name|hshubport
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ehci_open: pipe=%p, addr=%d, endpt=%d (%d)\n"
operator|,
name|pipe
operator|,
name|addr
operator|,
name|ed
operator|->
name|bEndpointAddress
operator|,
name|sc
operator|->
name|sc_addr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|myhsport
condition|)
block|{
name|hshubaddr
operator|=
name|dev
operator|->
name|myhsport
operator|->
name|parent
operator|->
name|address
expr_stmt|;
name|hshubport
operator|=
name|dev
operator|->
name|myhsport
operator|->
name|portno
expr_stmt|;
block|}
else|else
block|{
name|hshubaddr
operator|=
literal|0
expr_stmt|;
name|hshubport
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
if|if
condition|(
name|addr
operator|==
name|sc
operator|->
name|sc_addr
condition|)
block|{
switch|switch
condition|(
name|ed
operator|->
name|bEndpointAddress
condition|)
block|{
case|case
name|USB_CONTROL_ENDPOINT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ehci_root_ctrl_methods
expr_stmt|;
break|break;
case|case
name|UE_DIR_IN
operator||
name|EHCI_INTR_ENDPT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ehci_root_intr_methods
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
comment|/* XXX All this stuff is only valid for async. */
switch|switch
condition|(
name|dev
operator|->
name|speed
condition|)
block|{
case|case
name|USB_SPEED_LOW
case|:
name|speed
operator|=
name|EHCI_QH_SPEED_LOW
expr_stmt|;
break|break;
case|case
name|USB_SPEED_FULL
case|:
name|speed
operator|=
name|EHCI_QH_SPEED_FULL
expr_stmt|;
break|break;
case|case
name|USB_SPEED_HIGH
case|:
name|speed
operator|=
name|EHCI_QH_SPEED_HIGH
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"ehci_open: bad device speed %d"
argument_list|,
name|dev
operator|->
name|speed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|speed
operator|!=
name|EHCI_QH_SPEED_HIGH
operator|&&
name|xfertype
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: *** WARNING: opening low/full speed device, this "
literal|"does not work yet.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ehci_open: hshubaddr=%d hshubport=%d\n"
operator|,
name|hshubaddr
operator|,
name|hshubport
operator|)
argument_list|)
expr_stmt|;
return|return
name|USBD_INVAL
return|;
block|}
name|naks
operator|=
literal|8
expr_stmt|;
comment|/* XXX */
name|sqh
operator|=
name|ehci_alloc_sqh
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqh
operator|==
name|NULL
condition|)
goto|goto
name|bad0
goto|;
comment|/* qh_link filled when the QH is added */
name|sqh
operator|->
name|qh
operator|.
name|qh_endp
operator|=
name|htole32
argument_list|(
name|EHCI_QH_SET_ADDR
argument_list|(
name|addr
argument_list|)
operator||
name|EHCI_QH_SET_ENDPT
argument_list|(
name|UE_GET_ADDR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
argument_list|)
operator||
name|EHCI_QH_SET_EPS
argument_list|(
name|speed
argument_list|)
operator||
operator|(
name|xfertype
operator|==
name|UE_CONTROL
condition|?
name|EHCI_QH_DTC
else|:
literal|0
operator|)
operator||
name|EHCI_QH_SET_MPL
argument_list|(
name|UGETW
argument_list|(
name|ed
operator|->
name|wMaxPacketSize
argument_list|)
argument_list|)
operator||
operator|(
name|speed
operator|!=
name|EHCI_QH_SPEED_HIGH
operator|&&
name|xfertype
operator|==
name|UE_CONTROL
condition|?
name|EHCI_QH_CTL
else|:
literal|0
operator|)
operator||
name|EHCI_QH_SET_NRL
argument_list|(
name|naks
argument_list|)
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_endphub
operator|=
name|htole32
argument_list|(
name|EHCI_QH_SET_MULT
argument_list|(
literal|1
argument_list|)
operator||
name|EHCI_QH_SET_HUBA
argument_list|(
name|hshubaddr
argument_list|)
operator||
name|EHCI_QH_SET_PORT
argument_list|(
name|hshubport
argument_list|)
operator||
name|EHCI_QH_SET_CMASK
argument_list|(
literal|0x1c
argument_list|)
operator||
name|EHCI_QH_SET_SMASK
argument_list|(
name|xfertype
operator|==
name|UE_INTERRUPT
condition|?
literal|0x01
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_curqtd
operator|=
name|EHCI_NULL
expr_stmt|;
comment|/* The overlay qTD was already set up by ehci_alloc_sqh(). */
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_status
operator|=
name|htole32
argument_list|(
name|EHCI_QTD_SET_TOGGLE
argument_list|(
name|pipe
operator|->
name|endpoint
operator|->
name|savedtoggle
argument_list|)
argument_list|)
expr_stmt|;
name|epipe
operator|->
name|sqh
operator|=
name|sqh
expr_stmt|;
switch|switch
condition|(
name|xfertype
condition|)
block|{
case|case
name|UE_CONTROL
case|:
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
sizeof|sizeof
argument_list|(
name|usb_device_request_t
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|epipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
if|if
condition|(
name|err
condition|)
name|printf
argument_list|(
literal|"ehci_open: usb_allocmem()=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err
condition|)
goto|goto
name|bad1
goto|;
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ehci_device_ctrl_methods
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ehci_add_qh
argument_list|(
name|sqh
argument_list|,
name|sc
operator|->
name|sc_async_head
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_BULK
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ehci_device_bulk_methods
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ehci_add_qh
argument_list|(
name|sqh
argument_list|,
name|sc
operator|->
name|sc_async_head
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_INTERRUPT
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ehci_device_intr_methods
expr_stmt|;
name|ival
operator|=
name|pipe
operator|->
name|interval
expr_stmt|;
if|if
condition|(
name|ival
operator|==
name|USBD_DEFAULT_INTERVAL
condition|)
name|ival
operator|=
name|ed
operator|->
name|bInterval
expr_stmt|;
return|return
operator|(
name|ehci_device_setintr
argument_list|(
name|sc
argument_list|,
name|sqh
argument_list|,
name|ival
argument_list|)
operator|)
return|;
case|case
name|UE_ISOCHRONOUS
case|:
name|pipe
operator|->
name|methods
operator|=
operator|&
name|ehci_device_isoc_methods
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
default|default:
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad1
label|:
name|ehci_free_sqh
argument_list|(
name|sc
argument_list|,
name|sqh
argument_list|)
expr_stmt|;
name|bad0
label|:
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an ED to the schedule.  Called at splusb().  * If in the async schedule, it will always have a next.  * If in the intr schedule it may not.  */
end_comment

begin_function
name|void
name|ehci_add_qh
parameter_list|(
name|ehci_soft_qh_t
modifier|*
name|sqh
parameter_list|,
name|ehci_soft_qh_t
modifier|*
name|head
parameter_list|)
block|{
name|SPLUSBCHECK
expr_stmt|;
name|sqh
operator|->
name|next
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|sqh
operator|->
name|prev
operator|=
name|head
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_link
operator|=
name|head
operator|->
name|qh
operator|.
name|qh_link
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|sqh
expr_stmt|;
if|if
condition|(
name|sqh
operator|->
name|next
condition|)
name|sqh
operator|->
name|next
operator|->
name|prev
operator|=
name|sqh
expr_stmt|;
name|head
operator|->
name|qh
operator|.
name|qh_link
operator|=
name|htole32
argument_list|(
name|sqh
operator|->
name|physaddr
operator||
name|EHCI_LINK_QH
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"ehci_add_qh:\n"
argument_list|)
expr_stmt|;
name|ehci_dump_sqh
argument_list|(
name|sqh
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Remove an ED from the schedule.  Called at splusb().  * Will always have a 'next' if it's in the async list as it's circular.  */
end_comment

begin_function
name|void
name|ehci_rem_qh
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|ehci_soft_qh_t
modifier|*
name|sqh
parameter_list|,
name|ehci_soft_qh_t
modifier|*
name|head
parameter_list|)
block|{
name|SPLUSBCHECK
expr_stmt|;
comment|/* XXX */
name|sqh
operator|->
name|prev
operator|->
name|qh
operator|.
name|qh_link
operator|=
name|sqh
operator|->
name|qh
operator|.
name|qh_link
expr_stmt|;
name|sqh
operator|->
name|prev
operator|->
name|next
operator|=
name|sqh
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|sqh
operator|->
name|next
condition|)
name|sqh
operator|->
name|next
operator|->
name|prev
operator|=
name|sqh
operator|->
name|prev
expr_stmt|;
name|ehci_sync_hc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restart a QH following the addition of a qTD. */
end_comment

begin_function
name|void
name|ehci_activate_qh
parameter_list|(
name|ehci_soft_qh_t
modifier|*
name|sqh
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
name|sqtd
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_status
operator|&
name|htole32
argument_list|(
name|EHCI_QTD_ACTIVE
argument_list|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"ehci_activate_qh: already active"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * When a QH is idle, the overlay qTD should be marked as not 	 * halted and not active. This causes the host controller to 	 * retrieve the real qTD on each pass (rather than just examinig 	 * the overlay), so it will notice when we activate the qTD. 	 */
if|if
condition|(
name|sqtd
operator|==
name|sqh
operator|->
name|sqtd
condition|)
block|{
comment|/* Check that the hardware is in the state we expect. */
if|if
condition|(
name|EHCI_LINK_ADDR
argument_list|(
name|le32toh
argument_list|(
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_next
argument_list|)
argument_list|)
operator|!=
name|sqtd
operator|->
name|physaddr
condition|)
block|{
ifdef|#
directive|ifdef
name|EHCI_DEBUG
name|printf
argument_list|(
literal|"ehci_activate_qh: unexpected next ptr\n"
argument_list|)
expr_stmt|;
name|ehci_dump_sqh
argument_list|(
name|sqh
argument_list|)
expr_stmt|;
name|ehci_dump_sqtds
argument_list|(
name|sqh
operator|->
name|sqtd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_next
operator|=
name|htole32
argument_list|(
name|sqtd
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_altnext
operator|=
name|EHCI_NULL
expr_stmt|;
block|}
comment|/* Ensure the flags are correct. */
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_status
operator|&=
name|htole32
argument_list|(
name|EHCI_QTD_PINGSTATE
operator||
name|EHCI_QTD_TOGGLE_MASK
argument_list|)
expr_stmt|;
block|}
comment|/* Now activate the qTD. */
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_status
operator||=
name|htole32
argument_list|(
name|EHCI_QTD_ACTIVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ensure that the HC has released all references to the QH.  We do this  * by asking for a Async Advance Doorbell interrupt and then we wait for  * the interrupt.  * To make this easier we first obtain exclusive use of the doorbell.  */
end_comment

begin_function
name|void
name|ehci_sync_hc
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_sync_hc: dying\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_sync_hc: enter\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* get doorbell */
name|lockmgr
argument_list|(
operator|&
name|sc
operator|->
name|sc_doorbell_lock
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhardusb
argument_list|()
expr_stmt|;
comment|/* ask for doorbell */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
operator||
name|EHCI_CMD_IAAD
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ehci_sync_hc: cmd=0x%08x sts=0x%08x\n"
operator|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
operator|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_async_head
argument_list|,
name|PZERO
argument_list|,
literal|"ehcidi"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* bell wait */
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ehci_sync_hc: cmd=0x%08x sts=0x%08x\n"
operator|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
operator|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* release doorbell */
name|lockmgr
argument_list|(
operator|&
name|sc
operator|->
name|sc_doorbell_lock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"ehci_sync_hc: tsleep() = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_sync_hc: exit\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***********/
end_comment

begin_comment
comment|/*  * Data structures and routines to emulate the root hub.  */
end_comment

begin_decl_stmt
specifier|static
name|usb_device_descriptor_t
name|ehci_devd
init|=
block|{
name|USB_DEVICE_DESCRIPTOR_SIZE
block|,
name|UDESC_DEVICE
block|,
comment|/* type */
block|{
literal|0x00
block|,
literal|0x02
block|}
block|,
comment|/* USB version */
name|UDCLASS_HUB
block|,
comment|/* class */
name|UDSUBCLASS_HUB
block|,
comment|/* subclass */
name|UDPROTO_HSHUBSTT
block|,
comment|/* protocol */
literal|64
block|,
comment|/* max packet */
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* device id */
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* string indicies */
literal|1
comment|/* # of configurations */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_device_qualifier_t
name|ehci_odevd
init|=
block|{
name|USB_DEVICE_DESCRIPTOR_SIZE
block|,
name|UDESC_DEVICE_QUALIFIER
block|,
comment|/* type */
block|{
literal|0x00
block|,
literal|0x02
block|}
block|,
comment|/* USB version */
name|UDCLASS_HUB
block|,
comment|/* class */
name|UDSUBCLASS_HUB
block|,
comment|/* subclass */
name|UDPROTO_FSHUB
block|,
comment|/* protocol */
literal|64
block|,
comment|/* max packet */
literal|1
block|,
comment|/* # of configurations */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_config_descriptor_t
name|ehci_confd
init|=
block|{
name|USB_CONFIG_DESCRIPTOR_SIZE
block|,
name|UDESC_CONFIG
block|,
block|{
name|USB_CONFIG_DESCRIPTOR_SIZE
operator|+
name|USB_INTERFACE_DESCRIPTOR_SIZE
operator|+
name|USB_ENDPOINT_DESCRIPTOR_SIZE
block|}
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|UC_SELF_POWERED
block|,
literal|0
comment|/* max power */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_interface_descriptor_t
name|ehci_ifcd
init|=
block|{
name|USB_INTERFACE_DESCRIPTOR_SIZE
block|,
name|UDESC_INTERFACE
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
name|UICLASS_HUB
block|,
name|UISUBCLASS_HUB
block|,
name|UIPROTO_HSHUBSTT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_endpoint_descriptor_t
name|ehci_endpd
init|=
block|{
name|USB_ENDPOINT_DESCRIPTOR_SIZE
block|,
name|UDESC_ENDPOINT
block|,
name|UE_DIR_IN
operator||
name|EHCI_INTR_ENDPT
block|,
name|UE_INTERRUPT
block|,
block|{
literal|8
block|,
literal|0
block|}
block|,
comment|/* max packet */
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_hub_descriptor_t
name|ehci_hubd
init|=
block|{
name|USB_HUB_DESCRIPTOR_SIZE
block|,
name|UDESC_HUB
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ehci_str
parameter_list|(
name|usb_string_descriptor_t
modifier|*
name|p
parameter_list|,
name|int
name|l
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|->
name|bLength
operator|=
literal|2
operator|*
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|p
operator|->
name|bDescriptorType
operator|=
name|UDESC_STRING
expr_stmt|;
name|l
operator|-=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
index|[
name|i
index|]
operator|&&
name|l
operator|>
literal|1
condition|;
name|i
operator|++
operator|,
name|l
operator|-=
literal|2
control|)
name|USETW2
argument_list|(
name|p
operator|->
name|bString
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|*
name|i
operator|+
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simulate a hardware hub by handling all the necessary requests.  */
end_comment

begin_function
specifier|static
name|usbd_status
name|ehci_root_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Pipe isn't running, start first */
return|return
operator|(
name|ehci_root_ctrl_start
argument_list|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usbd_status
name|ehci_root_ctrl_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|xfer
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|usb_device_request_t
modifier|*
name|req
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|port
decl_stmt|,
name|i
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|,
name|value
decl_stmt|,
name|index
decl_stmt|,
name|l
decl_stmt|,
name|totlen
init|=
literal|0
decl_stmt|;
name|usb_port_status_t
name|ps
decl_stmt|;
name|usb_hub_descriptor_t
name|hubd
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
operator|)
condition|)
comment|/* XXX panic */
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
endif|#
directive|endif
name|req
operator|=
operator|&
name|xfer
operator|->
name|request
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ehci_root_ctrl_start: type=0x%02x request=%02x\n"
operator|,
name|req
operator|->
name|bmRequestType
operator|,
name|req
operator|->
name|bRequest
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
expr_stmt|;
name|value
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
expr_stmt|;
name|index
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|buf
operator|=
name|xfer
operator|->
name|buffer
expr_stmt|;
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) | ((y)<< 8))
switch|switch
condition|(
name|C
argument_list|(
name|req
operator|->
name|bRequest
argument_list|,
name|req
operator|->
name|bmRequestType
argument_list|)
condition|)
block|{
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
comment|/* 		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops 		 * for the integrated root hub. 		 */
break|break;
case|case
name|C
argument_list|(
name|UR_GET_CONFIG
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
name|sc
operator|->
name|sc_conf
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ehci_root_ctrl_start: wValue=0x%04x\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
operator|>>
literal|8
condition|)
block|{
case|case
name|UDESC_DEVICE
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|totlen
operator|=
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_DEVICE_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|ehci_devd
operator|.
name|idVendor
argument_list|,
name|sc
operator|->
name|sc_id_vendor
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ehci_devd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * We can't really operate at another speed, but the spec says 		 * we need this descriptor. 		 */
case|case
name|UDESC_DEVICE_QUALIFIER
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|totlen
operator|=
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_DEVICE_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ehci_odevd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * We can't really operate at another speed, but the spec says 		 * we need this descriptor. 		 */
case|case
name|UDESC_OTHER_SPEED_CONFIGURATION
case|:
case|case
name|UDESC_CONFIG
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|totlen
operator|=
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_CONFIG_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ehci_confd
argument_list|,
name|l
argument_list|)
expr_stmt|;
operator|(
operator|(
name|usb_config_descriptor_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|bDescriptorType
operator|=
name|value
operator|>>
literal|8
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_INTERFACE_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ehci_ifcd
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|USB_ENDPOINT_DESCRIPTOR_SIZE
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ehci_endpd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESC_STRING
case|:
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
literal|0
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0
case|:
comment|/* Language table */
name|totlen
operator|=
name|ehci_str
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"\001"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Vendor */
name|totlen
operator|=
name|ehci_str
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|sc
operator|->
name|sc_vendor
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Product */
name|totlen
operator|=
name|ehci_str
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"EHCI root hub"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_INTERFACE
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|=
literal|0
expr_stmt|;
name|totlen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|USETW
argument_list|(
operator|(
operator|(
name|usb_status_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|wStatus
argument_list|,
name|UDS_SELF_POWERED
argument_list|)
expr_stmt|;
name|totlen
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_ENDPOINT
argument_list|)
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|USETW
argument_list|(
operator|(
operator|(
name|usb_status_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|wStatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|totlen
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_SET_ADDRESS
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|>=
name|USB_MAX_DEVICES
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|sc
operator|->
name|sc_addr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_CONFIG
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|value
operator|!=
literal|1
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|sc
operator|->
name|sc_conf
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|C
argument_list|(
name|UR_SET_INTERFACE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SYNCH_FRAME
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
break|break;
comment|/* Hub requests */
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ehci_root_ctrl_start: UR_CLEAR_PORT_FEATURE "
literal|"port=%d feature=%d\n"
operator|,
name|index
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|1
operator|||
name|index
operator|>
name|sc
operator|->
name|sc_noport
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|port
operator|=
name|EHCI_PORTSC
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|v
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|&
operator|~
name|EHCI_PS_CLEAR
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator|&
operator|~
name|EHCI_PS_PE
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator|&
operator|~
name|EHCI_PS_SUSP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_POWER
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator|&
operator|~
name|EHCI_PS_PP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_TEST
case|:
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_root_ctrl_start: clear port test "
literal|"%d\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_INDICATOR
case|:
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_root_ctrl_start: clear port ind "
literal|"%d\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator|&
operator|~
name|EHCI_PS_PIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONNECTION
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_CSC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_ENABLE
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_PEC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_SUSPEND
case|:
comment|/* how? */
break|break;
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_OCC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_RESET
case|:
name|sc
operator|->
name|sc_isreset
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|#
directive|if
literal|0
block|switch(value) { 		case UHF_C_PORT_CONNECTION: 		case UHF_C_PORT_ENABLE: 		case UHF_C_PORT_SUSPEND: 		case UHF_C_PORT_OVER_CURRENT: 		case UHF_C_PORT_RESET:
comment|/* Enable RHSC interrupt if condition is cleared. */
block|if ((OREAD4(sc, port)>> 16) == 0) 				ehci_pcd_able(sc, 1); 			break; 		default: 			break; 		}
endif|#
directive|endif
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|hubd
operator|=
name|ehci_hubd
expr_stmt|;
name|hubd
operator|.
name|bNbrPorts
operator|=
name|sc
operator|->
name|sc_noport
expr_stmt|;
name|v
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_HCSPARAMS
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|hubd
operator|.
name|wHubCharacteristics
argument_list|,
name|EHCI_HCS_PPC
argument_list|(
name|v
argument_list|)
condition|?
name|UHD_PWR_INDIVIDUAL
else|:
name|UHD_PWR_NO_SWITCH
operator||
name|EHCI_HCS_P_INDICATOR
argument_list|(
name|EREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_HCSPARAMS
argument_list|)
argument_list|)
condition|?
name|UHD_PORT_IND
else|:
literal|0
argument_list|)
expr_stmt|;
name|hubd
operator|.
name|bPwrOn2PwrGood
operator|=
literal|200
expr_stmt|;
comment|/* XXX can't find out? */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|l
operator|=
name|sc
operator|->
name|sc_noport
init|;
name|l
operator|>
literal|0
condition|;
name|i
operator|++
operator|,
name|l
operator|-=
literal|8
operator|,
name|v
operator|>>=
literal|8
control|)
name|hubd
operator|.
name|DeviceRemovable
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/* XXX can't find out? */
name|hubd
operator|.
name|bDescLength
operator|=
name|USB_HUB_DESCRIPTOR_SIZE
operator|+
name|i
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|hubd
operator|.
name|bDescLength
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|hubd
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
name|len
operator|!=
literal|4
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* ? XXX */
name|totlen
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ehci_root_ctrl_start: get port status i=%d\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|1
operator|||
name|index
operator|>
name|sc
operator|->
name|sc_noport
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|len
operator|!=
literal|4
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|v
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
operator|(
literal|"ehci_root_ctrl_start: port status=0x%04x\n"
operator|,
name|v
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|UPS_HIGH_SPEED
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_CS
condition|)
name|i
operator||=
name|UPS_CURRENT_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_PE
condition|)
name|i
operator||=
name|UPS_PORT_ENABLED
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_SUSP
condition|)
name|i
operator||=
name|UPS_SUSPEND
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_OCA
condition|)
name|i
operator||=
name|UPS_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_PR
condition|)
name|i
operator||=
name|UPS_RESET
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_PP
condition|)
name|i
operator||=
name|UPS_PORT_POWER
expr_stmt|;
name|USETW
argument_list|(
name|ps
operator|.
name|wPortStatus
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_CSC
condition|)
name|i
operator||=
name|UPS_C_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_PEC
condition|)
name|i
operator||=
name|UPS_C_PORT_ENABLED
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_OCC
condition|)
name|i
operator||=
name|UPS_C_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_isreset
condition|)
name|i
operator||=
name|UPS_C_PORT_RESET
expr_stmt|;
name|USETW
argument_list|(
name|ps
operator|.
name|wPortChange
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|len
argument_list|,
sizeof|sizeof
name|ps
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ps
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|l
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
name|index
operator|<
literal|1
operator|||
name|index
operator|>
name|sc
operator|->
name|sc_noport
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|port
operator|=
name|EHCI_PORTSC
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|v
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|&
operator|~
name|EHCI_PS_CLEAR
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_PE
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_SUSP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_RESET
case|:
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ehci_root_ctrl_start: reset port %d\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EHCI_PS_IS_LOWSPEED
argument_list|(
name|v
argument_list|)
condition|)
block|{
comment|/* Low speed device, give up ownership. */
name|ehci_disown
argument_list|(
name|sc
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Start reset sequence. */
name|v
operator|&=
operator|~
operator|(
name|EHCI_PS_PE
operator||
name|EHCI_PS_PR
operator|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_PR
argument_list|)
expr_stmt|;
comment|/* Wait for reset to complete. */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_PORT_ROOT_RESET_DELAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* Terminate reset sequence. */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Wait for HC to complete reset. */
name|usb_delay_ms
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|EHCI_PORT_RESET_COMPLETE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
block|{
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|v
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci after reset, status=0x%08x\n"
operator|,
name|v
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_PR
condition|)
block|{
name|printf
argument_list|(
literal|"%s: port reset timeout\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_TIMEOUT
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|v
operator|&
name|EHCI_PS_PE
operator|)
condition|)
block|{
comment|/* Not a high speed device, give up ownership.*/
name|ehci_disown
argument_list|(
name|sc
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_isreset
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci port %d reset, status = 0x%08x\n"
operator|,
name|index
operator|,
name|v
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_POWER
case|:
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_root_ctrl_start: set port power "
literal|"%d\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_PP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_TEST
case|:
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_root_ctrl_start: set port test "
literal|"%d\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_INDICATOR
case|:
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_root_ctrl_start: set port ind "
literal|"%d\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_PIC
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_CLEAR_TT_BUFFER
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_RESET_TT
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_GET_TT_STATE
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_STOP_TT
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
break|break;
default|default:
name|err
operator|=
name|USBD_IOERROR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|xfer
operator|->
name|actlen
operator|=
name|totlen
expr_stmt|;
name|err
operator|=
name|USBD_NORMAL_COMPLETION
expr_stmt|;
name|ret
label|:
name|xfer
operator|->
name|status
operator|=
name|err
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ehci_disown
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|lowspeed
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_disown: index=%d lowspeed=%d\n"
operator|,
name|index
operator|,
name|lowspeed
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sc
operator|->
name|sc_npcomp
operator|!=
literal|0
condition|)
block|{
name|int
name|i
init|=
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
name|sc
operator|->
name|sc_npcomp
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|sc
operator|->
name|sc_ncomp
condition|)
name|printf
argument_list|(
literal|"%s: strange port\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s: handing over %s speed device on "
literal|"port %d to %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|,
name|lowspeed
condition|?
literal|"low"
else|:
literal|"full"
argument_list|,
name|index
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_comps
index|[
name|i
index|]
operator|->
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: npcomp == 0\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|port
operator|=
name|EHCI_PORTSC
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|v
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|&
operator|~
name|EHCI_PS_CLEAR
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_PO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Abort a root control request. */
end_comment

begin_function
specifier|static
name|void
name|ehci_root_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
comment|/* Nothing to do, all transfers are synchronous. */
block|}
end_function

begin_comment
comment|/* Close the root pipe. */
end_comment

begin_function
specifier|static
name|void
name|ehci_root_ctrl_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_root_ctrl_close\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Nothing to do. */
block|}
end_function

begin_function
name|void
name|ehci_root_intr_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|usbd_status
name|ehci_root_intr_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Pipe isn't running, start first */
return|return
operator|(
name|ehci_root_intr_start
argument_list|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usbd_status
name|ehci_root_intr_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_pipe_handle
name|pipe
init|=
name|xfer
operator|->
name|pipe
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
name|sc
operator|->
name|sc_intrxfer
operator|=
name|xfer
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort a root interrupt request. */
end_comment

begin_function
specifier|static
name|void
name|ehci_root_intr_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|==
name|xfer
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_root_intr_abort: remove\n"
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|=
name|NULL
expr_stmt|;
block|}
name|xfer
operator|->
name|status
operator|=
name|USBD_CANCELLED
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close the root pipe. */
end_comment

begin_function
specifier|static
name|void
name|ehci_root_intr_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_root_intr_close\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intrxfer
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ehci_root_ctrl_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{ }
end_function

begin_comment
comment|/************************/
end_comment

begin_function
name|ehci_soft_qh_t
modifier|*
name|ehci_alloc_sqh
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|ehci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|ehci_soft_qtd_t
modifier|*
name|sqtd
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offs
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_freeqhs
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_alloc_sqh: allocating chunk\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|EHCI_SQH_SIZE
operator|*
name|EHCI_SQH_CHUNK
argument_list|,
name|EHCI_PAGE_SIZE
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
if|if
condition|(
name|err
condition|)
name|printf
argument_list|(
literal|"ehci_alloc_sqh: usb_allocmem()=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EHCI_SQH_CHUNK
condition|;
name|i
operator|++
control|)
block|{
name|offs
operator|=
name|i
operator|*
name|EHCI_SQH_SIZE
expr_stmt|;
name|sqh
operator|=
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|physaddr
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|next
operator|=
name|sc
operator|->
name|sc_freeqhs
expr_stmt|;
name|sc
operator|->
name|sc_freeqhs
operator|=
name|sqh
expr_stmt|;
block|}
block|}
comment|/* Allocate the initial inactive sqtd. */
name|sqtd
operator|=
name|ehci_alloc_sqtd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqtd
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_status
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_next
operator|=
name|EHCI_NULL
expr_stmt|;
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_altnext
operator|=
name|EHCI_NULL
expr_stmt|;
name|sqh
operator|=
name|sc
operator|->
name|sc_freeqhs
expr_stmt|;
name|sc
operator|->
name|sc_freeqhs
operator|=
name|sqh
operator|->
name|next
expr_stmt|;
comment|/* The overlay QTD should begin zeroed. */
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_next
operator|=
name|htole32
argument_list|(
name|sqtd
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_altnext
operator|=
name|EHCI_NULL
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_status
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EHCI_QTD_NBUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_buffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_buffer_hi
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|sqh
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|sqh
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|sqh
operator|->
name|sqtd
operator|=
name|sqtd
expr_stmt|;
name|sqh
operator|->
name|inactivesqtd
operator|=
name|sqtd
expr_stmt|;
return|return
operator|(
name|sqh
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ehci_free_sqh
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|ehci_soft_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|ehci_free_sqtd
argument_list|(
name|sc
argument_list|,
name|sqh
operator|->
name|inactivesqtd
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|next
operator|=
name|sc
operator|->
name|sc_freeqhs
expr_stmt|;
name|sc
operator|->
name|sc_freeqhs
operator|=
name|sqh
expr_stmt|;
block|}
end_function

begin_function
name|ehci_soft_qtd_t
modifier|*
name|ehci_alloc_sqtd
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|ehci_soft_qtd_t
modifier|*
name|sqtd
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offs
decl_stmt|;
name|usb_dma_t
name|dma
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_freeqtds
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_alloc_sqtd: allocating chunk\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_allocmem
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|EHCI_SQTD_SIZE
operator|*
name|EHCI_SQTD_CHUNK
argument_list|,
name|EHCI_PAGE_SIZE
argument_list|,
operator|&
name|dma
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
if|if
condition|(
name|err
condition|)
name|printf
argument_list|(
literal|"ehci_alloc_sqtd: usb_allocmem()=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EHCI_SQTD_CHUNK
condition|;
name|i
operator|++
control|)
block|{
name|offs
operator|=
name|i
operator|*
name|EHCI_SQTD_SIZE
expr_stmt|;
name|sqtd
operator|=
name|KERNADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|sqtd
operator|->
name|physaddr
operator|=
name|DMAADDR
argument_list|(
operator|&
name|dma
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|sqtd
operator|->
name|nextqtd
operator|=
name|sc
operator|->
name|sc_freeqtds
expr_stmt|;
name|sc
operator|->
name|sc_freeqtds
operator|=
name|sqtd
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sqtd
operator|=
name|sc
operator|->
name|sc_freeqtds
expr_stmt|;
name|sc
operator|->
name|sc_freeqtds
operator|=
name|sqtd
operator|->
name|nextqtd
expr_stmt|;
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_next
operator|=
name|EHCI_NULL
expr_stmt|;
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_altnext
operator|=
name|EHCI_NULL
expr_stmt|;
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_status
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EHCI_QTD_NBUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_buffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_buffer_hi
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|sqtd
operator|->
name|nextqtd
operator|=
name|NULL
expr_stmt|;
name|sqtd
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|sqtd
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ehci_free_sqtd
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
name|sqtd
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sqtd
operator|->
name|nextqtd
operator|=
name|sc
operator|->
name|sc_freeqtds
expr_stmt|;
name|sc
operator|->
name|sc_freeqtds
operator|=
name|sqtd
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|ehci_alloc_sqtd_chain
parameter_list|(
name|struct
name|ehci_pipe
modifier|*
name|epipe
parameter_list|,
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|alen
parameter_list|,
name|int
name|rd
parameter_list|,
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
name|start
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
name|newinactive
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
modifier|*
name|sp
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
modifier|*
name|ep
parameter_list|)
block|{
name|ehci_soft_qtd_t
modifier|*
name|next
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|ehci_physaddr_t
name|dataphys
decl_stmt|,
name|nextphys
decl_stmt|;
name|u_int32_t
name|qtdstatus
decl_stmt|;
name|int
name|adj
decl_stmt|,
name|len
decl_stmt|,
name|curlen
decl_stmt|,
name|mps
decl_stmt|,
name|offset
decl_stmt|,
name|pagelen
decl_stmt|,
name|seg
decl_stmt|,
name|segoff
decl_stmt|;
name|int
name|i
decl_stmt|,
name|iscontrol
decl_stmt|,
name|forceshort
decl_stmt|;
name|struct
name|usb_dma_mapping
modifier|*
name|dma
init|=
operator|&
name|xfer
operator|->
name|dmamap
decl_stmt|;
name|DPRINTFN
argument_list|(
name|alen
operator|<
literal|4
operator|*
literal|4096
argument_list|,
operator|(
literal|"ehci_alloc_sqtd_chain: start len=%d\n"
operator|,
name|alen
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|alen
expr_stmt|;
name|iscontrol
operator|=
operator|(
name|epipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|==
name|UE_CONTROL
expr_stmt|;
name|qtdstatus
operator|=
name|EHCI_QTD_ACTIVE
operator||
name|EHCI_QTD_SET_PID
argument_list|(
name|rd
condition|?
name|EHCI_QTD_PID_IN
else|:
name|EHCI_QTD_PID_OUT
argument_list|)
operator||
name|EHCI_QTD_SET_CERR
argument_list|(
literal|3
argument_list|)
comment|/* IOC set below */
comment|/* BYTES set below */
expr_stmt|;
name|mps
operator|=
name|UGETW
argument_list|(
name|epipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
expr_stmt|;
name|forceshort
operator|=
operator|(
operator|(
name|xfer
operator|->
name|flags
operator|&
name|USBD_FORCE_SHORT_XFER
operator|)
operator|||
name|len
operator|==
literal|0
operator|)
operator|&&
name|len
operator|%
name|mps
operator|==
literal|0
expr_stmt|;
comment|/* 	 * The control transfer data stage always starts with a toggle of 1. 	 * For other transfers we let the hardware track the toggle state. 	 */
if|if
condition|(
name|iscontrol
condition|)
name|qtdstatus
operator||=
name|EHCI_QTD_SET_TOGGLE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we are given a starting qTD, assume it is linked into 		 * an active QH so be careful not to mark it active. 		 */
name|cur
operator|=
name|start
expr_stmt|;
operator|*
name|sp
operator|=
name|cur
expr_stmt|;
name|qtdstatus
operator|&=
operator|~
name|EHCI_QTD_ACTIVE
expr_stmt|;
block|}
else|else
block|{
name|cur
operator|=
name|ehci_alloc_sqtd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
block|}
name|seg
operator|=
literal|0
expr_stmt|;
name|segoff
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|curlen
operator|=
literal|0
expr_stmt|;
comment|/* The EHCI hardware can handle at most 5 pages. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EHCI_QTD_NBUFFERS
operator|&&
name|curlen
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|seg
operator|<
name|dma
operator|->
name|nsegs
argument_list|,
operator|(
literal|"ehci_alloc_sqtd_chain: overrun"
operator|)
argument_list|)
expr_stmt|;
name|dataphys
operator|=
name|dma
operator|->
name|segs
index|[
name|seg
index|]
operator|.
name|ds_addr
operator|+
name|segoff
expr_stmt|;
name|pagelen
operator|=
name|dma
operator|->
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
operator|-
name|segoff
expr_stmt|;
if|if
condition|(
name|pagelen
operator|>
name|len
operator|-
name|curlen
condition|)
name|pagelen
operator|=
name|len
operator|-
name|curlen
expr_stmt|;
if|if
condition|(
name|pagelen
operator|>
name|EHCI_PAGE_SIZE
operator|-
name|EHCI_PAGE_OFFSET
argument_list|(
name|dataphys
argument_list|)
condition|)
name|pagelen
operator|=
name|EHCI_PAGE_SIZE
operator|-
name|EHCI_PAGE_OFFSET
argument_list|(
name|dataphys
argument_list|)
expr_stmt|;
name|segoff
operator|+=
name|pagelen
expr_stmt|;
if|if
condition|(
name|segoff
operator|>=
name|dma
operator|->
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
condition|)
block|{
name|KASSERT
argument_list|(
name|segoff
operator|==
name|dma
operator|->
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
argument_list|,
operator|(
literal|"ehci_alloc_sqtd_chain: overlap"
operator|)
argument_list|)
expr_stmt|;
name|seg
operator|++
expr_stmt|;
name|segoff
operator|=
literal|0
expr_stmt|;
block|}
name|cur
operator|->
name|qtd
operator|.
name|qtd_buffer
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|dataphys
argument_list|)
expr_stmt|;
name|cur
operator|->
name|qtd
operator|.
name|qtd_buffer_hi
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|curlen
operator|+=
name|pagelen
expr_stmt|;
comment|/* 			 * Must stop if there is any gap before or after 			 * the page boundary. 			 */
if|if
condition|(
name|EHCI_PAGE_OFFSET
argument_list|(
name|dataphys
operator|+
name|pagelen
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|seg
operator|<
name|dma
operator|->
name|nsegs
operator|&&
name|EHCI_PAGE_OFFSET
argument_list|(
name|segoff
operator|+
name|dma
operator|->
name|segs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* Adjust down to a multiple of mps if not at the end. */
if|if
condition|(
name|curlen
operator|<
name|len
operator|&&
name|curlen
operator|%
name|mps
operator|!=
literal|0
condition|)
block|{
name|adj
operator|=
name|curlen
operator|%
name|mps
expr_stmt|;
name|curlen
operator|-=
name|adj
expr_stmt|;
name|KASSERT
argument_list|(
name|curlen
operator|>
literal|0
argument_list|,
operator|(
literal|"ehci_alloc_sqtd_chain: need to copy"
operator|)
argument_list|)
expr_stmt|;
name|segoff
operator|-=
name|adj
expr_stmt|;
if|if
condition|(
name|segoff
operator|<
literal|0
condition|)
block|{
name|seg
operator|--
expr_stmt|;
name|segoff
operator|+=
name|dma
operator|->
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|seg
operator|>=
literal|0
operator|&&
name|segoff
operator|>=
literal|0
argument_list|,
operator|(
literal|"ehci_alloc_sqtd_chain: adjust to mps"
operator|)
argument_list|)
expr_stmt|;
block|}
name|len
operator|-=
name|curlen
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
operator|||
name|forceshort
condition|)
block|{
name|next
operator|=
name|ehci_alloc_sqtd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
name|nextphys
operator|=
name|htole32
argument_list|(
name|next
operator|->
name|physaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|NULL
expr_stmt|;
name|nextphys
operator|=
name|EHCI_NULL
expr_stmt|;
block|}
name|cur
operator|->
name|nextqtd
operator|=
name|next
expr_stmt|;
name|cur
operator|->
name|qtd
operator|.
name|qtd_next
operator|=
name|nextphys
expr_stmt|;
comment|/* Make sure to stop after a short transfer. */
name|cur
operator|->
name|qtd
operator|.
name|qtd_altnext
operator|=
name|htole32
argument_list|(
name|newinactive
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|cur
operator|->
name|qtd
operator|.
name|qtd_status
operator|=
name|htole32
argument_list|(
name|qtdstatus
operator||
name|EHCI_QTD_SET_BYTES
argument_list|(
name|curlen
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|cur
operator|->
name|len
operator|=
name|curlen
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ehci_alloc_sqtd_chain: curlen=%d\n"
operator|,
name|curlen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscontrol
condition|)
block|{
comment|/* 			 * adjust the toggle based on the number of packets 			 * in this qtd 			 */
if|if
condition|(
operator|(
operator|(
operator|(
name|curlen
operator|+
name|mps
operator|-
literal|1
operator|)
operator|/
name|mps
operator|)
operator|&
literal|1
operator|)
operator|||
name|curlen
operator|==
literal|0
condition|)
name|qtdstatus
operator|^=
name|EHCI_QTD_TOGGLE_MASK
expr_stmt|;
block|}
name|qtdstatus
operator||=
name|EHCI_QTD_ACTIVE
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|forceshort
condition|)
break|break;
name|forceshort
operator|=
literal|0
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ehci_alloc_sqtd_chain: extend chain\n"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|curlen
expr_stmt|;
name|cur
operator|=
name|next
expr_stmt|;
block|}
name|cur
operator|->
name|qtd
operator|.
name|qtd_status
operator||=
name|htole32
argument_list|(
name|EHCI_QTD_IOC
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|=
name|cur
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ehci_alloc_sqtd_chain: return sqtd=%p sqtdend=%p\n"
operator|,
operator|*
name|sp
operator|,
operator|*
name|ep
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|nomem
label|:
comment|/* XXX free chain */
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"ehci_alloc_sqtd_chain: no memory\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free the chain starting at sqtd and end at the qTD before sqtdend */
end_comment

begin_function
specifier|static
name|void
name|ehci_free_sqtd_chain
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|ehci_soft_qh_t
modifier|*
name|sqh
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
name|sqtd
parameter_list|,
name|ehci_soft_qtd_t
modifier|*
name|sqtdend
parameter_list|)
block|{
name|ehci_soft_qtd_t
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|prevp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ehci_free_sqtd_chain: sqtd=%p sqtdend=%p\n"
operator|,
name|sqtd
operator|,
name|sqtdend
operator|)
argument_list|)
expr_stmt|;
comment|/* First unlink the chain from the QH's software qTD list. */
name|prevp
operator|=
operator|&
name|sqh
operator|->
name|sqtd
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sqh
operator|->
name|sqtd
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|nextqtd
control|)
block|{
if|if
condition|(
name|p
operator|==
name|sqtd
condition|)
block|{
operator|*
name|prevp
operator|=
name|sqtdend
expr_stmt|;
break|break;
block|}
name|prevp
operator|=
operator|&
name|p
operator|->
name|nextqtd
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|p
operator|!=
name|NULL
argument_list|,
operator|(
literal|"ehci_free_sqtd_chain: chain not found"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sqtd
operator|!=
name|sqtdend
condition|;
name|sqtd
operator|=
name|p
operator|,
name|i
operator|++
control|)
block|{
name|p
operator|=
name|sqtd
operator|->
name|nextqtd
expr_stmt|;
name|ehci_free_sqtd
argument_list|(
name|sc
argument_list|,
name|sqtd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************/
end_comment

begin_comment
comment|/*  * Close a reqular pipe.  * Assumes that there are no pending transactions.  */
end_comment

begin_function
name|void
name|ehci_close_pipe
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|,
name|ehci_soft_qh_t
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|ehci_pipe
modifier|*
name|epipe
init|=
operator|(
expr|struct
name|ehci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|ehci_soft_qh_t
modifier|*
name|sqh
init|=
name|epipe
operator|->
name|sqh
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ehci_rem_qh
argument_list|(
name|sc
argument_list|,
name|sqh
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pipe
operator|->
name|endpoint
operator|->
name|savedtoggle
operator|=
name|EHCI_QTD_GET_TOGGLE
argument_list|(
name|le32toh
argument_list|(
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_status
argument_list|)
argument_list|)
expr_stmt|;
name|ehci_free_sqh
argument_list|(
name|sc
argument_list|,
name|epipe
operator|->
name|sqh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Abort a device request.  * If this routine is called at splusb() it guarantees that the request  * will be removed from the hardware scheduling and that the callback  * for it will be called with USBD_CANCELLED status.  * It's impossible to guarantee that the requested transfer will not  * have happened since the hardware runs concurrently.  * If the transaction has already happened we rely on the ordinary  * interrupt processing to process it.  */
end_comment

begin_function
name|void
name|ehci_abort_xfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_status
name|status
parameter_list|)
block|{
define|#
directive|define
name|exfer
value|EXFER(xfer)
name|struct
name|ehci_pipe
modifier|*
name|epipe
init|=
operator|(
expr|struct
name|ehci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|epipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
decl_stmt|;
name|ehci_soft_qh_t
modifier|*
name|sqh
init|=
name|epipe
operator|->
name|sqh
decl_stmt|;
name|ehci_soft_qtd_t
modifier|*
name|sqtd
decl_stmt|,
modifier|*
name|snext
decl_stmt|;
name|ehci_physaddr_t
name|cur
decl_stmt|,
name|us
decl_stmt|,
name|next
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|hit
decl_stmt|,
name|i
decl_stmt|;
comment|/* int count = 0; */
name|ehci_soft_qh_t
modifier|*
name|psqh
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_abort_xfer: xfer=%p pipe=%p\n"
operator|,
name|xfer
operator|,
name|epipe
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
block|{
comment|/* If we're dying, just do the software part. */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|status
expr_stmt|;
comment|/* make software ignore it */
name|callout_stop
argument_list|(
operator|&
name|xfer
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
name|usb_rem_task
argument_list|(
name|epipe
operator|->
name|pipe
operator|.
name|device
argument_list|,
operator|&
name|exfer
operator|->
name|abort_task
argument_list|)
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xfer
operator|->
name|device
operator|->
name|bus
operator|->
name|intr_context
operator|||
operator|!
name|curproc
condition|)
name|panic
argument_list|(
literal|"ehci_abort_xfer: not in process context"
argument_list|)
expr_stmt|;
comment|/* 	 * If an abort is already in progress then just wait for it to 	 * complete and return. 	 */
if|if
condition|(
name|exfer
operator|->
name|ehci_xfer_flags
operator|&
name|EHCI_XFER_ABORTING
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_abort_xfer: already aborting\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* No need to wait if we're aborting from a timeout. */
if|if
condition|(
name|status
operator|==
name|USBD_TIMEOUT
condition|)
return|return;
comment|/* Override the status which might be USBD_TIMEOUT. */
name|xfer
operator|->
name|status
operator|=
name|status
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_abort_xfer: waiting for abort to finish\n"
operator|)
argument_list|)
expr_stmt|;
name|exfer
operator|->
name|ehci_xfer_flags
operator||=
name|EHCI_XFER_ABORTWAIT
expr_stmt|;
while|while
condition|(
name|exfer
operator|->
name|ehci_xfer_flags
operator|&
name|EHCI_XFER_ABORTING
condition|)
name|tsleep
argument_list|(
operator|&
name|exfer
operator|->
name|ehci_xfer_flags
argument_list|,
name|PZERO
argument_list|,
literal|"ehciaw"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Step 1: Make interrupt routine and timeouts ignore xfer. 	 */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|exfer
operator|->
name|ehci_xfer_flags
operator||=
name|EHCI_XFER_ABORTING
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|status
expr_stmt|;
comment|/* make software ignore it */
name|callout_stop
argument_list|(
operator|&
name|xfer
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
name|usb_rem_task
argument_list|(
name|epipe
operator|->
name|pipe
operator|.
name|device
argument_list|,
operator|&
name|exfer
operator|->
name|abort_task
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Step 2: Wait until we know hardware has finished any possible 	 * use of the xfer. We do this by removing the entire 	 * queue from the async schedule and waiting for the doorbell. 	 * Nothing else should be touching the queue now. 	 */
name|psqh
operator|=
name|sqh
operator|->
name|prev
expr_stmt|;
name|ehci_rem_qh
argument_list|(
name|sc
argument_list|,
name|sqh
argument_list|,
name|psqh
argument_list|)
expr_stmt|;
comment|/*  	 * Step 3:  make sure the soft interrupt routine 	 * has run. This should remove any completed items off the queue. 	 * The hardware has no reference to completed items (TDs). 	 * It's safe to remove them at any time. 	 */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_USE_SOFTINTR
name|sc
operator|->
name|sc_softwake
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* USB_USE_SOFTINTR */
name|usb_schedsoftintr
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_USE_SOFTINTR
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_softwake
argument_list|,
name|PZERO
argument_list|,
literal|"ehciab"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USB_USE_SOFTINTR */
comment|/* 	 * Step 4: Remove any vestiges of the xfer from the hardware. 	 * The complication here is that the hardware may have executed 	 * into or even beyond the xfer we're trying to abort. 	 * So as we're scanning the TDs of this xfer we check if 	 * the hardware points to any of them. 	 * 	 * first we need to see if there are any transfers 	 * on this queue before the xfer we are aborting.. we need 	 * to update any pointers that point to us to point past 	 * the aborting xfer.  (If there is something past us). 	 * Hardware and software. 	 */
name|cur
operator|=
name|EHCI_LINK_ADDR
argument_list|(
name|le32toh
argument_list|(
name|sqh
operator|->
name|qh
operator|.
name|qh_curqtd
argument_list|)
argument_list|)
expr_stmt|;
name|hit
operator|=
literal|0
expr_stmt|;
comment|/* If they initially point here. */
name|us
operator|=
name|exfer
operator|->
name|sqtdstart
operator|->
name|physaddr
expr_stmt|;
comment|/* We will change them to point here */
name|snext
operator|=
name|exfer
operator|->
name|sqtdend
operator|->
name|nextqtd
expr_stmt|;
name|next
operator|=
name|htole32
argument_list|(
name|snext
operator|->
name|physaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Now loop through any qTDs before us and keep track of the pointer 	 * that points to us for the end. 	 */
name|sqtd
operator|=
name|sqh
operator|->
name|sqtd
expr_stmt|;
while|while
condition|(
name|sqtd
operator|&&
name|sqtd
operator|!=
name|exfer
operator|->
name|sqtdstart
condition|)
block|{
name|hit
operator||=
operator|(
name|cur
operator|==
name|sqtd
operator|->
name|physaddr
operator|)
expr_stmt|;
if|if
condition|(
name|EHCI_LINK_ADDR
argument_list|(
name|le32toh
argument_list|(
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_next
argument_list|)
argument_list|)
operator|==
name|us
condition|)
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|EHCI_LINK_ADDR
argument_list|(
name|le32toh
argument_list|(
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_altnext
argument_list|)
argument_list|)
operator|==
name|us
condition|)
name|sqtd
operator|->
name|qtd
operator|.
name|qtd_altnext
operator|=
name|next
expr_stmt|;
name|sqtd
operator|=
name|sqtd
operator|->
name|nextqtd
expr_stmt|;
block|}
comment|/* 	 * If we already saw the active one then we are pretty much done. 	 * We've done all the relinking we need to do. 	 */
if|if
condition|(
operator|!
name|hit
condition|)
block|{
comment|/* 		 * Now reinitialise the QH to point to the next qTD 		 * (if there is one). We only need to do this if 		 * it was previously pointing to us. 		 */
for|for
control|(
name|sqtd
operator|=
name|exfer
operator|->
name|sqtdstart
init|;
condition|;
name|sqtd
operator|=
name|sqtd
operator|->
name|nextqtd
control|)
block|{
if|if
condition|(
name|cur
operator|==
name|sqtd
operator|->
name|physaddr
condition|)
block|{
name|hit
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sqtd
operator|==
name|exfer
operator|->
name|sqtdend
condition|)
break|break;
block|}
name|sqtd
operator|=
name|sqtd
operator|->
name|nextqtd
expr_stmt|;
comment|/* 		 * Only need to alter the QH if it was pointing at a qTD 		 * that we are removing. 		 */
if|if
condition|(
name|hit
condition|)
block|{
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_next
operator|=
name|htole32
argument_list|(
name|snext
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_altnext
operator|=
name|EHCI_NULL
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_status
operator|&=
name|htole32
argument_list|(
name|EHCI_QTD_TOGGLE_MASK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EHCI_QTD_NBUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_buffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|sqh
operator|->
name|qh
operator|.
name|qh_qtd
operator|.
name|qtd_buffer_hi
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|ehci_add_qh
argument_list|(
name|sqh
argument_list|,
name|psqh
argument_list|)
expr_stmt|;
comment|/* 	 * Step 5: Execute callback. 	 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|exfer
operator|->
name|isdone
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Do the wakeup first to avoid touching the xfer after the callback. */
name|exfer
operator|->
name|ehci_xfer_flags
operator|&=
operator|~
name|EHCI_XFER_ABORTING
expr_stmt|;
if|if
condition|(
name|exfer
operator|->
name|ehci_xfer_flags
operator|&
name|EHCI_XFER_ABORTWAIT
condition|)
block|{
name|exfer
operator|->
name|ehci_xfer_flags
operator|&=
operator|~
name|EHCI_XFER_ABORTWAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|exfer
operator|->
name|ehci_xfer_flags
argument_list|)
expr_stmt|;
block|}
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* printf("%s: %d TDs aborted\n", __func__, count); */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|exfer
block|}
end_function

begin_function
name|void
name|ehci_timeout
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|ehci_xfer
modifier|*
name|exfer
init|=
name|addr
decl_stmt|;
name|struct
name|ehci_pipe
modifier|*
name|epipe
init|=
operator|(
expr|struct
name|ehci_pipe
operator|*
operator|)
name|exfer
operator|->
name|xfer
operator|.
name|pipe
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|epipe
operator|->
name|pipe
operator|.
name|device
operator|->
name|bus
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_timeout: exfer=%p\n"
operator|,
name|exfer
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|1
condition|)
name|usbd_dump_pipe
argument_list|(
name|exfer
operator|->
name|xfer
operator|.
name|pipe
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
block|{
name|ehci_abort_xfer
argument_list|(
operator|&
name|exfer
operator|->
name|xfer
argument_list|,
name|USBD_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Execute the abort in a process context. */
name|usb_add_task
argument_list|(
name|exfer
operator|->
name|xfer
operator|.
name|pipe
operator|->
name|device
argument_list|,
operator|&
name|exfer
operator|->
name|abort_task
argument_list|,
name|USB_TASKQ_HC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ehci_timeout_task
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|usbd_xfer_handle
name|xfer
init|=
name|addr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_timeout_task: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ehci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_TIMEOUT
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Some EHCI chips from VIA / ATI seem to trigger interrupts before writing  * back the qTD status, or miss signalling occasionally under heavy load.  * If the host machine is too fast, we can miss transaction completion - when  * we scan the active list the transaction still seems to be active. This  * generally exhibits itself as a umass stall that never recovers.  *  * We work around this behaviour by setting up this callback after any softintr  * that completes with transactions still pending, giving us another chance to  * check for completion after the writeback has taken place.  */
end_comment

begin_function
name|void
name|ehci_intrlist_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|s
init|=
name|splusb
argument_list|()
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"ehci_intrlist_timeout\n"
operator|)
argument_list|)
expr_stmt|;
name|usb_schedsoftintr
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************/
end_comment

begin_function
specifier|static
name|usbd_status
name|ehci_device_ctrl_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Pipe isn't running, start first */
return|return
operator|(
name|ehci_device_ctrl_start
argument_list|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usbd_status
name|ehci_device_ctrl_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|xfer
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
operator|)
condition|)
block|{
comment|/* XXX panic */
name|printf
argument_list|(
literal|"ehci_device_ctrl_transfer: not a request\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
endif|#
directive|endif
name|err
operator|=
name|ehci_device_request
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
name|ehci_waitintr
argument_list|(
name|sc
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ehci_device_ctrl_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ehci_xfer
modifier|*
name|ex
init|=
name|EXFER
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|xfer
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|struct
name|ehci_pipe
modifier|*
name|epipe
init|=
operator|(
expr|struct
name|ehci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ehci_ctrl_done: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"ehci_ctrl_done: not a request"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|xfer
operator|->
name|status
operator|!=
name|USBD_NOMEM
operator|&&
name|ehci_active_intr_list
argument_list|(
name|ex
argument_list|)
condition|)
block|{
name|ehci_del_intr_list
argument_list|(
name|ex
argument_list|)
expr_stmt|;
comment|/* remove from active list */
name|ehci_free_sqtd_chain
argument_list|(
name|sc
argument_list|,
name|epipe
operator|->
name|sqh
argument_list|,
name|ex
operator|->
name|sqtdstart
argument_list|,
name|ex
operator|->
name|sqtdend
operator|->
name|nextqtd
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ehci_ctrl_done: length=%d\n"
operator|,
name|xfer
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Abort a device control request. */
end_comment

begin_function
specifier|static
name|void
name|ehci_device_ctrl_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_device_ctrl_abort: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
name|ehci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close a device control pipe. */
end_comment

begin_function
specifier|static
name|void
name|ehci_device_ctrl_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
comment|/*struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;*/
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_device_ctrl_close: pipe=%p\n"
operator|,
name|pipe
operator|)
argument_list|)
expr_stmt|;
name|ehci_close_pipe
argument_list|(
name|pipe
argument_list|,
name|sc
operator|->
name|sc_async_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|ehci_device_request
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
define|#
directive|define
name|exfer
value|EXFER(xfer)
name|struct
name|ehci_pipe
modifier|*
name|epipe
init|=
operator|(
expr|struct
name|ehci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usb_device_request_t
modifier|*
name|req
init|=
operator|&
name|xfer
operator|->
name|request
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|epipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|ehci_soft_qtd_t
modifier|*
name|newinactive
decl_stmt|,
modifier|*
name|setup
decl_stmt|,
modifier|*
name|stat
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|ehci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|int
name|isread
decl_stmt|;
name|int
name|len
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|s
decl_stmt|;
name|isread
operator|=
name|req
operator|->
name|bmRequestType
operator|&
name|UT_READ
expr_stmt|;
name|len
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"ehci_device_request: type=0x%02x, request=0x%02x, "
literal|"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\n"
operator|,
name|req
operator|->
name|bmRequestType
operator|,
name|req
operator|->
name|bRequest
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
operator|,
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
operator|,
name|len
operator|,
name|dev
operator|->
name|address
operator|,
name|epipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|)
argument_list|)
expr_stmt|;
name|newinactive
operator|=
name|ehci_alloc_sqtd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|newinactive
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
name|newinactive
operator|->
name|qtd
operator|.
name|qtd_status
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|newinactive
operator|->
name|qtd
operator|.
name|qtd_next
operator|=
name|EHCI_NULL
expr_stmt|;
name|newinactive
operator|->
name|qtd
operator|.
name|qtd_altnext
operator|=
name|EHCI_NULL
expr_stmt|;
name|stat
operator|=
name|ehci_alloc_sqtd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|sqh
operator|=
name|epipe
operator|->
name|sqh
expr_stmt|;
name|setup
operator|=
name|sqh
operator|->
name|inactivesqtd
expr_stmt|;
name|sqh
operator|->
name|inactivesqtd
operator|=
name|newinactive
expr_stmt|;
name|epipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|length
operator|=
name|len
expr_stmt|;
comment|/* Set up data transaction */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|ehci_soft_qtd_t
modifier|*
name|end
decl_stmt|;
name|err
operator|=
name|ehci_alloc_sqtd_chain
argument_list|(
name|epipe
argument_list|,
name|sc
argument_list|,
name|len
argument_list|,
name|isread
argument_list|,
name|xfer
argument_list|,
name|NULL
argument_list|,
name|newinactive
argument_list|,
operator|&
name|next
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|bad3
goto|;
name|end
operator|->
name|qtd
operator|.
name|qtd_status
operator|&=
name|htole32
argument_list|(
operator|~
name|EHCI_QTD_IOC
argument_list|)
expr_stmt|;
name|end
operator|->
name|nextqtd
operator|=
name|stat
expr_stmt|;
name|end
operator|->
name|qtd
operator|.
name|qtd_next
operator|=
name|htole32
argument_list|(
name|stat
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|end
operator|->
name|qtd
operator|.
name|qtd_altnext
operator|=
name|htole32
argument_list|(
name|newinactive
operator|->
name|physaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|stat
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|KERNADDR
argument_list|(
operator|&
name|epipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|,
literal|0
argument_list|)
argument_list|,
name|req
argument_list|,
sizeof|sizeof
expr|*
name|req
argument_list|)
expr_stmt|;
comment|/* Clear toggle, and do not activate until complete */
name|setup
operator|->
name|qtd
operator|.
name|qtd_status
operator|=
name|htole32
argument_list|(
name|EHCI_QTD_SET_PID
argument_list|(
name|EHCI_QTD_PID_SETUP
argument_list|)
operator||
name|EHCI_QTD_SET_CERR
argument_list|(
literal|3
argument_list|)
operator||
name|EHCI_QTD_SET_TOGGLE
argument_list|(
literal|0
argument_list|)
operator||
name|EHCI_QTD_SET_BYTES
argument_list|(
sizeof|sizeof
expr|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|setup
operator|->
name|qtd
operator|.
name|qtd_buffer
index|[
literal|0
index|]
operator|=
name|htole32
argument_list|(
name|DMAADDR
argument_list|(
operator|&
name|epipe
operator|->
name|u
operator|.
name|ctl
operator|.
name|reqdma
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|setup
operator|->
name|qtd
operator|.
name|qtd_buffer_hi
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|setup
operator|->
name|nextqtd
operator|=
name|next
expr_stmt|;
name|setup
operator|->
name|qtd
operator|.
name|qtd_next
operator|=
name|htole32
argument_list|(
name|next
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|setup
operator|->
name|qtd
operator|.
name|qtd_altnext
operator|=
name|htole32
argument_list|(
name|newinactive
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|setup
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|setup
operator|->
name|len
operator|=
sizeof|sizeof
expr|*
name|req
expr_stmt|;
name|stat
operator|->
name|qtd
operator|.
name|qtd_status
operator|=
name|htole32
argument_list|(
name|EHCI_QTD_ACTIVE
operator||
name|EHCI_QTD_SET_PID
argument_list|(
name|isread
condition|?
name|EHCI_QTD_PID_OUT
else|:
name|EHCI_QTD_PID_IN
argument_list|)
operator||
name|EHCI_QTD_SET_CERR
argument_list|(
literal|3
argument_list|)
operator||
name|EHCI_QTD_SET_TOGGLE
argument_list|(
literal|1
argument_list|)
operator||
name|EHCI_QTD_IOC
argument_list|)
expr_stmt|;
name|stat
operator|->
name|qtd
operator|.
name|qtd_buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* XXX not needed? */
name|stat
operator|->
name|qtd
operator|.
name|qtd_buffer_hi
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* XXX not needed? */
name|stat
operator|->
name|nextqtd
operator|=
name|newinactive
expr_stmt|;
name|stat
operator|->
name|qtd
operator|.
name|qtd_next
operator|=
name|htole32
argument_list|(
name|newinactive
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|stat
operator|->
name|qtd
operator|.
name|qtd_altnext
operator|=
name|htole32
argument_list|(
name|newinactive
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|stat
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|stat
operator|->
name|len
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|5
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_device_request:\n"
operator|)
argument_list|)
expr_stmt|;
name|ehci_dump_sqh
argument_list|(
name|sqh
argument_list|)
expr_stmt|;
name|ehci_dump_sqtds
argument_list|(
name|setup
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|exfer
operator|->
name|sqtdstart
operator|=
name|setup
expr_stmt|;
name|exfer
operator|->
name|sqtdend
operator|=
name|stat
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|exfer
operator|->
name|isdone
condition|)
block|{
name|printf
argument_list|(
literal|"ehci_device_request: not done, exfer=%p\n"
argument_list|,
name|exfer
argument_list|)
expr_stmt|;
block|}
name|exfer
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Activate the new qTD in the QH list. */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ehci_activate_qh
argument_list|(
name|sqh
argument_list|,
name|setup
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|&&
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|MS_TO_TICKS
argument_list|(
name|xfer
operator|->
name|timeout
argument_list|)
argument_list|,
name|ehci_timeout
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
name|ehci_add_intr_list
argument_list|(
name|sc
argument_list|,
name|exfer
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_device_request: status=%x\n"
operator|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|ehci_dump_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ehci_dump_sqh
argument_list|(
name|sc
operator|->
name|sc_async_head
argument_list|)
expr_stmt|;
name|ehci_dump_sqh
argument_list|(
name|sqh
argument_list|)
expr_stmt|;
name|ehci_dump_sqtds
argument_list|(
name|setup
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad3
label|:
name|sqh
operator|->
name|inactivesqtd
operator|=
name|setup
expr_stmt|;
name|ehci_free_sqtd
argument_list|(
name|sc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|bad2
label|:
name|ehci_free_sqtd
argument_list|(
name|sc
argument_list|,
name|newinactive
argument_list|)
expr_stmt|;
name|bad1
label|:
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"ehci_device_request: no memory\n"
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|err
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
undef|#
directive|undef
name|exfer
block|}
end_function

begin_comment
comment|/************************/
end_comment

begin_function
specifier|static
name|usbd_status
name|ehci_device_bulk_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Pipe isn't running, start first */
return|return
operator|(
name|ehci_device_bulk_start
argument_list|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|ehci_device_bulk_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
define|#
directive|define
name|exfer
value|EXFER(xfer)
name|struct
name|ehci_pipe
modifier|*
name|epipe
init|=
operator|(
expr|struct
name|ehci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|epipe
operator|->
name|pipe
operator|.
name|device
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|ehci_soft_qtd_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|dataend
decl_stmt|,
modifier|*
name|newinactive
decl_stmt|;
name|ehci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|len
decl_stmt|,
name|isread
decl_stmt|,
name|endpt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_device_bulk_start: xfer=%p len=%d flags=%d\n"
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|length
operator|,
name|xfer
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
condition|)
name|panic
argument_list|(
literal|"ehci_device_bulk_start: a request"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|xfer
operator|->
name|length
expr_stmt|;
name|endpt
operator|=
name|epipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
name|isread
operator|=
name|UE_GET_DIR
argument_list|(
name|endpt
argument_list|)
operator|==
name|UE_DIR_IN
expr_stmt|;
name|sqh
operator|=
name|epipe
operator|->
name|sqh
expr_stmt|;
name|epipe
operator|->
name|u
operator|.
name|bulk
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|newinactive
operator|=
name|ehci_alloc_sqtd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|newinactive
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"ehci_device_bulk_start: no sqtd memory\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|err
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|newinactive
operator|->
name|qtd
operator|.
name|qtd_status
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|newinactive
operator|->
name|qtd
operator|.
name|qtd_next
operator|=
name|EHCI_NULL
expr_stmt|;
name|newinactive
operator|->
name|qtd
operator|.
name|qtd_altnext
operator|=
name|EHCI_NULL
expr_stmt|;
name|err
operator|=
name|ehci_alloc_sqtd_chain
argument_list|(
name|epipe
argument_list|,
name|sc
argument_list|,
name|len
argument_list|,
name|isread
argument_list|,
name|xfer
argument_list|,
name|sqh
operator|->
name|inactivesqtd
argument_list|,
name|newinactive
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|dataend
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"ehci_device_bulk_start: no memory\n"
operator|)
argument_list|)
expr_stmt|;
name|ehci_free_sqtd
argument_list|(
name|sc
argument_list|,
name|newinactive
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|err
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|dataend
operator|->
name|nextqtd
operator|=
name|newinactive
expr_stmt|;
name|dataend
operator|->
name|qtd
operator|.
name|qtd_next
operator|=
name|htole32
argument_list|(
name|newinactive
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|dataend
operator|->
name|qtd
operator|.
name|qtd_altnext
operator|=
name|htole32
argument_list|(
name|newinactive
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|inactivesqtd
operator|=
name|newinactive
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|5
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_device_bulk_start: data(1)\n"
operator|)
argument_list|)
expr_stmt|;
name|ehci_dump_sqh
argument_list|(
name|sqh
argument_list|)
expr_stmt|;
name|ehci_dump_sqtds
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Set up interrupt info. */
name|exfer
operator|->
name|sqtdstart
operator|=
name|data
expr_stmt|;
name|exfer
operator|->
name|sqtdend
operator|=
name|dataend
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|exfer
operator|->
name|isdone
condition|)
block|{
name|printf
argument_list|(
literal|"ehci_device_bulk_start: not done, ex=%p\n"
argument_list|,
name|exfer
argument_list|)
expr_stmt|;
block|}
name|exfer
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ehci_activate_qh
argument_list|(
name|sqh
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|&&
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|MS_TO_TICKS
argument_list|(
name|xfer
operator|->
name|timeout
argument_list|)
argument_list|,
name|ehci_timeout
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
name|ehci_add_intr_list
argument_list|(
name|sc
argument_list|,
name|exfer
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_device_bulk_start: data(2)\n"
operator|)
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_device_bulk_start: data(3)\n"
operator|)
argument_list|)
expr_stmt|;
name|ehci_dump_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("async_head:\n"); 		ehci_dump_sqh(sc->sc_async_head);
endif|#
directive|endif
name|printf
argument_list|(
literal|"sqh:\n"
argument_list|)
expr_stmt|;
name|ehci_dump_sqh
argument_list|(
name|sqh
argument_list|)
expr_stmt|;
name|ehci_dump_sqtds
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
name|ehci_waitintr
argument_list|(
name|sc
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
undef|#
directive|undef
name|exfer
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_bulk_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_device_bulk_abort: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
name|ehci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close a device bulk pipe.  */
end_comment

begin_function
specifier|static
name|void
name|ehci_device_bulk_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_device_bulk_close: pipe=%p\n"
operator|,
name|pipe
operator|)
argument_list|)
expr_stmt|;
name|ehci_close_pipe
argument_list|(
name|pipe
argument_list|,
name|sc
operator|->
name|sc_async_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ehci_device_bulk_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|struct
name|ehci_xfer
modifier|*
name|ex
init|=
name|EXFER
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|xfer
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|struct
name|ehci_pipe
modifier|*
name|epipe
init|=
operator|(
expr|struct
name|ehci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ehci_bulk_done: xfer=%p, actlen=%d\n"
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|status
operator|!=
name|USBD_NOMEM
operator|&&
name|ehci_active_intr_list
argument_list|(
name|ex
argument_list|)
condition|)
block|{
name|ehci_del_intr_list
argument_list|(
name|ex
argument_list|)
expr_stmt|;
comment|/* remove from active list */
name|ehci_free_sqtd_chain
argument_list|(
name|sc
argument_list|,
name|epipe
operator|->
name|sqh
argument_list|,
name|ex
operator|->
name|sqtdstart
argument_list|,
name|ex
operator|->
name|sqtdend
operator|->
name|nextqtd
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ehci_bulk_done: length=%d\n"
operator|,
name|xfer
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************/
end_comment

begin_function
specifier|static
name|usbd_status
name|ehci_device_setintr
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|ehci_soft_qh_t
modifier|*
name|sqh
parameter_list|,
name|int
name|ival
parameter_list|)
block|{
name|struct
name|ehci_soft_islot
modifier|*
name|isp
decl_stmt|;
name|int
name|islot
decl_stmt|,
name|lev
decl_stmt|;
comment|/* Find a poll rate that is large enough. */
for|for
control|(
name|lev
operator|=
name|EHCI_IPOLLRATES
operator|-
literal|1
init|;
name|lev
operator|>
literal|0
condition|;
name|lev
operator|--
control|)
if|if
condition|(
name|EHCI_ILEV_IVAL
argument_list|(
name|lev
argument_list|)
operator|<=
name|ival
condition|)
break|break;
comment|/* Pick an interrupt slot at the right level. */
comment|/* XXX could do better than picking at random. */
name|islot
operator|=
name|EHCI_IQHIDX
argument_list|(
name|lev
argument_list|,
name|arc4random
argument_list|()
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|islot
operator|=
name|islot
expr_stmt|;
name|isp
operator|=
operator|&
name|sc
operator|->
name|sc_islots
index|[
name|islot
index|]
expr_stmt|;
name|ehci_add_qh
argument_list|(
name|sqh
argument_list|,
name|isp
operator|->
name|sqh
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usbd_status
name|ehci_device_intr_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
comment|/* Insert last in queue. */
name|err
operator|=
name|usb_insert_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Pipe isn't running (otherwise err would be USBD_INPROG), 	 * so start it first. 	 */
return|return
operator|(
name|ehci_device_intr_start
argument_list|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|xfer
operator|->
name|pipe
operator|->
name|queue
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usbd_status
name|ehci_device_intr_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
define|#
directive|define
name|exfer
value|EXFER(xfer)
name|struct
name|ehci_pipe
modifier|*
name|epipe
init|=
operator|(
expr|struct
name|ehci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|xfer
operator|->
name|pipe
operator|->
name|device
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|dev
operator|->
name|bus
decl_stmt|;
name|ehci_soft_qtd_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|dataend
decl_stmt|,
modifier|*
name|newinactive
decl_stmt|;
name|ehci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|len
decl_stmt|,
name|isread
decl_stmt|,
name|endpt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ehci_device_intr_start: xfer=%p len=%d flags=%d\n"
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|length
operator|,
name|xfer
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|xfer
operator|->
name|rqflags
operator|&
name|URQ_REQUEST
condition|)
name|panic
argument_list|(
literal|"ehci_device_intr_start: a request"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|xfer
operator|->
name|length
expr_stmt|;
name|endpt
operator|=
name|epipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
name|isread
operator|=
name|UE_GET_DIR
argument_list|(
name|endpt
argument_list|)
operator|==
name|UE_DIR_IN
expr_stmt|;
name|sqh
operator|=
name|epipe
operator|->
name|sqh
expr_stmt|;
name|epipe
operator|->
name|u
operator|.
name|intr
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|newinactive
operator|=
name|ehci_alloc_sqtd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|newinactive
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"ehci_device_intr_start: no sqtd memory\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|err
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|newinactive
operator|->
name|qtd
operator|.
name|qtd_status
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|newinactive
operator|->
name|qtd
operator|.
name|qtd_next
operator|=
name|EHCI_NULL
expr_stmt|;
name|newinactive
operator|->
name|qtd
operator|.
name|qtd_altnext
operator|=
name|EHCI_NULL
expr_stmt|;
name|err
operator|=
name|ehci_alloc_sqtd_chain
argument_list|(
name|epipe
argument_list|,
name|sc
argument_list|,
name|len
argument_list|,
name|isread
argument_list|,
name|xfer
argument_list|,
name|sqh
operator|->
name|inactivesqtd
argument_list|,
name|newinactive
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|dataend
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"ehci_device_intr_start: no memory\n"
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|err
expr_stmt|;
name|usb_transfer_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|dataend
operator|->
name|nextqtd
operator|=
name|newinactive
expr_stmt|;
name|dataend
operator|->
name|qtd
operator|.
name|qtd_next
operator|=
name|htole32
argument_list|(
name|newinactive
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|dataend
operator|->
name|qtd
operator|.
name|qtd_altnext
operator|=
name|htole32
argument_list|(
name|newinactive
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|inactivesqtd
operator|=
name|newinactive
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|5
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_device_intr_start: data(1)\n"
operator|)
argument_list|)
expr_stmt|;
name|ehci_dump_sqh
argument_list|(
name|sqh
argument_list|)
expr_stmt|;
name|ehci_dump_sqtds
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Set up interrupt info. */
name|exfer
operator|->
name|sqtdstart
operator|=
name|data
expr_stmt|;
name|exfer
operator|->
name|sqtdend
operator|=
name|dataend
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|exfer
operator|->
name|isdone
condition|)
block|{
name|printf
argument_list|(
literal|"ehci_device_intr_start: not done, ex=%p\n"
argument_list|,
name|exfer
argument_list|)
expr_stmt|;
block|}
name|exfer
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ehci_activate_qh
argument_list|(
name|sqh
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|&&
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|MS_TO_TICKS
argument_list|(
name|xfer
operator|->
name|timeout
argument_list|)
argument_list|,
name|ehci_timeout
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
name|ehci_add_intr_list
argument_list|(
name|sc
argument_list|,
name|exfer
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHCI_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_device_intr_start: data(2)\n"
operator|)
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ehci_device_intr_start: data(3)\n"
operator|)
argument_list|)
expr_stmt|;
name|ehci_dump_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sqh:\n"
argument_list|)
expr_stmt|;
name|ehci_dump_sqh
argument_list|(
name|sqh
argument_list|)
expr_stmt|;
name|ehci_dump_sqtds
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
name|ehci_waitintr
argument_list|(
name|sc
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
undef|#
directive|undef
name|exfer
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_intr_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ehci_device_intr_abort: xfer=%p\n"
operator|,
name|xfer
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|==
name|xfer
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ehci_device_intr_abort: remove\n"
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|pipe
operator|->
name|intrxfer
operator|=
name|NULL
expr_stmt|;
block|}
name|ehci_abort_xfer
argument_list|(
name|xfer
argument_list|,
name|USBD_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_intr_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|struct
name|ehci_pipe
modifier|*
name|epipe
init|=
operator|(
expr|struct
name|ehci_pipe
operator|*
operator|)
name|pipe
decl_stmt|;
name|struct
name|ehci_soft_islot
modifier|*
name|isp
decl_stmt|;
name|isp
operator|=
operator|&
name|sc
operator|->
name|sc_islots
index|[
name|epipe
operator|->
name|sqh
operator|->
name|islot
index|]
expr_stmt|;
name|ehci_close_pipe
argument_list|(
name|pipe
argument_list|,
name|isp
operator|->
name|sqh
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_intr_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
define|#
directive|define
name|exfer
value|EXFER(xfer)
name|struct
name|ehci_xfer
modifier|*
name|ex
init|=
name|EXFER
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|(
name|ehci_softc_t
operator|*
operator|)
name|xfer
operator|->
name|pipe
operator|->
name|device
operator|->
name|bus
decl_stmt|;
name|struct
name|ehci_pipe
modifier|*
name|epipe
init|=
operator|(
expr|struct
name|ehci_pipe
operator|*
operator|)
name|xfer
operator|->
name|pipe
decl_stmt|;
name|ehci_soft_qtd_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|dataend
decl_stmt|,
modifier|*
name|newinactive
decl_stmt|;
name|ehci_soft_qh_t
modifier|*
name|sqh
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|len
decl_stmt|,
name|isread
decl_stmt|,
name|endpt
decl_stmt|,
name|s
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ehci_device_intr_done: xfer=%p, actlen=%d\n"
operator|,
name|xfer
operator|,
name|xfer
operator|->
name|actlen
operator|)
argument_list|)
expr_stmt|;
name|sqh
operator|=
name|epipe
operator|->
name|sqh
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|pipe
operator|->
name|repeat
condition|)
block|{
name|ehci_free_sqtd_chain
argument_list|(
name|sc
argument_list|,
name|sqh
argument_list|,
name|ex
operator|->
name|sqtdstart
argument_list|,
name|ex
operator|->
name|sqtdend
operator|->
name|nextqtd
argument_list|)
expr_stmt|;
name|len
operator|=
name|epipe
operator|->
name|u
operator|.
name|intr
operator|.
name|length
expr_stmt|;
name|xfer
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|endpt
operator|=
name|epipe
operator|->
name|pipe
operator|.
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
name|isread
operator|=
name|UE_GET_DIR
argument_list|(
name|endpt
argument_list|)
operator|==
name|UE_DIR_IN
expr_stmt|;
name|newinactive
operator|=
name|ehci_alloc_sqtd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|newinactive
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"ehci_device_intr_done: no sqtd memory\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|USBD_NOMEM
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|err
expr_stmt|;
return|return;
block|}
name|newinactive
operator|->
name|qtd
operator|.
name|qtd_status
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|newinactive
operator|->
name|qtd
operator|.
name|qtd_next
operator|=
name|EHCI_NULL
expr_stmt|;
name|newinactive
operator|->
name|qtd
operator|.
name|qtd_altnext
operator|=
name|EHCI_NULL
expr_stmt|;
name|err
operator|=
name|ehci_alloc_sqtd_chain
argument_list|(
name|epipe
argument_list|,
name|sc
argument_list|,
name|len
argument_list|,
name|isread
argument_list|,
name|xfer
argument_list|,
name|sqh
operator|->
name|inactivesqtd
argument_list|,
name|newinactive
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|dataend
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"ehci_device_intr_done: no memory\n"
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|err
expr_stmt|;
return|return;
block|}
name|dataend
operator|->
name|nextqtd
operator|=
name|newinactive
expr_stmt|;
name|dataend
operator|->
name|qtd
operator|.
name|qtd_next
operator|=
name|htole32
argument_list|(
name|newinactive
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|dataend
operator|->
name|qtd
operator|.
name|qtd_altnext
operator|=
name|htole32
argument_list|(
name|newinactive
operator|->
name|physaddr
argument_list|)
expr_stmt|;
name|sqh
operator|->
name|inactivesqtd
operator|=
name|newinactive
expr_stmt|;
comment|/* Set up interrupt info. */
name|exfer
operator|->
name|sqtdstart
operator|=
name|data
expr_stmt|;
name|exfer
operator|->
name|sqtdend
operator|=
name|dataend
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|exfer
operator|->
name|isdone
condition|)
block|{
name|printf
argument_list|(
literal|"ehci_device_intr_done: not done, ex=%p\n"
argument_list|,
name|exfer
argument_list|)
expr_stmt|;
block|}
name|exfer
operator|->
name|isdone
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ehci_activate_qh
argument_list|(
name|sqh
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|&&
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|use_polling
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|MS_TO_TICKS
argument_list|(
name|xfer
operator|->
name|timeout
argument_list|)
argument_list|,
name|ehci_timeout
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|status
operator|=
name|USBD_IN_PROGRESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfer
operator|->
name|status
operator|!=
name|USBD_NOMEM
operator|&&
name|ehci_active_intr_list
argument_list|(
name|ex
argument_list|)
condition|)
block|{
name|ehci_del_intr_list
argument_list|(
name|ex
argument_list|)
expr_stmt|;
comment|/* remove from active list */
name|ehci_free_sqtd_chain
argument_list|(
name|sc
argument_list|,
name|sqh
argument_list|,
name|ex
operator|->
name|sqtdstart
argument_list|,
name|ex
operator|->
name|sqtdend
operator|->
name|nextqtd
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|exfer
block|}
end_function

begin_comment
comment|/************************/
end_comment

begin_function
specifier|static
name|usbd_status
name|ehci_device_isoc_transfer
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
return|return
name|USBD_IOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|usbd_status
name|ehci_device_isoc_start
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{
return|return
name|USBD_IOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_isoc_abort
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|ehci_device_isoc_close
parameter_list|(
name|usbd_pipe_handle
name|pipe
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|ehci_device_isoc_done
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|)
block|{ }
end_function

end_unit

