begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Sam Leffler, Errno Consulting  * Copyright (c) 2008-2009 Weongyo Jeong<weongyo@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_comment
comment|/*  * This driver is distantly derived from a driver of the same name  * by Damien Bergamini.  The original copyright is included below:  *  * Copyright (c) 2006  *	Damien Bergamini<damien.bergamini@free.fr>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Driver for Atheros AR5523 USB parts.  *  * The driver requires firmware to be loaded into the device.  This  * is done on device discovery from a user application (uathload)  * that is launched by devd when a device with suitable product ID  * is recognized.  Once firmware has been loaded the device will  * reset the USB port and re-attach with the original product ID+1  * and this driver will be attached.  The firmware is licensed for  * general use (royalty free) and may be incorporated in products.  * Note that the firmware normally packaged with the NDIS drivers  * for these devices does not work in this way and so does not work  * with this driver.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_radiotap.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_include
include|#
directive|include
file|<dev/usb/wlan/if_uathreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/wlan/if_uathvar.h>
end_include

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|uath
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB Atheros"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|uath_countrycode
init|=
name|CTRY_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* country code */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_uath
argument_list|,
name|OID_AUTO
argument_list|,
name|countrycode
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uath_countrycode
argument_list|,
literal|0
argument_list|,
literal|"country code"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.uath.countrycode"
argument_list|,
operator|&
name|uath_countrycode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|uath_regdomain
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* regulatory domain */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_uath
argument_list|,
name|OID_AUTO
argument_list|,
name|regdomain
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|uath_regdomain
argument_list|,
literal|0
argument_list|,
literal|"regulatory domain"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UATH_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|uath_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_uath
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uath_debug
argument_list|,
literal|0
argument_list|,
literal|"uath debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.uath.debug"
argument_list|,
operator|&
name|uath_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|UATH_DEBUG_XMIT
init|=
literal|0x00000001
block|,
comment|/* basic xmit operation */
name|UATH_DEBUG_XMIT_DUMP
init|=
literal|0x00000002
block|,
comment|/* xmit dump */
name|UATH_DEBUG_RECV
init|=
literal|0x00000004
block|,
comment|/* basic recv operation */
name|UATH_DEBUG_TX_PROC
init|=
literal|0x00000008
block|,
comment|/* tx ISR proc */
name|UATH_DEBUG_RX_PROC
init|=
literal|0x00000010
block|,
comment|/* rx ISR proc */
name|UATH_DEBUG_RECV_ALL
init|=
literal|0x00000020
block|,
comment|/* trace all frames (beacons) */
name|UATH_DEBUG_INIT
init|=
literal|0x00000040
block|,
comment|/* initialization of dev */
name|UATH_DEBUG_DEVCAP
init|=
literal|0x00000080
block|,
comment|/* dev caps */
name|UATH_DEBUG_CMDS
init|=
literal|0x00000100
block|,
comment|/* commands */
name|UATH_DEBUG_CMDS_DUMP
init|=
literal|0x00000200
block|,
comment|/* command buffer dump */
name|UATH_DEBUG_RESET
init|=
literal|0x00000400
block|,
comment|/* reset processing */
name|UATH_DEBUG_STATE
init|=
literal|0x00000800
block|,
comment|/* 802.11 state transitions */
name|UATH_DEBUG_MULTICAST
init|=
literal|0x00001000
block|,
comment|/* multicast */
name|UATH_DEBUG_WME
init|=
literal|0x00002000
block|,
comment|/* WME */
name|UATH_DEBUG_CHANNEL
init|=
literal|0x00004000
block|,
comment|/* channel */
name|UATH_DEBUG_RATES
init|=
literal|0x00008000
block|,
comment|/* rates */
name|UATH_DEBUG_CRYPTO
init|=
literal|0x00010000
block|,
comment|/* crypto */
name|UATH_DEBUG_LED
init|=
literal|0x00020000
block|,
comment|/* LED */
name|UATH_DEBUG_ANY
init|=
literal|0xffffffff
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	if (sc->sc_debug& (m))					\ 		printf(fmt, __VA_ARGS__);			\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	(void) sc;						\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unaligned little endian access */
end_comment

begin_define
define|#
directive|define
name|LE_READ_2
parameter_list|(
name|p
parameter_list|)
define|\
value|((u_int16_t)							\ 	 ((((u_int8_t *)(p))[0]      ) | (((u_int8_t *)(p))[1]<<  8)))
end_define

begin_define
define|#
directive|define
name|LE_READ_4
parameter_list|(
name|p
parameter_list|)
define|\
value|((u_int32_t)							\ 	 ((((u_int8_t *)(p))[0]      ) | (((u_int8_t *)(p))[1]<<  8) |	\ 	  (((u_int8_t *)(p))[2]<< 16) | (((u_int8_t *)(p))[3]<< 24)))
end_define

begin_comment
comment|/* recognized device vendors/products */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_device_id
name|uath_devs
index|[]
init|=
block|{
define|#
directive|define
name|UATH_DEV
parameter_list|(
name|v
parameter_list|,
name|p
parameter_list|)
value|{ USB_VP(USB_VENDOR_##v, USB_PRODUCT_##v##_##p) }
name|UATH_DEV
argument_list|(
name|ACCTON
argument_list|,
name|SMCWUSBG
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|ACCTON
argument_list|,
name|SMCWUSBTG2
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|ATHEROS
argument_list|,
name|AR5523
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|ATHEROS2
argument_list|,
name|AR5523_1
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|ATHEROS2
argument_list|,
name|AR5523_2
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|ATHEROS2
argument_list|,
name|AR5523_3
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|CONCEPTRONIC
argument_list|,
name|AR5523_1
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|CONCEPTRONIC
argument_list|,
name|AR5523_2
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|DLINK
argument_list|,
name|DWLAG122
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|DLINK
argument_list|,
name|DWLAG132
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|DLINK
argument_list|,
name|DWLG132
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|DLINK2
argument_list|,
name|DWA120
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|GIGASET
argument_list|,
name|AR5523
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|GIGASET
argument_list|,
name|SMCWUSBTG
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|GLOBALSUN
argument_list|,
name|AR5523_1
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|GLOBALSUN
argument_list|,
name|AR5523_2
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|NETGEAR
argument_list|,
name|WG111U
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|NETGEAR3
argument_list|,
name|WG111T
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|NETGEAR3
argument_list|,
name|WPN111
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|UMEDIA
argument_list|,
name|TEW444UBEU
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|UMEDIA
argument_list|,
name|AR5523_2
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|WISTRONNEWEB
argument_list|,
name|AR5523_1
argument_list|)
block|,
name|UATH_DEV
argument_list|(
name|WISTRONNEWEB
argument_list|,
name|AR5523_2
argument_list|)
block|,
name|UATH_DEV
argument_list|(
argument|ZCOM
argument_list|,
argument|AR5523
argument_list|)
undef|#
directive|undef
name|UATH_DEV
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|uath_intr_rx_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|uath_intr_tx_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|uath_bulk_rx_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|uath_bulk_tx_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|uath_usbconfig
index|[
name|UATH_N_XFERS
index|]
init|=
block|{
index|[
name|UATH_INTR_RX
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
literal|0x1
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
name|UATH_MAX_CMDSZ
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|}
block|,
operator|.
name|callback
operator|=
name|uath_intr_rx_callback
block|}
block|,
index|[
name|UATH_INTR_TX
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
literal|0x1
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
name|UATH_MAX_CMDSZ
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|ext_buffer
operator|=
literal|1
block|,
operator|.
name|force_short_xfer
operator|=
literal|1
block|,
operator|.
name|pipe_bof
operator|=
literal|1
block|, 		}
block|,
operator|.
name|callback
operator|=
name|uath_intr_tx_callback
block|,
operator|.
name|timeout
operator|=
name|UATH_CMD_TIMEOUT
block|}
block|,
index|[
name|UATH_BULK_RX
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
literal|0x2
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
name|MCLBYTES
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|ext_buffer
operator|=
literal|1
block|,
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|}
block|,
operator|.
name|callback
operator|=
name|uath_bulk_rx_callback
block|}
block|,
index|[
name|UATH_BULK_TX
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
literal|0x2
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
name|UATH_MAX_TXBUFSZ
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|ext_buffer
operator|=
literal|1
block|,
operator|.
name|force_short_xfer
operator|=
literal|1
block|,
operator|.
name|pipe_bof
operator|=
literal|1
block|}
block|,
operator|.
name|callback
operator|=
name|uath_bulk_tx_callback
block|,
operator|.
name|timeout
operator|=
name|UATH_DATA_TIMEOUT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|uath_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_alloc_cmd_list
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
name|struct
name|uath_cmd
type|[]
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_free_cmd_list
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
name|struct
name|uath_cmd
type|[]
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_host_available
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_get_capability
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_get_devcap
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|uath_cmd
modifier|*
name|uath_get_cmdbuf
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_cmd_read
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_cmd_write
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_stat
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|UATH_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|uath_dump_cmd
parameter_list|(
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|uath_codename
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|uath_get_devstatus
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_get_status
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_alloc_rx_data_list
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_alloc_tx_data_list
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_free_rx_data_list
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_free_tx_data_list
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_init_locked
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_stop_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_update_promisc
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_config
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_config_multi
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_switch_channel
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_set_rxfilter
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_watchdog
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_abort_xfers
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_dataflush
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_cmdflush
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_flush
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_set_ledstate
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_set_chan
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_reset_tx_queues
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_wme_init
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|uath_data
modifier|*
name|uath_getbuf
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_set_key
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uath_set_keys
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uath_sysctl_node
parameter_list|(
name|struct
name|uath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|uath_match
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bConfigIndex
operator|!=
name|UATH_CONFIG_INDEX
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
operator|!=
name|UATH_IFACE_INDEX
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|usbd_lookup_id_by_uaa
argument_list|(
name|uath_devs
argument_list|,
sizeof|sizeof
argument_list|(
name|uath_devs
argument_list|)
argument_list|,
name|uaa
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint8_t
name|bands
decl_stmt|,
name|iface_index
init|=
name|UATH_IFACE_INDEX
decl_stmt|;
comment|/* XXX */
name|usb_error_t
name|error
decl_stmt|;
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
ifdef|#
directive|ifdef
name|UATH_DEBUG
name|sc
operator|->
name|sc_debug
operator|=
name|uath_debug
expr_stmt|;
endif|#
directive|endif
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Only post-firmware devices here. 	 */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate xfers for firmware commands. 	 */
name|error
operator|=
name|uath_alloc_cmd_list
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cmd
argument_list|,
name|UATH_CMD_LIST_COUNT
argument_list|,
name|UATH_MAX_CMDSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate Tx command list\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|iface_index
argument_list|,
name|sc
operator|->
name|sc_xfer
argument_list|,
name|uath_usbconfig
argument_list|,
name|UATH_N_XFERS
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate USB transfers, "
literal|"err=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* 	 * We're now ready to send+receive firmware commands. 	 */
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|uath_host_available
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not initialize adapter\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|error
operator|=
name|uath_get_devcap
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not get device capabilities\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Create device sysctl node. */
name|uath_sysctl_node
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_IEEE80211
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can not allocate ifnet\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|uath_get_devstatus
argument_list|(
name|sc
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not get device status\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail4
goto|;
block|}
comment|/* 	 * Allocate xfers for Rx/Tx data pipes. 	 */
name|error
operator|=
name|uath_alloc_rx_data_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate Rx data list\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail4
goto|;
block|}
name|error
operator|=
name|uath_alloc_tx_data_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate Tx data list\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail4
goto|;
block|}
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"uath"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|uath_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|uath_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|uath_start
expr_stmt|;
comment|/* XXX UATH_TX_DATA_LIST_COUNT */
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|IFQ_MAXLEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
name|ic
operator|->
name|ic_ifp
operator|=
name|ifp
expr_stmt|;
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
comment|/* not only, but not used */
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
comment|/* default to BSS mode */
comment|/* set device capabilities */
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
operator||
comment|/* station mode */
name|IEEE80211_C_MONITOR
operator||
comment|/* monitor mode supported */
name|IEEE80211_C_TXPMGT
operator||
comment|/* tx power management */
name|IEEE80211_C_SHPREAMBLE
operator||
comment|/* short preamble supported */
name|IEEE80211_C_SHSLOT
operator||
comment|/* short slot time supported */
name|IEEE80211_C_WPA
operator||
comment|/* 802.11i */
name|IEEE80211_C_BGSCAN
operator||
comment|/* capable of bg scanning */
name|IEEE80211_C_TXFRAG
expr_stmt|;
comment|/* handle tx frags */
comment|/* put a regulatory domain to reveal informations.  */
name|uath_regdomain
operator|=
name|sc
operator|->
name|sc_devcap
operator|.
name|regDomain
expr_stmt|;
name|bands
operator|=
literal|0
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|bands
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|bands
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_devcap
operator|.
name|analog5GhzRevision
operator|&
literal|0xf0
operator|)
operator|==
literal|0x30
condition|)
name|setbit
argument_list|(
operator|&
name|bands
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
comment|/* XXX turbo */
name|ieee80211_init_channels
argument_list|(
name|ic
argument_list|,
name|NULL
argument_list|,
operator|&
name|bands
argument_list|)
expr_stmt|;
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|uath_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|uath_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|uath_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|uath_set_channel
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|uath_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|uath_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_update_mcast
operator|=
name|uath_update_mcast
expr_stmt|;
name|ic
operator|->
name|ic_update_promisc
operator|=
name|uath_update_promisc
expr_stmt|;
name|ieee80211_radiotap_attach
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_txtap
argument_list|)
argument_list|,
name|UATH_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rxtap
argument_list|)
argument_list|,
name|UATH_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail4
label|:
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|fail3
label|:
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fail2
label|:
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|UATH_N_XFERS
argument_list|)
expr_stmt|;
name|fail1
label|:
name|uath_free_cmd_list
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cmd
argument_list|,
name|UATH_CMD_LIST_COUNT
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|UATH_FLAG_INVALID
expr_stmt|;
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_ifdetach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|uath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_ch
argument_list|)
expr_stmt|;
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|UATH_N_XFERS
argument_list|)
expr_stmt|;
comment|/* free buffers */
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|uath_free_rx_data_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|uath_free_tx_data_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|uath_free_cmd_list
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cmd
argument_list|,
name|UATH_CMD_LIST_COUNT
argument_list|)
expr_stmt|;
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_free_cmd_list
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|uath_cmd
name|cmds
index|[]
parameter_list|,
name|int
name|ncmd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncmd
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cmds
index|[
name|i
index|]
operator|.
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cmds
index|[
name|i
index|]
operator|.
name|buf
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_alloc_cmd_list
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|uath_cmd
name|cmds
index|[]
parameter_list|,
name|int
name|ncmd
parameter_list|,
name|int
name|maxsz
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_active
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_pending
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_waiting
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_inactive
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncmd
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|uath_cmd
modifier|*
name|cmd
init|=
operator|&
name|cmds
index|[
name|i
index|]
decl_stmt|;
name|cmd
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
comment|/* backpointer for callbacks */
name|cmd
operator|->
name|msgid
operator|=
name|i
expr_stmt|;
name|cmd
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|maxsz
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate xfer buffer\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_inactive
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_cmd_inactive
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|uath_free_cmd_list
argument_list|(
name|sc
argument_list|,
name|cmds
argument_list|,
name|ncmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_host_available
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uath_cmd_host_available
name|setup
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* inform target the host is available */
name|setup
operator|.
name|sw_ver_major
operator|=
name|htobe32
argument_list|(
name|ATH_SW_VER_MAJOR
argument_list|)
expr_stmt|;
name|setup
operator|.
name|sw_ver_minor
operator|=
name|htobe32
argument_list|(
name|ATH_SW_VER_MINOR
argument_list|)
expr_stmt|;
name|setup
operator|.
name|sw_ver_patch
operator|=
name|htobe32
argument_list|(
name|ATH_SW_VER_PATCH
argument_list|)
expr_stmt|;
name|setup
operator|.
name|sw_ver_build
operator|=
name|htobe32
argument_list|(
name|ATH_SW_VER_BUILD
argument_list|)
expr_stmt|;
return|return
name|uath_cmd_read
argument_list|(
name|sc
argument_list|,
name|WDCMSG_HOST_AVAILABLE
argument_list|,
operator|&
name|setup
argument_list|,
sizeof|sizeof
name|setup
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UATH_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|uath_dump_cmd
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|char
name|prefix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sep
init|=
literal|""
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s%c "
argument_list|,
name|sep
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|"\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|%
literal|4
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|uath_codename
parameter_list|(
name|int
name|code
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
specifier|static
specifier|const
name|char
modifier|*
name|names
index|[]
init|=
block|{
literal|"0x00"
block|,
literal|"HOST_AVAILABLE"
block|,
literal|"BIND"
block|,
literal|"TARGET_RESET"
block|,
literal|"TARGET_GET_CAPABILITY"
block|,
literal|"TARGET_SET_CONFIG"
block|,
literal|"TARGET_GET_STATUS"
block|,
literal|"TARGET_GET_STATS"
block|,
literal|"TARGET_START"
block|,
literal|"TARGET_STOP"
block|,
literal|"TARGET_ENABLE"
block|,
literal|"TARGET_DISABLE"
block|,
literal|"CREATE_CONNECTION"
block|,
literal|"UPDATE_CONNECT_ATTR"
block|,
literal|"DELETE_CONNECT"
block|,
literal|"SEND"
block|,
literal|"FLUSH"
block|,
literal|"STATS_UPDATE"
block|,
literal|"BMISS"
block|,
literal|"DEVICE_AVAIL"
block|,
literal|"SEND_COMPLETE"
block|,
literal|"DATA_AVAIL"
block|,
literal|"SET_PWR_MODE"
block|,
literal|"BMISS_ACK"
block|,
literal|"SET_LED_STEADY"
block|,
literal|"SET_LED_BLINK"
block|,
literal|"SETUP_BEACON_DESC"
block|,
literal|"BEACON_INIT"
block|,
literal|"RESET_KEY_CACHE"
block|,
literal|"RESET_KEY_CACHE_ENTRY"
block|,
literal|"SET_KEY_CACHE_ENTRY"
block|,
literal|"SET_DECOMP_MASK"
block|,
literal|"SET_REGULATORY_DOMAIN"
block|,
literal|"SET_LED_STATE"
block|,
literal|"WRITE_ASSOCID"
block|,
literal|"SET_STA_BEACON_TIMERS"
block|,
literal|"GET_TSF"
block|,
literal|"RESET_TSF"
block|,
literal|"SET_ADHOC_MODE"
block|,
literal|"SET_BASIC_RATE"
block|,
literal|"MIB_CONTROL"
block|,
literal|"GET_CHANNEL_DATA"
block|,
literal|"GET_CUR_RSSI"
block|,
literal|"SET_ANTENNA_SWITCH"
block|,
literal|"0x2c"
block|,
literal|"0x2d"
block|,
literal|"0x2e"
block|,
literal|"USE_SHORT_SLOT_TIME"
block|,
literal|"SET_POWER_MODE"
block|,
literal|"SETUP_PSPOLL_DESC"
block|,
literal|"SET_RX_MULTICAST_FILTER"
block|,
literal|"RX_FILTER"
block|,
literal|"PER_CALIBRATION"
block|,
literal|"RESET"
block|,
literal|"DISABLE"
block|,
literal|"PHY_DISABLE"
block|,
literal|"SET_TX_POWER_LIMIT"
block|,
literal|"SET_TX_QUEUE_PARAMS"
block|,
literal|"SETUP_TX_QUEUE"
block|,
literal|"RELEASE_TX_QUEUE"
block|, 	}
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|code
operator|<
name|N
argument_list|(
name|names
argument_list|)
condition|)
return|return
name|names
index|[
name|code
index|]
return|;
if|if
condition|(
name|code
operator|==
name|WDCMSG_SET_DEFAULT_KEY
condition|)
return|return
literal|"SET_DEFAULT_KEY"
return|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"0x%02x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Low-level function to send read or write commands to the firmware.  */
end_comment

begin_function
specifier|static
name|int
name|uath_cmdsend
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|code
parameter_list|,
specifier|const
name|void
modifier|*
name|idata
parameter_list|,
name|int
name|ilen
parameter_list|,
name|void
modifier|*
name|odata
parameter_list|,
name|int
name|olen
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|uath_cmd_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|uath_cmd
modifier|*
name|cmd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* grab a xfer */
name|cmd
operator|=
name|uath_get_cmdbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: empty inactive queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|cmd
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
comment|/* always bulk-out a multiple of 4 bytes */
name|cmd
operator|->
name|buflen
operator|=
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uath_cmd_hdr
argument_list|)
operator|+
name|ilen
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|uath_cmd_hdr
operator|*
operator|)
name|cmd
operator|->
name|buf
expr_stmt|;
name|bzero
argument_list|(
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uath_cmd_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX not needed */
name|hdr
operator|->
name|len
operator|=
name|htobe32
argument_list|(
name|cmd
operator|->
name|buflen
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|code
operator|=
name|htobe32
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|msgid
operator|=
name|cmd
operator|->
name|msgid
expr_stmt|;
comment|/* don't care about endianness */
name|hdr
operator|->
name|magic
operator|=
name|htobe32
argument_list|(
operator|(
name|cmd
operator|->
name|flags
operator|&
name|UATH_CMD_FLAG_MAGIC
operator|)
condition|?
literal|1
operator|<<
literal|24
else|:
literal|0
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|idata
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|UATH_DEBUG_CMDS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: send  %s [flags 0x%x] olen %d\n"
argument_list|,
name|__func__
argument_list|,
name|uath_codename
argument_list|(
name|code
argument_list|)
argument_list|,
name|cmd
operator|->
name|flags
argument_list|,
name|olen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|UATH_DEBUG_CMDS_DUMP
condition|)
name|uath_dump_cmd
argument_list|(
name|cmd
operator|->
name|buf
argument_list|,
name|cmd
operator|->
name|buflen
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cmd
operator|->
name|odata
operator|=
name|odata
expr_stmt|;
name|KASSERT
argument_list|(
name|odata
operator|==
name|NULL
operator|||
name|olen
operator|<
name|UATH_MAX_CMDSZ
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
literal|"odata %p olen %u"
operator|,
name|odata
operator|,
name|olen
operator|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|olen
operator|=
name|olen
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_pending
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_cmd_pending
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UATH_INTR_TX
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|UATH_CMD_FLAG_READ
condition|)
block|{
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UATH_INTR_RX
index|]
argument_list|)
expr_stmt|;
comment|/* wait at most two seconds for command reply */
name|error
operator|=
name|mtx_sleep
argument_list|(
name|cmd
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"uathcmd"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|odata
operator|=
name|NULL
expr_stmt|;
comment|/* in case reply comes too late */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for reply "
literal|"to cmd 0x%x (%u)\n"
argument_list|,
name|code
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|->
name|olen
operator|!=
name|olen
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unexpected reply data count "
literal|"to cmd 0x%x (%u), got %u, expected %u\n"
argument_list|,
name|code
argument_list|,
name|code
argument_list|,
name|cmd
operator|->
name|olen
argument_list|,
name|olen
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_cmd_read
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|code
parameter_list|,
specifier|const
name|void
modifier|*
name|idata
parameter_list|,
name|int
name|ilen
parameter_list|,
name|void
modifier|*
name|odata
parameter_list|,
name|int
name|olen
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|flags
operator||=
name|UATH_CMD_FLAG_READ
expr_stmt|;
return|return
name|uath_cmdsend
argument_list|(
name|sc
argument_list|,
name|code
argument_list|,
name|idata
argument_list|,
name|ilen
argument_list|,
name|odata
argument_list|,
name|olen
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_cmd_write
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|code
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|flags
operator|&=
operator|~
name|UATH_CMD_FLAG_READ
expr_stmt|;
return|return
name|uath_cmdsend
argument_list|(
name|sc
argument_list|,
name|code
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|uath_cmd
modifier|*
name|uath_get_cmdbuf
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uath_cmd
modifier|*
name|uc
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|uc
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_inactive
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_inactive
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_DEC
argument_list|(
name|sc
argument_list|,
name|st_cmd_inactive
argument_list|)
expr_stmt|;
block|}
else|else
name|uc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|uc
operator|==
name|NULL
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_XMIT
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|__func__
argument_list|,
literal|"out of command xmit buffers"
argument_list|)
expr_stmt|;
return|return
operator|(
name|uc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called periodically (every second) when associated to  * query device statistics.  */
end_comment

begin_function
specifier|static
name|void
name|uath_stat
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Send request for statistics asynchronously. The timer will be 	 * restarted when we'll get the stats notification. 	 */
name|error
operator|=
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_TARGET_GET_STATS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|UATH_CMD_FLAG_ASYNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not query stats, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_get_capability
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|cap
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|cap
operator|=
name|htobe32
argument_list|(
name|cap
argument_list|)
expr_stmt|;
name|error
operator|=
name|uath_cmd_read
argument_list|(
name|sc
argument_list|,
name|WDCMSG_TARGET_GET_CAPABILITY
argument_list|,
operator|&
name|cap
argument_list|,
sizeof|sizeof
name|cap
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|UATH_CMD_FLAG_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not read capability %u\n"
argument_list|,
name|be32toh
argument_list|(
name|cap
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|val
operator|=
name|be32toh
argument_list|(
operator|*
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_get_devcap
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|GETCAP
parameter_list|(
name|x
parameter_list|,
name|v
parameter_list|)
value|do {				\ 	error = uath_get_capability(sc, x,&v);		\ 	if (error != 0)					\ 		return (error);				\ 	DPRINTF(sc, UATH_DEBUG_DEVCAP,			\ 	    "%s: %s=0x%08x\n", __func__, #x, v);	\ } while (0)
name|struct
name|uath_devcap
modifier|*
name|cap
init|=
operator|&
name|sc
operator|->
name|sc_devcap
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* collect device capabilities */
name|GETCAP
argument_list|(
name|CAP_TARGET_VERSION
argument_list|,
name|cap
operator|->
name|targetVersion
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_TARGET_REVISION
argument_list|,
name|cap
operator|->
name|targetRevision
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_MAC_VERSION
argument_list|,
name|cap
operator|->
name|macVersion
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_MAC_REVISION
argument_list|,
name|cap
operator|->
name|macRevision
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_PHY_REVISION
argument_list|,
name|cap
operator|->
name|phyRevision
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_ANALOG_5GHz_REVISION
argument_list|,
name|cap
operator|->
name|analog5GhzRevision
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_ANALOG_2GHz_REVISION
argument_list|,
name|cap
operator|->
name|analog2GhzRevision
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_REG_DOMAIN
argument_list|,
name|cap
operator|->
name|regDomain
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_REG_CAP_BITS
argument_list|,
name|cap
operator|->
name|regCapBits
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* NB: not supported in rev 1.5 */
block|GETCAP(CAP_COUNTRY_CODE, cap->countryCode);
endif|#
directive|endif
name|GETCAP
argument_list|(
name|CAP_WIRELESS_MODES
argument_list|,
name|cap
operator|->
name|wirelessModes
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_CHAN_SPREAD_SUPPORT
argument_list|,
name|cap
operator|->
name|chanSpreadSupport
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_COMPRESS_SUPPORT
argument_list|,
name|cap
operator|->
name|compressSupport
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_BURST_SUPPORT
argument_list|,
name|cap
operator|->
name|burstSupport
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_FAST_FRAMES_SUPPORT
argument_list|,
name|cap
operator|->
name|fastFramesSupport
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_CHAP_TUNING_SUPPORT
argument_list|,
name|cap
operator|->
name|chapTuningSupport
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_TURBOG_SUPPORT
argument_list|,
name|cap
operator|->
name|turboGSupport
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_TURBO_PRIME_SUPPORT
argument_list|,
name|cap
operator|->
name|turboPrimeSupport
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_DEVICE_TYPE
argument_list|,
name|cap
operator|->
name|deviceType
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_WME_SUPPORT
argument_list|,
name|cap
operator|->
name|wmeSupport
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_TOTAL_QUEUES
argument_list|,
name|cap
operator|->
name|numTxQueues
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_CONNECTION_ID_MAX
argument_list|,
name|cap
operator|->
name|connectionIdMax
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_LOW_5GHZ_CHAN
argument_list|,
name|cap
operator|->
name|low5GhzChan
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_HIGH_5GHZ_CHAN
argument_list|,
name|cap
operator|->
name|high5GhzChan
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_LOW_2GHZ_CHAN
argument_list|,
name|cap
operator|->
name|low2GhzChan
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_HIGH_2GHZ_CHAN
argument_list|,
name|cap
operator|->
name|high2GhzChan
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_TWICE_ANTENNAGAIN_5G
argument_list|,
name|cap
operator|->
name|twiceAntennaGain5G
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_TWICE_ANTENNAGAIN_2G
argument_list|,
name|cap
operator|->
name|twiceAntennaGain2G
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_CIPHER_AES_CCM
argument_list|,
name|cap
operator|->
name|supportCipherAES_CCM
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_CIPHER_TKIP
argument_list|,
name|cap
operator|->
name|supportCipherTKIP
argument_list|)
expr_stmt|;
name|GETCAP
argument_list|(
name|CAP_MIC_TKIP
argument_list|,
name|cap
operator|->
name|supportMicTKIP
argument_list|)
expr_stmt|;
name|cap
operator|->
name|supportCipherWEP
operator|=
literal|1
expr_stmt|;
comment|/* NB: always available */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_get_devstatus
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* retrieve MAC address */
name|error
operator|=
name|uath_get_status
argument_list|(
name|sc
argument_list|,
name|ST_MAC_ADDR
argument_list|,
name|macaddr
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not read MAC address\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|uath_get_status
argument_list|(
name|sc
argument_list|,
name|ST_SERIAL_NUMBER
argument_list|,
operator|&
name|sc
operator|->
name|sc_serial
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_serial
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not read device serial number\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_get_status
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|which
parameter_list|,
name|void
modifier|*
name|odata
parameter_list|,
name|int
name|olen
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|which
operator|=
name|htobe32
argument_list|(
name|which
argument_list|)
expr_stmt|;
name|error
operator|=
name|uath_cmd_read
argument_list|(
name|sc
argument_list|,
name|WDCMSG_TARGET_GET_STATUS
argument_list|,
operator|&
name|which
argument_list|,
sizeof|sizeof
argument_list|(
name|which
argument_list|)
argument_list|,
name|odata
argument_list|,
name|olen
argument_list|,
name|UATH_CMD_FLAG_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not read EEPROM offset 0x%02x\n"
argument_list|,
name|be32toh
argument_list|(
name|which
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_free_data_list
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|uath_data
name|data
index|[]
parameter_list|,
name|int
name|ndata
parameter_list|,
name|int
name|fillmbuf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndata
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|uath_data
modifier|*
name|dp
init|=
operator|&
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|fillmbuf
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|dp
operator|->
name|m
argument_list|)
expr_stmt|;
name|dp
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|dp
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dp
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dp
operator|->
name|buf
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
name|dp
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|UATH_DEBUG
if|if
condition|(
name|dp
operator|->
name|ni
operator|!=
name|NULL
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Node isn't NULL\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|uath_alloc_data_list
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|uath_data
name|data
index|[]
parameter_list|,
name|int
name|ndata
parameter_list|,
name|int
name|maxsz
parameter_list|,
name|int
name|fillmbuf
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndata
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|uath_data
modifier|*
name|dp
init|=
operator|&
name|data
index|[
name|i
index|]
decl_stmt|;
name|dp
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|fillmbuf
condition|)
block|{
comment|/* XXX check maxsz */
name|dp
operator|->
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate rx mbuf\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|dp
operator|->
name|buf
operator|=
name|mtod
argument_list|(
name|dp
operator|->
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|dp
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|maxsz
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate buffer\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|dp
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|uath_free_data_list
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
name|ndata
argument_list|,
name|fillmbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_alloc_rx_data_list
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* XXX is it enough to store the RX packet with MCLBYTES bytes?  */
name|error
operator|=
name|uath_alloc_data_list
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rx
argument_list|,
name|UATH_RX_DATA_LIST_COUNT
argument_list|,
name|MCLBYTES
argument_list|,
literal|1
comment|/* setup mbufs */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_active
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_inactive
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UATH_RX_DATA_LIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_inactive
argument_list|,
operator|&
name|sc
operator|->
name|sc_rx
index|[
name|i
index|]
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_rx_inactive
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_alloc_tx_data_list
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|uath_alloc_data_list
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_tx
argument_list|,
name|UATH_TX_DATA_LIST_COUNT
argument_list|,
name|UATH_MAX_TXBUFSZ
argument_list|,
literal|0
comment|/* no mbufs */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_active
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_pending
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UATH_TX_DATA_LIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx
index|[
name|i
index|]
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_inactive
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_free_rx_data_list
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_active
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_inactive
argument_list|)
expr_stmt|;
name|uath_free_data_list
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rx
argument_list|,
name|UATH_RX_DATA_LIST_COUNT
argument_list|,
literal|1
comment|/* free mbufs */
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_free_tx_data_list
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_active
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_pending
argument_list|)
expr_stmt|;
name|uath_free_data_list
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_tx
argument_list|,
name|UATH_TX_DATA_LIST_COUNT
argument_list|,
literal|0
comment|/* no mbufs */
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|uath_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|uath_vap
modifier|*
name|uvp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
condition|)
comment|/* only one at a time */
return|return
operator|(
name|NULL
operator|)
return|;
name|uvp
operator|=
operator|(
expr|struct
name|uath_vap
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uath_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|uvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vap
operator|=
operator|&
name|uvp
operator|->
name|vap
expr_stmt|;
comment|/* enable s/w bmiss handling for sta mode */
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
operator||
name|IEEE80211_CLONE_NOBEACONS
argument_list|,
name|bssid
argument_list|,
name|mac
argument_list|)
expr_stmt|;
comment|/* override state transition machine */
name|uvp
operator|->
name|newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|uath_newstate
expr_stmt|;
comment|/* complete setup */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|ieee80211_media_change
argument_list|,
name|ieee80211_media_status
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
return|return
operator|(
name|vap
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|uath_vap
modifier|*
name|uvp
init|=
name|UATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uvp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_init_locked
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|uath_stop_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* reset variables */
name|sc
operator|->
name|sc_intrx_nextnum
operator|=
name|sc
operator|->
name|sc_msgid
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_BIND
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set MAC address */
name|uath_config_multi
argument_list|(
name|sc
argument_list|,
name|CFG_MAC_ADDR
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* XXX honor net80211 state */
name|uath_config
argument_list|(
name|sc
argument_list|,
name|CFG_RATE_CONTROL_ENABLE
argument_list|,
literal|0x00000001
argument_list|)
expr_stmt|;
name|uath_config
argument_list|(
name|sc
argument_list|,
name|CFG_DIVERSITY_CTL
argument_list|,
literal|0x00000001
argument_list|)
expr_stmt|;
name|uath_config
argument_list|(
name|sc
argument_list|,
name|CFG_ABOLT
argument_list|,
literal|0x0000003f
argument_list|)
expr_stmt|;
name|uath_config
argument_list|(
name|sc
argument_list|,
name|CFG_WME_ENABLED
argument_list|,
literal|0x00000001
argument_list|)
expr_stmt|;
name|uath_config
argument_list|(
name|sc
argument_list|,
name|CFG_SERVICE_TYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|uath_config
argument_list|(
name|sc
argument_list|,
name|CFG_TP_SCALE
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|uath_config
argument_list|(
name|sc
argument_list|,
name|CFG_TPC_HALF_DBM5
argument_list|,
literal|0x0000003c
argument_list|)
expr_stmt|;
name|uath_config
argument_list|(
name|sc
argument_list|,
name|CFG_TPC_HALF_DBM2
argument_list|,
literal|0x0000003c
argument_list|)
expr_stmt|;
name|uath_config
argument_list|(
name|sc
argument_list|,
name|CFG_OVERRD_TX_POWER
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|uath_config
argument_list|(
name|sc
argument_list|,
name|CFG_GMODE_PROTECTION
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|uath_config
argument_list|(
name|sc
argument_list|,
name|CFG_GMODE_PROTECT_RATE_INDEX
argument_list|,
literal|0x00000003
argument_list|)
expr_stmt|;
name|uath_config
argument_list|(
name|sc
argument_list|,
name|CFG_PROTECTION_TYPE
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|uath_config
argument_list|(
name|sc
argument_list|,
name|CFG_MODE_CTS
argument_list|,
literal|0x00000002
argument_list|)
expr_stmt|;
name|error
operator|=
name|uath_cmd_read
argument_list|(
name|sc
argument_list|,
name|WDCMSG_TARGET_START
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
name|UATH_CMD_FLAG_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not start target, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_INIT
argument_list|,
literal|"%s returns handle: 0x%x\n"
argument_list|,
name|uath_codename
argument_list|(
name|WDCMSG_TARGET_START
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set default channel */
name|error
operator|=
name|uath_switch_channel
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not switch channel, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|val
operator|=
name|htobe32
argument_list|(
name|TARGET_DEVICE_AWAKE
argument_list|)
expr_stmt|;
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_SET_PWR_MODE
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX? check */
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_RESET_KEY_CACHE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UATH_BULK_RX
index|]
argument_list|)
expr_stmt|;
comment|/* enable Rx */
name|uath_set_rxfilter
argument_list|(
name|sc
argument_list|,
literal|0x0
argument_list|,
name|UATH_FILTER_OP_INIT
argument_list|)
expr_stmt|;
name|uath_set_rxfilter
argument_list|(
name|sc
argument_list|,
name|UATH_FILTER_RX_UCAST
operator||
name|UATH_FILTER_RX_MCAST
operator||
name|UATH_FILTER_RX_BCAST
operator||
name|UATH_FILTER_RX_BEACON
argument_list|,
name|UATH_FILTER_OP_SET
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|UATH_FLAG_INITDONE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_ch
argument_list|,
name|hz
argument_list|,
name|uath_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|uath_stop_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|uath_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_stop_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|UATH_FLAG_INITDONE
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
comment|/* abort pending transmits  */
name|uath_abort_xfers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* flush data& control requests into the target  */
operator|(
name|void
operator|)
name|uath_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set a LED status to the disconnected.  */
name|uath_set_ledstate
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* stop the target  */
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_TARGET_STOP
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|uath_stop_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_config
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|struct
name|uath_write_mac
name|write
decl_stmt|;
name|int
name|error
decl_stmt|;
name|write
operator|.
name|reg
operator|=
name|htobe32
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|write
operator|.
name|len
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 0 = single write */
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|write
operator|.
name|data
operator|=
name|htobe32
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|error
operator|=
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_TARGET_SET_CONFIG
argument_list|,
operator|&
name|write
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not write register 0x%02x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_config_multi
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|uath_write_mac
name|write
decl_stmt|;
name|int
name|error
decl_stmt|;
name|write
operator|.
name|reg
operator|=
name|htobe32
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|write
operator|.
name|len
operator|=
name|htobe32
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|write
operator|.
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* properly handle the case where len is zero (reset) */
name|error
operator|=
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_TARGET_SET_CONFIG
argument_list|,
operator|&
name|write
argument_list|,
operator|(
name|len
operator|==
literal|0
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
else|:
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not write %d bytes to register 0x%02x\n"
argument_list|,
name|len
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_switch_channel
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set radio frequency */
name|error
operator|=
name|uath_set_chan
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not set channel, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* reset Tx rings */
name|error
operator|=
name|uath_reset_tx_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not reset Tx queues, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* set Tx rings WME properties */
name|error
operator|=
name|uath_wme_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not init Tx queues, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|error
operator|=
name|uath_set_ledstate
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not set led state, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|error
operator|=
name|uath_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not flush pipes, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|failed
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_set_rxfilter
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|bits
parameter_list|,
name|uint32_t
name|op
parameter_list|)
block|{
name|struct
name|uath_cmd_rx_filter
name|rxfilter
decl_stmt|;
name|rxfilter
operator|.
name|bits
operator|=
name|htobe32
argument_list|(
name|bits
argument_list|)
expr_stmt|;
name|rxfilter
operator|.
name|op
operator|=
name|htobe32
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_RECV
operator||
name|UATH_DEBUG_RECV_ALL
argument_list|,
literal|"setting Rx filter=0x%x flags=0x%x\n"
argument_list|,
name|bits
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_RX_FILTER
argument_list|,
operator|&
name|rxfilter
argument_list|,
sizeof|sizeof
name|rxfilter
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tx_timer
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_tx_timer
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
comment|/*uath_init(ifp); XXX needs a process context! */
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_ch
argument_list|,
name|hz
argument_list|,
name|uath_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uath_abort_xfers
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* abort any pending transfers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UATH_N_XFERS
condition|;
name|i
operator|++
control|)
name|usbd_transfer_stop
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_flush
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|uath_dataflush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|failed
goto|;
name|error
operator|=
name|uath_cmdflush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|failed
goto|;
name|failed
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_cmdflush
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_FLUSH
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_dataflush
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uath_data
modifier|*
name|data
decl_stmt|;
name|struct
name|uath_chunk
modifier|*
name|chunk
decl_stmt|;
name|struct
name|uath_tx_desc
modifier|*
name|desc
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|data
operator|=
name|uath_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|data
operator|->
name|buflen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uath_chunk
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|uath_tx_desc
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
name|chunk
operator|=
operator|(
expr|struct
name|uath_chunk
operator|*
operator|)
name|data
operator|->
name|buf
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|uath_tx_desc
operator|*
operator|)
operator|(
name|chunk
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* one chunk only */
name|chunk
operator|->
name|seqnum
operator|=
literal|0
expr_stmt|;
name|chunk
operator|->
name|flags
operator|=
name|UATH_CFLAGS_FINAL
expr_stmt|;
name|chunk
operator|->
name|length
operator|=
name|htobe16
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uath_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uath_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|msglen
operator|=
name|htobe32
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uath_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|msgid
operator|=
operator|(
name|sc
operator|->
name|sc_msgid
operator|++
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* don't care about endianness */
name|desc
operator|->
name|type
operator|=
name|htobe32
argument_list|(
name|WDCMSG_FLUSH
argument_list|)
expr_stmt|;
name|desc
operator|->
name|txqid
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|desc
operator|->
name|connid
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|desc
operator|->
name|flags
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|UATH_DEBUG_CMDS
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_RESET
argument_list|,
literal|"send flush ix %d\n"
argument_list|,
name|desc
operator|->
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|UATH_DEBUG_CMDS_DUMP
condition|)
name|uath_dump_cmd
argument_list|(
name|data
operator|->
name|buf
argument_list|,
name|data
operator|->
name|buflen
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_pending
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_pending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UATH_BULK_TX
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|uath_data
modifier|*
name|_uath_getbuf
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uath_data
modifier|*
name|bf
decl_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_DEC
argument_list|(
name|sc
argument_list|,
name|st_tx_inactive
argument_list|)
expr_stmt|;
block|}
else|else
name|bf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_XMIT
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|__func__
argument_list|,
literal|"out of xmit buffers"
argument_list|)
expr_stmt|;
return|return
operator|(
name|bf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|uath_data
modifier|*
name|uath_getbuf
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uath_data
modifier|*
name|bf
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bf
operator|=
name|_uath_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_XMIT
argument_list|,
literal|"%s: stop queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
return|return
operator|(
name|bf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_set_ledstate
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|connected
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_LED
argument_list|,
literal|"set led state %sconnected\n"
argument_list|,
name|connected
condition|?
literal|""
else|:
literal|"!"
argument_list|)
expr_stmt|;
name|connected
operator|=
name|htobe32
argument_list|(
name|connected
argument_list|)
expr_stmt|;
return|return
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_SET_LED_STATE
argument_list|,
operator|&
name|connected
argument_list|,
sizeof|sizeof
name|connected
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_set_chan
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|UATH_DEBUG
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
endif|#
directive|endif
name|struct
name|uath_cmd_reset
name|reset
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|reset
argument_list|,
sizeof|sizeof
name|reset
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|c
argument_list|)
condition|)
name|reset
operator|.
name|flags
operator||=
name|htobe32
argument_list|(
name|UATH_CHAN_2GHZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|)
name|reset
operator|.
name|flags
operator||=
name|htobe32
argument_list|(
name|UATH_CHAN_5GHZ
argument_list|)
expr_stmt|;
comment|/* NB: 11g =>'s 11b so don't specify both OFDM and CCK */
if|if
condition|(
name|IEEE80211_IS_CHAN_OFDM
argument_list|(
name|c
argument_list|)
condition|)
name|reset
operator|.
name|flags
operator||=
name|htobe32
argument_list|(
name|UATH_CHAN_OFDM
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|c
argument_list|)
condition|)
name|reset
operator|.
name|flags
operator||=
name|htobe32
argument_list|(
name|UATH_CHAN_CCK
argument_list|)
expr_stmt|;
comment|/* turbo can be used in either 2GHz or 5GHz */
if|if
condition|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_TURBO
condition|)
name|reset
operator|.
name|flags
operator||=
name|htobe32
argument_list|(
name|UATH_CHAN_TURBO
argument_list|)
expr_stmt|;
name|reset
operator|.
name|freq
operator|=
name|htobe32
argument_list|(
name|c
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|reset
operator|.
name|maxrdpower
operator|=
name|htobe32
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* XXX */
name|reset
operator|.
name|channelchange
operator|=
name|htobe32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|reset
operator|.
name|keeprccontent
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_CHANNEL
argument_list|,
literal|"set channel %d, flags 0x%x freq %u\n"
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|reset
operator|.
name|flags
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|reset
operator|.
name|freq
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_RESET
argument_list|,
operator|&
name|reset
argument_list|,
sizeof|sizeof
name|reset
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_reset_tx_queues
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ac
decl_stmt|,
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_RESET
argument_list|,
literal|"%s: reset Tx queues\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|ac
operator|=
literal|0
init|;
name|ac
operator|<
literal|4
condition|;
name|ac
operator|++
control|)
block|{
specifier|const
name|uint32_t
name|qid
init|=
name|htobe32
argument_list|(
name|ac
argument_list|)
decl_stmt|;
name|error
operator|=
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_RELEASE_TX_QUEUE
argument_list|,
operator|&
name|qid
argument_list|,
sizeof|sizeof
name|qid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_wme_init
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* XXX get from net80211 */
specifier|static
specifier|const
name|struct
name|uath_wme_settings
name|uath_wme_11g
index|[
literal|4
index|]
init|=
block|{
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Background */
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Best-Effort */
block|{
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|26
block|,
literal|0
block|}
block|,
comment|/* Video */
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
comment|/* Voice */
block|}
decl_stmt|;
name|struct
name|uath_cmd_txq_setup
name|qinfo
decl_stmt|;
name|int
name|ac
decl_stmt|,
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_WME
argument_list|,
literal|"%s: setup Tx queues\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|ac
operator|=
literal|0
init|;
name|ac
operator|<
literal|4
condition|;
name|ac
operator|++
control|)
block|{
name|qinfo
operator|.
name|qid
operator|=
name|htobe32
argument_list|(
name|ac
argument_list|)
expr_stmt|;
name|qinfo
operator|.
name|len
operator|=
name|htobe32
argument_list|(
sizeof|sizeof
argument_list|(
name|qinfo
operator|.
name|attr
argument_list|)
argument_list|)
expr_stmt|;
name|qinfo
operator|.
name|attr
operator|.
name|priority
operator|=
name|htobe32
argument_list|(
name|ac
argument_list|)
expr_stmt|;
comment|/* XXX */
name|qinfo
operator|.
name|attr
operator|.
name|aifs
operator|=
name|htobe32
argument_list|(
name|uath_wme_11g
index|[
name|ac
index|]
operator|.
name|aifsn
argument_list|)
expr_stmt|;
name|qinfo
operator|.
name|attr
operator|.
name|logcwmin
operator|=
name|htobe32
argument_list|(
name|uath_wme_11g
index|[
name|ac
index|]
operator|.
name|logcwmin
argument_list|)
expr_stmt|;
name|qinfo
operator|.
name|attr
operator|.
name|logcwmax
operator|=
name|htobe32
argument_list|(
name|uath_wme_11g
index|[
name|ac
index|]
operator|.
name|logcwmax
argument_list|)
expr_stmt|;
name|qinfo
operator|.
name|attr
operator|.
name|bursttime
operator|=
name|htobe32
argument_list|(
name|UATH_TXOP_TO_US
argument_list|(
name|uath_wme_11g
index|[
name|ac
index|]
operator|.
name|txop
argument_list|)
argument_list|)
expr_stmt|;
name|qinfo
operator|.
name|attr
operator|.
name|mode
operator|=
name|htobe32
argument_list|(
name|uath_wme_11g
index|[
name|ac
index|]
operator|.
name|acm
argument_list|)
expr_stmt|;
comment|/*XXX? */
name|qinfo
operator|.
name|attr
operator|.
name|qflags
operator|=
name|htobe32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX? */
name|error
operator|=
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_SETUP_TX_QUEUE
argument_list|,
operator|&
name|qinfo
argument_list|,
sizeof|sizeof
name|qinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|startall
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|uath_init
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
name|startall
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|uath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|startall
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|ic
operator|->
name|ic_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFADDR
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_tx_start
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|uath_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|uath_chunk
modifier|*
name|chunk
decl_stmt|;
name|struct
name|uath_tx_desc
modifier|*
name|desc
decl_stmt|;
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
decl_stmt|;
name|int
name|framelen
decl_stmt|,
name|msglen
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|ni
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|m0
expr_stmt|;
name|chunk
operator|=
operator|(
expr|struct
name|uath_chunk
operator|*
operator|)
name|data
operator|->
name|buf
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|uath_tx_desc
operator|*
operator|)
operator|(
name|chunk
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|struct
name|uath_tx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_txtap
decl_stmt|;
name|tap
operator|->
name|wt_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_FRAG
condition|)
name|tap
operator|->
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_FRAG
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
condition|)
block|{
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* packet header may have moved, reset our local pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
block|}
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|framelen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|IEEE80211_CRC_LEN
expr_stmt|;
name|msglen
operator|=
name|framelen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|uath_tx_desc
argument_list|)
expr_stmt|;
name|data
operator|->
name|buflen
operator|=
name|msglen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|uath_chunk
argument_list|)
expr_stmt|;
comment|/* one chunk only for now */
name|chunk
operator|->
name|seqnum
operator|=
name|sc
operator|->
name|sc_seqnum
operator|++
expr_stmt|;
name|chunk
operator|->
name|flags
operator|=
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_FRAG
operator|)
condition|?
literal|0
else|:
name|UATH_CFLAGS_FINAL
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_LASTFRAG
condition|)
name|chunk
operator|->
name|flags
operator||=
name|UATH_CFLAGS_FINAL
expr_stmt|;
name|chunk
operator|->
name|flags
operator|=
name|UATH_CFLAGS_FINAL
expr_stmt|;
name|chunk
operator|->
name|length
operator|=
name|htobe16
argument_list|(
name|msglen
argument_list|)
expr_stmt|;
comment|/* fill Tx descriptor */
name|desc
operator|->
name|msglen
operator|=
name|htobe32
argument_list|(
name|msglen
argument_list|)
expr_stmt|;
comment|/* NB: to get UATH_TX_NOTIFY reply, `msgid' must be larger than 0  */
name|desc
operator|->
name|msgid
operator|=
operator|(
name|sc
operator|->
name|sc_msgid
operator|++
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* don't care about endianness */
name|desc
operator|->
name|type
operator|=
name|htobe32
argument_list|(
name|WDCMSG_SEND
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
comment|/* NB: force all management frames to highest queue */
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
condition|)
block|{
comment|/* NB: force all management frames to highest queue */
name|desc
operator|->
name|txqid
operator|=
name|htobe32
argument_list|(
name|WME_AC_VO
operator||
name|UATH_TXQID_MINRATE
argument_list|)
expr_stmt|;
block|}
else|else
name|desc
operator|->
name|txqid
operator|=
name|htobe32
argument_list|(
name|WME_AC_BE
operator||
name|UATH_TXQID_MINRATE
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
comment|/* XXX multicast frames should honor mcastrate */
name|desc
operator|->
name|txqid
operator|=
name|htobe32
argument_list|(
name|M_WME_GETAC
argument_list|(
name|m0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"bogus frame type 0x%x (%s)\n"
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_AUTH
operator|||
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_ASSOC
operator|||
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
name|desc
operator|->
name|connid
operator|=
name|htobe32
argument_list|(
name|UATH_ID_BSS
argument_list|)
expr_stmt|;
else|else
name|desc
operator|->
name|connid
operator|=
name|htobe32
argument_list|(
name|UATH_ID_INVALID
argument_list|)
expr_stmt|;
name|desc
operator|->
name|flags
operator|=
name|htobe32
argument_list|(
literal|0
comment|/* no UATH_TX_NOTIFY */
argument_list|)
expr_stmt|;
name|desc
operator|->
name|buflen
operator|=
name|htobe32
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UATH_DEBUG
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_XMIT
argument_list|,
literal|"send frame ix %u framelen %d msglen %d connid 0x%x txqid 0x%x\n"
argument_list|,
name|desc
operator|->
name|msgid
argument_list|,
name|framelen
argument_list|,
name|msglen
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|connid
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|txqid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|UATH_DEBUG_XMIT_DUMP
condition|)
name|uath_dump_cmd
argument_list|(
name|data
operator|->
name|buf
argument_list|,
name|data
operator|->
name|buflen
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_pending
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_pending
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UATH_BULK_TX
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup driver resources when we run out of buffers while processing  * fragments; return the tx buffers allocated and drop node references.  */
end_comment

begin_function
specifier|static
name|void
name|uath_txfrag_cleanup
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|uath_datahead
modifier|*
name|frags
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|uath_data
modifier|*
name|bf
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|bf
argument_list|,
argument|frags
argument_list|,
argument|next
argument_list|,
argument|next
argument_list|)
block|{
comment|/* NB: bf assumed clean */
name|STAILQ_REMOVE_HEAD
argument_list|(
name|frags
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|bf
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_inactive
argument_list|)
expr_stmt|;
name|ieee80211_node_decref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup xmit of a fragmented frame.  Allocate a buffer for each frag and bump  * the node reference count to reflect the held reference to be setup by  * uath_tx_start.  */
end_comment

begin_function
specifier|static
name|int
name|uath_txfrag_setup
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|uath_datahead
modifier|*
name|frags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|uath_data
modifier|*
name|bf
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
operator|->
name|m_nextpkt
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextpkt
control|)
block|{
name|bf
operator|=
name|uath_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* out of buffers, cleanup */
name|uath_txfrag_cleanup
argument_list|(
name|sc
argument_list|,
name|frags
argument_list|,
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
name|ieee80211_node_incref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|frags
argument_list|,
name|bf
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|STAILQ_EMPTY
argument_list|(
name|frags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim mbuf resources.  For fragmented frames we need to claim each frag  * chained with m_nextpkt.  */
end_comment

begin_function
specifier|static
name|void
name|uath_freetx
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
do|do
block|{
name|next
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|m
operator|=
name|next
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|uath_data
modifier|*
name|bf
decl_stmt|;
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|uath_datahead
name|frags
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|UATH_FLAG_INVALID
operator|)
condition|)
return|return;
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bf
operator|=
name|uath_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
break|break;
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|bf
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_inactive
argument_list|)
expr_stmt|;
break|break;
block|}
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Check for fragmentation.  If this frame has been broken up 		 * verify we have enough buffers to send all the fragments 		 * so all go out or none... 		 */
name|STAILQ_INIT
argument_list|(
operator|&
name|frags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_FRAG
operator|)
operator|&&
operator|!
name|uath_txfrag_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|frags
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_XMIT
argument_list|,
literal|"%s: out of txfrag buffers\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|uath_freetx
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_seqnum
operator|=
literal|0
expr_stmt|;
name|nextfrag
label|:
comment|/* 		 * Pass the frame to the h/w for transmission. 		 * Fragmented frames have each frag chained together 		 * with m_nextpkt.  We know there are sufficient uath_data's 		 * to send all the frags because of work done by 		 * uath_txfrag_setup. 		 */
name|next
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|uath_tx_start
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bad
label|:
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|reclaim
label|:
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|bf
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_inactive
argument_list|)
expr_stmt|;
name|uath_txfrag_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|frags
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Beware of state changing between frags. 			 XXX check sta power-save state? 			*/
if|if
condition|(
name|ni
operator|->
name|ni_vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_XMIT
argument_list|,
literal|"%s: flush fragmented packet, state %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ni
operator|->
name|ni_vap
operator|->
name|iv_state
index|]
argument_list|)
expr_stmt|;
name|uath_freetx
argument_list|(
name|next
argument_list|)
expr_stmt|;
goto|goto
name|reclaim
goto|;
block|}
name|m
operator|=
name|next
expr_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|frags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no buf for txfrag"
operator|)
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|frags
argument_list|,
name|next
argument_list|)
expr_stmt|;
goto|goto
name|nextfrag
goto|;
block|}
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
block|}
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|uath_data
modifier|*
name|bf
decl_stmt|;
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* prevent management frames from being sent if we're not ready */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|UATH_FLAG_INVALID
operator|)
operator|||
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* grab a TX buffer  */
name|bf
operator|=
name|uath_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|sc
operator|->
name|sc_seqnum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uath_tx_start
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|bf
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_inactive
argument_list|)
expr_stmt|;
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
comment|/* do nothing  */
block|}
end_function

begin_function
specifier|static
name|void
name|uath_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
comment|/* do nothing  */
block|}
end_function

begin_function
specifier|static
name|void
name|uath_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|UATH_FLAG_INVALID
operator|)
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|uath_switch_channel
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_set_rxmulti_filter
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* XXX broken */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|UATH_FLAG_INVALID
operator|)
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * this is for avoiding the race condition when we're try to 	 * connect to the AP with WPA. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UATH_FLAG_INITDONE
condition|)
operator|(
name|void
operator|)
name|uath_set_rxmulti_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_update_promisc
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|UATH_FLAG_INVALID
operator|)
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UATH_FLAG_INITDONE
condition|)
block|{
name|uath_set_rxfilter
argument_list|(
name|sc
argument_list|,
name|UATH_FILTER_RX_UCAST
operator||
name|UATH_FILTER_RX_MCAST
operator||
name|UATH_FILTER_RX_BCAST
operator||
name|UATH_FILTER_RX_BEACON
operator||
name|UATH_FILTER_RX_PROM
argument_list|,
name|UATH_FILTER_OP_SET
argument_list|)
expr_stmt|;
block|}
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_create_connection
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|connid
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|uath_cmd_create_connection
name|create
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|create
argument_list|,
sizeof|sizeof
name|create
argument_list|)
expr_stmt|;
name|create
operator|.
name|connid
operator|=
name|htobe32
argument_list|(
name|connid
argument_list|)
expr_stmt|;
name|create
operator|.
name|bssid
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX packed or not?  */
name|create
operator|.
name|size
operator|=
name|htobe32
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uath_cmd_rateset
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|=
operator|&
name|ni
operator|->
name|ni_rates
expr_stmt|;
name|create
operator|.
name|connattr
operator|.
name|rateset
operator|.
name|length
operator|=
name|rs
operator|->
name|rs_nrates
expr_stmt|;
name|bcopy
argument_list|(
name|rs
operator|->
name|rs_rates
argument_list|,
operator|&
name|create
operator|.
name|connattr
operator|.
name|rateset
operator|.
name|set
index|[
literal|0
index|]
argument_list|,
name|rs
operator|->
name|rs_nrates
argument_list|)
expr_stmt|;
comment|/* XXX turbo */
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|create
operator|.
name|connattr
operator|.
name|wlanmode
operator|=
name|htobe32
argument_list|(
name|WLAN_MODE_11a
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|create
operator|.
name|connattr
operator|.
name|wlanmode
operator|=
name|htobe32
argument_list|(
name|WLAN_MODE_11g
argument_list|)
expr_stmt|;
else|else
name|create
operator|.
name|connattr
operator|.
name|wlanmode
operator|=
name|htobe32
argument_list|(
name|WLAN_MODE_11b
argument_list|)
expr_stmt|;
return|return
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_CREATE_CONNECTION
argument_list|,
operator|&
name|create
argument_list|,
sizeof|sizeof
name|create
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_set_rates
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
name|struct
name|uath_cmd_rates
name|rates
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|rates
argument_list|,
sizeof|sizeof
name|rates
argument_list|)
expr_stmt|;
name|rates
operator|.
name|connid
operator|=
name|htobe32
argument_list|(
name|UATH_ID_BSS
argument_list|)
expr_stmt|;
comment|/* XXX */
name|rates
operator|.
name|size
operator|=
name|htobe32
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uath_cmd_rateset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX bounds check rs->rs_nrates */
name|rates
operator|.
name|rateset
operator|.
name|length
operator|=
name|rs
operator|->
name|rs_nrates
expr_stmt|;
name|bcopy
argument_list|(
name|rs
operator|->
name|rs_rates
argument_list|,
operator|&
name|rates
operator|.
name|rateset
operator|.
name|set
index|[
literal|0
index|]
argument_list|,
name|rs
operator|->
name|rs_nrates
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_RATES
argument_list|,
literal|"setting supported rates nrates=%d\n"
argument_list|,
name|rs
operator|->
name|rs_nrates
argument_list|)
expr_stmt|;
return|return
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_SET_BASIC_RATE
argument_list|,
operator|&
name|rates
argument_list|,
sizeof|sizeof
name|rates
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_write_associd
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|uath_cmd_set_associd
name|associd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|associd
argument_list|,
sizeof|sizeof
name|associd
argument_list|)
expr_stmt|;
name|associd
operator|.
name|defaultrateix
operator|=
name|htobe32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX */
name|associd
operator|.
name|associd
operator|=
name|htobe32
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
name|associd
operator|.
name|timoffset
operator|=
name|htobe32
argument_list|(
literal|0x3b
argument_list|)
expr_stmt|;
comment|/* XXX */
name|IEEE80211_ADDR_COPY
argument_list|(
name|associd
operator|.
name|bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
return|return
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_WRITE_ASSOCID
argument_list|,
operator|&
name|associd
argument_list|,
sizeof|sizeof
name|associd
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_set_ledsteady
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|lednum
parameter_list|,
name|int
name|ledmode
parameter_list|)
block|{
name|struct
name|uath_cmd_ledsteady
name|led
decl_stmt|;
name|led
operator|.
name|lednum
operator|=
name|htobe32
argument_list|(
name|lednum
argument_list|)
expr_stmt|;
name|led
operator|.
name|ledmode
operator|=
name|htobe32
argument_list|(
name|ledmode
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_LED
argument_list|,
literal|"set %s led %s (steady)\n"
argument_list|,
operator|(
name|lednum
operator|==
name|UATH_LED_LINK
operator|)
condition|?
literal|"link"
else|:
literal|"activity"
argument_list|,
name|ledmode
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
return|return
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_SET_LED_STEADY
argument_list|,
operator|&
name|led
argument_list|,
sizeof|sizeof
name|led
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_set_ledblink
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|lednum
parameter_list|,
name|int
name|ledmode
parameter_list|,
name|int
name|blinkrate
parameter_list|,
name|int
name|slowmode
parameter_list|)
block|{
name|struct
name|uath_cmd_ledblink
name|led
decl_stmt|;
name|led
operator|.
name|lednum
operator|=
name|htobe32
argument_list|(
name|lednum
argument_list|)
expr_stmt|;
name|led
operator|.
name|ledmode
operator|=
name|htobe32
argument_list|(
name|ledmode
argument_list|)
expr_stmt|;
name|led
operator|.
name|blinkrate
operator|=
name|htobe32
argument_list|(
name|blinkrate
argument_list|)
expr_stmt|;
name|led
operator|.
name|slowmode
operator|=
name|htobe32
argument_list|(
name|slowmode
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_LED
argument_list|,
literal|"set %s led %s (blink)\n"
argument_list|,
operator|(
name|lednum
operator|==
name|UATH_LED_LINK
operator|)
condition|?
literal|"link"
else|:
literal|"activity"
argument_list|,
name|ledmode
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
return|return
name|uath_cmd_write
argument_list|(
name|sc
argument_list|,
name|WDCMSG_SET_LED_BLINK
argument_list|,
operator|&
name|led
argument_list|,
sizeof|sizeof
name|led
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|enum
name|ieee80211_state
name|ostate
init|=
name|vap
operator|->
name|iv_state
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|uath_vap
modifier|*
name|uvp
init|=
name|UATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_STATE
argument_list|,
literal|"%s: %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_ch
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
if|if
condition|(
name|ostate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* turn link and activity LEDs off */
name|uath_set_ledstate
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_S_SCAN
case|:
break|break;
case|case
name|IEEE80211_S_AUTH
case|:
comment|/* XXX good place?  set RTS threshold  */
name|uath_config
argument_list|(
name|sc
argument_list|,
name|CFG_USER_RTS_THRESHOLD
argument_list|,
name|vap
operator|->
name|iv_rtsthreshold
argument_list|)
expr_stmt|;
comment|/* XXX bad place  */
name|error
operator|=
name|uath_set_keys
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not set crypto keys, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|uath_switch_channel
argument_list|(
name|sc
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not switch channel\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|uath_create_connection
argument_list|(
name|sc
argument_list|,
name|UATH_ID_BSS
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not create connection\n"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IEEE80211_S_ASSOC
case|:
if|if
condition|(
name|uath_set_rates
argument_list|(
name|sc
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not set negotiated rate set\n"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IEEE80211_S_RUN
case|:
comment|/* XXX monitor mode doesn't be tested  */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
block|{
name|uath_set_ledstate
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Tx rate is controlled by firmware, report the maximum 		 * negotiated rate in ifconfig output. 		 */
name|ni
operator|->
name|ni_txrate
operator|=
name|ni
operator|->
name|ni_rates
operator|.
name|rs_rates
index|[
name|ni
operator|->
name|ni_rates
operator|.
name|rs_nrates
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|uath_write_associd
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not write association id\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* turn link LED on */
name|uath_set_ledsteady
argument_list|(
name|sc
argument_list|,
name|UATH_LED_LINK
argument_list|,
name|UATH_LED_ON
argument_list|)
expr_stmt|;
comment|/* make activity LED blink */
name|uath_set_ledblink
argument_list|(
name|sc
argument_list|,
name|UATH_LED_ACTIVITY
argument_list|,
name|UATH_LED_ON
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* set state to associated */
name|uath_set_ledstate
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* start statistics timer */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|,
name|hz
argument_list|,
name|uath_stat
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
name|uvp
operator|->
name|newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uath_set_key
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|wk
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct uath_cmd_crypto crypto; 	int i;  	bzero(&crypto, sizeof crypto); 	crypto.keyidx = htobe32(index); 	crypto.magic1 = htobe32(1); 	crypto.size   = htobe32(368); 	crypto.mask   = htobe32(0xffff); 	crypto.flags  = htobe32(0x80000068); 	if (index != UATH_DEFAULT_KEY) 		crypto.flags |= htobe32(index<< 16); 	memset(crypto.magic2, 0xff, sizeof crypto.magic2);
comment|/* 	 * Each byte of the key must be XOR'ed with 10101010 before being 	 * transmitted to the firmware. 	 */
block|for (i = 0; i< wk->wk_keylen; i++) 		crypto.key[i] = wk->wk_key[i] ^ 0xaa;  	DPRINTF(sc, UATH_DEBUG_CRYPTO, 	    "setting crypto key index=%d len=%d\n", index, wk->wk_keylen); 	return uath_cmd_write(sc, WDCMSG_SET_KEY_CACHE_ENTRY,&crypto, 	    sizeof crypto, 0);
else|#
directive|else
comment|/* XXX support H/W cryto  */
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|uath_set_keys
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_WEP_NKID
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|wk
init|=
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|wk
operator|->
name|wk_flags
operator|&
operator|(
name|IEEE80211_KEY_XMIT
operator||
name|IEEE80211_KEY_RECV
operator|)
condition|)
block|{
name|error
operator|=
name|uath_set_key
argument_list|(
name|sc
argument_list|,
name|wk
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|vap
operator|->
name|iv_def_txkey
operator|!=
name|IEEE80211_KEYIX_NONE
condition|)
block|{
name|error
operator|=
name|uath_set_key
argument_list|(
name|sc
argument_list|,
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
name|vap
operator|->
name|iv_def_txkey
index|]
argument_list|,
name|UATH_DEFAULT_KEY
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|UATH_SYSCTL_STAT_ADD32
parameter_list|(
name|c
parameter_list|,
name|h
parameter_list|,
name|n
parameter_list|,
name|p
parameter_list|,
name|d
parameter_list|)
define|\
value|SYSCTL_ADD_UINT(c, h, OID_AUTO, n, CTLFLAG_RD, p, 0, d)
end_define

begin_function
specifier|static
name|void
name|uath_sysctl_node
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|;
name|struct
name|uath_stat
modifier|*
name|stats
decl_stmt|;
name|stats
operator|=
operator|&
name|sc
operator|->
name|sc_stat
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"UATH statistics"
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"badchunkseqnum"
argument_list|,
operator|&
name|stats
operator|->
name|st_badchunkseqnum
argument_list|,
literal|"Bad chunk sequence numbers"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"invalidlen"
argument_list|,
operator|&
name|stats
operator|->
name|st_invalidlen
argument_list|,
literal|"Invalid length"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"multichunk"
argument_list|,
operator|&
name|stats
operator|->
name|st_multichunk
argument_list|,
literal|"Multi chunks"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"toobigrxpkt"
argument_list|,
operator|&
name|stats
operator|->
name|st_toobigrxpkt
argument_list|,
literal|"Too big rx packets"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"stopinprogress"
argument_list|,
operator|&
name|stats
operator|->
name|st_stopinprogress
argument_list|,
literal|"Stop in progress"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"crcerrs"
argument_list|,
operator|&
name|stats
operator|->
name|st_crcerr
argument_list|,
literal|"CRC errors"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"phyerr"
argument_list|,
operator|&
name|stats
operator|->
name|st_phyerr
argument_list|,
literal|"PHY errors"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"decrypt_crcerr"
argument_list|,
operator|&
name|stats
operator|->
name|st_decrypt_crcerr
argument_list|,
literal|"Decryption CRC errors"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"decrypt_micerr"
argument_list|,
operator|&
name|stats
operator|->
name|st_decrypt_micerr
argument_list|,
literal|"Decryption Misc errors"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"decomperr"
argument_list|,
operator|&
name|stats
operator|->
name|st_decomperr
argument_list|,
literal|"Decomp errors"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"keyerr"
argument_list|,
operator|&
name|stats
operator|->
name|st_keyerr
argument_list|,
literal|"Key errors"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"err"
argument_list|,
operator|&
name|stats
operator|->
name|st_err
argument_list|,
literal|"Unknown errors"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"cmd_active"
argument_list|,
operator|&
name|stats
operator|->
name|st_cmd_active
argument_list|,
literal|"Active numbers in Command queue"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"cmd_inactive"
argument_list|,
operator|&
name|stats
operator|->
name|st_cmd_inactive
argument_list|,
literal|"Inactive numbers in Command queue"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"cmd_pending"
argument_list|,
operator|&
name|stats
operator|->
name|st_cmd_pending
argument_list|,
literal|"Pending numbers in Command queue"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"cmd_waiting"
argument_list|,
operator|&
name|stats
operator|->
name|st_cmd_waiting
argument_list|,
literal|"Waiting numbers in Command queue"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"rx_active"
argument_list|,
operator|&
name|stats
operator|->
name|st_rx_active
argument_list|,
literal|"Active numbers in RX queue"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"rx_inactive"
argument_list|,
operator|&
name|stats
operator|->
name|st_rx_inactive
argument_list|,
literal|"Inactive numbers in RX queue"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"tx_active"
argument_list|,
operator|&
name|stats
operator|->
name|st_tx_active
argument_list|,
literal|"Active numbers in TX queue"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"tx_inactive"
argument_list|,
operator|&
name|stats
operator|->
name|st_tx_inactive
argument_list|,
literal|"Inactive numbers in TX queue"
argument_list|)
expr_stmt|;
name|UATH_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"tx_pending"
argument_list|,
operator|&
name|stats
operator|->
name|st_tx_pending
argument_list|,
literal|"Pending numbers in TX queue"
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|UATH_SYSCTL_STAT_ADD32
end_undef

begin_function
specifier|static
name|void
name|uath_cmdeof
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|uath_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|uath_cmd_hdr
modifier|*
name|hdr
decl_stmt|;
name|int
name|dlen
decl_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|uath_cmd_hdr
operator|*
operator|)
name|cmd
operator|->
name|buf
expr_stmt|;
comment|/* NB: msgid is passed thru w/o byte swapping */
ifdef|#
directive|ifdef
name|UATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|UATH_DEBUG_CMDS
condition|)
block|{
name|int
name|len
init|=
name|be32toh
argument_list|(
name|hdr
operator|->
name|len
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s: %s [ix %u] len %u status %u\n"
argument_list|,
name|__func__
argument_list|,
name|uath_codename
argument_list|(
name|be32toh
argument_list|(
name|hdr
operator|->
name|code
argument_list|)
argument_list|)
argument_list|,
name|hdr
operator|->
name|msgid
argument_list|,
name|len
argument_list|,
name|be32toh
argument_list|(
name|hdr
operator|->
name|magic
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|UATH_DEBUG_CMDS_DUMP
condition|)
name|uath_dump_cmd
argument_list|(
name|cmd
operator|->
name|buf
argument_list|,
name|len
operator|>
name|UATH_MAX_CMDSZ
condition|?
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
else|:
name|len
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|hdr
operator|->
name|code
operator|=
name|be32toh
argument_list|(
name|hdr
operator|->
name|code
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|be32toh
argument_list|(
name|hdr
operator|->
name|len
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|magic
operator|=
name|be32toh
argument_list|(
name|hdr
operator|->
name|magic
argument_list|)
expr_stmt|;
comment|/* target status on return */
switch|switch
condition|(
name|hdr
operator|->
name|code
operator|&
literal|0xff
condition|)
block|{
comment|/* reply to a read command */
default|default:
name|dlen
operator|=
name|hdr
operator|->
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_RX_PROC
operator||
name|UATH_DEBUG_RECV_ALL
argument_list|,
literal|"%s: code %d data len %u\n"
argument_list|,
name|__func__
argument_list|,
name|hdr
operator|->
name|code
operator|&
literal|0xff
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
comment|/* 		 * The first response from the target after the 		 * HOST_AVAILABLE has an invalid msgid so we must 		 * treat it specially. 		 */
if|if
condition|(
name|hdr
operator|->
name|msgid
operator|<
name|UATH_CMD_LIST_COUNT
condition|)
block|{
name|uint32_t
modifier|*
name|rp
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
decl_stmt|;
name|u_int
name|olen
decl_stmt|;
if|if
condition|(
operator|!
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|<=
name|hdr
operator|->
name|len
operator|&&
name|hdr
operator|->
name|len
operator|<
name|UATH_MAX_CMDSZ
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: invalid WDC msg length %u; "
literal|"msg ignored\n"
argument_list|,
name|__func__
argument_list|,
name|hdr
operator|->
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 			 * Calculate return/receive payload size; the 			 * first word, if present, always gives the 			 * number of bytes--unless it's 0 in which 			 * case a single 32-bit word should be present. 			 */
if|if
condition|(
name|dlen
operator|>=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|olen
operator|=
name|be32toh
argument_list|(
name|rp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dlen
operator|-=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|olen
operator|==
literal|0
condition|)
block|{
comment|/* convention is 0 =>'s one word */
name|olen
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
comment|/* XXX KASSERT(olen == dlen ) */
block|}
block|}
else|else
name|olen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|odata
operator|!=
name|NULL
condition|)
block|{
comment|/* NB: cmd->olen validated in uath_cmd */
if|if
condition|(
name|olen
operator|>
name|cmd
operator|->
name|olen
condition|)
block|{
comment|/* XXX complain? */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cmd 0x%x olen %u cmd olen %u\n"
argument_list|,
name|__func__
argument_list|,
name|hdr
operator|->
name|code
argument_list|,
name|olen
argument_list|,
name|cmd
operator|->
name|olen
argument_list|)
expr_stmt|;
name|olen
operator|=
name|cmd
operator|->
name|olen
expr_stmt|;
block|}
if|if
condition|(
name|olen
operator|>
name|dlen
condition|)
block|{
comment|/* XXX complain, shouldn't happen */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cmd 0x%x olen %u dlen %u\n"
argument_list|,
name|__func__
argument_list|,
name|hdr
operator|->
name|code
argument_list|,
name|olen
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|olen
operator|=
name|dlen
expr_stmt|;
block|}
comment|/* XXX have submitter do this */
comment|/* copy answer into caller's supplied buffer */
name|bcopy
argument_list|(
operator|&
name|rp
index|[
literal|1
index|]
argument_list|,
name|cmd
operator|->
name|odata
argument_list|,
name|olen
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|olen
operator|=
name|olen
expr_stmt|;
block|}
block|}
name|wakeup_one
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/* wake up caller */
break|break;
case|case
name|WDCMSG_TARGET_START
case|:
if|if
condition|(
name|hdr
operator|->
name|msgid
operator|>=
name|UATH_CMD_LIST_COUNT
condition|)
block|{
comment|/* XXX */
return|return;
block|}
name|dlen
operator|=
name|hdr
operator|->
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlen
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
comment|/* XXX something wrong */
return|return;
block|}
comment|/* XXX have submitter do this */
comment|/* copy answer into caller's supplied buffer */
name|bcopy
argument_list|(
name|hdr
operator|+
literal|1
argument_list|,
name|cmd
operator|->
name|odata
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|olen
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/* wake up caller */
break|break;
case|case
name|WDCMSG_SEND_COMPLETE
case|:
comment|/* this notification is sent when UATH_TX_NOTIFY is set */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_RX_PROC
operator||
name|UATH_DEBUG_RECV_ALL
argument_list|,
literal|"%s: received Tx notification\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
case|case
name|WDCMSG_TARGET_GET_STATS
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_RX_PROC
operator||
name|UATH_DEBUG_RECV_ALL
argument_list|,
literal|"%s: received device statistics\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|,
name|hz
argument_list|,
name|uath_stat
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uath_intr_rx_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|uath_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|int
name|actlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|cmd
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_waiting
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
goto|goto
name|setup
goto|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_waiting
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_DEC
argument_list|(
name|sc
argument_list|,
name|st_cmd_waiting
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_inactive
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_cmd_inactive
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|actlen
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|uath_cmd_hdr
argument_list|)
argument_list|,
operator|(
literal|"short xfer error"
operator|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|cmd
operator|->
name|buf
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
name|uath_cmdeof
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
case|case
name|USB_ST_SETUP
case|:
name|setup
label|:
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|setup
goto|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uath_intr_tx_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|uath_cmd
modifier|*
name|cmd
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|cmd
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_active
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
goto|goto
name|setup
goto|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_DEC
argument_list|(
name|sc
argument_list|,
name|st_cmd_active
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|(
name|cmd
operator|->
name|flags
operator|&
name|UATH_CMD_FLAG_READ
operator|)
condition|?
operator|&
name|sc
operator|->
name|sc_cmd_waiting
else|:
operator|&
name|sc
operator|->
name|sc_cmd_inactive
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|UATH_CMD_FLAG_READ
condition|)
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_cmd_waiting
argument_list|)
expr_stmt|;
else|else
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_cmd_inactive
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|USB_ST_SETUP
case|:
name|setup
label|:
name|cmd
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_XMIT
argument_list|,
literal|"%s: empty pending queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_pending
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_DEC
argument_list|(
name|sc
argument_list|,
name|st_cmd_pending
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|(
name|cmd
operator|->
name|flags
operator|&
name|UATH_CMD_FLAG_ASYNC
operator|)
condition|?
operator|&
name|sc
operator|->
name|sc_cmd_inactive
else|:
operator|&
name|sc
operator|->
name|sc_cmd_active
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|UATH_CMD_FLAG_ASYNC
condition|)
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_cmd_inactive
argument_list|)
expr_stmt|;
else|else
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_cmd_active
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|cmd
operator|->
name|buf
argument_list|,
name|cmd
operator|->
name|buflen
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|setup
goto|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uath_update_rxstat
parameter_list|(
name|struct
name|uath_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|status
parameter_list|)
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|UATH_STATUS_STOP_IN_PROGRESS
case|:
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_stopinprogress
argument_list|)
expr_stmt|;
break|break;
case|case
name|UATH_STATUS_CRC_ERR
case|:
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_crcerr
argument_list|)
expr_stmt|;
break|break;
case|case
name|UATH_STATUS_PHY_ERR
case|:
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_phyerr
argument_list|)
expr_stmt|;
break|break;
case|case
name|UATH_STATUS_DECRYPT_CRC_ERR
case|:
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_decrypt_crcerr
argument_list|)
expr_stmt|;
break|break;
case|case
name|UATH_STATUS_DECRYPT_MIC_ERR
case|:
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_decrypt_micerr
argument_list|)
expr_stmt|;
break|break;
case|case
name|UATH_STATUS_DECOMP_ERR
case|:
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_decomperr
argument_list|)
expr_stmt|;
break|break;
case|case
name|UATH_STATUS_KEY_ERR
case|:
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_keyerr
argument_list|)
expr_stmt|;
break|break;
case|case
name|UATH_STATUS_ERR
case|:
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_err
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|uath_data_rxeof
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|struct
name|uath_data
modifier|*
name|data
parameter_list|,
name|struct
name|uath_rx_desc
modifier|*
modifier|*
name|pdesc
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|uath_chunk
modifier|*
name|chunk
decl_stmt|;
name|struct
name|uath_rx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|data
operator|->
name|m
decl_stmt|,
modifier|*
name|mnew
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|uint16_t
name|chunklen
decl_stmt|;
name|int
name|actlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|actlen
operator|<
name|UATH_MIN_RXBUFSZ
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_RECV
operator||
name|UATH_DEBUG_RECV_ALL
argument_list|,
literal|"%s: wrong xfer size (len=%d)\n"
argument_list|,
name|__func__
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chunk
operator|=
operator|(
expr|struct
name|uath_chunk
operator|*
operator|)
name|data
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|chunk
operator|->
name|seqnum
operator|==
literal|0
operator|&&
name|chunk
operator|->
name|flags
operator|==
literal|0
operator|&&
name|chunk
operator|->
name|length
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: strange response\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|UATH_RESET_INTRX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|chunk
operator|->
name|seqnum
operator|!=
name|sc
operator|->
name|sc_intrx_nextnum
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_XMIT
argument_list|,
literal|"invalid seqnum %d, expected %d\n"
argument_list|,
name|chunk
operator|->
name|seqnum
argument_list|,
name|sc
operator|->
name|sc_intrx_nextnum
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_badchunkseqnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_intrx_head
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_intrx_head
argument_list|)
expr_stmt|;
name|UATH_RESET_INTRX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* check multi-chunk frames  */
if|if
condition|(
operator|(
name|chunk
operator|->
name|seqnum
operator|==
literal|0
operator|&&
operator|!
operator|(
name|chunk
operator|->
name|flags
operator|&
name|UATH_CFLAGS_FINAL
operator|)
operator|)
operator|||
operator|(
name|chunk
operator|->
name|seqnum
operator|!=
literal|0
operator|&&
operator|(
name|chunk
operator|->
name|flags
operator|&
name|UATH_CFLAGS_FINAL
operator|)
operator|)
operator|||
name|chunk
operator|->
name|flags
operator|&
name|UATH_CFLAGS_RXMSG
condition|)
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_multichunk
argument_list|)
expr_stmt|;
name|chunklen
operator|=
name|be16toh
argument_list|(
name|chunk
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|->
name|flags
operator|&
name|UATH_CFLAGS_FINAL
condition|)
name|chunklen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|uath_rx_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunklen
operator|>
literal|0
operator|&&
operator|(
operator|!
operator|(
name|chunk
operator|->
name|flags
operator|&
name|UATH_CFLAGS_FINAL
operator|)
operator|||
operator|!
operator|(
name|chunk
operator|->
name|seqnum
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* we should use intermediate RX buffer  */
if|if
condition|(
name|chunk
operator|->
name|seqnum
operator|==
literal|0
condition|)
name|UATH_RESET_INTRX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_intrx_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|uath_rx_desc
argument_list|)
operator|+
name|chunklen
operator|)
operator|>
name|UATH_MAX_INTRX_SIZE
condition|)
block|{
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_invalidlen
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_intrx_head
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_intrx_head
argument_list|)
expr_stmt|;
name|UATH_RESET_INTRX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|chunklen
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|uath_chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_intrx_head
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_intrx_head
operator|=
name|m
expr_stmt|;
name|sc
operator|->
name|sc_intrx_tail
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|sc
operator|->
name|sc_intrx_tail
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|sc
operator|->
name|sc_intrx_tail
operator|=
name|m
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_intrx_len
operator|+=
name|chunklen
expr_stmt|;
name|mnew
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnew
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_RECV
operator||
name|UATH_DEBUG_RECV_ALL
argument_list|,
literal|"%s: can't get new mbuf, drop frame\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_intrx_head
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_intrx_head
argument_list|)
expr_stmt|;
name|UATH_RESET_INTRX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|data
operator|->
name|m
operator|=
name|mnew
expr_stmt|;
name|data
operator|->
name|buf
operator|=
name|mtod
argument_list|(
name|mnew
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
comment|/* if the frame is not final continue the transfer  */
if|if
condition|(
operator|!
operator|(
name|chunk
operator|->
name|flags
operator|&
name|UATH_CFLAGS_FINAL
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_intrx_nextnum
operator|++
expr_stmt|;
name|UATH_RESET_INTRX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * if the frame is not set UATH_CFLAGS_RXMSG, then rx descriptor is 	 * located at the end, 32-bit aligned 	 */
name|desc
operator|=
operator|(
name|chunk
operator|->
name|flags
operator|&
name|UATH_CFLAGS_RXMSG
operator|)
condition|?
operator|(
expr|struct
name|uath_rx_desc
operator|*
operator|)
operator|(
name|chunk
operator|+
literal|1
operator|)
else|:
operator|(
expr|struct
name|uath_rx_desc
operator|*
operator|)
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|chunk
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|uath_chunk
argument_list|)
operator|+
name|be16toh
argument_list|(
name|chunk
operator|->
name|length
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|uath_rx_desc
argument_list|)
operator|)
expr_stmt|;
operator|*
name|pdesc
operator|=
name|desc
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_RECV
operator||
name|UATH_DEBUG_RECV_ALL
argument_list|,
literal|"%s: frame len %u code %u status %u rate %u antenna %u "
literal|"rssi %d channel %u phyerror %u connix %u decrypterror %u "
literal|"keycachemiss %u\n"
argument_list|,
name|__func__
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|framelen
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|code
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|status
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|rate
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|antenna
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|rssi
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|channel
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|phyerror
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|connix
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|decrypterror
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|keycachemiss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|be32toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
operator|>
name|MCLBYTES
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_RECV
operator||
name|UATH_DEBUG_RECV_ALL
argument_list|,
literal|"%s: bad descriptor (len=%d)\n"
argument_list|,
name|__func__
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_toobigrxpkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_intrx_head
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_intrx_head
argument_list|)
expr_stmt|;
name|UATH_RESET_INTRX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|uath_update_rxstat
argument_list|(
name|sc
argument_list|,
name|be32toh
argument_list|(
name|desc
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* finalize mbuf */
if|if
condition|(
name|sc
operator|->
name|sc_intrx_head
operator|==
name|NULL
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|be32toh
argument_list|(
name|desc
operator|->
name|framelen
argument_list|)
operator|-
name|UATH_RX_DUMMYSIZE
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|uath_chunk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|=
name|sc
operator|->
name|sc_intrx_head
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|mp
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|sc
operator|->
name|sc_intrx_len
expr_stmt|;
name|m
operator|=
name|mp
expr_stmt|;
block|}
comment|/* there are a lot more fields in the RX descriptor */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|UATH_FLAG_INVALID
operator|)
operator|==
literal|0
operator|&&
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|struct
name|uath_rx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_rxtap
decl_stmt|;
name|uint32_t
name|tsf_hi
init|=
name|be32toh
argument_list|(
name|desc
operator|->
name|tstamp_high
argument_list|)
decl_stmt|;
name|uint32_t
name|tsf_lo
init|=
name|be32toh
argument_list|(
name|desc
operator|->
name|tstamp_low
argument_list|)
decl_stmt|;
comment|/* XXX only get low order 24bits of tsf from h/w */
name|tap
operator|->
name|wr_tsf
operator|=
name|htole64
argument_list|(
operator|(
operator|(
name|uint64_t
operator|)
name|tsf_hi
operator|<<
literal|32
operator|)
operator||
name|tsf_lo
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|be32toh
argument_list|(
name|desc
operator|->
name|status
argument_list|)
operator|==
name|UATH_STATUS_CRC_ERR
condition|)
name|tap
operator|->
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_BADFCS
expr_stmt|;
comment|/* XXX map other status to BADFCS? */
comment|/* XXX ath h/w rate code, need to map */
name|tap
operator|->
name|wr_rate
operator|=
name|be32toh
argument_list|(
name|desc
operator|->
name|rate
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_antenna
operator|=
name|be32toh
argument_list|(
name|desc
operator|->
name|antenna
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_antsignal
operator|=
operator|-
literal|95
operator|+
name|be32toh
argument_list|(
name|desc
operator|->
name|rssi
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_antnoise
operator|=
operator|-
literal|95
expr_stmt|;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|UATH_RESET_INTRX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_bulk_rx_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|uath_data
modifier|*
name|data
decl_stmt|;
name|struct
name|uath_rx_desc
modifier|*
name|desc
init|=
name|NULL
decl_stmt|;
name|int8_t
name|nf
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|data
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_active
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
goto|goto
name|setup
goto|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_DEC
argument_list|(
name|sc
argument_list|,
name|st_rx_active
argument_list|)
expr_stmt|;
name|m
operator|=
name|uath_data_rxeof
argument_list|(
name|xfer
argument_list|,
name|data
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_inactive
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_rx_inactive
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|USB_ST_SETUP
case|:
name|setup
label|:
name|data
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_inactive
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_inactive
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_DEC
argument_list|(
name|sc
argument_list|,
name|st_rx_inactive
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_active
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_rx_active
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|data
operator|->
name|buf
argument_list|,
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* 		 * To avoid LOR we should unlock our private mutex here to call 		 * ieee80211_input() because here is at the end of a USB 		 * callback and safe to unlock. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UATH_FLAG_INVALID
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|desc
operator|!=
name|NULL
condition|)
block|{
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
operator|(
expr|struct
name|ieee80211_frame_min
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
name|nf
operator|=
operator|-
literal|95
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
operator|(
name|int
operator|)
name|be32toh
argument_list|(
name|desc
operator|->
name|rssi
argument_list|)
argument_list|,
name|nf
argument_list|)
expr_stmt|;
comment|/* node is no longer needed */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ieee80211_input_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
operator|(
name|int
operator|)
name|be32toh
argument_list|(
name|desc
operator|->
name|rssi
argument_list|)
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|desc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
operator|&&
operator|!
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|uath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* needs it to the inactive queue due to a error.  */
name|data
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_active
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_DEC
argument_list|(
name|sc
argument_list|,
name|st_rx_active
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_inactive
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_rx_inactive
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|setup
goto|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uath_data_txeof
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|struct
name|uath_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Do any tx complete callback.  Note this must be done before releasing 	 * the node reference. 	 */
if|if
condition|(
name|data
operator|->
name|m
condition|)
block|{
name|m
operator|=
name|data
operator|->
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_TXCB
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|UATH_FLAG_INVALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX status? */
name|ieee80211_process_callback
argument_list|(
name|data
operator|->
name|ni
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|ni
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|UATH_FLAG_INVALID
operator|)
operator|==
literal|0
condition|)
name|ieee80211_free_node
argument_list|(
name|data
operator|->
name|ni
argument_list|)
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uath_bulk_tx_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|uath_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|uath_data
modifier|*
name|data
decl_stmt|;
name|UATH_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|data
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_active
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
goto|goto
name|setup
goto|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_DEC
argument_list|(
name|sc
argument_list|,
name|st_tx_active
argument_list|)
expr_stmt|;
name|uath_data_txeof
argument_list|(
name|xfer
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_inactive
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|USB_ST_SETUP
case|:
name|setup
label|:
name|data
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UATH_DEBUG_XMIT
argument_list|,
literal|"%s: empty pending queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_pending
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_DEC
argument_list|(
name|sc
argument_list|,
name|st_tx_pending
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_active
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UATH_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_active
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|data
operator|->
name|buf
argument_list|,
name|data
operator|->
name|buflen
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|UATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|uath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|UATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|data
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_active
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
goto|goto
name|setup
goto|;
if|if
condition|(
name|data
operator|->
name|ni
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|UATH_FLAG_INVALID
operator|)
operator|==
literal|0
condition|)
name|ieee80211_free_node
argument_list|(
name|data
operator|->
name|ni
argument_list|)
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|setup
goto|;
block|}
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|uath_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|uath_match
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|uath_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|uath_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|uath_driver
init|=
block|{
literal|"uath"
block|,
name|uath_methods
block|,
expr|sizeof
operator|(
expr|struct
name|uath_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|uath_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|uath
argument_list|,
name|uhub
argument_list|,
name|uath_driver
argument_list|,
name|uath_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|uath
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|uath
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

