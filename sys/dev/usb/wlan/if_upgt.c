begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: if_upgt.c,v 1.35 2008/04/16 18:32:15 damien Exp $ */
end_comment

begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2007 Marcus Glocker<mglocker@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_phy.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_radiotap.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_include
include|#
directive|include
file|<dev/usb/wlan/if_upgtvar.h>
end_include

begin_comment
comment|/*  * Driver for the USB PrismGT devices.  *  * For now just USB 2.0 devices with the GW3887 chipset are supported.  * The driver has been written based on the firmware version 2.13.1.0_LM87.  *  * TODO's:  * - MONITOR mode test.  * - Add HOSTAP mode.  * - Add IBSS mode.  * - Support the USB 1.0 devices (NET2280, ISL3880, ISL3886 chipsets).  *  * Parts of this driver has been influenced by reading the p54u driver  * written by Jean-Baptiste Note<jean-baptiste.note@m4x.org> and  * Sebastien Bourdeauducq<lekernel@prism54.org>.  */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|upgt
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"USB PrismGT GW3887 driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UPGT_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|upgt_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_upgt
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|upgt_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.upgt.debug"
argument_list|,
operator|&
name|upgt_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|UPGT_DEBUG_XMIT
init|=
literal|0x00000001
block|,
comment|/* basic xmit operation */
name|UPGT_DEBUG_RECV
init|=
literal|0x00000002
block|,
comment|/* basic recv operation */
name|UPGT_DEBUG_RESET
init|=
literal|0x00000004
block|,
comment|/* reset processing */
name|UPGT_DEBUG_INTR
init|=
literal|0x00000008
block|,
comment|/* INTR */
name|UPGT_DEBUG_TX_PROC
init|=
literal|0x00000010
block|,
comment|/* tx ISR proc */
name|UPGT_DEBUG_RX_PROC
init|=
literal|0x00000020
block|,
comment|/* rx ISR proc */
name|UPGT_DEBUG_STATE
init|=
literal|0x00000040
block|,
comment|/* 802.11 state transitions */
name|UPGT_DEBUG_STAT
init|=
literal|0x00000080
block|,
comment|/* statistic */
name|UPGT_DEBUG_FW
init|=
literal|0x00000100
block|,
comment|/* firmware */
name|UPGT_DEBUG_ANY
init|=
literal|0xffffffff
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	if (sc->sc_debug& (m))					\ 		printf(fmt, __VA_ARGS__);			\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	(void) sc;						\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|device_probe_t
name|upgt_match
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|upgt_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|upgt_detach
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|upgt_alloc_tx
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upgt_alloc_rx
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upgt_device_reset
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_bulk_tx
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|,
name|struct
name|upgt_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upgt_fw_verify
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upgt_mem_init
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upgt_fw_load
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upgt_fw_copy
parameter_list|(
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|upgt_crc32_le
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|upgt_rxeof
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|,
name|struct
name|upgt_data
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|upgt_rx
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_txeof
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|,
name|struct
name|upgt_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upgt_eeprom_read
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upgt_eeprom_parse
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_eeprom_parse_hwrx
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_eeprom_parse_freq3
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_eeprom_parse_freq4
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_eeprom_parse_freq6
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|upgt_chksum_le
parameter_list|(
specifier|const
name|uint32_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_tx_done
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_init_locked
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upgt_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upgt_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|upgt_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
parameter_list|,
name|enum
name|ieee80211_opmode
parameter_list|,
name|int
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|upgt_rx_rate
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_set_multi
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_stop
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_setup_rates
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upgt_set_macfilter
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upgt_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_set_chan
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_set_led
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_set_led_blink
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_get_stats
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_mem_free
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|upgt_mem_alloc
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_free_tx
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_free_rx
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_watchdog
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_abort_xfers
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_abort_xfers_locked
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upgt_sysctl_node
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|upgt_data
modifier|*
name|upgt_getbuf
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|upgt_data
modifier|*
name|upgt_gettxbuf
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|upgt_tx_start
parameter_list|(
name|struct
name|upgt_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|upgt_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|upgt_fwname
init|=
literal|"upgt-gw3887"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|STRUCT_USB_HOST_ID
name|upgt_devs
index|[]
init|=
block|{
define|#
directive|define
name|UPGT_DEV
parameter_list|(
name|v
parameter_list|,
name|p
parameter_list|)
value|{ USB_VP(USB_VENDOR_##v, USB_PRODUCT_##v##_##p) }
comment|/* version 2 devices */
name|UPGT_DEV
argument_list|(
name|ACCTON
argument_list|,
name|PRISM_GT
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|BELKIN
argument_list|,
name|F5D7050
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|CISCOLINKSYS
argument_list|,
name|WUSB54AG
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|CONCEPTRONIC
argument_list|,
name|PRISM_GT
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|DELL
argument_list|,
name|PRISM_GT_1
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|DELL
argument_list|,
name|PRISM_GT_2
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|FSC
argument_list|,
name|E5400
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|GLOBESPAN
argument_list|,
name|PRISM_GT_1
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|GLOBESPAN
argument_list|,
name|PRISM_GT_2
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|NETGEAR
argument_list|,
name|WG111V2_2
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|INTERSIL
argument_list|,
name|PRISM_GT
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|SMC
argument_list|,
literal|2862WG
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|USR
argument_list|,
name|USR5422
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|WISTRONNEWEB
argument_list|,
name|UR045G
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|XYRATEX
argument_list|,
name|PRISM_GT_1
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|XYRATEX
argument_list|,
name|PRISM_GT_2
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
name|ZCOM
argument_list|,
name|XG703A
argument_list|)
block|,
name|UPGT_DEV
argument_list|(
argument|ZCOM
argument_list|,
argument|XM142
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|upgt_bulk_rx_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|upgt_bulk_tx_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|upgt_config
index|[
name|UPGT_N_XFERS
index|]
init|=
block|{
index|[
name|UPGT_BULK_TX
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
name|MCLBYTES
operator|*
name|UPGT_TX_MAXCOUNT
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|force_short_xfer
operator|=
literal|1
block|,
operator|.
name|pipe_bof
operator|=
literal|1
block|}
block|,
operator|.
name|callback
operator|=
name|upgt_bulk_tx_callback
block|,
operator|.
name|timeout
operator|=
name|UPGT_USB_TIMEOUT
block|,
comment|/* ms */
block|}
block|,
index|[
name|UPGT_BULK_RX
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
name|MCLBYTES
operator|*
name|UPGT_RX_MAXCOUNT
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|}
block|,
operator|.
name|callback
operator|=
name|upgt_bulk_rx_callback
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|upgt_match
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bConfigIndex
operator|!=
name|UPGT_CONFIG_INDEX
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
operator|!=
name|UPGT_IFACE_INDEX
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|usbd_lookup_id_by_uaa
argument_list|(
name|upgt_devs
argument_list|,
sizeof|sizeof
argument_list|(
name|upgt_devs
argument_list|)
argument_list|,
name|uaa
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint8_t
name|bands
decl_stmt|,
name|iface_index
init|=
name|UPGT_IFACE_INDEX
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
ifdef|#
directive|ifdef
name|UPGT_DEBUG
name|sc
operator|->
name|sc_debug
operator|=
name|upgt_debug
expr_stmt|;
endif|#
directive|endif
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_led_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|iface_index
argument_list|,
name|sc
operator|->
name|sc_xfer
argument_list|,
name|upgt_config
argument_list|,
name|UPGT_N_XFERS
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate USB transfers, "
literal|"err=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|sc
operator|->
name|sc_rx_dma_buf
operator|=
name|usbd_xfer_get_frame_buffer
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UPGT_BULK_RX
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_dma_buf
operator|=
name|usbd_xfer_get_frame_buffer
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UPGT_BULK_TX
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup TX and RX buffers */
name|error
operator|=
name|upgt_alloc_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail2
goto|;
name|error
operator|=
name|upgt_alloc_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail3
goto|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_IEEE80211
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail4
goto|;
block|}
comment|/* Initialize the device.  */
name|error
operator|=
name|upgt_device_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail5
goto|;
comment|/* Verify the firmware.  */
name|error
operator|=
name|upgt_fw_verify
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail5
goto|;
comment|/* Calculate device memory space.  */
if|if
condition|(
name|sc
operator|->
name|sc_memaddr_frame_start
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_memaddr_frame_end
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not find memory space addresses on FW\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|fail5
goto|;
block|}
name|sc
operator|->
name|sc_memaddr_frame_end
operator|-=
name|UPGT_MEMSIZE_RX
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_memaddr_rx_start
operator|=
name|sc
operator|->
name|sc_memaddr_frame_end
operator|+
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"memory address frame start=0x%08x\n"
argument_list|,
name|sc
operator|->
name|sc_memaddr_frame_start
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"memory address frame end=0x%08x\n"
argument_list|,
name|sc
operator|->
name|sc_memaddr_frame_end
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"memory address rx start=0x%08x\n"
argument_list|,
name|sc
operator|->
name|sc_memaddr_rx_start
argument_list|)
expr_stmt|;
name|upgt_mem_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Load the firmware.  */
name|error
operator|=
name|upgt_fw_load
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail5
goto|;
comment|/* Read the whole EEPROM content and parse it.  */
name|error
operator|=
name|upgt_eeprom_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail5
goto|;
name|error
operator|=
name|upgt_eeprom_parse
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail5
goto|;
comment|/* all works related with the device have done here. */
name|upgt_abort_xfers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Setup the 802.11 device.  */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"upgt"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|upgt_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|upgt_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|upgt_start
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
name|ic
operator|->
name|ic_ifp
operator|=
name|ifp
expr_stmt|;
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
comment|/* not only, but not used */
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
comment|/* set device capabilities */
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
comment|/* station mode */
operator||
name|IEEE80211_C_MONITOR
comment|/* monitor mode */
operator||
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
operator||
name|IEEE80211_C_SHSLOT
comment|/* short slot time supported */
operator||
name|IEEE80211_C_BGSCAN
comment|/* capable of bg scanning */
operator||
name|IEEE80211_C_WPA
comment|/* 802.11i */
expr_stmt|;
name|bands
operator|=
literal|0
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|bands
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|bands
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
name|ieee80211_init_channels
argument_list|(
name|ic
argument_list|,
name|NULL
argument_list|,
operator|&
name|bands
argument_list|)
expr_stmt|;
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|,
name|sc
operator|->
name|sc_myaddr
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|upgt_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|upgt_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|upgt_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|upgt_set_channel
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|upgt_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|upgt_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_update_mcast
operator|=
name|upgt_update_mcast
expr_stmt|;
name|ieee80211_radiotap_attach
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_txtap
argument_list|)
argument_list|,
name|UPGT_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rxtap
argument_list|)
argument_list|,
name|UPGT_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
name|upgt_sysctl_node
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail5
label|:
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|fail4
label|:
name|upgt_free_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fail3
label|:
name|upgt_free_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fail2
label|:
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|UPGT_N_XFERS
argument_list|)
expr_stmt|;
name|fail1
label|:
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_txeof
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|struct
name|upgt_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|UPGT_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Do any tx complete callback.  Note this must be done before releasing 	 * the node reference. 	 */
if|if
condition|(
name|data
operator|->
name|m
condition|)
block|{
name|m
operator|=
name|data
operator|->
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_TXCB
condition|)
block|{
comment|/* XXX status? */
name|ieee80211_process_callback
argument_list|(
name|data
operator|->
name|ni
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|ni
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|data
operator|->
name|ni
argument_list|)
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
block|}
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_get_stats
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|upgt_data
modifier|*
name|data_cmd
decl_stmt|;
name|struct
name|upgt_lmac_mem
modifier|*
name|mem
decl_stmt|;
name|struct
name|upgt_lmac_stats
modifier|*
name|stats
decl_stmt|;
name|data_cmd
operator|=
name|upgt_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_cmd
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: out of buffers.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Transmit the URB containing the CMD data. 	 */
name|memset
argument_list|(
name|data_cmd
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
name|mem
operator|=
operator|(
expr|struct
name|upgt_lmac_mem
operator|*
operator|)
name|data_cmd
operator|->
name|buf
expr_stmt|;
name|mem
operator|->
name|addr
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_memaddr_frame_start
operator|+
name|UPGT_MEMSIZE_FRAME_HEAD
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|(
expr|struct
name|upgt_lmac_stats
operator|*
operator|)
operator|(
name|mem
operator|+
literal|1
operator|)
expr_stmt|;
name|stats
operator|->
name|header1
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|stats
operator|->
name|header1
operator|.
name|type
operator|=
name|UPGT_H1_TYPE_CTRL
expr_stmt|;
name|stats
operator|->
name|header1
operator|.
name|len
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_lmac_stats
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_lmac_header
argument_list|)
argument_list|)
expr_stmt|;
name|stats
operator|->
name|header2
operator|.
name|reqid
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_memaddr_frame_start
argument_list|)
expr_stmt|;
name|stats
operator|->
name|header2
operator|.
name|type
operator|=
name|htole16
argument_list|(
name|UPGT_H2_TYPE_STATS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|header2
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|data_cmd
operator|->
name|buflen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
expr_stmt|;
name|mem
operator|->
name|chksum
operator|=
name|upgt_chksum_le
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
name|stats
argument_list|,
name|data_cmd
operator|->
name|buflen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|upgt_bulk_tx
argument_list|(
name|sc
argument_list|,
name|data_cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|startall
init|=
literal|0
decl_stmt|;
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|UPGT_FLAG_DETACHED
operator|)
condition|?
name|ENXIO
else|:
literal|0
expr_stmt|;
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|sc_if_flags
operator|)
operator|&
operator|(
name|IFF_ALLMULTI
operator||
name|IFF_PROMISC
operator|)
condition|)
name|upgt_set_multi
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|upgt_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|startall
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|upgt_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
if|if
condition|(
name|startall
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|ic
operator|->
name|ic_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFADDR
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_stop_locked
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|UPGT_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|upgt_set_macfilter
argument_list|(
name|sc
argument_list|,
name|IEEE80211_S_INIT
argument_list|)
expr_stmt|;
name|upgt_abort_xfers_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_stop
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|upgt_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* device down */
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|UPGT_FLAG_INITDONE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_set_led
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|struct
name|upgt_data
modifier|*
name|data_cmd
decl_stmt|;
name|struct
name|upgt_lmac_mem
modifier|*
name|mem
decl_stmt|;
name|struct
name|upgt_lmac_led
modifier|*
name|led
decl_stmt|;
name|data_cmd
operator|=
name|upgt_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_cmd
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: out of buffers.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Transmit the URB containing the CMD data. 	 */
name|memset
argument_list|(
name|data_cmd
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
name|mem
operator|=
operator|(
expr|struct
name|upgt_lmac_mem
operator|*
operator|)
name|data_cmd
operator|->
name|buf
expr_stmt|;
name|mem
operator|->
name|addr
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_memaddr_frame_start
operator|+
name|UPGT_MEMSIZE_FRAME_HEAD
argument_list|)
expr_stmt|;
name|led
operator|=
operator|(
expr|struct
name|upgt_lmac_led
operator|*
operator|)
operator|(
name|mem
operator|+
literal|1
operator|)
expr_stmt|;
name|led
operator|->
name|header1
operator|.
name|flags
operator|=
name|UPGT_H1_FLAGS_TX_NO_CALLBACK
expr_stmt|;
name|led
operator|->
name|header1
operator|.
name|type
operator|=
name|UPGT_H1_TYPE_CTRL
expr_stmt|;
name|led
operator|->
name|header1
operator|.
name|len
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_lmac_led
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_lmac_header
argument_list|)
argument_list|)
expr_stmt|;
name|led
operator|->
name|header2
operator|.
name|reqid
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_memaddr_frame_start
argument_list|)
expr_stmt|;
name|led
operator|->
name|header2
operator|.
name|type
operator|=
name|htole16
argument_list|(
name|UPGT_H2_TYPE_LED
argument_list|)
expr_stmt|;
name|led
operator|->
name|header2
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|UPGT_LED_OFF
case|:
name|led
operator|->
name|mode
operator|=
name|htole16
argument_list|(
name|UPGT_LED_MODE_SET
argument_list|)
expr_stmt|;
name|led
operator|->
name|action_fix
operator|=
literal|0
expr_stmt|;
name|led
operator|->
name|action_tmp
operator|=
name|htole16
argument_list|(
name|UPGT_LED_ACTION_OFF
argument_list|)
expr_stmt|;
name|led
operator|->
name|action_tmp_dur
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UPGT_LED_ON
case|:
name|led
operator|->
name|mode
operator|=
name|htole16
argument_list|(
name|UPGT_LED_MODE_SET
argument_list|)
expr_stmt|;
name|led
operator|->
name|action_fix
operator|=
literal|0
expr_stmt|;
name|led
operator|->
name|action_tmp
operator|=
name|htole16
argument_list|(
name|UPGT_LED_ACTION_ON
argument_list|)
expr_stmt|;
name|led
operator|->
name|action_tmp_dur
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UPGT_LED_BLINK
case|:
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|data_cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_led_blink
condition|)
block|{
comment|/* previous blink was not finished */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|data_cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return;
block|}
name|led
operator|->
name|mode
operator|=
name|htole16
argument_list|(
name|UPGT_LED_MODE_SET
argument_list|)
expr_stmt|;
name|led
operator|->
name|action_fix
operator|=
name|htole16
argument_list|(
name|UPGT_LED_ACTION_OFF
argument_list|)
expr_stmt|;
name|led
operator|->
name|action_tmp
operator|=
name|htole16
argument_list|(
name|UPGT_LED_ACTION_ON
argument_list|)
expr_stmt|;
name|led
operator|->
name|action_tmp_dur
operator|=
name|htole16
argument_list|(
name|UPGT_LED_ACTION_TMP_DUR
argument_list|)
expr_stmt|;
comment|/* lock blink */
name|sc
operator|->
name|sc_led_blink
operator|=
literal|1
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_led_ch
argument_list|,
name|hz
argument_list|,
name|upgt_set_led_blink
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|data_cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return;
block|}
name|data_cmd
operator|->
name|buflen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|led
argument_list|)
expr_stmt|;
name|mem
operator|->
name|chksum
operator|=
name|upgt_chksum_le
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
name|led
argument_list|,
name|data_cmd
operator|->
name|buflen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|upgt_bulk_tx
argument_list|(
name|sc
argument_list|,
name|data_cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_set_led_blink
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
comment|/* blink finished, we are ready for a next one */
name|sc
operator|->
name|sc_led_blink
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_init
parameter_list|(
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|priv
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|upgt_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* start all vap's */
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_init_locked
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|UPGT_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|upgt_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UPGT_BULK_RX
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|upgt_set_macfilter
argument_list|(
name|sc
argument_list|,
name|IEEE80211_S_SCAN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|UPGT_FLAG_INITDONE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_ch
argument_list|,
name|hz
argument_list|,
name|upgt_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_set_macfilter
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|state
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|upgt_data
modifier|*
name|data_cmd
decl_stmt|;
name|struct
name|upgt_lmac_mem
modifier|*
name|mem
decl_stmt|;
name|struct
name|upgt_lmac_filter
modifier|*
name|filter
decl_stmt|;
name|uint8_t
name|broadcast
index|[]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
name|UPGT_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|data_cmd
operator|=
name|upgt_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_cmd
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"out of TX buffers.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 	 * Transmit the URB containing the CMD data. 	 */
name|memset
argument_list|(
name|data_cmd
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
name|mem
operator|=
operator|(
expr|struct
name|upgt_lmac_mem
operator|*
operator|)
name|data_cmd
operator|->
name|buf
expr_stmt|;
name|mem
operator|->
name|addr
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_memaddr_frame_start
operator|+
name|UPGT_MEMSIZE_FRAME_HEAD
argument_list|)
expr_stmt|;
name|filter
operator|=
operator|(
expr|struct
name|upgt_lmac_filter
operator|*
operator|)
operator|(
name|mem
operator|+
literal|1
operator|)
expr_stmt|;
name|filter
operator|->
name|header1
operator|.
name|flags
operator|=
name|UPGT_H1_FLAGS_TX_NO_CALLBACK
expr_stmt|;
name|filter
operator|->
name|header1
operator|.
name|type
operator|=
name|UPGT_H1_TYPE_CTRL
expr_stmt|;
name|filter
operator|->
name|header1
operator|.
name|len
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_lmac_filter
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_lmac_header
argument_list|)
argument_list|)
expr_stmt|;
name|filter
operator|->
name|header2
operator|.
name|reqid
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_memaddr_frame_start
argument_list|)
expr_stmt|;
name|filter
operator|->
name|header2
operator|.
name|type
operator|=
name|htole16
argument_list|(
name|UPGT_H2_TYPE_MACFILTER
argument_list|)
expr_stmt|;
name|filter
operator|->
name|header2
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_STATE
argument_list|,
literal|"%s: set MAC filter to INIT\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|filter
operator|->
name|type
operator|=
name|htole16
argument_list|(
name|UPGT_FILTER_TYPE_RESET
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_SCAN
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_STATE
argument_list|,
literal|"set MAC filter to SCAN (bssid %s)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|broadcast
argument_list|)
argument_list|)
expr_stmt|;
name|filter
operator|->
name|type
operator|=
name|htole16
argument_list|(
name|UPGT_FILTER_TYPE_NONE
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|filter
operator|->
name|dst
argument_list|,
name|sc
operator|->
name|sc_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|filter
operator|->
name|src
argument_list|,
name|broadcast
argument_list|)
expr_stmt|;
name|filter
operator|->
name|unknown1
operator|=
name|htole16
argument_list|(
name|UPGT_FILTER_UNKNOWN1
argument_list|)
expr_stmt|;
name|filter
operator|->
name|rxaddr
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_memaddr_rx_start
argument_list|)
expr_stmt|;
name|filter
operator|->
name|unknown2
operator|=
name|htole16
argument_list|(
name|UPGT_FILTER_UNKNOWN2
argument_list|)
expr_stmt|;
name|filter
operator|->
name|rxhw
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_eeprom_hwrx
argument_list|)
expr_stmt|;
name|filter
operator|->
name|unknown3
operator|=
name|htole16
argument_list|(
name|UPGT_FILTER_UNKNOWN3
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_RUN
case|:
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
comment|/* XXX monitor mode isn't tested yet.  */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
block|{
name|filter
operator|->
name|type
operator|=
name|htole16
argument_list|(
name|UPGT_FILTER_TYPE_MONITOR
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|filter
operator|->
name|dst
argument_list|,
name|sc
operator|->
name|sc_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|filter
operator|->
name|src
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|filter
operator|->
name|unknown1
operator|=
name|htole16
argument_list|(
name|UPGT_FILTER_MONITOR_UNKNOWN1
argument_list|)
expr_stmt|;
name|filter
operator|->
name|rxaddr
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_memaddr_rx_start
argument_list|)
expr_stmt|;
name|filter
operator|->
name|unknown2
operator|=
name|htole16
argument_list|(
name|UPGT_FILTER_MONITOR_UNKNOWN2
argument_list|)
expr_stmt|;
name|filter
operator|->
name|rxhw
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_eeprom_hwrx
argument_list|)
expr_stmt|;
name|filter
operator|->
name|unknown3
operator|=
name|htole16
argument_list|(
name|UPGT_FILTER_MONITOR_UNKNOWN3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_STATE
argument_list|,
literal|"set MAC filter to RUN (bssid %s)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|)
expr_stmt|;
name|filter
operator|->
name|type
operator|=
name|htole16
argument_list|(
name|UPGT_FILTER_TYPE_STA
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|filter
operator|->
name|dst
argument_list|,
name|sc
operator|->
name|sc_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|filter
operator|->
name|src
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|filter
operator|->
name|unknown1
operator|=
name|htole16
argument_list|(
name|UPGT_FILTER_UNKNOWN1
argument_list|)
expr_stmt|;
name|filter
operator|->
name|rxaddr
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_memaddr_rx_start
argument_list|)
expr_stmt|;
name|filter
operator|->
name|unknown2
operator|=
name|htole16
argument_list|(
name|UPGT_FILTER_UNKNOWN2
argument_list|)
expr_stmt|;
name|filter
operator|->
name|rxhw
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_eeprom_hwrx
argument_list|)
expr_stmt|;
name|filter
operator|->
name|unknown3
operator|=
name|htole16
argument_list|(
name|UPGT_FILTER_UNKNOWN3
argument_list|)
expr_stmt|;
block|}
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"MAC filter does not know that state\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|data_cmd
operator|->
name|buflen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|filter
argument_list|)
expr_stmt|;
name|mem
operator|->
name|chksum
operator|=
name|upgt_chksum_le
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
name|filter
argument_list|,
name|data_cmd
operator|->
name|buflen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|upgt_bulk_tx
argument_list|(
name|sc
argument_list|,
name|data_cmd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_setup_rates
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
decl_stmt|;
comment|/* 	 * 0x01 = OFMD6   0x10 = DS1 	 * 0x04 = OFDM9   0x11 = DS2 	 * 0x06 = OFDM12  0x12 = DS5 	 * 0x07 = OFDM18  0x13 = DS11 	 * 0x08 = OFDM24 	 * 0x09 = OFDM36 	 * 0x0a = OFDM48 	 * 0x0b = OFDM54 	 */
specifier|const
name|uint8_t
name|rateset_auto_11b
index|[]
init|=
block|{
literal|0x13
block|,
literal|0x13
block|,
literal|0x12
block|,
literal|0x11
block|,
literal|0x11
block|,
literal|0x10
block|,
literal|0x10
block|,
literal|0x10
block|}
decl_stmt|;
specifier|const
name|uint8_t
name|rateset_auto_11g
index|[]
init|=
block|{
literal|0x0b
block|,
literal|0x0a
block|,
literal|0x09
block|,
literal|0x08
block|,
literal|0x07
block|,
literal|0x06
block|,
literal|0x04
block|,
literal|0x01
block|}
decl_stmt|;
specifier|const
name|uint8_t
name|rateset_fix_11bg
index|[]
init|=
block|{
literal|0x10
block|,
literal|0x11
block|,
literal|0x12
block|,
literal|0x13
block|,
literal|0x01
block|,
literal|0x04
block|,
literal|0x06
block|,
literal|0x07
block|,
literal|0x08
block|,
literal|0x09
block|,
literal|0x0a
block|,
literal|0x0b
block|}
decl_stmt|;
name|tp
operator|=
operator|&
name|vap
operator|->
name|iv_txparms
index|[
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
index|]
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|tp
operator|->
name|ucastrate
operator|==
name|IEEE80211_FIXED_RATE_NONE
condition|)
block|{
comment|/* 		 * Automatic rate control is done by the device. 		 * We just pass the rateset from which the device 		 * will pickup a rate. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11B
condition|)
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_cur_rateset
argument_list|,
name|rateset_auto_11b
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_cur_rateset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11G
operator|||
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_AUTO
condition|)
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_cur_rateset
argument_list|,
name|rateset_auto_11g
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_cur_rateset
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set a fixed rate */
name|memset
argument_list|(
name|sc
operator|->
name|sc_cur_rateset
argument_list|,
name|rateset_fix_11bg
index|[
name|tp
operator|->
name|ucastrate
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_cur_rateset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_set_multi
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
return|return;
comment|/* 	 * XXX don't know how to set a device.  Lack of docs.  Just try to set 	 * IFF_ALLMULTI flag here. 	 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|upgt_data
modifier|*
name|data_tx
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|data_tx
operator|=
name|upgt_gettxbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_tx
operator|==
name|NULL
condition|)
block|{
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|upgt_tx_start
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|data_tx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|data_tx
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UPGT_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_inactive
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
block|}
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|upgt_data
modifier|*
name|data_tx
init|=
name|NULL
decl_stmt|;
comment|/* prevent management frames from being sent if we're not ready */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|data_tx
operator|=
name|upgt_gettxbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_tx
operator|==
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
if|if
condition|(
name|upgt_tx_start
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|data_tx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|data_tx
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UPGT_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_inactive
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tx_timer
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_tx_timer
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"watchdog timeout\n"
argument_list|)
expr_stmt|;
comment|/* upgt_init(ifp); XXX needs a process context ? */
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_ch
argument_list|,
name|hz
argument_list|,
name|upgt_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|upgt_mem_alloc
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_memory
operator|.
name|pages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_memory
operator|.
name|page
index|[
name|i
index|]
operator|.
name|used
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_memory
operator|.
name|page
index|[
name|i
index|]
operator|.
name|used
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_memory
operator|.
name|page
index|[
name|i
index|]
operator|.
name|addr
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
comment|/* do nothing.  */
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
comment|/* do nothing.  */
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|upgt_set_chan
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_set_chan
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|upgt_data
modifier|*
name|data_cmd
decl_stmt|;
name|struct
name|upgt_lmac_mem
modifier|*
name|mem
decl_stmt|;
name|struct
name|upgt_lmac_channel
modifier|*
name|chan
decl_stmt|;
name|int
name|channel
decl_stmt|;
name|UPGT_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|channel
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|0
operator|||
name|channel
operator|==
name|IEEE80211_CHAN_ANY
condition|)
block|{
comment|/* XXX should NEVER happen */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: invalid channel %x\n"
argument_list|,
name|__func__
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_STATE
argument_list|,
literal|"%s: channel %d\n"
argument_list|,
name|__func__
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|data_cmd
operator|=
name|upgt_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_cmd
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: out of buffers.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Transmit the URB containing the CMD data. 	 */
name|memset
argument_list|(
name|data_cmd
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
name|mem
operator|=
operator|(
expr|struct
name|upgt_lmac_mem
operator|*
operator|)
name|data_cmd
operator|->
name|buf
expr_stmt|;
name|mem
operator|->
name|addr
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_memaddr_frame_start
operator|+
name|UPGT_MEMSIZE_FRAME_HEAD
argument_list|)
expr_stmt|;
name|chan
operator|=
operator|(
expr|struct
name|upgt_lmac_channel
operator|*
operator|)
operator|(
name|mem
operator|+
literal|1
operator|)
expr_stmt|;
name|chan
operator|->
name|header1
operator|.
name|flags
operator|=
name|UPGT_H1_FLAGS_TX_NO_CALLBACK
expr_stmt|;
name|chan
operator|->
name|header1
operator|.
name|type
operator|=
name|UPGT_H1_TYPE_CTRL
expr_stmt|;
name|chan
operator|->
name|header1
operator|.
name|len
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_lmac_channel
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_lmac_header
argument_list|)
argument_list|)
expr_stmt|;
name|chan
operator|->
name|header2
operator|.
name|reqid
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_memaddr_frame_start
argument_list|)
expr_stmt|;
name|chan
operator|->
name|header2
operator|.
name|type
operator|=
name|htole16
argument_list|(
name|UPGT_H2_TYPE_CHANNEL
argument_list|)
expr_stmt|;
name|chan
operator|->
name|header2
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|unknown1
operator|=
name|htole16
argument_list|(
name|UPGT_CHANNEL_UNKNOWN1
argument_list|)
expr_stmt|;
name|chan
operator|->
name|unknown2
operator|=
name|htole16
argument_list|(
name|UPGT_CHANNEL_UNKNOWN2
argument_list|)
expr_stmt|;
name|chan
operator|->
name|freq6
operator|=
name|sc
operator|->
name|sc_eeprom_freq6
index|[
name|channel
index|]
expr_stmt|;
name|chan
operator|->
name|settings
operator|=
name|sc
operator|->
name|sc_eeprom_freq6_settings
expr_stmt|;
name|chan
operator|->
name|unknown3
operator|=
name|UPGT_CHANNEL_UNKNOWN3
expr_stmt|;
name|memcpy
argument_list|(
name|chan
operator|->
name|freq3_1
argument_list|,
operator|&
name|sc
operator|->
name|sc_eeprom_freq3
index|[
name|channel
index|]
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|chan
operator|->
name|freq3_1
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|chan
operator|->
name|freq4
argument_list|,
operator|&
name|sc
operator|->
name|sc_eeprom_freq4
index|[
name|channel
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_eeprom_freq4
index|[
name|channel
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|chan
operator|->
name|freq3_2
argument_list|,
operator|&
name|sc
operator|->
name|sc_eeprom_freq3
index|[
name|channel
index|]
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|chan
operator|->
name|freq3_2
argument_list|)
argument_list|)
expr_stmt|;
name|data_cmd
operator|->
name|buflen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|chan
argument_list|)
expr_stmt|;
name|mem
operator|->
name|chksum
operator|=
name|upgt_chksum_le
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
name|chan
argument_list|,
name|data_cmd
operator|->
name|buflen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|upgt_bulk_tx
argument_list|(
name|sc
argument_list|,
name|data_cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|upgt_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|enum
name|ieee80211_opmode
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|upgt_vap
modifier|*
name|uvp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
condition|)
comment|/* only one at a time */
return|return
name|NULL
return|;
name|uvp
operator|=
operator|(
expr|struct
name|upgt_vap
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|uvp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|vap
operator|=
operator|&
name|uvp
operator|->
name|vap
expr_stmt|;
comment|/* enable s/w bmiss handling for sta mode */
if|if
condition|(
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
operator||
name|IEEE80211_CLONE_NOBEACONS
argument_list|,
name|bssid
argument_list|,
name|mac
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* out of memory */
name|free
argument_list|(
name|uvp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* override state transition machine */
name|uvp
operator|->
name|newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|upgt_newstate
expr_stmt|;
comment|/* setup device rates */
name|upgt_setup_rates
argument_list|(
name|vap
argument_list|,
name|ic
argument_list|)
expr_stmt|;
comment|/* complete setup */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|ieee80211_media_change
argument_list|,
name|ieee80211_media_status
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
return|return
name|vap
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|upgt_vap
modifier|*
name|uvp
init|=
name|UPGT_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* do it in a process context */
name|sc
operator|->
name|sc_state
operator|=
name|nstate
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_led_ch
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_ch
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
comment|/* do not accept any frames if the device is down */
operator|(
name|void
operator|)
name|upgt_set_macfilter
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
name|upgt_set_led
argument_list|(
name|sc
argument_list|,
name|UPGT_LED_OFF
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_SCAN
case|:
name|upgt_set_chan
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_AUTH
case|:
name|upgt_set_chan
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_ASSOC
case|:
break|break;
case|case
name|IEEE80211_S_RUN
case|:
name|upgt_set_macfilter
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
name|upgt_set_led
argument_list|(
name|sc
argument_list|,
name|UPGT_LED_ON
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
name|uvp
operator|->
name|newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|upgt_vap
modifier|*
name|uvp
init|=
name|UPGT_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uvp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|upgt_set_multi
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_eeprom_parse
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|upgt_eeprom_header
modifier|*
name|eeprom_header
decl_stmt|;
name|struct
name|upgt_eeprom_option
modifier|*
name|eeprom_option
decl_stmt|;
name|uint16_t
name|option_len
decl_stmt|;
name|uint16_t
name|option_type
decl_stmt|;
name|uint16_t
name|preamble_len
decl_stmt|;
name|int
name|option_end
init|=
literal|0
decl_stmt|;
comment|/* calculate eeprom options start offset */
name|eeprom_header
operator|=
operator|(
expr|struct
name|upgt_eeprom_header
operator|*
operator|)
name|sc
operator|->
name|sc_eeprom
expr_stmt|;
name|preamble_len
operator|=
name|le16toh
argument_list|(
name|eeprom_header
operator|->
name|preamble_len
argument_list|)
expr_stmt|;
name|eeprom_option
operator|=
operator|(
expr|struct
name|upgt_eeprom_option
operator|*
operator|)
operator|(
name|sc
operator|->
name|sc_eeprom
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_eeprom_header
argument_list|)
operator|+
name|preamble_len
operator|)
operator|)
expr_stmt|;
while|while
condition|(
operator|!
name|option_end
condition|)
block|{
comment|/* sanity check */
if|if
condition|(
name|eeprom_option
operator|>=
operator|(
expr|struct
name|upgt_eeprom_option
operator|*
operator|)
operator|(
name|sc
operator|->
name|sc_eeprom
operator|+
name|UPGT_EEPROM_SIZE
operator|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* the eeprom option length is stored in words */
name|option_len
operator|=
operator|(
name|le16toh
argument_list|(
name|eeprom_option
operator|->
name|len
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
name|option_type
operator|=
name|le16toh
argument_list|(
name|eeprom_option
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
name|option_len
operator|==
literal|0
operator|||
name|option_len
operator|>=
name|UPGT_EEPROM_SIZE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|option_type
condition|)
block|{
case|case
name|UPGT_EEPROM_TYPE_NAME
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"EEPROM name len=%d\n"
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPGT_EEPROM_TYPE_SERIAL
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"EEPROM serial len=%d\n"
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPGT_EEPROM_TYPE_MAC
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"EEPROM mac len=%d\n"
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|sc_myaddr
argument_list|,
name|eeprom_option
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPGT_EEPROM_TYPE_HWRX
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"EEPROM hwrx len=%d\n"
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
name|upgt_eeprom_parse_hwrx
argument_list|(
name|sc
argument_list|,
name|eeprom_option
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPGT_EEPROM_TYPE_CHIP
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"EEPROM chip len=%d\n"
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPGT_EEPROM_TYPE_FREQ3
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"EEPROM freq3 len=%d\n"
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
name|upgt_eeprom_parse_freq3
argument_list|(
name|sc
argument_list|,
name|eeprom_option
operator|->
name|data
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPGT_EEPROM_TYPE_FREQ4
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"EEPROM freq4 len=%d\n"
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
name|upgt_eeprom_parse_freq4
argument_list|(
name|sc
argument_list|,
name|eeprom_option
operator|->
name|data
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPGT_EEPROM_TYPE_FREQ5
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"EEPROM freq5 len=%d\n"
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPGT_EEPROM_TYPE_FREQ6
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"EEPROM freq6 len=%d\n"
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
name|upgt_eeprom_parse_freq6
argument_list|(
name|sc
argument_list|,
name|eeprom_option
operator|->
name|data
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPGT_EEPROM_TYPE_END
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"EEPROM end len=%d\n"
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
name|option_end
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UPGT_EEPROM_TYPE_OFF
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"%s: EEPROM off without end option\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"EEPROM unknown type 0x%04x len=%d\n"
argument_list|,
name|option_type
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* jump to next EEPROM option */
name|eeprom_option
operator|=
operator|(
expr|struct
name|upgt_eeprom_option
operator|*
operator|)
operator|(
name|eeprom_option
operator|->
name|data
operator|+
name|option_len
operator|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_eeprom_parse_freq3
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|upgt_eeprom_freq3_header
modifier|*
name|freq3_header
decl_stmt|;
name|struct
name|upgt_lmac_freq3
modifier|*
name|freq3
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|elements
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|unsigned
name|channel
decl_stmt|;
name|freq3_header
operator|=
operator|(
expr|struct
name|upgt_eeprom_freq3_header
operator|*
operator|)
name|data
expr_stmt|;
name|freq3
operator|=
operator|(
expr|struct
name|upgt_lmac_freq3
operator|*
operator|)
operator|(
name|freq3_header
operator|+
literal|1
operator|)
expr_stmt|;
name|flags
operator|=
name|freq3_header
operator|->
name|flags
expr_stmt|;
name|elements
operator|=
name|freq3_header
operator|->
name|elements
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"flags=0x%02x elements=%d\n"
argument_list|,
name|flags
argument_list|,
name|elements
argument_list|)
expr_stmt|;
if|if
condition|(
name|elements
operator|>=
call|(
name|int
call|)
argument_list|(
name|UPGT_EEPROM_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|freq3
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elements
condition|;
name|i
operator|++
control|)
block|{
name|channel
operator|=
name|ieee80211_mhz2ieee
argument_list|(
name|le16toh
argument_list|(
name|freq3
index|[
name|i
index|]
operator|.
name|freq
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|>=
name|IEEE80211_CHAN_MAX
condition|)
continue|continue;
name|sc
operator|->
name|sc_eeprom_freq3
index|[
name|channel
index|]
operator|=
name|freq3
index|[
name|i
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"frequence=%d, channel=%d\n"
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|sc_eeprom_freq3
index|[
name|channel
index|]
operator|.
name|freq
argument_list|)
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|upgt_eeprom_parse_freq4
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|upgt_eeprom_freq4_header
modifier|*
name|freq4_header
decl_stmt|;
name|struct
name|upgt_eeprom_freq4_1
modifier|*
name|freq4_1
decl_stmt|;
name|struct
name|upgt_eeprom_freq4_2
modifier|*
name|freq4_2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|elements
decl_stmt|;
name|int
name|settings
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|unsigned
name|channel
decl_stmt|;
name|freq4_header
operator|=
operator|(
expr|struct
name|upgt_eeprom_freq4_header
operator|*
operator|)
name|data
expr_stmt|;
name|freq4_1
operator|=
operator|(
expr|struct
name|upgt_eeprom_freq4_1
operator|*
operator|)
operator|(
name|freq4_header
operator|+
literal|1
operator|)
expr_stmt|;
name|flags
operator|=
name|freq4_header
operator|->
name|flags
expr_stmt|;
name|elements
operator|=
name|freq4_header
operator|->
name|elements
expr_stmt|;
name|settings
operator|=
name|freq4_header
operator|->
name|settings
expr_stmt|;
comment|/* we need this value later */
name|sc
operator|->
name|sc_eeprom_freq6_settings
operator|=
name|freq4_header
operator|->
name|settings
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"flags=0x%02x elements=%d settings=%d\n"
argument_list|,
name|flags
argument_list|,
name|elements
argument_list|,
name|settings
argument_list|)
expr_stmt|;
if|if
condition|(
name|elements
operator|>=
call|(
name|int
call|)
argument_list|(
name|UPGT_EEPROM_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|freq4_1
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elements
condition|;
name|i
operator|++
control|)
block|{
name|channel
operator|=
name|ieee80211_mhz2ieee
argument_list|(
name|le16toh
argument_list|(
name|freq4_1
index|[
name|i
index|]
operator|.
name|freq
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|>=
name|IEEE80211_CHAN_MAX
condition|)
continue|continue;
name|freq4_2
operator|=
operator|(
expr|struct
name|upgt_eeprom_freq4_2
operator|*
operator|)
name|freq4_1
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|settings
condition|;
name|j
operator|++
control|)
block|{
name|sc
operator|->
name|sc_eeprom_freq4
index|[
name|channel
index|]
index|[
name|j
index|]
operator|.
name|cmd
operator|=
name|freq4_2
index|[
name|j
index|]
expr_stmt|;
name|sc
operator|->
name|sc_eeprom_freq4
index|[
name|channel
index|]
index|[
name|j
index|]
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"frequence=%d, channel=%d\n"
argument_list|,
name|le16toh
argument_list|(
name|freq4_1
index|[
name|i
index|]
operator|.
name|freq
argument_list|)
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|upgt_eeprom_parse_freq6
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|upgt_lmac_freq6
modifier|*
name|freq6
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|elements
decl_stmt|;
name|unsigned
name|channel
decl_stmt|;
name|freq6
operator|=
operator|(
expr|struct
name|upgt_lmac_freq6
operator|*
operator|)
name|data
expr_stmt|;
name|elements
operator|=
name|len
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_lmac_freq6
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"elements=%d\n"
argument_list|,
name|elements
argument_list|)
expr_stmt|;
if|if
condition|(
name|elements
operator|>=
call|(
name|int
call|)
argument_list|(
name|UPGT_EEPROM_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|freq6
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elements
condition|;
name|i
operator|++
control|)
block|{
name|channel
operator|=
name|ieee80211_mhz2ieee
argument_list|(
name|le16toh
argument_list|(
name|freq6
index|[
name|i
index|]
operator|.
name|freq
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|>=
name|IEEE80211_CHAN_MAX
condition|)
continue|continue;
name|sc
operator|->
name|sc_eeprom_freq6
index|[
name|channel
index|]
operator|=
name|freq6
index|[
name|i
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"frequence=%d, channel=%d\n"
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|sc_eeprom_freq6
index|[
name|channel
index|]
operator|.
name|freq
argument_list|)
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_eeprom_parse_hwrx
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|upgt_eeprom_option_hwrx
modifier|*
name|option_hwrx
decl_stmt|;
name|option_hwrx
operator|=
operator|(
expr|struct
name|upgt_eeprom_option_hwrx
operator|*
operator|)
name|data
expr_stmt|;
name|sc
operator|->
name|sc_eeprom_hwrx
operator|=
name|option_hwrx
operator|->
name|rxfilter
operator|-
name|UPGT_EEPROM_RX_CONST
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"hwrx option value=0x%04x\n"
argument_list|,
name|sc
operator|->
name|sc_eeprom_hwrx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_eeprom_read
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|upgt_data
modifier|*
name|data_cmd
decl_stmt|;
name|struct
name|upgt_lmac_mem
modifier|*
name|mem
decl_stmt|;
name|struct
name|upgt_lmac_eeprom
modifier|*
name|eeprom
decl_stmt|;
name|int
name|block
decl_stmt|,
name|error
decl_stmt|,
name|offset
decl_stmt|;
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|block
operator|=
name|UPGT_EEPROM_BLOCK_SIZE
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|UPGT_EEPROM_SIZE
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"request EEPROM block (offset=%d, len=%d)\n"
argument_list|,
name|offset
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|data_cmd
operator|=
name|upgt_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_cmd
operator|==
name|NULL
condition|)
block|{
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 		 * Transmit the URB containing the CMD data. 		 */
name|memset
argument_list|(
name|data_cmd
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
name|mem
operator|=
operator|(
expr|struct
name|upgt_lmac_mem
operator|*
operator|)
name|data_cmd
operator|->
name|buf
expr_stmt|;
name|mem
operator|->
name|addr
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_memaddr_frame_start
operator|+
name|UPGT_MEMSIZE_FRAME_HEAD
argument_list|)
expr_stmt|;
name|eeprom
operator|=
operator|(
expr|struct
name|upgt_lmac_eeprom
operator|*
operator|)
operator|(
name|mem
operator|+
literal|1
operator|)
expr_stmt|;
name|eeprom
operator|->
name|header1
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|eeprom
operator|->
name|header1
operator|.
name|type
operator|=
name|UPGT_H1_TYPE_CTRL
expr_stmt|;
name|eeprom
operator|->
name|header1
operator|.
name|len
operator|=
name|htole16
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_lmac_eeprom
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_lmac_header
argument_list|)
operator|)
operator|+
name|block
argument_list|)
expr_stmt|;
name|eeprom
operator|->
name|header2
operator|.
name|reqid
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_memaddr_frame_start
argument_list|)
expr_stmt|;
name|eeprom
operator|->
name|header2
operator|.
name|type
operator|=
name|htole16
argument_list|(
name|UPGT_H2_TYPE_EEPROM
argument_list|)
expr_stmt|;
name|eeprom
operator|->
name|header2
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|eeprom
operator|->
name|offset
operator|=
name|htole16
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|eeprom
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|data_cmd
operator|->
name|buflen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|eeprom
argument_list|)
operator|+
name|block
expr_stmt|;
name|mem
operator|->
name|chksum
operator|=
name|upgt_chksum_le
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
name|eeprom
argument_list|,
name|data_cmd
operator|->
name|buflen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|upgt_bulk_tx
argument_list|(
name|sc
argument_list|,
name|data_cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|mtx_sleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"eeprom_request"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout while waiting for EEPROM data\n"
argument_list|)
expr_stmt|;
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|offset
operator|+=
name|block
expr_stmt|;
if|if
condition|(
name|UPGT_EEPROM_SIZE
operator|-
name|offset
operator|<
name|block
condition|)
name|block
operator|=
name|UPGT_EEPROM_SIZE
operator|-
name|offset
expr_stmt|;
block|}
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When a rx data came in the function returns a mbuf and a rssi values.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|upgt_rxeof
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|struct
name|upgt_data
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|rssi
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|upgt_lmac_header
modifier|*
name|header
decl_stmt|;
name|struct
name|upgt_lmac_eeprom
modifier|*
name|eeprom
decl_stmt|;
name|uint8_t
name|h1_type
decl_stmt|;
name|uint16_t
name|h2_type
decl_stmt|;
name|int
name|actlen
decl_stmt|,
name|sumlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
operator|&
name|sumlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|UPGT_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|actlen
operator|<
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Check only at the very beginning.  */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|UPGT_FLAG_FWLOADED
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
name|data
operator|->
name|buf
argument_list|,
literal|"OK"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|UPGT_FLAG_FWLOADED
expr_stmt|;
name|wakeup_one
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|actlen
operator|<
operator|(
name|int
operator|)
name|UPGT_RX_MINSZ
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Check what type of frame came in. 	 */
name|header
operator|=
operator|(
expr|struct
name|upgt_lmac_header
operator|*
operator|)
operator|(
name|data
operator|->
name|buf
operator|+
literal|4
operator|)
expr_stmt|;
name|h1_type
operator|=
name|header
operator|->
name|header1
operator|.
name|type
expr_stmt|;
name|h2_type
operator|=
name|le16toh
argument_list|(
name|header
operator|->
name|header2
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|h1_type
operator|==
name|UPGT_H1_TYPE_CTRL
operator|&&
name|h2_type
operator|==
name|UPGT_H2_TYPE_EEPROM
condition|)
block|{
name|eeprom
operator|=
operator|(
expr|struct
name|upgt_lmac_eeprom
operator|*
operator|)
operator|(
name|data
operator|->
name|buf
operator|+
literal|4
operator|)
expr_stmt|;
name|uint16_t
name|eeprom_offset
init|=
name|le16toh
argument_list|(
name|eeprom
operator|->
name|offset
argument_list|)
decl_stmt|;
name|uint16_t
name|eeprom_len
init|=
name|le16toh
argument_list|(
name|eeprom
operator|->
name|len
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"received EEPROM block (offset=%d, len=%d)\n"
argument_list|,
name|eeprom_offset
argument_list|,
name|eeprom_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_eeprom
operator|+
name|eeprom_offset
argument_list|,
name|data
operator|->
name|buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_lmac_eeprom
argument_list|)
operator|+
literal|4
argument_list|,
name|eeprom_len
argument_list|)
expr_stmt|;
comment|/* EEPROM data has arrived in time, wakeup.  */
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h1_type
operator|==
name|UPGT_H1_TYPE_CTRL
operator|&&
name|h2_type
operator|==
name|UPGT_H2_TYPE_TX_DONE
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_XMIT
argument_list|,
literal|"%s: received 802.11 TX done\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|upgt_tx_done
argument_list|(
name|sc
argument_list|,
name|data
operator|->
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h1_type
operator|==
name|UPGT_H1_TYPE_RX_DATA
operator|||
name|h1_type
operator|==
name|UPGT_H1_TYPE_RX_DATA_MGMT
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_RECV
argument_list|,
literal|"%s: received 802.11 RX data\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m
operator|=
name|upgt_rx
argument_list|(
name|sc
argument_list|,
name|data
operator|->
name|buf
operator|+
literal|4
argument_list|,
name|le16toh
argument_list|(
name|header
operator|->
name|header1
operator|.
name|len
argument_list|)
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h1_type
operator|==
name|UPGT_H1_TYPE_CTRL
operator|&&
name|h2_type
operator|==
name|UPGT_H2_TYPE_STATS
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_STAT
argument_list|,
literal|"%s: received statistic data\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* TODO: what could we do with the statistic data? */
block|}
else|else
block|{
comment|/* ignore unknown frame types */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_INTR
argument_list|,
literal|"received unknown frame type 0x%02x\n"
argument_list|,
name|header
operator|->
name|header1
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The firmware awaits a checksum for each frame we send to it.  * The algorithm used therefor is uncommon but somehow similar to CRC32.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|upgt_chksum_le
parameter_list|(
specifier|const
name|uint32_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|uint32_t
name|crc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
control|)
block|{
name|crc
operator|=
name|htole32
argument_list|(
name|crc
operator|^
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
name|crc
operator|=
name|htole32
argument_list|(
operator|(
name|crc
operator|>>
literal|5
operator|)
operator|^
operator|(
name|crc
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|crc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|upgt_rx
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|,
name|int
name|pkglen
parameter_list|,
name|int
modifier|*
name|rssi
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|upgt_lmac_rx_desc
modifier|*
name|rxdesc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* 	 * don't pass packets to the ieee80211 framework if the driver isn't 	 * RUNNING. 	 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* access RX packet descriptor */
name|rxdesc
operator|=
operator|(
expr|struct
name|upgt_lmac_rx_desc
operator|*
operator|)
name|data
expr_stmt|;
comment|/* create mbuf which is suitable for strict alignment archs */
name|KASSERT
argument_list|(
operator|(
name|pkglen
operator|+
name|ETHER_ALIGN
operator|)
operator|<
name|MCLBYTES
argument_list|,
operator|(
literal|"A current mbuf storage is small (%d)"
operator|,
name|pkglen
operator|+
name|ETHER_ALIGN
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not create RX mbuf\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|rxdesc
operator|->
name|data
argument_list|,
name|pkglen
argument_list|)
expr_stmt|;
comment|/* trim FCS */
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pkglen
operator|-
name|IEEE80211_CRC_LEN
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|struct
name|upgt_rx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_rxtap
decl_stmt|;
name|tap
operator|->
name|wr_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wr_rate
operator|=
name|upgt_rx_rate
argument_list|(
name|sc
argument_list|,
name|rxdesc
operator|->
name|rate
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_antsignal
operator|=
name|rxdesc
operator|->
name|rssi
expr_stmt|;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_RX_PROC
argument_list|,
literal|"%s: RX done\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|rssi
operator|=
name|rxdesc
operator|->
name|rssi
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|upgt_rx_rate
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|int
name|rate
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
specifier|static
specifier|const
name|uint8_t
name|cck_upgt2rate
index|[
literal|4
index|]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint8_t
name|ofdm_upgt2rate
index|[
literal|12
index|]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|,
literal|12
block|,
literal|18
block|,
literal|24
block|,
literal|36
block|,
literal|48
block|,
literal|72
block|,
literal|96
block|,
literal|108
block|}
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11B
operator|&&
operator|!
operator|(
name|rate
operator|<
literal|0
operator|||
name|rate
operator|>
literal|3
operator|)
condition|)
return|return
name|cck_upgt2rate
index|[
name|rate
operator|&
literal|0xf
index|]
return|;
if|if
condition|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11G
operator|&&
operator|!
operator|(
name|rate
operator|<
literal|0
operator|||
name|rate
operator|>
literal|11
operator|)
condition|)
return|return
name|ofdm_upgt2rate
index|[
name|rate
operator|&
literal|0xf
index|]
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_tx_done
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|upgt_lmac_tx_done_desc
modifier|*
name|desc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|freed
init|=
literal|0
decl_stmt|;
name|UPGT_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|upgt_lmac_tx_done_desc
operator|*
operator|)
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPGT_TX_MAXCOUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|upgt_data
modifier|*
name|data_tx
init|=
operator|&
name|sc
operator|->
name|sc_tx_data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data_tx
operator|->
name|addr
operator|==
name|le32toh
argument_list|(
name|desc
operator|->
name|header2
operator|.
name|reqid
argument_list|)
condition|)
block|{
name|upgt_mem_free
argument_list|(
name|sc
argument_list|,
name|data_tx
operator|->
name|addr
argument_list|)
expr_stmt|;
name|data_tx
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
name|data_tx
operator|->
name|addr
operator|=
literal|0
expr_stmt|;
name|data_tx
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_TX_PROC
argument_list|,
literal|"TX done: memaddr=0x%08x, status=0x%04x, rssi=%d, "
argument_list|,
name|le32toh
argument_list|(
name|desc
operator|->
name|header2
operator|.
name|reqid
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|desc
operator|->
name|status
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|desc
operator|->
name|rssi
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_TX_PROC
argument_list|,
literal|"seq=%d\n"
argument_list|,
name|le16toh
argument_list|(
name|desc
operator|->
name|seq
argument_list|)
argument_list|)
expr_stmt|;
name|freed
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|freed
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|upgt_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_mem_free
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_memory
operator|.
name|pages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_memory
operator|.
name|page
index|[
name|i
index|]
operator|.
name|addr
operator|==
name|addr
condition|)
block|{
name|sc
operator|->
name|sc_memory
operator|.
name|page
index|[
name|i
index|]
operator|.
name|used
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not free memory address 0x%08x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_fw_load
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
name|struct
name|upgt_data
modifier|*
name|data_cmd
decl_stmt|;
name|struct
name|upgt_fw_x2_header
modifier|*
name|x2
decl_stmt|;
name|char
name|start_fwload_cmd
index|[]
init|=
block|{
literal|0x3c
block|,
literal|0x0d
block|}
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|int
name|n
decl_stmt|;
name|uint32_t
name|crc32
decl_stmt|;
name|fw
operator|=
name|firmware_get
argument_list|(
name|upgt_fwname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not read microcode %s\n"
argument_list|,
name|upgt_fwname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* send firmware start load command */
name|data_cmd
operator|=
name|upgt_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_cmd
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|data_cmd
operator|->
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|start_fwload_cmd
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data_cmd
operator|->
name|buf
argument_list|,
name|start_fwload_cmd
argument_list|,
name|data_cmd
operator|->
name|buflen
argument_list|)
expr_stmt|;
name|upgt_bulk_tx
argument_list|(
name|sc
argument_list|,
name|data_cmd
argument_list|)
expr_stmt|;
comment|/* send X2 header */
name|data_cmd
operator|=
name|upgt_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_cmd
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|data_cmd
operator|->
name|buflen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_fw_x2_header
argument_list|)
expr_stmt|;
name|x2
operator|=
operator|(
expr|struct
name|upgt_fw_x2_header
operator|*
operator|)
name|data_cmd
operator|->
name|buf
expr_stmt|;
name|memcpy
argument_list|(
name|x2
operator|->
name|signature
argument_list|,
name|UPGT_X2_SIGNATURE
argument_list|,
name|UPGT_X2_SIGNATURE_SIZE
argument_list|)
expr_stmt|;
name|x2
operator|->
name|startaddr
operator|=
name|htole32
argument_list|(
name|UPGT_MEMADDR_FIRMWARE_START
argument_list|)
expr_stmt|;
name|x2
operator|->
name|len
operator|=
name|htole32
argument_list|(
name|fw
operator|->
name|datasize
argument_list|)
expr_stmt|;
name|x2
operator|->
name|crc
operator|=
name|upgt_crc32_le
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|data_cmd
operator|->
name|buf
operator|+
name|UPGT_X2_SIGNATURE_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_fw_x2_header
argument_list|)
operator|-
name|UPGT_X2_SIGNATURE_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|upgt_bulk_tx
argument_list|(
name|sc
argument_list|,
name|data_cmd
argument_list|)
expr_stmt|;
comment|/* download firmware */
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|fw
operator|->
name|datasize
condition|;
name|offset
operator|+=
name|bsize
control|)
block|{
if|if
condition|(
name|fw
operator|->
name|datasize
operator|-
name|offset
operator|>
name|UPGT_FW_BLOCK_SIZE
condition|)
name|bsize
operator|=
name|UPGT_FW_BLOCK_SIZE
expr_stmt|;
else|else
name|bsize
operator|=
name|fw
operator|->
name|datasize
operator|-
name|offset
expr_stmt|;
name|data_cmd
operator|=
name|upgt_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_cmd
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|n
operator|=
name|upgt_fw_copy
argument_list|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|fw
operator|->
name|data
operator|+
name|offset
argument_list|,
name|data_cmd
operator|->
name|buf
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|data_cmd
operator|->
name|buflen
operator|=
name|bsize
expr_stmt|;
name|upgt_bulk_tx
argument_list|(
name|sc
argument_list|,
name|data_cmd
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"FW offset=%d, read=%d, sent=%d\n"
argument_list|,
name|offset
argument_list|,
name|n
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|bsize
operator|=
name|n
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"%s: firmware downloaded\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* load firmware */
name|data_cmd
operator|=
name|upgt_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_cmd
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|crc32
operator|=
name|upgt_crc32_le
argument_list|(
name|fw
operator|->
name|data
argument_list|,
name|fw
operator|->
name|datasize
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|data_cmd
operator|->
name|buf
operator|)
operator|)
operator|=
name|crc32
expr_stmt|;
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|data_cmd
operator|->
name|buf
operator|)
operator|+
literal|4
operator|)
operator|=
literal|'g'
expr_stmt|;
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|data_cmd
operator|->
name|buf
operator|)
operator|+
literal|5
operator|)
operator|=
literal|'\r'
expr_stmt|;
name|data_cmd
operator|->
name|buflen
operator|=
literal|6
expr_stmt|;
name|upgt_bulk_tx
argument_list|(
name|sc
argument_list|,
name|data_cmd
argument_list|)
expr_stmt|;
comment|/* waiting 'OK' response.  */
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UPGT_BULK_RX
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|mtx_sleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"upgtfw"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware load failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"%s: firmware loaded\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|fail
label|:
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|upgt_crc32_le
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint32_t
name|crc
decl_stmt|;
name|crc
operator|=
name|ether_crc32_le
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* apply final XOR value as common for CRC-32 */
name|crc
operator|=
name|htole32
argument_list|(
name|crc
operator|^
literal|0xffffffffU
argument_list|)
expr_stmt|;
return|return
operator|(
name|crc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * While copying the version 2 firmware, we need to replace two characters:  *  * 0x7e -> 0x7d 0x5e  * 0x7d -> 0x7d 0x5d  */
end_comment

begin_function
specifier|static
name|int
name|upgt_fw_copy
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|&&
name|j
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|src
index|[
name|i
index|]
condition|)
block|{
case|case
literal|0x7e
case|:
name|dst
index|[
name|j
index|]
operator|=
literal|0x7d
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|dst
index|[
name|j
index|]
operator|=
literal|0x5e
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
case|case
literal|0x7d
case|:
name|dst
index|[
name|j
index|]
operator|=
literal|0x7d
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|dst
index|[
name|j
index|]
operator|=
literal|0x5d
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
default|default:
name|dst
index|[
name|j
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_mem_init
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPGT_MEMORY_MAX_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_memory
operator|.
name|page
index|[
name|i
index|]
operator|.
name|used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The first memory page is always reserved for 			 * command data. 			 */
name|sc
operator|->
name|sc_memory
operator|.
name|page
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|sc
operator|->
name|sc_memaddr_frame_start
operator|+
name|MCLBYTES
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_memory
operator|.
name|page
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|sc
operator|->
name|sc_memory
operator|.
name|page
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|addr
operator|+
name|MCLBYTES
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_memory
operator|.
name|page
index|[
name|i
index|]
operator|.
name|addr
operator|+
name|MCLBYTES
operator|>=
name|sc
operator|->
name|sc_memaddr_frame_end
condition|)
break|break;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"memory address page %d=0x%08x\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|sc_memory
operator|.
name|page
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_memory
operator|.
name|pages
operator|=
name|i
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"memory pages=%d\n"
argument_list|,
name|sc
operator|->
name|sc_memory
operator|.
name|pages
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_fw_verify
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
specifier|const
name|struct
name|upgt_fw_bra_option
modifier|*
name|bra_opt
decl_stmt|;
specifier|const
name|struct
name|upgt_fw_bra_descr
modifier|*
name|descr
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|p
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|uc
decl_stmt|;
name|uint32_t
name|bra_option_type
decl_stmt|,
name|bra_option_len
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|int
name|bra_end
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|fw
operator|=
name|firmware_get
argument_list|(
name|upgt_fwname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not read microcode %s\n"
argument_list|,
name|upgt_fwname
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* 	 * Seek to beginning of Boot Record Area (BRA). 	 */
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|fw
operator|->
name|datasize
condition|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|uc
argument_list|)
control|)
block|{
name|uc
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|fw
operator|->
name|data
operator|+
name|offset
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|uc
operator|==
literal|0
condition|)
break|break;
block|}
for|for
control|(
init|;
name|offset
operator|<
name|fw
operator|->
name|datasize
condition|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|uc
argument_list|)
control|)
block|{
name|uc
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|fw
operator|->
name|data
operator|+
name|offset
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|uc
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|offset
operator|==
name|fw
operator|->
name|datasize
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware Boot Record Area not found\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"firmware Boot Record Area found at offset %d\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* 	 * Parse Boot Record Area (BRA) options. 	 */
while|while
condition|(
name|offset
operator|<
name|fw
operator|->
name|datasize
operator|&&
name|bra_end
operator|==
literal|0
condition|)
block|{
comment|/* get current BRA option */
name|p
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|fw
operator|->
name|data
operator|+
name|offset
expr_stmt|;
name|bra_opt
operator|=
operator|(
specifier|const
expr|struct
name|upgt_fw_bra_option
operator|*
operator|)
name|p
expr_stmt|;
name|bra_option_type
operator|=
name|le32toh
argument_list|(
name|bra_opt
operator|->
name|type
argument_list|)
expr_stmt|;
name|bra_option_len
operator|=
name|le32toh
argument_list|(
name|bra_opt
operator|->
name|len
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|uc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bra_option_type
condition|)
block|{
case|case
name|UPGT_BRA_TYPE_FW
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"UPGT_BRA_TYPE_FW len=%d\n"
argument_list|,
name|bra_option_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra_option_len
operator|!=
name|UPGT_BRA_FWTYPE_SIZE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"wrong UPGT_BRA_TYPE_FW len\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|UPGT_BRA_FWTYPE_LM86
argument_list|,
name|bra_opt
operator|->
name|data
argument_list|,
name|bra_option_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_fw_type
operator|=
name|UPGT_FWTYPE_LM86
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|UPGT_BRA_FWTYPE_LM87
argument_list|,
name|bra_opt
operator|->
name|data
argument_list|,
name|bra_option_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_fw_type
operator|=
name|UPGT_FWTYPE_LM87
expr_stmt|;
break|break;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unsupported firmware type\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|fail
goto|;
case|case
name|UPGT_BRA_TYPE_VERSION
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"UPGT_BRA_TYPE_VERSION len=%d\n"
argument_list|,
name|bra_option_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPGT_BRA_TYPE_DEPIF
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"UPGT_BRA_TYPE_DEPIF len=%d\n"
argument_list|,
name|bra_option_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPGT_BRA_TYPE_EXPIF
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"UPGT_BRA_TYPE_EXPIF len=%d\n"
argument_list|,
name|bra_option_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPGT_BRA_TYPE_DESCR
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"UPGT_BRA_TYPE_DESCR len=%d\n"
argument_list|,
name|bra_option_len
argument_list|)
expr_stmt|;
name|descr
operator|=
operator|(
specifier|const
expr|struct
name|upgt_fw_bra_descr
operator|*
operator|)
name|bra_opt
operator|->
name|data
expr_stmt|;
name|sc
operator|->
name|sc_memaddr_frame_start
operator|=
name|le32toh
argument_list|(
name|descr
operator|->
name|memaddr_space_start
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_memaddr_frame_end
operator|=
name|le32toh
argument_list|(
name|descr
operator|->
name|memaddr_space_end
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"memory address space start=0x%08x\n"
argument_list|,
name|sc
operator|->
name|sc_memaddr_frame_start
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"memory address space end=0x%08x\n"
argument_list|,
name|sc
operator|->
name|sc_memaddr_frame_end
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPGT_BRA_TYPE_END
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"UPGT_BRA_TYPE_END len=%d\n"
argument_list|,
name|bra_option_len
argument_list|)
expr_stmt|;
name|bra_end
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"unknown BRA option len=%d\n"
argument_list|,
name|bra_option_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* jump to next BRA option */
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|upgt_fw_bra_option
argument_list|)
operator|+
name|bra_option_len
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"%s: firmware verified"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|fail
label|:
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_bulk_tx
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|upgt_data
modifier|*
name|data
parameter_list|)
block|{
name|UPGT_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_pending
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UPGT_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_pending
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|UPGT_BULK_TX
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_device_reset
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|upgt_data
modifier|*
name|data
decl_stmt|;
name|char
name|init_cmd
index|[]
init|=
block|{
literal|0x7e
block|,
literal|0x7e
block|,
literal|0x7e
block|,
literal|0x7e
block|}
decl_stmt|;
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|data
operator|=
name|upgt_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|data
operator|->
name|buf
argument_list|,
name|init_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|init_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|init_cmd
argument_list|)
expr_stmt|;
name|upgt_bulk_tx
argument_list|(
name|sc
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_FW
argument_list|,
literal|"%s: device initialized\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_alloc_tx
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_active
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_pending
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPGT_TX_MAXCOUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|upgt_data
modifier|*
name|data
init|=
operator|&
name|sc
operator|->
name|sc_tx_data
index|[
name|i
index|]
decl_stmt|;
name|data
operator|->
name|buf
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|sc_tx_dma_buf
operator|)
operator|+
operator|(
name|i
operator|*
name|MCLBYTES
operator|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UPGT_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_inactive
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_alloc_rx
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_active
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_inactive
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPGT_RX_MAXCOUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|upgt_data
modifier|*
name|data
init|=
operator|&
name|sc
operator|->
name|sc_rx_data
index|[
name|i
index|]
decl_stmt|;
name|data
operator|->
name|buf
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|sc_rx_dma_buf
operator|)
operator|+
operator|(
name|i
operator|*
name|MCLBYTES
operator|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_inactive
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|unsigned
name|int
name|x
decl_stmt|;
comment|/* 	 * Prevent further allocations from RX/TX/CMD 	 * data lists and ioctls 	 */
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|UPGT_FLAG_DETACHED
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_active
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_pending
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_active
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_inactive
argument_list|)
expr_stmt|;
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|upgt_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_led_ch
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_ch
argument_list|)
expr_stmt|;
comment|/* drain USB transfers */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|UPGT_N_XFERS
condition|;
name|x
operator|++
control|)
name|usbd_transfer_drain
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|x
index|]
argument_list|)
expr_stmt|;
comment|/* free data buffers */
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|upgt_free_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|upgt_free_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* free USB transfers and some data buffers */
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|UPGT_N_XFERS
argument_list|)
expr_stmt|;
name|ieee80211_ifdetach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_free_rx
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPGT_RX_MAXCOUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|upgt_data
modifier|*
name|data
init|=
operator|&
name|sc
operator|->
name|sc_rx_data
index|[
name|i
index|]
decl_stmt|;
name|data
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_free_tx
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPGT_TX_MAXCOUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|upgt_data
modifier|*
name|data
init|=
operator|&
name|sc
operator|->
name|sc_tx_data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|ni
operator|!=
name|NULL
condition|)
name|ieee80211_free_node
argument_list|(
name|data
operator|->
name|ni
argument_list|)
expr_stmt|;
name|data
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_abort_xfers_locked
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|UPGT_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* abort any pending transfers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPGT_N_XFERS
condition|;
name|i
operator|++
control|)
name|usbd_transfer_stop
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_abort_xfers
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|upgt_abort_xfers_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|UPGT_SYSCTL_STAT_ADD32
parameter_list|(
name|c
parameter_list|,
name|h
parameter_list|,
name|n
parameter_list|,
name|p
parameter_list|,
name|d
parameter_list|)
define|\
value|SYSCTL_ADD_UINT(c, h, OID_AUTO, n, CTLFLAG_RD, p, 0, d)
end_define

begin_function
specifier|static
name|void
name|upgt_sysctl_node
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|;
name|struct
name|upgt_stat
modifier|*
name|stats
decl_stmt|;
name|stats
operator|=
operator|&
name|sc
operator|->
name|sc_stat
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"UPGT statistics"
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|UPGT_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"tx_active"
argument_list|,
operator|&
name|stats
operator|->
name|st_tx_active
argument_list|,
literal|"Active numbers in TX queue"
argument_list|)
expr_stmt|;
name|UPGT_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"tx_inactive"
argument_list|,
operator|&
name|stats
operator|->
name|st_tx_inactive
argument_list|,
literal|"Inactive numbers in TX queue"
argument_list|)
expr_stmt|;
name|UPGT_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"tx_pending"
argument_list|,
operator|&
name|stats
operator|->
name|st_tx_pending
argument_list|,
literal|"Pending numbers in TX queue"
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|UPGT_SYSCTL_STAT_ADD32
end_undef

begin_function
specifier|static
name|struct
name|upgt_data
modifier|*
name|_upgt_getbuf
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|upgt_data
modifier|*
name|bf
decl_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UPGT_STAT_DEC
argument_list|(
name|sc
argument_list|,
name|st_tx_inactive
argument_list|)
expr_stmt|;
block|}
else|else
name|bf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_XMIT
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|__func__
argument_list|,
literal|"out of xmit buffers"
argument_list|)
expr_stmt|;
return|return
operator|(
name|bf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|upgt_data
modifier|*
name|upgt_getbuf
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|upgt_data
modifier|*
name|bf
decl_stmt|;
name|UPGT_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bf
operator|=
name|_upgt_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_XMIT
argument_list|,
literal|"%s: stop queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
return|return
operator|(
name|bf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|upgt_data
modifier|*
name|upgt_gettxbuf
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|upgt_data
modifier|*
name|bf
decl_stmt|;
name|UPGT_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bf
operator|=
name|upgt_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bf
operator|->
name|addr
operator|=
name|upgt_mem_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|addr
operator|==
literal|0
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_XMIT
argument_list|,
literal|"%s: no free prism memory!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|bf
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UPGT_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_inactive
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
condition|)
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|bf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgt_tx_start
parameter_list|(
name|struct
name|upgt_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|upgt_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|upgt_lmac_mem
modifier|*
name|mem
decl_stmt|;
name|struct
name|upgt_lmac_tx_desc
modifier|*
name|txdesc
decl_stmt|;
name|UPGT_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|upgt_set_led
argument_list|(
name|sc
argument_list|,
name|UPGT_LED_BLINK
argument_list|)
expr_stmt|;
comment|/* 	 * Software crypto. 	 */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PROTECTED
condition|)
block|{
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"ieee80211_crypto_encap returns NULL.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* in case packet header moved, reset pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* Transmit the URB containing the TX data.  */
name|memset
argument_list|(
name|data
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
name|mem
operator|=
operator|(
expr|struct
name|upgt_lmac_mem
operator|*
operator|)
name|data
operator|->
name|buf
expr_stmt|;
name|mem
operator|->
name|addr
operator|=
name|htole32
argument_list|(
name|data
operator|->
name|addr
argument_list|)
expr_stmt|;
name|txdesc
operator|=
operator|(
expr|struct
name|upgt_lmac_tx_desc
operator|*
operator|)
operator|(
name|mem
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
operator|)
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
block|{
comment|/* mgmt frames  */
name|txdesc
operator|->
name|header1
operator|.
name|flags
operator|=
name|UPGT_H1_FLAGS_TX_MGMT
expr_stmt|;
comment|/* always send mgmt frames at lowest rate (DS1) */
name|memset
argument_list|(
name|txdesc
operator|->
name|rates
argument_list|,
literal|0x10
argument_list|,
sizeof|sizeof
argument_list|(
name|txdesc
operator|->
name|rates
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* data frames  */
name|txdesc
operator|->
name|header1
operator|.
name|flags
operator|=
name|UPGT_H1_FLAGS_TX_DATA
expr_stmt|;
name|memcpy
argument_list|(
name|txdesc
operator|->
name|rates
argument_list|,
name|sc
operator|->
name|sc_cur_rateset
argument_list|,
sizeof|sizeof
argument_list|(
name|txdesc
operator|->
name|rates
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|txdesc
operator|->
name|header1
operator|.
name|type
operator|=
name|UPGT_H1_TYPE_TX_DATA
expr_stmt|;
name|txdesc
operator|->
name|header1
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|txdesc
operator|->
name|header2
operator|.
name|reqid
operator|=
name|htole32
argument_list|(
name|data
operator|->
name|addr
argument_list|)
expr_stmt|;
name|txdesc
operator|->
name|header2
operator|.
name|type
operator|=
name|htole16
argument_list|(
name|UPGT_H2_TYPE_TX_ACK_YES
argument_list|)
expr_stmt|;
name|txdesc
operator|->
name|header2
operator|.
name|flags
operator|=
name|htole16
argument_list|(
name|UPGT_H2_FLAGS_TX_ACK_YES
argument_list|)
expr_stmt|;
name|txdesc
operator|->
name|type
operator|=
name|htole32
argument_list|(
name|UPGT_TX_DESC_TYPE_DATA
argument_list|)
expr_stmt|;
name|txdesc
operator|->
name|pad3
index|[
literal|0
index|]
operator|=
name|UPGT_TX_DESC_PAD3_SIZE
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|struct
name|upgt_tx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_txtap
decl_stmt|;
name|tap
operator|->
name|wt_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wt_rate
operator|=
literal|0
expr_stmt|;
comment|/* XXX where to get from? */
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* copy frame below our TX descriptor header */
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|data
operator|->
name|buf
operator|+
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|txdesc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* calculate frame size */
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|txdesc
argument_list|)
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* we need to align the frame to a 4 byte boundary */
name|len
operator|=
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* calculate frame checksum */
name|mem
operator|->
name|chksum
operator|=
name|upgt_chksum_le
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
name|txdesc
argument_list|,
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|ni
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|data
operator|->
name|buflen
operator|=
name|len
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_XMIT
argument_list|,
literal|"%s: TX start data sending (%d bytes)\n"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|len
operator|<=
name|MCLBYTES
argument_list|,
operator|(
literal|"mbuf is small for saving data"
operator|)
argument_list|)
expr_stmt|;
name|upgt_bulk_tx
argument_list|(
name|sc
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * If we don't regulary read the device statistics, the RX queue 	 * will stall.  It's strange, but it works, so we keep reading 	 * the statistics here.  *shrug* 	 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_opackets
operator|%
name|UPGT_TX_STAT_INTERVAL
operator|)
condition|)
name|upgt_get_stats
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_bulk_rx_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|upgt_data
modifier|*
name|data
decl_stmt|;
name|int8_t
name|nf
decl_stmt|;
name|int
name|rssi
init|=
operator|-
literal|1
decl_stmt|;
name|UPGT_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|data
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_active
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
goto|goto
name|setup
goto|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|m
operator|=
name|upgt_rxeof
argument_list|(
name|xfer
argument_list|,
name|data
argument_list|,
operator|&
name|rssi
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_inactive
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|USB_ST_SETUP
case|:
name|setup
label|:
name|data
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_inactive
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_inactive
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_active
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|data
operator|->
name|buf
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* 		 * To avoid LOR we should unlock our private mutex here to call 		 * ieee80211_input() because here is at the end of a USB 		 * callback and safe to unlock. 		 */
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
operator|(
expr|struct
name|ieee80211_frame_min
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
name|nf
operator|=
operator|-
literal|95
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
comment|/* node is no longer needed */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ieee80211_input_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
operator|&&
operator|!
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|upgt_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* needs it to the inactive queue due to a error.  */
name|data
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_active
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_inactive
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|setup
goto|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|upgt_bulk_tx_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|upgt_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|upgt_data
modifier|*
name|data
decl_stmt|;
name|UPGT_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|data
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_active
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
goto|goto
name|setup
goto|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UPGT_STAT_DEC
argument_list|(
name|sc
argument_list|,
name|st_tx_active
argument_list|)
expr_stmt|;
name|upgt_txeof
argument_list|(
name|xfer
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_inactive
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UPGT_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_inactive
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|USB_ST_SETUP
case|:
name|setup
label|:
name|data
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UPGT_DEBUG_XMIT
argument_list|,
literal|"%s: empty pending queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_pending
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UPGT_STAT_DEC
argument_list|(
name|sc
argument_list|,
name|st_tx_pending
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_active
argument_list|,
name|data
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UPGT_STAT_INC
argument_list|(
name|sc
argument_list|,
name|st_tx_active
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|data
operator|->
name|buf
argument_list|,
name|data
operator|->
name|buflen
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|UPGT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|upgt_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|UPGT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|data
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_active
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
goto|goto
name|setup
goto|;
if|if
condition|(
name|data
operator|->
name|ni
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|data
operator|->
name|ni
argument_list|)
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|setup
goto|;
block|}
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|upgt_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|upgt_match
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|upgt_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|upgt_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|upgt_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"upgt"
block|,
operator|.
name|methods
operator|=
name|upgt_methods
block|,
operator|.
name|size
operator|=
expr|sizeof
operator|(
expr|struct
name|upgt_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|upgt_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_upgt
argument_list|,
name|uhub
argument_list|,
name|upgt_driver
argument_list|,
name|upgt_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|if_upgt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|if_upgt
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|if_upgt
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|if_upgt
argument_list|,
name|upgtfw_fw
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

