begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2009 Andrew Thompson (thompsa@FreeBSD.org)  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/net/usb_ethernet.h>
end_include

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net
argument_list|,
name|OID_AUTO
argument_list|,
name|ue
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"USB Ethernet parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|UE_LOCK
parameter_list|(
name|_ue
parameter_list|)
value|mtx_lock((_ue)->ue_mtx)
end_define

begin_define
define|#
directive|define
name|UE_UNLOCK
parameter_list|(
name|_ue
parameter_list|)
value|mtx_unlock((_ue)->ue_mtx)
end_define

begin_define
define|#
directive|define
name|UE_LOCK_ASSERT
parameter_list|(
name|_ue
parameter_list|,
name|t
parameter_list|)
value|mtx_assert((_ue)->ue_mtx, t)
end_define

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|uether
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|uether
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|unrhdr
modifier|*
name|ueunit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_proc_callback_t
name|ue_attach_post_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_proc_callback_t
name|ue_promisc_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_proc_callback_t
name|ue_setmulti_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_proc_callback_t
name|ue_ifmedia_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_proc_callback_t
name|ue_tick_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_proc_callback_t
name|ue_start_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_proc_callback_t
name|ue_stop_task
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ue_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ue_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ue_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ue_watchdog
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Return values:  *    0: success  * Else: device has been detached  */
end_comment

begin_function
name|uint8_t
name|uether_pause
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|,
name|unsigned
name|int
name|_ticks
parameter_list|)
block|{
if|if
condition|(
name|usb_proc_is_gone
argument_list|(
operator|&
name|ue
operator|->
name|ue_tq
argument_list|)
condition|)
block|{
comment|/* nothing to do */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|usb_pause_mtx
argument_list|(
name|ue
operator|->
name|ue_mtx
argument_list|,
name|_ticks
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ue_queue_command
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|,
name|usb_proc_callback_t
modifier|*
name|fn
parameter_list|,
name|struct
name|usb_proc_msg
modifier|*
name|t0
parameter_list|,
name|struct
name|usb_proc_msg
modifier|*
name|t1
parameter_list|)
block|{
name|struct
name|usb_ether_cfg_task
modifier|*
name|task
decl_stmt|;
name|UE_LOCK_ASSERT
argument_list|(
name|ue
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb_proc_is_gone
argument_list|(
operator|&
name|ue
operator|->
name|ue_tq
argument_list|)
condition|)
block|{
return|return;
comment|/* nothing to do */
block|}
comment|/*  	 * NOTE: The task cannot get executed before we drop the 	 * "sc_mtx" mutex. It is safe to update fields in the message 	 * structure after that the message got queued. 	 */
name|task
operator|=
operator|(
expr|struct
name|usb_ether_cfg_task
operator|*
operator|)
name|usb_proc_msignal
argument_list|(
operator|&
name|ue
operator|->
name|ue_tq
argument_list|,
name|t0
argument_list|,
name|t1
argument_list|)
expr_stmt|;
comment|/* Setup callback and self pointers */
name|task
operator|->
name|hdr
operator|.
name|pm_callback
operator|=
name|fn
expr_stmt|;
name|task
operator|->
name|ue
operator|=
name|ue
expr_stmt|;
comment|/* 	 * Start and stop must be synchronous! 	 */
if|if
condition|(
operator|(
name|fn
operator|==
name|ue_start_task
operator|)
operator|||
operator|(
name|fn
operator|==
name|ue_stop_task
operator|)
condition|)
name|usb_proc_mwait
argument_list|(
operator|&
name|ue
operator|->
name|ue_tq
argument_list|,
name|t0
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ifnet
modifier|*
name|uether_getifp
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
return|return
operator|(
name|ue
operator|->
name|ue_ifp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mii_data
modifier|*
name|uether_getmii
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
return|return
operator|(
name|device_get_softc
argument_list|(
name|ue
operator|->
name|ue_miibus
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|uether_getsc
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
return|return
operator|(
name|ue
operator|->
name|ue_sc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ue_sysctl_parent
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|usb_ether
modifier|*
name|ue
init|=
name|arg1
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|device_get_nameunit
argument_list|(
name|ue
operator|->
name|ue_dev
argument_list|)
expr_stmt|;
return|return
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|uether_ifattach
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* check some critical parameters */
if|if
condition|(
operator|(
name|ue
operator|->
name|ue_dev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ue
operator|->
name|ue_udev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ue
operator|->
name|ue_mtx
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ue
operator|->
name|ue_methods
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|usb_proc_create
argument_list|(
operator|&
name|ue
operator|->
name|ue_tq
argument_list|,
name|ue
operator|->
name|ue_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|ue
operator|->
name|ue_dev
argument_list|)
argument_list|,
name|USB_PRI_MED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|ue
operator|->
name|ue_dev
argument_list|,
literal|"could not setup taskqueue\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* fork rest of the attach code */
name|UE_LOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|ue_queue_command
argument_list|(
name|ue
argument_list|,
name|ue_attach_post_task
argument_list|,
operator|&
name|ue
operator|->
name|ue_sync_task
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|,
operator|&
name|ue
operator|->
name|ue_sync_task
index|[
literal|1
index|]
operator|.
name|hdr
argument_list|)
expr_stmt|;
name|UE_UNLOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|error
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ue_attach_post_task
parameter_list|(
name|struct
name|usb_proc_msg
modifier|*
name|_task
parameter_list|)
block|{
name|struct
name|usb_ether_cfg_task
modifier|*
name|task
init|=
operator|(
expr|struct
name|usb_ether_cfg_task
operator|*
operator|)
name|_task
decl_stmt|;
name|struct
name|usb_ether
modifier|*
name|ue
init|=
name|task
operator|->
name|ue
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|num
index|[
literal|14
index|]
decl_stmt|;
comment|/* sufficient for 32 bits */
comment|/* first call driver's post attach routine */
name|ue
operator|->
name|ue_methods
operator|->
name|ue_attach_post
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|UE_UNLOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|ue
operator|->
name|ue_unit
operator|=
name|alloc_unr
argument_list|(
name|ueunit
argument_list|)
expr_stmt|;
name|usb_callout_init_mtx
argument_list|(
operator|&
name|ue
operator|->
name|ue_watchdog
argument_list|,
name|ue
operator|->
name|ue_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|ue
operator|->
name|ue_sysctl_ctx
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ue
operator|->
name|ue_dev
argument_list|,
literal|"could not allocate ifnet\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|ue
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"ue"
argument_list|,
name|ue
operator|->
name|ue_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
if|if
condition|(
name|ue
operator|->
name|ue_methods
operator|->
name|ue_ioctl
operator|!=
name|NULL
condition|)
name|ifp
operator|->
name|if_ioctl
operator|=
name|ue
operator|->
name|ue_methods
operator|->
name|ue_ioctl
expr_stmt|;
else|else
name|ifp
operator|->
name|if_ioctl
operator|=
name|uether_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ue_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ue_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|IFQ_MAXLEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ue
operator|->
name|ue_ifp
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|ue
operator|->
name|ue_methods
operator|->
name|ue_mii_upd
operator|!=
name|NULL
operator|&&
name|ue
operator|->
name|ue_methods
operator|->
name|ue_mii_sts
operator|!=
name|NULL
condition|)
block|{
name|newbus_xlock
argument_list|()
expr_stmt|;
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|ue
operator|->
name|ue_dev
argument_list|,
operator|&
name|ue
operator|->
name|ue_miibus
argument_list|,
name|ue_ifmedia_upd
argument_list|,
name|ue
operator|->
name|ue_methods
operator|->
name|ue_mii_sts
argument_list|)
expr_stmt|;
name|newbus_xunlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|ue
operator|->
name|ue_dev
argument_list|,
literal|"MII without any PHY\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"<USB Ethernet> on %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|ue
operator|->
name|ue_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ue
operator|->
name|ue_eaddr
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|num
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|ue
operator|->
name|ue_unit
argument_list|)
expr_stmt|;
name|ue
operator|->
name|ue_sysctl_oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|ue
operator|->
name|ue_sysctl_ctx
argument_list|,
operator|&
name|SYSCTL_NODE_CHILDREN
argument_list|(
name|_net
argument_list|,
name|ue
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|num
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|ue
operator|->
name|ue_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|ue
operator|->
name|ue_sysctl_oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"%parent"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|ue
argument_list|,
literal|0
argument_list|,
name|ue_sysctl_parent
argument_list|,
literal|"A"
argument_list|,
literal|"parent device"
argument_list|)
expr_stmt|;
name|UE_LOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
return|return;
name|error
label|:
name|free_unr
argument_list|(
name|ueunit
argument_list|,
name|ue
operator|->
name|ue_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ue
operator|->
name|ue_ifp
operator|!=
name|NULL
condition|)
block|{
name|if_free
argument_list|(
name|ue
operator|->
name|ue_ifp
argument_list|)
expr_stmt|;
name|ue
operator|->
name|ue_ifp
operator|=
name|NULL
expr_stmt|;
block|}
name|UE_LOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|uether_ifdetach
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* wait for any post attach or other command to complete */
name|usb_proc_drain
argument_list|(
operator|&
name|ue
operator|->
name|ue_tq
argument_list|)
expr_stmt|;
comment|/* read "ifnet" pointer after taskqueue drain */
name|ifp
operator|=
name|ue
operator|->
name|ue_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
comment|/* we are not running any more */
name|UE_LOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|UE_UNLOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
comment|/* drain any callouts */
name|usb_callout_drain
argument_list|(
operator|&
name|ue
operator|->
name|ue_watchdog
argument_list|)
expr_stmt|;
comment|/* detach miibus */
if|if
condition|(
name|ue
operator|->
name|ue_miibus
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * It is up to the callers to provide the correct 			 * newbus locking. 			 */
name|device_delete_child
argument_list|(
name|ue
operator|->
name|ue_dev
argument_list|,
name|ue
operator|->
name|ue_miibus
argument_list|)
expr_stmt|;
block|}
comment|/* detach ethernet */
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* free interface instance */
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* free sysctl */
name|sysctl_ctx_free
argument_list|(
operator|&
name|ue
operator|->
name|ue_sysctl_ctx
argument_list|)
expr_stmt|;
comment|/* free unit */
name|free_unr
argument_list|(
name|ueunit
argument_list|,
name|ue
operator|->
name|ue_unit
argument_list|)
expr_stmt|;
block|}
comment|/* free taskqueue, if any */
name|usb_proc_free
argument_list|(
operator|&
name|ue
operator|->
name|ue_tq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint8_t
name|uether_is_gone
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
return|return
operator|(
name|usb_proc_is_gone
argument_list|(
operator|&
name|ue
operator|->
name|ue_tq
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ue_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|usb_ether
modifier|*
name|ue
init|=
name|arg
decl_stmt|;
name|UE_LOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|ue_queue_command
argument_list|(
name|ue
argument_list|,
name|ue_start_task
argument_list|,
operator|&
name|ue
operator|->
name|ue_sync_task
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|,
operator|&
name|ue
operator|->
name|ue_sync_task
index|[
literal|1
index|]
operator|.
name|hdr
argument_list|)
expr_stmt|;
name|UE_UNLOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ue_start_task
parameter_list|(
name|struct
name|usb_proc_msg
modifier|*
name|_task
parameter_list|)
block|{
name|struct
name|usb_ether_cfg_task
modifier|*
name|task
init|=
operator|(
expr|struct
name|usb_ether_cfg_task
operator|*
operator|)
name|_task
decl_stmt|;
name|struct
name|usb_ether
modifier|*
name|ue
init|=
name|task
operator|->
name|ue
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ue
operator|->
name|ue_ifp
decl_stmt|;
name|UE_LOCK_ASSERT
argument_list|(
name|ue
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ue
operator|->
name|ue_methods
operator|->
name|ue_init
argument_list|(
name|ue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ue
operator|->
name|ue_methods
operator|->
name|ue_tick
operator|!=
name|NULL
condition|)
name|usb_callout_reset
argument_list|(
operator|&
name|ue
operator|->
name|ue_watchdog
argument_list|,
name|hz
argument_list|,
name|ue_watchdog
argument_list|,
name|ue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ue_stop_task
parameter_list|(
name|struct
name|usb_proc_msg
modifier|*
name|_task
parameter_list|)
block|{
name|struct
name|usb_ether_cfg_task
modifier|*
name|task
init|=
operator|(
expr|struct
name|usb_ether_cfg_task
operator|*
operator|)
name|_task
decl_stmt|;
name|struct
name|usb_ether
modifier|*
name|ue
init|=
name|task
operator|->
name|ue
decl_stmt|;
name|UE_LOCK_ASSERT
argument_list|(
name|ue
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|usb_callout_stop
argument_list|(
operator|&
name|ue
operator|->
name|ue_watchdog
argument_list|)
expr_stmt|;
name|ue
operator|->
name|ue_methods
operator|->
name|ue_stop
argument_list|(
name|ue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ue_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|usb_ether
modifier|*
name|ue
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|UE_LOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|ue
operator|->
name|ue_methods
operator|->
name|ue_start
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|UE_UNLOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ue_promisc_task
parameter_list|(
name|struct
name|usb_proc_msg
modifier|*
name|_task
parameter_list|)
block|{
name|struct
name|usb_ether_cfg_task
modifier|*
name|task
init|=
operator|(
expr|struct
name|usb_ether_cfg_task
operator|*
operator|)
name|_task
decl_stmt|;
name|struct
name|usb_ether
modifier|*
name|ue
init|=
name|task
operator|->
name|ue
decl_stmt|;
name|ue
operator|->
name|ue_methods
operator|->
name|ue_setpromisc
argument_list|(
name|ue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ue_setmulti_task
parameter_list|(
name|struct
name|usb_proc_msg
modifier|*
name|_task
parameter_list|)
block|{
name|struct
name|usb_ether_cfg_task
modifier|*
name|task
init|=
operator|(
expr|struct
name|usb_ether_cfg_task
operator|*
operator|)
name|_task
decl_stmt|;
name|struct
name|usb_ether
modifier|*
name|ue
init|=
name|task
operator|->
name|ue
decl_stmt|;
name|ue
operator|->
name|ue_methods
operator|->
name|ue_setmulti
argument_list|(
name|ue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ue_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|usb_ether
modifier|*
name|ue
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* Defer to process context */
name|UE_LOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|ue_queue_command
argument_list|(
name|ue
argument_list|,
name|ue_ifmedia_task
argument_list|,
operator|&
name|ue
operator|->
name|ue_media_task
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|,
operator|&
name|ue
operator|->
name|ue_media_task
index|[
literal|1
index|]
operator|.
name|hdr
argument_list|)
expr_stmt|;
name|UE_UNLOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ue_ifmedia_task
parameter_list|(
name|struct
name|usb_proc_msg
modifier|*
name|_task
parameter_list|)
block|{
name|struct
name|usb_ether_cfg_task
modifier|*
name|task
init|=
operator|(
expr|struct
name|usb_ether_cfg_task
operator|*
operator|)
name|_task
decl_stmt|;
name|struct
name|usb_ether
modifier|*
name|ue
init|=
name|task
operator|->
name|ue
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ue
operator|->
name|ue_ifp
decl_stmt|;
name|ue
operator|->
name|ue_methods
operator|->
name|ue_mii_upd
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ue_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|usb_ether
modifier|*
name|ue
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ue
operator|->
name|ue_ifp
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|ue_queue_command
argument_list|(
name|ue
argument_list|,
name|ue_tick_task
argument_list|,
operator|&
name|ue
operator|->
name|ue_tick_task
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|,
operator|&
name|ue
operator|->
name|ue_tick_task
index|[
literal|1
index|]
operator|.
name|hdr
argument_list|)
expr_stmt|;
name|usb_callout_reset
argument_list|(
operator|&
name|ue
operator|->
name|ue_watchdog
argument_list|,
name|hz
argument_list|,
name|ue_watchdog
argument_list|,
name|ue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ue_tick_task
parameter_list|(
name|struct
name|usb_proc_msg
modifier|*
name|_task
parameter_list|)
block|{
name|struct
name|usb_ether_cfg_task
modifier|*
name|task
init|=
operator|(
expr|struct
name|usb_ether_cfg_task
operator|*
operator|)
name|_task
decl_stmt|;
name|struct
name|usb_ether
modifier|*
name|ue
init|=
name|task
operator|->
name|ue
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ue
operator|->
name|ue_ifp
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|ue
operator|->
name|ue_methods
operator|->
name|ue_tick
argument_list|(
name|ue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|uether_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|usb_ether
modifier|*
name|ue
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|UE_LOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ue_queue_command
argument_list|(
name|ue
argument_list|,
name|ue_promisc_task
argument_list|,
operator|&
name|ue
operator|->
name|ue_promisc_task
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|,
operator|&
name|ue
operator|->
name|ue_promisc_task
index|[
literal|1
index|]
operator|.
name|hdr
argument_list|)
expr_stmt|;
else|else
name|ue_queue_command
argument_list|(
name|ue
argument_list|,
name|ue_start_task
argument_list|,
operator|&
name|ue
operator|->
name|ue_sync_task
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|,
operator|&
name|ue
operator|->
name|ue_sync_task
index|[
literal|1
index|]
operator|.
name|hdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ue_queue_command
argument_list|(
name|ue
argument_list|,
name|ue_stop_task
argument_list|,
operator|&
name|ue
operator|->
name|ue_sync_task
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|,
operator|&
name|ue
operator|->
name|ue_sync_task
index|[
literal|1
index|]
operator|.
name|hdr
argument_list|)
expr_stmt|;
block|}
name|UE_UNLOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|UE_LOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|ue_queue_command
argument_list|(
name|ue
argument_list|,
name|ue_setmulti_task
argument_list|,
operator|&
name|ue
operator|->
name|ue_multi_task
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|,
operator|&
name|ue
operator|->
name|ue_multi_task
index|[
literal|1
index|]
operator|.
name|hdr
argument_list|)
expr_stmt|;
name|UE_UNLOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
if|if
condition|(
name|ue
operator|->
name|ue_miibus
operator|!=
name|NULL
condition|)
block|{
name|mii
operator|=
name|device_get_softc
argument_list|(
name|ue
operator|->
name|ue_miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uether_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|ueunit
operator|=
name|new_unrhdr
argument_list|(
literal|0
argument_list|,
name|INT_MAX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|uether_mod
init|=
block|{
literal|"uether"
block|,
name|uether_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|mbuf
modifier|*
name|uether_newbuf
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
name|m_new
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m_new
operator|->
name|m_len
operator|=
name|m_new
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
name|m_adj
argument_list|(
name|m_new
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
return|return
operator|(
name|m_new
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uether_rxmbuf
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ue
operator|->
name|ue_ifp
decl_stmt|;
name|UE_LOCK_ASSERT
argument_list|(
name|ue
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* finalize mbuf */
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* enqueue for later when the lock can be released */
name|_IF_ENQUEUE
argument_list|(
operator|&
name|ue
operator|->
name|ue_rxq
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uether_rxbuf
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|,
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ue
operator|->
name|ue_ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|UE_LOCK_ASSERT
argument_list|(
name|ue
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|ETHER_HDR_LEN
operator|||
name|len
operator|>
name|MCLBYTES
operator|-
name|ETHER_ALIGN
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|m
operator|=
name|uether_newbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
name|offset
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* finalize mbuf */
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* enqueue for later when the lock can be released */
name|_IF_ENQUEUE
argument_list|(
operator|&
name|ue
operator|->
name|ue_rxq
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uether_rxflush
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ue
operator|->
name|ue_ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|UE_LOCK_ASSERT
argument_list|(
name|ue
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|_IF_DEQUEUE
argument_list|(
operator|&
name|ue
operator|->
name|ue_rxq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * The USB xfer has been resubmitted so its safe to unlock now. 		 */
name|UE_UNLOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_input
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|UE_LOCK
argument_list|(
name|ue
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|uether
argument_list|,
name|uether_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|uether
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

