begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012  *	Ben Gray<bgray@freebsd.org>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * SMSC LAN9xxx devices (http://www.smsc.com/)  *   * The LAN9500& LAN9500A devices are stand-alone USB to Ethernet chips that  * support USB 2.0 and 10/100 Mbps Ethernet.  *  * The LAN951x devices are an integrated USB hub and USB to Ethernet adapter.  * The driver only covers the Ethernet part, the standard USB hub driver  * supports the hub part.  *  * This driver is closely modelled on the Linux driver written and copyrighted  * by SMSC.  *  *  *  *  * H/W TCP& UDP Checksum Offloading  * ---------------------------------  * The chip supports both tx and rx offloading of UDP& TCP checksums, this  * feature can be dynamically enabled/disabled.    *  * RX checksuming is performed across bytes after the IPv4 header to the end of  * the Ethernet frame, this means if the frame is padded with non-zero values  * the H/W checksum will be incorrect, however the rx code compensates for this.  *  * TX checksuming is more complicated, the device requires a special header to  * be prefixed onto the start of the frame which indicates the start and end  * positions of the UDP or TCP frame.  This requires the driver to manually  * go through the packet data and decode the headers prior to sending.  * On Linux they generally provide cues to the location of the csum and the  * area to calculate it over, on FreeBSD we seem to have to do it all ourselves,  * hence this is not as optimal and therefore h/w tX checksum is currently not  * implemented.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|smsc_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/net/usb_ethernet.h>
end_include

begin_include
include|#
directive|include
file|"if_smscreg.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|smsc_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|smsc
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB smsc"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_smsc
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|smsc_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Various supported device vendors/products.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_device_id
name|smsc_devs
index|[]
init|=
block|{
define|#
directive|define
name|SMSC_DEV
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
value|{ USB_VPI(USB_VENDOR_SMC2, USB_PRODUCT_SMC2_##p, i) }
name|SMSC_DEV
argument_list|(
name|LAN9514_ETH
argument_list|,
literal|0
argument_list|)
block|,
undef|#
directive|undef
name|SMSC_DEV
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|smsc_dbg_printf
parameter_list|(
name|sc
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|do { \ 		if (smsc_debug> 0) \ 			device_printf((sc)->sc_ue.ue_dev, "debug: " fmt, ##args); \ 	} while(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|smsc_dbg_printf
parameter_list|(
name|sc
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|smsc_warn_printf
parameter_list|(
name|sc
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|device_printf((sc)->sc_ue.ue_dev, "warning: " fmt, ##args)
end_define

begin_define
define|#
directive|define
name|smsc_err_printf
parameter_list|(
name|sc
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|device_printf((sc)->sc_ue.ue_dev, "error: " fmt, ##args)
end_define

begin_define
define|#
directive|define
name|ETHER_IS_ZERO
parameter_list|(
name|addr
parameter_list|)
define|\
value|(!(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]))
end_define

begin_define
define|#
directive|define
name|ETHER_IS_VALID
parameter_list|(
name|addr
parameter_list|)
define|\
value|(!ETHER_IS_MULTICAST(addr)&& !ETHER_IS_ZERO(addr))
end_define

begin_decl_stmt
specifier|static
name|device_probe_t
name|smsc_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|smsc_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|smsc_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|smsc_bulk_read_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|smsc_bulk_write_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|miibus_readreg_t
name|smsc_miibus_readreg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|miibus_writereg_t
name|smsc_miibus_writereg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|miibus_statchg_t
name|smsc_miibus_statchg
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|1000000
end_if

begin_function_decl
specifier|static
name|int
name|smsc_attach_post_sub
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|uether_fn_t
name|smsc_attach_post
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uether_fn_t
name|smsc_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uether_fn_t
name|smsc_stop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uether_fn_t
name|smsc_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uether_fn_t
name|smsc_tick
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uether_fn_t
name|smsc_setmulti
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uether_fn_t
name|smsc_setpromisc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|smsc_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smsc_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smsc_chip_init
parameter_list|(
name|struct
name|smsc_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smsc_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|smsc_config
index|[
name|SMSC_N_TRANSFER
index|]
init|=
block|{
index|[
name|SMSC_BULK_DT_WR
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|frames
operator|=
literal|16
block|,
operator|.
name|bufsize
operator|=
literal|16
operator|*
operator|(
name|MCLBYTES
operator|+
literal|16
operator|)
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|force_short_xfer
operator|=
literal|1
block|,}
block|,
operator|.
name|callback
operator|=
name|smsc_bulk_write_callback
block|,
operator|.
name|timeout
operator|=
literal|10000
block|,
comment|/* 10 seconds */
block|}
block|,
index|[
name|SMSC_BULK_DT_RD
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
literal|20480
block|,
comment|/* bytes */
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|callback
operator|=
name|smsc_bulk_read_callback
block|,
operator|.
name|timeout
operator|=
literal|0
block|,
comment|/* no timeout */
block|}
block|,
comment|/* The SMSC chip supports an interrupt endpoints, however they aren't 	 * needed as we poll on the MII status. 	 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_ether_methods
name|smsc_ue_methods
init|=
block|{
operator|.
name|ue_attach_post
operator|=
name|smsc_attach_post
block|,
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|1000000
operator|.
name|ue_attach_post_sub
operator|=
name|smsc_attach_post_sub
block|,
endif|#
directive|endif
operator|.
name|ue_start
operator|=
name|smsc_start
block|,
operator|.
name|ue_ioctl
operator|=
name|smsc_ioctl
block|,
operator|.
name|ue_init
operator|=
name|smsc_init
block|,
operator|.
name|ue_stop
operator|=
name|smsc_stop
block|,
operator|.
name|ue_tick
operator|=
name|smsc_tick
block|,
operator|.
name|ue_setmulti
operator|=
name|smsc_setmulti
block|,
operator|.
name|ue_setpromisc
operator|=
name|smsc_setpromisc
block|,
operator|.
name|ue_mii_upd
operator|=
name|smsc_ifmedia_upd
block|,
operator|.
name|ue_mii_sts
operator|=
name|smsc_ifmedia_sts
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  *	smsc_read_reg - Reads a 32-bit register on the device  *	@sc: driver soft context  *	@off: offset of the register  *	@data: pointer a value that will be populated with the register value  *	  *	LOCKING:  *	The device lock must be held before calling this function.  *  *	RETURNS:  *	0 on success, a USB_ERR_?? error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_read_reg
parameter_list|(
name|struct
name|smsc_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|off
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|uint32_t
name|buf
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|SMSC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_READ_VENDOR_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|SMSC_UR_READ_REG
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|err
operator|=
name|uether_do_request
argument_list|(
operator|&
name|sc
operator|->
name|sc_ue
argument_list|,
operator|&
name|req
argument_list|,
operator|&
name|buf
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"Failed to read register 0x%0x\n"
argument_list|,
name|off
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|le32toh
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	smsc_write_reg - Writes a 32-bit register on the device  *	@sc: driver soft context  *	@off: offset of the register  *	@data: the 32-bit value to write into the register  *	  *	LOCKING:  *	The device lock must be held before calling this function.  *  *	RETURNS:  *	0 on success, a USB_ERR_?? error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_write_reg
parameter_list|(
name|struct
name|smsc_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|off
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|uint32_t
name|buf
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|SMSC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|buf
operator|=
name|htole32
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_VENDOR_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|SMSC_UR_WRITE_REG
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|err
operator|=
name|uether_do_request
argument_list|(
operator|&
name|sc
operator|->
name|sc_ue
argument_list|,
operator|&
name|req
argument_list|,
operator|&
name|buf
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"Failed to write register 0x%0x\n"
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	smsc_wait_for_bits - Polls on a register value until bits are cleared  *	@sc: soft context  *	@reg: offset of the register  *	@bits: if the bits are clear the function returns  *  *	LOCKING:  *	The device lock must be held before calling this function.  *  *	RETURNS:  *	0 on success, or a USB_ERR_?? error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_wait_for_bits
parameter_list|(
name|struct
name|smsc_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|bits
parameter_list|)
block|{
name|usb_ticks_t
name|start_ticks
decl_stmt|;
specifier|const
name|usb_ticks_t
name|max_ticks
init|=
name|USB_MS_TO_TICKS
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|err
decl_stmt|;
name|SMSC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|start_ticks
operator|=
operator|(
name|usb_ticks_t
operator|)
name|ticks
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|smsc_read_reg
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
operator|&
name|val
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|bits
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|uether_pause
argument_list|(
operator|&
name|sc
operator|->
name|sc_ue
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
call|(
name|usb_ticks_t
call|)
argument_list|(
name|ticks
operator|-
name|start_ticks
argument_list|)
operator|)
operator|<
name|max_ticks
condition|)
do|;
return|return
operator|(
name|USB_ERR_TIMEOUT
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	smsc_eeprom_read - Reads the attached EEPROM  *	@sc: soft context  *	@off: the eeprom address offset  *	@buf: stores the bytes  *	@buflen: the number of bytes to read  *  *	Simply reads bytes from an attached eeprom.  *  *	LOCKING:  *	The function takes and releases the device lock if it is not already held.  *  *	RETURNS:  *	0 on success, or a USB_ERR_?? error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_eeprom_read
parameter_list|(
name|struct
name|smsc_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|off
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint16_t
name|buflen
parameter_list|)
block|{
name|usb_ticks_t
name|start_ticks
decl_stmt|;
specifier|const
name|usb_ticks_t
name|max_ticks
init|=
name|USB_MS_TO_TICKS
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|locked
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|locked
operator|=
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|SMSC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|smsc_wait_for_bits
argument_list|(
name|sc
argument_list|,
name|SMSC_EEPROM_CMD
argument_list|,
name|SMSC_EEPROM_CMD_BUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"eeprom busy, failed to read data\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* start reading the bytes, one at a time */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buflen
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|SMSC_EEPROM_CMD_BUSY
operator||
operator|(
name|SMSC_EEPROM_CMD_ADDR_MASK
operator|&
operator|(
name|off
operator|+
name|i
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_EEPROM_CMD
argument_list|,
name|val
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|start_ticks
operator|=
operator|(
name|usb_ticks_t
operator|)
name|ticks
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|smsc_read_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_EEPROM_CMD
argument_list|,
operator|&
name|val
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|SMSC_EEPROM_CMD_BUSY
operator|)
operator|||
operator|(
name|val
operator|&
name|SMSC_EEPROM_CMD_TIMEOUT
operator|)
condition|)
break|break;
name|uether_pause
argument_list|(
operator|&
name|sc
operator|->
name|sc_ue
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
call|(
name|usb_ticks_t
call|)
argument_list|(
name|ticks
operator|-
name|start_ticks
argument_list|)
operator|)
operator|<
name|max_ticks
condition|)
do|;
if|if
condition|(
name|val
operator|&
operator|(
name|SMSC_EEPROM_CMD_BUSY
operator||
name|SMSC_EEPROM_CMD_TIMEOUT
operator|)
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"eeprom command failed\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|smsc_read_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_EEPROM_DATA
argument_list|,
operator|&
name|val
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|buf
index|[
name|i
index|]
operator|=
operator|(
name|val
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
operator|!
name|locked
condition|)
name|SMSC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	smsc_miibus_readreg - Reads a MII/MDIO register  *	@dev: usb ether device  *	@phy: the number of phy reading from  *	@reg: the register address  *  *	Attempts to read a phy register over the MII bus.  *  *	LOCKING:  *	Takes and releases the device mutex lock if not already held.  *  *	RETURNS:  *	Returns the 16-bits read from the MII register, if this function fails 0  *	is returned.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|locked
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
name|locked
operator|=
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|SMSC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|smsc_wait_for_bits
argument_list|(
name|sc
argument_list|,
name|SMSC_MII_ADDR
argument_list|,
name|SMSC_MII_BUSY
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"MII is busy\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|addr
operator|=
operator|(
name|phy
operator|<<
literal|11
operator|)
operator||
operator|(
name|reg
operator|<<
literal|6
operator|)
operator||
name|SMSC_MII_READ
expr_stmt|;
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_MII_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|smsc_wait_for_bits
argument_list|(
name|sc
argument_list|,
name|SMSC_MII_ADDR
argument_list|,
name|SMSC_MII_BUSY
argument_list|)
operator|!=
literal|0
condition|)
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"MII read timeout\n"
argument_list|)
expr_stmt|;
name|smsc_read_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_MII_DATA
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|le32toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|!
name|locked
condition|)
name|SMSC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|&
literal|0xFFFF
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	smsc_miibus_writereg - Writes a MII/MDIO register  *	@dev: usb ether device  *	@phy: the number of phy writing to  *	@reg: the register address  *	@val: the value to write  *  *	Attempts to write a phy register over the MII bus.  *  *	LOCKING:  *	Takes and releases the device mutex lock if not already held.  *  *	RETURNS:  *	Always returns 0 regardless of success or failure.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|locked
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_phyno
operator|!=
name|phy
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|locked
operator|=
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|SMSC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|smsc_wait_for_bits
argument_list|(
name|sc
argument_list|,
name|SMSC_MII_ADDR
argument_list|,
name|SMSC_MII_BUSY
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"MII is busy\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|val
operator|=
name|htole32
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_MII_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|phy
operator|<<
literal|11
operator|)
operator||
operator|(
name|reg
operator|<<
literal|6
operator|)
operator||
name|SMSC_MII_WRITE
expr_stmt|;
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_MII_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|smsc_wait_for_bits
argument_list|(
name|sc
argument_list|,
name|SMSC_MII_ADDR
argument_list|,
name|SMSC_MII_BUSY
argument_list|)
operator|!=
literal|0
condition|)
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"MII write timeout\n"
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|!
name|locked
condition|)
name|SMSC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	smsc_miibus_statchg - Called to detect phy status change  *	@dev: usb ether device  *  *	This function is called periodically by the system to poll for status  *	changes of the link.  *  *	LOCKING:  *	Takes and releases the device mutex lock if not already held.  */
end_comment

begin_function
specifier|static
name|void
name|smsc_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
init|=
name|uether_getmii
argument_list|(
operator|&
name|sc
operator|->
name|sc_ue
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|locked
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint32_t
name|flow
decl_stmt|;
name|uint32_t
name|afc_cfg
decl_stmt|;
name|locked
operator|=
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|SMSC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|uether_getifp
argument_list|(
operator|&
name|sc
operator|->
name|sc_ue
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii
operator|==
name|NULL
operator|||
name|ifp
operator|==
name|NULL
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* Use the MII status to determine link status */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SMSC_FLAG_LINK
expr_stmt|;
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_status
operator|&
operator|(
name|IFM_ACTIVE
operator||
name|IFM_AVALID
operator|)
operator|)
operator|==
operator|(
name|IFM_ACTIVE
operator||
name|IFM_AVALID
operator|)
condition|)
block|{
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_10_T
case|:
case|case
name|IFM_100_TX
case|:
name|sc
operator|->
name|sc_flags
operator||=
name|SMSC_FLAG_LINK
expr_stmt|;
break|break;
case|case
name|IFM_1000_T
case|:
comment|/* Gigabit ethernet not supported by chipset */
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Lost link, do nothing. */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SMSC_FLAG_LINK
operator|)
operator|==
literal|0
condition|)
block|{
name|smsc_dbg_printf
argument_list|(
name|sc
argument_list|,
literal|"link flag not set\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|err
operator|=
name|smsc_read_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_AFC_CFG
argument_list|,
operator|&
name|afc_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"failed to read initial AFC_CFG, error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Enable/disable full duplex operation and TX/RX pause */
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
block|{
name|smsc_dbg_printf
argument_list|(
name|sc
argument_list|,
literal|"full duplex operation\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mac_csr
operator|&=
operator|~
name|SMSC_MAC_CSR_RCVOWN
expr_stmt|;
name|sc
operator|->
name|sc_mac_csr
operator||=
name|SMSC_MAC_CSR_FDPX
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_RXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|flow
operator|=
literal|0xffff0002
expr_stmt|;
else|else
name|flow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_TXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|afc_cfg
operator||=
literal|0xf
expr_stmt|;
else|else
name|afc_cfg
operator|&=
operator|~
literal|0xf
expr_stmt|;
block|}
else|else
block|{
name|smsc_dbg_printf
argument_list|(
name|sc
argument_list|,
literal|"half duplex operation\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mac_csr
operator|&=
operator|~
name|SMSC_MAC_CSR_FDPX
expr_stmt|;
name|sc
operator|->
name|sc_mac_csr
operator||=
name|SMSC_MAC_CSR_RCVOWN
expr_stmt|;
name|flow
operator|=
literal|0
expr_stmt|;
name|afc_cfg
operator||=
literal|0xf
expr_stmt|;
block|}
name|err
operator|=
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_MAC_CSR
argument_list|,
name|sc
operator|->
name|sc_mac_csr
argument_list|)
expr_stmt|;
name|err
operator|+=
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_FLOW
argument_list|,
name|flow
argument_list|)
expr_stmt|;
name|err
operator|+=
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_AFC_CFG
argument_list|,
name|afc_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"media change failed, error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|!
name|locked
condition|)
name|SMSC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	smsc_ifmedia_upd - Set media options  *	@ifp: interface pointer  *  *	Basically boilerplate code that simply calls the mii functions to set the  *	media options.  *  *	LOCKING:  *	The device lock must be held before this function is called.  *  *	RETURNS:  *	Returns 0 on success or a negative error code.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
init|=
name|uether_getmii
argument_list|(
operator|&
name|sc
operator|->
name|sc_ue
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|SMSC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii
operator|->
name|mii_instance
condition|)
block|{
name|struct
name|mii_softc
modifier|*
name|miisc
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|miisc
argument_list|,
argument|&mii->mii_phys
argument_list|,
argument|mii_list
argument_list|)
name|mii_phy_reset
argument_list|(
name|miisc
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	smsc_ifmedia_sts - Report current media status  *	@ifp: inet interface pointer  *	@ifmr: interface media request  *  *	Basically boilerplate code that simply calls the mii functions to get the  *	media status.  *  *	LOCKING:  *	Internally takes and releases the device lock.  */
end_comment

begin_function
specifier|static
name|void
name|smsc_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
init|=
name|uether_getmii
argument_list|(
operator|&
name|sc
operator|->
name|sc_ue
argument_list|)
decl_stmt|;
name|SMSC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|SMSC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	smsc_hash - Calculate the hash of a mac address  *	@addr: The mac address to calculate the hash on  *  *	This function is used when configuring a range of m'cast mac addresses to  *	filter on.  The hash of the mac address is put in the device's mac hash  *	table.  *  *	RETURNS:  *	Returns a value from 0-63 value which is the hash of the mac address.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|smsc_hash
parameter_list|(
name|uint8_t
name|addr
index|[
name|ETHER_ADDR_LEN
index|]
parameter_list|)
block|{
return|return
operator|(
name|ether_crc32_be
argument_list|(
name|addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
return|;
block|}
end_function

begin_comment
comment|/**  *	smsc_setmulti - Setup multicast  *	@ue: usb ethernet device context  *  *	Tells the device to either accept frames with a multicast mac address, a  *	select group of m'cast mac addresses or just the devices mac address.  *  *	LOCKING:  *	Should be called with the SMSC lock held.  */
end_comment

begin_function
specifier|static
name|void
name|smsc_setmulti
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|uether_getsc
argument_list|(
name|ue
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|uether_getifp
argument_list|(
name|ue
argument_list|)
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|uint32_t
name|hashtbl
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|SMSC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_ALLMULTI
operator||
name|IFF_PROMISC
operator|)
condition|)
block|{
name|smsc_dbg_printf
argument_list|(
name|sc
argument_list|,
literal|"receive all multicast enabled\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mac_csr
operator||=
name|SMSC_MAC_CSR_MCPAS
expr_stmt|;
name|sc
operator|->
name|sc_mac_csr
operator|&=
operator|~
name|SMSC_MAC_CSR_HPFILT
expr_stmt|;
block|}
else|else
block|{
comment|/* Take the lock of the mac address list before hashing each of them */
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_multiaddrs
argument_list|)
condition|)
block|{
comment|/* We are filtering on a set of address so calculate hashes of each 			 * of the address and set the corresponding bits in the register. 			 */
name|sc
operator|->
name|sc_mac_csr
operator||=
name|SMSC_MAC_CSR_HPFILT
expr_stmt|;
name|sc
operator|->
name|sc_mac_csr
operator|&=
operator|~
operator|(
name|SMSC_MAC_CSR_PRMS
operator||
name|SMSC_MAC_CSR_MCPAS
operator|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|hash
operator|=
name|smsc_hash
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
expr_stmt|;
name|hashtbl
index|[
name|hash
operator|>>
literal|5
index|]
operator||=
literal|1
operator|<<
operator|(
name|hash
operator|&
literal|0x1F
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Only receive packets with destination set to our mac address */
name|sc
operator|->
name|sc_mac_csr
operator|&=
operator|~
operator|(
name|SMSC_MAC_CSR_MCPAS
operator||
name|SMSC_MAC_CSR_HPFILT
operator|)
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Debug */
if|if
condition|(
name|sc
operator|->
name|sc_mac_csr
operator|&
name|SMSC_MAC_CSR_HPFILT
condition|)
name|smsc_dbg_printf
argument_list|(
name|sc
argument_list|,
literal|"receive select group of macs\n"
argument_list|)
expr_stmt|;
else|else
name|smsc_dbg_printf
argument_list|(
name|sc
argument_list|,
literal|"receive own packets only\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Write the hash table and mac control registers */
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_HASHH
argument_list|,
name|hashtbl
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_HASHL
argument_list|,
name|hashtbl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_MAC_CSR
argument_list|,
name|sc
operator|->
name|sc_mac_csr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	smsc_setpromisc - Enables/disables promiscuous mode  *	@ue: usb ethernet device context  *  *	LOCKING:  *	Should be called with the SMSC lock held.  */
end_comment

begin_function
specifier|static
name|void
name|smsc_setpromisc
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|uether_getsc
argument_list|(
name|ue
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|uether_getifp
argument_list|(
name|ue
argument_list|)
decl_stmt|;
name|smsc_dbg_printf
argument_list|(
name|sc
argument_list|,
literal|"promiscuous mode %sabled\n"
argument_list|,
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
name|SMSC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|sc
operator|->
name|sc_mac_csr
operator||=
name|SMSC_MAC_CSR_PRMS
expr_stmt|;
else|else
name|sc
operator|->
name|sc_mac_csr
operator|&=
operator|~
name|SMSC_MAC_CSR_PRMS
expr_stmt|;
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_MAC_CSR
argument_list|,
name|sc
operator|->
name|sc_mac_csr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	smsc_sethwcsum - Enable or disable H/W UDP and TCP checksumming  *	@sc: driver soft context  *  *	LOCKING:  *	Should be called with the SMSC lock held.  *  *	RETURNS:  *	Returns 0 on success or a negative error code.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_sethwcsum
parameter_list|(
name|struct
name|smsc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|uether_getifp
argument_list|(
operator|&
name|sc
operator|->
name|sc_ue
argument_list|)
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|ifp
condition|)
return|return
operator|(
operator|-
name|EIO
operator|)
return|;
name|SMSC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|err
operator|=
name|smsc_read_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_COE_CTRL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"failed to read SMSC_COE_CTRL (err=%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* Enable/disable the Rx checksum */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|&
name|IFCAP_RXCSUM
condition|)
name|val
operator||=
name|SMSC_COE_CTRL_RX_EN
expr_stmt|;
else|else
name|val
operator|&=
operator|~
name|SMSC_COE_CTRL_RX_EN
expr_stmt|;
comment|/* Enable/disable the Tx checksum (currently not supported) */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|&
name|IFCAP_TXCSUM
condition|)
name|val
operator||=
name|SMSC_COE_CTRL_TX_EN
expr_stmt|;
else|else
name|val
operator|&=
operator|~
name|SMSC_COE_CTRL_TX_EN
expr_stmt|;
name|err
operator|=
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_COE_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"failed to write SMSC_COE_CTRL (err=%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	smsc_setmacaddress - Sets the mac address in the device  *	@sc: driver soft context  *	@addr: pointer to array contain at least 6 bytes of the mac  *  *	Writes the MAC address into the device, usually the MAC is programmed with  *	values from the EEPROM.  *  *	LOCKING:  *	Should be called with the SMSC lock held.  *  *	RETURNS:  *	Returns 0 on success or a negative error code.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_setmacaddress
parameter_list|(
name|struct
name|smsc_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|smsc_dbg_printf
argument_list|(
name|sc
argument_list|,
literal|"setting mac address to %02x:%02x:%02x:%02x:%02x:%02x\n"
argument_list|,
name|addr
index|[
literal|0
index|]
argument_list|,
name|addr
index|[
literal|1
index|]
argument_list|,
name|addr
index|[
literal|2
index|]
argument_list|,
name|addr
index|[
literal|3
index|]
argument_list|,
name|addr
index|[
literal|4
index|]
argument_list|,
name|addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|SMSC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_MAC_ADDRL
argument_list|,
name|val
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|val
operator|=
operator|(
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|err
operator|=
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_MAC_ADDRH
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|done
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	smsc_reset - Reset the SMSC chip  *	@sc: device soft context  *  *	LOCKING:  *	Should be called with the SMSC lock held.  */
end_comment

begin_function
specifier|static
name|void
name|smsc_reset
parameter_list|(
name|struct
name|smsc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_config_descriptor
modifier|*
name|cd
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|cd
operator|=
name|usbd_get_config_descriptor
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_udev
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_req_set_config
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|cd
operator|->
name|bConfigurationValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"reset failed (ignored)\n"
argument_list|)
expr_stmt|;
comment|/* Wait a little while for the chip to get its brains in order. */
name|uether_pause
argument_list|(
operator|&
name|sc
operator|->
name|sc_ue
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* Reinitialize controller to achieve full reset. */
name|smsc_chip_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	smsc_init - Initialises the LAN95xx chip  *	@ue: USB ether interface  *  *	Called when the interface is brought up (i.e. ifconfig ue0 up), this  *	initialise the interface and the rx/tx pipes.  *  *	LOCKING:  *	Should be called with the SMSC lock held.  */
end_comment

begin_function
specifier|static
name|void
name|smsc_init
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|uether_getsc
argument_list|(
name|ue
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|uether_getifp
argument_list|(
name|ue
argument_list|)
decl_stmt|;
name|SMSC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Cancel pending I/O */
name|smsc_stop
argument_list|(
name|ue
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<=
literal|1000000
comment|/* On earlier versions this was the first place we could tell the system 	 * that we supported h/w csuming, however this is only called after the 	 * the interface has been brought up - not ideal.   	 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_RXCSUM
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_RXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_RXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
block|}
comment|/* TX checksuming is disabled for now 	ifp->if_capabilities |= IFCAP_TXCSUM; 	ifp->if_capenable |= IFCAP_TXCSUM; 	ifp->if_hwassist = CSUM_TCP | CSUM_UDP; 	*/
endif|#
directive|endif
comment|/* Reset the ethernet interface. */
name|smsc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Load the multicast filter. */
name|smsc_setmulti
argument_list|(
name|ue
argument_list|)
expr_stmt|;
comment|/* TCP/UDP checksum offload engines. */
name|smsc_sethwcsum
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|usbd_xfer_set_stall
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|SMSC_BULK_DT_WR
index|]
argument_list|)
expr_stmt|;
comment|/* Indicate we are up and running. */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* Switch to selected media. */
name|smsc_ifmedia_upd
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|smsc_start
argument_list|(
name|ue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	smsc_bulk_read_callback - Read callback used to process the USB URB  *	@xfer: the USB transfer  *	@error:   *  *	Reads the URB data which can contain one or more ethernet frames, the  *	frames are copyed into a mbuf and given to the system.  *  *	LOCKING:  *	No locking required, doesn't access internal driver settings.  */
end_comment

begin_function
specifier|static
name|void
name|smsc_bulk_read_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|usb_ether
modifier|*
name|ue
init|=
operator|&
name|sc
operator|->
name|sc_ue
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|uether_getifp
argument_list|(
name|ue
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint32_t
name|rxhdr
decl_stmt|;
name|uint16_t
name|pktlen
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|actlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|smsc_dbg_printf
argument_list|(
name|sc
argument_list|,
literal|"rx : actlen %d\n"
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
comment|/* There is always a zero length frame after bringing the IF up */
if|if
condition|(
name|actlen
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|rxhdr
argument_list|)
operator|+
name|ETHER_CRC_LEN
operator|)
condition|)
goto|goto
name|tr_setup
goto|;
comment|/* There maybe multiple packets in the USB frame, each will have a  		 * header and each needs to have it's own mbuf allocated and populated 		 * for it. 		 */
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|off
operator|<
name|actlen
condition|)
block|{
comment|/* The frame header is always aligned on a 4 byte boundary */
name|off
operator|=
operator|(
operator|(
name|off
operator|+
literal|0x3
operator|)
operator|&
operator|~
literal|0x3
operator|)
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
name|off
argument_list|,
operator|&
name|rxhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|rxhdr
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|rxhdr
argument_list|)
operator|+
name|ETHER_ALIGN
operator|)
expr_stmt|;
name|rxhdr
operator|=
name|le32toh
argument_list|(
name|rxhdr
argument_list|)
expr_stmt|;
name|pktlen
operator|=
operator|(
name|uint16_t
operator|)
name|SMSC_RX_STAT_FRM_LENGTH
argument_list|(
name|rxhdr
argument_list|)
expr_stmt|;
name|smsc_dbg_printf
argument_list|(
name|sc
argument_list|,
literal|"rx : rxhdr 0x%08x : pktlen %d : actlen %d : "
literal|"off %d\n"
argument_list|,
name|rxhdr
argument_list|,
name|pktlen
argument_list|,
name|actlen
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxhdr
operator|&
name|SMSC_RX_STAT_ERROR
condition|)
block|{
name|smsc_dbg_printf
argument_list|(
name|sc
argument_list|,
literal|"rx error (hdr 0x%08x)\n"
argument_list|,
name|rxhdr
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|rxhdr
operator|&
name|SMSC_RX_STAT_COLLISION
condition|)
name|ifp
operator|->
name|if_collisions
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Check if the ethernet frame is too big or too small */
if|if
condition|(
operator|(
name|pktlen
operator|<
name|ETHER_HDR_LEN
operator|)
operator|||
operator|(
name|pktlen
operator|>
operator|(
name|actlen
operator|-
name|off
operator|)
operator|)
condition|)
goto|goto
name|tr_setup
goto|;
comment|/* Create a new mbuf to store the packet in */
name|m
operator|=
name|uether_newbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"failed to create new mbuf\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
name|off
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
comment|/* Check if RX TCP/UDP checksumming is being offloaded */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* Remove the extra 2 bytes of the csum */
name|pktlen
operator|-=
literal|2
expr_stmt|;
comment|/* The checksum appears to be simplistically calculated 					 * over the udp/tcp header and data up to the end of the 					 * eth frame.  Which means if the eth frame is padded 					 * the csum calculation is incorrectly performed over 					 * the padding bytes as well. Therefore to be safe we 					 * ignore the H/W csum on frames less than or equal to 					 * 64 bytes. 					 * 					 * Ignore H/W csum for non-IPv4 packets. 					 */
if|if
condition|(
name|be16toh
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|==
name|ETHERTYPE_IP
operator|&&
name|pktlen
operator|>
name|ETHER_MIN_LEN
condition|)
block|{
comment|/* Indicate the UDP/TCP csum has been calculated */
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
expr_stmt|;
comment|/* Copy the TCP/UDP checksum from the last 2 bytes 						 * of the transfer and put in the csum_data field. 						 */
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
operator|(
name|off
operator|+
name|pktlen
operator|)
argument_list|,
operator|&
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* The data is copied in network order, but the 						 * csum algorithm in the kernel expects it to be 						 * in host network order. 						 */
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|ntohs
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
argument_list|)
expr_stmt|;
name|smsc_dbg_printf
argument_list|(
name|sc
argument_list|,
literal|"RX checksum offloaded (0x%04x)\n"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
argument_list|)
expr_stmt|;
block|}
comment|/* Need to adjust the offset as well or we'll be off 					 * by 2 because the csum is removed from the packet 					 * length. 					 */
name|off
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Finally enqueue the mbuf on the receive queue */
comment|/* Remove 4 trailing bytes */
if|if
condition|(
name|pktlen
operator|<
operator|(
literal|4
operator|+
name|ETHER_HDR_LEN
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
name|uether_rxmbuf
argument_list|(
name|ue
argument_list|,
name|m
argument_list|,
name|pktlen
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Update the offset to move to the next potential packet */
name|off
operator|+=
name|pktlen
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|uether_rxflush
argument_list|(
name|ue
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"bulk read error, %s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
return|return;
block|}
block|}
end_function

begin_comment
comment|/**  *	smsc_bulk_write_callback - Write callback used to send ethernet frame(s)  *	@xfer: the USB transfer  *	@error: error code if the transfers is in an errored state  *  *	The main write function that pulls ethernet frames off the queue and sends  *	them out.  *  *	LOCKING:  *	  */
end_comment

begin_function
specifier|static
name|void
name|smsc_bulk_write_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|uether_getifp
argument_list|(
operator|&
name|sc
operator|->
name|sc_ue
argument_list|)
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|txhdr
decl_stmt|;
name|uint32_t
name|frm_len
init|=
literal|0
decl_stmt|;
name|int
name|nframes
decl_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SMSC_FLAG_LINK
operator|)
operator|==
literal|0
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Don't send anything if there is no link or controller is busy. */
return|return;
block|}
for|for
control|(
name|nframes
operator|=
literal|0
init|;
name|nframes
operator|<
literal|16
operator|&&
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|;
name|nframes
operator|++
control|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|usbd_xfer_set_frame_offset
argument_list|(
name|xfer
argument_list|,
name|nframes
operator|*
name|MCLBYTES
argument_list|,
name|nframes
argument_list|)
expr_stmt|;
name|frm_len
operator|=
literal|0
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
name|nframes
argument_list|)
expr_stmt|;
comment|/* Each frame is prefixed with two 32-bit values describing the 			 * length of the packet and buffer. 			 */
name|txhdr
operator|=
name|SMSC_TX_CTRL_0_BUF_SIZE
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
operator||
name|SMSC_TX_CTRL_0_FIRST_SEG
operator||
name|SMSC_TX_CTRL_0_LAST_SEG
expr_stmt|;
name|txhdr
operator|=
name|htole32
argument_list|(
name|txhdr
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|txhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|txhdr
argument_list|)
argument_list|)
expr_stmt|;
name|txhdr
operator|=
name|SMSC_TX_CTRL_1_PKT_LENGTH
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|txhdr
operator|=
name|htole32
argument_list|(
name|txhdr
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|,
operator|&
name|txhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|txhdr
argument_list|)
argument_list|)
expr_stmt|;
name|frm_len
operator|+=
literal|8
expr_stmt|;
comment|/* Next copy in the actual packet */
name|usbd_m_copy_in
argument_list|(
name|pc
argument_list|,
name|frm_len
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|frm_len
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
comment|/* If there's a BPF listener, bounce a copy of this frame to him */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Set frame length. */
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
name|nframes
argument_list|,
name|frm_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nframes
operator|!=
literal|0
condition|)
block|{
name|usbd_xfer_set_frames
argument_list|(
name|xfer
argument_list|,
name|nframes
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
return|return;
default|default:
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
name|smsc_err_printf
argument_list|(
name|sc
argument_list|,
literal|"usb error on tx: %s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
return|return;
block|}
block|}
end_function

begin_comment
comment|/**  *	smsc_tick - Called periodically to monitor the state of the LAN95xx chip  *	@ue: USB ether interface  *  *	Simply calls the mii status functions to check the state of the link.  *  *	LOCKING:  *	Should be called with the SMSC lock held.  */
end_comment

begin_function
specifier|static
name|void
name|smsc_tick
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|uether_getsc
argument_list|(
name|ue
argument_list|)
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
init|=
name|uether_getmii
argument_list|(
operator|&
name|sc
operator|->
name|sc_ue
argument_list|)
decl_stmt|;
name|SMSC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SMSC_FLAG_LINK
operator|)
operator|==
literal|0
condition|)
block|{
name|smsc_miibus_statchg
argument_list|(
name|ue
operator|->
name|ue_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SMSC_FLAG_LINK
operator|)
operator|!=
literal|0
condition|)
name|smsc_start
argument_list|(
name|ue
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	smsc_start - Starts communication with the LAN95xx chip  *	@ue: USB ether interface  *  *	  *  */
end_comment

begin_function
specifier|static
name|void
name|smsc_start
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|uether_getsc
argument_list|(
name|ue
argument_list|)
decl_stmt|;
comment|/* 	 * start the USB transfers, if not already started: 	 */
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|SMSC_BULK_DT_RD
index|]
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|SMSC_BULK_DT_WR
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	smsc_stop - Stops communication with the LAN95xx chip  *	@ue: USB ether interface  *  *	  *  */
end_comment

begin_function
specifier|static
name|void
name|smsc_stop
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|uether_getsc
argument_list|(
name|ue
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|uether_getifp
argument_list|(
name|ue
argument_list|)
decl_stmt|;
name|SMSC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SMSC_FLAG_LINK
expr_stmt|;
comment|/* 	 * stop all the transfers, if not already stopped: 	 */
name|usbd_transfer_stop
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|SMSC_BULK_DT_WR
index|]
argument_list|)
expr_stmt|;
name|usbd_transfer_stop
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|SMSC_BULK_DT_RD
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	smsc_phy_init - Initialises the in-built SMSC phy  *	@sc: driver soft context  *  *	Resets the PHY part of the chip and then initialises it to default  *	values.  The 'link down' and 'auto-negotiation complete' interrupts  *	from the PHY are also enabled, however we don't monitor the interrupt  *	endpoints for the moment.  *  *	RETURNS:  *	Returns 0 on success or EIO if failed to reset the PHY.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_phy_init
parameter_list|(
name|struct
name|smsc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|bmcr
decl_stmt|;
name|usb_ticks_t
name|start_ticks
decl_stmt|;
specifier|const
name|usb_ticks_t
name|max_ticks
init|=
name|USB_MS_TO_TICKS
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
name|SMSC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Reset phy and wait for reset to complete */
name|smsc_miibus_writereg
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_dev
argument_list|,
name|sc
operator|->
name|sc_phyno
argument_list|,
name|MII_BMCR
argument_list|,
name|BMCR_RESET
argument_list|)
expr_stmt|;
name|start_ticks
operator|=
name|ticks
expr_stmt|;
do|do
block|{
name|uether_pause
argument_list|(
operator|&
name|sc
operator|->
name|sc_ue
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
name|bmcr
operator|=
name|smsc_miibus_readreg
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_dev
argument_list|,
name|sc
operator|->
name|sc_phyno
argument_list|,
name|MII_BMCR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|bmcr
operator|&
name|MII_BMCR
operator|)
operator|&&
operator|(
operator|(
name|ticks
operator|-
name|start_ticks
operator|)
operator|<
name|max_ticks
operator|)
condition|)
do|;
if|if
condition|(
operator|(
call|(
name|usb_ticks_t
call|)
argument_list|(
name|ticks
operator|-
name|start_ticks
argument_list|)
operator|)
operator|>=
name|max_ticks
condition|)
block|{
name|smsc_err_printf
argument_list|(
name|sc
argument_list|,
literal|"PHY reset timed-out"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|smsc_miibus_writereg
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_dev
argument_list|,
name|sc
operator|->
name|sc_phyno
argument_list|,
name|MII_ANAR
argument_list|,
name|ANAR_10
operator||
name|ANAR_10_FD
operator||
name|ANAR_TX
operator||
name|ANAR_TX_FD
operator||
comment|/* all modes */
name|ANAR_CSMA
operator||
name|ANAR_FC
operator||
name|ANAR_PAUSE_ASYM
argument_list|)
expr_stmt|;
comment|/* Setup the phy to interrupt when the link goes down or autoneg completes */
name|smsc_miibus_readreg
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_dev
argument_list|,
name|sc
operator|->
name|sc_phyno
argument_list|,
name|SMSC_PHY_INTR_STAT
argument_list|)
expr_stmt|;
name|smsc_miibus_writereg
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_dev
argument_list|,
name|sc
operator|->
name|sc_phyno
argument_list|,
name|SMSC_PHY_INTR_MASK
argument_list|,
operator|(
name|SMSC_PHY_INTR_ANEG_COMP
operator||
name|SMSC_PHY_INTR_LINK_DOWN
operator|)
argument_list|)
expr_stmt|;
comment|/* Restart auto-negotation */
name|bmcr
operator|=
name|smsc_miibus_readreg
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_dev
argument_list|,
name|sc
operator|->
name|sc_phyno
argument_list|,
name|MII_BMCR
argument_list|)
expr_stmt|;
name|bmcr
operator||=
name|BMCR_STARTNEG
expr_stmt|;
name|smsc_miibus_writereg
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_dev
argument_list|,
name|sc
operator|->
name|sc_phyno
argument_list|,
name|MII_BMCR
argument_list|,
name|bmcr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	smsc_chip_init - Initialises the chip after power on  *	@sc: driver soft context  *  *	This initialisation sequence is modelled on the procedure in the Linux  *	driver.  *  *	RETURNS:  *	Returns 0 on success or an error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_chip_init
parameter_list|(
name|struct
name|smsc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|locked
decl_stmt|;
name|uint32_t
name|reg_val
decl_stmt|;
name|int
name|burst_cap
decl_stmt|;
name|locked
operator|=
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|SMSC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enter H/W config mode */
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_HW_CFG
argument_list|,
name|SMSC_HW_CFG_LRST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|smsc_wait_for_bits
argument_list|(
name|sc
argument_list|,
name|SMSC_HW_CFG
argument_list|,
name|SMSC_HW_CFG_LRST
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"timed-out waiting for reset to complete\n"
argument_list|)
expr_stmt|;
goto|goto
name|init_failed
goto|;
block|}
comment|/* Reset the PHY */
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_PM_CTRL
argument_list|,
name|SMSC_PM_CTRL_PHY_RST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|smsc_wait_for_bits
argument_list|(
name|sc
argument_list|,
name|SMSC_PM_CTRL
argument_list|,
name|SMSC_PM_CTRL_PHY_RST
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"timed-out waiting for phy reset to complete\n"
argument_list|)
expr_stmt|;
goto|goto
name|init_failed
goto|;
block|}
comment|/* Set the mac address */
if|if
condition|(
operator|(
name|err
operator|=
name|smsc_setmacaddress
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"failed to set the MAC address\n"
argument_list|)
expr_stmt|;
goto|goto
name|init_failed
goto|;
block|}
comment|/* Don't know what the HW_CFG_BIR bit is, but following the reset sequence 	 * as used in the Linux driver. 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|smsc_read_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_HW_CFG
argument_list|,
operator|&
name|reg_val
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"failed to read HW_CFG: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|init_failed
goto|;
block|}
name|reg_val
operator||=
name|SMSC_HW_CFG_BIR
expr_stmt|;
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_HW_CFG
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* There is a so called 'turbo mode' that the linux driver supports, it 	 * seems to allow you to jam multiple frames per Rx transaction.  By default 	 * this driver supports that and therefore allows multiple frames per URB. 	 * 	 * The xfer buffer size needs to reflect this as well, therefore based on 	 * the calculations in the Linux driver the RX bufsize is set to 18944, 	 *     bufsz = (16 * 1024 + 5 * 512) 	 * 	 * Burst capability is the number of URBs that can be in a burst of data/ 	 * ethernet frames. 	 */
if|if
condition|(
name|usbd_get_speed
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_udev
argument_list|)
operator|==
name|USB_SPEED_HIGH
condition|)
name|burst_cap
operator|=
literal|37
expr_stmt|;
else|else
name|burst_cap
operator|=
literal|128
expr_stmt|;
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_BURST_CAP
argument_list|,
name|burst_cap
argument_list|)
expr_stmt|;
comment|/* Set the default bulk in delay (magic value from Linux driver) */
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_BULK_IN_DLY
argument_list|,
literal|0x00002000
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise the RX interface 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|smsc_read_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_HW_CFG
argument_list|,
operator|&
name|reg_val
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"failed to read HW_CFG: (err = %d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|init_failed
goto|;
block|}
comment|/* Adjust the packet offset in the buffer (designed to try and align IP 	 * header on 4 byte boundary) 	 */
name|reg_val
operator|&=
operator|~
name|SMSC_HW_CFG_RXDOFF
expr_stmt|;
name|reg_val
operator||=
operator|(
name|ETHER_ALIGN
operator|<<
literal|9
operator|)
operator|&
name|SMSC_HW_CFG_RXDOFF
expr_stmt|;
comment|/* The following setings are used for 'turbo mode', a.k.a multiple frames 	 * per Rx transaction (again info taken form Linux driver). 	 */
name|reg_val
operator||=
operator|(
name|SMSC_HW_CFG_MEF
operator||
name|SMSC_HW_CFG_BCE
operator|)
expr_stmt|;
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_HW_CFG
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* Clear the status register ? */
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_INTR_STATUS
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Read and display the revision register */
if|if
condition|(
operator|(
name|err
operator|=
name|smsc_read_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_ID_REV
argument_list|,
operator|&
name|sc
operator|->
name|sc_rev_id
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"failed to read ID_REV (err = %d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|init_failed
goto|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_dev
argument_list|,
literal|"chip 0x%04lx, rev. %04lx\n"
argument_list|,
operator|(
name|sc
operator|->
name|sc_rev_id
operator|&
name|SMSC_ID_REV_CHIP_ID_MASK
operator|)
operator|>>
literal|16
argument_list|,
operator|(
name|sc
operator|->
name|sc_rev_id
operator|&
name|SMSC_ID_REV_CHIP_REV_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* GPIO/LED setup */
name|reg_val
operator|=
name|SMSC_LED_GPIO_CFG_SPD_LED
operator||
name|SMSC_LED_GPIO_CFG_LNK_LED
operator||
name|SMSC_LED_GPIO_CFG_FDX_LED
expr_stmt|;
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_LED_GPIO_CFG
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise the TX interface 	 */
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_FLOW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_AFC_CFG
argument_list|,
name|AFC_CFG_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Read the current MAC configuration */
if|if
condition|(
operator|(
name|err
operator|=
name|smsc_read_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_MAC_CSR
argument_list|,
operator|&
name|sc
operator|->
name|sc_mac_csr
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|smsc_warn_printf
argument_list|(
name|sc
argument_list|,
literal|"failed to read MAC_CSR (err=%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|init_failed
goto|;
block|}
comment|/* Vlan */
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_VLAN1
argument_list|,
operator|(
name|uint32_t
operator|)
name|ETHERTYPE_VLAN
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise the PHY 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|smsc_phy_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|init_failed
goto|;
comment|/* 	 * Start TX 	 */
name|sc
operator|->
name|sc_mac_csr
operator||=
name|SMSC_MAC_CSR_TXEN
expr_stmt|;
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_MAC_CSR
argument_list|,
name|sc
operator|->
name|sc_mac_csr
argument_list|)
expr_stmt|;
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_TX_CFG
argument_list|,
name|SMSC_TX_CFG_ON
argument_list|)
expr_stmt|;
comment|/* 	 * Start RX 	 */
name|sc
operator|->
name|sc_mac_csr
operator||=
name|SMSC_MAC_CSR_RXEN
expr_stmt|;
name|smsc_write_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_MAC_CSR
argument_list|,
name|sc
operator|->
name|sc_mac_csr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|SMSC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|init_failed
label|:
if|if
condition|(
operator|!
name|locked
condition|)
name|SMSC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smsc_err_printf
argument_list|(
name|sc
argument_list|,
literal|"smsc_chip_init failed (err=%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	smsc_ioctl - ioctl function for the device  *	@ifp: interface pointer  *	@cmd: the ioctl command  *	@data: data passed in the ioctl call, typically a pointer to struct ifreq.  *	  *	The ioctl routine is overridden to detect change requests for the H/W  *	checksum capabilities.  *  *	RETURNS:  *	0 on success and an error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|usb_ether
modifier|*
name|ue
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|smsc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|reinit
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|SIOCSIFCAP
condition|)
block|{
name|sc
operator|=
name|uether_getsc
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|SMSC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|reinit
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
comment|/* Modify the RX CSUM enable bits */
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|SMSC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|reinit
condition|)
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|1000000
name|uether_init
argument_list|(
name|ue
argument_list|)
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_init
argument_list|(
name|ue
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|rc
operator|=
name|uether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_comment
comment|/**  * Get MAC address from FDT blob. Firmware or loader should fill  * mac-address or local-mac-address property Returns 0 if MAC address  * obtained, error code otherwise  */
end_comment

begin_function
specifier|static
name|int
name|smsc_fdt_find_mac
parameter_list|(
name|unsigned
name|char
modifier|*
name|mac
parameter_list|)
block|{
name|phandle_t
name|child
decl_stmt|,
name|parent
decl_stmt|,
name|root
decl_stmt|;
name|int
name|len
decl_stmt|;
name|root
operator|=
name|OF_finddevice
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|parent
operator|=
name|root
expr_stmt|;
comment|/* Traverse through entire tree to find nodes usb ethernet nodes */
for|for
control|(
name|child
operator|=
name|OF_child
argument_list|(
name|parent
argument_list|)
init|;
name|child
operator|!=
literal|0
condition|;
name|child
operator|=
name|OF_peer
argument_list|(
name|child
argument_list|)
control|)
block|{
comment|/* Find a 'leaf'. Start the search from this node. */
while|while
condition|(
name|OF_child
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|parent
operator|=
name|child
expr_stmt|;
name|child
operator|=
name|OF_child
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fdt_is_compatible
argument_list|(
name|child
argument_list|,
literal|"net,ethernet"
argument_list|)
operator|&&
name|fdt_is_compatible
argument_list|(
name|child
argument_list|,
literal|"usb,device"
argument_list|)
condition|)
block|{
comment|/* Check if there is property */
if|if
condition|(
operator|(
name|len
operator|=
name|OF_getproplen
argument_list|(
name|child
argument_list|,
literal|"local-mac-address"
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|!=
name|ETHER_ADDR_LEN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|OF_getprop
argument_list|(
name|child
argument_list|,
literal|"local-mac-address"
argument_list|,
name|mac
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|OF_getproplen
argument_list|(
name|child
argument_list|,
literal|"mac-address"
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|!=
name|ETHER_ADDR_LEN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|OF_getprop
argument_list|(
name|child
argument_list|,
literal|"mac-address"
argument_list|,
name|mac
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|OF_peer
argument_list|(
name|child
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* No more siblings. */
name|child
operator|=
name|parent
expr_stmt|;
name|parent
operator|=
name|OF_parent
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  *	smsc_attach_post - Called after the driver attached to the USB interface  *	@ue: the USB ethernet device  *  *	This is where the chip is intialised for the first time.  This is different  *	from the smsc_init() function in that that one is designed to setup the  *	H/W to match the UE settings and can be called after a reset.  *  *  */
end_comment

begin_function
specifier|static
name|void
name|smsc_attach_post
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|uether_getsc
argument_list|(
name|ue
argument_list|)
decl_stmt|;
name|uint32_t
name|mac_h
decl_stmt|,
name|mac_l
decl_stmt|;
name|int
name|err
decl_stmt|;
name|smsc_dbg_printf
argument_list|(
name|sc
argument_list|,
literal|"smsc_attach_post\n"
argument_list|)
expr_stmt|;
comment|/* Setup some of the basics */
name|sc
operator|->
name|sc_phyno
operator|=
literal|1
expr_stmt|;
comment|/* Attempt to get the mac address, if an EEPROM is not attached this 	 * will just return FF:FF:FF:FF:FF:FF, so in such cases we invent a MAC 	 * address based on urandom. 	 */
name|memset
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
argument_list|,
literal|0xff
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Check if there is already a MAC address in the register */
if|if
condition|(
operator|(
name|smsc_read_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_MAC_ADDRL
argument_list|,
operator|&
name|mac_l
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|smsc_read_reg
argument_list|(
name|sc
argument_list|,
name|SMSC_MAC_ADDRH
argument_list|,
operator|&
name|mac_h
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
index|[
literal|5
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|mac_h
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
index|[
literal|4
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|mac_h
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
index|[
literal|3
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|mac_l
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
index|[
literal|2
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|mac_l
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
index|[
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|mac_l
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
index|[
literal|0
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|mac_l
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
comment|/* MAC address is not set so try to read from EEPROM, if that fails generate 	 * a random MAC address. 	 */
if|if
condition|(
operator|!
name|ETHER_IS_VALID
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
argument_list|)
condition|)
block|{
name|err
operator|=
name|smsc_eeprom_read
argument_list|(
name|sc
argument_list|,
literal|0x01
argument_list|,
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FDT
if|if
condition|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|!
name|ETHER_IS_VALID
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
argument_list|)
operator|)
condition|)
name|err
operator|=
name|smsc_fdt_find_mac
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|!
name|ETHER_IS_VALID
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
argument_list|)
operator|)
condition|)
block|{
name|read_random
argument_list|(
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
index|[
literal|0
index|]
operator|&=
operator|~
literal|0x01
expr_stmt|;
comment|/* unicast */
name|sc
operator|->
name|sc_ue
operator|.
name|ue_eaddr
index|[
literal|0
index|]
operator||=
literal|0x02
expr_stmt|;
comment|/* locally administered */
block|}
block|}
comment|/* Initialise the chip for the first time */
name|smsc_chip_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	smsc_attach_post_sub - Called after the driver attached to the USB interface  *	@ue: the USB ethernet device  *  *	Most of this is boilerplate code and copied from the base USB ethernet  *	driver.  It has been overriden so that we can indicate to the system that  *	the chip supports H/W checksumming.  *  *	RETURNS:  *	Returns 0 on success or a negative error code.  */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|1000000
end_if

begin_function
specifier|static
name|int
name|smsc_attach_post_sub
parameter_list|(
name|struct
name|usb_ether
modifier|*
name|ue
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|uether_getsc
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|ue
operator|->
name|ue_ifp
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|uether_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|smsc_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|uether_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* The chip supports TCP/UDP checksum offloading on TX and RX paths, however 	 * currently only RX checksum is supported in the driver (see top of file). 	 */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_RXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
comment|/* TX checksuming is disabled (for now?) 	ifp->if_capabilities |= IFCAP_TXCSUM; 	ifp->if_capenable |= IFCAP_TXCSUM; 	ifp->if_hwassist = CSUM_TCP | CSUM_UDP; 	*/
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|error
operator|=
name|mii_attach
argument_list|(
name|ue
operator|->
name|ue_dev
argument_list|,
operator|&
name|ue
operator|->
name|ue_miibus
argument_list|,
name|ifp
argument_list|,
name|uether_ifmedia_upd
argument_list|,
name|ue
operator|->
name|ue_methods
operator|->
name|ue_mii_sts
argument_list|,
name|BMSR_DEFCAPMASK
argument_list|,
name|sc
operator|->
name|sc_phyno
argument_list|,
name|MII_OFFSET_ANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD_version> 1000000 */
end_comment

begin_comment
comment|/**  *	smsc_probe - Probe the interface.   *	@dev: smsc device handle  *  *	Checks if the device is a match for this driver.  *  *	RETURNS:  *	Returns 0 on success or an error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bConfigIndex
operator|!=
name|SMSC_CONFIG_INDEX
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
operator|!=
name|SMSC_IFACE_IDX
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|usbd_lookup_id_by_uaa
argument_list|(
name|smsc_devs
argument_list|,
sizeof|sizeof
argument_list|(
name|smsc_devs
argument_list|)
argument_list|,
name|uaa
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	smsc_attach - Attach the interface.   *	@dev: smsc device handle  *  *	Allocate softc structures, do ifmedia setup and ethernet/BPF attach.  *  *	RETURNS:  *	Returns 0 on success or a negative error code.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_ether
modifier|*
name|ue
init|=
operator|&
name|sc
operator|->
name|sc_ue
decl_stmt|;
name|uint8_t
name|iface_index
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|USB_GET_DRIVER_INFO
argument_list|(
name|uaa
argument_list|)
expr_stmt|;
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Setup the endpoints for the SMSC LAN95xx device(s) */
name|iface_index
operator|=
name|SMSC_IFACE_IDX
expr_stmt|;
name|err
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|iface_index
argument_list|,
name|sc
operator|->
name|sc_xfer
argument_list|,
name|smsc_config
argument_list|,
name|SMSC_N_TRANSFER
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"error: allocating USB transfers failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|ue
operator|->
name|ue_sc
operator|=
name|sc
expr_stmt|;
name|ue
operator|->
name|ue_dev
operator|=
name|dev
expr_stmt|;
name|ue
operator|->
name|ue_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
name|ue
operator|->
name|ue_mtx
operator|=
operator|&
name|sc
operator|->
name|sc_mtx
expr_stmt|;
name|ue
operator|->
name|ue_methods
operator|=
operator|&
name|smsc_ue_methods
expr_stmt|;
name|err
operator|=
name|uether_ifattach
argument_list|(
name|ue
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"error: could not attach interface\n"
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
name|detach
label|:
name|smsc_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* failure */
block|}
end_function

begin_comment
comment|/**  *	smsc_detach - Detach the interface.   *	@dev: smsc device handle  *  *	RETURNS:  *	Returns 0.  */
end_comment

begin_function
specifier|static
name|int
name|smsc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|smsc_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_ether
modifier|*
name|ue
init|=
operator|&
name|sc
operator|->
name|sc_ue
decl_stmt|;
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|SMSC_N_TRANSFER
argument_list|)
expr_stmt|;
name|uether_ifdetach
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|smsc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|smsc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|smsc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|smsc_detach
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|smsc_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|smsc_miibus_writereg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|smsc_miibus_statchg
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|smsc_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"smsc"
block|,
operator|.
name|methods
operator|=
name|smsc_methods
block|,
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|smsc_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|smsc_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|smsc
argument_list|,
name|uhub
argument_list|,
name|smsc_driver
argument_list|,
name|smsc_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|smsc
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|smsc
argument_list|,
name|uether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|smsc
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|smsc
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|smsc
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|smsc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

