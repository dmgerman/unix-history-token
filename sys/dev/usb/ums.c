begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: ums.c,v 1.22 1999/01/12 22:06:48 augustss Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (augustss@carlstedt.se) at  * Carlstedt Research& Technology.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * HID spec: http://www.usb.org/developers/data/usbhid10.pdf  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbhid.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdevs.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_quirks.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/hid.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/wscons/wsconsio.h>
end_include

begin_include
include|#
directive|include
file|<dev/wscons/wsmousevar.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<machine/mouse.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UMS_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (umsdebug) logprintf x
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (umsdebug>(n)) logprintf x
end_define

begin_decl_stmt
name|int
name|umsdebug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UMSUNIT
parameter_list|(
name|s
parameter_list|)
value|(minor(s)&0x1f)
end_define

begin_define
define|#
directive|define
name|QUEUE_BUFSIZE
value|400
end_define

begin_comment
comment|/* MUST be divisible by 5 _and_ 8 */
end_comment

begin_struct
struct|struct
name|ums_softc
block|{
name|bdevice
name|sc_dev
decl_stmt|;
comment|/* base device */
name|usbd_interface_handle
name|sc_iface
decl_stmt|;
comment|/* interface */
name|usbd_pipe_handle
name|sc_intrpipe
decl_stmt|;
comment|/* interrupt pipe */
name|int
name|sc_ep_addr
decl_stmt|;
name|u_char
modifier|*
name|sc_ibuf
decl_stmt|;
name|u_int8_t
name|sc_iid
decl_stmt|;
name|int
name|sc_isize
decl_stmt|;
name|struct
name|hid_location
name|sc_loc_x
decl_stmt|,
name|sc_loc_y
decl_stmt|,
name|sc_loc_z
decl_stmt|;
name|struct
name|hid_location
modifier|*
name|sc_loc_btn
decl_stmt|;
name|int
name|sc_enabled
decl_stmt|;
name|int
name|sc_disconnected
decl_stmt|;
comment|/* device is gone */
name|int
name|flags
decl_stmt|;
comment|/* device configuration */
define|#
directive|define
name|UMS_Z
value|0x01
comment|/* z direction available */
name|int
name|nbuttons
decl_stmt|;
define|#
directive|define
name|MAX_BUTTONS
value|7
comment|/* chosen because sc_buttons is u_char */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|u_char
name|sc_buttons
decl_stmt|;
comment|/* mouse button status */
name|struct
name|device
modifier|*
name|sc_wsmousedev
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|u_char
name|qbuf
index|[
name|QUEUE_BUFSIZE
index|]
decl_stmt|;
comment|/* must be divisable by 3&4 */
name|u_char
name|dummy
index|[
literal|100
index|]
decl_stmt|;
comment|/* XXX just for safety and for now */
name|int
name|qcount
decl_stmt|,
name|qhead
decl_stmt|,
name|qtail
decl_stmt|;
name|mousehw_t
name|hw
decl_stmt|;
name|mousemode_t
name|mode
decl_stmt|;
name|mousestatus_t
name|status
decl_stmt|;
name|int
name|state
decl_stmt|;
define|#
directive|define
name|UMS_ASLEEP
value|0x01
comment|/* readFromDevice is waiting */
define|#
directive|define
name|UMS_SELECT
value|0x02
comment|/* select is waiting */
name|struct
name|selinfo
name|rsel
decl_stmt|;
comment|/* process waiting in select */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MOUSE_FLAGS_MASK
value|(HIO_CONST|HIO_RELATIVE)
end_define

begin_define
define|#
directive|define
name|MOUSE_FLAGS
value|(HIO_RELATIVE)
end_define

begin_decl_stmt
name|void
name|ums_intr
name|__P
argument_list|(
operator|(
name|usbd_request_handle
operator|,
name|usbd_private_handle
operator|,
name|usbd_status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ums_disco
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ums_enable
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ums_disable
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|ums_ioctl
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|u_long
operator|,
name|caddr_t
operator|,
name|int
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|wsmouse_accessops
name|ums_accessops
init|=
block|{
name|ums_enable
block|,
name|ums_ioctl
block|,
name|ums_disable
block|, }
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_decl_stmt
specifier|static
name|d_open_t
name|ums_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|ums_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|ums_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|ums_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|ums_poll
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UMS_CDEV_MAJOR
value|111
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ums_cdevsw
init|=
block|{
comment|/* open */
name|ums_open
block|,
comment|/* close */
name|ums_close
block|,
comment|/* read */
name|ums_read
block|,
comment|/* write */
name|nowrite
block|,
comment|/* ioctl */
name|ums_ioctl
block|,
comment|/* stop */
name|nostop
block|,
comment|/* reset */
name|noreset
block|,
comment|/* devtotty */
name|nodevtotty
block|,
comment|/* poll */
name|ums_poll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"ums"
block|,
comment|/* parms */
name|noparms
block|,
comment|/* maj */
name|UMS_CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|,
comment|/* maxio */
literal|0
block|,
comment|/* bmaj */
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|USB_DECLARE_DRIVER
argument_list|(
name|ums
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|USB_MATCH
argument_list|(
argument|ums
argument_list|)
end_macro

begin_block
block|{
name|USB_MATCH_START
argument_list|(
name|ums
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
name|int
name|size
decl_stmt|,
name|ret
decl_stmt|;
name|void
modifier|*
name|desc
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|uaa
operator|->
name|iface
condition|)
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id
operator|||
name|id
operator|->
name|bInterfaceClass
operator|!=
name|UCLASS_HID
condition|)
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
name|r
operator|=
name|usbd_alloc_report_desc
argument_list|(
name|uaa
operator|->
name|iface
argument_list|,
operator|&
name|desc
argument_list|,
operator|&
name|size
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
if|if
condition|(
name|hid_is_collection
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_MOUSE
argument_list|)
argument_list|)
condition|)
name|ret
operator|=
name|UMATCH_IFACECLASS
expr_stmt|;
else|else
name|ret
operator|=
name|UMATCH_NONE
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_block

begin_macro
name|USB_ATTACH
argument_list|(
argument|ums
argument_list|)
end_macro

begin_block
block|{
name|USB_ATTACH_START
argument_list|(
name|ums
argument_list|,
name|sc
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|usbd_interface_handle
name|iface
init|=
name|uaa
operator|->
name|iface
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|struct
name|wsmousedev_attach_args
name|a
decl_stmt|;
endif|#
directive|endif
name|int
name|size
decl_stmt|;
name|void
modifier|*
name|desc
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|char
name|devinfo
index|[
literal|1024
index|]
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|hid_location
name|loc_btn
decl_stmt|;
name|sc
operator|->
name|sc_disconnected
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_iface
operator|=
name|iface
expr_stmt|;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|iface
argument_list|)
expr_stmt|;
name|usbd_devinfo
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
literal|0
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|USB_ATTACH_SETUP
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %s, iclass %d/%d\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|devinfo
argument_list|,
name|id
operator|->
name|bInterfaceClass
argument_list|,
name|id
operator|->
name|bInterfaceSubClass
argument_list|)
expr_stmt|;
name|ed
operator|=
name|usbd_interface2endpoint_descriptor
argument_list|(
name|iface
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ed
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not read endpoint descriptor\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ums_attach: bLength=%d bDescriptorType=%d "
literal|"bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d"
literal|" bInterval=%d\n"
operator|,
name|ed
operator|->
name|bLength
operator|,
name|ed
operator|->
name|bDescriptorType
operator|,
name|ed
operator|->
name|bEndpointAddress
operator|&
name|UE_ADDR
operator|,
name|ed
operator|->
name|bEndpointAddress
operator|&
name|UE_IN
condition|?
literal|"in"
else|:
literal|"out"
operator|,
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|,
name|UGETW
argument_list|(
name|ed
operator|->
name|wMaxPacketSize
argument_list|)
operator|,
name|ed
operator|->
name|bInterval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ed
operator|->
name|bEndpointAddress
operator|&
name|UE_IN
operator|)
operator|!=
name|UE_IN
operator|||
operator|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|!=
name|UE_INTERRUPT
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected endpoint\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
name|r
operator|=
name|usbd_alloc_report_desc
argument_list|(
name|uaa
operator|->
name|iface
argument_list|,
operator|&
name|desc
argument_list|,
operator|&
name|size
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
if|if
condition|(
operator|!
name|hid_locate
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_X
argument_list|)
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_x
argument_list|,
operator|&
name|flags
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: mouse has no X report\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|MOUSE_FLAGS_MASK
operator|)
operator|!=
name|MOUSE_FLAGS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: X report 0x%04x not supported\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hid_locate
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_Y
argument_list|)
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_y
argument_list|,
operator|&
name|flags
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: mouse has no Y report\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|MOUSE_FLAGS_MASK
operator|)
operator|!=
name|MOUSE_FLAGS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Y report 0x%04x not supported\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
comment|/* try to guess the Z activator: first check Z, then WHEEL */
if|if
condition|(
name|hid_locate
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_Z
argument_list|)
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_z
argument_list|,
operator|&
name|flags
argument_list|)
operator|||
name|hid_locate
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_WHEEL
argument_list|)
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_z
argument_list|,
operator|&
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MOUSE_FLAGS_MASK
operator|)
operator|!=
name|MOUSE_FLAGS
condition|)
block|{
name|sc
operator|->
name|sc_loc_z
operator|.
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Bad Z coord, ignore it */
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|UMS_Z
expr_stmt|;
block|}
block|}
comment|/* figure out the number of buttons */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|MAX_BUTTONS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|hid_locate
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_BUTTON
argument_list|,
name|i
argument_list|)
argument_list|,
name|hid_input
argument_list|,
operator|&
name|loc_btn
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|sc
operator|->
name|nbuttons
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_loc_btn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hid_location
argument_list|)
operator|*
name|sc
operator|->
name|nbuttons
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_loc_btn
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no memory\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: %d buttons%s\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|nbuttons
argument_list|,
name|sc
operator|->
name|flags
operator|&
name|UMS_Z
condition|?
literal|" and Z dir."
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|sc
operator|->
name|nbuttons
condition|;
name|i
operator|++
control|)
name|hid_locate
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_BUTTON
argument_list|,
name|i
argument_list|)
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_btn
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_isize
operator|=
name|hid_report_size
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_iid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ibuf
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|sc_isize
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_ibuf
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no memory\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_loc_btn
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ep_addr
operator|=
name|ed
operator|->
name|bEndpointAddress
expr_stmt|;
name|sc
operator|->
name|sc_disconnected
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMS_DEBUG
name|DPRINTF
argument_list|(
operator|(
literal|"ums_attach: sc=%p\n"
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ums_attach: X\t%d/%d\n"
operator|,
name|sc
operator|->
name|sc_loc_x
operator|.
name|pos
operator|,
name|sc
operator|->
name|sc_loc_x
operator|.
name|size
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ums_attach: Y\t%d/%d\n"
operator|,
name|sc
operator|->
name|sc_loc_x
operator|.
name|pos
operator|,
name|sc
operator|->
name|sc_loc_x
operator|.
name|size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|UMS_Z
condition|)
name|DPRINTF
argument_list|(
operator|(
literal|"ums_attach: Z\t%d/%d\n"
operator|,
name|sc
operator|->
name|sc_loc_z
operator|.
name|pos
operator|,
name|sc
operator|->
name|sc_loc_z
operator|.
name|size
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|sc
operator|->
name|nbuttons
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ums_attach: B%d\t%d/%d\n"
operator|,
name|i
operator|,
name|sc
operator|->
name|sc_loc_btn
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|pos
operator|,
name|sc
operator|->
name|sc_loc_btn
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|size
operator|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"ums_attach: size=%d, id=%d\n"
operator|,
name|sc
operator|->
name|sc_isize
operator|,
name|sc
operator|->
name|sc_iid
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|a
operator|.
name|accessops
operator|=
operator|&
name|ums_accessops
expr_stmt|;
name|a
operator|.
name|accesscookie
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_wsmousedev
operator|=
name|config_found
argument_list|(
name|self
argument_list|,
operator|&
name|a
argument_list|,
name|wsmousedevprint
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|sc
operator|->
name|nbuttons
operator|>
name|MOUSE_MSC_MAXBUTTON
condition|)
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|MOUSE_MSC_MAXBUTTON
expr_stmt|;
else|else
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|sc
operator|->
name|nbuttons
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|iftype
operator|=
name|MOUSE_IF_USB
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_MOUSE
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|model
operator|=
name|MOUSE_MODEL_GENERIC
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|accelfactor
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
name|sc
operator|->
name|status
operator|.
name|obutton
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|=
name|sc
operator|->
name|status
operator|.
name|dy
operator|=
name|sc
operator|->
name|status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rsel
operator|.
name|si_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rsel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|USB_ATTACH_SUCCESS_RETURN
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
specifier|static
name|int
name|ums_detach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|ums_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_enabled
condition|)
name|ums_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_disconnected
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: disconnected\n"
operator|,
name|USBDEVNAME
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|self
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_loc_btn
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_ibuf
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
comment|/* 	 * XXX If we wakeup the process here, the device will be gone by 	 * the time the process gets a chance to notice. *_close and friends 	 * should be fixed to handle this case. 	 * Or we should do a delayed detach for this. 	 */
if|#
directive|if
literal|0
comment|/* someone waiting for data */
block|if (sc->state& UMS_ASLEEP) { 		sc->state&= ~UMS_ASLEEP; 		wakeup(sc); 	} 	if (sc->state& UMS_SELECT) { 		sc->state&= ~UMS_SELECT; 		selwakeup(&sc->rsel); 	}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|ums_disco
parameter_list|(
name|p
parameter_list|)
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|ums_softc
modifier|*
name|sc
init|=
name|p
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ums_disco: sc=%p\n"
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
name|usbd_abort_pipe
argument_list|(
name|sc
operator|->
name|sc_intrpipe
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_disconnected
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ums_intr
parameter_list|(
name|reqh
parameter_list|,
name|addr
parameter_list|,
name|status
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
name|usbd_private_handle
name|addr
decl_stmt|;
name|usbd_status
name|status
decl_stmt|;
block|{
name|struct
name|ums_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|u_char
modifier|*
name|ibuf
decl_stmt|;
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|dz
decl_stmt|;
name|u_char
name|buttons
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
define|#
directive|define
name|UMS_BUT
parameter_list|(
name|i
parameter_list|)
value|((i) == 1 || (i) == 2 ? 3 - (i) : i)
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
define|#
directive|define
name|UMS_BUT
parameter_list|(
name|i
parameter_list|)
value|((i)< 3 ? (((i) + 2) % 3) : (i))
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ums_intr: sc=%p status=%d\n"
operator|,
name|sc
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ums_intr: data = %02x %02x %02x\n"
operator|,
name|sc
operator|->
name|sc_ibuf
index|[
literal|0
index|]
operator|,
name|sc
operator|->
name|sc_ibuf
index|[
literal|1
index|]
operator|,
name|sc
operator|->
name|sc_ibuf
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|USBD_CANCELLED
condition|)
return|return;
if|if
condition|(
name|status
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ums_intr: status=%d\n"
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
name|usbd_clear_endpoint_stall_async
argument_list|(
name|sc
operator|->
name|sc_intrpipe
argument_list|)
expr_stmt|;
return|return;
block|}
name|ibuf
operator|=
name|sc
operator|->
name|sc_ibuf
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_iid
condition|)
block|{
if|if
condition|(
operator|*
name|ibuf
operator|++
operator|!=
name|sc
operator|->
name|sc_iid
condition|)
return|return;
block|}
name|dx
operator|=
name|hid_get_data
argument_list|(
name|ibuf
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_x
argument_list|)
expr_stmt|;
name|dy
operator|=
operator|-
name|hid_get_data
argument_list|(
name|ibuf
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_y
argument_list|)
expr_stmt|;
name|dz
operator|=
operator|-
name|hid_get_data
argument_list|(
name|ibuf
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_z
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nbuttons
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hid_get_data
argument_list|(
name|ibuf
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_btn
index|[
name|i
index|]
argument_list|)
condition|)
name|buttons
operator||=
operator|(
literal|1
operator|<<
name|UMS_BUT
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|dx
operator|||
name|dy
operator|||
name|buttons
operator|!=
name|sc
operator|->
name|sc_buttons
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ums_intr: x:%d y:%d z:%d buttons:0x%x\n"
operator|,
name|dx
operator|,
name|dy
operator|,
name|dz
operator|,
name|buttons
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_buttons
operator|=
name|buttons
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_wsmousedev
condition|)
name|wsmouse_input
argument_list|(
name|sc
operator|->
name|sc_wsmousedev
argument_list|,
name|buttons
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|dz
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|dx
operator|||
name|dy
operator|||
name|dz
operator|||
operator|(
name|sc
operator|->
name|flags
operator|&
name|UMS_Z
operator|)
operator|||
name|buttons
operator|!=
name|sc
operator|->
name|status
operator|.
name|button
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ums_intr: x:%d y:%d z:%d buttons:0x%x\n"
operator|,
name|dx
operator|,
name|dy
operator|,
name|dz
operator|,
name|buttons
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
name|buttons
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|+=
name|dx
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dy
operator|+=
name|dy
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dz
operator|+=
name|dz
expr_stmt|;
comment|/* Discard data in case of full buffer */
if|if
condition|(
name|sc
operator|->
name|qcount
operator|==
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"Buffer full, discarded packet"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dx
operator|>
literal|254
condition|)
name|dx
operator|=
literal|254
expr_stmt|;
if|if
condition|(
name|dx
operator|<
operator|-
literal|256
condition|)
name|dx
operator|=
operator|-
literal|256
expr_stmt|;
if|if
condition|(
name|dy
operator|>
literal|254
condition|)
name|dy
operator|=
literal|254
expr_stmt|;
if|if
condition|(
name|dy
operator|<
operator|-
literal|256
condition|)
name|dy
operator|=
operator|-
literal|256
expr_stmt|;
if|if
condition|(
name|dz
operator|>
literal|126
condition|)
name|dz
operator|=
literal|126
expr_stmt|;
if|if
condition|(
name|dz
operator|<
operator|-
literal|128
condition|)
name|dz
operator|=
operator|-
literal|128
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
index|]
operator|=
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
index|]
operator||=
operator|~
name|buttons
operator|&
name|MOUSE_MSC_BUTTONS
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
operator|+
literal|1
index|]
operator|=
name|dx
operator|>>
literal|1
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
operator|+
literal|2
index|]
operator|=
name|dy
operator|>>
literal|1
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
operator|+
literal|3
index|]
operator|=
name|dx
operator|-
operator|(
name|dx
operator|>>
literal|1
operator|)
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
operator|+
literal|4
index|]
operator|=
name|dy
operator|-
operator|(
name|dy
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
operator|+
literal|5
index|]
operator|=
name|dz
operator|>>
literal|1
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
operator|+
literal|6
index|]
operator|=
name|dz
operator|-
operator|(
name|dz
operator|>>
literal|1
operator|)
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
operator|+
literal|7
index|]
operator|=
operator|(
operator|(
operator|~
name|buttons
operator|>>
literal|3
operator|)
operator|&
name|MOUSE_SYS_EXTBUTTONS
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|qhead
operator|+=
name|sc
operator|->
name|mode
operator|.
name|packetsize
expr_stmt|;
name|sc
operator|->
name|qcount
operator|+=
name|sc
operator|->
name|mode
operator|.
name|packetsize
expr_stmt|;
ifdef|#
directive|ifdef
name|UMS_DEBUG
if|if
condition|(
name|sc
operator|->
name|qhead
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
condition|)
name|DPRINTF
argument_list|(
operator|(
literal|"Buffer overrun! %d %d\n"
operator|,
name|sc
operator|->
name|qhead
operator|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* wrap round at end of buffer */
if|if
condition|(
name|sc
operator|->
name|qhead
operator|>=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
condition|)
name|sc
operator|->
name|qhead
operator|=
literal|0
expr_stmt|;
comment|/* someone waiting for data */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|UMS_ASLEEP
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|UMS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|UMS_SELECT
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|UMS_SELECT
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
specifier|static
name|int
name|ums_enable
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|ums_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_enabled
condition|)
return|return
name|EBUSY
return|;
name|sc
operator|->
name|sc_enabled
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|sc
operator|->
name|sc_buttons
operator|=
literal|0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sc
operator|->
name|qcount
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|qhead
operator|=
name|sc
operator|->
name|qtail
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
name|sc
operator|->
name|status
operator|.
name|obutton
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|=
name|sc
operator|->
name|status
operator|.
name|dy
operator|=
name|sc
operator|->
name|status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Set up interrupt pipe. */
name|r
operator|=
name|usbd_open_pipe_intr
argument_list|(
name|sc
operator|->
name|sc_iface
argument_list|,
name|sc
operator|->
name|sc_ep_addr
argument_list|,
name|USBD_SHORT_XFER_OK
argument_list|,
operator|&
name|sc
operator|->
name|sc_intrpipe
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_ibuf
argument_list|,
name|sc
operator|->
name|sc_isize
argument_list|,
name|ums_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ums_enable: usbd_open_pipe_intr failed, error=%d\n"
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_enabled
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|usbd_set_disco
argument_list|(
name|sc
operator|->
name|sc_intrpipe
argument_list|,
name|ums_disco
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|ums_disable
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|ums_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
comment|/* Disable interrupts. */
name|usbd_abort_pipe
argument_list|(
name|sc
operator|->
name|sc_intrpipe
argument_list|)
expr_stmt|;
name|usbd_close_pipe
argument_list|(
name|sc
operator|->
name|sc_intrpipe
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_enabled
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|sc
operator|->
name|qcount
operator|!=
literal|0
condition|)
name|DPRINTF
argument_list|(
operator|(
literal|"Discarded %d bytes in queue\n"
operator|,
name|sc
operator|->
name|qcount
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
specifier|static
name|int
name|ums_ioctl
parameter_list|(
name|v
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|WSMOUSEIO_GTYPE
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|WSMOUSE_TYPE_USB
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
specifier|static
name|int
name|ums_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|USB_GET_SC_OPEN
argument_list|(
name|ums
argument_list|,
name|UMSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
name|ums_enable
argument_list|(
name|sc
argument_list|)
return|;
block|}
specifier|static
name|int
name|ums_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|USB_GET_SC
argument_list|(
name|ums
argument_list|,
name|UMSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sc
operator|->
name|sc_enabled
condition|)
name|ums_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|ums_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|USB_GET_SC
argument_list|(
name|ums
argument_list|,
name|UMSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|int
name|s
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
index|]
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|qcount
operator|==
literal|0
condition|)
block|{
comment|/* NWH XXX non blocking I/O ?? 		if (non blocking I/O ) { 			splx(s); 			return EWOULDBLOCK; 		} else { 		*/
name|sc
operator|->
name|state
operator||=
name|UMS_ASLEEP
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"umsrea"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_enabled
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINTR
return|;
block|}
block|}
while|while
condition|(
operator|(
name|sc
operator|->
name|qcount
operator|>
literal|0
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|)
condition|)
block|{
name|l
operator|=
operator|(
name|sc
operator|->
name|qcount
operator|<
name|uio
operator|->
name|uio_resid
condition|?
name|sc
operator|->
name|qcount
else|:
name|uio
operator|->
name|uio_resid
operator|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|l
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
operator|-
name|sc
operator|->
name|qtail
condition|)
comment|/* transfer till end of buf */
name|l
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
operator|-
name|sc
operator|->
name|qtail
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|uiomove
argument_list|(
operator|&
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qtail
index|]
argument_list|,
name|l
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|qcount
operator|-
name|l
operator|<
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"qcount below 0, count=%d l=%d\n"
operator|,
name|sc
operator|->
name|qcount
operator|,
name|l
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|qcount
operator|=
name|l
expr_stmt|;
block|}
name|sc
operator|->
name|qcount
operator|-=
name|l
expr_stmt|;
comment|/* remove the bytes from the buffer */
name|sc
operator|->
name|qtail
operator|=
operator|(
name|sc
operator|->
name|qtail
operator|+
name|l
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|ums_poll
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|USB_GET_SC
argument_list|(
name|ums
argument_list|,
name|UMSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|qcount
condition|)
block|{
name|revents
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|state
operator||=
name|UMS_SELECT
expr_stmt|;
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|revents
return|;
block|}
name|int
name|ums_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|USB_GET_SC
argument_list|(
name|ums
argument_list|,
name|UMSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|mousemode_t
name|mode
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOUSE_GETHWINFO
case|:
operator|*
operator|(
name|mousehw_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|hw
expr_stmt|;
break|break;
case|case
name|MOUSE_GETMODE
case|:
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|mode
expr_stmt|;
break|break;
case|case
name|MOUSE_SETMODE
case|:
name|mode
operator|=
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|level
operator|==
operator|-
literal|1
condition|)
comment|/* don't change the current setting */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mode
operator|.
name|level
operator|<
literal|0
operator|)
operator|||
operator|(
name|mode
operator|.
name|level
operator|>
literal|1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
name|mode
operator|.
name|level
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|nbuttons
operator|>
name|MOUSE_MSC_MAXBUTTON
condition|)
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|MOUSE_MSC_MAXBUTTON
expr_stmt|;
else|else
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|sc
operator|->
name|nbuttons
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|nbuttons
operator|>
name|MOUSE_SYS_MAXBUTTON
condition|)
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|MOUSE_SYS_MAXBUTTON
expr_stmt|;
else|else
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|sc
operator|->
name|nbuttons
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|MOUSE_SYS_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_SYS_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_SYS_SYNC
expr_stmt|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|qhead
operator|=
name|sc
operator|->
name|qtail
operator|=
name|sc
operator|->
name|qcount
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETLEVEL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|mode
operator|.
name|level
expr_stmt|;
break|break;
case|case
name|MOUSE_SETLEVEL
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|<
literal|0
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|>
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|nbuttons
operator|>
name|MOUSE_MSC_MAXBUTTON
condition|)
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|MOUSE_MSC_MAXBUTTON
expr_stmt|;
else|else
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|sc
operator|->
name|nbuttons
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|nbuttons
operator|>
name|MOUSE_SYS_MAXBUTTON
condition|)
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|MOUSE_SYS_MAXBUTTON
expr_stmt|;
else|else
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|sc
operator|->
name|nbuttons
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|MOUSE_SYS_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_SYS_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_SYS_SYNC
expr_stmt|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|qhead
operator|=
name|sc
operator|->
name|qtail
operator|=
name|sc
operator|->
name|qcount
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETSTATUS
case|:
block|{
name|mousestatus_t
modifier|*
name|status
init|=
operator|(
name|mousestatus_t
operator|*
operator|)
name|addr
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
operator|*
name|status
operator|=
name|sc
operator|->
name|status
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|obutton
operator|=
name|sc
operator|->
name|status
operator|.
name|button
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|=
name|sc
operator|->
name|status
operator|.
name|dy
operator|=
name|sc
operator|->
name|status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|dx
operator|||
name|status
operator|->
name|dy
operator|||
name|status
operator|->
name|dz
condition|)
name|status
operator|->
name|flags
operator||=
name|MOUSE_POSCHANGED
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|button
operator|!=
name|status
operator|->
name|obutton
condition|)
name|status
operator|->
name|flags
operator||=
name|MOUSE_BUTTONSCHANGED
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|DEV_DRIVER_MODULE
argument_list|(
name|ums
argument_list|,
name|uhub
argument_list|,
name|ums_driver
argument_list|,
name|ums_devclass
argument_list|,
name|UMS_CDEV_MAJOR
argument_list|,
name|NOMAJ
argument_list|,
name|ums_cdevsw
argument_list|,
name|usbd_driver_load
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

