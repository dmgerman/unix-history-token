begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (lennart@augustsson.net) at  * Carlstedt Research& Technology.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * HID spec: http://www.usb.org/developers/devclass_docs/HID1_11.pdf  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbhid.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_quirks.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/hid.h>
end_include

begin_include
include|#
directive|include
file|<sys/mouse.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (umsdebug) logprintf x
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (umsdebug>(n)) logprintf x
end_define

begin_decl_stmt
name|int
name|umsdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|ums
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB ums"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_ums
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|umsdebug
argument_list|,
literal|0
argument_list|,
literal|"ums debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UMSUNIT
parameter_list|(
name|s
parameter_list|)
value|(minor(s)&0x1f)
end_define

begin_define
define|#
directive|define
name|MS_TO_TICKS
parameter_list|(
name|ms
parameter_list|)
value|((ms) * hz / 1000)
end_define

begin_define
define|#
directive|define
name|QUEUE_BUFSIZE
value|400
end_define

begin_comment
comment|/* MUST be divisible by 5 _and_ 8 */
end_comment

begin_struct
struct|struct
name|ums_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
comment|/* base device */
name|usbd_interface_handle
name|sc_iface
decl_stmt|;
comment|/* interface */
name|usbd_pipe_handle
name|sc_intrpipe
decl_stmt|;
comment|/* interrupt pipe */
name|int
name|sc_ep_addr
decl_stmt|;
name|u_char
modifier|*
name|sc_ibuf
decl_stmt|;
name|u_int8_t
name|sc_iid
decl_stmt|;
name|int
name|sc_isize
decl_stmt|;
name|struct
name|hid_location
name|sc_loc_x
decl_stmt|,
name|sc_loc_y
decl_stmt|,
name|sc_loc_z
decl_stmt|,
name|sc_loc_t
decl_stmt|;
name|struct
name|hid_location
modifier|*
name|sc_loc_btn
decl_stmt|;
name|usb_callout_t
name|callout_handle
decl_stmt|;
comment|/* for spurious button ups */
name|int
name|sc_enabled
decl_stmt|;
name|int
name|sc_disconnected
decl_stmt|;
comment|/* device is gone */
name|int
name|flags
decl_stmt|;
comment|/* device configuration */
define|#
directive|define
name|UMS_Z
value|0x01
comment|/* z direction available */
define|#
directive|define
name|UMS_SPUR_BUT_UP
value|0x02
comment|/* spurious button up events */
define|#
directive|define
name|UMS_T
value|0x04
comment|/* aa direction available (tilt) */
name|int
name|nbuttons
decl_stmt|;
define|#
directive|define
name|MAX_BUTTONS
value|31
comment|/* chosen because sc_buttons is int */
name|u_char
name|qbuf
index|[
name|QUEUE_BUFSIZE
index|]
decl_stmt|;
comment|/* must be divisable by 3&4 */
name|u_char
name|dummy
index|[
literal|100
index|]
decl_stmt|;
comment|/* XXX just for safety and for now */
name|int
name|qcount
decl_stmt|,
name|qhead
decl_stmt|,
name|qtail
decl_stmt|;
name|mousehw_t
name|hw
decl_stmt|;
name|mousemode_t
name|mode
decl_stmt|;
name|mousestatus_t
name|status
decl_stmt|;
name|int
name|state
decl_stmt|;
define|#
directive|define
name|UMS_ASLEEP
value|0x01
comment|/* readFromDevice is waiting */
define|#
directive|define
name|UMS_SELECT
value|0x02
comment|/* select is waiting */
name|struct
name|selinfo
name|rsel
decl_stmt|;
comment|/* process waiting in select */
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
comment|/* specfs */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MOUSE_FLAGS_MASK
value|(HIO_CONST|HIO_RELATIVE)
end_define

begin_define
define|#
directive|define
name|MOUSE_FLAGS
value|(HIO_RELATIVE)
end_define

begin_function_decl
specifier|static
name|void
name|ums_intr
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|priv
parameter_list|,
name|usbd_status
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ums_add_to_queue
parameter_list|(
name|struct
name|ums_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
name|int
name|dz
parameter_list|,
name|int
name|dt
parameter_list|,
name|int
name|buttons
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ums_add_to_queue_timeout
parameter_list|(
name|void
modifier|*
name|priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ums_enable
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ums_disable
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|ums_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|ums_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|ums_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|ums_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|ums_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ums_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|ums_open
block|,
operator|.
name|d_close
operator|=
name|ums_close
block|,
operator|.
name|d_read
operator|=
name|ums_read
block|,
operator|.
name|d_ioctl
operator|=
name|ums_ioctl
block|,
operator|.
name|d_poll
operator|=
name|ums_poll
block|,
operator|.
name|d_name
operator|=
literal|"ums"
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|USB_DECLARE_DRIVER
argument_list|(
name|ums
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|ums_match
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
name|int
name|size
decl_stmt|,
name|ret
decl_stmt|;
name|void
modifier|*
name|desc
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|uaa
operator|->
name|iface
condition|)
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id
operator|||
name|id
operator|->
name|bInterfaceClass
operator|!=
name|UICLASS_HID
condition|)
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
name|err
operator|=
name|usbd_read_report_desc
argument_list|(
name|uaa
operator|->
name|iface
argument_list|,
operator|&
name|desc
argument_list|,
operator|&
name|size
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
if|if
condition|(
name|hid_is_collection
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_MOUSE
argument_list|)
argument_list|)
condition|)
name|ret
operator|=
name|UMATCH_IFACECLASS
expr_stmt|;
else|else
name|ret
operator|=
name|UMATCH_NONE
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ums_attach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|USB_ATTACH_START
argument_list|(
name|ums
argument_list|,
name|sc
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|usbd_interface_handle
name|iface
init|=
name|uaa
operator|->
name|iface
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
decl_stmt|;
name|int
name|size
decl_stmt|;
name|void
modifier|*
name|desc
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|hid_location
name|loc_btn
decl_stmt|;
name|sc
operator|->
name|sc_disconnected
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_iface
operator|=
name|iface
expr_stmt|;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|iface
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|self
expr_stmt|;
name|ed
operator|=
name|usbd_interface2endpoint_descriptor
argument_list|(
name|iface
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ed
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not read endpoint descriptor\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ums_attach: bLength=%d bDescriptorType=%d "
literal|"bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d"
literal|" bInterval=%d\n"
operator|,
name|ed
operator|->
name|bLength
operator|,
name|ed
operator|->
name|bDescriptorType
operator|,
name|UE_GET_ADDR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator|,
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_IN
condition|?
literal|"in"
else|:
literal|"out"
operator|,
name|UE_GET_XFERTYPE
argument_list|(
name|ed
operator|->
name|bmAttributes
argument_list|)
operator|,
name|UGETW
argument_list|(
name|ed
operator|->
name|wMaxPacketSize
argument_list|)
operator|,
name|ed
operator|->
name|bInterval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator|!=
name|UE_DIR_IN
operator|||
name|UE_GET_XFERTYPE
argument_list|(
name|ed
operator|->
name|bmAttributes
argument_list|)
operator|!=
name|UE_INTERRUPT
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected endpoint\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|err
operator|=
name|usbd_read_report_desc
argument_list|(
name|uaa
operator|->
name|iface
argument_list|,
operator|&
name|desc
argument_list|,
operator|&
name|size
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|!
name|hid_locate
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_X
argument_list|)
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_x
argument_list|,
operator|&
name|flags
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: mouse has no X report\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|MOUSE_FLAGS_MASK
operator|)
operator|!=
name|MOUSE_FLAGS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: X report 0x%04x not supported\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|!
name|hid_locate
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_Y
argument_list|)
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_y
argument_list|,
operator|&
name|flags
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: mouse has no Y report\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|MOUSE_FLAGS_MASK
operator|)
operator|!=
name|MOUSE_FLAGS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Y report 0x%04x not supported\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* try to guess the Z activator: first check Z, then WHEEL */
if|if
condition|(
name|hid_locate
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_Z
argument_list|)
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_z
argument_list|,
operator|&
name|flags
argument_list|)
operator|||
name|hid_locate
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_WHEEL
argument_list|)
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_z
argument_list|,
operator|&
name|flags
argument_list|)
operator|||
name|hid_locate
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_TWHEEL
argument_list|)
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_z
argument_list|,
operator|&
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MOUSE_FLAGS_MASK
operator|)
operator|!=
name|MOUSE_FLAGS
condition|)
block|{
name|sc
operator|->
name|sc_loc_z
operator|.
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Bad Z coord, ignore it */
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|UMS_Z
expr_stmt|;
block|}
block|}
comment|/* The Microsoft Wireless Intellimouse 2.0 reports it's wheel 	 * using 0x0048 (i've called it HUG_TWHEEL) and seems to expect 	 * you to know that the byte after the wheel is the tilt axis. 	 * There are no other HID axis descriptors other than X,Y and  	 * TWHEEL */
if|if
condition|(
name|hid_locate
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_TWHEEL
argument_list|)
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_t
argument_list|,
operator|&
name|flags
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_loc_t
operator|.
name|pos
operator|=
name|sc
operator|->
name|sc_loc_t
operator|.
name|pos
operator|+
literal|8
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|UMS_T
expr_stmt|;
block|}
comment|/* figure out the number of buttons */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|MAX_BUTTONS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|hid_locate
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_BUTTON
argument_list|,
name|i
argument_list|)
argument_list|,
name|hid_input
argument_list|,
operator|&
name|loc_btn
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|sc
operator|->
name|nbuttons
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_loc_btn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hid_location
argument_list|)
operator|*
name|sc
operator|->
name|nbuttons
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_loc_btn
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no memory\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|printf
argument_list|(
literal|"%s: %d buttons%s%s.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|nbuttons
argument_list|,
name|sc
operator|->
name|flags
operator|&
name|UMS_Z
condition|?
literal|" and Z dir"
else|:
literal|""
argument_list|,
name|sc
operator|->
name|flags
operator|&
name|UMS_T
condition|?
literal|" and a TILT dir"
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|sc
operator|->
name|nbuttons
condition|;
name|i
operator|++
control|)
name|hid_locate
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_BUTTON
argument_list|,
name|i
argument_list|)
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_btn
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_isize
operator|=
name|hid_report_size
argument_list|(
name|desc
argument_list|,
name|size
argument_list|,
name|hid_input
argument_list|,
operator|&
name|sc
operator|->
name|sc_iid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ibuf
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|sc_isize
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_ibuf
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no memory\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_loc_btn
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|sc_ep_addr
operator|=
name|ed
operator|->
name|bEndpointAddress
expr_stmt|;
name|sc
operator|->
name|sc_disconnected
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|DPRINTF
argument_list|(
operator|(
literal|"ums_attach: sc=%p\n"
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ums_attach: X\t%d/%d\n"
operator|,
name|sc
operator|->
name|sc_loc_x
operator|.
name|pos
operator|,
name|sc
operator|->
name|sc_loc_x
operator|.
name|size
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ums_attach: Y\t%d/%d\n"
operator|,
name|sc
operator|->
name|sc_loc_y
operator|.
name|pos
operator|,
name|sc
operator|->
name|sc_loc_y
operator|.
name|size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|UMS_Z
condition|)
name|DPRINTF
argument_list|(
operator|(
literal|"ums_attach: Z\t%d/%d\n"
operator|,
name|sc
operator|->
name|sc_loc_z
operator|.
name|pos
operator|,
name|sc
operator|->
name|sc_loc_z
operator|.
name|size
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|sc
operator|->
name|nbuttons
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ums_attach: B%d\t%d/%d\n"
operator|,
name|i
operator|,
name|sc
operator|->
name|sc_loc_btn
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|pos
operator|,
name|sc
operator|->
name|sc_loc_btn
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|size
operator|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"ums_attach: size=%d, id=%d\n"
operator|,
name|sc
operator|->
name|sc_isize
operator|,
name|sc
operator|->
name|sc_iid
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|nbuttons
operator|>
name|MOUSE_MSC_MAXBUTTON
condition|)
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|MOUSE_MSC_MAXBUTTON
expr_stmt|;
else|else
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|sc
operator|->
name|nbuttons
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|iftype
operator|=
name|MOUSE_IF_USB
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_MOUSE
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|model
operator|=
name|MOUSE_MODEL_GENERIC
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|accelfactor
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
name|sc
operator|->
name|status
operator|.
name|obutton
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|=
name|sc
operator|->
name|status
operator|.
name|dy
operator|=
name|sc
operator|->
name|status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|ums_cdevsw
argument_list|,
name|device_get_unit
argument_list|(
name|self
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0644
argument_list|,
literal|"ums%d"
argument_list|,
name|device_get_unit
argument_list|(
name|self
argument_list|)
argument_list|)
expr_stmt|;
name|usb_callout_init
argument_list|(
name|sc
operator|->
name|callout_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbd_get_quirks
argument_list|(
name|uaa
operator|->
name|device
argument_list|)
operator|->
name|uq_flags
operator|&
name|UQ_SPUR_BUT_UP
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: Spurious button up events\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|UMS_SPUR_BUT_UP
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ums_detach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|ums_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_enabled
condition|)
name|ums_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: disconnected\n"
operator|,
name|device_get_nameunit
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_loc_btn
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_ibuf
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
comment|/* someone waiting for data */
comment|/* 	 * XXX If we wakeup the process here, the device will be gone by 	 * the time the process gets a chance to notice. *_close and friends 	 * should be fixed to handle this case. 	 * Or we should do a delayed detach for this. 	 * Does this delay now force tsleep to exit with an error? 	 */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|UMS_ASLEEP
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|UMS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|UMS_SELECT
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|UMS_SELECT
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|sc
operator|->
name|rsel
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
block|}
name|destroy_dev
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ums_intr
parameter_list|(
name|xfer
parameter_list|,
name|addr
parameter_list|,
name|status
parameter_list|)
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|usbd_private_handle
name|addr
decl_stmt|;
name|usbd_status
name|status
decl_stmt|;
block|{
name|struct
name|ums_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|u_char
modifier|*
name|ibuf
decl_stmt|;
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|dz
decl_stmt|,
name|dt
decl_stmt|;
name|int
name|buttons
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
define|#
directive|define
name|UMS_BUT
parameter_list|(
name|i
parameter_list|)
value|((i)< 3 ? (((i) + 2) % 3) : (i))
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ums_intr: sc=%p status=%d\n"
operator|,
name|sc
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ums_intr: data ="
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_isize
condition|;
name|i
operator|++
control|)
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|" %02x"
operator|,
name|sc
operator|->
name|sc_ibuf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|USBD_CANCELLED
condition|)
return|return;
if|if
condition|(
name|status
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ums_intr: status=%d\n"
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|USBD_STALLED
condition|)
name|usbd_clear_endpoint_stall_async
argument_list|(
name|sc
operator|->
name|sc_intrpipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|USBD_IOERROR
condition|)
return|return;
block|}
name|ibuf
operator|=
name|sc
operator|->
name|sc_ibuf
expr_stmt|;
comment|/* 	 * The M$ Wireless Intellimouse 2.0 sends 1 extra leading byte of 	 * data compared to most USB mice. This byte frequently switches 	 * from 0x01 (usual state) to 0x02. I assume it is to allow 	 * extra, non-standard, reporting (say battery-life). However 	 * at the same time it generates a left-click message on the button 	 * byte which causes spurious left-click's where there shouldn't be. 	 * This should sort that. 	 * Currently it's the only user of UMS_T so use it as an identifier. 	 * We probably should switch to some more official quirk. 	 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|UMS_T
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_iid
condition|)
block|{
if|if
condition|(
operator|*
name|ibuf
operator|++
operator|==
literal|0x02
condition|)
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_iid
condition|)
block|{
if|if
condition|(
operator|*
name|ibuf
operator|++
operator|!=
name|sc
operator|->
name|sc_iid
condition|)
return|return;
block|}
block|}
name|dx
operator|=
name|hid_get_data
argument_list|(
name|ibuf
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_x
argument_list|)
expr_stmt|;
name|dy
operator|=
operator|-
name|hid_get_data
argument_list|(
name|ibuf
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_y
argument_list|)
expr_stmt|;
name|dz
operator|=
operator|-
name|hid_get_data
argument_list|(
name|ibuf
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_z
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|UMS_T
condition|)
name|dt
operator|=
operator|-
name|hid_get_data
argument_list|(
name|ibuf
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_t
argument_list|)
expr_stmt|;
else|else
name|dt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nbuttons
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hid_get_data
argument_list|(
name|ibuf
argument_list|,
operator|&
name|sc
operator|->
name|sc_loc_btn
index|[
name|i
index|]
argument_list|)
condition|)
name|buttons
operator||=
operator|(
literal|1
operator|<<
name|UMS_BUT
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|dx
operator|||
name|dy
operator|||
name|dz
operator|||
name|dt
operator|||
operator|(
name|sc
operator|->
name|flags
operator|&
name|UMS_Z
operator|)
operator|||
name|buttons
operator|!=
name|sc
operator|->
name|status
operator|.
name|button
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ums_intr: x:%d y:%d z:%d t:%d buttons:0x%x\n"
operator|,
name|dx
operator|,
name|dy
operator|,
name|dz
operator|,
name|dt
operator|,
name|buttons
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
name|buttons
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|+=
name|dx
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dy
operator|+=
name|dy
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dz
operator|+=
name|dz
expr_stmt|;
comment|/* sc->status.dt += dt;*/
comment|/* no way to export this yet */
comment|/* Discard data in case of full buffer */
if|if
condition|(
name|sc
operator|->
name|qcount
operator|==
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"Buffer full, discarded packet"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * The Qtronix keyboard has a built in PS/2 port for a mouse. 		 * The firmware once in a while posts a spurious button up 		 * event. This event we ignore by doing a timeout for 50 msecs. 		 * If we receive dx=dy=dz=buttons=0 before we add the event to 		 * the queue. 		 * In any other case we delete the timeout event. 		 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|UMS_SPUR_BUT_UP
operator|&&
name|dx
operator|==
literal|0
operator|&&
name|dy
operator|==
literal|0
operator|&&
name|dz
operator|==
literal|0
operator|&&
name|dt
operator|==
literal|0
operator|&&
name|buttons
operator|==
literal|0
condition|)
block|{
name|usb_callout
argument_list|(
name|sc
operator|->
name|callout_handle
argument_list|,
name|MS_TO_TICKS
argument_list|(
literal|50
comment|/*msecs*/
argument_list|)
argument_list|,
name|ums_add_to_queue_timeout
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usb_uncallout
argument_list|(
name|sc
operator|->
name|callout_handle
argument_list|,
name|ums_add_to_queue_timeout
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
name|ums_add_to_queue
argument_list|(
name|sc
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|dz
argument_list|,
name|dt
argument_list|,
name|buttons
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ums_add_to_queue_timeout
parameter_list|(
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|ums_softc
modifier|*
name|sc
init|=
name|priv
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|ums_add_to_queue
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ums_add_to_queue
parameter_list|(
name|struct
name|ums_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
name|int
name|dz
parameter_list|,
name|int
name|dt
parameter_list|,
name|int
name|buttons
parameter_list|)
block|{
comment|/* Discard data in case of full buffer */
if|if
condition|(
name|sc
operator|->
name|qhead
operator|+
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"Buffer full, discarded packet"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dx
operator|>
literal|254
condition|)
name|dx
operator|=
literal|254
expr_stmt|;
if|if
condition|(
name|dx
operator|<
operator|-
literal|256
condition|)
name|dx
operator|=
operator|-
literal|256
expr_stmt|;
if|if
condition|(
name|dy
operator|>
literal|254
condition|)
name|dy
operator|=
literal|254
expr_stmt|;
if|if
condition|(
name|dy
operator|<
operator|-
literal|256
condition|)
name|dy
operator|=
operator|-
literal|256
expr_stmt|;
if|if
condition|(
name|dz
operator|>
literal|126
condition|)
name|dz
operator|=
literal|126
expr_stmt|;
if|if
condition|(
name|dz
operator|<
operator|-
literal|128
condition|)
name|dz
operator|=
operator|-
literal|128
expr_stmt|;
if|if
condition|(
name|dt
operator|>
literal|126
condition|)
name|dt
operator|=
literal|126
expr_stmt|;
if|if
condition|(
name|dt
operator|<
operator|-
literal|128
condition|)
name|dt
operator|=
operator|-
literal|128
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
index|]
operator|=
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
index|]
operator||=
operator|~
name|buttons
operator|&
name|MOUSE_MSC_BUTTONS
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
operator|+
literal|1
index|]
operator|=
name|dx
operator|>>
literal|1
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
operator|+
literal|2
index|]
operator|=
name|dy
operator|>>
literal|1
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
operator|+
literal|3
index|]
operator|=
name|dx
operator|-
operator|(
name|dx
operator|>>
literal|1
operator|)
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
operator|+
literal|4
index|]
operator|=
name|dy
operator|-
operator|(
name|dy
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
operator|+
literal|5
index|]
operator|=
name|dz
operator|>>
literal|1
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
operator|+
literal|6
index|]
operator|=
name|dz
operator|-
operator|(
name|dz
operator|>>
literal|1
operator|)
expr_stmt|;
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qhead
operator|+
literal|7
index|]
operator|=
operator|(
operator|(
operator|~
name|buttons
operator|>>
literal|3
operator|)
operator|&
name|MOUSE_SYS_EXTBUTTONS
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|qhead
operator|+=
name|sc
operator|->
name|mode
operator|.
name|packetsize
expr_stmt|;
name|sc
operator|->
name|qcount
operator|+=
name|sc
operator|->
name|mode
operator|.
name|packetsize
expr_stmt|;
comment|/* wrap round at end of buffer */
if|if
condition|(
name|sc
operator|->
name|qhead
operator|>=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
condition|)
name|sc
operator|->
name|qhead
operator|=
literal|0
expr_stmt|;
comment|/* someone waiting for data */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|UMS_ASLEEP
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|UMS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|UMS_SELECT
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|UMS_SELECT
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|sc
operator|->
name|rsel
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ums_enable
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|ums_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_enabled
condition|)
return|return
name|EBUSY
return|;
name|sc
operator|->
name|sc_enabled
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|qcount
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|qhead
operator|=
name|sc
operator|->
name|qtail
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
name|sc
operator|->
name|status
operator|.
name|obutton
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|=
name|sc
operator|->
name|status
operator|.
name|dy
operator|=
name|sc
operator|->
name|status
operator|.
name|dz
comment|/* = sc->status.dt */
operator|=
literal|0
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|(
expr|struct
name|callout_handle
operator|*
operator|)
operator|&
name|sc
operator|->
name|callout_handle
argument_list|)
expr_stmt|;
comment|/* Set up interrupt pipe. */
name|err
operator|=
name|usbd_open_pipe_intr
argument_list|(
name|sc
operator|->
name|sc_iface
argument_list|,
name|sc
operator|->
name|sc_ep_addr
argument_list|,
name|USBD_SHORT_XFER_OK
argument_list|,
operator|&
name|sc
operator|->
name|sc_intrpipe
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_ibuf
argument_list|,
name|sc
operator|->
name|sc_isize
argument_list|,
name|ums_intr
argument_list|,
name|USBD_DEFAULT_INTERVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ums_enable: usbd_open_pipe_intr failed, error=%d\n"
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_enabled
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ums_disable
parameter_list|(
name|priv
parameter_list|)
name|void
modifier|*
name|priv
decl_stmt|;
block|{
name|struct
name|ums_softc
modifier|*
name|sc
init|=
name|priv
decl_stmt|;
name|usb_uncallout
argument_list|(
name|sc
operator|->
name|callout_handle
argument_list|,
name|ums_add_to_queue_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable interrupts. */
name|usbd_abort_pipe
argument_list|(
name|sc
operator|->
name|sc_intrpipe
argument_list|)
expr_stmt|;
name|usbd_close_pipe
argument_list|(
name|sc
operator|->
name|sc_intrpipe
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|qcount
operator|!=
literal|0
condition|)
name|DPRINTF
argument_list|(
operator|(
literal|"Discarded %d bytes in queue\n"
operator|,
name|sc
operator|->
name|qcount
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ums_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ums_softc
modifier|*
name|sc
decl_stmt|;
name|USB_GET_SC_OPEN
argument_list|(
name|ums
argument_list|,
name|UMSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
name|ums_enable
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ums_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ums_softc
modifier|*
name|sc
decl_stmt|;
name|USB_GET_SC
argument_list|(
name|ums
argument_list|,
name|UMSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sc
operator|->
name|sc_enabled
condition|)
name|ums_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ums_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|ums_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
index|]
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|USB_GET_SC
argument_list|(
name|ums
argument_list|,
name|UMSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
while|while
condition|(
name|sc
operator|->
name|qcount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
comment|/* non-blocking I/O */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EWOULDBLOCK
return|;
block|}
name|sc
operator|->
name|state
operator||=
name|UMS_ASLEEP
expr_stmt|;
comment|/* blocking I/O */
name|error
operator|=
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"umsrea"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_enabled
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINTR
return|;
block|}
comment|/* check whether the device is still there */
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|ums_devclass
argument_list|,
name|UMSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
block|}
comment|/* 	 * XXX we could optimise the use of splx/splusb somewhat. The writer 	 * process only extends qcount and qtail. We could copy them and use the copies 	 * to do the copying out of the queue. 	 */
while|while
condition|(
operator|(
name|sc
operator|->
name|qcount
operator|>
literal|0
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|)
condition|)
block|{
name|l
operator|=
operator|(
name|sc
operator|->
name|qcount
operator|<
name|uio
operator|->
name|uio_resid
condition|?
name|sc
operator|->
name|qcount
else|:
name|uio
operator|->
name|uio_resid
operator|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|l
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
operator|-
name|sc
operator|->
name|qtail
condition|)
comment|/* transfer till end of buf */
name|l
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
operator|-
name|sc
operator|->
name|qtail
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|uiomove
argument_list|(
operator|&
name|sc
operator|->
name|qbuf
index|[
name|sc
operator|->
name|qtail
index|]
argument_list|,
name|l
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|qcount
operator|-
name|l
operator|<
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"qcount below 0, count=%d l=%d\n"
operator|,
name|sc
operator|->
name|qcount
operator|,
name|l
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|qcount
operator|=
name|l
expr_stmt|;
block|}
name|sc
operator|->
name|qcount
operator|-=
name|l
expr_stmt|;
comment|/* remove the bytes from the buffer */
name|sc
operator|->
name|qtail
operator|=
operator|(
name|sc
operator|->
name|qtail
operator|+
name|l
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ums_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ums_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|USB_GET_SC
argument_list|(
name|ums
argument_list|,
name|UMSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|qcount
condition|)
block|{
name|revents
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|state
operator||=
name|UMS_SELECT
expr_stmt|;
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|revents
return|;
block|}
end_function

begin_function
name|int
name|ums_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ums_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|mousemode_t
name|mode
decl_stmt|;
name|USB_GET_SC
argument_list|(
name|ums
argument_list|,
name|UMSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return
name|EIO
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOUSE_GETHWINFO
case|:
operator|*
operator|(
name|mousehw_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|hw
expr_stmt|;
break|break;
case|case
name|MOUSE_GETMODE
case|:
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|mode
expr_stmt|;
break|break;
case|case
name|MOUSE_SETMODE
case|:
name|mode
operator|=
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|level
operator|==
operator|-
literal|1
condition|)
comment|/* don't change the current setting */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mode
operator|.
name|level
operator|<
literal|0
operator|)
operator|||
operator|(
name|mode
operator|.
name|level
operator|>
literal|1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
name|mode
operator|.
name|level
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|nbuttons
operator|>
name|MOUSE_MSC_MAXBUTTON
condition|)
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|MOUSE_MSC_MAXBUTTON
expr_stmt|;
else|else
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|sc
operator|->
name|nbuttons
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|nbuttons
operator|>
name|MOUSE_SYS_MAXBUTTON
condition|)
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|MOUSE_SYS_MAXBUTTON
expr_stmt|;
else|else
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|sc
operator|->
name|nbuttons
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|MOUSE_SYS_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_SYS_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_SYS_SYNC
expr_stmt|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|qhead
operator|=
name|sc
operator|->
name|qtail
operator|=
name|sc
operator|->
name|qcount
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETLEVEL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|mode
operator|.
name|level
expr_stmt|;
break|break;
case|case
name|MOUSE_SETLEVEL
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|<
literal|0
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|>
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|nbuttons
operator|>
name|MOUSE_MSC_MAXBUTTON
condition|)
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|MOUSE_MSC_MAXBUTTON
expr_stmt|;
else|else
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|sc
operator|->
name|nbuttons
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|nbuttons
operator|>
name|MOUSE_SYS_MAXBUTTON
condition|)
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|MOUSE_SYS_MAXBUTTON
expr_stmt|;
else|else
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|sc
operator|->
name|nbuttons
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|MOUSE_SYS_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_SYS_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_SYS_SYNC
expr_stmt|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|qbuf
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|qhead
operator|=
name|sc
operator|->
name|qtail
operator|=
name|sc
operator|->
name|qcount
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETSTATUS
case|:
block|{
name|mousestatus_t
modifier|*
name|status
init|=
operator|(
name|mousestatus_t
operator|*
operator|)
name|addr
decl_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
operator|*
name|status
operator|=
name|sc
operator|->
name|status
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|obutton
operator|=
name|sc
operator|->
name|status
operator|.
name|button
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|=
name|sc
operator|->
name|status
operator|.
name|dy
operator|=
name|sc
operator|->
name|status
operator|.
name|dz
operator|=
comment|/* sc->status.dt = */
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|dx
operator|||
name|status
operator|->
name|dy
operator|||
name|status
operator|->
name|dz
comment|/* || status->dt */
condition|)
name|status
operator|->
name|flags
operator||=
name|MOUSE_POSCHANGED
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|button
operator|!=
name|status
operator|->
name|obutton
condition|)
name|status
operator|->
name|flags
operator||=
name|MOUSE_BUTTONSCHANGED
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ums
argument_list|,
name|uhub
argument_list|,
name|ums_driver
argument_list|,
name|ums_devclass
argument_list|,
name|usbd_driver_load
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

