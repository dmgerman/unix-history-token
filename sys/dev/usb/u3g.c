begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2008 AnyWi Technologies  * Author: Andrea Guzzo<aguzzo@anywi.com>  * * based on uark.c 1.1 2006/08/14 08:30:22 jsg *  * * parts from ubsa.c 183348 2008-09-25 12:00:56Z phk *  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Notes:  * - The detour through the tty layer is ridiculously expensive wrt buffering  *   due to the high speeds.  *   We should consider adding a simple r/w device which allows attaching of PPP  *   in a more efficient way.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/ucomvar.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
end_if

begin_include
include|#
directive|include
file|"opt_u3g.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_comment
comment|//#define U3G_DEBUG
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|U3G_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
modifier|...
parameter_list|)
value|do { if (u3gdebug) device_printf(sc->sc_dev, ##x); } while (0)
end_define

begin_decl_stmt
name|int
name|u3gdebug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
modifier|...
parameter_list|)
end_define

begin_comment
comment|/* nop */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|U3G_MAXPORTS
value|4
end_define

begin_define
define|#
directive|define
name|U3G_CONFIG_INDEX
value|0
end_define

begin_struct
struct|struct
name|u3g_softc
block|{
name|struct
name|ucom_softc
name|sc_ucom
index|[
name|U3G_MAXPORTS
index|]
decl_stmt|;
name|device_t
name|sc_dev
decl_stmt|;
name|usbd_device_handle
name|sc_udev
decl_stmt|;
name|u_int8_t
name|sc_speed
decl_stmt|;
name|u_int8_t
name|sc_flags
decl_stmt|;
name|u_char
name|sc_numports
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|u3g_open
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|portno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|u3g_close
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|portno
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|ucom_callback
name|u3g_callback
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|u3g_open
block|,
name|u3g_close
block|,
name|NULL
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|u3g_speeds_s
block|{
name|u_int32_t
name|ispeed
decl_stmt|;
name|u_int32_t
name|ospeed
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|u3g_speeds_s
name|u3g_speeds
index|[]
init|=
block|{
define|#
directive|define
name|U3GSP_GPRS
value|0
block|{
literal|64000
block|,
literal|64000
block|}
block|,
define|#
directive|define
name|U3GSP_EDGE
value|1
block|{
literal|384000
block|,
literal|64000
block|}
block|,
define|#
directive|define
name|U3GSP_CDMA
value|2
block|{
literal|384000
block|,
literal|64000
block|}
block|,
define|#
directive|define
name|U3GSP_UMTS
value|3
block|{
literal|384000
block|,
literal|64000
block|}
block|,
define|#
directive|define
name|U3GSP_HSDPA
value|4
block|{
literal|1200000
block|,
literal|384000
block|}
block|,
define|#
directive|define
name|U3GSP_HSUPA
value|5
block|{
literal|1200000
block|,
literal|384000
block|}
block|,
define|#
directive|define
name|U3GSP_HSPA
value|6
block|{
literal|7200000
block|,
literal|384000
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Various supported device vendors/products.  */
end_comment

begin_struct
struct|struct
name|u3g_dev_type_s
block|{
name|struct
name|usb_devno
name|devno
decl_stmt|;
name|u_int8_t
name|speed
decl_stmt|;
name|u_int8_t
name|flags
decl_stmt|;
define|#
directive|define
name|U3GFL_NONE
value|0x00
define|#
directive|define
name|U3GFL_HUAWEI_INIT
value|0x01
comment|// Requires init command (Huawei cards)
define|#
directive|define
name|U3GFL_SCSI_EJECT
value|0x02
comment|// Requires SCSI eject command (Novatel)
define|#
directive|define
name|U3GFL_SIERRA_INIT
value|0x04
comment|// Requires init command (Sierra cards)
define|#
directive|define
name|U3GFL_STUB_WAIT
value|0x08
comment|// Device reappears after a short delay
block|}
struct|;
end_struct

begin_comment
comment|// Note: The entries marked with XXX should be checked for the correct speed
end_comment

begin_comment
comment|// indication to set the buffer sizes.
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|u3g_dev_type_s
name|u3g_devs
index|[]
init|=
block|{
comment|/* OEM: Option */
block|{
block|{
name|USB_VENDOR_OPTION
block|,
name|USB_PRODUCT_OPTION_GT3G
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
block|{
block|{
name|USB_VENDOR_OPTION
block|,
name|USB_PRODUCT_OPTION_GT3GQUAD
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
block|{
block|{
name|USB_VENDOR_OPTION
block|,
name|USB_PRODUCT_OPTION_GT3GPLUS
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
block|{
block|{
name|USB_VENDOR_OPTION
block|,
name|USB_PRODUCT_OPTION_GTMAX36
block|}
block|,
name|U3GSP_HSDPA
block|,
name|U3GFL_NONE
block|}
block|,
block|{
block|{
name|USB_VENDOR_OPTION
block|,
name|USB_PRODUCT_OPTION_GTMAXHSUPA
block|}
block|,
name|U3GSP_HSDPA
block|,
name|U3GFL_NONE
block|}
block|,
block|{
block|{
name|USB_VENDOR_OPTION
block|,
name|USB_PRODUCT_OPTION_VODAFONEMC3G
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|/* OEM: Qualcomm, Inc. */
block|{
block|{
name|USB_VENDOR_QUALCOMMINC
block|,
name|USB_PRODUCT_QUALCOMMINC_ZTE_STOR
block|}
block|,
name|U3GSP_CDMA
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
block|{
block|{
name|USB_VENDOR_QUALCOMMINC
block|,
name|USB_PRODUCT_QUALCOMMINC_CDMA_MSM
block|}
block|,
name|U3GSP_CDMA
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
comment|/* OEM: Huawei */
block|{
block|{
name|USB_VENDOR_HUAWEI
block|,
name|USB_PRODUCT_HUAWEI_MOBILE
block|}
block|,
name|U3GSP_HSDPA
block|,
name|U3GFL_HUAWEI_INIT
block|}
block|,
block|{
block|{
name|USB_VENDOR_HUAWEI
block|,
name|USB_PRODUCT_HUAWEI_E220
block|}
block|,
name|U3GSP_HSPA
block|,
name|U3GFL_HUAWEI_INIT
block|}
block|,
comment|/* OEM: Novatel */
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_CDMA_MODEM
block|}
block|,
name|U3GSP_CDMA
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_ES620
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_MC950D
block|}
block|,
name|U3GSP_HSUPA
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_U720
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_U727
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_U740
block|}
block|,
name|U3GSP_HSDPA
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_U740_2
block|}
block|,
name|U3GSP_HSDPA
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_U870
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_V620
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_V640
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_V720
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_V740
block|}
block|,
name|U3GSP_HSDPA
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_X950D
block|}
block|,
name|U3GSP_HSUPA
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_XU870
block|}
block|,
name|U3GSP_HSDPA
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
block|{
block|{
name|USB_VENDOR_NOVATEL
block|,
name|USB_PRODUCT_NOVATEL_ZEROCD
block|}
block|,
name|U3GSP_HSUPA
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
block|{
block|{
name|USB_VENDOR_DELL
block|,
name|USB_PRODUCT_DELL_U740
block|}
block|,
name|U3GSP_HSDPA
block|,
name|U3GFL_SCSI_EJECT
block|}
block|,
comment|/* OEM: Merlin */
block|{
block|{
name|USB_VENDOR_MERLIN
block|,
name|USB_PRODUCT_MERLIN_V620
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
comment|/* OEM: Sierra Wireless: */
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_AIRCARD580
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_AIRCARD595
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_AC595U
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_AC597E
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_C597
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_AC880
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_AC880E
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_AC880U
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_AC881
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_AC881E
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_AC881U
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_EM5625
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_MC5720
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_MC5720_2
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_MC5725
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_MINI5725
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_AIRCARD875
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_MC8755
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_MC8755_2
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_MC8755_3
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_MC8765
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_AC875U
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_MC8775_2
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_MC8780
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_MC8781
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_NONE
block|}
block|,
comment|// XXX
block|{
block|{
name|USB_VENDOR_SIERRA
block|,
name|USB_PRODUCT_SIERRA_TRUINSTALL
block|}
block|,
name|U3GSP_UMTS
block|,
name|U3GFL_SIERRA_INIT
block|}
block|,
comment|// Sierra TruInstaller device ID
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|u3g_lookup
parameter_list|(
name|v
parameter_list|,
name|p
parameter_list|)
value|((const struct u3g_dev_type_s *)usb_lookup(u3g_devs, v, p))
end_define

begin_function
specifier|static
name|int
name|u3g_match
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|self
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|u3g_dev_type_s
modifier|*
name|u3g_dev_type
decl_stmt|;
if|if
condition|(
operator|!
name|uaa
operator|->
name|iface
condition|)
return|return
name|UMATCH_NONE
return|;
name|u3g_dev_type
operator|=
name|u3g_lookup
argument_list|(
name|uaa
operator|->
name|vendor
argument_list|,
name|uaa
operator|->
name|product
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u3g_dev_type
condition|)
return|return
name|UMATCH_NONE
return|;
if|if
condition|(
name|u3g_dev_type
operator|->
name|flags
operator|&
name|U3GFL_HUAWEI_INIT
condition|)
block|{
comment|/* If the interface class of the first interface is no longer 		 * mass storage the card has changed to modem (see u3g_attach() 		 * below). 		 */
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id
operator|||
name|id
operator|->
name|bInterfaceClass
operator|==
name|UICLASS_MASS
condition|)
return|return
name|UMATCH_NONE
return|;
block|}
return|return
name|UMATCH_VENDOR_PRODUCT_CONF_IFACE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|u3g_attach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|u3g_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|self
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|u3g_dev_type_s
modifier|*
name|u3g_dev_type
decl_stmt|;
name|usbd_device_handle
name|dev
init|=
name|uaa
operator|->
name|device
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|usb_config_descriptor_t
modifier|*
name|cd
decl_stmt|;
name|char
name|devnamefmt
index|[
literal|32
index|]
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
name|char
modifier|*
name|devinfo
init|=
name|malloc
argument_list|(
literal|1024
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
argument_list|)
decl_stmt|;
name|usbd_devinfo
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"%s\n"
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|devinfo
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* get the config descriptor */
name|cd
operator|=
name|usbd_get_config_descriptor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"failed to get configuration descriptor\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|sc_dev
operator|=
name|self
expr_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|dev
expr_stmt|;
name|u3g_dev_type
operator|=
name|u3g_lookup
argument_list|(
name|uaa
operator|->
name|vendor
argument_list|,
name|uaa
operator|->
name|product
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|u3g_dev_type
operator|->
name|flags
expr_stmt|;
name|sc
operator|->
name|sc_speed
operator|=
name|u3g_dev_type
operator|->
name|speed
expr_stmt|;
name|sprintf
argument_list|(
name|devnamefmt
argument_list|,
literal|"U%d.%%d"
argument_list|,
name|device_get_unit
argument_list|(
name|self
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|portno
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uaa
operator|->
name|nifaces
operator|&&
name|portno
operator|<
name|U3G_MAXPORTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|&&
name|id
operator|->
name|bInterfaceClass
operator|==
name|UICLASS_MASS
condition|)
block|{
comment|/* We attach to the interface instead of the device as 			 * some devices have a built-in SD card reader. 			 * Claim the first umass device (cdX) as it contains 			 * only Windows drivers anyway (CD-ROM), hiding it. 			 */
ifndef|#
directive|ifndef
name|U3G_DEBUG
if|if
condition|(
operator|!
name|bootverbose
condition|)
if|if
condition|(
name|uaa
operator|->
name|vendor
operator|==
name|USB_VENDOR_HUAWEI
condition|)
if|if
condition|(
name|id
operator|->
name|bInterfaceNumber
operator|==
literal|2
condition|)
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
name|int
name|bulkin_no
init|=
operator|-
literal|1
decl_stmt|,
name|bulkout_no
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|claim_iface
init|=
literal|0
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|id
operator|->
name|bNumEndpoints
condition|;
name|n
operator|++
control|)
block|{
name|ed
operator|=
name|usbd_interface2endpoint_descriptor
argument_list|(
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_IN
operator|&&
name|UE_GET_XFERTYPE
argument_list|(
name|ed
operator|->
name|bmAttributes
argument_list|)
operator|==
name|UE_BULK
condition|)
name|bulkin_no
operator|=
name|ed
operator|->
name|bEndpointAddress
expr_stmt|;
elseif|else
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_OUT
operator|&&
name|UE_GET_XFERTYPE
argument_list|(
name|ed
operator|->
name|bmAttributes
argument_list|)
operator|==
name|UE_BULK
condition|)
name|bulkout_no
operator|=
name|ed
operator|->
name|bEndpointAddress
expr_stmt|;
comment|/* If we have found a pair of bulk-in/-out endpoints 			 * create a serial port for it. Note: We assume that 			 * the bulk-in and bulk-out endpoints appear in pairs. 			 */
if|if
condition|(
name|bulkin_no
operator|!=
operator|-
literal|1
operator|&&
name|bulkout_no
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|ucom_softc
modifier|*
name|ucom
init|=
operator|&
name|sc
operator|->
name|sc_ucom
index|[
name|portno
index|]
decl_stmt|;
name|ucom
operator|->
name|sc_dev
operator|=
name|self
expr_stmt|;
name|ucom
operator|->
name|sc_udev
operator|=
name|dev
expr_stmt|;
name|ucom
operator|->
name|sc_iface
operator|=
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
expr_stmt|;
name|ucom
operator|->
name|sc_bulkin_no
operator|=
name|bulkin_no
expr_stmt|;
name|ucom
operator|->
name|sc_bulkout_no
operator|=
name|bulkout_no
expr_stmt|;
comment|// Allocate a buffer enough for 10ms worth of data
name|ucom
operator|->
name|sc_ibufsize
operator|=
name|u3g_speeds
index|[
name|sc
operator|->
name|sc_speed
index|]
operator|.
name|ispeed
operator|/
name|USB_FRAMES_PER_SECOND
operator|*
literal|10
expr_stmt|;
name|ucom
operator|->
name|sc_ibufsizepad
operator|=
name|ucom
operator|->
name|sc_ibufsize
expr_stmt|;
name|ucom
operator|->
name|sc_obufsize
operator|=
name|u3g_speeds
index|[
name|sc
operator|->
name|sc_speed
index|]
operator|.
name|ospeed
operator|/
name|USB_FRAMES_PER_SECOND
operator|*
literal|10
expr_stmt|;
name|ucom
operator|->
name|sc_opkthdrlen
operator|=
literal|0
expr_stmt|;
name|ucom
operator|->
name|sc_callback
operator|=
operator|&
name|u3g_callback
expr_stmt|;
name|ucom
operator|->
name|sc_parent
operator|=
name|sc
expr_stmt|;
name|ucom
operator|->
name|sc_portno
operator|=
name|portno
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"port=%d iface=%d in=0x%x out=0x%x\n"
argument_list|,
name|portno
argument_list|,
name|i
argument_list|,
name|ucom
operator|->
name|sc_bulkin_no
argument_list|,
name|ucom
operator|->
name|sc_bulkout_no
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
name|ucom_attach_tty
argument_list|(
name|ucom
argument_list|,
name|MINOR_CALLOUT
argument_list|,
name|devnamefmt
argument_list|,
name|portno
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|800000
name|ucom_attach_tty
argument_list|(
name|ucom
argument_list|,
name|TS_CALLOUT
argument_list|,
name|devnamefmt
argument_list|,
name|portno
argument_list|)
expr_stmt|;
else|#
directive|else
name|ucom_attach_tty
argument_list|(
name|ucom
argument_list|,
name|devnamefmt
argument_list|,
name|portno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|claim_iface
operator|=
literal|1
expr_stmt|;
name|portno
operator|++
expr_stmt|;
name|bulkin_no
operator|=
name|bulkout_no
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|claim_iface
condition|)
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|// claim the interface
block|}
name|sc
operator|->
name|sc_numports
operator|=
name|portno
expr_stmt|;
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"configured %d serial ports (%s)\n"
argument_list|,
name|sc
operator|->
name|sc_numports
argument_list|,
name|devnamefmt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|u3g_detach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|u3g_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_numports
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_ucom
index|[
name|i
index|]
operator|.
name|sc_dying
operator|=
literal|1
expr_stmt|;
name|rv
operator|=
name|ucom_detach
argument_list|(
operator|&
name|sc
operator|->
name|sc_ucom
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"ucom_detach(U%d.%d\n"
argument_list|,
name|device_get_unit
argument_list|(
name|self
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|u3g_open
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|portno
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
comment|/* Supply generous buffering for these cards to avoid disappointments 	 * when setting the speed incorrectly. Only do this for the first port 	 * assuming that the rest of the ports are used for diagnostics only 	 * anyway. 	 * Note: We abuse the fact that ucom sets the speed through 	 * ispeed/ospeed, not through ispeedwat/ospeedwat. 	 * XXX Are the speeds correct? 	 */
if|if
condition|(
name|portno
operator|==
literal|0
condition|)
block|{
name|struct
name|u3g_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|struct
name|ucom_softc
modifier|*
name|ucom
init|=
operator|&
name|sc
operator|->
name|sc_ucom
index|[
name|portno
index|]
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|ucom
operator|->
name|sc_tty
decl_stmt|;
name|tp
operator|->
name|t_ispeedwat
operator|=
name|u3g_speeds
index|[
name|sc
operator|->
name|sc_speed
index|]
operator|.
name|ispeed
expr_stmt|;
name|tp
operator|->
name|t_ospeedwat
operator|=
name|u3g_speeds
index|[
name|sc
operator|->
name|sc_speed
index|]
operator|.
name|ospeed
expr_stmt|;
comment|/* Avoid excessive buffer sizes. 		 * XXX The values here should be checked. Lower them and see 		 * whether 'lost chars' messages appear. 		 */
if|if
condition|(
name|tp
operator|->
name|t_ispeedwat
operator|>
literal|384000
condition|)
name|tp
operator|->
name|t_ispeedwat
operator|=
literal|384000
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ospeedwat
operator|>
literal|384000
condition|)
name|tp
operator|->
name|t_ospeedwat
operator|=
literal|384000
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|u3g_close
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|portno
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
if|if
condition|(
name|portno
operator|==
literal|0
condition|)
block|{
comment|/* see u3g_open() */
comment|/* Reduce the buffers allocated above again */
name|struct
name|u3g_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|struct
name|ucom_softc
modifier|*
name|ucom
init|=
operator|&
name|sc
operator|->
name|sc_ucom
index|[
name|portno
index|]
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|ucom
operator|->
name|sc_tty
decl_stmt|;
ifdef|#
directive|ifdef
name|U3G_DEBUG
name|device_t
name|self
init|=
name|sc
operator|->
name|sc_dev
decl_stmt|;
endif|#
directive|endif
name|tp
operator|->
name|t_ispeedwat
operator|=
operator|(
name|speed_t
operator|)
operator|-
literal|1
expr_stmt|;
name|tp
operator|->
name|t_ospeedwat
operator|=
operator|(
name|speed_t
operator|)
operator|-
literal|1
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|u3g_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|u3g_match
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|u3g_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|u3g_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|u3g_driver
init|=
block|{
literal|"ucom"
block|,
name|u3g_methods
block|,
expr|sizeof
operator|(
expr|struct
name|u3g_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|u3g
argument_list|,
name|uhub
argument_list|,
name|u3g_driver
argument_list|,
name|ucom_devclass
argument_list|,
name|usbd_driver_load
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|u3g
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|u3g
argument_list|,
name|ucom
argument_list|,
name|UCOM_MINVER
argument_list|,
name|UCOM_PREFVER
argument_list|,
name|UCOM_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|u3g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*******************************************************************  ****** Stub driver to hide devices that need to reinitialise ******  *******************************************************************/
end_comment

begin_struct
struct|struct
name|u3gstub_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|usbd_device_handle
name|sc_udev
decl_stmt|;
name|usbd_pipe_handle
name|sc_pipe
decl_stmt|;
name|usbd_xfer_handle
name|sc_xfer
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|u3gstub_huawei_init
parameter_list|(
name|struct
name|u3gstub_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_attach_arg
modifier|*
name|uaa
parameter_list|)
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_SET_FEATURE
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|UF_DEVICE_REMOTE_WAKEUP
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|UHF_PORT_SUSPEND
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|usbd_do_request
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ignore any error */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|u3gstub_scsi_eject
parameter_list|(
name|struct
name|u3gstub_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_attach_arg
modifier|*
name|uaa
parameter_list|)
block|{
comment|/* See definition of umass_bbb_cbw_t in sys/dev/usb/umass.c and struct 	 * scsi_start_stop_unit in sys/cam/scsi/scsi_all.h .          */
name|unsigned
name|char
name|cmd
index|[
literal|31
index|]
init|=
block|{
literal|0x55
block|,
literal|0x53
block|,
literal|0x42
block|,
literal|0x43
block|,
comment|/* 0..3: Command Block Wrapper (CBW) signature */
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 4..7: CBW Tag, unique 32-bit number */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 8..11: CBW Transfer Length, no data here */
literal|0x00
block|,
comment|/* 12: CBW Flag: output, so 0 */
literal|0x00
block|,
comment|/* 13: CBW Lun */
literal|0x06
block|,
comment|/* 14: CBW Length */
literal|0x1b
block|,
comment|/* 15+0: opcode: SCSI START/STOP */
literal|0x00
block|,
comment|/* 15+1: byte2: Not immediate */
literal|0x00
block|,
literal|0x00
block|,
comment|/* 15+2..3: reserved */
literal|0x02
block|,
comment|/* 15+4: Load/Eject command */
literal|0x00
block|,
comment|/* 15+5: control */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 15+6..15: unused */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find the bulk-out endpoints */
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|id
operator|->
name|bNumEndpoints
condition|;
name|i
operator|++
control|)
block|{
name|ed
operator|=
name|usbd_interface2endpoint_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|!=
name|NULL
operator|&&
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_OUT
operator|&&
operator|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|==
name|UE_BULK
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|id
operator|->
name|bNumEndpoints
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"failed to find bulk-out pipe\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|usbd_open_pipe
argument_list|(
name|uaa
operator|->
name|iface
argument_list|,
name|ed
operator|->
name|bEndpointAddress
argument_list|,
name|USBD_EXCLUSIVE_USE
argument_list|,
operator|&
name|sc
operator|->
name|sc_pipe
argument_list|)
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"failed to open bulk-out pipe on endpoint %d\n"
argument_list|,
name|ed
operator|->
name|bEndpointAddress
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|sc_xfer
operator|=
name|usbd_alloc_xfer
argument_list|(
name|uaa
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_xfer
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"failed to allocate xfer\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|usbd_setup_xfer
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|sc
operator|->
name|sc_pipe
argument_list|,
name|NULL
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
name|USBD_DEFAULT_TIMEOUT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|int
name|err
init|=
name|usbd_transfer
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|)
operator|!=
name|USBD_NORMAL_COMPLETION
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_NORMAL_COMPLETION
operator|&&
name|err
operator|!=
name|USBD_IN_PROGRESS
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"failed to start transfer\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|u3gstub_sierra_init
parameter_list|(
name|struct
name|u3gstub_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_attach_arg
modifier|*
name|uaa
parameter_list|)
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_VENDOR
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_SET_INTERFACE
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|UF_DEVICE_REMOTE_WAKEUP
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|UHF_PORT_CONNECTION
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|usbd_do_request
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ignore any error */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|u3gstub_match
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|self
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|u3g_dev_type_s
modifier|*
name|u3g_dev_type
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
comment|/* This stub handles 3G modem devices (E220, Mobile, etc.) with 	 * auto-install flash disks for Windows/MacOSX on the first interface. 	 * After some command or some delay they change appearance to a modem. 	 */
if|if
condition|(
operator|!
name|uaa
operator|->
name|iface
condition|)
return|return
name|UMATCH_NONE
return|;
name|u3g_dev_type
operator|=
name|u3g_lookup
argument_list|(
name|uaa
operator|->
name|vendor
argument_list|,
name|uaa
operator|->
name|product
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u3g_dev_type
condition|)
return|return
name|UMATCH_NONE
return|;
if|if
condition|(
name|u3g_dev_type
operator|->
name|flags
operator|&
name|U3GFL_HUAWEI_INIT
operator|||
name|u3g_dev_type
operator|->
name|flags
operator|&
name|U3GFL_SCSI_EJECT
operator|||
name|u3g_dev_type
operator|->
name|flags
operator|&
name|U3GFL_SIERRA_INIT
operator|||
name|u3g_dev_type
operator|->
name|flags
operator|&
name|U3GFL_STUB_WAIT
condition|)
block|{
comment|/* We assume that if the first interface is still a mass 		 * storage device the device has not yet changed appearance. 		 */
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|&&
name|id
operator|->
name|bInterfaceNumber
operator|==
literal|0
operator|&&
name|id
operator|->
name|bInterfaceClass
operator|==
name|UICLASS_MASS
condition|)
return|return
name|UMATCH_VENDOR_PRODUCT
return|;
block|}
return|return
name|UMATCH_NONE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|u3gstub_attach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|u3gstub_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|self
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|u3g_dev_type_s
modifier|*
name|u3g_dev_type
decl_stmt|;
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|U3G_DEBUG
if|if
condition|(
operator|!
name|bootverbose
condition|)
comment|// hide the stub attachment
name|device_quiet
argument_list|(
name|self
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_dev
operator|=
name|self
expr_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uaa
operator|->
name|nifaces
condition|;
name|i
operator|++
control|)
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|// claim all interfaces
name|u3g_dev_type
operator|=
name|u3g_lookup
argument_list|(
name|uaa
operator|->
name|vendor
argument_list|,
name|uaa
operator|->
name|product
argument_list|)
expr_stmt|;
if|if
condition|(
name|u3g_dev_type
operator|->
name|flags
operator|&
name|U3GFL_HUAWEI_INIT
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"changing Huawei modem to modem mode\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u3gstub_huawei_init
argument_list|(
name|sc
argument_list|,
name|uaa
argument_list|)
condition|)
return|return
name|ENXIO
return|;
block|}
elseif|else
if|if
condition|(
name|u3g_dev_type
operator|->
name|flags
operator|&
name|U3GFL_SCSI_EJECT
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"sending CD eject command to change to modem mode\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u3gstub_scsi_eject
argument_list|(
name|sc
argument_list|,
name|uaa
argument_list|)
condition|)
return|return
name|ENXIO
return|;
block|}
elseif|else
if|if
condition|(
name|u3g_dev_type
operator|->
name|flags
operator|&
name|U3GFL_SIERRA_INIT
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"changing Sierra modem to modem mode\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u3gstub_sierra_init
argument_list|(
name|sc
argument_list|,
name|uaa
argument_list|)
condition|)
return|return
name|ENXIO
return|;
block|}
elseif|else
if|if
condition|(
name|u3g_dev_type
operator|->
name|flags
operator|&
name|U3GFL_STUB_WAIT
condition|)
block|{
comment|/* nop  */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|u3gstub_detach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|u3gstub_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_xfer
condition|)
name|usbd_free_xfer
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_pipe
condition|)
block|{
name|usbd_abort_pipe
argument_list|(
name|sc
operator|->
name|sc_pipe
argument_list|)
expr_stmt|;
name|usbd_close_pipe
argument_list|(
name|sc
operator|->
name|sc_pipe
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|u3gstub_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|u3gstub_match
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|u3gstub_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|u3gstub_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|u3gstub_driver
init|=
block|{
literal|"u3gstub"
block|,
name|u3gstub_methods
block|,
expr|sizeof
operator|(
expr|struct
name|u3gstub_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|u3gstub
argument_list|,
name|uhub
argument_list|,
name|u3gstub_driver
argument_list|,
name|ucom_devclass
argument_list|,
name|usbd_driver_load
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|u3gstub
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

