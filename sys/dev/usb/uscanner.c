begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: uscanner.c,v 1.6 2000/10/13 18:16:36 augustss Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2000 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (lennart@augustsson.net) at  * Carlstedt Research& Technology  * and Nick Hibma (n_hibma@qubesoft.com).  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdevs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USCANNER_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (uscannerdebug) logprintf x
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (uscannerdebug>(n)) logprintf x
end_define

begin_decl_stmt
name|int
name|uscannerdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Table of scanners that may work with this driver. */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|scanner_id
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|product
decl_stmt|;
block|}
name|scanner_ids
index|[]
init|=
block|{
comment|/* Acer Peripherals */
block|{
name|USB_VENDOR_ACERP
block|,
name|USB_PRODUCT_ACERP_ACERSCAN_320U
block|}
block|,
block|{
name|USB_VENDOR_ACERP
block|,
name|USB_PRODUCT_ACERP_ACERSCAN_640U
block|}
block|,
block|{
name|USB_VENDOR_ACERP
block|,
name|USB_PRODUCT_ACERP_ACERSCAN_620U
block|}
block|,
block|{
name|USB_VENDOR_ACERP
block|,
name|USB_PRODUCT_ACERP_ACERSCAN_C310U
block|}
block|,
comment|/* AGFA */
block|{
name|USB_VENDOR_AGFA
block|,
name|USB_PRODUCT_AGFA_SNAPSCAN1212U
block|}
block|,
block|{
name|USB_VENDOR_AGFA
block|,
name|USB_PRODUCT_AGFA_SNAPSCAN1212U2
block|}
block|,
block|{
name|USB_VENDOR_AGFA
block|,
name|USB_PRODUCT_AGFA_SNAPSCANTOUCH
block|}
block|,
comment|/* Kye */
block|{
name|USB_VENDOR_KYE
block|,
name|USB_PRODUCT_KYE_VIVIDPRO
block|}
block|,
comment|/* HP */
block|{
name|USB_VENDOR_HP
block|,
name|USB_PRODUCT_HP_3300C
block|}
block|,
block|{
name|USB_VENDOR_HP
block|,
name|USB_PRODUCT_HP_4100C
block|}
block|,
block|{
name|USB_VENDOR_HP
block|,
name|USB_PRODUCT_HP_4200C
block|}
block|,
block|{
name|USB_VENDOR_HP
block|,
name|USB_PRODUCT_HP_S20
block|}
block|,
block|{
name|USB_VENDOR_HP
block|,
name|USB_PRODUCT_HP_5200C
block|}
block|,
block|{
name|USB_VENDOR_HP
block|,
name|USB_PRODUCT_HP_5300C
block|}
block|,
block|{
name|USB_VENDOR_HP
block|,
name|USB_PRODUCT_HP_6200C
block|}
block|,
block|{
name|USB_VENDOR_HP
block|,
name|USB_PRODUCT_HP_6300C
block|}
block|,
comment|/* Avision */
block|{
name|USB_VENDOR_AVISION
block|,
name|USB_PRODUCT_AVISION_1200U
block|}
block|,
comment|/* Microtek */
block|{
name|USB_VENDOR_MICROTEK
block|,
name|USB_PRODUCT_MICROTEK_X6U
block|}
block|,
block|{
name|USB_VENDOR_MICROTEK
block|,
name|USB_PRODUCT_MICROTEK_336CX
block|}
block|,
block|{
name|USB_VENDOR_MICROTEK
block|,
name|USB_PRODUCT_MICROTEK_336CX2
block|}
block|,
block|{
name|USB_VENDOR_MICROTEK
block|,
name|USB_PRODUCT_MICROTEK_C6
block|}
block|,
block|{
name|USB_VENDOR_MICROTEK
block|,
name|USB_PRODUCT_MICROTEK_V6USL
block|}
block|,
block|{
name|USB_VENDOR_MICROTEK
block|,
name|USB_PRODUCT_MICROTEK_V6USL2
block|}
block|,
block|{
name|USB_VENDOR_MICROTEK
block|,
name|USB_PRODUCT_MICROTEK_V6UL
block|}
block|,
comment|/* Mustek */
block|{
name|USB_VENDOR_MUSTEK
block|,
name|USB_PRODUCT_MUSTEK_1200CU
block|}
block|,
block|{
name|USB_VENDOR_NATIONAL
block|,
name|USB_PRODUCT_NATIONAL_BEARPAW
block|}
block|,
block|{
name|USB_VENDOR_NATIONAL
block|,
name|USB_PRODUCT_MUSTEK_600CU
block|}
block|,
block|{
name|USB_VENDOR_NATIONAL
block|,
name|USB_PRODUCT_MUSTEK_1200USB
block|}
block|,
block|{
name|USB_VENDOR_NATIONAL
block|,
name|USB_PRODUCT_MUSTEK_1200UB
block|}
block|,
comment|/* Primax */
block|{
name|USB_VENDOR_PRIMAX
block|,
name|USB_PRODUCT_PRIMAX_G2X300
block|}
block|,
block|{
name|USB_VENDOR_PRIMAX
block|,
name|USB_PRODUCT_PRIMAX_G2E300
block|}
block|,
block|{
name|USB_VENDOR_PRIMAX
block|,
name|USB_PRODUCT_PRIMAX_G2300
block|}
block|,
block|{
name|USB_VENDOR_PRIMAX
block|,
name|USB_PRODUCT_PRIMAX_G2E3002
block|}
block|,
block|{
name|USB_VENDOR_PRIMAX
block|,
name|USB_PRODUCT_PRIMAX_9600
block|}
block|,
block|{
name|USB_VENDOR_PRIMAX
block|,
name|USB_PRODUCT_PRIMAX_600U
block|}
block|,
block|{
name|USB_VENDOR_PRIMAX
block|,
name|USB_PRODUCT_PRIMAX_19200
block|}
block|,
block|{
name|USB_VENDOR_PRIMAX
block|,
name|USB_PRODUCT_PRIMAX_1200U
block|}
block|,
block|{
name|USB_VENDOR_PRIMAX
block|,
name|USB_PRODUCT_PRIMAX_G600
block|}
block|,
block|{
name|USB_VENDOR_PRIMAX
block|,
name|USB_PRODUCT_PRIMAX_636I
block|}
block|,
block|{
name|USB_VENDOR_PRIMAX
block|,
name|USB_PRODUCT_PRIMAX_G2600
block|}
block|,
block|{
name|USB_VENDOR_PRIMAX
block|,
name|USB_PRODUCT_PRIMAX_G2E600
block|}
block|,
comment|/* Epson */
block|{
name|USB_VENDOR_EPSON
block|,
name|USB_PRODUCT_EPSON_636
block|}
block|,
block|{
name|USB_VENDOR_EPSON
block|,
name|USB_PRODUCT_EPSON_610
block|}
block|,
block|{
name|USB_VENDOR_EPSON
block|,
name|USB_PRODUCT_EPSON_1200
block|}
block|,
block|{
name|USB_VENDOR_EPSON
block|,
name|USB_PRODUCT_EPSON_1600
block|}
block|,
comment|/* UMAX */
block|{
name|USB_VENDOR_UMAX
block|,
name|USB_PRODUCT_UMAX_ASTRA1220U
block|}
block|,
block|{
name|USB_VENDOR_UMAX
block|,
name|USB_PRODUCT_UMAX_ASTRA1236U
block|}
block|,
block|{
name|USB_VENDOR_UMAX
block|,
name|USB_PRODUCT_UMAX_ASTRA2000U
block|}
block|,
block|{
name|USB_VENDOR_UMAX
block|,
name|USB_PRODUCT_UMAX_ASTRA2200U
block|}
block|,
comment|/* Visioneer */
block|{
name|USB_VENDOR_VISIONEER
block|,
name|USB_PRODUCT_VISIONEER_5300
block|}
block|,
block|{
name|USB_VENDOR_VISIONEER
block|,
name|USB_PRODUCT_VISIONEER_7600
block|}
block|,
block|{
name|USB_VENDOR_VISIONEER
block|,
name|USB_PRODUCT_VISIONEER_6100
block|}
block|,
block|{
name|USB_VENDOR_VISIONEER
block|,
name|USB_PRODUCT_VISIONEER_6200
block|}
block|,
block|{
name|USB_VENDOR_VISIONEER
block|,
name|USB_PRODUCT_VISIONEER_8100
block|}
block|,
block|{
name|USB_VENDOR_VISIONEER
block|,
name|USB_PRODUCT_VISIONEER_8600
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|USCANNER_BUFFERSIZE
value|1024
end_define

begin_struct
struct|struct
name|uscanner_softc
block|{
name|USBBASEDEVICE
name|sc_dev
decl_stmt|;
comment|/* base device */
name|usbd_device_handle
name|sc_udev
decl_stmt|;
name|usbd_interface_handle
name|sc_iface
decl_stmt|;
name|usbd_pipe_handle
name|sc_bulkin_pipe
decl_stmt|;
name|int
name|sc_bulkin
decl_stmt|;
name|usbd_xfer_handle
name|sc_bulkin_xfer
decl_stmt|;
name|void
modifier|*
name|sc_bulkin_buffer
decl_stmt|;
name|int
name|sc_bulkin_bufferlen
decl_stmt|;
name|int
name|sc_bulkin_datalen
decl_stmt|;
name|usbd_pipe_handle
name|sc_bulkout_pipe
decl_stmt|;
name|int
name|sc_bulkout
decl_stmt|;
name|usbd_xfer_handle
name|sc_bulkout_xfer
decl_stmt|;
name|void
modifier|*
name|sc_bulkout_buffer
decl_stmt|;
name|int
name|sc_bulkout_bufferlen
decl_stmt|;
name|int
name|sc_bulkout_datalen
decl_stmt|;
name|u_char
name|sc_state
decl_stmt|;
define|#
directive|define
name|USCANNER_OPEN
value|0x01
comment|/* opened */
name|int
name|sc_refcnt
decl_stmt|;
name|u_char
name|sc_dying
decl_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_expr_stmt
name|cdev_decl
argument_list|(
name|uscanner
argument_list|)
expr_stmt|;
end_expr_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_decl_stmt
name|d_open_t
name|uscanneropen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_close_t
name|uscannerclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_read_t
name|uscannerread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_write_t
name|uscannerwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_poll_t
name|uscannerpoll
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USCANNER_CDEV_MAJOR
value|156
end_define

begin_decl_stmt
name|Static
name|struct
name|cdevsw
name|uscanner_cdevsw
init|=
block|{
comment|/* open */
name|uscanneropen
block|,
comment|/* close */
name|uscannerclose
block|,
comment|/* read */
name|uscannerread
block|,
comment|/* write */
name|uscannerwrite
block|,
comment|/* ioctl */
name|noioctl
block|,
comment|/* poll */
name|uscannerpoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"uscanner"
block|,
comment|/* maj */
name|USCANNER_CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|,
comment|/* bmaj */
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|Static
name|int
name|uscanner_do_read
parameter_list|(
name|struct
name|uscanner_softc
modifier|*
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uscanner_do_write
parameter_list|(
name|struct
name|uscanner_softc
modifier|*
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uscanner_do_close
parameter_list|(
name|struct
name|uscanner_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|USCANNERUNIT
parameter_list|(
name|n
parameter_list|)
value|(minor(n))
end_define

begin_expr_stmt
name|USB_DECLARE_DRIVER
argument_list|(
name|uscanner
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|USB_MATCH
argument_list|(
argument|uscanner
argument_list|)
end_macro

begin_block
block|{
name|USB_MATCH_START
argument_list|(
name|uscanner
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|iface
operator|!=
name|NULL
condition|)
return|return
name|UMATCH_NONE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scanner_ids
index|[
name|i
index|]
operator|.
name|vendor
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|scanner_ids
index|[
name|i
index|]
operator|.
name|vendor
operator|==
name|uaa
operator|->
name|vendor
operator|&&
name|scanner_ids
index|[
name|i
index|]
operator|.
name|product
operator|==
name|uaa
operator|->
name|product
condition|)
block|{
return|return
operator|(
name|UMATCH_VENDOR_PRODUCT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
block|}
end_block

begin_macro
name|USB_ATTACH
argument_list|(
argument|uscanner
argument_list|)
end_macro

begin_block
block|{
name|USB_ATTACH_START
argument_list|(
name|uscanner
argument_list|,
name|sc
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
init|=
literal|0
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
decl_stmt|,
modifier|*
name|ed_bulkin
init|=
name|NULL
decl_stmt|,
modifier|*
name|ed_bulkout
init|=
name|NULL
decl_stmt|;
name|char
name|devinfo
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|usbd_devinfo
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
literal|0
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|USB_ATTACH_SETUP
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
name|err
operator|=
name|usbd_set_config_no
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"%s: setting config no failed\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
comment|/* XXX We only check the first interface */
name|err
operator|=
name|usbd_device2interface_handle
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_iface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|sc
operator|->
name|sc_iface
condition|)
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|sc
operator|->
name|sc_iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|id
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not get interface descriptor, err=%d,id=%p\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|err
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
comment|/* Find the two first bulk endpoints */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|id
operator|->
name|bNumEndpoints
condition|;
name|i
operator|++
control|)
block|{
name|ed
operator|=
name|usbd_interface2endpoint_descriptor
argument_list|(
name|sc
operator|->
name|sc_iface
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not read endpoint descriptor\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_IN
operator|&&
operator|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|==
name|UE_BULK
condition|)
block|{
name|ed_bulkin
operator|=
name|ed
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_OUT
operator|&&
operator|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|==
name|UE_BULK
condition|)
block|{
name|ed_bulkout
operator|=
name|ed
expr_stmt|;
block|}
if|if
condition|(
name|ed_bulkin
operator|&&
name|ed_bulkout
condition|)
comment|/* found all we need */
break|break;
block|}
comment|/* Verify that we goething sensible */
if|if
condition|(
name|ed_bulkin
operator|==
name|NULL
operator|||
name|ed_bulkout
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bulk-in and/or bulk-out endpoint not found\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
name|sc
operator|->
name|sc_bulkin
operator|=
name|ed_bulkin
operator|->
name|bEndpointAddress
expr_stmt|;
name|sc
operator|->
name|sc_bulkout
operator|=
name|ed_bulkout
operator|->
name|bEndpointAddress
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* the main device, ctrl endpoint */
name|make_dev
argument_list|(
operator|&
name|uscanner_cdevsw
argument_list|,
name|USBDEVUNIT
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0644
argument_list|,
literal|"%s"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|USB_ATTACH_SUCCESS_RETURN
expr_stmt|;
block|}
end_block

begin_function
name|int
name|uscanneropen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|uscanner_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
init|=
name|USCANNERUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|USB_GET_SC_OPEN
argument_list|(
name|uscanner
argument_list|,
name|unit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uscanneropen: flag=%d, mode=%d, unit=%d\n"
operator|,
name|flag
operator|,
name|mode
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|&
name|USCANNER_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|->
name|sc_bulkin_buffer
operator|=
name|malloc
argument_list|(
name|USCANNER_BUFFERSIZE
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bulkout_buffer
operator|=
name|malloc
argument_list|(
name|USCANNER_BUFFERSIZE
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* No need to check buffers for NULL since we have WAITOK */
name|sc
operator|->
name|sc_bulkin_bufferlen
operator|=
name|USCANNER_BUFFERSIZE
expr_stmt|;
name|sc
operator|->
name|sc_bulkout_bufferlen
operator|=
name|USCANNER_BUFFERSIZE
expr_stmt|;
comment|/* We have decided on which endpoints to use, now open the pipes */
name|err
operator|=
name|usbd_open_pipe
argument_list|(
name|sc
operator|->
name|sc_iface
argument_list|,
name|sc
operator|->
name|sc_bulkin
argument_list|,
name|USBD_EXCLUSIVE_USE
argument_list|,
operator|&
name|sc
operator|->
name|sc_bulkin_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot open bulk-in pipe (addr %d)\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_bulkin
argument_list|)
expr_stmt|;
name|uscanner_do_close
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|err
operator|=
name|usbd_open_pipe
argument_list|(
name|sc
operator|->
name|sc_iface
argument_list|,
name|sc
operator|->
name|sc_bulkout
argument_list|,
name|USBD_EXCLUSIVE_USE
argument_list|,
operator|&
name|sc
operator|->
name|sc_bulkout_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot open bulk-out pipe (addr %d)\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_bulkout
argument_list|)
expr_stmt|;
name|uscanner_do_close
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_bulkin_xfer
operator|=
name|usbd_alloc_xfer
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bulkin_xfer
operator|==
name|NULL
condition|)
block|{
name|uscanner_do_close
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sc
operator|->
name|sc_bulkout_xfer
operator|=
name|usbd_alloc_xfer
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bulkout_xfer
operator|==
name|NULL
condition|)
block|{
name|uscanner_do_close
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
name|int
name|uscannerclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|uscanner_softc
modifier|*
name|sc
decl_stmt|;
name|USB_GET_SC
argument_list|(
name|uscanner
argument_list|,
name|USCANNERUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uscannerclose: flag=%d, mode=%d, unit=%d\n"
operator|,
name|flag
operator|,
name|mode
operator|,
name|USCANNERUNIT
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_state
operator|&
name|USCANNER_OPEN
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"uscannerclose: not open\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
endif|#
directive|endif
name|uscanner_do_close
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|uscanner_do_close
parameter_list|(
name|struct
name|uscanner_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_bulkin_xfer
condition|)
block|{
name|usbd_free_xfer
argument_list|(
name|sc
operator|->
name|sc_bulkin_xfer
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bulkin_xfer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bulkout_xfer
condition|)
block|{
name|usbd_free_xfer
argument_list|(
name|sc
operator|->
name|sc_bulkout_xfer
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bulkout_xfer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bulkin_pipe
condition|)
block|{
name|usbd_abort_pipe
argument_list|(
name|sc
operator|->
name|sc_bulkin_pipe
argument_list|)
expr_stmt|;
name|usbd_close_pipe
argument_list|(
name|sc
operator|->
name|sc_bulkin_pipe
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bulkin_pipe
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bulkout_pipe
condition|)
block|{
name|usbd_abort_pipe
argument_list|(
name|sc
operator|->
name|sc_bulkout_pipe
argument_list|)
expr_stmt|;
name|usbd_close_pipe
argument_list|(
name|sc
operator|->
name|sc_bulkout_pipe
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bulkout_pipe
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bulkin_buffer
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|sc_bulkin_buffer
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bulkin_buffer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bulkout_buffer
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|sc_bulkout_buffer
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bulkout_buffer
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|USCANNER_OPEN
expr_stmt|;
block|}
end_function

begin_function
name|Static
name|int
name|uscanner_do_read
parameter_list|(
name|sc
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|struct
name|uscanner_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|u_int32_t
name|n
decl_stmt|,
name|tn
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s: uscannerread\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
while|while
condition|(
operator|(
name|n
operator|=
name|min
argument_list|(
name|sc
operator|->
name|sc_bulkin_bufferlen
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uscannerread: start transfer %d bytes\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|tn
operator|=
name|n
expr_stmt|;
name|err
operator|=
name|usbd_bulk_transfer
argument_list|(
name|sc
operator|->
name|sc_bulkin_xfer
argument_list|,
name|sc
operator|->
name|sc_bulkin_pipe
argument_list|,
name|USBD_SHORT_XFER_OK
argument_list|,
name|USBD_NO_TIMEOUT
argument_list|,
name|sc
operator|->
name|sc_bulkin_buffer
argument_list|,
operator|&
name|tn
argument_list|,
literal|"uscannerrb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|USBD_INTERRUPTED
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|USBD_TIMEOUT
condition|)
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
else|else
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uscannerread: got %d bytes\n"
operator|,
name|tn
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|sc
operator|->
name|sc_bulkin_buffer
argument_list|,
name|tn
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|tn
operator|<
name|n
condition|)
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uscannerread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|uscanner_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|USB_GET_SC
argument_list|(
name|uscanner
argument_list|,
name|USCANNERUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_refcnt
operator|++
expr_stmt|;
name|error
operator|=
name|uscanner_do_read
argument_list|(
name|sc
argument_list|,
name|uio
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|<
literal|0
condition|)
name|usb_detach_wakeup
argument_list|(
name|USBDEV
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|Static
name|int
name|uscanner_do_write
parameter_list|(
name|sc
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|struct
name|uscanner_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|u_int32_t
name|n
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s: uscanner_do_write\n"
operator|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
while|while
condition|(
operator|(
name|n
operator|=
name|min
argument_list|(
name|sc
operator|->
name|sc_bulkout_bufferlen
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|sc
operator|->
name|sc_bulkout_buffer
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uscanner_do_write: transfer %d bytes\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_bulk_transfer
argument_list|(
name|sc
operator|->
name|sc_bulkout_xfer
argument_list|,
name|sc
operator|->
name|sc_bulkout_pipe
argument_list|,
literal|0
argument_list|,
name|USBD_NO_TIMEOUT
argument_list|,
name|sc
operator|->
name|sc_bulkout_buffer
argument_list|,
operator|&
name|n
argument_list|,
literal|"uscannerwb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|USBD_INTERRUPTED
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
else|else
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uscannerwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|uscanner_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|USB_GET_SC
argument_list|(
name|uscanner
argument_list|,
name|USCANNERUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_refcnt
operator|++
expr_stmt|;
name|error
operator|=
name|uscanner_do_write
argument_list|(
name|sc
argument_list|,
name|uio
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|<
literal|0
condition|)
name|usb_detach_wakeup
argument_list|(
name|USBDEV
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|int
name|uscanner_activate
parameter_list|(
name|self
parameter_list|,
name|act
parameter_list|)
name|device_ptr_t
name|self
decl_stmt|;
name|enum
name|devact
name|act
decl_stmt|;
block|{
name|struct
name|uscanner_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|uscanner_softc
operator|*
operator|)
name|self
decl_stmt|;
switch|switch
condition|(
name|act
condition|)
block|{
case|case
name|DVACT_ACTIVATE
case|:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
case|case
name|DVACT_DEACTIVATE
case|:
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|USB_DETACH
argument_list|(
argument|uscanner
argument_list|)
end_macro

begin_block
block|{
name|USB_DETACH_START
argument_list|(
name|uscanner
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|int
name|maj
decl_stmt|,
name|mn
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|DPRINTF
argument_list|(
operator|(
literal|"uscanner_detach: sc=%p flags=%d\n"
operator|,
name|sc
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|DPRINTF
argument_list|(
operator|(
literal|"uscanner_detach: sc=%p\n"
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
comment|/* Abort all pipes.  Causes processes waiting for transfer to wake. */
if|if
condition|(
name|sc
operator|->
name|sc_bulkin_pipe
condition|)
name|usbd_abort_pipe
argument_list|(
name|sc
operator|->
name|sc_bulkin_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bulkout_pipe
condition|)
name|usbd_abort_pipe
argument_list|(
name|sc
operator|->
name|sc_bulkout_pipe
argument_list|)
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|>=
literal|0
condition|)
block|{
comment|/* Wait for processes to go away. */
name|usb_detach_wait
argument_list|(
name|USBDEV
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
comment|/* locate the major number */
for|for
control|(
name|maj
operator|=
literal|0
init|;
name|maj
operator|<
name|nchrdev
condition|;
name|maj
operator|++
control|)
if|if
condition|(
name|cdevsw
index|[
name|maj
index|]
operator|.
name|d_open
operator|==
name|uscanneropen
condition|)
break|break;
comment|/* Nuke the vnodes for any open instances (calls close). */
name|mn
operator|=
name|self
operator|->
name|dv_unit
operator|*
name|USB_MAX_ENDPOINTS
expr_stmt|;
name|vdevgone
argument_list|(
name|maj
argument_list|,
name|mn
argument_list|,
name|mn
operator|+
name|USB_MAX_ENDPOINTS
operator|-
literal|1
argument_list|,
name|VCHR
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* destroy the device for the control endpoint */
name|dev
operator|=
name|makedev
argument_list|(
name|USCANNER_CDEV_MAJOR
argument_list|,
name|USBDEVUNIT
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|si_hlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
condition|)
name|VOP_REVOKE
argument_list|(
name|vp
argument_list|,
name|REVOKEALL
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|int
name|uscannerpoll
parameter_list|(
name|dev
parameter_list|,
name|events
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|events
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|uscanner_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|USB_GET_SC
argument_list|(
name|uscanner
argument_list|,
name|USCANNERUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*  	 * We have no easy way of determining if a read will 	 * yield any data or a write will happen. 	 * Pretend they will. 	 */
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator||
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|uscanner
argument_list|,
name|uhub
argument_list|,
name|uscanner_driver
argument_list|,
name|uscanner_devclass
argument_list|,
name|usbd_driver_load
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

