begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: if_udav.c,v 1.2 2003/09/04 15:17:38 tsutsui Exp $	*/
end_comment

begin_comment
comment|/*	$nabe: if_udav.c,v 1.3 2003/08/21 16:57:19 nabe Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2003  *     Shingo WATANABE<nabe@nabechan.org>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*  * DM9601(DAVICOM USB to Ethernet MAC Controller with Integrated 10/100 PHY)  * The spec can be found at the following url.  *   http://www.davicom.com.tw/big5/download/Data%20Sheet/DM9601-DS-P01-930914.pdf  */
end_comment

begin_comment
comment|/*  * TODO:  *	Interrupt Endpoint support  *	External PHYs  *	powerhook() support?  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_ns.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|NBPFILTER
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"rnd.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/lockmgr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NRND
argument_list|)
operator|&&
name|NRND
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/rnd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|BPF_MTAP
end_ifndef

begin_define
define|#
directive|define
name|BPF_MTAP
parameter_list|(
name|_ifp
parameter_list|,
name|_m
parameter_list|)
value|do {			\ 	if ((_ifp)->if_bpf)) {				\ 		bpf_mtap((_ifp)->if_bpf, (_m)) ;	\ 	}						\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<net/if_ether.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_inarp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_comment
comment|/* defined(__NetBSD__) */
end_comment

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__FreeBSD__) */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (__NetBSD__) */
end_comment

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_ethersubr.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/if_udavreg.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|udav
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|udav
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|udav
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* "device miibus" required.  See GENERIC if you get errors here. */
end_comment

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_comment
comment|/* Function declarations */
end_comment

begin_expr_stmt
name|USB_DECLARE_DRIVER
argument_list|(
name|udav
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|udav_match
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udav_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udav_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udav_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|udav_openpipes
parameter_list|(
name|struct
name|udav_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udav_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udav_send
parameter_list|(
name|struct
name|udav_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udav_txeof
parameter_list|(
name|usbd_xfer_handle
parameter_list|,
name|usbd_private_handle
parameter_list|,
name|usbd_status
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|udav_rxstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|udav_rxeof
parameter_list|(
name|usbd_xfer_handle
parameter_list|,
name|usbd_private_handle
parameter_list|,
name|usbd_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udav_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udav_tick_task
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udav_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udav_stop_task
parameter_list|(
name|struct
name|udav_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udav_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udav_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udav_ifmedia_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udav_ifmedia_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udav_lock_mii
parameter_list|(
name|struct
name|udav_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udav_unlock_mii
parameter_list|(
name|struct
name|udav_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udav_miibus_readreg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udav_miibus_writereg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udav_miibus_statchg
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|udav_init
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_function_decl
specifier|static
name|void
name|udav_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|udav_setmulti
parameter_list|(
name|struct
name|udav_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udav_reset
parameter_list|(
name|struct
name|udav_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udav_csr_read
parameter_list|(
name|struct
name|udav_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udav_csr_write
parameter_list|(
name|struct
name|udav_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udav_csr_read1
parameter_list|(
name|struct
name|udav_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udav_csr_write1
parameter_list|(
name|struct
name|udav_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int udav_mem_read(struct udav_softc *, int, void *, int); static int udav_mem_write(struct udav_softc *, int, void *, int); static int udav_mem_write1(struct udav_softc *, int, unsigned char);
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|device_method_t
name|udav_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|udav_match
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|udav_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|udav_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|udav_shutdown
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|udav_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|udav_miibus_writereg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|udav_miibus_statchg
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|udav_driver
init|=
block|{
literal|"udav"
block|,
name|udav_methods
block|,
expr|sizeof
operator|(
expr|struct
name|udav_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|udav_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|udav
argument_list|,
name|uhub
argument_list|,
name|udav_driver
argument_list|,
name|udav_devclass
argument_list|,
name|usbd_driver_load
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|udav
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__FreeBSD__) */
end_comment

begin_comment
comment|/* Macros */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UDAV_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (udavdebug) logprintf x
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (udavdebug>= (n)) logprintf x
end_define

begin_decl_stmt
name|int
name|udavdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|delay
parameter_list|(
name|d
parameter_list|)
value|DELAY(d)
end_define

begin_define
define|#
directive|define
name|UDAV_SETBIT
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|x
parameter_list|)
define|\
value|udav_csr_write1(sc, reg, udav_csr_read1(sc, reg) | (x))
end_define

begin_define
define|#
directive|define
name|UDAV_CLRBIT
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|x
parameter_list|)
define|\
value|udav_csr_write1(sc, reg, udav_csr_read1(sc, reg)& ~(x))
end_define

begin_struct
specifier|static
specifier|const
struct|struct
name|udav_type
block|{
name|struct
name|usb_devno
name|udav_dev
decl_stmt|;
name|u_int16_t
name|udav_flags
decl_stmt|;
define|#
directive|define
name|UDAV_EXT_PHY
value|0x0001
block|}
name|udav_devs
index|[]
init|=
block|{
comment|/* Corega USB-TXC */
block|{
block|{
name|USB_VENDOR_COREGA
block|,
name|USB_PRODUCT_COREGA_FETHER_USB_TXC
block|}
block|,
literal|0
block|}
block|,
if|#
directive|if
literal|0
comment|/* DAVICOM DM9601 Generic? */
comment|/*  XXX: The following ids was obtained from the data sheet. */
block|{{ 0x0a46, 0x9601 }, 0},
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|udav_lookup
parameter_list|(
name|v
parameter_list|,
name|p
parameter_list|)
value|((const struct udav_type *)usb_lookup(udav_devs, v, p))
end_define

begin_comment
comment|/* Probe */
end_comment

begin_function
specifier|static
name|int
name|udav_match
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|self
argument_list|)
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|iface
operator|!=
name|NULL
condition|)
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
return|return
operator|(
name|udav_lookup
argument_list|(
name|uaa
operator|->
name|vendor
argument_list|,
name|uaa
operator|->
name|product
argument_list|)
operator|!=
name|NULL
condition|?
name|UMATCH_VENDOR_PRODUCT
else|:
name|UMATCH_NONE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Attach */
end_comment

begin_function
specifier|static
name|int
name|udav_attach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|USB_ATTACH_START
argument_list|(
name|udav
argument_list|,
name|sc
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|usbd_device_handle
name|dev
init|=
name|uaa
operator|->
name|device
decl_stmt|;
name|usbd_interface_handle
name|iface
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
decl_stmt|;
specifier|const
name|char
modifier|*
name|devname
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
endif|#
directive|endif
name|u_char
name|eaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|int
name|s
decl_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_dev
operator|=
name|self
expr_stmt|;
name|devname
operator|=
name|device_get_nameunit
argument_list|(
name|self
argument_list|)
expr_stmt|;
comment|/* Move the device into the configured state. */
name|err
operator|=
name|usbd_set_config_no
argument_list|(
name|dev
argument_list|,
name|UDAV_CONFIG_NO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"%s: setting config no failed\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|usb_init_task
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_task
argument_list|,
name|udav_tick_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|lockinit
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii_lock
argument_list|,
name|PZERO
argument_list|,
literal|"udavmii"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usb_init_task
argument_list|(
operator|&
name|sc
operator|->
name|sc_stop_task
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|udav_stop_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* get control interface */
name|err
operator|=
name|usbd_device2interface_handle
argument_list|(
name|dev
argument_list|,
name|UDAV_IFACE_INDEX
argument_list|,
operator|&
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"%s: failed to get interface, err=%s\n"
argument_list|,
name|devname
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_udev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_ctl_iface
operator|=
name|iface
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|udav_lookup
argument_list|(
name|uaa
operator|->
name|vendor
argument_list|,
name|uaa
operator|->
name|product
argument_list|)
operator|->
name|udav_flags
expr_stmt|;
comment|/* get interface descriptor */
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|sc
operator|->
name|sc_ctl_iface
argument_list|)
expr_stmt|;
comment|/* find endpoints */
name|sc
operator|->
name|sc_bulkin_no
operator|=
name|sc
operator|->
name|sc_bulkout_no
operator|=
name|sc
operator|->
name|sc_intrin_no
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|id
operator|->
name|bNumEndpoints
condition|;
name|i
operator|++
control|)
block|{
name|ed
operator|=
name|usbd_interface2endpoint_descriptor
argument_list|(
name|sc
operator|->
name|sc_ctl_iface
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: couldn't get endpoint %d\n"
argument_list|,
name|devname
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|==
name|UE_BULK
operator|&&
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
name|sc
operator|->
name|sc_bulkin_no
operator|=
name|ed
operator|->
name|bEndpointAddress
expr_stmt|;
comment|/* RX */
elseif|else
if|if
condition|(
operator|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|==
name|UE_BULK
operator|&&
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_OUT
condition|)
name|sc
operator|->
name|sc_bulkout_no
operator|=
name|ed
operator|->
name|bEndpointAddress
expr_stmt|;
comment|/* TX */
elseif|else
if|if
condition|(
operator|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|==
name|UE_INTERRUPT
operator|&&
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
name|sc
operator|->
name|sc_intrin_no
operator|=
name|ed
operator|->
name|bEndpointAddress
expr_stmt|;
comment|/* Status */
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bulkin_no
operator|==
operator|-
literal|1
operator|||
name|sc
operator|->
name|sc_bulkout_no
operator|==
operator|-
literal|1
operator|||
name|sc
operator|->
name|sc_intrin_no
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: missing endpoint\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|self
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* reset the adapter */
name|udav_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Get Ethernet Address */
name|err
operator|=
name|udav_csr_read
argument_list|(
name|sc
argument_list|,
name|UDAV_PAR
argument_list|,
operator|(
name|void
operator|*
operator|)
name|eaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"%s: read MAC address failed\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|bad
goto|;
block|}
comment|/* Print Ethernet Address */
name|printf
argument_list|(
literal|"%s: Ethernet address %s\n"
argument_list|,
name|devname
argument_list|,
name|ether_sprintf
argument_list|(
name|eaddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize interface infomation */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ifp
operator|=
name|GET_IFP
argument_list|(
name|sc
argument_list|)
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can not if_alloc\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
else|#
directive|else
name|ifp
operator|=
name|GET_IFP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|strncpy
argument_list|(
name|ifp
operator|->
name|if_xname
argument_list|,
name|devname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"udav"
argument_list|,
name|device_get_unit
argument_list|(
name|self
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator||
name|IFF_NEEDSGIANT
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|udav_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|udav_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|udav_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|udav_init
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|ifp
operator|->
name|if_stop
operator|=
name|udav_stop
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
comment|/* 	 * Do ifmedia setup. 	 */
name|mii
operator|=
operator|&
name|sc
operator|->
name|sc_mii
expr_stmt|;
name|mii
operator|->
name|mii_ifp
operator|=
name|ifp
expr_stmt|;
name|mii
operator|->
name|mii_readreg
operator|=
name|udav_miibus_readreg
expr_stmt|;
name|mii
operator|->
name|mii_writereg
operator|=
name|udav_miibus_writereg
expr_stmt|;
name|mii
operator|->
name|mii_statchg
operator|=
name|udav_miibus_statchg
expr_stmt|;
name|mii
operator|->
name|mii_flags
operator|=
name|MIIF_AUTOTSLEEP
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
literal|0
argument_list|,
name|udav_ifmedia_change
argument_list|,
name|udav_ifmedia_status
argument_list|)
expr_stmt|;
name|mii_attach
argument_list|(
name|self
argument_list|,
name|mii
argument_list|,
literal|0xffffffff
argument_list|,
name|MII_PHY_ANY
argument_list|,
name|MII_OFFSET_ANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|mii
operator|->
name|mii_phys
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_NONE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_NONE
argument_list|)
expr_stmt|;
block|}
else|else
name|ifmedia_set
argument_list|(
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
comment|/* attach the interface */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|Ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|mii_phy_probe
argument_list|(
name|self
argument_list|,
operator|&
name|sc
operator|->
name|sc_miibus
argument_list|,
name|udav_ifmedia_change
argument_list|,
name|udav_ifmedia_status
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: MII without any PHY!\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|sc_qdat
operator|.
name|ifp
operator|=
name|ifp
expr_stmt|;
name|sc
operator|->
name|sc_qdat
operator|.
name|if_rxstart
operator|=
name|udav_rxstart
expr_stmt|;
comment|/* 	 * Call MI attach routine. 	 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|NRND
argument_list|)
operator|&&
name|NRND
operator|>
literal|0
name|rnd_attach_source
argument_list|(
operator|&
name|sc
operator|->
name|rnd_source
argument_list|,
name|devname
argument_list|,
name|RND_TYPE_NET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usb_callout_init
argument_list|(
name|sc
operator|->
name|sc_stat_ch
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|usb_register_netisr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_attached
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usbd_add_drv_event
argument_list|(
name|USB_EVENT_DRIVER_ATTACH
argument_list|,
name|dev
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_comment
comment|/* detach */
end_comment

begin_function
specifier|static
name|int
name|udav_detach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|USB_DETACH_START
argument_list|(
name|udav
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|GET_IFP
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|int
name|s
decl_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Detached before attached finished */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_attached
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|UDAV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|usb_uncallout
argument_list|(
name|sc
operator|->
name|sc_stat_ch
argument_list|,
name|udav_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Remove any pending tasks */
name|usb_rem_task
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_tick_task
argument_list|)
expr_stmt|;
name|usb_rem_task
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_stop_task
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|>=
literal|0
condition|)
block|{
comment|/* Wait for processes to go away */
name|usb_detach_wait
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
else|#
directive|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
endif|#
directive|endif
name|udav_stop
argument_list|(
name|GET_IFP
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NRND
argument_list|)
operator|&&
name|NRND
operator|>
literal|0
name|rnd_detach_source
argument_list|(
operator|&
name|sc
operator|->
name|rnd_source
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|mii_detach
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii
argument_list|,
name|MII_PHY_ANY
argument_list|,
name|MII_OFFSET_ANY
argument_list|)
expr_stmt|;
name|ifmedia_delete_instance
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii
operator|.
name|mii_media
argument_list|,
name|IFM_INST_ANY
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|if_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sc
operator|->
name|sc_pipe_tx
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: detach has active tx endpoint.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_pipe_rx
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: detach has active rx endpoint.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_pipe_intr
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: detach has active intr endpoint.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_attached
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usbd_add_drv_event
argument_list|(
name|USB_EVENT_DRIVER_DETACH
argument_list|,
name|sc
operator|->
name|sc_udev
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* read memory */
end_comment

begin_comment
unit|static int udav_mem_read(struct udav_softc *sc, int offset, void *buf, int len) { 	usb_device_request_t req; 	usbd_status err;  	if (sc == NULL) 		return (0);  	DPRINTFN(0x200, 		("%s: %s: enter\n", device_get_nameunit(sc->sc_dev), __func__));  	if (sc->sc_dying) 		return (0);  	offset&= 0xffff; 	len&= 0xff;  	req.bmRequestType = UT_READ_VENDOR_DEVICE; 	req.bRequest = UDAV_REQ_MEM_READ; 	USETW(req.wValue, 0x0000); 	USETW(req.wIndex, offset); 	USETW(req.wLength, len);  	sc->sc_refcnt++; 	err = usbd_do_request(sc->sc_udev,&req, buf); 	if (--sc->sc_refcnt< 0) 		usb_detach_wakeup(sc->sc_dev); 	if (err) { 		DPRINTF(("%s: %s: read failed. off=%04x, err=%d\n", 			 device_get_nameunit(sc->sc_dev), __func__, offset, err)); 	}  	return (err); }
comment|/* write memory */
end_comment

begin_comment
unit|static int udav_mem_write(struct udav_softc *sc, int offset, void *buf, int len) { 	usb_device_request_t req; 	usbd_status err;  	if (sc == NULL) 		return (0);  	DPRINTFN(0x200, 		("%s: %s: enter\n", device_get_nameunit(sc->sc_dev), __func__));  	if (sc->sc_dying) 		return (0);  	offset&= 0xffff; 	len&= 0xff;  	req.bmRequestType = UT_WRITE_VENDOR_DEVICE; 	req.bRequest = UDAV_REQ_MEM_WRITE; 	USETW(req.wValue, 0x0000); 	USETW(req.wIndex, offset); 	USETW(req.wLength, len);  	sc->sc_refcnt++; 	err = usbd_do_request(sc->sc_udev,&req, buf); 	if (--sc->sc_refcnt< 0) 		usb_detach_wakeup(sc->sc_dev); 	if (err) { 		DPRINTF(("%s: %s: write failed. off=%04x, err=%d\n", 			 device_get_nameunit(sc->sc_dev), __func__, offset, err)); 	}  	return (err); }
comment|/* write memory */
end_comment

begin_endif
unit|static int udav_mem_write1(struct udav_softc *sc, int offset, unsigned char ch) { 	usb_device_request_t req; 	usbd_status err;  	if (sc == NULL) 		return (0);  	DPRINTFN(0x200, 		("%s: %s: enter\n", device_get_nameunit(sc->sc_dev), __func__));  	if (sc->sc_dying) 		return (0);  	offset&= 0xffff;  	req.bmRequestType = UT_WRITE_VENDOR_DEVICE; 	req.bRequest = UDAV_REQ_MEM_WRITE1; 	USETW(req.wValue, ch); 	USETW(req.wIndex, offset); 	USETW(req.wLength, 0x0000);  	sc->sc_refcnt++; 	err = usbd_do_request(sc->sc_udev,&req, NULL); 	if (--sc->sc_refcnt< 0) 		usb_detach_wakeup(sc->sc_dev); 	if (err) { 		DPRINTF(("%s: %s: write failed. off=%04x, err=%d\n", 			 device_get_nameunit(sc->sc_dev), __func__, offset, err)); 	}  	return (err); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* read register(s) */
end_comment

begin_function
specifier|static
name|int
name|udav_csr_read
parameter_list|(
name|struct
name|udav_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DPRINTFN
argument_list|(
literal|0x200
argument_list|,
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|offset
operator|&=
literal|0xff
expr_stmt|;
name|len
operator|&=
literal|0xff
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_READ_VENDOR_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UDAV_REQ_REG_READ
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_refcnt
operator|++
expr_stmt|;
name|err
operator|=
name|usbd_do_request
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|req
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|<
literal|0
condition|)
name|usb_detach_wakeup
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: read failed. off=%04x, err=%d\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|,
name|offset
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* write register(s) */
end_comment

begin_function
specifier|static
name|int
name|udav_csr_write
parameter_list|(
name|struct
name|udav_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DPRINTFN
argument_list|(
literal|0x200
argument_list|,
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|offset
operator|&=
literal|0xff
expr_stmt|;
name|len
operator|&=
literal|0xff
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_VENDOR_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UDAV_REQ_REG_WRITE
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_refcnt
operator|++
expr_stmt|;
name|err
operator|=
name|usbd_do_request
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|req
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|<
literal|0
condition|)
name|usb_detach_wakeup
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: write failed. off=%04x, err=%d\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|,
name|offset
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udav_csr_read1
parameter_list|(
name|struct
name|udav_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|u_int8_t
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DPRINTFN
argument_list|(
literal|0x200
argument_list|,
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|udav_csr_read
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|)
condition|?
literal|0
else|:
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* write a register */
end_comment

begin_function
specifier|static
name|int
name|udav_csr_write1
parameter_list|(
name|struct
name|udav_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|unsigned
name|char
name|ch
parameter_list|)
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DPRINTFN
argument_list|(
literal|0x200
argument_list|,
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|offset
operator|&=
literal|0xff
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_VENDOR_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UDAV_REQ_REG_WRITE1
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_refcnt
operator|++
expr_stmt|;
name|err
operator|=
name|usbd_do_request
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|req
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|<
literal|0
condition|)
name|usb_detach_wakeup
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: write failed. off=%04x, err=%d\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|,
name|offset
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|udav_init
argument_list|(
expr|struct
name|ifnet
operator|*
name|ifp
argument_list|)
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
decl|static
name|void
name|udav_init
argument_list|(
name|void
operator|*
name|xsc
argument_list|)
endif|#
directive|endif
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|struct
name|udav_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|struct
name|udav_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|udav_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|GET_IFP
argument_list|(
name|sc
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|struct
name|mii_data
modifier|*
name|mii
init|=
name|GET_MII
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|u_char
modifier|*
name|eaddr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|int
name|s
decl_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
return|return
operator|(
name|EIO
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
return|return ;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Cancel pending I/O and free all TX/RX buffers */
name|udav_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|eaddr
operator|=
name|LLADDR
argument_list|(
name|ifp
operator|->
name|if_sadl
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|eaddr
operator|=
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|udav_csr_write
argument_list|(
name|sc
argument_list|,
name|UDAV_PAR
argument_list|,
name|eaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Initialize network control register */
comment|/*  Disable loopback  */
name|UDAV_CLRBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_NCR
argument_list|,
name|UDAV_NCR_LBK0
operator||
name|UDAV_NCR_LBK1
argument_list|)
expr_stmt|;
comment|/* Initialize RX control register */
name|UDAV_SETBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_RCR
argument_list|,
name|UDAV_RCR_DIS_LONG
operator||
name|UDAV_RCR_DIS_CRC
argument_list|)
expr_stmt|;
comment|/* If we want promiscuous mode, accept all physical frames. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|UDAV_SETBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_RCR
argument_list|,
name|UDAV_RCR_ALL
operator||
name|UDAV_RCR_PRMSC
argument_list|)
expr_stmt|;
else|else
name|UDAV_CLRBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_RCR
argument_list|,
name|UDAV_RCR_ALL
operator||
name|UDAV_RCR_PRMSC
argument_list|)
expr_stmt|;
comment|/* Initialize transmit ring */
if|if
condition|(
name|usb_ether_tx_list_init
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdata
argument_list|,
name|sc
operator|->
name|sc_udev
argument_list|)
operator|==
name|ENOBUFS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: tx list init failed\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return ;
endif|#
directive|endif
block|}
comment|/* Initialize receive ring */
if|if
condition|(
name|usb_ether_rx_list_init
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdata
argument_list|,
name|sc
operator|->
name|sc_udev
argument_list|)
operator|==
name|ENOBUFS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: rx list init failed\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return ;
endif|#
directive|endif
block|}
comment|/* Load the multicast filter */
name|udav_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable RX */
name|UDAV_SETBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_RCR
argument_list|,
name|UDAV_RCR_RXEN
argument_list|)
expr_stmt|;
comment|/* clear POWER_DOWN state of internal PHY */
name|UDAV_SETBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_GPCR
argument_list|,
name|UDAV_GPCR_GEP_CNTL0
argument_list|)
expr_stmt|;
name|UDAV_CLRBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_GPR
argument_list|,
name|UDAV_GPR_GEPIO0
argument_list|)
expr_stmt|;
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_pipe_tx
operator|==
name|NULL
operator|||
name|sc
operator|->
name|sc_pipe_rx
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|udav_openpipes
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return ;
endif|#
directive|endif
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usb_callout
argument_list|(
name|sc
operator|->
name|sc_stat_ch
argument_list|,
name|hz
argument_list|,
name|udav_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
return|return ;
endif|#
directive|endif
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|udav_reset
parameter_list|(
name|struct
name|udav_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return;
comment|/* Select PHY */
if|#
directive|if
literal|1
comment|/* 	 * XXX: force select internal phy. 	 *	external phy routines are not tested. 	 */
name|UDAV_CLRBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_NCR
argument_list|,
name|UDAV_NCR_EXT_PHY
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UDAV_EXT_PHY
condition|)
block|{
name|UDAV_SETBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_NCR
argument_list|,
name|UDAV_NCR_EXT_PHY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UDAV_CLRBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_NCR
argument_list|,
name|UDAV_NCR_EXT_PHY
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|UDAV_SETBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_NCR
argument_list|,
name|UDAV_NCR_RST
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UDAV_TX_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|udav_csr_read1
argument_list|(
name|sc
argument_list|,
name|UDAV_NCR
argument_list|)
operator|&
name|UDAV_NCR_RST
operator|)
condition|)
break|break;
name|delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
name|delay
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|int
name|udav_activate
parameter_list|(
name|device_t
name|self
parameter_list|,
name|enum
name|devact
name|act
parameter_list|)
block|{
name|struct
name|udav_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|udav_softc
operator|*
operator|)
name|self
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter, act=%d\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|,
name|act
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|act
condition|)
block|{
case|case
name|DVACT_ACTIVATE
case|:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
case|case
name|DVACT_DEACTIVATE
case|:
name|if_deactivate
argument_list|(
operator|&
name|sc
operator|->
name|sc_ec
operator|.
name|ec_if
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UDAV_BITS
value|6
end_define

begin_define
define|#
directive|define
name|UDAV_CALCHASH
parameter_list|(
name|addr
parameter_list|)
define|\
value|(ether_crc32_le((addr), ETHER_ADDR_LEN)& ((1<< UDAV_BITS) - 1))
end_define

begin_function
specifier|static
name|void
name|udav_setmulti
parameter_list|(
name|struct
name|udav_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|struct
name|ether_multi
modifier|*
name|enm
decl_stmt|;
name|struct
name|ether_multistep
name|step
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
endif|#
directive|endif
name|u_int8_t
name|hashes
index|[
literal|8
index|]
decl_stmt|;
name|int
name|h
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return;
name|ifp
operator|=
name|GET_IFP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|UDAV_SETBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_RCR
argument_list|,
name|UDAV_RCR_ALL
operator||
name|UDAV_RCR_PRMSC
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|allmulti
label|:
endif|#
directive|endif
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
name|UDAV_SETBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_RCR
argument_list|,
name|UDAV_RCR_ALL
argument_list|)
expr_stmt|;
name|UDAV_CLRBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_RCR
argument_list|,
name|UDAV_RCR_PRMSC
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* first, zot all the existing hash bits */
name|memset
argument_list|(
name|hashes
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
name|hashes
argument_list|)
argument_list|)
expr_stmt|;
name|hashes
index|[
literal|7
index|]
operator||=
literal|0x80
expr_stmt|;
comment|/* broadcast address */
name|udav_csr_write
argument_list|(
name|sc
argument_list|,
name|UDAV_MAR
argument_list|,
name|hashes
argument_list|,
sizeof|sizeof
argument_list|(
name|hashes
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now program new ones */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|ETHER_FIRST_MULTI
argument_list|(
name|step
argument_list|,
operator|&
name|sc
operator|->
name|sc_ec
argument_list|,
name|enm
argument_list|)
expr_stmt|;
while|while
condition|(
name|enm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|enm
operator|->
name|enm_addrlo
argument_list|,
name|enm
operator|->
name|enm_addrhi
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|allmulti
goto|;
name|h
operator|=
name|UDAV_CALCHASH
argument_list|(
name|enm
operator|->
name|enm_addrlo
argument_list|)
expr_stmt|;
name|hashes
index|[
name|h
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
expr_stmt|;
name|ETHER_NEXT_MULTI
argument_list|(
name|step
argument_list|,
name|enm
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|h
operator|=
name|UDAV_CALCHASH
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
expr_stmt|;
name|hashes
index|[
name|h
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* disable all multicast */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_ALLMULTI
expr_stmt|;
name|UDAV_CLRBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_RCR
argument_list|,
name|UDAV_RCR_ALL
argument_list|)
expr_stmt|;
comment|/* write hash value to the register */
name|udav_csr_write
argument_list|(
name|sc
argument_list|,
name|UDAV_MAR
argument_list|,
name|hashes
argument_list|,
sizeof|sizeof
argument_list|(
name|hashes
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|udav_openpipes
parameter_list|(
name|struct
name|udav_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ue_chain
modifier|*
name|c
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|sc
operator|->
name|sc_refcnt
operator|++
expr_stmt|;
comment|/* Open RX pipe */
name|err
operator|=
name|usbd_open_pipe
argument_list|(
name|sc
operator|->
name|sc_ctl_iface
argument_list|,
name|sc
operator|->
name|sc_bulkin_no
argument_list|,
name|USBD_EXCLUSIVE_USE
argument_list|,
operator|&
name|sc
operator|->
name|sc_pipe_rx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"%s: open rx pipe failed: %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Open TX pipe */
name|err
operator|=
name|usbd_open_pipe
argument_list|(
name|sc
operator|->
name|sc_ctl_iface
argument_list|,
name|sc
operator|->
name|sc_bulkout_no
argument_list|,
name|USBD_EXCLUSIVE_USE
argument_list|,
operator|&
name|sc
operator|->
name|sc_pipe_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"%s: open tx pipe failed: %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|#
directive|if
literal|0
comment|/* XXX: interrupt endpoint is not yet supported */
comment|/* Open Interrupt pipe */
block|err = usbd_open_pipe_intr(sc->sc_ctl_iface, sc->sc_intrin_no, 				  USBD_EXCLUSIVE_USE,&sc->sc_pipe_intr, sc,&sc->sc_cdata.ue_ibuf, UDAV_INTR_PKGLEN, 				  udav_intr, UDAV_INTR_INTERVAL); 	if (err) { 		printf("%s: open intr pipe failed: %s\n", 		       device_get_nameunit(sc->sc_dev), usbd_errstr(err)); 		error = EIO; 		goto done; 	}
endif|#
directive|endif
comment|/* Start up the receive pipe. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UE_RX_LIST_CNT
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|ue_rx_chain
index|[
name|i
index|]
expr_stmt|;
name|usbd_setup_xfer
argument_list|(
name|c
operator|->
name|ue_xfer
argument_list|,
name|sc
operator|->
name|sc_pipe_rx
argument_list|,
name|c
argument_list|,
name|c
operator|->
name|ue_buf
argument_list|,
name|UE_BUFSZ
argument_list|,
name|USBD_SHORT_XFER_OK
operator||
name|USBD_NO_COPY
argument_list|,
name|USBD_NO_TIMEOUT
argument_list|,
name|udav_rxeof
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|usbd_transfer
argument_list|(
name|c
operator|->
name|ue_xfer
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: start read\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|<
literal|0
condition|)
name|usb_detach_wakeup
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|udav_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|udav_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
init|=
name|NULL
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter, link=%d\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|,
name|sc
operator|->
name|sc_link
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_link
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
condition|)
else|#
directive|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
endif|#
directive|endif
return|return;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|IFQ_POLL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|udav_send
argument_list|(
name|sc
argument_list|,
name|m_head
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
comment|/* Set a timeout in case the chip goes out to lunch. */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|udav_send
parameter_list|(
name|struct
name|udav_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|total_len
decl_stmt|;
name|struct
name|ue_chain
modifier|*
name|c
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|c
operator|=
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|ue_tx_chain
index|[
name|idx
index|]
expr_stmt|;
comment|/* Copy the mbuf data into a contiguous buffer */
comment|/*  first 2 bytes are packet length */
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|c
operator|->
name|ue_buf
operator|+
literal|2
argument_list|)
expr_stmt|;
name|c
operator|->
name|ue_mbuf
operator|=
name|m
expr_stmt|;
name|total_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|total_len
operator|<
name|UDAV_MIN_FRAME_LEN
condition|)
block|{
name|memset
argument_list|(
name|c
operator|->
name|ue_buf
operator|+
literal|2
operator|+
name|total_len
argument_list|,
literal|0
argument_list|,
name|UDAV_MIN_FRAME_LEN
operator|-
name|total_len
argument_list|)
expr_stmt|;
name|total_len
operator|=
name|UDAV_MIN_FRAME_LEN
expr_stmt|;
block|}
comment|/* Frame length is specified in the first 2bytes of the buffer */
name|c
operator|->
name|ue_buf
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|total_len
expr_stmt|;
name|c
operator|->
name|ue_buf
index|[
literal|1
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|total_len
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|total_len
operator|+=
literal|2
expr_stmt|;
name|usbd_setup_xfer
argument_list|(
name|c
operator|->
name|ue_xfer
argument_list|,
name|sc
operator|->
name|sc_pipe_tx
argument_list|,
name|c
argument_list|,
name|c
operator|->
name|ue_buf
argument_list|,
name|total_len
argument_list|,
name|USBD_FORCE_SHORT_XFER
operator||
name|USBD_NO_COPY
argument_list|,
name|UDAV_TX_TIMEOUT
argument_list|,
name|udav_txeof
argument_list|)
expr_stmt|;
comment|/* Transmit */
name|sc
operator|->
name|sc_refcnt
operator|++
expr_stmt|;
name|err
operator|=
name|usbd_transfer
argument_list|(
name|c
operator|->
name|ue_xfer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|<
literal|0
condition|)
name|usb_detach_wakeup
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USBD_IN_PROGRESS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: udav_send error=%s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stop the interface */
name|usb_add_task
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_stop_task
argument_list|,
name|USB_TASKQ_DRIVER
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: send %d bytes\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|,
name|total_len
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|ue_tx_cnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|udav_txeof
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|priv
parameter_list|,
name|usbd_status
name|status
parameter_list|)
block|{
name|struct
name|ue_chain
modifier|*
name|c
init|=
name|priv
decl_stmt|;
name|struct
name|udav_softc
modifier|*
name|sc
init|=
name|c
operator|->
name|ue_sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|GET_IFP
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|int
name|s
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|USBD_NOT_STARTED
operator|||
name|status
operator|==
name|USBD_CANCELLED
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%s: usb error on tx: %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|usbd_errstr
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|USBD_STALLED
condition|)
block|{
name|sc
operator|->
name|sc_refcnt
operator|++
expr_stmt|;
name|usbd_clear_endpoint_stall
argument_list|(
name|sc
operator|->
name|sc_pipe_tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|<
literal|0
condition|)
name|usb_detach_wakeup
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|c
operator|->
name|ue_mbuf
argument_list|)
expr_stmt|;
name|c
operator|->
name|ue_mbuf
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
operator|==
literal|0
condition|)
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
endif|#
directive|endif
name|udav_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|udav_rxeof
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|priv
parameter_list|,
name|usbd_status
name|status
parameter_list|)
block|{
name|struct
name|ue_chain
modifier|*
name|c
init|=
name|priv
decl_stmt|;
name|struct
name|udav_softc
modifier|*
name|sc
init|=
name|c
operator|->
name|ue_sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|GET_IFP
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int32_t
name|total_len
decl_stmt|;
name|u_int8_t
modifier|*
name|pktstat
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|int
name|s
decl_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return;
if|if
condition|(
name|status
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|USBD_NOT_STARTED
operator|||
name|status
operator|==
name|USBD_CANCELLED
condition|)
return|return;
name|sc
operator|->
name|sc_rx_errs
operator|++
expr_stmt|;
if|if
condition|(
name|usbd_ratecheck
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_notice
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %u usb errors on rx: %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_rx_errs
argument_list|,
name|usbd_errstr
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_errs
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|USBD_STALLED
condition|)
block|{
name|sc
operator|->
name|sc_refcnt
operator|++
expr_stmt|;
name|usbd_clear_endpoint_stall
argument_list|(
name|sc
operator|->
name|sc_pipe_rx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|<
literal|0
condition|)
name|usb_detach_wakeup
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|usbd_get_xfer_status
argument_list|(
name|xfer
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|total_len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* copy data to mbuf */
name|m
operator|=
name|c
operator|->
name|ue_mbuf
expr_stmt|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|c
operator|->
name|ue_buf
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
comment|/* first byte in received data */
name|pktstat
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: RX Status: 0x%02x\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
operator|*
name|pktstat
operator|)
argument_list|)
expr_stmt|;
name|total_len
operator|=
name|UGETW
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pktstat
operator|&
name|UDAV_RSR_LCS
condition|)
block|{
name|ifp
operator|->
name|if_collisions
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|total_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|||
operator|*
name|pktstat
operator|&
name|UDAV_RSR_ERR
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|total_len
operator|-=
name|ETHER_CRC_LEN
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|total_len
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_qdat
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|c
operator|->
name|ue_mbuf
operator|=
name|usb_ether_newbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ue_mbuf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no memory for rx list "
literal|"-- packet dropped!\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|done1
goto|;
block|}
endif|#
directive|endif
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: deliver %d\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|IF_INPUT
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|usb_ether_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return ;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|done1
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|done
label|:
comment|/* Setup new transfer */
name|usbd_setup_xfer
argument_list|(
name|xfer
argument_list|,
name|sc
operator|->
name|sc_pipe_rx
argument_list|,
name|c
argument_list|,
name|c
operator|->
name|ue_buf
argument_list|,
name|UE_BUFSZ
argument_list|,
name|USBD_SHORT_XFER_OK
operator||
name|USBD_NO_COPY
argument_list|,
name|USBD_NO_TIMEOUT
argument_list|,
name|udav_rxeof
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_refcnt
operator|++
expr_stmt|;
name|usbd_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|<
literal|0
condition|)
name|usb_detach_wakeup
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: start rx\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void udav_intr() { }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|udav_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|udav_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|int
name|s
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|UDAV_SETBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_RCR
argument_list|,
name|UDAV_RCR_ALL
operator||
name|UDAV_RCR_PRMSC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|UDAV_CLRBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_RCR
argument_list|,
name|UDAV_RCR_PRMSC
argument_list|)
expr_stmt|;
else|else
name|UDAV_CLRBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_RCR
argument_list|,
name|UDAV_RCR_ALL
operator||
name|UDAV_RCR_PRMSC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|udav_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|udav_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|udav_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|mii
operator|=
name|GET_MII
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
name|udav_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|udav_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|udav_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ue_chain
modifier|*
name|c
decl_stmt|;
name|usbd_status
name|stat
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|int
name|s
decl_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%s: watchdog timeout\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_LOCK
argument_list|(
argument|sc
argument_list|)
endif|#
directive|endif
name|c
operator|=
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|ue_tx_chain
index|[
literal|0
index|]
expr_stmt|;
name|usbd_get_xfer_status
argument_list|(
name|c
operator|->
name|ue_xfer
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|stat
argument_list|)
expr_stmt|;
name|udav_txeof
argument_list|(
name|c
operator|->
name|ue_xfer
argument_list|,
name|c
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
operator|==
literal|0
condition|)
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
endif|#
directive|endif
name|udav_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|udav_stop_task
parameter_list|(
name|struct
name|udav_softc
modifier|*
name|sc
parameter_list|)
block|{
name|udav_stop
argument_list|(
name|GET_IFP
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop the adapter and free any mbufs allocated to the RX and TX lists. */
end_comment

begin_function
specifier|static
name|void
name|udav_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|disable
parameter_list|)
block|{
name|struct
name|udav_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|udav_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|usb_uncallout
argument_list|(
name|sc
operator|->
name|sc_stat_ch
argument_list|,
name|udav_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Stop transfers */
comment|/* RX endpoint */
if|if
condition|(
name|sc
operator|->
name|sc_pipe_rx
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|usbd_abort_pipe
argument_list|(
name|sc
operator|->
name|sc_pipe_rx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|printf
argument_list|(
literal|"%s: abort rx pipe failed: %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_close_pipe
argument_list|(
name|sc
operator|->
name|sc_pipe_rx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|printf
argument_list|(
literal|"%s: close rx pipe failed: %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_pipe_rx
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* TX endpoint */
if|if
condition|(
name|sc
operator|->
name|sc_pipe_tx
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|usbd_abort_pipe
argument_list|(
name|sc
operator|->
name|sc_pipe_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|printf
argument_list|(
literal|"%s: abort tx pipe failed: %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_close_pipe
argument_list|(
name|sc
operator|->
name|sc_pipe_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|printf
argument_list|(
literal|"%s: close tx pipe failed: %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_pipe_tx
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* XXX: Interrupt endpoint is not yet supported!! */
comment|/* Interrupt endpoint */
block|if (sc->sc_pipe_intr != NULL) { 		err = usbd_abort_pipe(sc->sc_pipe_intr); 		if (err) 			printf("%s: abort intr pipe failed: %s\n", 			       device_get_nameunit(sc->sc_dev), usbd_errstr(err)); 		err = usbd_close_pipe(sc->sc_pipe_intr); 		if (err) 			printf("%s: close intr pipe failed: %s\n", 			       device_get_nameunit(sc->sc_dev), usbd_errstr(err)); 		sc->sc_pipe_intr = NULL; 	}
endif|#
directive|endif
comment|/* Free RX resources. */
name|usb_ether_rx_list_free
argument_list|(
operator|&
name|sc
operator|->
name|sc_cdata
argument_list|)
expr_stmt|;
comment|/* Free TX resources. */
name|usb_ether_tx_list_free
argument_list|(
operator|&
name|sc
operator|->
name|sc_cdata
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_link
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Set media options */
end_comment

begin_function
specifier|static
name|int
name|udav_ifmedia_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|udav_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
init|=
name|GET_MII
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|sc_link
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mii
operator|->
name|mii_instance
condition|)
block|{
name|struct
name|mii_softc
modifier|*
name|miisc
decl_stmt|;
for|for
control|(
name|miisc
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|mii
operator|->
name|mii_phys
argument_list|)
init|;
name|miisc
operator|!=
name|NULL
condition|;
name|miisc
operator|=
name|LIST_NEXT
argument_list|(
name|miisc
argument_list|,
name|mii_list
argument_list|)
control|)
name|mii_phy_reset
argument_list|(
name|miisc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Report current media status. */
end_comment

begin_function
specifier|static
name|void
name|udav_ifmedia_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|udav_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
init|=
name|GET_MII
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_NONE
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
block|}
specifier|static
name|void
name|udav_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|udav_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|DPRINTFN
argument_list|(
literal|0xff
argument_list|,
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return;
comment|/* Perform periodic stuff in process context */
name|usb_add_task
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_tick_task
argument_list|,
name|USB_TASKQ_DRIVER
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|udav_tick_task
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|udav_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|int
name|s
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|DPRINTFN
argument_list|(
literal|0xff
argument_list|,
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return;
name|ifp
operator|=
name|GET_IFP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|GET_MII
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii
operator|==
name|NULL
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_link
condition|)
block|{
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii
operator|->
name|mii_media_status
operator|&
name|IFM_ACTIVE
operator|&&
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|!=
name|IFM_NONE
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: got link\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_link
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
operator|==
literal|0
condition|)
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
endif|#
directive|endif
name|udav_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
name|usb_callout
argument_list|(
name|sc
operator|->
name|sc_stat_ch
argument_list|,
name|hz
argument_list|,
name|udav_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Get exclusive access to the MII registers */
specifier|static
name|void
name|udav_lock_mii
parameter_list|(
name|struct
name|udav_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|0xff
argument_list|,
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_refcnt
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|lockmgr
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii_lock
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|lockmgr
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii_lock
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|void
name|udav_unlock_mii
parameter_list|(
name|struct
name|udav_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|0xff
argument_list|,
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|lockmgr
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii_lock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|lockmgr
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii_lock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|<
literal|0
condition|)
name|usb_detach_wakeup
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|udav_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|udav_softc
modifier|*
name|sc
decl_stmt|;
name|u_int8_t
name|val
index|[
literal|2
index|]
decl_stmt|;
name|u_int16_t
name|data16
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|=
name|USBGETSOFTC
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|0xff
argument_list|,
operator|(
literal|"%s: %s: enter, phy=%d reg=0x%04x\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|,
name|phy
operator|,
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"%s: %s: dying\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* XXX: one PHY only for the internal PHY */
if|if
condition|(
name|phy
operator|!=
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0xff
argument_list|,
operator|(
literal|"%s: %s: phy=%d is not supported\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|,
name|phy
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|udav_lock_mii
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* select internal PHY and set PHY register address */
name|udav_csr_write1
argument_list|(
name|sc
argument_list|,
name|UDAV_EPAR
argument_list|,
name|UDAV_EPAR_PHY_ADR0
operator||
operator|(
name|reg
operator|&
name|UDAV_EPAR_EROA_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* select PHY operation and start read command */
name|udav_csr_write1
argument_list|(
name|sc
argument_list|,
name|UDAV_EPCR
argument_list|,
name|UDAV_EPCR_EPOS
operator||
name|UDAV_EPCR_ERPRR
argument_list|)
expr_stmt|;
comment|/* XXX: should be wait? */
comment|/* end read command */
name|UDAV_CLRBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_EPCR
argument_list|,
name|UDAV_EPCR_ERPRR
argument_list|)
expr_stmt|;
comment|/* retrieve the result from data registers */
name|udav_csr_read
argument_list|(
name|sc
argument_list|,
name|UDAV_EPDRL
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|udav_unlock_mii
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|data16
operator|=
name|val
index|[
literal|0
index|]
operator||
operator|(
name|val
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|0xff
argument_list|,
operator|(
literal|"%s: %s: phy=%d reg=0x%04x => 0x%04x\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|,
name|phy
operator|,
name|reg
operator|,
name|data16
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|data16
operator|)
return|;
block|}
specifier|static
name|void
name|udav_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|struct
name|udav_softc
modifier|*
name|sc
decl_stmt|;
name|u_int8_t
name|val
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|=
name|USBGETSOFTC
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|0xff
argument_list|,
operator|(
literal|"%s: %s: enter, phy=%d reg=0x%04x data=0x%04x\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|,
name|phy
operator|,
name|reg
operator|,
name|data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"%s: %s: dying\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* XXX: one PHY only for the internal PHY */
if|if
condition|(
name|phy
operator|!=
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0xff
argument_list|,
operator|(
literal|"%s: %s: phy=%d is not supported\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|,
name|phy
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|udav_lock_mii
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* select internal PHY and set PHY register address */
name|udav_csr_write1
argument_list|(
name|sc
argument_list|,
name|UDAV_EPAR
argument_list|,
name|UDAV_EPAR_PHY_ADR0
operator||
operator|(
name|reg
operator|&
name|UDAV_EPAR_EROA_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* put the value to the data registers */
name|val
index|[
literal|0
index|]
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
name|val
index|[
literal|1
index|]
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|udav_csr_write
argument_list|(
name|sc
argument_list|,
name|UDAV_EPDRL
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* select PHY operation and start write command */
name|udav_csr_write1
argument_list|(
name|sc
argument_list|,
name|UDAV_EPCR
argument_list|,
name|UDAV_EPCR_EPOS
operator||
name|UDAV_EPCR_ERPRW
argument_list|)
expr_stmt|;
comment|/* XXX: should be wait? */
comment|/* end write command */
name|UDAV_CLRBIT
argument_list|(
name|sc
argument_list|,
name|UDAV_EPCR
argument_list|,
name|UDAV_EPCR_ERPRW
argument_list|)
expr_stmt|;
name|udav_unlock_mii
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|udav_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|UDAV_DEBUG
name|struct
name|udav_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|=
name|USBGETSOFTC
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s: enter\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Nothing to do */
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/*  * Stop all chip I/O so that the kernel's probe routines don't  * get confused by errant DMAs when rebooting.  */
specifier|static
name|void
name|udav_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|udav_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|udav_stop_task
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|udav_rxstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|udav_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ue_chain
modifier|*
name|c
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|UDAV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|c
operator|=
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|ue_rx_chain
index|[
name|sc
operator|->
name|sc_cdata
operator|.
name|ue_rx_prod
index|]
expr_stmt|;
name|c
operator|->
name|ue_mbuf
operator|=
name|usb_ether_newbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ue_mbuf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no memory for rx list "
literal|"-- packet dropped!\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Setup new transfer. */
name|usbd_setup_xfer
argument_list|(
name|c
operator|->
name|ue_xfer
argument_list|,
name|sc
operator|->
name|sc_pipe_rx
argument_list|,
name|c
argument_list|,
name|c
operator|->
name|ue_buf
argument_list|,
name|UE_BUFSZ
argument_list|,
name|USBD_SHORT_XFER_OK
operator||
name|USBD_NO_COPY
argument_list|,
name|USBD_NO_TIMEOUT
argument_list|,
name|udav_rxeof
argument_list|)
expr_stmt|;
name|usbd_transfer
argument_list|(
name|c
operator|->
name|ue_xfer
argument_list|)
expr_stmt|;
name|UDAV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

