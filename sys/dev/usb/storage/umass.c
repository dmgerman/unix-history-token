begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Copyright (c) 1999 MAEKAWA Masahide<bishop@rr.iij4u.or.jp>,  *		      Nick Hibma<n_hibma@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  *	$NetBSD: umass.c,v 1.28 2000/04/02 23:46:53 augustss Exp $  */
end_comment

begin_comment
comment|/* Also already merged from NetBSD:  *	$NetBSD: umass.c,v 1.67 2001/11/25 19:05:22 augustss Exp $  *	$NetBSD: umass.c,v 1.90 2002/11/04 19:17:33 pooka Exp $  *	$NetBSD: umass.c,v 1.108 2003/11/07 17:03:25 wiz Exp $  *	$NetBSD: umass.c,v 1.109 2003/12/04 13:57:31 keihan Exp $  */
end_comment

begin_comment
comment|/*  * Universal Serial Bus Mass Storage Class specs:  * http://www.usb.org/developers/devclass_docs/usb_msc_overview_1.2.pdf  * http://www.usb.org/developers/devclass_docs/usbmassbulk_10.pdf  * http://www.usb.org/developers/devclass_docs/usb_msc_cbi_1.1.pdf  * http://www.usb.org/developers/devclass_docs/usbmass-ufi10.pdf  */
end_comment

begin_comment
comment|/*  * Ported to NetBSD by Lennart Augustsson<augustss@NetBSD.org>.  * Parts of the code written by Jason R. Thorpe<thorpej@shagadelic.org>.  */
end_comment

begin_comment
comment|/*  * The driver handles 3 Wire Protocols  * - Command/Bulk/Interrupt (CBI)  * - Command/Bulk/Interrupt with Command Completion Interrupt (CBI with CCI)  * - Mass Storage Bulk-Only (BBB)  *   (BBB refers Bulk/Bulk/Bulk for Command/Data/Status phases)  *  * Over these wire protocols it handles the following command protocols  * - SCSI  * - UFI (floppy command set)  * - 8070i (ATAPI)  *  * UFI and 8070i (ATAPI) are transformed versions of the SCSI command set. The  * sc->sc_transform method is used to convert the commands into the appropriate  * format (if at all necessary). For example, UFI requires all commands to be  * 12 bytes in length amongst other things.  *  * The source code below is marked and can be split into a number of pieces  * (in this order):  *  * - probe/attach/detach  * - generic transfer routines  * - BBB  * - CBI  * - CBI_I (in addition to functions from CBI)  * - CAM (Common Access Method)  * - SCSI  * - UFI  * - 8070i (ATAPI)  *  * The protocols are implemented using a state machine, for the transfers as  * well as for the resets. The state machine is contained in umass_t_*_callback.  * The state machine is started through either umass_command_start() or  * umass_reset().  *  * The reason for doing this is a) CAM performs a lot better this way and b) it  * avoids using tsleep from interrupt context (for example after a failed  * transfer).  */
end_comment

begin_comment
comment|/*  * The SCSI related part of this driver has been derived from the  * dev/ppbus/vpo.c driver, by Nicolas Souchu (nsouch@FreeBSD.org).  *  * The CAM layer uses so called actions which are messages sent to the host  * adapter for completion. The actions come in through umass_cam_action. The  * appropriate block of routines is called depending on the transport protocol  * in use. When the transfer has finished, these routines call  * umass_cam_cb again to complete the CAM command.  */
end_comment

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_define
define|#
directive|define
name|UMASS_EXT_BUFFER
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|UMASS_EXT_BUFFER
end_ifdef

begin_comment
comment|/* this enables loading of virtual buffers into DMA */
end_comment

begin_define
define|#
directive|define
name|UMASS_USB_FLAGS
value|.ext_buffer=1,
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UMASS_USB_FLAGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_define
define|#
directive|define
name|DIF
parameter_list|(
name|m
parameter_list|,
name|x
parameter_list|)
define|\
value|do {						\     if (umass_debug& (m)) { x ; }		\   } while (0)
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {							\     if (umass_debug& (m)) {				\         printf("%s:%s: " fmt,				\ 	       (sc) ? (const char *)(sc)->sc_name :	\ 	       (const char *)"umassX",			\ 		__FUNCTION__ ,## __VA_ARGS__);		\     }							\   } while (0)
end_define

begin_define
define|#
directive|define
name|UDMASS_GEN
value|0x00010000
end_define

begin_comment
comment|/* general */
end_comment

begin_define
define|#
directive|define
name|UDMASS_SCSI
value|0x00020000
end_define

begin_comment
comment|/* scsi */
end_comment

begin_define
define|#
directive|define
name|UDMASS_UFI
value|0x00040000
end_define

begin_comment
comment|/* ufi command set */
end_comment

begin_define
define|#
directive|define
name|UDMASS_ATAPI
value|0x00080000
end_define

begin_comment
comment|/* 8070i command set */
end_comment

begin_define
define|#
directive|define
name|UDMASS_CMD
value|(UDMASS_SCSI|UDMASS_UFI|UDMASS_ATAPI)
end_define

begin_define
define|#
directive|define
name|UDMASS_USB
value|0x00100000
end_define

begin_comment
comment|/* USB general */
end_comment

begin_define
define|#
directive|define
name|UDMASS_BBB
value|0x00200000
end_define

begin_comment
comment|/* Bulk-Only transfers */
end_comment

begin_define
define|#
directive|define
name|UDMASS_CBI
value|0x00400000
end_define

begin_comment
comment|/* CBI transfers */
end_comment

begin_define
define|#
directive|define
name|UDMASS_WIRE
value|(UDMASS_BBB|UDMASS_CBI)
end_define

begin_define
define|#
directive|define
name|UDMASS_ALL
value|0xffff0000
end_define

begin_comment
comment|/* all of the above */
end_comment

begin_decl_stmt
specifier|static
name|int
name|umass_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|umass
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB umass"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_umass
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|umass_debug
argument_list|,
literal|0
argument_list|,
literal|"umass debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DIF
parameter_list|(
modifier|...
parameter_list|)
value|do { } while (0)
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
modifier|...
parameter_list|)
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UMASS_GONE
value|((struct umass_softc *)1)
end_define

begin_define
define|#
directive|define
name|UMASS_BULK_SIZE
value|(1<< 17)
end_define

begin_define
define|#
directive|define
name|UMASS_CBI_DIAGNOSTIC_CMDLEN
value|12
end_define

begin_comment
comment|/* bytes */
end_comment

begin_define
define|#
directive|define
name|UMASS_MAX_CMDLEN
value|MAX(12, CAM_MAX_CDBLEN)
end_define

begin_comment
comment|/* bytes */
end_comment

begin_comment
comment|/* USB transfer definitions */
end_comment

begin_define
define|#
directive|define
name|UMASS_T_BBB_RESET1
value|0
end_define

begin_comment
comment|/* Bulk-Only */
end_comment

begin_define
define|#
directive|define
name|UMASS_T_BBB_RESET2
value|1
end_define

begin_define
define|#
directive|define
name|UMASS_T_BBB_RESET3
value|2
end_define

begin_define
define|#
directive|define
name|UMASS_T_BBB_COMMAND
value|3
end_define

begin_define
define|#
directive|define
name|UMASS_T_BBB_DATA_READ
value|4
end_define

begin_define
define|#
directive|define
name|UMASS_T_BBB_DATA_RD_CS
value|5
end_define

begin_define
define|#
directive|define
name|UMASS_T_BBB_DATA_WRITE
value|6
end_define

begin_define
define|#
directive|define
name|UMASS_T_BBB_DATA_WR_CS
value|7
end_define

begin_define
define|#
directive|define
name|UMASS_T_BBB_STATUS
value|8
end_define

begin_define
define|#
directive|define
name|UMASS_T_BBB_MAX
value|9
end_define

begin_define
define|#
directive|define
name|UMASS_T_CBI_RESET1
value|0
end_define

begin_comment
comment|/* CBI */
end_comment

begin_define
define|#
directive|define
name|UMASS_T_CBI_RESET2
value|1
end_define

begin_define
define|#
directive|define
name|UMASS_T_CBI_RESET3
value|2
end_define

begin_define
define|#
directive|define
name|UMASS_T_CBI_COMMAND
value|3
end_define

begin_define
define|#
directive|define
name|UMASS_T_CBI_DATA_READ
value|4
end_define

begin_define
define|#
directive|define
name|UMASS_T_CBI_DATA_RD_CS
value|5
end_define

begin_define
define|#
directive|define
name|UMASS_T_CBI_DATA_WRITE
value|6
end_define

begin_define
define|#
directive|define
name|UMASS_T_CBI_DATA_WR_CS
value|7
end_define

begin_define
define|#
directive|define
name|UMASS_T_CBI_STATUS
value|8
end_define

begin_define
define|#
directive|define
name|UMASS_T_CBI_RESET4
value|9
end_define

begin_define
define|#
directive|define
name|UMASS_T_CBI_MAX
value|10
end_define

begin_define
define|#
directive|define
name|UMASS_T_MAX
value|MAX(UMASS_T_CBI_MAX, UMASS_T_BBB_MAX)
end_define

begin_comment
comment|/* Generic definitions */
end_comment

begin_comment
comment|/* Direction for transfer */
end_comment

begin_define
define|#
directive|define
name|DIR_NONE
value|0
end_define

begin_define
define|#
directive|define
name|DIR_IN
value|1
end_define

begin_define
define|#
directive|define
name|DIR_OUT
value|2
end_define

begin_comment
comment|/* device name */
end_comment

begin_define
define|#
directive|define
name|DEVNAME
value|"umass"
end_define

begin_define
define|#
directive|define
name|DEVNAME_SIM
value|"umass-sim"
end_define

begin_comment
comment|/* Approximate maximum transfer speeds (assumes 33% overhead). */
end_comment

begin_define
define|#
directive|define
name|UMASS_FULL_TRANSFER_SPEED
value|1000
end_define

begin_define
define|#
directive|define
name|UMASS_HIGH_TRANSFER_SPEED
value|40000
end_define

begin_define
define|#
directive|define
name|UMASS_FLOPPY_TRANSFER_SPEED
value|20
end_define

begin_define
define|#
directive|define
name|UMASS_TIMEOUT
value|5000
end_define

begin_comment
comment|/* ms */
end_comment

begin_comment
comment|/* CAM specific definitions */
end_comment

begin_define
define|#
directive|define
name|UMASS_SCSIID_MAX
value|1
end_define

begin_comment
comment|/* maximum number of drives expected */
end_comment

begin_define
define|#
directive|define
name|UMASS_SCSIID_HOST
value|UMASS_SCSIID_MAX
end_define

begin_comment
comment|/* Bulk-Only features */
end_comment

begin_define
define|#
directive|define
name|UR_BBB_RESET
value|0xff
end_define

begin_comment
comment|/* Bulk-Only reset */
end_comment

begin_define
define|#
directive|define
name|UR_BBB_GET_MAX_LUN
value|0xfe
end_define

begin_comment
comment|/* Get maximum lun */
end_comment

begin_comment
comment|/* Command Block Wrapper */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uDWord
name|dCBWSignature
decl_stmt|;
define|#
directive|define
name|CBWSIGNATURE
value|0x43425355
name|uDWord
name|dCBWTag
decl_stmt|;
name|uDWord
name|dCBWDataTransferLength
decl_stmt|;
name|uByte
name|bCBWFlags
decl_stmt|;
define|#
directive|define
name|CBWFLAGS_OUT
value|0x00
define|#
directive|define
name|CBWFLAGS_IN
value|0x80
name|uByte
name|bCBWLUN
decl_stmt|;
name|uByte
name|bCDBLength
decl_stmt|;
define|#
directive|define
name|CBWCDBLENGTH
value|16
name|uByte
name|CBWCDB
index|[
name|CBWCDBLENGTH
index|]
decl_stmt|;
block|}
name|__packed
name|umass_bbb_cbw_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|UMASS_BBB_CBW_SIZE
value|31
end_define

begin_comment
comment|/* Command Status Wrapper */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uDWord
name|dCSWSignature
decl_stmt|;
define|#
directive|define
name|CSWSIGNATURE
value|0x53425355
define|#
directive|define
name|CSWSIGNATURE_IMAGINATION_DBX1
value|0x43425355
define|#
directive|define
name|CSWSIGNATURE_OLYMPUS_C1
value|0x55425355
name|uDWord
name|dCSWTag
decl_stmt|;
name|uDWord
name|dCSWDataResidue
decl_stmt|;
name|uByte
name|bCSWStatus
decl_stmt|;
define|#
directive|define
name|CSWSTATUS_GOOD
value|0x0
define|#
directive|define
name|CSWSTATUS_FAILED
value|0x1
define|#
directive|define
name|CSWSTATUS_PHASE
value|0x2
block|}
name|__packed
name|umass_bbb_csw_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|UMASS_BBB_CSW_SIZE
value|13
end_define

begin_comment
comment|/* CBI features */
end_comment

begin_define
define|#
directive|define
name|UR_CBI_ADSC
value|0x00
end_define

begin_typedef
typedef|typedef
union|union
block|{
struct|struct
block|{
name|uint8_t
name|type
decl_stmt|;
define|#
directive|define
name|IDB_TYPE_CCI
value|0x00
name|uint8_t
name|value
decl_stmt|;
define|#
directive|define
name|IDB_VALUE_PASS
value|0x00
define|#
directive|define
name|IDB_VALUE_FAIL
value|0x01
define|#
directive|define
name|IDB_VALUE_PHASE
value|0x02
define|#
directive|define
name|IDB_VALUE_PERSISTENT
value|0x03
define|#
directive|define
name|IDB_VALUE_STATUS_MASK
value|0x03
block|}
name|__packed
name|common
struct|;
struct|struct
block|{
name|uint8_t
name|asc
decl_stmt|;
name|uint8_t
name|ascq
decl_stmt|;
block|}
name|__packed
name|ufi
struct|;
block|}
name|__packed
name|umass_cbi_sbl_t
typedef|;
end_typedef

begin_struct_decl
struct_decl|struct
name|umass_softc
struct_decl|;
end_struct_decl

begin_comment
comment|/* see below */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
name|umass_callback_t
function_decl|)
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint32_t
name|residue
parameter_list|,
name|uint8_t
name|status
parameter_list|)
function_decl|;
end_typedef

begin_define
define|#
directive|define
name|STATUS_CMD_OK
value|0
end_define

begin_comment
comment|/* everything ok */
end_comment

begin_define
define|#
directive|define
name|STATUS_CMD_UNKNOWN
value|1
end_define

begin_comment
comment|/* will have to fetch sense */
end_comment

begin_define
define|#
directive|define
name|STATUS_CMD_FAILED
value|2
end_define

begin_comment
comment|/* transfer was ok, command failed */
end_comment

begin_define
define|#
directive|define
name|STATUS_WIRE_FAILED
value|3
end_define

begin_comment
comment|/* couldn't even get command across */
end_comment

begin_typedef
typedef|typedef
name|uint8_t
function_decl|(
name|umass_transform_t
function_decl|)
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|cmd_ptr
parameter_list|,
name|uint8_t
name|cmd_len
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|umass_devdescr
block|{
name|uint32_t
name|vid
decl_stmt|;
define|#
directive|define
name|VID_WILDCARD
value|0xffffffff
define|#
directive|define
name|VID_EOT
value|0xfffffffe
name|uint32_t
name|pid
decl_stmt|;
define|#
directive|define
name|PID_WILDCARD
value|0xffffffff
define|#
directive|define
name|PID_EOT
value|0xfffffffe
name|uint32_t
name|rid
decl_stmt|;
define|#
directive|define
name|RID_WILDCARD
value|0xffffffff
define|#
directive|define
name|RID_EOT
value|0xfffffffe
comment|/* wire and command protocol */
name|uint16_t
name|proto
decl_stmt|;
define|#
directive|define
name|UMASS_PROTO_DEFAULT
value|0x0000
comment|/* use protocol indicated by USB descriptors */
define|#
directive|define
name|UMASS_PROTO_BBB
value|0x0001
comment|/* USB wire protocol */
define|#
directive|define
name|UMASS_PROTO_CBI
value|0x0002
define|#
directive|define
name|UMASS_PROTO_CBI_I
value|0x0004
define|#
directive|define
name|UMASS_PROTO_WIRE
value|0x00ff
comment|/* USB wire protocol mask */
define|#
directive|define
name|UMASS_PROTO_SCSI
value|0x0100
comment|/* command protocol */
define|#
directive|define
name|UMASS_PROTO_ATAPI
value|0x0200
define|#
directive|define
name|UMASS_PROTO_UFI
value|0x0400
define|#
directive|define
name|UMASS_PROTO_RBC
value|0x0800
define|#
directive|define
name|UMASS_PROTO_COMMAND
value|0xff00
comment|/* command protocol mask */
comment|/* Device specific quirks */
name|uint16_t
name|quirks
decl_stmt|;
define|#
directive|define
name|NO_QUIRKS
value|0x0000
comment|/* 	 * The drive does not support Test Unit Ready. Convert to Start Unit 	 */
define|#
directive|define
name|NO_TEST_UNIT_READY
value|0x0001
comment|/* 	 * The drive does not reset the Unit Attention state after REQUEST 	 * SENSE has been sent. The INQUIRY command does not reset the UA 	 * either, and so CAM runs in circles trying to retrieve the initial 	 * INQUIRY data. 	 */
define|#
directive|define
name|RS_NO_CLEAR_UA
value|0x0002
comment|/* The drive does not support START STOP.  */
define|#
directive|define
name|NO_START_STOP
value|0x0004
comment|/* Don't ask for full inquiry data (255b).  */
define|#
directive|define
name|FORCE_SHORT_INQUIRY
value|0x0008
comment|/* Needs to be initialised the Shuttle way */
define|#
directive|define
name|SHUTTLE_INIT
value|0x0010
comment|/* Drive needs to be switched to alternate iface 1 */
define|#
directive|define
name|ALT_IFACE_1
value|0x0020
comment|/* Drive does not do 1Mb/s, but just floppy speeds (20kb/s) */
define|#
directive|define
name|FLOPPY_SPEED
value|0x0040
comment|/* The device can't count and gets the residue of transfers wrong */
define|#
directive|define
name|IGNORE_RESIDUE
value|0x0080
comment|/* No GetMaxLun call */
define|#
directive|define
name|NO_GETMAXLUN
value|0x0100
comment|/* The device uses a weird CSWSIGNATURE. */
define|#
directive|define
name|WRONG_CSWSIG
value|0x0200
comment|/* Device cannot handle INQUIRY so fake a generic response */
define|#
directive|define
name|NO_INQUIRY
value|0x0400
comment|/* Device cannot handle INQUIRY EVPD, return CHECK CONDITION */
define|#
directive|define
name|NO_INQUIRY_EVPD
value|0x0800
comment|/* Pad all RBC requests to 12 bytes. */
define|#
directive|define
name|RBC_PAD_TO_12
value|0x1000
comment|/* 	 * Device reports number of sectors from READ_CAPACITY, not max 	 * sector number. 	 */
define|#
directive|define
name|READ_CAPACITY_OFFBY1
value|0x2000
comment|/* 	 * Device cannot handle a SCSI synchronize cache command.  Normally 	 * this quirk would be handled in the cam layer, but for IDE bridges 	 * we need to associate the quirk with the bridge and not the 	 * underlying disk device.  This is handled by faking a success 	 * result. 	 */
define|#
directive|define
name|NO_SYNCHRONIZE_CACHE
value|0x4000
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|umass_devdescr
name|umass_devdescr
index|[]
init|=
block|{
block|{
name|USB_VENDOR_ASAHIOPTICAL
block|,
name|PID_WILDCARD
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|RS_NO_CLEAR_UA
block|}
block|,
block|{
name|USB_VENDOR_ADDON
block|,
name|USB_PRODUCT_ADDON_ATTACHE
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_ADDON
block|,
name|USB_PRODUCT_ADDON_A256MB
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_ADDON
block|,
name|USB_PRODUCT_ADDON_DISKPRO512
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_ADDONICS2
block|,
name|USB_PRODUCT_ADDONICS2_CABLE_205
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_AIPTEK
block|,
name|USB_PRODUCT_AIPTEK_POCKETCAM3M
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_AIPTEK2
block|,
name|USB_PRODUCT_AIPTEK2_SUNPLUS_TECH
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_ALCOR
block|,
name|USB_PRODUCT_ALCOR_SDCR_6335
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|NO_TEST_UNIT_READY
operator||
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_ALCOR
block|,
name|USB_PRODUCT_ALCOR_AU6390
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_ALCOR
block|,
name|USB_PRODUCT_ALCOR_UMCR_9361
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_ALCOR
block|,
name|USB_PRODUCT_ALCOR_TRANSCEND
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_ASAHIOPTICAL
block|,
name|USB_PRODUCT_ASAHIOPTICAL_OPTIO230
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_ASAHIOPTICAL
block|,
name|USB_PRODUCT_ASAHIOPTICAL_OPTIO330
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_BELKIN
block|,
name|USB_PRODUCT_BELKIN_USB2SCSI
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_CASIO
block|,
name|USB_PRODUCT_CASIO_QV_DIGICAM
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_CCYU
block|,
name|USB_PRODUCT_CCYU_ED1064
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_CENTURY
block|,
name|USB_PRODUCT_CENTURY_EX35QUAT
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|FORCE_SHORT_INQUIRY
operator||
name|NO_START_STOP
operator||
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_CYPRESS
block|,
name|USB_PRODUCT_CYPRESS_XX6830XX
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|NO_GETMAXLUN
operator||
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_DESKNOTE
block|,
name|USB_PRODUCT_DESKNOTE_UCR_61S2B
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_DMI
block|,
name|USB_PRODUCT_DMI_CFSM_RW
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_EPSON
block|,
name|USB_PRODUCT_EPSON_STYLUS_875DC
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_EPSON
block|,
name|USB_PRODUCT_EPSON_STYLUS_895
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_FEIYA
block|,
name|USB_PRODUCT_FEIYA_5IN1
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_FREECOM
block|,
name|USB_PRODUCT_FREECOM_DVD
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_FUJIPHOTO
block|,
name|USB_PRODUCT_FUJIPHOTO_MASS0100
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_CBI_I
block|,
name|RS_NO_CLEAR_UA
block|}
block|,
block|{
name|USB_VENDOR_GENESYS
block|,
name|USB_PRODUCT_GENESYS_GL641USB2IDE
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|FORCE_SHORT_INQUIRY
operator||
name|NO_START_STOP
operator||
name|IGNORE_RESIDUE
operator||
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_GENESYS
block|,
name|USB_PRODUCT_GENESYS_GL641USB2IDE_2
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_BBB
block|,
name|FORCE_SHORT_INQUIRY
operator||
name|NO_START_STOP
operator||
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_GENESYS
block|,
name|USB_PRODUCT_GENESYS_GL641USB
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|FORCE_SHORT_INQUIRY
operator||
name|NO_START_STOP
operator||
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_GENESYS
block|,
name|USB_PRODUCT_GENESYS_GL641USB_2
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|WRONG_CSWSIG
block|}
block|,
block|{
name|USB_VENDOR_HAGIWARA
block|,
name|USB_PRODUCT_HAGIWARA_FG
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_HAGIWARA
block|,
name|USB_PRODUCT_HAGIWARA_FGSM
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_HITACHI
block|,
name|USB_PRODUCT_HITACHI_DVDCAM_DZ_MV100A
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_HITACHI
block|,
name|USB_PRODUCT_HITACHI_DVDCAM_USB
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_CBI_I
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_HP
block|,
name|USB_PRODUCT_HP_CDW4E
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_HP
block|,
name|USB_PRODUCT_HP_CDW8200
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_CBI_I
block|,
name|NO_TEST_UNIT_READY
operator||
name|NO_START_STOP
block|}
block|,
block|{
name|USB_VENDOR_IMAGINATION
block|,
name|USB_PRODUCT_IMAGINATION_DBX1
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|WRONG_CSWSIG
block|}
block|,
block|{
name|USB_VENDOR_INSYSTEM
block|,
name|USB_PRODUCT_INSYSTEM_USBCABLE
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_TEST_UNIT_READY
operator||
name|NO_START_STOP
operator||
name|ALT_IFACE_1
block|}
block|,
block|{
name|USB_VENDOR_INSYSTEM
block|,
name|USB_PRODUCT_INSYSTEM_ATAPI
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_RBC
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_INSYSTEM
block|,
name|USB_PRODUCT_INSYSTEM_STORAGE_V2
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_RBC
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_IODATA
block|,
name|USB_PRODUCT_IODATA_IU_CD2
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_IODATA
block|,
name|USB_PRODUCT_IODATA_DVR_UEH8
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_IOMEGA
block|,
name|USB_PRODUCT_IOMEGA_ZIP100
block|,
name|RID_WILDCARD
block|,
comment|/* 		 * XXX This is not correct as there are Zip drives that use 		 * ATAPI. 		 */
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_TEST_UNIT_READY
block|}
block|,
block|{
name|USB_VENDOR_KYOCERA
block|,
name|USB_PRODUCT_KYOCERA_FINECAM_L3
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_KYOCERA
block|,
name|USB_PRODUCT_KYOCERA_FINECAM_S3X
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_KYOCERA
block|,
name|USB_PRODUCT_KYOCERA_FINECAM_S4
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_KYOCERA
block|,
name|USB_PRODUCT_KYOCERA_FINECAM_S5
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_LACIE
block|,
name|USB_PRODUCT_LACIE_HD
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_RBC
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_LEXAR
block|,
name|USB_PRODUCT_LEXAR_CF_READER
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_LEXAR
block|,
name|USB_PRODUCT_LEXAR_JUMPSHOT
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_LOGITEC
block|,
name|USB_PRODUCT_LOGITEC_LDR_H443SU2
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_LOGITEC
block|,
name|USB_PRODUCT_LOGITEC_LDR_H443U2
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_MELCO
block|,
name|USB_PRODUCT_MELCO_DUBPXXG
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|FORCE_SHORT_INQUIRY
operator||
name|NO_START_STOP
operator||
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_MICROTECH
block|,
name|USB_PRODUCT_MICROTECH_DPCM
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_TEST_UNIT_READY
operator||
name|NO_START_STOP
block|}
block|,
block|{
name|USB_VENDOR_MICROTECH
block|,
name|USB_PRODUCT_MICROTECH_SCSIDB25
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_MICROTECH
block|,
name|USB_PRODUCT_MICROTECH_SCSIHD50
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_MINOLTA
block|,
name|USB_PRODUCT_MINOLTA_E223
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_MINOLTA
block|,
name|USB_PRODUCT_MINOLTA_F300
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_MITSUMI
block|,
name|USB_PRODUCT_MITSUMI_CDRRW
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_MITSUMI
block|,
name|USB_PRODUCT_MITSUMI_FDD
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_MOTOROLA2
block|,
name|USB_PRODUCT_MOTOROLA2_E398
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|FORCE_SHORT_INQUIRY
operator||
name|NO_INQUIRY_EVPD
operator||
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_MPMAN
block|,
name|PID_WILDCARD
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_MSYSTEMS
block|,
name|USB_PRODUCT_MSYSTEMS_DISKONKEY
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|IGNORE_RESIDUE
operator||
name|NO_GETMAXLUN
operator||
name|RS_NO_CLEAR_UA
block|}
block|,
block|{
name|USB_VENDOR_MSYSTEMS
block|,
name|USB_PRODUCT_MSYSTEMS_DISKONKEY2
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_MYSON
block|,
name|USB_PRODUCT_MYSON_HEDEN
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|IGNORE_RESIDUE
operator||
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_MYSON
block|,
name|USB_PRODUCT_MYSON_HEDEN_8813
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_MYSON
block|,
name|USB_PRODUCT_MYSON_STARREADER
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_NEODIO
block|,
name|USB_PRODUCT_NEODIO_ND3260
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|FORCE_SHORT_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_NETAC
block|,
name|USB_PRODUCT_NETAC_CF_CARD
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_NETAC
block|,
name|USB_PRODUCT_NETAC_ONLYDISK
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_NETCHIP
block|,
name|USB_PRODUCT_NETCHIP_CLIK_40
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_NIKON
block|,
name|USB_PRODUCT_NIKON_D300
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_OLYMPUS
block|,
name|USB_PRODUCT_OLYMPUS_C1
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|WRONG_CSWSIG
block|}
block|,
block|{
name|USB_VENDOR_OLYMPUS
block|,
name|USB_PRODUCT_OLYMPUS_C700
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_ONSPEC
block|,
name|USB_PRODUCT_ONSPEC_SDS_HOTFIND_D
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_GETMAXLUN
operator||
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_ONSPEC
block|,
name|USB_PRODUCT_ONSPEC_CFMS_RW
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_ONSPEC
block|,
name|USB_PRODUCT_ONSPEC_CFSM_COMBO
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_ONSPEC
block|,
name|USB_PRODUCT_ONSPEC_CFSM_READER
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_ONSPEC
block|,
name|USB_PRODUCT_ONSPEC_CFSM_READER2
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_ONSPEC
block|,
name|USB_PRODUCT_ONSPEC_MDCFE_B_CF_READER
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_ONSPEC
block|,
name|USB_PRODUCT_ONSPEC_MDSM_B_READER
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_ONSPEC
block|,
name|USB_PRODUCT_ONSPEC_READER
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_ONSPEC
block|,
name|USB_PRODUCT_ONSPEC_UCF100
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
operator||
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_ONSPEC2
block|,
name|USB_PRODUCT_ONSPEC2_IMAGEMATE_SDDR55
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_PANASONIC
block|,
name|USB_PRODUCT_PANASONIC_KXL840AN
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_PANASONIC
block|,
name|USB_PRODUCT_PANASONIC_KXLCB20AN
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_PANASONIC
block|,
name|USB_PRODUCT_PANASONIC_KXLCB35AN
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_PANASONIC
block|,
name|USB_PRODUCT_PANASONIC_LS120CAM
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_UFI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_PHILIPS
block|,
name|USB_PRODUCT_PHILIPS_SPE3030CC
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_PLEXTOR
block|,
name|USB_PRODUCT_PLEXTOR_40_12_40U
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_TEST_UNIT_READY
block|}
block|,
block|{
name|USB_VENDOR_PNY
block|,
name|USB_PRODUCT_PNY_ATTACHE2
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|IGNORE_RESIDUE
operator||
name|NO_START_STOP
block|}
block|,
block|{
name|USB_VENDOR_SAMSUNG_TECHWIN
block|,
name|USB_PRODUCT_SAMSUNG_TECHWIN_DIGIMAX_410
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_SANDISK
block|,
name|USB_PRODUCT_SANDISK_SDDR05A
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_CBI
block|,
name|READ_CAPACITY_OFFBY1
operator||
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_SANDISK
block|,
name|USB_PRODUCT_SANDISK_SDDR09
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|READ_CAPACITY_OFFBY1
operator||
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_SANDISK
block|,
name|USB_PRODUCT_SANDISK_SDDR12
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_CBI
block|,
name|READ_CAPACITY_OFFBY1
operator||
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_SANDISK
block|,
name|USB_PRODUCT_SANDISK_SDCZ2_256
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_SANDISK
block|,
name|USB_PRODUCT_SANDISK_SDCZ4_128
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_SANDISK
block|,
name|USB_PRODUCT_SANDISK_SDCZ4_256
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_SANDISK
block|,
name|USB_PRODUCT_SANDISK_SDDR31
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|READ_CAPACITY_OFFBY1
block|}
block|,
block|{
name|USB_VENDOR_SCANLOGIC
block|,
name|USB_PRODUCT_SCANLOGIC_SL11R
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_SHUTTLE
block|,
name|USB_PRODUCT_SHUTTLE_EUSB
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_CBI_I
block|,
name|NO_TEST_UNIT_READY
operator||
name|NO_START_STOP
operator||
name|SHUTTLE_INIT
block|}
block|,
block|{
name|USB_VENDOR_SHUTTLE
block|,
name|USB_PRODUCT_SHUTTLE_CDRW
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_SHUTTLE
block|,
name|USB_PRODUCT_SHUTTLE_CF
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_SHUTTLE
block|,
name|USB_PRODUCT_SHUTTLE_EUSBATAPI
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_SHUTTLE
block|,
name|USB_PRODUCT_SHUTTLE_EUSBCFSM
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_SHUTTLE
block|,
name|USB_PRODUCT_SHUTTLE_EUSCSI
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_SHUTTLE
block|,
name|USB_PRODUCT_SHUTTLE_HIFD
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_SHUTTLE
block|,
name|USB_PRODUCT_SHUTTLE_SDDR09
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_SHUTTLE
block|,
name|USB_PRODUCT_SHUTTLE_ZIOMMC
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_SIGMATEL
block|,
name|USB_PRODUCT_SIGMATEL_I_BEAD100
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|SHUTTLE_INIT
block|}
block|,
block|{
name|USB_VENDOR_SIIG
block|,
name|USB_PRODUCT_SIIG_WINTERREADER
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_SKANHEX
block|,
name|USB_PRODUCT_SKANHEX_MD_7425
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_SKANHEX
block|,
name|USB_PRODUCT_SKANHEX_SX_520Z
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_SONY
block|,
name|USB_PRODUCT_SONY_HANDYCAM
block|,
literal|0x0500
block|,
name|UMASS_PROTO_RBC
operator||
name|UMASS_PROTO_CBI
block|,
name|RBC_PAD_TO_12
block|}
block|,
block|{
name|USB_VENDOR_SONY
block|,
name|USB_PRODUCT_SONY_CLIE_40_MS
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_SONY
block|,
name|USB_PRODUCT_SONY_DSC
block|,
literal|0x0500
block|,
name|UMASS_PROTO_RBC
operator||
name|UMASS_PROTO_CBI
block|,
name|RBC_PAD_TO_12
block|}
block|,
block|{
name|USB_VENDOR_SONY
block|,
name|USB_PRODUCT_SONY_DSC
block|,
literal|0x0600
block|,
name|UMASS_PROTO_RBC
operator||
name|UMASS_PROTO_CBI
block|,
name|RBC_PAD_TO_12
block|}
block|,
block|{
name|USB_VENDOR_SONY
block|,
name|USB_PRODUCT_SONY_DSC
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_RBC
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_SONY
block|,
name|USB_PRODUCT_SONY_HANDYCAM
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_RBC
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_SONY
block|,
name|USB_PRODUCT_SONY_MSC
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_RBC
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_SONY
block|,
name|USB_PRODUCT_SONY_MS_MSC_U03
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_UFI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_SONY
block|,
name|USB_PRODUCT_SONY_MS_NW_MS7
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_SONY
block|,
name|USB_PRODUCT_SONY_MS_PEG_N760C
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_SONY
block|,
name|USB_PRODUCT_SONY_MSACUS1
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_SONY
block|,
name|USB_PRODUCT_SONY_PORTABLE_HDD_V2
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_SUPERTOP
block|,
name|USB_PRODUCT_SUPERTOP_IDE
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|IGNORE_RESIDUE
operator||
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_TAUGA
block|,
name|USB_PRODUCT_TAUGA_CAMERAMATE
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_TEAC
block|,
name|USB_PRODUCT_TEAC_FD05PUB
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_UFI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_TECLAST
block|,
name|USB_PRODUCT_TECLAST_TLC300
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|NO_TEST_UNIT_READY
operator||
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_TREK
block|,
name|USB_PRODUCT_TREK_MEMKEY
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_TREK
block|,
name|USB_PRODUCT_TREK_THUMBDRIVE_8MB
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_BBB
block|,
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_TRUMPION
block|,
name|USB_PRODUCT_TRUMPION_C3310
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_UFI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_TRUMPION
block|,
name|USB_PRODUCT_TRUMPION_MP3
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_RBC
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_TRUMPION
block|,
name|USB_PRODUCT_TRUMPION_T33520
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_TWINMOS
block|,
name|USB_PRODUCT_TWINMOS_MDIV
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_VIA
block|,
name|USB_PRODUCT_VIA_USB2IDEBRIDGE
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_VIVITAR
block|,
name|USB_PRODUCT_VIVITAR_35XX
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_WESTERN
block|,
name|USB_PRODUCT_WESTERN_COMBO
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|FORCE_SHORT_INQUIRY
operator||
name|NO_START_STOP
operator||
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_WESTERN
block|,
name|USB_PRODUCT_WESTERN_EXTHDD
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|FORCE_SHORT_INQUIRY
operator||
name|NO_START_STOP
operator||
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_WESTERN
block|,
name|USB_PRODUCT_WESTERN_MYBOOK
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY_EVPD
block|}
block|,
block|{
name|USB_VENDOR_WESTERN
block|,
name|USB_PRODUCT_WESTERN_MYPASSWORD
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|FORCE_SHORT_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_WINMAXGROUP
block|,
name|USB_PRODUCT_WINMAXGROUP_FLASH64MC
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_YANO
block|,
name|USB_PRODUCT_YANO_FW800HD
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|FORCE_SHORT_INQUIRY
operator||
name|NO_START_STOP
operator||
name|IGNORE_RESIDUE
block|}
block|,
block|{
name|USB_VENDOR_YANO
block|,
name|USB_PRODUCT_YANO_U640MO
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_CBI_I
block|,
name|FORCE_SHORT_INQUIRY
block|}
block|,
block|{
name|USB_VENDOR_YEDATA
block|,
name|USB_PRODUCT_YEDATA_FLASHBUSTERU
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_GETMAXLUN
block|}
block|,
block|{
name|USB_VENDOR_ZORAN
block|,
name|USB_PRODUCT_ZORAN_EX20DSC
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_ATAPI
operator||
name|UMASS_PROTO_CBI
block|,
name|NO_QUIRKS
block|}
block|,
block|{
name|USB_VENDOR_MEIZU
block|,
name|USB_PRODUCT_MEIZU_M6_SL
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_INQUIRY
operator||
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_ACTIONS
block|,
name|USB_PRODUCT_ACTIONS_MP4
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_SCSI
operator||
name|UMASS_PROTO_BBB
block|,
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|USB_VENDOR_ASUS
block|,
name|USB_PRODUCT_ASUS_GMSC
block|,
name|RID_WILDCARD
block|,
name|UMASS_PROTO_DEFAULT
block|,
name|NO_SYNCHRONIZE_CACHE
block|}
block|,
block|{
name|VID_EOT
block|,
name|PID_EOT
block|,
name|RID_EOT
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|umass_softc
block|{
name|struct
name|scsi_sense
name|cam_scsi_sense
decl_stmt|;
name|struct
name|scsi_test_unit_ready
name|cam_scsi_test_unit_ready
decl_stmt|;
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
struct|struct
block|{
name|uint8_t
modifier|*
name|data_ptr
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|umass_callback_t
modifier|*
name|callback
decl_stmt|;
name|uint32_t
name|data_len
decl_stmt|;
comment|/* bytes */
name|uint32_t
name|data_rem
decl_stmt|;
comment|/* bytes */
name|uint32_t
name|data_timeout
decl_stmt|;
comment|/* ms */
name|uint32_t
name|actlen
decl_stmt|;
comment|/* bytes */
name|uint8_t
name|cmd_data
index|[
name|UMASS_MAX_CMDLEN
index|]
decl_stmt|;
name|uint8_t
name|cmd_len
decl_stmt|;
comment|/* bytes */
name|uint8_t
name|dir
decl_stmt|;
name|uint8_t
name|lun
decl_stmt|;
block|}
name|sc_transfer
struct|;
comment|/* Bulk specific variables for transfers in progress */
name|umass_bbb_cbw_t
name|cbw
decl_stmt|;
comment|/* command block wrapper */
name|umass_bbb_csw_t
name|csw
decl_stmt|;
comment|/* command status wrapper */
comment|/* CBI specific variables for transfers in progress */
name|umass_cbi_sbl_t
name|sbl
decl_stmt|;
comment|/* status block */
name|device_t
name|sc_dev
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|sc_udev
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sc_sim
decl_stmt|;
comment|/* SCSI Interface Module */
name|struct
name|usb_xfer
modifier|*
name|sc_xfer
index|[
name|UMASS_T_MAX
index|]
decl_stmt|;
comment|/* 	 * The command transform function is used to convert the SCSI 	 * commands into their derivatives, like UFI, ATAPI, and friends. 	 */
name|umass_transform_t
modifier|*
name|sc_transform
decl_stmt|;
name|uint32_t
name|sc_unit
decl_stmt|;
name|uint16_t
name|sc_proto
decl_stmt|;
comment|/* wire and cmd protocol */
name|uint16_t
name|sc_quirks
decl_stmt|;
comment|/* they got it almost right */
name|uint8_t
name|sc_name
index|[
literal|16
index|]
decl_stmt|;
name|uint8_t
name|sc_iface_no
decl_stmt|;
comment|/* interface number */
name|uint8_t
name|sc_maxlun
decl_stmt|;
comment|/* maximum LUN number, inclusive */
name|uint8_t
name|sc_last_xfer_index
decl_stmt|;
name|uint8_t
name|sc_status_try
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|umass_probe_proto
block|{
name|uint16_t
name|quirks
decl_stmt|;
name|uint16_t
name|proto
decl_stmt|;
name|int32_t
name|error
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* prototypes */
end_comment

begin_decl_stmt
specifier|static
name|device_probe_t
name|umass_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|umass_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|umass_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_tr_error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_bbb_reset1_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_bbb_reset2_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_bbb_reset3_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_bbb_command_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_bbb_data_read_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_bbb_data_rd_cs_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_bbb_data_write_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_bbb_data_wr_cs_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_bbb_status_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_cbi_reset1_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_cbi_reset2_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_cbi_reset3_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_cbi_reset4_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_cbi_command_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_cbi_data_read_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_cbi_data_rd_cs_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_cbi_data_write_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_cbi_data_wr_cs_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umass_t_cbi_status_callback
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|umass_cancel_ccb
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_init_shuttle
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_reset
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_t_bbb_data_clear_stall_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|usb_error_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_command_start
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|umass_callback_t
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|umass_bbb_get_max_lun
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_cbi_start_status
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_t_cbi_data_clear_stall_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|usb_error_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umass_cam_attach_sim
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_cam_rescan_callback
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_cam_rescan
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_cam_attach
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_cam_detach_sim
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_cam_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_cam_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_cam_cb
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_cam_sense_cb
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_cam_quirk_cb
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|umass_scsi_transform
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|umass_rbc_transform
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|umass_ufi_transform
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|umass_atapi_transform
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|umass_no_transform
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|umass_std_transform
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_function_decl
specifier|static
name|void
name|umass_bbb_dump_cbw
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|,
name|umass_bbb_cbw_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_bbb_dump_csw
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|,
name|umass_bbb_csw_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_cbi_dump_cmd
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umass_dump_buffer
parameter_list|(
name|struct
name|umass_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|usb_config
name|umass_bbb_config
index|[
name|UMASS_T_BBB_MAX
index|]
init|=
block|{
index|[
name|UMASS_T_BBB_RESET1
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_bbb_reset1_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
operator|.
name|interval
operator|=
literal|500
block|,
comment|/* 500 milliseconds */
block|}
block|,
index|[
name|UMASS_T_BBB_RESET2
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_bbb_reset2_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
operator|.
name|interval
operator|=
literal|50
block|,
comment|/* 50 milliseconds */
block|}
block|,
index|[
name|UMASS_T_BBB_RESET3
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_bbb_reset3_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
operator|.
name|interval
operator|=
literal|50
block|,
comment|/* 50 milliseconds */
block|}
block|,
index|[
name|UMASS_T_BBB_COMMAND
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
name|umass_bbb_cbw_t
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_bbb_command_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
block|}
block|,
index|[
name|UMASS_T_BBB_DATA_READ
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
name|UMASS_BULK_SIZE
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|proxy_buffer
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,
name|UMASS_USB_FLAGS
block|}
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_bbb_data_read_callback
block|,
operator|.
name|timeout
operator|=
literal|0
block|,
comment|/* overwritten later */
block|}
block|,
index|[
name|UMASS_T_BBB_DATA_RD_CS
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_bbb_data_rd_cs_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
block|}
block|,
index|[
name|UMASS_T_BBB_DATA_WRITE
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
name|UMASS_BULK_SIZE
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|proxy_buffer
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,
name|UMASS_USB_FLAGS
block|}
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_bbb_data_write_callback
block|,
operator|.
name|timeout
operator|=
literal|0
block|,
comment|/* overwritten later */
block|}
block|,
index|[
name|UMASS_T_BBB_DATA_WR_CS
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_bbb_data_wr_cs_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
block|}
block|,
index|[
name|UMASS_T_BBB_STATUS
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
name|umass_bbb_csw_t
argument_list|)
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_bbb_status_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* ms */
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|usb_config
name|umass_cbi_config
index|[
name|UMASS_T_CBI_MAX
index|]
init|=
block|{
index|[
name|UMASS_T_CBI_RESET1
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
operator|+
name|UMASS_CBI_DIAGNOSTIC_CMDLEN
operator|)
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_cbi_reset1_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
operator|.
name|interval
operator|=
literal|500
block|,
comment|/* 500 milliseconds */
block|}
block|,
index|[
name|UMASS_T_CBI_RESET2
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_cbi_reset2_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
operator|.
name|interval
operator|=
literal|50
block|,
comment|/* 50 milliseconds */
block|}
block|,
index|[
name|UMASS_T_CBI_RESET3
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_cbi_reset3_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
operator|.
name|interval
operator|=
literal|50
block|,
comment|/* 50 milliseconds */
block|}
block|,
index|[
name|UMASS_T_CBI_COMMAND
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
operator|+
name|UMASS_MAX_CMDLEN
operator|)
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_cbi_command_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
block|}
block|,
index|[
name|UMASS_T_CBI_DATA_READ
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
name|UMASS_BULK_SIZE
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|proxy_buffer
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,
name|UMASS_USB_FLAGS
block|}
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_cbi_data_read_callback
block|,
operator|.
name|timeout
operator|=
literal|0
block|,
comment|/* overwritten later */
block|}
block|,
index|[
name|UMASS_T_CBI_DATA_RD_CS
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_cbi_data_rd_cs_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
block|}
block|,
index|[
name|UMASS_T_CBI_DATA_WRITE
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
name|UMASS_BULK_SIZE
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|proxy_buffer
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,
name|UMASS_USB_FLAGS
block|}
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_cbi_data_write_callback
block|,
operator|.
name|timeout
operator|=
literal|0
block|,
comment|/* overwritten later */
block|}
block|,
index|[
name|UMASS_T_CBI_DATA_WR_CS
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_cbi_data_wr_cs_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
block|}
block|,
index|[
name|UMASS_T_CBI_STATUS
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_INTERRUPT
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
name|umass_cbi_sbl_t
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_cbi_status_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* ms */
block|}
block|,
index|[
name|UMASS_T_CBI_RESET4
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|umass_t_cbi_reset4_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* ms */
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If device cannot return valid inquiry data, fake it */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|fake_inq_data
index|[
name|SHORT_INQUIRY_LENGTH
index|]
init|=
block|{
literal|0
block|,
comment|/* removable */
literal|0x80
block|,
name|SCSI_REV_2
block|,
name|SCSI_REV_2
block|,
comment|/* additional_length */
literal|31
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UFI_COMMAND_LENGTH
value|12
end_define

begin_comment
comment|/* UFI commands are always 12 bytes */
end_comment

begin_define
define|#
directive|define
name|ATAPI_COMMAND_LENGTH
value|12
end_define

begin_comment
comment|/* ATAPI commands are always 12 bytes */
end_comment

begin_decl_stmt
specifier|static
name|devclass_t
name|umass_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|umass_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|umass_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|umass_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|umass_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|umass_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"umass"
block|,
operator|.
name|methods
operator|=
name|umass_methods
block|,
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|umass_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|umass
argument_list|,
name|uhub
argument_list|,
name|umass_driver
argument_list|,
name|umass_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|umass
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|umass
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * USB device probe/attach/detach  */
end_comment

begin_function
specifier|static
name|uint16_t
name|umass_get_proto
parameter_list|(
name|struct
name|usb_interface
modifier|*
name|iface
parameter_list|)
block|{
name|struct
name|usb_interface_descriptor
modifier|*
name|id
decl_stmt|;
name|uint16_t
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* Check for a standards compliant device */
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|==
name|NULL
operator|)
operator|||
operator|(
name|id
operator|->
name|bInterfaceClass
operator|!=
name|UICLASS_MASS
operator|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|id
operator|->
name|bInterfaceSubClass
condition|)
block|{
case|case
name|UISUBCLASS_SCSI
case|:
name|retval
operator||=
name|UMASS_PROTO_SCSI
expr_stmt|;
break|break;
case|case
name|UISUBCLASS_UFI
case|:
name|retval
operator||=
name|UMASS_PROTO_UFI
expr_stmt|;
break|break;
case|case
name|UISUBCLASS_RBC
case|:
name|retval
operator||=
name|UMASS_PROTO_RBC
expr_stmt|;
break|break;
case|case
name|UISUBCLASS_SFF8020I
case|:
case|case
name|UISUBCLASS_SFF8070I
case|:
name|retval
operator||=
name|UMASS_PROTO_ATAPI
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|id
operator|->
name|bInterfaceProtocol
condition|)
block|{
case|case
name|UIPROTO_MASS_CBI
case|:
name|retval
operator||=
name|UMASS_PROTO_CBI
expr_stmt|;
break|break;
case|case
name|UIPROTO_MASS_CBI_I
case|:
name|retval
operator||=
name|UMASS_PROTO_CBI_I
expr_stmt|;
break|break;
case|case
name|UIPROTO_MASS_BBB_OLD
case|:
case|case
name|UIPROTO_MASS_BBB
case|:
name|retval
operator||=
name|UMASS_PROTO_BBB
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|done
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Match the device we are seeing with the  * devices supported.  */
end_comment

begin_function
specifier|static
name|struct
name|umass_probe_proto
name|umass_probe_proto
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|usb_attach_arg
modifier|*
name|uaa
parameter_list|)
block|{
specifier|const
name|struct
name|umass_devdescr
modifier|*
name|udd
init|=
name|umass_devdescr
decl_stmt|;
name|struct
name|umass_probe_proto
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * An entry specifically for Y-E Data devices as they don't fit in 	 * the device description table. 	 */
if|if
condition|(
operator|(
name|uaa
operator|->
name|info
operator|.
name|idVendor
operator|==
name|USB_VENDOR_YEDATA
operator|)
operator|&&
operator|(
name|uaa
operator|->
name|info
operator|.
name|idProduct
operator|==
name|USB_PRODUCT_YEDATA_FLASHBUSTERU
operator|)
condition|)
block|{
comment|/* 		 * Revisions< 1.28 do not handle the interrupt endpoint 		 * very well. 		 */
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bcdDevice
operator|<
literal|0x128
condition|)
block|{
name|ret
operator|.
name|proto
operator|=
name|UMASS_PROTO_UFI
operator||
name|UMASS_PROTO_CBI
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|proto
operator|=
name|UMASS_PROTO_UFI
operator||
name|UMASS_PROTO_CBI_I
expr_stmt|;
block|}
comment|/* 		 * Revisions< 1.28 do not have the TEST UNIT READY command 		 * Revisions == 1.28 have a broken TEST UNIT READY 		 */
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bcdDevice
operator|<=
literal|0x128
condition|)
block|{
name|ret
operator|.
name|quirks
operator||=
name|NO_TEST_UNIT_READY
expr_stmt|;
block|}
name|ret
operator|.
name|quirks
operator||=
name|RS_NO_CLEAR_UA
operator||
name|FLOPPY_SPEED
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Check the list of supported devices for a match. While looking, 	 * check for wildcarded and fully matched. First match wins. 	 */
for|for
control|(
init|;
name|udd
operator|->
name|vid
operator|!=
name|VID_EOT
condition|;
name|udd
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|udd
operator|->
name|vid
operator|==
name|uaa
operator|->
name|info
operator|.
name|idVendor
operator|)
operator|||
operator|(
name|udd
operator|->
name|vid
operator|==
name|VID_WILDCARD
operator|)
operator|)
operator|&&
operator|(
operator|(
name|udd
operator|->
name|pid
operator|==
name|uaa
operator|->
name|info
operator|.
name|idProduct
operator|)
operator|||
operator|(
name|udd
operator|->
name|pid
operator|==
name|PID_WILDCARD
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|udd
operator|->
name|rid
operator|==
name|RID_WILDCARD
condition|)
block|{
name|ret
operator|.
name|proto
operator|=
name|udd
operator|->
name|proto
expr_stmt|;
name|ret
operator|.
name|quirks
operator|=
name|udd
operator|->
name|quirks
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|proto
operator|==
name|UMASS_PROTO_DEFAULT
condition|)
goto|goto
name|default_proto
goto|;
else|else
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|udd
operator|->
name|rid
operator|==
name|uaa
operator|->
name|info
operator|.
name|bcdDevice
condition|)
block|{
name|ret
operator|.
name|proto
operator|=
name|udd
operator|->
name|proto
expr_stmt|;
name|ret
operator|.
name|quirks
operator|=
name|udd
operator|->
name|quirks
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|proto
operator|==
name|UMASS_PROTO_DEFAULT
condition|)
goto|goto
name|default_proto
goto|;
else|else
goto|goto
name|done
goto|;
block|}
comment|/* else RID does not match */
block|}
block|}
name|default_proto
label|:
name|ret
operator|.
name|proto
operator|=
name|umass_get_proto
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|proto
operator|==
literal|0
condition|)
name|ret
operator|.
name|error
operator|=
name|ENXIO
expr_stmt|;
else|else
name|ret
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|done
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|umass_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|umass_probe_proto
name|temp
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|uaa
operator|->
name|use_generic
operator|==
literal|0
condition|)
block|{
comment|/* give other drivers a try first */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|temp
operator|=
name|umass_probe_proto
argument_list|(
name|dev
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|.
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|umass_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|umass_probe_proto
name|temp
init|=
name|umass_probe_proto
argument_list|(
name|dev
argument_list|,
name|uaa
argument_list|)
decl_stmt|;
name|struct
name|usb_interface_descriptor
modifier|*
name|id
decl_stmt|;
name|int32_t
name|err
decl_stmt|;
comment|/* 	 * NOTE: the softc struct is bzero-ed in device_set_driver. 	 * We can safely call umass_detach without specifically 	 * initializing the struct. 	 */
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
name|sc
operator|->
name|sc_proto
operator|=
name|temp
operator|.
name|proto
expr_stmt|;
name|sc
operator|->
name|sc_quirks
operator|=
name|temp
operator|.
name|quirks
expr_stmt|;
name|sc
operator|->
name|sc_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|sc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_name
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
comment|/* get interface index */
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to get "
literal|"interface number\n"
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|sc
operator|->
name|sc_iface_no
operator|=
name|id
operator|->
name|bInterfaceNumber
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_proto
operator|&
name|UMASS_PROTO_COMMAND
condition|)
block|{
case|case
name|UMASS_PROTO_SCSI
case|:
name|printf
argument_list|(
literal|"SCSI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMASS_PROTO_ATAPI
case|:
name|printf
argument_list|(
literal|"8070i (ATAPI)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMASS_PROTO_UFI
case|:
name|printf
argument_list|(
literal|"UFI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMASS_PROTO_RBC
case|:
name|printf
argument_list|(
literal|"RBC"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"(unknown 0x%02x)"
argument_list|,
name|sc
operator|->
name|sc_proto
operator|&
name|UMASS_PROTO_COMMAND
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|" over "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_proto
operator|&
name|UMASS_PROTO_WIRE
condition|)
block|{
case|case
name|UMASS_PROTO_BBB
case|:
name|printf
argument_list|(
literal|"Bulk-Only"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMASS_PROTO_CBI
case|:
comment|/* uses Comand/Bulk pipes */
name|printf
argument_list|(
literal|"CBI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMASS_PROTO_CBI_I
case|:
comment|/* uses Comand/Bulk/Interrupt pipes */
name|printf
argument_list|(
literal|"CBI with CCI"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"(unknown 0x%02x)"
argument_list|,
name|sc
operator|->
name|sc_proto
operator|&
name|UMASS_PROTO_WIRE
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"; quirks = 0x%04x\n"
argument_list|,
name|sc
operator|->
name|sc_quirks
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_quirks
operator|&
name|ALT_IFACE_1
condition|)
block|{
name|err
operator|=
name|usbd_set_alt_interface_index
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_USB
argument_list|,
literal|"could not switch to "
literal|"Alt Interface 1\n"
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
block|}
comment|/* allocate all required USB transfers */
if|if
condition|(
name|sc
operator|->
name|sc_proto
operator|&
name|UMASS_PROTO_BBB
condition|)
block|{
name|err
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|,
name|sc
operator|->
name|sc_xfer
argument_list|,
name|umass_bbb_config
argument_list|,
name|UMASS_T_BBB_MAX
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
comment|/* skip reset first time */
name|sc
operator|->
name|sc_last_xfer_index
operator|=
name|UMASS_T_BBB_COMMAND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_proto
operator|&
operator|(
name|UMASS_PROTO_CBI
operator||
name|UMASS_PROTO_CBI_I
operator|)
condition|)
block|{
name|err
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|,
name|sc
operator|->
name|sc_xfer
argument_list|,
name|umass_cbi_config
argument_list|,
operator|(
name|sc
operator|->
name|sc_proto
operator|&
name|UMASS_PROTO_CBI_I
operator|)
condition|?
name|UMASS_T_CBI_MAX
else|:
operator|(
name|UMASS_T_CBI_MAX
operator|-
literal|2
operator|)
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
comment|/* skip reset first time */
name|sc
operator|->
name|sc_last_xfer_index
operator|=
name|UMASS_T_CBI_COMMAND
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup required "
literal|"transfers, %s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|sc
operator|->
name|sc_transform
operator|=
operator|(
name|sc
operator|->
name|sc_proto
operator|&
name|UMASS_PROTO_SCSI
operator|)
condition|?
operator|&
name|umass_scsi_transform
else|:
operator|(
name|sc
operator|->
name|sc_proto
operator|&
name|UMASS_PROTO_UFI
operator|)
condition|?
operator|&
name|umass_ufi_transform
else|:
operator|(
name|sc
operator|->
name|sc_proto
operator|&
name|UMASS_PROTO_ATAPI
operator|)
condition|?
operator|&
name|umass_atapi_transform
else|:
operator|(
name|sc
operator|->
name|sc_proto
operator|&
name|UMASS_PROTO_RBC
operator|)
condition|?
operator|&
name|umass_rbc_transform
else|:
operator|&
name|umass_no_transform
expr_stmt|;
comment|/* from here onwards the device can be used. */
if|if
condition|(
name|sc
operator|->
name|sc_quirks
operator|&
name|SHUTTLE_INIT
condition|)
block|{
name|umass_init_shuttle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* get the maximum LUN supported by the device */
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|sc_proto
operator|&
name|UMASS_PROTO_WIRE
operator|)
operator|==
name|UMASS_PROTO_BBB
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_quirks
operator|&
name|NO_GETMAXLUN
operator|)
condition|)
name|sc
operator|->
name|sc_maxlun
operator|=
name|umass_bbb_get_max_lun
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|sc_maxlun
operator|=
literal|0
expr_stmt|;
comment|/* Prepare the SCSI command block */
name|sc
operator|->
name|cam_scsi_sense
operator|.
name|opcode
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|sc
operator|->
name|cam_scsi_test_unit_ready
operator|.
name|opcode
operator|=
name|TEST_UNIT_READY
expr_stmt|;
comment|/* 	 * some devices need a delay after that the configuration value is 	 * set to function properly: 	 */
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* register the SIM */
name|err
operator|=
name|umass_cam_attach_sim
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|detach
goto|;
block|}
comment|/* scan the SIM */
name|umass_cam_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_GEN
argument_list|,
literal|"Attach finished\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
name|detach
label|:
name|umass_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* failure */
block|}
end_function

begin_function
specifier|static
name|int
name|umass_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_USB
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* teardown our statemachine */
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|UMASS_T_MAX
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|700037
operator|)
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|umass_cam_detach_sim
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|700037
operator|)
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|void
name|umass_init_shuttle
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|uint8_t
name|status
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/* 	 * The Linux driver does this, but no one can tell us what the 	 * command does. 	 */
name|req
operator|.
name|bmRequestType
operator|=
name|UT_READ_VENDOR_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
literal|1
expr_stmt|;
comment|/* XXX unknown command */
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|wIndex
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_iface_no
expr_stmt|;
name|req
operator|.
name|wIndex
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_do_request
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|NULL
argument_list|,
operator|&
name|req
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_GEN
argument_list|,
literal|"Shuttle init returned 0x%02x%02x\n"
argument_list|,
name|status
index|[
literal|0
index|]
argument_list|,
name|status
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generic functions to handle transfers  */
end_comment

begin_function
specifier|static
name|void
name|umass_transfer_start
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|xfer_index
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_GEN
argument_list|,
literal|"transfer index = "
literal|"%d\n"
argument_list|,
name|xfer_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_xfer
index|[
name|xfer_index
index|]
condition|)
block|{
name|sc
operator|->
name|sc_last_xfer_index
operator|=
name|xfer_index
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|xfer_index
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|umass_cancel_ccb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umass_reset
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_GEN
argument_list|,
literal|"resetting device\n"
argument_list|)
expr_stmt|;
comment|/* 	 * stop the last transfer, if not already stopped: 	 */
name|usbd_transfer_stop
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|sc
operator|->
name|sc_last_xfer_index
index|]
argument_list|)
expr_stmt|;
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_cancel_ccb
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|sc
operator|->
name|sc_transfer
operator|.
name|ccb
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|ccb
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_last_xfer_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ccb
condition|)
block|{
call|(
name|sc
operator|->
name|sc_transfer
operator|.
name|callback
call|)
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|,
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_len
operator|-
name|sc
operator|->
name|sc_transfer
operator|.
name|actlen
operator|)
argument_list|,
name|STATUS_WIRE_FAILED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umass_tr_error
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_GEN
argument_list|,
literal|"transfer error, %s -> "
literal|"reset\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|umass_cancel_ccb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * BBB protocol specific functions  */
end_comment

begin_function
specifier|static
name|void
name|umass_t_bbb_reset1_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
name|UMASS_T_BBB_RESET2
argument_list|)
expr_stmt|;
return|return;
case|case
name|USB_ST_SETUP
case|:
comment|/* 		 * Reset recovery (5.3.4 in Universal Serial Bus Mass Storage Class) 		 * 		 * For Reset Recovery the host shall issue in the following order: 		 * a) a Bulk-Only Mass Storage Reset 		 * b) a Clear Feature HALT to the Bulk-In endpoint 		 * c) a Clear Feature HALT to the Bulk-Out endpoint 		 * 		 * This is done in 3 steps, using 3 transfers: 		 * UMASS_T_BBB_RESET1 		 * UMASS_T_BBB_RESET2 		 * UMASS_T_BBB_RESET3 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"BBB reset!\n"
argument_list|)
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_CLASS_INTERFACE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_BBB_RESET
expr_stmt|;
comment|/* bulk only reset */
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|wIndex
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_iface_no
expr_stmt|;
name|req
operator|.
name|wIndex
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frames
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Error */
name|umass_tr_error
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_bbb_reset2_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umass_t_bbb_data_clear_stall_callback
argument_list|(
name|xfer
argument_list|,
name|UMASS_T_BBB_RESET3
argument_list|,
name|UMASS_T_BBB_DATA_READ
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_bbb_reset3_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umass_t_bbb_data_clear_stall_callback
argument_list|(
name|xfer
argument_list|,
name|UMASS_T_BBB_COMMAND
argument_list|,
name|UMASS_T_BBB_DATA_WRITE
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_bbb_data_clear_stall_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|uint8_t
name|next_xfer
parameter_list|,
name|uint8_t
name|stall_xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|tr_transferred
label|:
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
name|next_xfer
argument_list|)
expr_stmt|;
return|return;
case|case
name|USB_ST_SETUP
case|:
if|if
condition|(
name|usbd_clear_stall_callback
argument_list|(
name|xfer
argument_list|,
name|sc
operator|->
name|sc_xfer
index|[
name|stall_xfer
index|]
argument_list|)
condition|)
block|{
goto|goto
name|tr_transferred
goto|;
block|}
return|return;
default|default:
comment|/* Error */
name|umass_tr_error
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_bbb_command_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|ccb
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint32_t
name|tag
decl_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|dir
operator|==
name|DIR_IN
operator|)
condition|?
name|UMASS_T_BBB_DATA_READ
else|:
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|dir
operator|==
name|DIR_OUT
operator|)
condition|?
name|UMASS_T_BBB_DATA_WRITE
else|:
name|UMASS_T_BBB_STATUS
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|USB_ST_SETUP
case|:
name|sc
operator|->
name|sc_status_try
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ccb
condition|)
block|{
comment|/* 		         * the initial value is not important, 		         * as long as the values are unique: 		         */
name|tag
operator|=
name|UGETDW
argument_list|(
name|sc
operator|->
name|cbw
operator|.
name|dCBWTag
argument_list|)
operator|+
literal|1
expr_stmt|;
name|USETDW
argument_list|(
name|sc
operator|->
name|cbw
operator|.
name|dCBWSignature
argument_list|,
name|CBWSIGNATURE
argument_list|)
expr_stmt|;
name|USETDW
argument_list|(
name|sc
operator|->
name|cbw
operator|.
name|dCBWTag
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* 		         * dCBWDataTransferLength: 		         *   This field indicates the number of bytes of data that the host 		         *   intends to transfer on the IN or OUT Bulk endpoint(as indicated by 		         *   the Direction bit) during the execution of this command. If this 		         *   field is set to 0, the device will expect that no data will be 		         *   transferred IN or OUT during this command, regardless of the value 		         *   of the Direction bit defined in dCBWFlags. 		         */
name|USETDW
argument_list|(
name|sc
operator|->
name|cbw
operator|.
name|dCBWDataTransferLength
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_len
argument_list|)
expr_stmt|;
comment|/* 		         * dCBWFlags: 		         *   The bits of the Flags field are defined as follows: 		         *     Bits 0-6  reserved 		         *     Bit  7    Direction - this bit shall be ignored if the 		         *                           dCBWDataTransferLength field is zero. 		         *               0 = data Out from host to device 		         *               1 = data In from device to host 		         */
name|sc
operator|->
name|cbw
operator|.
name|bCBWFlags
operator|=
operator|(
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|dir
operator|==
name|DIR_IN
operator|)
condition|?
name|CBWFLAGS_IN
else|:
name|CBWFLAGS_OUT
operator|)
expr_stmt|;
name|sc
operator|->
name|cbw
operator|.
name|bCBWLUN
operator|=
name|sc
operator|->
name|sc_transfer
operator|.
name|lun
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cbw
operator|.
name|CBWCDB
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cbw
operator|.
name|CBWCDB
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"Truncating long command!\n"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|cbw
operator|.
name|bCDBLength
operator|=
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|,
name|sc
operator|->
name|cbw
operator|.
name|CBWCDB
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
operator|+
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cbw
operator|.
name|CBWCDB
argument_list|)
operator|-
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
argument_list|)
expr_stmt|;
name|DIF
argument_list|(
name|UDMASS_BBB
argument_list|,
name|umass_bbb_dump_cbw
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|cbw
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|cbw
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cbw
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cbw
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
comment|/* Error */
name|umass_tr_error
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_bbb_data_read_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|uint32_t
name|max_bulk
init|=
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|UMASS_EXT_BUFFER
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
endif|#
directive|endif
name|int
name|actlen
decl_stmt|,
name|sumlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
operator|&
name|sumlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
ifndef|#
directive|ifndef
name|UMASS_EXT_BUFFER
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|-=
name|actlen
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
operator|+=
name|actlen
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|actlen
operator|+=
name|actlen
expr_stmt|;
if|if
condition|(
name|actlen
operator|<
name|sumlen
condition|)
block|{
comment|/* short transfer */
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|=
literal|0
expr_stmt|;
block|}
case|case
name|USB_ST_SETUP
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"max_bulk=%d, data_rem=%d\n"
argument_list|,
name|max_bulk
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|==
literal|0
condition|)
block|{
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
name|UMASS_T_BBB_STATUS
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|max_bulk
operator|>
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
condition|)
block|{
name|max_bulk
operator|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
expr_stmt|;
block|}
name|usbd_xfer_set_timeout
argument_list|(
name|xfer
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_timeout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMASS_EXT_BUFFER
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
else|#
directive|else
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Error */
if|if
condition|(
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
name|umass_tr_error
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
name|UMASS_T_BBB_DATA_RD_CS
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_bbb_data_rd_cs_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umass_t_bbb_data_clear_stall_callback
argument_list|(
name|xfer
argument_list|,
name|UMASS_T_BBB_STATUS
argument_list|,
name|UMASS_T_BBB_DATA_READ
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_bbb_data_write_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|uint32_t
name|max_bulk
init|=
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|UMASS_EXT_BUFFER
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
endif|#
directive|endif
name|int
name|actlen
decl_stmt|,
name|sumlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
operator|&
name|sumlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|-=
name|actlen
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
operator|+=
name|actlen
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|actlen
operator|+=
name|actlen
expr_stmt|;
if|if
condition|(
name|actlen
operator|<
name|sumlen
condition|)
block|{
comment|/* short transfer */
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|=
literal|0
expr_stmt|;
block|}
case|case
name|USB_ST_SETUP
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"max_bulk=%d, data_rem=%d\n"
argument_list|,
name|max_bulk
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|==
literal|0
condition|)
block|{
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
name|UMASS_T_BBB_STATUS
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|max_bulk
operator|>
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
condition|)
block|{
name|max_bulk
operator|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
expr_stmt|;
block|}
name|usbd_xfer_set_timeout
argument_list|(
name|xfer
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_timeout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMASS_EXT_BUFFER
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
else|#
directive|else
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Error */
if|if
condition|(
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
name|umass_tr_error
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
name|UMASS_T_BBB_DATA_WR_CS
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_bbb_data_wr_cs_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umass_t_bbb_data_clear_stall_callback
argument_list|(
name|xfer
argument_list|,
name|UMASS_T_BBB_STATUS
argument_list|,
name|UMASS_T_BBB_DATA_WRITE
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_bbb_status_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|ccb
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint32_t
name|residue
decl_stmt|;
name|int
name|actlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
comment|/* 		 * Do a full reset if there is something wrong with the CSW: 		 */
name|sc
operator|->
name|sc_status_try
operator|=
literal|1
expr_stmt|;
comment|/* Zero missing parts of the CSW: */
if|if
condition|(
name|actlen
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|csw
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|csw
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|csw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|csw
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
name|DIF
argument_list|(
name|UDMASS_BBB
argument_list|,
name|umass_bbb_dump_csw
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|csw
argument_list|)
argument_list|)
expr_stmt|;
name|residue
operator|=
name|UGETDW
argument_list|(
name|sc
operator|->
name|csw
operator|.
name|dCSWDataResidue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|residue
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_quirks
operator|&
name|IGNORE_RESIDUE
operator|)
condition|)
block|{
name|residue
operator|=
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_len
operator|-
name|sc
operator|->
name|sc_transfer
operator|.
name|actlen
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|residue
operator|>
name|sc
operator|->
name|sc_transfer
operator|.
name|data_len
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"truncating residue from %d "
literal|"to %d bytes\n"
argument_list|,
name|residue
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_len
argument_list|)
expr_stmt|;
name|residue
operator|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_len
expr_stmt|;
block|}
comment|/* translate weird command-status signatures: */
if|if
condition|(
name|sc
operator|->
name|sc_quirks
operator|&
name|WRONG_CSWSIG
condition|)
block|{
name|uint32_t
name|temp
init|=
name|UGETDW
argument_list|(
name|sc
operator|->
name|csw
operator|.
name|dCSWSignature
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|temp
operator|==
name|CSWSIGNATURE_OLYMPUS_C1
operator|)
operator|||
operator|(
name|temp
operator|==
name|CSWSIGNATURE_IMAGINATION_DBX1
operator|)
condition|)
block|{
name|USETDW
argument_list|(
name|sc
operator|->
name|csw
operator|.
name|dCSWSignature
argument_list|,
name|CSWSIGNATURE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check CSW and handle eventual error */
if|if
condition|(
name|UGETDW
argument_list|(
name|sc
operator|->
name|csw
operator|.
name|dCSWSignature
argument_list|)
operator|!=
name|CSWSIGNATURE
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"bad CSW signature 0x%08x != 0x%08x\n"
argument_list|,
name|UGETDW
argument_list|(
name|sc
operator|->
name|csw
operator|.
name|dCSWSignature
argument_list|)
argument_list|,
name|CSWSIGNATURE
argument_list|)
expr_stmt|;
comment|/* 			 * Invalid CSW: Wrong signature or wrong tag might 			 * indicate that we lost synchronization. Reset the 			 * device. 			 */
goto|goto
name|tr_error
goto|;
block|}
elseif|else
if|if
condition|(
name|UGETDW
argument_list|(
name|sc
operator|->
name|csw
operator|.
name|dCSWTag
argument_list|)
operator|!=
name|UGETDW
argument_list|(
name|sc
operator|->
name|cbw
operator|.
name|dCBWTag
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"Invalid CSW: tag 0x%08x should be "
literal|"0x%08x\n"
argument_list|,
name|UGETDW
argument_list|(
name|sc
operator|->
name|csw
operator|.
name|dCSWTag
argument_list|)
argument_list|,
name|UGETDW
argument_list|(
name|sc
operator|->
name|cbw
operator|.
name|dCBWTag
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|tr_error
goto|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|csw
operator|.
name|bCSWStatus
operator|>
name|CSWSTATUS_PHASE
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"Invalid CSW: status %d> %d\n"
argument_list|,
name|sc
operator|->
name|csw
operator|.
name|bCSWStatus
argument_list|,
name|CSWSTATUS_PHASE
argument_list|)
expr_stmt|;
goto|goto
name|tr_error
goto|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|csw
operator|.
name|bCSWStatus
operator|==
name|CSWSTATUS_PHASE
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"Phase error, residue = "
literal|"%d\n"
argument_list|,
name|residue
argument_list|)
expr_stmt|;
goto|goto
name|tr_error
goto|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|actlen
operator|>
name|sc
operator|->
name|sc_transfer
operator|.
name|data_len
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"Buffer overrun %d> %d\n"
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|actlen
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_len
argument_list|)
expr_stmt|;
goto|goto
name|tr_error
goto|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|csw
operator|.
name|bCSWStatus
operator|==
name|CSWSTATUS_FAILED
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"Command failed, residue = "
literal|"%d\n"
argument_list|,
name|residue
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|ccb
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_last_xfer_index
operator|=
name|UMASS_T_BBB_COMMAND
expr_stmt|;
call|(
name|sc
operator|->
name|sc_transfer
operator|.
name|callback
call|)
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|,
name|residue
argument_list|,
name|STATUS_CMD_FAILED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_transfer
operator|.
name|ccb
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_last_xfer_index
operator|=
name|UMASS_T_BBB_COMMAND
expr_stmt|;
call|(
name|sc
operator|->
name|sc_transfer
operator|.
name|callback
call|)
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|,
name|residue
argument_list|,
name|STATUS_CMD_OK
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|USB_ST_SETUP
case|:
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
default|default:
name|tr_error
label|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"Failed to read CSW: %s, try %d\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_status_try
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|USB_ERR_CANCELLED
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_status_try
operator|)
condition|)
block|{
name|umass_tr_error
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_status_try
operator|=
literal|1
expr_stmt|;
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
name|UMASS_T_BBB_DATA_RD_CS
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umass_command_start
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|dir
parameter_list|,
name|void
modifier|*
name|data_ptr
parameter_list|,
name|uint32_t
name|data_len
parameter_list|,
name|uint32_t
name|data_timeout
parameter_list|,
name|umass_callback_t
modifier|*
name|callback
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|sc
operator|->
name|sc_transfer
operator|.
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
comment|/* 	 * NOTE: assumes that "sc->sc_transfer.cmd_data" and 	 * "sc->sc_transfer.cmd_len" has been properly 	 * initialized. 	 */
name|sc
operator|->
name|sc_transfer
operator|.
name|dir
operator|=
name|data_len
condition|?
name|dir
else|:
name|DIR_NONE
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
operator|=
name|data_ptr
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_len
operator|=
name|data_len
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|=
name|data_len
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_timeout
operator|=
operator|(
name|data_timeout
operator|+
name|UMASS_TIMEOUT
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|actlen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|ccb
operator|=
name|ccb
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_xfer
index|[
name|sc
operator|->
name|sc_last_xfer_index
index|]
condition|)
block|{
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|sc
operator|->
name|sc_last_xfer_index
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|umass_bbb_get_max_lun
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|uint8_t
name|buf
init|=
literal|0
decl_stmt|;
comment|/* The Get Max Lun command is a class-specific request. */
name|req
operator|.
name|bmRequestType
operator|=
name|UT_READ_CLASS_INTERFACE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_BBB_GET_MAX_LUN
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|wIndex
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_iface_no
expr_stmt|;
name|req
operator|.
name|wIndex
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_do_request
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|NULL
argument_list|,
operator|&
name|req
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|buf
operator|=
literal|0
expr_stmt|;
comment|/* Device doesn't support Get Max Lun request. */
name|printf
argument_list|(
literal|"%s: Get Max Lun not supported (%s)\n"
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Command/Bulk/Interrupt (CBI) specific functions  */
end_comment

begin_function
specifier|static
name|void
name|umass_cbi_start_status
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_xfer
index|[
name|UMASS_T_CBI_STATUS
index|]
condition|)
block|{
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
name|UMASS_T_CBI_STATUS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|ccb
decl_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|ccb
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_last_xfer_index
operator|=
name|UMASS_T_CBI_COMMAND
expr_stmt|;
call|(
name|sc
operator|->
name|sc_transfer
operator|.
name|callback
call|)
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|,
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_len
operator|-
name|sc
operator|->
name|sc_transfer
operator|.
name|actlen
operator|)
argument_list|,
name|STATUS_CMD_UNKNOWN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_cbi_reset1_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint8_t
name|buf
index|[
name|UMASS_CBI_DIAGNOSTIC_CMDLEN
index|]
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
name|UMASS_T_CBI_RESET2
argument_list|)
expr_stmt|;
return|return;
case|case
name|USB_ST_SETUP
case|:
comment|/* 		 * Command Block Reset Protocol 		 * 		 * First send a reset request to the device. Then clear 		 * any possibly stalled bulk endpoints. 		 * 		 * This is done in 3 steps, using 3 transfers: 		 * UMASS_T_CBI_RESET1 		 * UMASS_T_CBI_RESET2 		 * UMASS_T_CBI_RESET3 		 * UMASS_T_CBI_RESET4 (only if there is an interrupt endpoint) 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_CBI
argument_list|,
literal|"CBI reset!\n"
argument_list|)
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_CLASS_INTERFACE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_CBI_ADSC
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|wIndex
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_iface_no
expr_stmt|;
name|req
operator|.
name|wIndex
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|UMASS_CBI_DIAGNOSTIC_CMDLEN
argument_list|)
expr_stmt|;
comment|/* 		 * The 0x1d code is the SEND DIAGNOSTIC command. To 		 * distinguish between the two, the last 10 bytes of the CBL 		 * is filled with 0xff (section 2.2 of the CBI 		 * specification) 		 */
name|buf
index|[
literal|0
index|]
operator|=
literal|0x1d
expr_stmt|;
comment|/* Command Block Reset */
name|buf
index|[
literal|1
index|]
operator|=
literal|0x04
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|UMASS_CBI_DIAGNOSTIC_CMDLEN
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
block|}
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frames
argument_list|(
name|xfer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Error */
name|umass_tr_error
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_cbi_reset2_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umass_t_cbi_data_clear_stall_callback
argument_list|(
name|xfer
argument_list|,
name|UMASS_T_CBI_RESET3
argument_list|,
name|UMASS_T_CBI_DATA_READ
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_cbi_reset3_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|umass_t_cbi_data_clear_stall_callback
argument_list|(
name|xfer
argument_list|,
operator|(
name|sc
operator|->
name|sc_xfer
index|[
name|UMASS_T_CBI_RESET4
index|]
operator|&&
name|sc
operator|->
name|sc_xfer
index|[
name|UMASS_T_CBI_STATUS
index|]
operator|)
condition|?
name|UMASS_T_CBI_RESET4
else|:
name|UMASS_T_CBI_COMMAND
argument_list|,
name|UMASS_T_CBI_DATA_WRITE
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_cbi_reset4_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umass_t_cbi_data_clear_stall_callback
argument_list|(
name|xfer
argument_list|,
name|UMASS_T_CBI_COMMAND
argument_list|,
name|UMASS_T_CBI_STATUS
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_cbi_data_clear_stall_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|uint8_t
name|next_xfer
parameter_list|,
name|uint8_t
name|stall_xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|tr_transferred
label|:
if|if
condition|(
name|next_xfer
operator|==
name|UMASS_T_CBI_STATUS
condition|)
block|{
name|umass_cbi_start_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
name|next_xfer
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|USB_ST_SETUP
case|:
if|if
condition|(
name|usbd_clear_stall_callback
argument_list|(
name|xfer
argument_list|,
name|sc
operator|->
name|sc_xfer
index|[
name|stall_xfer
index|]
argument_list|)
condition|)
block|{
goto|goto
name|tr_transferred
goto|;
comment|/* should not happen */
block|}
return|return;
default|default:
comment|/* Error */
name|umass_tr_error
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_cbi_command_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|ccb
decl_stmt|;
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|dir
operator|==
name|DIR_NONE
condition|)
block|{
name|umass_cbi_start_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|dir
operator|==
name|DIR_IN
operator|)
condition|?
name|UMASS_T_CBI_DATA_READ
else|:
name|UMASS_T_CBI_DATA_WRITE
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|USB_ST_SETUP
case|:
if|if
condition|(
name|ccb
condition|)
block|{
comment|/* 		         * do a CBI transfer with cmd_len bytes from 		         * cmd_data, possibly a data phase of data_len 		         * bytes from/to the device and finally a status 		         * read phase. 		         */
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_CLASS_INTERFACE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_CBI_ADSC
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|wIndex
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_iface_no
expr_stmt|;
name|req
operator|.
name|wIndex
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|wLength
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
expr_stmt|;
name|req
operator|.
name|wLength
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frames
argument_list|(
name|xfer
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
name|DIF
argument_list|(
name|UDMASS_CBI
argument_list|,
name|umass_cbi_dump_cmd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
comment|/* Error */
name|umass_tr_error
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_cbi_data_read_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|uint32_t
name|max_bulk
init|=
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|UMASS_EXT_BUFFER
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
endif|#
directive|endif
name|int
name|actlen
decl_stmt|,
name|sumlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
operator|&
name|sumlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
ifndef|#
directive|ifndef
name|UMASS_EXT_BUFFER
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|-=
name|actlen
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
operator|+=
name|actlen
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|actlen
operator|+=
name|actlen
expr_stmt|;
if|if
condition|(
name|actlen
operator|<
name|sumlen
condition|)
block|{
comment|/* short transfer */
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|=
literal|0
expr_stmt|;
block|}
case|case
name|USB_ST_SETUP
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_CBI
argument_list|,
literal|"max_bulk=%d, data_rem=%d\n"
argument_list|,
name|max_bulk
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|==
literal|0
condition|)
block|{
name|umass_cbi_start_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|max_bulk
operator|>
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
condition|)
block|{
name|max_bulk
operator|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
expr_stmt|;
block|}
name|usbd_xfer_set_timeout
argument_list|(
name|xfer
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_timeout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMASS_EXT_BUFFER
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
else|#
directive|else
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Error */
if|if
condition|(
operator|(
name|error
operator|==
name|USB_ERR_CANCELLED
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|callback
operator|!=
operator|&
name|umass_cam_cb
operator|)
condition|)
block|{
name|umass_tr_error
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
name|UMASS_T_CBI_DATA_RD_CS
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_cbi_data_rd_cs_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umass_t_cbi_data_clear_stall_callback
argument_list|(
name|xfer
argument_list|,
name|UMASS_T_CBI_STATUS
argument_list|,
name|UMASS_T_CBI_DATA_READ
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_cbi_data_write_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|uint32_t
name|max_bulk
init|=
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|UMASS_EXT_BUFFER
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
endif|#
directive|endif
name|int
name|actlen
decl_stmt|,
name|sumlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
operator|&
name|sumlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|-=
name|actlen
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
operator|+=
name|actlen
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|actlen
operator|+=
name|actlen
expr_stmt|;
if|if
condition|(
name|actlen
operator|<
name|sumlen
condition|)
block|{
comment|/* short transfer */
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|=
literal|0
expr_stmt|;
block|}
case|case
name|USB_ST_SETUP
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_CBI
argument_list|,
literal|"max_bulk=%d, data_rem=%d\n"
argument_list|,
name|max_bulk
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|==
literal|0
condition|)
block|{
name|umass_cbi_start_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|max_bulk
operator|>
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
condition|)
block|{
name|max_bulk
operator|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
expr_stmt|;
block|}
name|usbd_xfer_set_timeout
argument_list|(
name|xfer
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_timeout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMASS_EXT_BUFFER
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
else|#
directive|else
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Error */
if|if
condition|(
operator|(
name|error
operator|==
name|USB_ERR_CANCELLED
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|callback
operator|!=
operator|&
name|umass_cam_cb
operator|)
condition|)
block|{
name|umass_tr_error
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|umass_transfer_start
argument_list|(
name|sc
argument_list|,
name|UMASS_T_CBI_DATA_WR_CS
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_cbi_data_wr_cs_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|umass_t_cbi_data_clear_stall_callback
argument_list|(
name|xfer
argument_list|,
name|UMASS_T_CBI_STATUS
argument_list|,
name|UMASS_T_CBI_DATA_WRITE
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_t_cbi_status_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|ccb
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint32_t
name|residue
decl_stmt|;
name|uint8_t
name|status
decl_stmt|;
name|int
name|actlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
if|if
condition|(
name|actlen
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sbl
argument_list|)
condition|)
block|{
goto|goto
name|tr_setup
goto|;
block|}
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sbl
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sbl
argument_list|)
argument_list|)
expr_stmt|;
name|residue
operator|=
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_len
operator|-
name|sc
operator|->
name|sc_transfer
operator|.
name|actlen
operator|)
expr_stmt|;
comment|/* dissect the information in the buffer */
if|if
condition|(
name|sc
operator|->
name|sc_proto
operator|&
name|UMASS_PROTO_UFI
condition|)
block|{
comment|/* 			 * Section 3.4.3.1.3 specifies that the UFI command 			 * protocol returns an ASC and ASCQ in the interrupt 			 * data block. 			 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_CBI
argument_list|,
literal|"UFI CCI, ASC = 0x%02x, "
literal|"ASCQ = 0x%02x\n"
argument_list|,
name|sc
operator|->
name|sbl
operator|.
name|ufi
operator|.
name|asc
argument_list|,
name|sc
operator|->
name|sbl
operator|.
name|ufi
operator|.
name|ascq
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
operator|(
operator|(
name|sc
operator|->
name|sbl
operator|.
name|ufi
operator|.
name|asc
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sbl
operator|.
name|ufi
operator|.
name|ascq
operator|==
literal|0
operator|)
operator|)
condition|?
name|STATUS_CMD_OK
else|:
name|STATUS_CMD_FAILED
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|ccb
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_last_xfer_index
operator|=
name|UMASS_T_CBI_COMMAND
expr_stmt|;
call|(
name|sc
operator|->
name|sc_transfer
operator|.
name|callback
call|)
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|,
name|residue
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Command Interrupt Data Block */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_CBI
argument_list|,
literal|"type=0x%02x, value=0x%02x\n"
argument_list|,
name|sc
operator|->
name|sbl
operator|.
name|common
operator|.
name|type
argument_list|,
name|sc
operator|->
name|sbl
operator|.
name|common
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sbl
operator|.
name|common
operator|.
name|type
operator|==
name|IDB_TYPE_CCI
condition|)
block|{
name|status
operator|=
operator|(
name|sc
operator|->
name|sbl
operator|.
name|common
operator|.
name|value
operator|&
name|IDB_VALUE_STATUS_MASK
operator|)
expr_stmt|;
name|status
operator|=
operator|(
operator|(
name|status
operator|==
name|IDB_VALUE_PASS
operator|)
condition|?
name|STATUS_CMD_OK
else|:
operator|(
name|status
operator|==
name|IDB_VALUE_FAIL
operator|)
condition|?
name|STATUS_CMD_FAILED
else|:
operator|(
name|status
operator|==
name|IDB_VALUE_PERSISTENT
operator|)
condition|?
name|STATUS_CMD_FAILED
else|:
name|STATUS_WIRE_FAILED
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|ccb
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_last_xfer_index
operator|=
name|UMASS_T_CBI_COMMAND
expr_stmt|;
call|(
name|sc
operator|->
name|sc_transfer
operator|.
name|callback
call|)
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|,
name|residue
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* fallthrough */
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Error */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_CBI
argument_list|,
literal|"Failed to read CSW: %s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|umass_tr_error
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * CAM specific functions (used by SCSI, UFI, 8070i (ATAPI))  */
end_comment

begin_function
specifier|static
name|int
name|umass_cam_attach_sim
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
comment|/* Per device Queue */
comment|/* 	 * A HBA is attached to the CAM layer. 	 * 	 * The CAM layer will then after a while start probing for devices on 	 * the bus. The number of SIMs is limited to one. 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
literal|1
comment|/* maximum openings */
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sc
operator|->
name|sc_sim
operator|=
name|cam_sim_alloc
argument_list|(
operator|&
name|umass_cam_action
argument_list|,
operator|&
name|umass_cam_poll
argument_list|,
name|DEVNAME_SIM
argument_list|,
name|sc
comment|/* priv */
argument_list|,
name|sc
operator|->
name|sc_unit
comment|/* unit number */
argument_list|,
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|700037
operator|)
operator|&
name|sc
operator|->
name|sc_mtx
comment|/* mutex */
argument_list|,
endif|#
directive|endif
literal|1
comment|/* maximum device openings */
argument_list|,
literal|0
comment|/* maximum tagged device openings */
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|700037
operator|)
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|700048
operator|)
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|700037
operator|)
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
endif|#
directive|endif
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|700037
operator|)
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_cam_rescan_callback
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|#
directive|if
name|USB_DEBUG
name|struct
name|umass_softc
modifier|*
name|sc
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"%s:%d Rescan failed, 0x%04x\n"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"%s%d: Rescan succeeded\n"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|xpt_free_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ccb
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_cam_rescan
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"scbus%d: scanning for %d:%d:%d\n"
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ccb
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|700037
operator|)
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|700037
operator|)
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|ccb
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|path
argument_list|,
literal|5
comment|/* priority (low) */
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_BUS
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
operator|&
name|umass_cam_rescan_callback
expr_stmt|;
name|ccb
operator|->
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|700037
operator|)
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The scan is in progress now. */
block|}
end_function

begin_function
specifier|static
name|void
name|umass_cam_attach
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|USB_DEBUG
if|if
condition|(
name|bootverbose
condition|)
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s:%d:%d:%d: Attached to scbus%d\n"
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cold
condition|)
block|{
comment|/* 		 * Notify CAM of the new device after a short delay. Any 		 * failure is benign, as the user can still do it by hand 		 * (camcontrol rescan<busno>). Only do this if we are not 		 * booting, because CAM does a scan after booting has 		 * completed, when interrupts have been enabled. 		 */
comment|/* scan the new sim */
name|umass_cam_rescan
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* umass_cam_detach  *	detach from the CAM layer  */
end_comment

begin_function
specifier|static
name|void
name|umass_cam_detach_sim
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_sim
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
argument_list|)
condition|)
block|{
comment|/* accessing the softc is not possible after this */
name|sc
operator|->
name|sc_sim
operator|->
name|softc
operator|=
name|UMASS_GONE
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|,
comment|/* free_devq */
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"%s: CAM layer is busy!\n"
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_sim
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* umass_cam_action  * 	CAM requests for action come through here  */
end_comment

begin_function
specifier|static
name|void
name|umass_cam_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|umass_softc
operator|*
operator|)
name|sim
operator|->
name|softc
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|UMASS_GONE
operator|||
operator|(
name|sc
operator|!=
name|NULL
operator|&&
operator|!
name|usbd_device_attached
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
condition|)
block|{
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|700037
operator|)
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Verify, depending on the operation to perform, that we either got 	 * a valid sc, because an existing target was referenced, or 	 * otherwise the SIM is addressed. 	 * 	 * This avoids bombing out at a printf and does give the CAM layer some 	 * sensible feedback on errors. 	 */
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
case|case
name|XPT_RESET_DEV
case|:
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
case|case
name|XPT_CALC_GEOMETRY
case|:
comment|/* the opcodes requiring a target. These should never occur. */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_GEN
argument_list|,
literal|"%s:%d:%d:%d:func_code 0x%04x: "
literal|"Invalid target (target needed)\n"
argument_list|,
name|DEVNAME_SIM
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|XPT_PATH_INQ
case|:
case|case
name|XPT_NOOP
case|:
comment|/* 		 * The opcodes sometimes aimed at a target (sc is valid), 		 * sometimes aimed at the SIM (sc is invalid and target is 		 * CAM_TARGET_WILDCARD) 		 */
if|if
condition|(
operator|(
name|sc
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"%s:%d:%d:%d:func_code 0x%04x: "
literal|"Invalid target (no wildcard)\n"
argument_list|,
name|DEVNAME_SIM
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
default|default:
comment|/* XXX Hm, we should check the input parameters */
break|break;
block|}
comment|/* Perform the requested action */
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
block|{
name|uint8_t
modifier|*
name|cmd
decl_stmt|;
name|uint8_t
name|dir
decl_stmt|;
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
block|{
name|cmd
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_ptr
operator|)
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
operator|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"%d:%d:%d:XPT_SCSI_IO: "
literal|"cmd: 0x%02x, flags: 0x%02x, "
literal|"%db cmd/%db data/%db sense\n"
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|cmd
index|[
literal|0
index|]
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|ccb
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"%d:%d:%d:XPT_SCSI_IO: "
literal|"I/O in progress, deferring\n"
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_BUSY
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
condition|)
block|{
case|case
name|CAM_DIR_IN
case|:
name|dir
operator|=
name|DIR_IN
expr_stmt|;
break|break;
case|case
name|CAM_DIR_OUT
case|:
name|dir
operator|=
name|DIR_OUT
expr_stmt|;
name|DIF
argument_list|(
name|UDMASS_SCSI
argument_list|,
name|umass_dump_buffer
argument_list|(
name|sc
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
literal|48
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dir
operator|=
name|DIR_NONE
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
operator||
name|CAM_SIM_QUEUED
expr_stmt|;
comment|/* 			 * sc->sc_transform will convert the command to the 			 * command format needed by the specific command set 			 * and return the converted command in 			 * "sc->sc_transfer.cmd_data" 			 */
if|if
condition|(
name|umass_std_transform
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|,
name|cmd
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|0
index|]
operator|==
name|INQUIRY
condition|)
block|{
comment|/* 					 * Umass devices don't generally report their serial numbers 					 * in the usual SCSI way.  Emulate it here. 					 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|1
index|]
operator|&
name|SI_EVPD
operator|)
operator|&&
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|2
index|]
operator|==
name|SVPD_UNIT_SERIAL_NUMBER
operator|&&
name|sc
operator|->
name|sc_udev
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|sc_udev
operator|->
name|serial
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|sc_udev
operator|->
name|serial
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|struct
name|scsi_vpd_unit_serial_number
modifier|*
name|vpd_serial
decl_stmt|;
name|vpd_serial
operator|=
operator|(
expr|struct
name|scsi_vpd_unit_serial_number
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|vpd_serial
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|sc
operator|->
name|sc_udev
operator|->
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|vpd_serial
operator|->
name|length
operator|>
sizeof|sizeof
argument_list|(
name|vpd_serial
operator|->
name|serial_num
argument_list|)
condition|)
name|vpd_serial
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
name|vpd_serial
operator|->
name|serial_num
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|vpd_serial
operator|->
name|serial_num
argument_list|,
name|sc
operator|->
name|sc_udev
operator|->
name|serial
argument_list|,
name|vpd_serial
operator|->
name|length
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 					 * Handle EVPD inquiry for broken devices first 					 * NO_INQUIRY also implies NO_INQUIRY_EVPD 					 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_quirks
operator|&
operator|(
name|NO_INQUIRY_EVPD
operator||
name|NO_INQUIRY
operator|)
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|1
index|]
operator|&
name|SI_EVPD
operator|)
condition|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|bzero
argument_list|(
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense
argument_list|)
argument_list|)
expr_stmt|;
name|sense
operator|->
name|error_code
operator|=
name|SSD_CURRENT_ERROR
expr_stmt|;
name|sense
operator|->
name|flags
operator|=
name|SSD_KEY_ILLEGAL_REQUEST
expr_stmt|;
name|sense
operator|->
name|add_sense_code
operator|=
literal|0x24
expr_stmt|;
name|sense
operator|->
name|extra_len
operator|=
literal|10
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 					 * Return fake inquiry data for 					 * broken devices 					 */
if|if
condition|(
name|sc
operator|->
name|sc_quirks
operator|&
name|NO_INQUIRY
condition|)
block|{
name|memcpy
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
operator|&
name|fake_inq_data
argument_list|,
sizeof|sizeof
argument_list|(
name|fake_inq_data
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_quirks
operator|&
name|FORCE_SHORT_INQUIRY
condition|)
block|{
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|=
name|SHORT_INQUIRY_LENGTH
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|0
index|]
operator|==
name|SYNCHRONIZE_CACHE
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_quirks
operator|&
name|NO_SYNCHRONIZE_CACHE
condition|)
block|{
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|umass_command_start
argument_list|(
name|sc
argument_list|,
name|dir
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|,
operator|&
name|umass_cam_cb
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"%d:%d:%d:XPT_PATH_INQ:.\n"
argument_list|,
name|sc
condition|?
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
else|:
operator|-
literal|1
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
comment|/* host specific information */
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NO_6_BYTE
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|UMASS_SCSIID_MAX
expr_stmt|;
comment|/* one target */
name|cpi
operator|->
name|initiator_id
operator|=
name|UMASS_SCSIID_HOST
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"USB SCSI"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|700025
operator|)
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_USB
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_quirks
operator|&
name|FLOPPY_SPEED
condition|)
block|{
name|cpi
operator|->
name|base_transfer_speed
operator|=
name|UMASS_FLOPPY_TRANSFER_SPEED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usbd_get_speed
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
operator|==
name|USB_SPEED_HIGH
condition|)
block|{
name|cpi
operator|->
name|base_transfer_speed
operator|=
name|UMASS_HIGH_TRANSFER_SPEED
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|base_transfer_speed
operator|=
name|UMASS_FULL_TRANSFER_SPEED
expr_stmt|;
block|}
name|cpi
operator|->
name|max_lun
operator|=
name|sc
operator|->
name|sc_maxlun
expr_stmt|;
block|}
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_DEV
case|:
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"%d:%d:%d:XPT_RESET_DEV:.\n"
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|umass_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"%d:%d:%d:XPT_GET_TRAN_SETTINGS:.\n"
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|700025
operator|)
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_USB
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|cts
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|cts
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* no disconnection, tagging */
endif|#
directive|endif
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"%d:%d:%d:XPT_SET_TRAN_SETTINGS:.\n"
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
comment|/* extended */
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_NOOP
case|:
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"%d:%d:%d:XPT_NOOP:.\n"
argument_list|,
name|sc
condition|?
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
else|:
operator|-
literal|1
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"%d:%d:%d:func_code 0x%04x: "
literal|"Not implemented\n"
argument_list|,
name|sc
condition|?
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
else|:
operator|-
literal|1
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|done
label|:
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|700037
operator|)
if|if
condition|(
name|sc
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_cam_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|umass_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|umass_softc
operator|*
operator|)
name|sim
operator|->
name|softc
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|UMASS_GONE
condition|)
return|return;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"CAM poll\n"
argument_list|)
expr_stmt|;
name|usbd_transfer_poll
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|UMASS_T_MAX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* umass_cam_cb  *	finalise a completed CAM command  */
end_comment

begin_function
specifier|static
name|void
name|umass_cam_cb
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint32_t
name|residue
parameter_list|,
name|uint8_t
name|status
parameter_list|)
block|{
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|residue
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|STATUS_CMD_OK
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_quirks
operator|&
name|READ_CAPACITY_OFFBY1
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|==
name|READ_CAPACITY
operator|)
condition|)
block|{
name|struct
name|scsi_read_capacity_data
modifier|*
name|rcap
decl_stmt|;
name|uint32_t
name|maxsector
decl_stmt|;
name|rcap
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
operator|)
expr_stmt|;
name|maxsector
operator|=
name|scsi_4btoul
argument_list|(
name|rcap
operator|->
name|addr
argument_list|)
operator|-
literal|1
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|maxsector
argument_list|,
name|rcap
operator|->
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We have to add SVPD_UNIT_SERIAL_NUMBER to the list 		 * of pages supported by the device - otherwise, CAM 		 * will never ask us for the serial number if the 		 * device cannot handle that by itself. 		 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
operator|&&
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|0
index|]
operator|==
name|INQUIRY
operator|&&
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|1
index|]
operator|&
name|SI_EVPD
operator|)
operator|&&
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|2
index|]
operator|==
name|SVPD_SUPPORTED_PAGE_LIST
operator|&&
name|sc
operator|->
name|sc_udev
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|sc_udev
operator|->
name|serial
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|sc_udev
operator|->
name|serial
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|scsi_vpd_supported_page_list
modifier|*
name|page_list
decl_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|page_list
operator|=
operator|(
expr|struct
name|scsi_vpd_supported_page_list
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
if|if
condition|(
name|page_list
operator|->
name|length
operator|+
literal|1
operator|<
name|SVPD_SUPPORTED_PAGES_SIZE
condition|)
block|{
name|page_list
operator|->
name|list
index|[
name|page_list
operator|->
name|length
index|]
operator|=
name|SVPD_UNIT_SERIAL_NUMBER
expr_stmt|;
name|page_list
operator|->
name|length
operator|++
expr_stmt|;
block|}
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATUS_CMD_UNKNOWN
case|:
case|case
name|STATUS_CMD_FAILED
case|:
comment|/* fetch sense data */
comment|/* the rest of the command was filled in at attach */
name|sc
operator|->
name|cam_scsi_sense
operator|.
name|length
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sense_len
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"Fetching %d bytes of "
literal|"sense data\n"
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|umass_std_transform
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|,
operator|&
name|sc
operator|->
name|cam_scsi_sense
operator|.
name|opcode
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cam_scsi_sense
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_quirks
operator|&
name|FORCE_SHORT_INQUIRY
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|0
index|]
operator|==
name|INQUIRY
operator|)
condition|)
block|{
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|=
name|SHORT_INQUIRY_LENGTH
expr_stmt|;
block|}
name|umass_command_start
argument_list|(
name|sc
argument_list|,
name|DIR_IN
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
operator|.
name|error_code
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|,
operator|&
name|umass_cam_sense_cb
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* 		 * the wire protocol failed and will have recovered 		 * (hopefully).  We return an error to CAM and let CAM retry 		 * the command if necessary. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Finalise a completed autosense operation  */
end_comment

begin_function
specifier|static
name|void
name|umass_cam_sense_cb
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint32_t
name|residue
parameter_list|,
name|uint8_t
name|status
parameter_list|)
block|{
name|uint8_t
modifier|*
name|cmd
decl_stmt|;
name|uint8_t
name|key
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|STATUS_CMD_OK
case|:
case|case
name|STATUS_CMD_UNKNOWN
case|:
case|case
name|STATUS_CMD_FAILED
case|:
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
block|{
name|cmd
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_ptr
operator|)
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
operator|)
expr_stmt|;
block|}
name|key
operator|=
operator|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
operator|.
name|flags
operator|&
name|SSD_KEY
operator|)
expr_stmt|;
comment|/* 		 * Getting sense data always succeeds (apart from wire 		 * failures): 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_quirks
operator|&
name|RS_NO_CLEAR_UA
operator|)
operator|&&
operator|(
name|cmd
index|[
literal|0
index|]
operator|==
name|INQUIRY
operator|)
operator|&&
operator|(
name|key
operator|==
name|SSD_KEY_UNIT_ATTENTION
operator|)
condition|)
block|{
comment|/* 			 * Ignore unit attention errors in the case where 			 * the Unit Attention state is not cleared on 			 * REQUEST SENSE. They will appear again at the next 			 * command. 			 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
name|SSD_KEY_NO_SENSE
condition|)
block|{
comment|/* 			 * No problem after all (in the case of CBI without 			 * CCI) 			 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_quirks
operator|&
name|RS_NO_CLEAR_UA
operator|)
operator|&&
operator|(
name|cmd
index|[
literal|0
index|]
operator|==
name|READ_CAPACITY
operator|)
operator|&&
operator|(
name|key
operator|==
name|SSD_KEY_UNIT_ATTENTION
operator|)
condition|)
block|{
comment|/* 			 * Some devices do not clear the unit attention error 			 * on request sense. We insert a test unit ready 			 * command to make sure we clear the unit attention 			 * condition, then allow the retry to proceed as 			 * usual. 			 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
if|#
directive|if
literal|0
block|DELAY(300000);
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"Doing a sneaky"
literal|"TEST_UNIT_READY\n"
argument_list|)
expr_stmt|;
comment|/* the rest of the command was filled in at attach */
if|if
condition|(
name|umass_std_transform
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|,
operator|&
name|sc
operator|->
name|cam_scsi_test_unit_ready
operator|.
name|opcode
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cam_scsi_test_unit_ready
argument_list|)
argument_list|)
condition|)
block|{
name|umass_command_start
argument_list|(
name|sc
argument_list|,
name|DIR_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|,
operator|&
name|umass_cam_quirk_cb
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"Autosense failed, "
literal|"status %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_AUTOSENSE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This completion code just handles the fact that we sent a test-unit-ready  * after having previously failed a READ CAPACITY with CHECK_COND.  Even  * though this command succeeded, we have to tell CAM to retry.  */
end_comment

begin_function
specifier|static
name|void
name|umass_cam_quirk_cb
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint32_t
name|residue
parameter_list|,
name|uint8_t
name|status
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"Test unit ready "
literal|"returned status %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SCSI specific functions  */
end_comment

begin_function
specifier|static
name|uint8_t
name|umass_scsi_transform
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|cmd_ptr
parameter_list|,
name|uint8_t
name|cmd_len
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cmd_len
operator|==
literal|0
operator|)
operator|||
operator|(
name|cmd_len
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"Invalid command "
literal|"length: %d bytes\n"
argument_list|,
name|cmd_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* failure */
block|}
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
operator|=
name|cmd_len
expr_stmt|;
switch|switch
condition|(
name|cmd_ptr
index|[
literal|0
index|]
condition|)
block|{
case|case
name|TEST_UNIT_READY
case|:
if|if
condition|(
name|sc
operator|->
name|sc_quirks
operator|&
name|NO_TEST_UNIT_READY
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"Converted TEST_UNIT_READY "
literal|"to START_UNIT\n"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|,
name|cmd_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|0
index|]
operator|=
name|START_STOP_UNIT
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|4
index|]
operator|=
name|SSS_START
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|INQUIRY
case|:
comment|/* 		 * some drives wedge when asked for full inquiry 		 * information. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_quirks
operator|&
name|FORCE_SHORT_INQUIRY
condition|)
block|{
name|bcopy
argument_list|(
name|cmd_ptr
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|,
name|cmd_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|4
index|]
operator|=
name|SHORT_INQUIRY_LENGTH
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
name|bcopy
argument_list|(
name|cmd_ptr
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|,
name|cmd_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|umass_rbc_transform
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|cmd_ptr
parameter_list|,
name|uint8_t
name|cmd_len
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cmd_len
operator|==
literal|0
operator|)
operator|||
operator|(
name|cmd_len
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"Invalid command "
literal|"length: %d bytes\n"
argument_list|,
name|cmd_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* failure */
block|}
switch|switch
condition|(
name|cmd_ptr
index|[
literal|0
index|]
condition|)
block|{
comment|/* these commands are defined in RBC: */
case|case
name|READ_10
case|:
case|case
name|READ_CAPACITY
case|:
case|case
name|START_STOP_UNIT
case|:
case|case
name|SYNCHRONIZE_CACHE
case|:
case|case
name|WRITE_10
case|:
case|case
literal|0x2f
case|:
comment|/* VERIFY_10 is absent from 					 * scsi_all.h??? */
case|case
name|INQUIRY
case|:
case|case
name|MODE_SELECT_10
case|:
case|case
name|MODE_SENSE_10
case|:
case|case
name|TEST_UNIT_READY
case|:
case|case
name|WRITE_BUFFER
case|:
comment|/* 		 * The following commands are not listed in my copy of the 		 * RBC specs. CAM however seems to want those, and at least 		 * the Sony DSC device appears to support those as well 		 */
case|case
name|REQUEST_SENSE
case|:
case|case
name|PREVENT_ALLOW
case|:
name|bcopy
argument_list|(
name|cmd_ptr
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|,
name|cmd_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_quirks
operator|&
name|RBC_PAD_TO_12
operator|)
operator|&&
operator|(
name|cmd_len
operator|<
literal|12
operator|)
condition|)
block|{
name|bzero
argument_list|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
operator|+
name|cmd_len
argument_list|,
literal|12
operator|-
name|cmd_len
argument_list|)
expr_stmt|;
name|cmd_len
operator|=
literal|12
expr_stmt|;
block|}
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
operator|=
name|cmd_len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* sucess */
comment|/* All other commands are not legal in RBC */
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"Unsupported RBC "
literal|"command 0x%02x\n"
argument_list|,
name|cmd_ptr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* failure */
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|umass_ufi_transform
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|cmd_ptr
parameter_list|,
name|uint8_t
name|cmd_len
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cmd_len
operator|==
literal|0
operator|)
operator|||
operator|(
name|cmd_len
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"Invalid command "
literal|"length: %d bytes\n"
argument_list|,
name|cmd_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* failure */
block|}
comment|/* An UFI command is always 12 bytes in length */
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
operator|=
name|UFI_COMMAND_LENGTH
expr_stmt|;
comment|/* Zero the command data */
name|bzero
argument_list|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|,
name|UFI_COMMAND_LENGTH
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd_ptr
index|[
literal|0
index|]
condition|)
block|{
comment|/* 		 * Commands of which the format has been verified. They 		 * should work. Copy the command into the (zeroed out) 		 * destination buffer. 		 */
case|case
name|TEST_UNIT_READY
case|:
if|if
condition|(
name|sc
operator|->
name|sc_quirks
operator|&
name|NO_TEST_UNIT_READY
condition|)
block|{
comment|/* 			 * Some devices do not support this command. Start 			 * Stop Unit should give the same results 			 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_UFI
argument_list|,
literal|"Converted TEST_UNIT_READY "
literal|"to START_UNIT\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|0
index|]
operator|=
name|START_STOP_UNIT
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|4
index|]
operator|=
name|SSS_START
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|REZERO_UNIT
case|:
case|case
name|REQUEST_SENSE
case|:
case|case
name|FORMAT_UNIT
case|:
case|case
name|INQUIRY
case|:
case|case
name|START_STOP_UNIT
case|:
case|case
name|SEND_DIAGNOSTIC
case|:
case|case
name|PREVENT_ALLOW
case|:
case|case
name|READ_CAPACITY
case|:
case|case
name|READ_10
case|:
case|case
name|WRITE_10
case|:
case|case
name|POSITION_TO_ELEMENT
case|:
comment|/* SEEK_10 */
case|case
name|WRITE_AND_VERIFY
case|:
case|case
name|VERIFY
case|:
case|case
name|MODE_SELECT_10
case|:
case|case
name|MODE_SENSE_10
case|:
case|case
name|READ_12
case|:
case|case
name|WRITE_12
case|:
case|case
name|READ_FORMAT_CAPACITIES
case|:
break|break;
comment|/* 		 * SYNCHRONIZE_CACHE isn't supported by UFI, nor should it be 		 * required for UFI devices, so it is appropriate to fake 		 * success. 		 */
case|case
name|SYNCHRONIZE_CACHE
case|:
return|return
operator|(
literal|2
operator|)
return|;
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"Unsupported UFI "
literal|"command 0x%02x\n"
argument_list|,
name|cmd_ptr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* failure */
block|}
name|bcopy
argument_list|(
name|cmd_ptr
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|,
name|cmd_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/*  * 8070i (ATAPI) specific functions  */
end_comment

begin_function
specifier|static
name|uint8_t
name|umass_atapi_transform
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|cmd_ptr
parameter_list|,
name|uint8_t
name|cmd_len
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cmd_len
operator|==
literal|0
operator|)
operator|||
operator|(
name|cmd_len
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"Invalid command "
literal|"length: %d bytes\n"
argument_list|,
name|cmd_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* failure */
block|}
comment|/* An ATAPI command is always 12 bytes in length. */
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
operator|=
name|ATAPI_COMMAND_LENGTH
expr_stmt|;
comment|/* Zero the command data */
name|bzero
argument_list|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|,
name|ATAPI_COMMAND_LENGTH
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd_ptr
index|[
literal|0
index|]
condition|)
block|{
comment|/* 		 * Commands of which the format has been verified. They 		 * should work. Copy the command into the destination 		 * buffer. 		 */
case|case
name|INQUIRY
case|:
comment|/* 		 * some drives wedge when asked for full inquiry 		 * information. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_quirks
operator|&
name|FORCE_SHORT_INQUIRY
condition|)
block|{
name|bcopy
argument_list|(
name|cmd_ptr
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|,
name|cmd_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|4
index|]
operator|=
name|SHORT_INQUIRY_LENGTH
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|TEST_UNIT_READY
case|:
if|if
condition|(
name|sc
operator|->
name|sc_quirks
operator|&
name|NO_TEST_UNIT_READY
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"Converted TEST_UNIT_READY "
literal|"to START_UNIT\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|0
index|]
operator|=
name|START_STOP_UNIT
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
index|[
literal|4
index|]
operator|=
name|SSS_START
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|REZERO_UNIT
case|:
case|case
name|REQUEST_SENSE
case|:
case|case
name|START_STOP_UNIT
case|:
case|case
name|SEND_DIAGNOSTIC
case|:
case|case
name|PREVENT_ALLOW
case|:
case|case
name|READ_CAPACITY
case|:
case|case
name|READ_10
case|:
case|case
name|WRITE_10
case|:
case|case
name|POSITION_TO_ELEMENT
case|:
comment|/* SEEK_10 */
case|case
name|SYNCHRONIZE_CACHE
case|:
case|case
name|MODE_SELECT_10
case|:
case|case
name|MODE_SENSE_10
case|:
case|case
name|READ_BUFFER
case|:
case|case
literal|0x42
case|:
comment|/* READ_SUBCHANNEL */
case|case
literal|0x43
case|:
comment|/* READ_TOC */
case|case
literal|0x44
case|:
comment|/* READ_HEADER */
case|case
literal|0x47
case|:
comment|/* PLAY_MSF (Play Minute/Second/Frame) */
case|case
literal|0x48
case|:
comment|/* PLAY_TRACK */
case|case
literal|0x49
case|:
comment|/* PLAY_TRACK_REL */
case|case
literal|0x4b
case|:
comment|/* PAUSE */
case|case
literal|0x51
case|:
comment|/* READ_DISK_INFO */
case|case
literal|0x52
case|:
comment|/* READ_TRACK_INFO */
case|case
literal|0x54
case|:
comment|/* SEND_OPC */
case|case
literal|0x59
case|:
comment|/* READ_MASTER_CUE */
case|case
literal|0x5b
case|:
comment|/* CLOSE_TR_SESSION */
case|case
literal|0x5c
case|:
comment|/* READ_BUFFER_CAP */
case|case
literal|0x5d
case|:
comment|/* SEND_CUE_SHEET */
case|case
literal|0xa1
case|:
comment|/* BLANK */
case|case
literal|0xa5
case|:
comment|/* PLAY_12 */
case|case
literal|0xa6
case|:
comment|/* EXCHANGE_MEDIUM */
case|case
literal|0xad
case|:
comment|/* READ_DVD_STRUCTURE */
case|case
literal|0xbb
case|:
comment|/* SET_CD_SPEED */
case|case
literal|0xe5
case|:
comment|/* READ_TRACK_INFO_PHILIPS */
break|break;
empty_stmt|;
case|case
name|READ_12
case|:
case|case
name|WRITE_12
case|:
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_SCSI
argument_list|,
literal|"Unsupported ATAPI "
literal|"command 0x%02x - trying anyway\n"
argument_list|,
name|cmd_ptr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
empty_stmt|;
block|}
name|bcopy
argument_list|(
name|cmd_ptr
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_data
argument_list|,
name|cmd_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|umass_no_transform
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|cmd
parameter_list|,
name|uint8_t
name|cmdlen
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* failure */
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|umass_std_transform
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint8_t
modifier|*
name|cmd
parameter_list|,
name|uint8_t
name|cmdlen
parameter_list|)
block|{
name|uint8_t
name|retval
decl_stmt|;
name|retval
operator|=
call|(
name|sc
operator|->
name|sc_transform
call|)
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|cmdlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|2
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Command should be executed */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_function
specifier|static
name|void
name|umass_bbb_dump_cbw
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|umass_bbb_cbw_t
modifier|*
name|cbw
parameter_list|)
block|{
name|uint8_t
modifier|*
name|c
init|=
name|cbw
operator|->
name|CBWCDB
decl_stmt|;
name|uint32_t
name|dlen
init|=
name|UGETDW
argument_list|(
name|cbw
operator|->
name|dCBWDataTransferLength
argument_list|)
decl_stmt|;
name|uint32_t
name|tag
init|=
name|UGETDW
argument_list|(
name|cbw
operator|->
name|dCBWTag
argument_list|)
decl_stmt|;
name|uint8_t
name|clen
init|=
name|cbw
operator|->
name|bCDBLength
decl_stmt|;
name|uint8_t
name|flags
init|=
name|cbw
operator|->
name|bCBWFlags
decl_stmt|;
name|uint8_t
name|lun
init|=
name|cbw
operator|->
name|bCBWLUN
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"CBW %d: cmd = %db "
literal|"(0x%02x%02x%02x%02x%02x%02x%s), "
literal|"data = %db, lun = %d, dir = %s\n"
argument_list|,
name|tag
argument_list|,
name|clen
argument_list|,
name|c
index|[
literal|0
index|]
argument_list|,
name|c
index|[
literal|1
index|]
argument_list|,
name|c
index|[
literal|2
index|]
argument_list|,
name|c
index|[
literal|3
index|]
argument_list|,
name|c
index|[
literal|4
index|]
argument_list|,
name|c
index|[
literal|5
index|]
argument_list|,
operator|(
name|clen
operator|>
literal|6
condition|?
literal|"..."
else|:
literal|""
operator|)
argument_list|,
name|dlen
argument_list|,
name|lun
argument_list|,
operator|(
name|flags
operator|==
name|CBWFLAGS_IN
condition|?
literal|"in"
else|:
operator|(
name|flags
operator|==
name|CBWFLAGS_OUT
condition|?
literal|"out"
else|:
literal|"<invalid>"
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_bbb_dump_csw
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|umass_bbb_csw_t
modifier|*
name|csw
parameter_list|)
block|{
name|uint32_t
name|sig
init|=
name|UGETDW
argument_list|(
name|csw
operator|->
name|dCSWSignature
argument_list|)
decl_stmt|;
name|uint32_t
name|tag
init|=
name|UGETDW
argument_list|(
name|csw
operator|->
name|dCSWTag
argument_list|)
decl_stmt|;
name|uint32_t
name|res
init|=
name|UGETDW
argument_list|(
name|csw
operator|->
name|dCSWDataResidue
argument_list|)
decl_stmt|;
name|uint8_t
name|status
init|=
name|csw
operator|->
name|bCSWStatus
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"CSW %d: sig = 0x%08x (%s), tag = 0x%08x, "
literal|"res = %d, status = 0x%02x (%s)\n"
argument_list|,
name|tag
argument_list|,
name|sig
argument_list|,
operator|(
name|sig
operator|==
name|CSWSIGNATURE
condition|?
literal|"valid"
else|:
literal|"invalid"
operator|)
argument_list|,
name|tag
argument_list|,
name|res
argument_list|,
name|status
argument_list|,
operator|(
name|status
operator|==
name|CSWSTATUS_GOOD
condition|?
literal|"good"
else|:
operator|(
name|status
operator|==
name|CSWSTATUS_FAILED
condition|?
literal|"failed"
else|:
operator|(
name|status
operator|==
name|CSWSTATUS_PHASE
condition|?
literal|"phase"
else|:
literal|"<invalid>"
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_cbi_dump_cmd
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|cmd
parameter_list|,
name|uint8_t
name|cmdlen
parameter_list|)
block|{
name|uint8_t
modifier|*
name|c
init|=
name|cmd
decl_stmt|;
name|uint8_t
name|dir
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|dir
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_BBB
argument_list|,
literal|"cmd = %db "
literal|"(0x%02x%02x%02x%02x%02x%02x%s), "
literal|"data = %db, dir = %s\n"
argument_list|,
name|cmdlen
argument_list|,
name|c
index|[
literal|0
index|]
argument_list|,
name|c
index|[
literal|1
index|]
argument_list|,
name|c
index|[
literal|2
index|]
argument_list|,
name|c
index|[
literal|3
index|]
argument_list|,
name|c
index|[
literal|4
index|]
argument_list|,
name|c
index|[
literal|5
index|]
argument_list|,
operator|(
name|cmdlen
operator|>
literal|6
condition|?
literal|"..."
else|:
literal|""
operator|)
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_len
argument_list|,
operator|(
name|dir
operator|==
name|DIR_IN
condition|?
literal|"in"
else|:
operator|(
name|dir
operator|==
name|DIR_OUT
condition|?
literal|"out"
else|:
operator|(
name|dir
operator|==
name|DIR_NONE
condition|?
literal|"no data phase"
else|:
literal|"<invalid>"
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umass_dump_buffer
parameter_list|(
name|struct
name|umass_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|buflen
parameter_list|,
name|uint32_t
name|printlen
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|s1
index|[
literal|40
index|]
decl_stmt|;
name|char
name|s2
index|[
literal|40
index|]
decl_stmt|;
name|char
name|s3
index|[
literal|5
index|]
decl_stmt|;
name|s1
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s3
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|s2
argument_list|,
literal|" buffer=%p, buflen=%d"
argument_list|,
name|buffer
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|buflen
operator|)
operator|&&
operator|(
name|i
operator|<
name|printlen
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|i
operator|%
literal|16
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_GEN
argument_list|,
literal|"0x %s%s\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|s2
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|sprintf
argument_list|(
operator|&
name|s1
index|[
name|j
operator|*
literal|2
index|]
argument_list|,
literal|"%02x"
argument_list|,
name|buffer
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buflen
operator|>
name|printlen
condition|)
name|sprintf
argument_list|(
name|s3
argument_list|,
literal|" ..."
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|UDMASS_GEN
argument_list|,
literal|"0x %s%s%s\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

