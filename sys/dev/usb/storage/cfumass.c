begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Edward Tomasz Napierala under sponsorship  * from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*  * USB Mass Storage Class Bulk-Only (BBB) Transport target.  *  * http://www.usb.org/developers/docs/devclass_docs/usbmassbulk_10.pdf  *  * This code implements the USB Mass Storage frontend driver for the CAM  * Target Layer (ctl(4)) subsystem.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_include
include|#
directive|include
file|"usb_if.h"
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_io.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_backend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_error.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_frontend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_ha.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_private.h>
end_include

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|cfumass
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"CAM Target Layer USB Mass Storage Frontend"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_cfumass
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|debug
argument_list|,
literal|1
argument_list|,
literal|"Enable debug messages"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|max_lun
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_cfumass
argument_list|,
name|OID_AUTO
argument_list|,
name|max_lun
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|max_lun
argument_list|,
literal|1
argument_list|,
literal|"Maximum advertised LUN number"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ignore_stop
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_cfumass
argument_list|,
name|OID_AUTO
argument_list|,
name|ignore_stop
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ignore_stop
argument_list|,
literal|1
argument_list|,
literal|"Ignore START STOP UNIT with START and LOEJ bits cleared"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The driver uses a single, global CTL port.  It could create its ports  * in cfumass_attach() instead, but that would make it impossible to specify  * "port cfumass0" in ctl.conf(5), as the port generally wouldn't exist  * at the time ctld(8) gets run.  */
end_comment

begin_decl_stmt
name|struct
name|ctl_port
name|cfumass_port
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|cfumass_port_online
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|u_int
name|cfumass_refcount
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CFUMASS_BULK_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CFUMASS_BULK_SIZE
value|(1U<< 17)
end_define

begin_comment
comment|/* bytes */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * USB transfer definitions.  */
end_comment

begin_define
define|#
directive|define
name|CFUMASS_T_COMMAND
value|0
end_define

begin_define
define|#
directive|define
name|CFUMASS_T_DATA_OUT
value|1
end_define

begin_define
define|#
directive|define
name|CFUMASS_T_DATA_IN
value|2
end_define

begin_define
define|#
directive|define
name|CFUMASS_T_STATUS
value|3
end_define

begin_define
define|#
directive|define
name|CFUMASS_T_MAX
value|4
end_define

begin_comment
comment|/*  * USB interface specific control requests.  */
end_comment

begin_define
define|#
directive|define
name|UR_RESET
value|0xff
end_define

begin_comment
comment|/* Bulk-Only Mass Storage Reset */
end_comment

begin_define
define|#
directive|define
name|UR_GET_MAX_LUN
value|0xfe
end_define

begin_comment
comment|/* Get Max LUN */
end_comment

begin_comment
comment|/*  * Command Block Wrapper.  */
end_comment

begin_struct
struct|struct
name|cfumass_cbw_t
block|{
name|uDWord
name|dCBWSignature
decl_stmt|;
define|#
directive|define
name|CBWSIGNATURE
value|0x43425355
comment|/* "USBC" */
name|uDWord
name|dCBWTag
decl_stmt|;
name|uDWord
name|dCBWDataTransferLength
decl_stmt|;
name|uByte
name|bCBWFlags
decl_stmt|;
define|#
directive|define
name|CBWFLAGS_OUT
value|0x00
define|#
directive|define
name|CBWFLAGS_IN
value|0x80
name|uByte
name|bCBWLUN
decl_stmt|;
name|uByte
name|bCDBLength
decl_stmt|;
define|#
directive|define
name|CBWCBLENGTH
value|16
name|uByte
name|CBWCB
index|[
name|CBWCBLENGTH
index|]
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|CFUMASS_CBW_SIZE
value|31
end_define

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cfumass_cbw_t
argument_list|)
operator|==
name|CFUMASS_CBW_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Command Status Wrapper.  */
end_comment

begin_struct
struct|struct
name|cfumass_csw_t
block|{
name|uDWord
name|dCSWSignature
decl_stmt|;
define|#
directive|define
name|CSWSIGNATURE
value|0x53425355
comment|/* "USBS" */
name|uDWord
name|dCSWTag
decl_stmt|;
name|uDWord
name|dCSWDataResidue
decl_stmt|;
name|uByte
name|bCSWStatus
decl_stmt|;
define|#
directive|define
name|CSWSTATUS_GOOD
value|0x0
define|#
directive|define
name|CSWSTATUS_FAILED
value|0x1
define|#
directive|define
name|CSWSTATUS_PHASE
value|0x2
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|CFUMASS_CSW_SIZE
value|13
end_define

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cfumass_csw_t
argument_list|)
operator|==
name|CFUMASS_CSW_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|cfumass_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|sc_udev
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|sc_xfer
index|[
name|CFUMASS_T_MAX
index|]
decl_stmt|;
name|struct
name|cfumass_cbw_t
modifier|*
name|sc_cbw
decl_stmt|;
name|struct
name|cfumass_csw_t
modifier|*
name|sc_csw
decl_stmt|;
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
name|int
name|sc_online
decl_stmt|;
name|int
name|sc_ctl_initid
decl_stmt|;
comment|/* 	 * This is used to communicate between CTL callbacks 	 * and USB callbacks; basically, it holds the state 	 * for the current command ("the" command, since there 	 * is no queueing in USB Mass Storage). 	 */
name|bool
name|sc_current_stalled
decl_stmt|;
comment|/* 	 * The following are set upon receiving a SCSI command. 	 */
name|int
name|sc_current_tag
decl_stmt|;
name|int
name|sc_current_transfer_length
decl_stmt|;
name|int
name|sc_current_flags
decl_stmt|;
comment|/* 	 * The following are set in ctl_datamove(). 	 */
name|int
name|sc_current_residue
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|sc_ctl_io
decl_stmt|;
comment|/* 	 * The following is set in cfumass_done(). 	 */
name|int
name|sc_current_status
decl_stmt|;
comment|/* 	 * Number of requests queued to CTL. 	 */
specifier|volatile
name|u_int
name|sc_queued
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * USB interface.  */
end_comment

begin_decl_stmt
specifier|static
name|device_probe_t
name|cfumass_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|cfumass_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|cfumass_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_suspend_t
name|cfumass_suspend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_resume_t
name|cfumass_resume
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_handle_request_t
name|cfumass_handle_request
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|cfumass_t_command_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|cfumass_t_data_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|cfumass_t_status_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|cfumass_methods
index|[]
init|=
block|{
comment|/* USB interface. */
name|DEVMETHOD
argument_list|(
name|usb_handle_request
argument_list|,
name|cfumass_handle_request
argument_list|)
block|,
comment|/* Device interface. */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cfumass_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cfumass_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cfumass_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|cfumass_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|cfumass_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cfumass_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"cfumass"
block|,
operator|.
name|methods
operator|=
name|cfumass_methods
block|,
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cfumass_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|cfumass_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cfumass
argument_list|,
name|uhub
argument_list|,
name|cfumass_driver
argument_list|,
name|cfumass_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cfumass
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|cfumass
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|cfumass
argument_list|,
name|usb_template
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|usb_config
name|cfumass_config
index|[
name|CFUMASS_T_MAX
index|]
init|=
block|{
index|[
name|CFUMASS_T_COMMAND
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cfumass_cbw_t
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|cfumass_t_command_callback
block|,
operator|.
name|usb_mode
operator|=
name|USB_MODE_DEVICE
block|, 	}
block|,
index|[
name|CFUMASS_T_DATA_OUT
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
name|CFUMASS_BULK_SIZE
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|proxy_buffer
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,
operator|.
name|ext_buffer
operator|=
literal|1
block|}
block|,
operator|.
name|callback
operator|=
operator|&
name|cfumass_t_data_callback
block|,
operator|.
name|usb_mode
operator|=
name|USB_MODE_DEVICE
block|, 	}
block|,
index|[
name|CFUMASS_T_DATA_IN
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
name|CFUMASS_BULK_SIZE
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|proxy_buffer
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,
operator|.
name|ext_buffer
operator|=
literal|1
block|}
block|,
operator|.
name|callback
operator|=
operator|&
name|cfumass_t_data_callback
block|,
operator|.
name|usb_mode
operator|=
name|USB_MODE_DEVICE
block|, 	}
block|,
index|[
name|CFUMASS_T_STATUS
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cfumass_csw_t
argument_list|)
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|}
block|,
operator|.
name|callback
operator|=
operator|&
name|cfumass_t_status_callback
block|,
operator|.
name|usb_mode
operator|=
name|USB_MODE_DEVICE
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * CTL frontend interface.  */
end_comment

begin_function_decl
specifier|static
name|int
name|cfumass_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cfumass_shutdown
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfumass_online
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfumass_offline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfumass_datamove
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfumass_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ctl_frontend
name|cfumass_frontend
init|=
block|{
operator|.
name|name
operator|=
literal|"umass"
block|,
operator|.
name|init
operator|=
name|cfumass_init
block|,
operator|.
name|shutdown
operator|=
name|cfumass_shutdown
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CTL_FRONTEND_DECLARE
argument_list|(
name|ctlcfumass
argument_list|,
name|cfumass_frontend
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CFUMASS_DEBUG
parameter_list|(
name|S
parameter_list|,
name|X
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {								\ 		if (debug> 1) {					\ 			device_printf(S->sc_dev, "%s: " X "\n",		\ 			    __func__, ## __VA_ARGS__);			\ 		}							\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|CFUMASS_WARN
parameter_list|(
name|S
parameter_list|,
name|X
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {								\ 		if (debug> 0) {					\ 			device_printf(S->sc_dev, "WARNING: %s: " X "\n",\ 			    __func__, ## __VA_ARGS__);			\ 		}							\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|CFUMASS_LOCK
parameter_list|(
name|X
parameter_list|)
value|mtx_lock(&X->sc_mtx)
end_define

begin_define
define|#
directive|define
name|CFUMASS_UNLOCK
parameter_list|(
name|X
parameter_list|)
value|mtx_unlock(&X->sc_mtx)
end_define

begin_function_decl
specifier|static
name|void
name|cfumass_transfer_start
parameter_list|(
name|struct
name|cfumass_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|xfer_index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfumass_terminate
parameter_list|(
name|struct
name|cfumass_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|cfumass_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
decl_stmt|;
name|struct
name|usb_interface_descriptor
modifier|*
name|id
decl_stmt|;
name|uaa
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_DEVICE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Check for a compliant device. 	 */
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|==
name|NULL
operator|)
operator|||
operator|(
name|id
operator|->
name|bInterfaceClass
operator|!=
name|UICLASS_MASS
operator|)
operator|||
operator|(
name|id
operator|->
name|bInterfaceSubClass
operator|!=
name|UISUBCLASS_SCSI
operator|)
operator|||
operator|(
name|id
operator|->
name|bInterfaceProtocol
operator|!=
name|UIPROTO_MASS_BBB
operator|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|BUS_PROBE_GENERIC
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfumass_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cfumass_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|uaa
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"go"
argument_list|)
expr_stmt|;
name|usbd_set_power_mode
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|USB_POWER_MODE_SAVE
argument_list|)
expr_stmt|;
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|"cfumass"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|refcount_acquire
argument_list|(
operator|&
name|cfumass_refcount
argument_list|)
expr_stmt|;
name|error
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|,
name|sc
operator|->
name|sc_xfer
argument_list|,
name|cfumass_config
argument_list|,
name|CFUMASS_T_MAX
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|CFUMASS_WARN
argument_list|(
name|sc
argument_list|,
literal|"usbd_transfer_setup() failed: %s"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|refcount_release
argument_list|(
operator|&
name|cfumass_refcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_cbw
operator|=
name|usbd_xfer_get_frame_buffer
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|CFUMASS_T_COMMAND
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_csw
operator|=
name|usbd_xfer_get_frame_buffer
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|CFUMASS_T_STATUS
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ctl_initid
operator|=
name|ctl_add_initiator
argument_list|(
operator|&
name|cfumass_port
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ctl_initid
operator|<
literal|0
condition|)
block|{
name|CFUMASS_WARN
argument_list|(
name|sc
argument_list|,
literal|"ctl_add_initiator() failed with error %d"
argument_list|,
name|sc
operator|->
name|sc_ctl_initid
argument_list|)
expr_stmt|;
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|CFUMASS_T_MAX
argument_list|)
expr_stmt|;
name|refcount_release
argument_list|(
operator|&
name|cfumass_refcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|refcount_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_queued
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CFUMASS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cfumass_transfer_start
argument_list|(
name|sc
argument_list|,
name|CFUMASS_T_COMMAND
argument_list|)
expr_stmt|;
name|CFUMASS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfumass_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cfumass_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"go"
argument_list|)
expr_stmt|;
name|CFUMASS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cfumass_terminate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CFUMASS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|CFUMASS_T_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ctl_initid
operator|!=
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|ctl_remove_initiator
argument_list|(
operator|&
name|cfumass_port
argument_list|,
name|sc
operator|->
name|sc_ctl_initid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|CFUMASS_WARN
argument_list|(
name|sc
argument_list|,
literal|"ctl_remove_initiator() failed "
literal|"with error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ctl_initid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|refcount_release
argument_list|(
operator|&
name|cfumass_refcount
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfumass_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cfumass_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"go"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfumass_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cfumass_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"go"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfumass_transfer_start
parameter_list|(
name|struct
name|cfumass_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|xfer_index
parameter_list|)
block|{
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|xfer_index
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfumass_transfer_stop_and_drain
parameter_list|(
name|struct
name|cfumass_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|xfer_index
parameter_list|)
block|{
name|usbd_transfer_stop
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|xfer_index
index|]
argument_list|)
expr_stmt|;
name|CFUMASS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|usbd_transfer_drain
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|xfer_index
index|]
argument_list|)
expr_stmt|;
name|CFUMASS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfumass_terminate
parameter_list|(
name|struct
name|cfumass_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|last
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cfumass_transfer_stop_and_drain
argument_list|(
name|sc
argument_list|,
name|CFUMASS_T_COMMAND
argument_list|)
expr_stmt|;
name|cfumass_transfer_stop_and_drain
argument_list|(
name|sc
argument_list|,
name|CFUMASS_T_DATA_IN
argument_list|)
expr_stmt|;
name|cfumass_transfer_stop_and_drain
argument_list|(
name|sc
argument_list|,
name|CFUMASS_T_DATA_OUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ctl_io
operator|!=
name|NULL
condition|)
block|{
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"terminating CTL transfer"
argument_list|)
expr_stmt|;
name|ctl_set_data_phase_error
argument_list|(
operator|&
name|sc
operator|->
name|sc_ctl_io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ctl_io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|sc
operator|->
name|sc_ctl_io
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ctl_io
operator|=
name|NULL
expr_stmt|;
block|}
name|cfumass_transfer_stop_and_drain
argument_list|(
name|sc
argument_list|,
name|CFUMASS_T_STATUS
argument_list|)
expr_stmt|;
name|refcount_acquire
argument_list|(
operator|&
name|sc
operator|->
name|sc_queued
argument_list|)
expr_stmt|;
name|last
operator|=
name|refcount_release
argument_list|(
operator|&
name|sc
operator|->
name|sc_queued
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|!=
literal|0
condition|)
break|break;
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"%d CTL tasks pending"
argument_list|,
name|sc
operator|->
name|sc_queued
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
name|__DEVOLATILE
argument_list|(
name|void
operator|*
argument_list|,
operator|&
name|sc
operator|->
name|sc_queued
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"cfumass_reset"
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cfumass_handle_request
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|void
modifier|*
name|preq
parameter_list|,
name|void
modifier|*
modifier|*
name|pptr
parameter_list|,
name|uint16_t
modifier|*
name|plen
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|pstate
parameter_list|)
block|{
specifier|static
name|uint8_t
name|max_lun_tmp
decl_stmt|;
name|struct
name|cfumass_softc
modifier|*
name|sc
decl_stmt|;
specifier|const
name|struct
name|usb_device_request
modifier|*
name|req
decl_stmt|;
name|uint8_t
name|is_complete
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|req
operator|=
name|preq
expr_stmt|;
name|is_complete
operator|=
operator|*
name|pstate
expr_stmt|;
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"go"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_complete
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|req
operator|->
name|bmRequestType
operator|==
name|UT_WRITE_CLASS_INTERFACE
operator|)
operator|&&
operator|(
name|req
operator|->
name|bRequest
operator|==
name|UR_RESET
operator|)
condition|)
block|{
name|CFUMASS_WARN
argument_list|(
name|sc
argument_list|,
literal|"received Bulk-Only Mass Storage Reset"
argument_list|)
expr_stmt|;
operator|*
name|plen
operator|=
literal|0
expr_stmt|;
name|CFUMASS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cfumass_terminate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cfumass_transfer_start
argument_list|(
name|sc
argument_list|,
name|CFUMASS_T_COMMAND
argument_list|)
expr_stmt|;
name|CFUMASS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"Bulk-Only Mass Storage Reset done"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|req
operator|->
name|bmRequestType
operator|==
name|UT_READ_CLASS_INTERFACE
operator|)
operator|&&
operator|(
name|req
operator|->
name|bRequest
operator|==
name|UR_GET_MAX_LUN
operator|)
condition|)
block|{
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"received Get Max LUN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
operator|*
name|plen
operator|=
literal|1
expr_stmt|;
comment|/* 			 * The protocol doesn't support LUN numbers higher 			 * than 15.  Also, some initiators (namely Windows XP 			 * SP3 Version 2002) can't properly query the number 			 * of LUNs, resulting in inaccessible "fake" ones - thus 			 * the default limit of one LUN. 			 */
if|if
condition|(
name|max_lun
operator|<
literal|0
operator|||
name|max_lun
operator|>
literal|15
condition|)
block|{
name|CFUMASS_WARN
argument_list|(
name|sc
argument_list|,
literal|"invalid hw.usb.cfumass.max_lun, must be "
literal|"between 0 and 15; defaulting to 0"
argument_list|)
expr_stmt|;
name|max_lun_tmp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|max_lun_tmp
operator|=
name|max_lun
expr_stmt|;
block|}
operator|*
name|pptr
operator|=
operator|&
name|max_lun_tmp
expr_stmt|;
block|}
else|else
block|{
operator|*
name|plen
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfumass_quirk
parameter_list|(
name|struct
name|cfumass_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|char
modifier|*
name|cdb
parameter_list|,
name|int
name|cdb_len
parameter_list|)
block|{
name|struct
name|scsi_start_stop_unit
modifier|*
name|sssu
decl_stmt|;
switch|switch
condition|(
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|START_STOP_UNIT
case|:
comment|/* 		 * Some initiators - eg OSX, Darwin Kernel Version 15.6.0, 		 * root:xnu-3248.60.11~2/RELEASE_X86_64 - attempt to stop 		 * the unit on eject, but fail to start it when it's plugged 		 * back.  Just ignore the command. 		 */
if|if
condition|(
name|cdb_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sssu
argument_list|)
condition|)
block|{
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"received START STOP UNIT with "
literal|"bCDBLength %d, should be %zd"
argument_list|,
name|cdb_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sssu
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|sssu
operator|=
operator|(
expr|struct
name|scsi_start_stop_unit
operator|*
operator|)
name|cdb
expr_stmt|;
if|if
condition|(
operator|(
name|sssu
operator|->
name|how
operator|&
name|SSS_PC_MASK
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|sssu
operator|->
name|how
operator|&
name|SSS_START
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|sssu
operator|->
name|how
operator|&
name|SSS_LOEJ
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|ignore_stop
operator|==
literal|0
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|ignore_stop
operator|==
literal|1
condition|)
block|{
name|CFUMASS_WARN
argument_list|(
name|sc
argument_list|,
literal|"ignoring START STOP UNIT request"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"ignoring START STOP UNIT request"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_current_status
operator|=
literal|0
expr_stmt|;
name|cfumass_transfer_start
argument_list|(
name|sc
argument_list|,
name|CFUMASS_T_STATUS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfumass_t_command_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|usb_error
parameter_list|)
block|{
name|struct
name|cfumass_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|signature
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_ctl_io
operator|==
name|NULL
argument_list|,
operator|(
literal|"sc_ctl_io is %p, should be NULL"
operator|,
name|sc
operator|->
name|sc_ctl_io
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"USB_ST_TRANSFERRED"
argument_list|)
expr_stmt|;
name|signature
operator|=
name|UGETDW
argument_list|(
name|sc
operator|->
name|sc_cbw
operator|->
name|dCBWSignature
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
operator|!=
name|CBWSIGNATURE
condition|)
block|{
name|CFUMASS_WARN
argument_list|(
name|sc
argument_list|,
literal|"wrong dCBWSignature 0x%08x, "
literal|"should be 0x%08x"
argument_list|,
name|signature
argument_list|,
name|CBWSIGNATURE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_cbw
operator|->
name|bCDBLength
operator|<=
literal|0
operator|||
name|sc
operator|->
name|sc_cbw
operator|->
name|bCDBLength
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCB
argument_list|)
condition|)
block|{
name|CFUMASS_WARN
argument_list|(
name|sc
argument_list|,
literal|"invalid bCDBLength %d, should be<= %zd"
argument_list|,
name|sc
operator|->
name|sc_cbw
operator|->
name|bCDBLength
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCB
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_current_stalled
operator|=
name|false
expr_stmt|;
name|sc
operator|->
name|sc_current_status
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_current_tag
operator|=
name|UGETDW
argument_list|(
name|sc
operator|->
name|sc_cbw
operator|->
name|dCBWTag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_current_transfer_length
operator|=
name|UGETDW
argument_list|(
name|sc
operator|->
name|sc_cbw
operator|->
name|dCBWDataTransferLength
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_current_flags
operator|=
name|sc
operator|->
name|sc_cbw
operator|->
name|bCBWFlags
expr_stmt|;
comment|/* 		 * Make sure to report proper residue if the datamove wasn't 		 * required, or wasn't called due to SCSI error. 		 */
name|sc
operator|->
name|sc_current_residue
operator|=
name|sc
operator|->
name|sc_current_transfer_length
expr_stmt|;
if|if
condition|(
name|cfumass_quirk
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCB
argument_list|,
name|sc
operator|->
name|sc_cbw
operator|->
name|bCDBLength
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|cfumass_port_online
condition|)
block|{
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"cfumass port is offline; stalling"
argument_list|)
expr_stmt|;
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Those CTL functions cannot be called with mutex held. 		 */
name|CFUMASS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|io
operator|=
name|ctl_alloc_io
argument_list|(
name|cfumass_port
operator|.
name|ctl_pool_ref
argument_list|)
expr_stmt|;
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
operator|=
name|sc
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_SCSI
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|=
name|sc
operator|->
name|sc_ctl_initid
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|cfumass_port
operator|.
name|targ_port
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|ctl_decode_lun
argument_list|(
name|sc
operator|->
name|sc_cbw
operator|->
name|bCBWLUN
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|tag_num
operator|=
name|UGETDW
argument_list|(
name|sc
operator|->
name|sc_cbw
operator|->
name|dCBWTag
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_UNTAGGED
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|cdb_len
operator|=
name|sc
operator|->
name|sc_cbw
operator|->
name|bCDBLength
expr_stmt|;
name|memcpy
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|,
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCB
argument_list|,
name|sc
operator|->
name|sc_cbw
operator|->
name|bCDBLength
argument_list|)
expr_stmt|;
name|refcount_acquire
argument_list|(
operator|&
name|sc
operator|->
name|sc_queued
argument_list|)
expr_stmt|;
name|error
operator|=
name|ctl_queue
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|CTL_RETVAL_COMPLETE
condition|)
block|{
name|CFUMASS_WARN
argument_list|(
name|sc
argument_list|,
literal|"ctl_queue() failed; error %d; stalling"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|refcount_release
argument_list|(
operator|&
name|sc
operator|->
name|sc_queued
argument_list|)
expr_stmt|;
name|CFUMASS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
block|}
name|CFUMASS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"USB_ST_SETUP"
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|sc_cbw
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|usb_error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"USB_ERR_CANCELLED"
argument_list|)
expr_stmt|;
break|break;
block|}
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"USB_ST_ERROR: %s"
argument_list|,
name|usbd_errstr
argument_list|(
name|usb_error
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cfumass_t_data_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|usb_error
parameter_list|)
block|{
name|struct
name|cfumass_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
init|=
name|sc
operator|->
name|sc_ctl_io
decl_stmt|;
name|uint32_t
name|max_bulk
decl_stmt|;
name|struct
name|ctl_sg_entry
name|sg_entry
decl_stmt|,
modifier|*
name|sglist
decl_stmt|;
name|int
name|actlen
decl_stmt|,
name|sumlen
decl_stmt|,
name|sg_count
decl_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"USB_ST_TRANSFERRED"
argument_list|)
expr_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
operator|&
name|sumlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_current_residue
operator|-=
name|actlen
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|+=
name|actlen
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
operator|-=
name|actlen
expr_stmt|;
if|if
condition|(
name|actlen
operator|<
name|sumlen
operator|||
name|sc
operator|->
name|sc_current_residue
operator|==
literal|0
operator|||
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_ctl_io
operator|=
name|NULL
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"USB_ST_SETUP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|>
literal|0
condition|)
block|{
name|sglist
operator|=
operator|(
expr|struct
name|ctl_sg_entry
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
name|sg_count
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
expr_stmt|;
block|}
else|else
block|{
name|sglist
operator|=
operator|&
name|sg_entry
expr_stmt|;
name|sglist
operator|->
name|addr
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
name|sglist
operator|->
name|len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
expr_stmt|;
name|sg_count
operator|=
literal|1
expr_stmt|;
block|}
name|sumlen
operator|=
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|-
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
expr_stmt|;
while|while
condition|(
name|sumlen
operator|>=
name|sglist
operator|->
name|len
operator|&&
name|sg_count
operator|>
literal|0
condition|)
block|{
name|sumlen
operator|-=
name|sglist
operator|->
name|len
expr_stmt|;
name|sglist
operator|++
expr_stmt|;
name|sg_count
operator|--
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|sg_count
operator|>
literal|0
argument_list|,
operator|(
literal|"Run out of S/G list entries"
operator|)
argument_list|)
expr_stmt|;
name|max_bulk
operator|=
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|actlen
operator|=
name|min
argument_list|(
name|sglist
operator|->
name|len
operator|-
name|sumlen
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
name|actlen
operator|=
name|min
argument_list|(
name|actlen
argument_list|,
name|sc
operator|->
name|sc_current_transfer_length
operator|-
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
argument_list|)
expr_stmt|;
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"requested %d, done %d, max_bulk %d, "
literal|"segment %zd => transfer %d"
argument_list|,
name|sc
operator|->
name|sc_current_transfer_length
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
argument_list|,
name|max_bulk
argument_list|,
name|sglist
operator|->
name|len
operator|-
name|sumlen
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|sglist
operator|->
name|addr
operator|+
name|sumlen
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|usb_error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"USB_ERR_CANCELLED"
argument_list|)
expr_stmt|;
break|break;
block|}
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"USB_ST_ERROR: %s"
argument_list|,
name|usbd_errstr
argument_list|(
name|usb_error
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cfumass_t_status_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|usb_error
parameter_list|)
block|{
name|struct
name|cfumass_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_ctl_io
operator|==
name|NULL
argument_list|,
operator|(
literal|"sc_ctl_io is %p, should be NULL"
operator|,
name|sc
operator|->
name|sc_ctl_io
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"USB_ST_TRANSFERRED"
argument_list|)
expr_stmt|;
name|cfumass_transfer_start
argument_list|(
name|sc
argument_list|,
name|CFUMASS_T_COMMAND
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"USB_ST_SETUP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_current_residue
operator|>
literal|0
operator|&&
operator|!
name|sc
operator|->
name|sc_current_stalled
condition|)
block|{
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"non-zero residue, stalling"
argument_list|)
expr_stmt|;
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_current_stalled
operator|=
name|true
expr_stmt|;
block|}
name|USETDW
argument_list|(
name|sc
operator|->
name|sc_csw
operator|->
name|dCSWSignature
argument_list|,
name|CSWSIGNATURE
argument_list|)
expr_stmt|;
name|USETDW
argument_list|(
name|sc
operator|->
name|sc_csw
operator|->
name|dCSWTag
argument_list|,
name|sc
operator|->
name|sc_current_tag
argument_list|)
expr_stmt|;
name|USETDW
argument_list|(
name|sc
operator|->
name|sc_csw
operator|->
name|dCSWDataResidue
argument_list|,
name|sc
operator|->
name|sc_current_residue
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_csw
operator|->
name|bCSWStatus
operator|=
name|sc
operator|->
name|sc_current_status
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|sc_csw
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|usb_error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"USB_ERR_CANCELLED"
argument_list|)
expr_stmt|;
break|break;
block|}
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"USB_ST_ERROR: %s"
argument_list|,
name|usbd_errstr
argument_list|(
name|usb_error
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cfumass_online
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|cfumass_port_online
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfumass_offline
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|cfumass_port_online
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfumass_datamove
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|cfumass_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
expr_stmt|;
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"go"
argument_list|)
expr_stmt|;
name|CFUMASS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_ctl_io
operator|==
name|NULL
argument_list|,
operator|(
literal|"sc_ctl_io is %p, should be NULL"
operator|,
name|sc
operator|->
name|sc_ctl_io
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ctl_io
operator|=
name|io
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
condition|)
block|{
comment|/* 		 * Verify that CTL wants us to send the data in the direction 		 * expected by the initiator. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_current_flags
operator|!=
name|CBWFLAGS_IN
condition|)
block|{
name|CFUMASS_WARN
argument_list|(
name|sc
argument_list|,
literal|"wrong bCBWFlags 0x%x, should be 0x%x"
argument_list|,
name|sc
operator|->
name|sc_current_flags
argument_list|,
name|CBWFLAGS_IN
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|cfumass_transfer_start
argument_list|(
name|sc
argument_list|,
name|CFUMASS_T_DATA_IN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_current_flags
operator|!=
name|CBWFLAGS_OUT
condition|)
block|{
name|CFUMASS_WARN
argument_list|(
name|sc
argument_list|,
literal|"wrong bCBWFlags 0x%x, should be 0x%x"
argument_list|,
name|sc
operator|->
name|sc_current_flags
argument_list|,
name|CBWFLAGS_OUT
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|cfumass_transfer_start
argument_list|(
name|sc
argument_list|,
name|CFUMASS_T_DATA_OUT
argument_list|)
expr_stmt|;
block|}
name|CFUMASS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|ctl_set_data_phase_error
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ctl_io
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfumass_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|cfumass_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
expr_stmt|;
name|CFUMASS_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"go"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
operator|)
argument_list|,
operator|(
literal|"invalid CTL status %#x"
operator|,
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_ctl_io
operator|==
name|NULL
argument_list|,
operator|(
literal|"sc_ctl_io is %p, should be NULL"
operator|,
name|sc
operator|->
name|sc_ctl_io
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_TASK
operator|&&
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|==
name|CTL_TASK_I_T_NEXUS_RESET
condition|)
block|{
comment|/* 		 * Implicit task termination has just completed; nothing to do. 		 */
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Do not return status for aborted commands. 	 * There are exceptions, but none supported by CTL yet. 	 */
if|if
condition|(
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT_STATUS
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_STATUS_SENT
operator|)
condition|)
block|{
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SUCCESS
condition|)
name|sc
operator|->
name|sc_current_status
operator|=
literal|0
expr_stmt|;
else|else
name|sc
operator|->
name|sc_current_status
operator|=
literal|1
expr_stmt|;
comment|/* XXX: How should we report BUSY, RESERVATION CONFLICT, etc? */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SCSI_ERROR
operator|&&
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
operator|==
name|SCSI_STATUS_CHECK_COND
condition|)
name|ctl_queue_sense
argument_list|(
name|io
argument_list|)
expr_stmt|;
else|else
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|CFUMASS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cfumass_transfer_start
argument_list|(
name|sc
argument_list|,
name|CFUMASS_T_STATUS
argument_list|)
expr_stmt|;
name|CFUMASS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|refcount_release
argument_list|(
operator|&
name|sc
operator|->
name|sc_queued
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cfumass_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|cfumass_port
operator|.
name|frontend
operator|=
operator|&
name|cfumass_frontend
expr_stmt|;
name|cfumass_port
operator|.
name|port_type
operator|=
name|CTL_PORT_UMASS
expr_stmt|;
name|cfumass_port
operator|.
name|num_requested_ctl_io
operator|=
literal|1
expr_stmt|;
name|cfumass_port
operator|.
name|port_name
operator|=
literal|"cfumass"
expr_stmt|;
name|cfumass_port
operator|.
name|physical_port
operator|=
literal|0
expr_stmt|;
name|cfumass_port
operator|.
name|virtual_port
operator|=
literal|0
expr_stmt|;
name|cfumass_port
operator|.
name|port_online
operator|=
name|cfumass_online
expr_stmt|;
name|cfumass_port
operator|.
name|port_offline
operator|=
name|cfumass_offline
expr_stmt|;
name|cfumass_port
operator|.
name|onoff_arg
operator|=
name|NULL
expr_stmt|;
name|cfumass_port
operator|.
name|fe_datamove
operator|=
name|cfumass_datamove
expr_stmt|;
name|cfumass_port
operator|.
name|fe_done
operator|=
name|cfumass_done
expr_stmt|;
name|cfumass_port
operator|.
name|targ_port
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|ctl_port_register
argument_list|(
operator|&
name|cfumass_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ctl_port_register() failed "
literal|"with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|cfumass_port_online
operator|=
name|true
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|cfumass_refcount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfumass_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|cfumass_refcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: still have %u attachments; "
literal|"returning EBUSY\n"
argument_list|,
name|__func__
argument_list|,
name|cfumass_refcount
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|error
operator|=
name|ctl_port_deregister
argument_list|(
operator|&
name|cfumass_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ctl_port_deregister() failed "
literal|"with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

