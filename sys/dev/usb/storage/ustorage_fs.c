begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (C) 2003-2005 Alan Stern  * Copyright (C) 2008 Hans Petter Selasky  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The names of the above-listed copyright holders may not be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS  * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * NOTE: Much of the SCSI statemachine handling code derives from the  * Linux USB gadget stack.  */
end_comment

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_include
include|#
directive|include
file|"usb_if.h"
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|ustorage_fs_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ustorage_fs_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|ustorage_fs
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB ustorage_fs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_ustorage_fs
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ustorage_fs_debug
argument_list|,
literal|0
argument_list|,
literal|"ustorage_fs debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define some limits */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USTORAGE_FS_BULK_SIZE
end_ifndef

begin_define
define|#
directive|define
name|USTORAGE_FS_BULK_SIZE
value|(1U<< 17)
end_define

begin_comment
comment|/* bytes */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USTORAGE_FS_MAX_LUN
end_ifndef

begin_define
define|#
directive|define
name|USTORAGE_FS_MAX_LUN
value|8
end_define

begin_comment
comment|/* units */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USTORAGE_QDATA_MAX
end_ifndef

begin_define
define|#
directive|define
name|USTORAGE_QDATA_MAX
value|40
end_define

begin_comment
comment|/* bytes */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The SCSI ID string must be exactly 28 characters long  * exluding the terminating zero.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USTORAGE_FS_ID_STRING
end_ifndef

begin_define
define|#
directive|define
name|USTORAGE_FS_ID_STRING
define|\
value|"FreeBSD "
comment|/* 8 */
value|\ 	"File-Stor Gadget"
comment|/* 16 */
value|\ 	"0101"
end_define

begin_comment
comment|/* 4 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The following macro defines the number of  * sectors to be allocated for the RAM disk:  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USTORAGE_FS_RAM_SECT
end_ifndef

begin_define
define|#
directive|define
name|USTORAGE_FS_RAM_SECT
value|(1UL<< 13)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|uint8_t
modifier|*
name|ustorage_fs_ramdisk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* USB transfer definitions */
end_comment

begin_define
define|#
directive|define
name|USTORAGE_FS_T_BBB_COMMAND
value|0
end_define

begin_define
define|#
directive|define
name|USTORAGE_FS_T_BBB_DATA_DUMP
value|1
end_define

begin_define
define|#
directive|define
name|USTORAGE_FS_T_BBB_DATA_READ
value|2
end_define

begin_define
define|#
directive|define
name|USTORAGE_FS_T_BBB_DATA_WRITE
value|3
end_define

begin_define
define|#
directive|define
name|USTORAGE_FS_T_BBB_STATUS
value|4
end_define

begin_define
define|#
directive|define
name|USTORAGE_FS_T_BBB_MAX
value|5
end_define

begin_comment
comment|/* USB data stage direction */
end_comment

begin_define
define|#
directive|define
name|DIR_NONE
value|0
end_define

begin_define
define|#
directive|define
name|DIR_READ
value|1
end_define

begin_define
define|#
directive|define
name|DIR_WRITE
value|2
end_define

begin_comment
comment|/* USB interface specific control request */
end_comment

begin_define
define|#
directive|define
name|UR_BBB_RESET
value|0xff
end_define

begin_comment
comment|/* Bulk-Only reset */
end_comment

begin_define
define|#
directive|define
name|UR_BBB_GET_MAX_LUN
value|0xfe
end_define

begin_comment
comment|/* Get maximum lun */
end_comment

begin_comment
comment|/* Command Block Wrapper */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uDWord
name|dCBWSignature
decl_stmt|;
define|#
directive|define
name|CBWSIGNATURE
value|0x43425355
name|uDWord
name|dCBWTag
decl_stmt|;
name|uDWord
name|dCBWDataTransferLength
decl_stmt|;
name|uByte
name|bCBWFlags
decl_stmt|;
define|#
directive|define
name|CBWFLAGS_OUT
value|0x00
define|#
directive|define
name|CBWFLAGS_IN
value|0x80
name|uByte
name|bCBWLUN
decl_stmt|;
name|uByte
name|bCDBLength
decl_stmt|;
define|#
directive|define
name|CBWCDBLENGTH
value|16
name|uByte
name|CBWCDB
index|[
name|CBWCDBLENGTH
index|]
decl_stmt|;
block|}
name|__packed
name|ustorage_fs_bbb_cbw_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|USTORAGE_FS_BBB_CBW_SIZE
value|31
end_define

begin_comment
comment|/* Command Status Wrapper */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uDWord
name|dCSWSignature
decl_stmt|;
define|#
directive|define
name|CSWSIGNATURE
value|0x53425355
name|uDWord
name|dCSWTag
decl_stmt|;
name|uDWord
name|dCSWDataResidue
decl_stmt|;
name|uByte
name|bCSWStatus
decl_stmt|;
define|#
directive|define
name|CSWSTATUS_GOOD
value|0x0
define|#
directive|define
name|CSWSTATUS_FAILED
value|0x1
define|#
directive|define
name|CSWSTATUS_PHASE
value|0x2
block|}
name|__packed
name|ustorage_fs_bbb_csw_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|USTORAGE_FS_BBB_CSW_SIZE
value|13
end_define

begin_struct
struct|struct
name|ustorage_fs_lun
block|{
name|uint8_t
modifier|*
name|memory_image
decl_stmt|;
name|uint32_t
name|num_sectors
decl_stmt|;
name|uint32_t
name|sense_data
decl_stmt|;
name|uint32_t
name|sense_data_info
decl_stmt|;
name|uint32_t
name|unit_attention_data
decl_stmt|;
name|uint8_t
name|read_only
range|:
literal|1
decl_stmt|;
name|uint8_t
name|prevent_medium_removal
range|:
literal|1
decl_stmt|;
name|uint8_t
name|info_valid
range|:
literal|1
decl_stmt|;
name|uint8_t
name|removable
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ustorage_fs_softc
block|{
name|ustorage_fs_bbb_cbw_t
modifier|*
name|sc_cbw
decl_stmt|;
comment|/* Command Wrapper Block */
name|ustorage_fs_bbb_csw_t
modifier|*
name|sc_csw
decl_stmt|;
comment|/* Command Status Block */
name|void
modifier|*
name|sc_dma_ptr
decl_stmt|;
comment|/* Main data buffer */
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
name|struct
name|ustorage_fs_lun
name|sc_lun
index|[
name|USTORAGE_FS_MAX_LUN
index|]
decl_stmt|;
struct|struct
block|{
name|uint8_t
modifier|*
name|data_ptr
decl_stmt|;
name|struct
name|ustorage_fs_lun
modifier|*
name|currlun
decl_stmt|;
name|uint32_t
name|data_rem
decl_stmt|;
comment|/* bytes, as reported by the command 					 * block wrapper */
name|uint32_t
name|offset
decl_stmt|;
comment|/* bytes */
name|uint8_t
name|cbw_dir
decl_stmt|;
name|uint8_t
name|cmd_dir
decl_stmt|;
name|uint8_t
name|lun
decl_stmt|;
name|uint8_t
name|cmd_len
decl_stmt|;
name|uint8_t
name|data_short
range|:
literal|1
decl_stmt|;
name|uint8_t
name|data_error
range|:
literal|1
decl_stmt|;
block|}
name|sc_transfer
struct|;
name|device_t
name|sc_dev
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|sc_udev
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|sc_xfer
index|[
name|USTORAGE_FS_T_BBB_MAX
index|]
decl_stmt|;
name|uint8_t
name|sc_iface_no
decl_stmt|;
comment|/* interface number */
name|uint8_t
name|sc_last_lun
decl_stmt|;
name|uint8_t
name|sc_last_xfer_index
decl_stmt|;
name|uint8_t
name|sc_qdata
index|[
name|USTORAGE_QDATA_MAX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* prototypes */
end_comment

begin_decl_stmt
specifier|static
name|device_probe_t
name|ustorage_fs_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|ustorage_fs_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|ustorage_fs_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_suspend_t
name|ustorage_fs_suspend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_resume_t
name|ustorage_fs_resume
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_handle_request_t
name|ustorage_fs_handle_request
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|ustorage_fs_t_bbb_command_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|ustorage_fs_t_bbb_data_dump_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|ustorage_fs_t_bbb_data_read_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|ustorage_fs_t_bbb_data_write_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|ustorage_fs_t_bbb_status_callback
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ustorage_fs_transfer_start
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|xfer_index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ustorage_fs_transfer_stop
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ustorage_fs_verify
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ustorage_fs_inquiry
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ustorage_fs_request_sense
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ustorage_fs_read_capacity
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ustorage_fs_mode_sense
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ustorage_fs_start_stop
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ustorage_fs_prevent_allow
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ustorage_fs_read_format_capacities
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ustorage_fs_mode_select
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ustorage_fs_min_len
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ustorage_fs_read
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ustorage_fs_write
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ustorage_fs_check_cmd
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|cmd_size
parameter_list|,
name|uint16_t
name|mask
parameter_list|,
name|uint8_t
name|needs_medium
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ustorage_fs_do_cmd
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|ustorage_fs_methods
index|[]
init|=
block|{
comment|/* USB interface */
name|DEVMETHOD
argument_list|(
name|usb_handle_request
argument_list|,
name|ustorage_fs_handle_request
argument_list|)
block|,
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ustorage_fs_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ustorage_fs_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ustorage_fs_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|ustorage_fs_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ustorage_fs_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ustorage_fs_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"ustorage_fs"
block|,
operator|.
name|methods
operator|=
name|ustorage_fs_methods
block|,
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ustorage_fs_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ustorage_fs_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ustorage_fs
argument_list|,
name|uhub
argument_list|,
name|ustorage_fs_driver
argument_list|,
name|ustorage_fs_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ustorage_fs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ustorage_fs
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|usb_config
name|ustorage_fs_bbb_config
index|[
name|USTORAGE_FS_T_BBB_MAX
index|]
init|=
block|{
index|[
name|USTORAGE_FS_T_BBB_COMMAND
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
name|ustorage_fs_bbb_cbw_t
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|ustorage_fs_t_bbb_command_callback
block|,
operator|.
name|usb_mode
operator|=
name|USB_MODE_DEVICE
block|, 	}
block|,
index|[
name|USTORAGE_FS_T_BBB_DATA_DUMP
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use wMaxPacketSize */
operator|.
name|flags
operator|=
block|{
operator|.
name|proxy_buffer
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|callback
operator|=
operator|&
name|ustorage_fs_t_bbb_data_dump_callback
block|,
operator|.
name|usb_mode
operator|=
name|USB_MODE_DEVICE
block|, 	}
block|,
index|[
name|USTORAGE_FS_T_BBB_DATA_READ
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
name|USTORAGE_FS_BULK_SIZE
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|proxy_buffer
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|}
block|,
operator|.
name|callback
operator|=
operator|&
name|ustorage_fs_t_bbb_data_read_callback
block|,
operator|.
name|usb_mode
operator|=
name|USB_MODE_DEVICE
block|, 	}
block|,
index|[
name|USTORAGE_FS_T_BBB_DATA_WRITE
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
name|USTORAGE_FS_BULK_SIZE
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|proxy_buffer
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,
operator|.
name|ext_buffer
operator|=
literal|1
block|}
block|,
operator|.
name|callback
operator|=
operator|&
name|ustorage_fs_t_bbb_data_write_callback
block|,
operator|.
name|usb_mode
operator|=
name|USB_MODE_DEVICE
block|, 	}
block|,
index|[
name|USTORAGE_FS_T_BBB_STATUS
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
name|ustorage_fs_bbb_csw_t
argument_list|)
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|}
block|,
operator|.
name|callback
operator|=
operator|&
name|ustorage_fs_t_bbb_status_callback
block|,
operator|.
name|usb_mode
operator|=
name|USB_MODE_DEVICE
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * USB device probe/attach/detach  */
end_comment

begin_function
specifier|static
name|int
name|ustorage_fs_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_interface_descriptor
modifier|*
name|id
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_DEVICE
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Check for a standards compliant device */
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|==
name|NULL
operator|)
operator|||
operator|(
name|id
operator|->
name|bInterfaceClass
operator|!=
name|UICLASS_MASS
operator|)
operator|||
operator|(
name|id
operator|->
name|bInterfaceSubClass
operator|!=
name|UISUBCLASS_SCSI
operator|)
operator|||
operator|(
name|id
operator|->
name|bInterfaceProtocol
operator|!=
name|UIPROTO_MASS_BBB
operator|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|BUS_PROBE_GENERIC
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ustorage_fs_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_interface_descriptor
modifier|*
name|id
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * NOTE: the softc struct is cleared in device_set_driver. 	 * We can safely call ustorage_fs_detach without specifically 	 * initializing the struct. 	 */
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* enable power saving mode */
name|usbd_set_power_mode
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|USB_POWER_MODE_SAVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ustorage_fs_ramdisk
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * allocate a memory image for our ramdisk until 			 * further 			 */
name|ustorage_fs_ramdisk
operator|=
name|malloc
argument_list|(
name|USTORAGE_FS_RAM_SECT
operator|<<
literal|9
argument_list|,
name|M_USB
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ustorage_fs_ramdisk
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|sc_lun
index|[
literal|0
index|]
operator|.
name|memory_image
operator|=
name|ustorage_fs_ramdisk
expr_stmt|;
name|sc
operator|->
name|sc_lun
index|[
literal|0
index|]
operator|.
name|num_sectors
operator|=
name|USTORAGE_FS_RAM_SECT
expr_stmt|;
name|sc
operator|->
name|sc_lun
index|[
literal|0
index|]
operator|.
name|removable
operator|=
literal|1
expr_stmt|;
block|}
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|"USTORAGE_FS lock"
argument_list|,
name|NULL
argument_list|,
operator|(
name|MTX_DEF
operator||
name|MTX_RECURSE
operator|)
argument_list|)
expr_stmt|;
comment|/* get interface index */
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to get "
literal|"interface number\n"
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|sc
operator|->
name|sc_iface_no
operator|=
name|id
operator|->
name|bInterfaceNumber
expr_stmt|;
name|err
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|,
name|sc
operator|->
name|sc_xfer
argument_list|,
name|ustorage_fs_bbb_config
argument_list|,
name|USTORAGE_FS_T_BBB_MAX
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup required "
literal|"transfers, %s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|sc
operator|->
name|sc_cbw
operator|=
name|usbd_xfer_get_frame_buffer
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|USTORAGE_FS_T_BBB_COMMAND
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_csw
operator|=
name|usbd_xfer_get_frame_buffer
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|USTORAGE_FS_T_BBB_STATUS
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dma_ptr
operator|=
name|usbd_xfer_get_frame_buffer
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|USTORAGE_FS_T_BBB_DATA_READ
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* start Mass Storage State Machine */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|ustorage_fs_transfer_start
argument_list|(
name|sc
argument_list|,
name|USTORAGE_FS_T_BBB_COMMAND
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
name|detach
label|:
name|ustorage_fs_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* failure */
block|}
end_function

begin_function
specifier|static
name|int
name|ustorage_fs_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* teardown our statemachine */
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|USTORAGE_FS_T_BBB_MAX
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|int
name|ustorage_fs_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"suspending\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|int
name|ustorage_fs_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"resuming\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/*  * Generic functions to handle transfers  */
end_comment

begin_function
specifier|static
name|void
name|ustorage_fs_transfer_start
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|xfer_index
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_xfer
index|[
name|xfer_index
index|]
condition|)
block|{
name|sc
operator|->
name|sc_last_xfer_index
operator|=
name|xfer_index
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|xfer_index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ustorage_fs_transfer_stop
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|usbd_transfer_stop
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|sc
operator|->
name|sc_last_xfer_index
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|usbd_transfer_drain
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|sc
operator|->
name|sc_last_xfer_index
index|]
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ustorage_fs_handle_request
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|void
modifier|*
name|preq
parameter_list|,
name|void
modifier|*
modifier|*
name|pptr
parameter_list|,
name|uint16_t
modifier|*
name|plen
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|pstate
parameter_list|)
block|{
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|usb_device_request
modifier|*
name|req
init|=
name|preq
decl_stmt|;
name|uint8_t
name|is_complete
init|=
operator|*
name|pstate
decl_stmt|;
if|if
condition|(
operator|!
name|is_complete
condition|)
block|{
if|if
condition|(
operator|(
name|req
operator|->
name|bmRequestType
operator|==
name|UT_WRITE_CLASS_INTERFACE
operator|)
operator|&&
operator|(
name|req
operator|->
name|bRequest
operator|==
name|UR_BBB_RESET
operator|)
condition|)
block|{
operator|*
name|plen
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|ustorage_fs_transfer_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
operator|=
literal|1
expr_stmt|;
name|ustorage_fs_transfer_start
argument_list|(
name|sc
argument_list|,
name|USTORAGE_FS_T_BBB_COMMAND
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|req
operator|->
name|bmRequestType
operator|==
name|UT_READ_CLASS_INTERFACE
operator|)
operator|&&
operator|(
name|req
operator|->
name|bRequest
operator|==
name|UR_BBB_GET_MAX_LUN
operator|)
condition|)
block|{
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
operator|*
name|plen
operator|=
literal|1
expr_stmt|;
operator|*
name|pptr
operator|=
operator|&
name|sc
operator|->
name|sc_last_lun
expr_stmt|;
block|}
else|else
block|{
operator|*
name|plen
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* use builtin handler */
block|}
end_function

begin_function
specifier|static
name|void
name|ustorage_fs_t_bbb_command_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|uint32_t
name|tag
decl_stmt|;
name|uint8_t
name|err
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|tag
operator|=
name|UGETDW
argument_list|(
name|sc
operator|->
name|sc_cbw
operator|->
name|dCBWSignature
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|CBWSIGNATURE
condition|)
block|{
comment|/* do nothing */
name|DPRINTF
argument_list|(
literal|"invalid signature 0x%08x\n"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
break|break;
block|}
name|tag
operator|=
name|UGETDW
argument_list|(
name|sc
operator|->
name|sc_cbw
operator|->
name|dCBWTag
argument_list|)
expr_stmt|;
comment|/* echo back tag */
name|USETDW
argument_list|(
name|sc
operator|->
name|sc_csw
operator|->
name|dCSWTag
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* reset status */
name|sc
operator|->
name|sc_csw
operator|->
name|bCSWStatus
operator|=
literal|0
expr_stmt|;
comment|/* reset data offset, data length and data remainder */
name|sc
operator|->
name|sc_transfer
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|=
name|UGETDW
argument_list|(
name|sc
operator|->
name|sc_cbw
operator|->
name|dCBWDataTransferLength
argument_list|)
expr_stmt|;
comment|/* reset data flags */
name|sc
operator|->
name|sc_transfer
operator|.
name|data_short
operator|=
literal|0
expr_stmt|;
comment|/* extract LUN */
name|sc
operator|->
name|sc_transfer
operator|.
name|lun
operator|=
name|sc
operator|->
name|sc_cbw
operator|->
name|bCBWLUN
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_transfer
operator|.
name|cbw_dir
operator|=
name|DIR_NONE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_cbw
operator|->
name|bCBWFlags
operator|&
name|CBWFLAGS_IN
condition|)
block|{
name|sc
operator|->
name|sc_transfer
operator|.
name|cbw_dir
operator|=
name|DIR_WRITE
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_transfer
operator|.
name|cbw_dir
operator|=
name|DIR_READ
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
operator|=
name|sc
operator|->
name|sc_cbw
operator|->
name|bCDBLength
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
argument_list|)
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* just halt - this is invalid */
name|DPRINTF
argument_list|(
literal|"invalid command length %d bytes\n"
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|ustorage_fs_do_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* got an error */
name|DPRINTF
argument_list|(
literal|"command failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cbw_dir
operator|!=
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|)
condition|)
block|{
comment|/* contradicting data transfer direction */
name|err
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"data direction mismatch\n"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cbw_dir
condition|)
block|{
case|case
name|DIR_READ
case|:
name|ustorage_fs_transfer_start
argument_list|(
name|sc
argument_list|,
name|USTORAGE_FS_T_BBB_DATA_READ
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIR_WRITE
case|:
name|ustorage_fs_transfer_start
argument_list|(
name|sc
argument_list|,
name|USTORAGE_FS_T_BBB_DATA_WRITE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ustorage_fs_transfer_start
argument_list|(
name|sc
argument_list|,
name|USTORAGE_FS_T_BBB_STATUS
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
condition|)
block|{
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
operator|=
literal|0
expr_stmt|;
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"stall pipe\n"
argument_list|)
expr_stmt|;
block|}
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ustorage_fs_bbb_cbw_t
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Error */
name|DPRINTF
argument_list|(
literal|"error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
break|break;
block|}
comment|/* If the pipe is already stalled, don't do another stall */
if|if
condition|(
operator|!
name|usbd_xfer_is_stalled
argument_list|(
name|xfer
argument_list|)
condition|)
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
operator|=
literal|1
expr_stmt|;
comment|/* try again */
goto|goto
name|tr_setup
goto|;
block|}
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_csw
operator|->
name|bCSWStatus
operator|==
literal|0
condition|)
block|{
comment|/* set some default error code */
name|sc
operator|->
name|sc_csw
operator|->
name|bCSWStatus
operator|=
name|CSWSTATUS_FAILED
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cbw_dir
operator|==
name|DIR_READ
condition|)
block|{
comment|/* dump all data */
name|ustorage_fs_transfer_start
argument_list|(
name|sc
argument_list|,
name|USTORAGE_FS_T_BBB_DATA_DUMP
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cbw_dir
operator|==
name|DIR_WRITE
condition|)
block|{
comment|/* need to stall before status */
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
operator|=
literal|1
expr_stmt|;
block|}
name|ustorage_fs_transfer_start
argument_list|(
name|sc
argument_list|,
name|USTORAGE_FS_T_BBB_STATUS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ustorage_fs_t_bbb_data_dump_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|uint32_t
name|max_bulk
init|=
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|int
name|actlen
decl_stmt|,
name|sumlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
operator|&
name|sumlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|-=
name|actlen
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|offset
operator|+=
name|actlen
expr_stmt|;
if|if
condition|(
name|actlen
operator|!=
name|sumlen
operator|||
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|==
literal|0
condition|)
block|{
comment|/* short transfer or end of data */
name|ustorage_fs_transfer_start
argument_list|(
name|sc
argument_list|,
name|USTORAGE_FS_T_BBB_STATUS
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fallthrough */
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
if|if
condition|(
name|max_bulk
operator|>
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
condition|)
block|{
name|max_bulk
operator|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
condition|)
block|{
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
operator|=
literal|0
expr_stmt|;
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Error */
if|if
condition|(
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
break|break;
block|}
comment|/* 		 * If the pipe is already stalled, don't do another stall: 		 */
if|if
condition|(
operator|!
name|usbd_xfer_is_stalled
argument_list|(
name|xfer
argument_list|)
condition|)
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
operator|=
literal|1
expr_stmt|;
comment|/* try again */
goto|goto
name|tr_setup
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ustorage_fs_t_bbb_data_read_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|uint32_t
name|max_bulk
init|=
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|int
name|actlen
decl_stmt|,
name|sumlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
operator|&
name|sumlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
comment|/* XXX copy data from DMA buffer */
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
argument_list|,
name|sc
operator|->
name|sc_dma_ptr
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|-=
name|actlen
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
operator|+=
name|actlen
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|offset
operator|+=
name|actlen
expr_stmt|;
if|if
condition|(
name|actlen
operator|!=
name|sumlen
operator|||
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|==
literal|0
condition|)
block|{
comment|/* short transfer or end of data */
name|ustorage_fs_transfer_start
argument_list|(
name|sc
argument_list|,
name|USTORAGE_FS_T_BBB_STATUS
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fallthrough */
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
if|if
condition|(
name|max_bulk
operator|>
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
condition|)
block|{
name|max_bulk
operator|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
condition|)
block|{
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
operator|=
literal|0
expr_stmt|;
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_dma_ptr
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Error */
if|if
condition|(
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
break|break;
block|}
comment|/* If the pipe is already stalled, don't do another stall */
if|if
condition|(
operator|!
name|usbd_xfer_is_stalled
argument_list|(
name|xfer
argument_list|)
condition|)
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
operator|=
literal|1
expr_stmt|;
comment|/* try again */
goto|goto
name|tr_setup
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ustorage_fs_t_bbb_data_write_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|uint32_t
name|max_bulk
init|=
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|int
name|actlen
decl_stmt|,
name|sumlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
operator|&
name|sumlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|-=
name|actlen
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
operator|+=
name|actlen
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|offset
operator|+=
name|actlen
expr_stmt|;
if|if
condition|(
name|actlen
operator|!=
name|sumlen
operator|||
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|==
literal|0
condition|)
block|{
comment|/* short transfer or end of data */
name|ustorage_fs_transfer_start
argument_list|(
name|sc
argument_list|,
name|USTORAGE_FS_T_BBB_STATUS
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
if|if
condition|(
name|max_bulk
operator|>=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
condition|)
block|{
name|max_bulk
operator|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_short
condition|)
name|usbd_xfer_set_flag
argument_list|(
name|xfer
argument_list|,
name|USB_FORCE_SHORT_XFER
argument_list|)
expr_stmt|;
else|else
name|usbd_xfer_clr_flag
argument_list|(
name|xfer
argument_list|,
name|USB_FORCE_SHORT_XFER
argument_list|)
expr_stmt|;
block|}
else|else
name|usbd_xfer_clr_flag
argument_list|(
name|xfer
argument_list|,
name|USB_FORCE_SHORT_XFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
condition|)
block|{
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
operator|=
literal|0
expr_stmt|;
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
comment|/* XXX copy data to DMA buffer */
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_dma_ptr
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_dma_ptr
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Error */
if|if
condition|(
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
break|break;
block|}
comment|/* 		 * If the pipe is already stalled, don't do another 		 * stall 		 */
if|if
condition|(
operator|!
name|usbd_xfer_is_stalled
argument_list|(
name|xfer
argument_list|)
condition|)
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
operator|=
literal|1
expr_stmt|;
comment|/* try again */
goto|goto
name|tr_setup
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ustorage_fs_t_bbb_status_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|ustorage_fs_transfer_start
argument_list|(
name|sc
argument_list|,
name|USTORAGE_FS_T_BBB_COMMAND
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
name|USETDW
argument_list|(
name|sc
operator|->
name|sc_csw
operator|->
name|dCSWSignature
argument_list|,
name|CSWSIGNATURE
argument_list|)
expr_stmt|;
name|USETDW
argument_list|(
name|sc
operator|->
name|sc_csw
operator|->
name|dCSWDataResidue
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
condition|)
block|{
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
operator|=
literal|0
expr_stmt|;
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ustorage_fs_bbb_csw_t
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
break|break;
block|}
comment|/* If the pipe is already stalled, don't do another stall */
if|if
condition|(
operator|!
name|usbd_xfer_is_stalled
argument_list|(
name|xfer
argument_list|)
condition|)
name|sc
operator|->
name|sc_transfer
operator|.
name|data_error
operator|=
literal|1
expr_stmt|;
comment|/* try again */
goto|goto
name|tr_setup
goto|;
block|}
block|}
end_function

begin_comment
comment|/* SCSI commands that we recognize */
end_comment

begin_define
define|#
directive|define
name|SC_FORMAT_UNIT
value|0x04
end_define

begin_define
define|#
directive|define
name|SC_INQUIRY
value|0x12
end_define

begin_define
define|#
directive|define
name|SC_MODE_SELECT_6
value|0x15
end_define

begin_define
define|#
directive|define
name|SC_MODE_SELECT_10
value|0x55
end_define

begin_define
define|#
directive|define
name|SC_MODE_SENSE_6
value|0x1a
end_define

begin_define
define|#
directive|define
name|SC_MODE_SENSE_10
value|0x5a
end_define

begin_define
define|#
directive|define
name|SC_PREVENT_ALLOW_MEDIUM_REMOVAL
value|0x1e
end_define

begin_define
define|#
directive|define
name|SC_READ_6
value|0x08
end_define

begin_define
define|#
directive|define
name|SC_READ_10
value|0x28
end_define

begin_define
define|#
directive|define
name|SC_READ_12
value|0xa8
end_define

begin_define
define|#
directive|define
name|SC_READ_CAPACITY
value|0x25
end_define

begin_define
define|#
directive|define
name|SC_READ_FORMAT_CAPACITIES
value|0x23
end_define

begin_define
define|#
directive|define
name|SC_RELEASE
value|0x17
end_define

begin_define
define|#
directive|define
name|SC_REQUEST_SENSE
value|0x03
end_define

begin_define
define|#
directive|define
name|SC_RESERVE
value|0x16
end_define

begin_define
define|#
directive|define
name|SC_SEND_DIAGNOSTIC
value|0x1d
end_define

begin_define
define|#
directive|define
name|SC_START_STOP_UNIT
value|0x1b
end_define

begin_define
define|#
directive|define
name|SC_SYNCHRONIZE_CACHE
value|0x35
end_define

begin_define
define|#
directive|define
name|SC_TEST_UNIT_READY
value|0x00
end_define

begin_define
define|#
directive|define
name|SC_VERIFY
value|0x2f
end_define

begin_define
define|#
directive|define
name|SC_WRITE_6
value|0x0a
end_define

begin_define
define|#
directive|define
name|SC_WRITE_10
value|0x2a
end_define

begin_define
define|#
directive|define
name|SC_WRITE_12
value|0xaa
end_define

begin_comment
comment|/* SCSI Sense Key/Additional Sense Code/ASC Qualifier values */
end_comment

begin_define
define|#
directive|define
name|SS_NO_SENSE
value|0
end_define

begin_define
define|#
directive|define
name|SS_COMMUNICATION_FAILURE
value|0x040800
end_define

begin_define
define|#
directive|define
name|SS_INVALID_COMMAND
value|0x052000
end_define

begin_define
define|#
directive|define
name|SS_INVALID_FIELD_IN_CDB
value|0x052400
end_define

begin_define
define|#
directive|define
name|SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE
value|0x052100
end_define

begin_define
define|#
directive|define
name|SS_LOGICAL_UNIT_NOT_SUPPORTED
value|0x052500
end_define

begin_define
define|#
directive|define
name|SS_MEDIUM_NOT_PRESENT
value|0x023a00
end_define

begin_define
define|#
directive|define
name|SS_MEDIUM_REMOVAL_PREVENTED
value|0x055302
end_define

begin_define
define|#
directive|define
name|SS_NOT_READY_TO_READY_TRANSITION
value|0x062800
end_define

begin_define
define|#
directive|define
name|SS_RESET_OCCURRED
value|0x062900
end_define

begin_define
define|#
directive|define
name|SS_SAVING_PARAMETERS_NOT_SUPPORTED
value|0x053900
end_define

begin_define
define|#
directive|define
name|SS_UNRECOVERED_READ_ERROR
value|0x031100
end_define

begin_define
define|#
directive|define
name|SS_WRITE_ERROR
value|0x030c02
end_define

begin_define
define|#
directive|define
name|SS_WRITE_PROTECTED
value|0x072700
end_define

begin_define
define|#
directive|define
name|SK
parameter_list|(
name|x
parameter_list|)
value|((uint8_t) ((x)>> 16))
end_define

begin_comment
comment|/* Sense Key byte, etc. */
end_comment

begin_define
define|#
directive|define
name|ASC
parameter_list|(
name|x
parameter_list|)
value|((uint8_t) ((x)>> 8))
end_define

begin_define
define|#
directive|define
name|ASCQ
parameter_list|(
name|x
parameter_list|)
value|((uint8_t) (x))
end_define

begin_comment
comment|/* Routines for unaligned data access */
end_comment

begin_function
specifier|static
name|uint16_t
name|get_be16
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
operator|(
name|uint16_t
operator|)
name|buf
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|uint16_t
operator|)
name|buf
index|[
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|get_be32
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
operator|(
name|uint32_t
operator|)
name|buf
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|buf
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|buf
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|buf
index|[
literal|3
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_be16
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_be32
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_verify  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_verify
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ustorage_fs_lun
modifier|*
name|currlun
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
decl_stmt|;
name|uint32_t
name|lba
decl_stmt|;
name|uint32_t
name|vlen
decl_stmt|;
name|uint64_t
name|file_offset
decl_stmt|;
name|uint64_t
name|amount_left
decl_stmt|;
comment|/* 	 * Get the starting Logical Block Address 	 */
name|lba
operator|=
name|get_be32
argument_list|(
operator|&
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * We allow DPO (Disable Page Out = don't save data in the cache) 	 * but we don't implement it. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|1
index|]
operator|&
operator|~
literal|0x10
operator|)
operator|!=
literal|0
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_INVALID_FIELD_IN_CDB
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|vlen
operator|=
name|get_be16
argument_list|(
operator|&
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlen
operator|==
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* No default reply */
comment|/* Prepare to carry out the file verify */
name|amount_left
operator|=
name|vlen
expr_stmt|;
name|amount_left
operator|<<=
literal|9
expr_stmt|;
name|file_offset
operator|=
name|lba
expr_stmt|;
name|file_offset
operator|<<=
literal|9
expr_stmt|;
comment|/* Range check */
name|vlen
operator|+=
name|lba
expr_stmt|;
if|if
condition|(
operator|(
name|vlen
operator|<
name|lba
operator|)
operator|||
operator|(
name|vlen
operator|>
name|currlun
operator|->
name|num_sectors
operator|)
operator|||
operator|(
name|lba
operator|>=
name|currlun
operator|->
name|num_sectors
operator|)
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* XXX TODO: verify that data is readable */
name|done
label|:
return|return
operator|(
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
operator|-
literal|1U
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_inquiry  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_inquiry
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
modifier|*
name|buf
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
decl_stmt|;
name|struct
name|ustorage_fs_lun
modifier|*
name|currlun
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
condition|)
block|{
comment|/* Unsupported LUNs are okay */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|36
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0x7f
expr_stmt|;
comment|/* Unsupported, no device - type */
return|return
operator|(
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
literal|36
argument_list|,
operator|-
literal|1U
argument_list|)
operator|)
return|;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Non - removable, direct - access device */
if|if
condition|(
name|currlun
operator|->
name|removable
condition|)
name|buf
index|[
literal|1
index|]
operator|=
literal|0x80
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|2
expr_stmt|;
comment|/* ANSI SCSI level 2 */
name|buf
index|[
literal|3
index|]
operator|=
literal|2
expr_stmt|;
comment|/* SCSI - 2 INQUIRY data format */
name|buf
index|[
literal|4
index|]
operator|=
literal|31
expr_stmt|;
comment|/* Additional length */
comment|/* No special options */
comment|/* Copy in ID string */
name|memcpy
argument_list|(
name|buf
operator|+
literal|8
argument_list|,
name|USTORAGE_FS_ID_STRING
argument_list|,
literal|28
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|USTORAGE_QDATA_MAX
operator|<
literal|36
operator|)
error|#
directive|error
literal|"(USTORAGE_QDATA_MAX< 36)"
endif|#
directive|endif
return|return
operator|(
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
literal|36
argument_list|,
operator|-
literal|1U
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_request_sense  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_request_sense
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
modifier|*
name|buf
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
decl_stmt|;
name|struct
name|ustorage_fs_lun
modifier|*
name|currlun
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
decl_stmt|;
name|uint32_t
name|sd
decl_stmt|;
name|uint32_t
name|sdinfo
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * From the SCSI-2 spec., section 7.9 (Unit attention condition): 	 * 	 * If a REQUEST SENSE command is received from an initiator 	 * with a pending unit attention condition (before the target 	 * generates the contingent allegiance condition), then the 	 * target shall either: 	 *   a) report any pending sense data and preserve the unit 	 *	attention condition on the logical unit, or, 	 *   b) report the unit attention condition, may discard any 	 *	pending sense data, and clear the unit attention 	 *	condition on the logical unit for that initiator. 	 * 	 * FSG normally uses option a); enable this code to use option b). 	 */
if|#
directive|if
literal|0
block|if (currlun&& currlun->unit_attention_data != SS_NO_SENSE) { 		currlun->sense_data = currlun->unit_attention_data; 		currlun->unit_attention_data = SS_NO_SENSE; 	}
endif|#
directive|endif
if|if
condition|(
operator|!
name|currlun
condition|)
block|{
comment|/* Unsupported LUNs are okay */
name|sd
operator|=
name|SS_LOGICAL_UNIT_NOT_SUPPORTED
expr_stmt|;
name|sdinfo
operator|=
literal|0
expr_stmt|;
name|valid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sd
operator|=
name|currlun
operator|->
name|sense_data
expr_stmt|;
name|sdinfo
operator|=
name|currlun
operator|->
name|sense_data_info
expr_stmt|;
name|valid
operator|=
name|currlun
operator|->
name|info_valid
operator|<<
literal|7
expr_stmt|;
name|currlun
operator|->
name|sense_data
operator|=
name|SS_NO_SENSE
expr_stmt|;
name|currlun
operator|->
name|sense_data_info
operator|=
literal|0
expr_stmt|;
name|currlun
operator|->
name|info_valid
operator|=
literal|0
expr_stmt|;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|valid
operator||
literal|0x70
expr_stmt|;
comment|/* Valid, current error */
name|buf
index|[
literal|2
index|]
operator|=
name|SK
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|put_be32
argument_list|(
operator|&
name|buf
index|[
literal|3
index|]
argument_list|,
name|sdinfo
argument_list|)
expr_stmt|;
comment|/* Sense information */
name|buf
index|[
literal|7
index|]
operator|=
literal|18
operator|-
literal|8
expr_stmt|;
comment|/* Additional sense length */
name|buf
index|[
literal|12
index|]
operator|=
name|ASC
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|buf
index|[
literal|13
index|]
operator|=
name|ASCQ
argument_list|(
name|sd
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|USTORAGE_QDATA_MAX
operator|<
literal|18
operator|)
error|#
directive|error
literal|"(USTORAGE_QDATA_MAX< 18)"
endif|#
directive|endif
return|return
operator|(
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
literal|18
argument_list|,
operator|-
literal|1U
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_read_capacity  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_read_capacity
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
modifier|*
name|buf
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
decl_stmt|;
name|struct
name|ustorage_fs_lun
modifier|*
name|currlun
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
decl_stmt|;
name|uint32_t
name|lba
init|=
name|get_be32
argument_list|(
operator|&
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|uint8_t
name|pmi
init|=
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|8
index|]
decl_stmt|;
comment|/* Check the PMI and LBA fields */
if|if
condition|(
operator|(
name|pmi
operator|>
literal|1
operator|)
operator|||
operator|(
operator|(
name|pmi
operator|==
literal|0
operator|)
operator|&&
operator|(
name|lba
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_INVALID_FIELD_IN_CDB
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Max logical block */
name|put_be32
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|currlun
operator|->
name|num_sectors
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Block length */
name|put_be32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|USTORAGE_QDATA_MAX
operator|<
literal|8
operator|)
error|#
directive|error
literal|"(USTORAGE_QDATA_MAX< 8)"
endif|#
directive|endif
return|return
operator|(
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
literal|8
argument_list|,
operator|-
literal|1U
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_mode_sense  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_mode_sense
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
modifier|*
name|buf
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
decl_stmt|;
name|struct
name|ustorage_fs_lun
modifier|*
name|currlun
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
decl_stmt|;
name|uint8_t
modifier|*
name|buf0
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|uint16_t
name|limit
decl_stmt|;
name|uint8_t
name|mscmnd
init|=
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|0
index|]
decl_stmt|;
name|uint8_t
name|pc
decl_stmt|;
name|uint8_t
name|page_code
decl_stmt|;
name|uint8_t
name|changeable_values
decl_stmt|;
name|uint8_t
name|all_pages
decl_stmt|;
name|buf0
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|1
index|]
operator|&
operator|~
literal|0x08
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Mask away DBD */
name|currlun
operator|->
name|sense_data
operator|=
name|SS_INVALID_FIELD_IN_CDB
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|pc
operator|=
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|2
index|]
operator|>>
literal|6
expr_stmt|;
name|page_code
operator|=
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|2
index|]
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|pc
operator|==
literal|3
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_SAVING_PARAMETERS_NOT_SUPPORTED
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|changeable_values
operator|=
operator|(
name|pc
operator|==
literal|1
operator|)
expr_stmt|;
name|all_pages
operator|=
operator|(
name|page_code
operator|==
literal|0x3f
operator|)
expr_stmt|;
comment|/* 	 * Write the mode parameter header.  Fixed values are: default 	 * medium type, no cache control (DPOFUA), and no block descriptors. 	 * The only variable value is the WriteProtect bit.  We will fill in 	 * the mode data length later. 	 */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|mscmnd
operator|==
name|SC_MODE_SENSE_6
condition|)
block|{
name|buf
index|[
literal|2
index|]
operator|=
operator|(
name|currlun
operator|->
name|read_only
condition|?
literal|0x80
else|:
literal|0x00
operator|)
expr_stmt|;
comment|/* WP, DPOFUA */
name|buf
operator|+=
literal|4
expr_stmt|;
name|limit
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
comment|/* SC_MODE_SENSE_10 */
name|buf
index|[
literal|3
index|]
operator|=
operator|(
name|currlun
operator|->
name|read_only
condition|?
literal|0x80
else|:
literal|0x00
operator|)
expr_stmt|;
comment|/* WP, DPOFUA */
name|buf
operator|+=
literal|8
expr_stmt|;
name|limit
operator|=
literal|65535
expr_stmt|;
comment|/* Should really be mod_data.buflen */
block|}
comment|/* No block descriptors */
comment|/* 	 * The mode pages, in numerical order. 	 */
if|if
condition|(
operator|(
name|page_code
operator|==
literal|0x08
operator|)
operator|||
name|all_pages
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|0x08
expr_stmt|;
comment|/* Page code */
name|buf
index|[
literal|1
index|]
operator|=
literal|10
expr_stmt|;
comment|/* Page length */
name|memset
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* None of the fields are changeable */
if|if
condition|(
operator|!
name|changeable_values
condition|)
block|{
name|buf
index|[
literal|2
index|]
operator|=
literal|0x04
expr_stmt|;
comment|/* Write cache enable, */
comment|/* Read cache not disabled */
comment|/* No cache retention priorities */
name|put_be16
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* Don 't disable prefetch */
comment|/* Minimum prefetch = 0 */
name|put_be16
argument_list|(
operator|&
name|buf
index|[
literal|8
index|]
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* Maximum prefetch */
name|put_be16
argument_list|(
operator|&
name|buf
index|[
literal|10
index|]
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* Maximum prefetch ceiling */
block|}
name|buf
operator|+=
literal|12
expr_stmt|;
block|}
comment|/* 	 * Check that a valid page was requested and the mode data length 	 * isn't too long. 	 */
name|len
operator|=
name|buf
operator|-
name|buf0
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|limit
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_INVALID_FIELD_IN_CDB
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Store the mode data length */
if|if
condition|(
name|mscmnd
operator|==
name|SC_MODE_SENSE_6
condition|)
name|buf0
index|[
literal|0
index|]
operator|=
name|len
operator|-
literal|1
expr_stmt|;
else|else
name|put_be16
argument_list|(
name|buf0
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|USTORAGE_QDATA_MAX
operator|<
literal|24
operator|)
error|#
directive|error
literal|"(USTORAGE_QDATA_MAX< 24)"
endif|#
directive|endif
return|return
operator|(
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
operator|-
literal|1U
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_start_stop  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_start_stop
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ustorage_fs_lun
modifier|*
name|currlun
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
decl_stmt|;
name|uint8_t
name|loej
decl_stmt|;
name|uint8_t
name|start
decl_stmt|;
name|uint8_t
name|immed
decl_stmt|;
if|if
condition|(
operator|!
name|currlun
operator|->
name|removable
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_INVALID_COMMAND
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|immed
operator|=
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|1
index|]
operator|&
literal|0x01
expr_stmt|;
name|loej
operator|=
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|4
index|]
operator|&
literal|0x02
expr_stmt|;
name|start
operator|=
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|4
index|]
operator|&
literal|0x01
expr_stmt|;
if|if
condition|(
name|immed
operator|||
name|loej
operator|||
name|start
condition|)
block|{
comment|/* compile fix */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_prevent_allow  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_prevent_allow
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ustorage_fs_lun
modifier|*
name|currlun
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
decl_stmt|;
name|uint8_t
name|prevent
decl_stmt|;
if|if
condition|(
operator|!
name|currlun
operator|->
name|removable
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_INVALID_COMMAND
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|prevent
operator|=
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|4
index|]
operator|&
literal|0x01
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|4
index|]
operator|&
operator|~
literal|0x01
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Mask away Prevent */
name|currlun
operator|->
name|sense_data
operator|=
name|SS_INVALID_FIELD_IN_CDB
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|currlun
operator|->
name|prevent_medium_removal
operator|&&
operator|!
name|prevent
condition|)
block|{
comment|//fsync_sub(currlun);
block|}
name|currlun
operator|->
name|prevent_medium_removal
operator|=
name|prevent
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_read_format_capacities  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_read_format_capacities
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
modifier|*
name|buf
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
decl_stmt|;
name|struct
name|ustorage_fs_lun
modifier|*
name|currlun
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|1
index|]
operator|=
name|buf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|8
expr_stmt|;
comment|/* Only the Current / Maximum Capacity Descriptor */
name|buf
operator|+=
literal|4
expr_stmt|;
comment|/* Number of blocks */
name|put_be32
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|currlun
operator|->
name|num_sectors
argument_list|)
expr_stmt|;
comment|/* Block length */
name|put_be32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/* Current capacity */
name|buf
index|[
literal|4
index|]
operator|=
literal|0x02
expr_stmt|;
if|#
directive|if
operator|(
name|USTORAGE_QDATA_MAX
operator|<
literal|12
operator|)
error|#
directive|error
literal|"(USTORAGE_QDATA_MAX< 12)"
endif|#
directive|endif
return|return
operator|(
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
literal|12
argument_list|,
operator|-
literal|1U
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_mode_select  *  * Return values:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_mode_select
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ustorage_fs_lun
modifier|*
name|currlun
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
decl_stmt|;
comment|/* We don't support MODE SELECT */
name|currlun
operator|->
name|sense_data
operator|=
name|SS_INVALID_COMMAND
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_synchronize_cache  *  * Return values:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_synchronize_cache
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct ustorage_fs_lun *currlun = sc->sc_transfer.currlun; 	uint8_t rc;
comment|/* 	 * We ignore the requested LBA and write out all dirty data buffers. 	 */
block|rc = 0; 	if (rc) { 		currlun->sense_data = SS_WRITE_ERROR; 	}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_read - read data from disk  *  * Return values:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_read
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ustorage_fs_lun
modifier|*
name|currlun
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
decl_stmt|;
name|uint64_t
name|file_offset
decl_stmt|;
name|uint32_t
name|lba
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
comment|/* 	 * Get the starting Logical Block Address and check that it's not 	 * too big 	 */
if|if
condition|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|0
index|]
operator|==
name|SC_READ_6
condition|)
block|{
name|lba
operator|=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|1
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
name|get_be16
argument_list|(
operator|&
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lba
operator|=
name|get_be32
argument_list|(
operator|&
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * We allow DPO (Disable Page Out = don't save data in the 		 * cache) and FUA (Force Unit Access = don't read from the 		 * cache), but we don't implement them. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|1
index|]
operator|&
operator|~
literal|0x18
operator|)
operator|!=
literal|0
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_INVALID_FIELD_IN_CDB
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|len
operator|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|>>
literal|9
expr_stmt|;
name|len
operator|+=
name|lba
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|<
name|lba
operator|)
operator|||
operator|(
name|len
operator|>
name|currlun
operator|->
name|num_sectors
operator|)
operator|||
operator|(
name|lba
operator|>=
name|currlun
operator|->
name|num_sectors
operator|)
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|file_offset
operator|=
name|lba
expr_stmt|;
name|file_offset
operator|<<=
literal|9
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
operator|=
name|currlun
operator|->
name|memory_image
operator|+
name|file_offset
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_write - write data to disk  *  * Return values:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_write
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ustorage_fs_lun
modifier|*
name|currlun
init|=
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
decl_stmt|;
name|uint64_t
name|file_offset
decl_stmt|;
name|uint32_t
name|lba
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
if|if
condition|(
name|currlun
operator|->
name|read_only
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_WRITE_PROTECTED
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* XXX clear SYNC */
comment|/* 	 * Get the starting Logical Block Address and check that it's not 	 * too big. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|0
index|]
operator|==
name|SC_WRITE_6
condition|)
name|lba
operator|=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|1
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
name|get_be16
argument_list|(
operator|&
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|lba
operator|=
name|get_be32
argument_list|(
operator|&
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * We allow DPO (Disable Page Out = don't save data in the 		 * cache) and FUA (Force Unit Access = write directly to the 		 * medium).  We don't implement DPO; we implement FUA by 		 * performing synchronous output. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|1
index|]
operator|&
operator|~
literal|0x18
operator|)
operator|!=
literal|0
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_INVALID_FIELD_IN_CDB
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|1
index|]
operator|&
literal|0x08
condition|)
block|{
comment|/* FUA */
comment|/* XXX set SYNC flag here */
block|}
block|}
name|len
operator|=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|>>
literal|9
expr_stmt|;
name|len
operator|+=
name|lba
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|<
name|lba
operator|)
operator|||
operator|(
name|len
operator|>
name|currlun
operator|->
name|num_sectors
operator|)
operator|||
operator|(
name|lba
operator|>=
name|currlun
operator|->
name|num_sectors
operator|)
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|file_offset
operator|=
name|lba
expr_stmt|;
name|file_offset
operator|<<=
literal|9
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
operator|=
name|currlun
operator|->
name|memory_image
operator|+
name|file_offset
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_min_len  *  * Return values:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_min_len
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
if|if
condition|(
name|len
operator|!=
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|cbw_dir
operator|==
name|DIR_READ
condition|)
block|{
comment|/* 			 * there must be something wrong about this SCSI 			 * command 			 */
name|sc
operator|->
name|sc_csw
operator|->
name|bCSWStatus
operator|=
name|CSWSTATUS_PHASE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* compute the minimum length */
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|>
name|len
condition|)
block|{
comment|/* data ends prematurely */
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|=
name|len
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_short
operator|=
literal|1
expr_stmt|;
block|}
comment|/* check length alignment */
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|&
operator|~
name|mask
condition|)
block|{
comment|/* data ends prematurely */
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
operator|&=
name|mask
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|data_short
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_check_cmd - check command routine  *  * Check whether the command is properly formed and whether its data  * size and direction agree with the values we already have.  *  * Return values:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_check_cmd
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|min_cmd_size
parameter_list|,
name|uint16_t
name|mask
parameter_list|,
name|uint8_t
name|needs_medium
parameter_list|)
block|{
name|struct
name|ustorage_fs_lun
modifier|*
name|currlun
decl_stmt|;
name|uint8_t
name|lun
init|=
operator|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|1
index|]
operator|>>
literal|5
operator|)
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
comment|/* Verify the length of the command itself */
if|if
condition|(
name|min_cmd_size
operator|>
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"%u> %u\n"
argument_list|,
name|min_cmd_size
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_csw
operator|->
name|bCSWStatus
operator|=
name|CSWSTATUS_PHASE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Mask away the LUN */
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|1
index|]
operator|&=
literal|0x1f
expr_stmt|;
comment|/* Check if LUN is correct */
if|if
condition|(
name|lun
operator|!=
name|sc
operator|->
name|sc_transfer
operator|.
name|lun
condition|)
block|{  	}
comment|/* Check the LUN */
if|if
condition|(
name|sc
operator|->
name|sc_transfer
operator|.
name|lun
operator|<=
name|sc
operator|->
name|sc_last_lun
condition|)
block|{
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
operator|=
name|currlun
operator|=
name|sc
operator|->
name|sc_lun
operator|+
name|sc
operator|->
name|sc_transfer
operator|.
name|lun
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|0
index|]
operator|!=
name|SC_REQUEST_SENSE
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_NO_SENSE
expr_stmt|;
name|currlun
operator|->
name|sense_data_info
operator|=
literal|0
expr_stmt|;
name|currlun
operator|->
name|info_valid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * If a unit attention condition exists, only INQUIRY 		 * and REQUEST SENSE commands are allowed. Anything 		 * else must fail! 		 */
if|if
condition|(
operator|(
name|currlun
operator|->
name|unit_attention_data
operator|!=
name|SS_NO_SENSE
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|0
index|]
operator|!=
name|SC_INQUIRY
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|0
index|]
operator|!=
name|SC_REQUEST_SENSE
operator|)
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|currlun
operator|->
name|unit_attention_data
expr_stmt|;
name|currlun
operator|->
name|unit_attention_data
operator|=
name|SS_NO_SENSE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
operator|=
name|currlun
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * INQUIRY and REQUEST SENSE commands are explicitly allowed 		 * to use unsupported LUNs; all others may not. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|0
index|]
operator|!=
name|SC_INQUIRY
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|0
index|]
operator|!=
name|SC_REQUEST_SENSE
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Check that only command bytes listed in the mask are 	 * non-zero. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|min_cmd_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
name|i
index|]
operator|&&
operator|!
operator|(
name|mask
operator|&
operator|(
literal|1UL
operator|<<
name|i
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|currlun
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_INVALID_FIELD_IN_CDB
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * If the medium isn't mounted and the command needs to access 	 * it, return an error. 	 */
if|if
condition|(
name|currlun
operator|&&
operator|(
operator|!
name|currlun
operator|->
name|memory_image
operator|)
operator|&&
name|needs_medium
condition|)
block|{
name|currlun
operator|->
name|sense_data
operator|=
name|SS_MEDIUM_NOT_PRESENT
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ustorage_fs_do_cmd - do command  *  * Return values:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ustorage_fs_do_cmd
parameter_list|(
name|struct
name|ustorage_fs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|error
init|=
literal|1
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
specifier|const
name|uint32_t
name|mask9
init|=
operator|(
literal|0xFFFFFFFFUL
operator|>>
literal|9
operator|)
operator|<<
literal|9
decl_stmt|;
comment|/* set default data transfer pointer */
name|sc
operator|->
name|sc_transfer
operator|.
name|data_ptr
operator|=
name|sc
operator|->
name|sc_qdata
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"cmd_data[0]=0x%02x, data_rem=0x%08x\n"
argument_list|,
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|data_rem
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SC_INQUIRY
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|=
name|DIR_WRITE
expr_stmt|;
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|4
index|]
argument_list|,
operator|-
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|,
operator|(
literal|1UL
operator|<<
literal|4
operator|)
operator||
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_inquiry
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_MODE_SELECT_6
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|=
name|DIR_READ
expr_stmt|;
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|4
index|]
argument_list|,
operator|-
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|,
operator|(
literal|1UL
operator|<<
literal|1
operator|)
operator||
operator|(
literal|1UL
operator|<<
literal|4
operator|)
operator||
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_mode_select
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_MODE_SELECT_10
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|=
name|DIR_READ
expr_stmt|;
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
name|get_be16
argument_list|(
operator|&
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|7
index|]
argument_list|)
argument_list|,
operator|-
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|10
argument_list|,
operator|(
literal|1UL
operator|<<
literal|1
operator|)
operator||
operator|(
literal|3UL
operator|<<
literal|7
operator|)
operator||
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_mode_select
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_MODE_SENSE_6
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|=
name|DIR_WRITE
expr_stmt|;
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|4
index|]
argument_list|,
operator|-
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|,
operator|(
literal|1UL
operator|<<
literal|1
operator|)
operator||
operator|(
literal|1UL
operator|<<
literal|2
operator|)
operator||
operator|(
literal|1UL
operator|<<
literal|4
operator|)
operator||
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_mode_sense
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_MODE_SENSE_10
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|=
name|DIR_WRITE
expr_stmt|;
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
name|get_be16
argument_list|(
operator|&
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|7
index|]
argument_list|)
argument_list|,
operator|-
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|10
argument_list|,
operator|(
literal|1UL
operator|<<
literal|1
operator|)
operator||
operator|(
literal|1UL
operator|<<
literal|2
operator|)
operator||
operator|(
literal|3UL
operator|<<
literal|7
operator|)
operator||
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_mode_sense
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_PREVENT_ALLOW_MEDIUM_REMOVAL
case|:
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
operator|-
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|,
operator|(
literal|1UL
operator|<<
literal|4
operator|)
operator||
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_prevent_allow
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_READ_6
case|:
name|i
operator|=
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|=
name|DIR_WRITE
expr_stmt|;
name|temp
operator|=
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
literal|256UL
else|:
name|i
operator|)
expr_stmt|;
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
name|temp
operator|<<
literal|9
argument_list|,
name|mask9
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|,
operator|(
literal|7UL
operator|<<
literal|1
operator|)
operator||
operator|(
literal|1UL
operator|<<
literal|4
operator|)
operator||
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_READ_10
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|=
name|DIR_WRITE
expr_stmt|;
name|temp
operator|=
name|get_be16
argument_list|(
operator|&
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
name|temp
operator|<<
literal|9
argument_list|,
name|mask9
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|10
argument_list|,
operator|(
literal|1UL
operator|<<
literal|1
operator|)
operator||
operator|(
literal|0xfUL
operator|<<
literal|2
operator|)
operator||
operator|(
literal|3UL
operator|<<
literal|7
operator|)
operator||
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_READ_12
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|=
name|DIR_WRITE
expr_stmt|;
name|temp
operator|=
name|get_be32
argument_list|(
operator|&
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
operator|(
literal|1UL
operator|<<
operator|(
literal|32
operator|-
literal|9
operator|)
operator|)
condition|)
block|{
comment|/* numerical overflow */
name|sc
operator|->
name|sc_csw
operator|->
name|bCSWStatus
operator|=
name|CSWSTATUS_FAILED
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
name|temp
operator|<<
literal|9
argument_list|,
name|mask9
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|12
argument_list|,
operator|(
literal|1UL
operator|<<
literal|1
operator|)
operator||
operator|(
literal|0xfUL
operator|<<
literal|2
operator|)
operator||
operator|(
literal|0xfUL
operator|<<
literal|6
operator|)
operator||
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_READ_CAPACITY
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|=
name|DIR_WRITE
expr_stmt|;
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|10
argument_list|,
operator|(
literal|0xfUL
operator|<<
literal|2
operator|)
operator||
operator|(
literal|1UL
operator|<<
literal|8
operator|)
operator||
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_read_capacity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_READ_FORMAT_CAPACITIES
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|=
name|DIR_WRITE
expr_stmt|;
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
name|get_be16
argument_list|(
operator|&
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|7
index|]
argument_list|)
argument_list|,
operator|-
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|10
argument_list|,
operator|(
literal|3UL
operator|<<
literal|7
operator|)
operator||
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_read_format_capacities
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_REQUEST_SENSE
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|=
name|DIR_WRITE
expr_stmt|;
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|4
index|]
argument_list|,
operator|-
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|,
operator|(
literal|1UL
operator|<<
literal|4
operator|)
operator||
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_request_sense
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_START_STOP_UNIT
case|:
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
operator|-
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|,
operator|(
literal|1UL
operator|<<
literal|1
operator|)
operator||
operator|(
literal|1UL
operator|<<
literal|4
operator|)
operator||
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_start_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_SYNCHRONIZE_CACHE
case|:
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
operator|-
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|10
argument_list|,
operator|(
literal|0xfUL
operator|<<
literal|2
operator|)
operator||
operator|(
literal|3UL
operator|<<
literal|7
operator|)
operator||
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_synchronize_cache
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_TEST_UNIT_READY
case|:
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
operator|-
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|,
literal|0
operator||
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Although optional, this command is used by MS-Windows. 		 * We support a minimal version: BytChk must be 0. 		 */
case|case
name|SC_VERIFY
case|:
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
operator|-
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|10
argument_list|,
operator|(
literal|1UL
operator|<<
literal|1
operator|)
operator||
operator|(
literal|0xfUL
operator|<<
literal|2
operator|)
operator||
operator|(
literal|3UL
operator|<<
literal|7
operator|)
operator||
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_verify
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_WRITE_6
case|:
name|i
operator|=
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|=
name|DIR_READ
expr_stmt|;
name|temp
operator|=
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
literal|256UL
else|:
name|i
operator|)
expr_stmt|;
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
name|temp
operator|<<
literal|9
argument_list|,
name|mask9
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|,
operator|(
literal|7UL
operator|<<
literal|1
operator|)
operator||
operator|(
literal|1UL
operator|<<
literal|4
operator|)
operator||
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_write
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_WRITE_10
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|=
name|DIR_READ
expr_stmt|;
name|temp
operator|=
name|get_be16
argument_list|(
operator|&
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
name|temp
operator|<<
literal|9
argument_list|,
name|mask9
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|10
argument_list|,
operator|(
literal|1UL
operator|<<
literal|1
operator|)
operator||
operator|(
literal|0xfUL
operator|<<
literal|2
operator|)
operator||
operator|(
literal|3UL
operator|<<
literal|7
operator|)
operator||
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_write
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_WRITE_12
case|:
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_dir
operator|=
name|DIR_READ
expr_stmt|;
name|temp
operator|=
name|get_be32
argument_list|(
operator|&
name|sc
operator|->
name|sc_cbw
operator|->
name|CBWCDB
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
operator|(
name|mask9
operator|>>
literal|9
operator|)
condition|)
block|{
comment|/* numerical overflow */
name|sc
operator|->
name|sc_csw
operator|->
name|bCSWStatus
operator|=
name|CSWSTATUS_FAILED
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
name|temp
operator|<<
literal|9
argument_list|,
name|mask9
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
literal|12
argument_list|,
operator|(
literal|1UL
operator|<<
literal|1
operator|)
operator||
operator|(
literal|0xfUL
operator|<<
literal|2
operator|)
operator||
operator|(
literal|0xfUL
operator|<<
literal|6
operator|)
operator||
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_write
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Some mandatory commands that we recognize but don't 		 * implement.  They don't mean much in this setting. 		 * It's left as an exercise for anyone interested to 		 * implement RESERVE and RELEASE in terms of Posix 		 * locks. 		 */
case|case
name|SC_FORMAT_UNIT
case|:
case|case
name|SC_RELEASE
case|:
case|case
name|SC_RESERVE
case|:
case|case
name|SC_SEND_DIAGNOSTIC
case|:
comment|/* Fallthrough */
default|default:
name|error
operator|=
name|ustorage_fs_min_len
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
operator|-
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|error
operator|=
name|ustorage_fs_check_cmd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_transfer
operator|.
name|cmd_len
argument_list|,
literal|0xff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|sc
operator|->
name|sc_transfer
operator|.
name|currlun
operator|->
name|sense_data
operator|=
name|SS_INVALID_COMMAND
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

