begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1998 The NetBSD Foundation, Inc. All rights reserved.  * Copyright (c) 1998 Lennart Augustsson. All rights reserved.  * Copyright (c) 2008 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * USB spec: http://www.usb.org/developers/docs/usbspec.zip   */
end_comment

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|uhub_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_hub.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_dynamic.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_define
define|#
directive|define
name|UHUB_INTR_INTERVAL
value|250
end_define

begin_comment
comment|/* ms */
end_comment

begin_define
define|#
directive|define
name|UHUB_N_TRANSFER
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|uhub_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|uhub
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB HUB"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_uhub
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uhub_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USB_HAVE_POWERD
end_if

begin_decl_stmt
specifier|static
name|int
name|usb_power_timeout
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* seconds */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|power_timeout
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|usb_power_timeout
argument_list|,
literal|0
argument_list|,
literal|"USB power timeout"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|uhub_current_state
block|{
name|uint16_t
name|port_change
decl_stmt|;
name|uint16_t
name|port_status
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uhub_softc
block|{
name|struct
name|uhub_current_state
name|sc_st
decl_stmt|;
comment|/* current state */
name|device_t
name|sc_dev
decl_stmt|;
comment|/* base device */
name|struct
name|usb_device
modifier|*
name|sc_udev
decl_stmt|;
comment|/* USB device */
name|struct
name|usb_xfer
modifier|*
name|sc_xfer
index|[
name|UHUB_N_TRANSFER
index|]
decl_stmt|;
comment|/* interrupt xfer */
name|uint8_t
name|sc_flags
decl_stmt|;
define|#
directive|define
name|UHUB_FLAG_DID_EXPLORE
value|0x01
name|char
name|sc_name
index|[
literal|32
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|UHUB_PROTO
parameter_list|(
name|sc
parameter_list|)
value|((sc)->sc_udev->ddesc.bDeviceProtocol)
end_define

begin_define
define|#
directive|define
name|UHUB_IS_HIGH_SPEED
parameter_list|(
name|sc
parameter_list|)
value|(UHUB_PROTO(sc) != UDPROTO_FSHUB)
end_define

begin_define
define|#
directive|define
name|UHUB_IS_SINGLE_TT
parameter_list|(
name|sc
parameter_list|)
value|(UHUB_PROTO(sc) == UDPROTO_HSHUBSTT)
end_define

begin_comment
comment|/* prototypes for type checking: */
end_comment

begin_decl_stmt
specifier|static
name|device_probe_t
name|uhub_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|uhub_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|uhub_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_suspend_t
name|uhub_suspend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_resume_t
name|uhub_resume
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_driver_added_t
name|uhub_driver_added
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_child_location_str_t
name|uhub_child_location_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_child_pnpinfo_str_t
name|uhub_child_pnpinfo_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|uhub_intr_callback
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|usb_dev_resume_peer
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_dev_suspend_peer
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|uhub_config
index|[
name|UHUB_N_TRANSFER
index|]
init|=
block|{
index|[
literal|0
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_INTERRUPT
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|timeout
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use wMaxPacketSize */
operator|.
name|callback
operator|=
operator|&
name|uhub_intr_callback
block|,
operator|.
name|interval
operator|=
name|UHUB_INTR_INTERVAL
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * driver instance for "hub" connected to "usb"  * and "hub" connected to "hub"  */
end_comment

begin_decl_stmt
specifier|static
name|devclass_t
name|uhub_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|uhub_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|uhub_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|uhub_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|uhub_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|uhub_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|uhub_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|uhub_child_location_string
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_pnpinfo_str
argument_list|,
name|uhub_child_pnpinfo_string
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|uhub_driver_added
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|uhub_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"uhub"
block|,
operator|.
name|methods
operator|=
name|uhub_methods
block|,
operator|.
name|size
operator|=
expr|sizeof
operator|(
expr|struct
name|uhub_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|uhub
argument_list|,
name|usbus
argument_list|,
name|uhub_driver
argument_list|,
name|uhub_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|uhub
argument_list|,
name|uhub
argument_list|,
name|uhub_driver
argument_list|,
name|uhub_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|uhub_intr_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|uhub_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 		 * This is an indication that some port 		 * has changed status. Notify the bus 		 * event handler thread that we need 		 * to be explored again: 		 */
name|usb_needs_explore
argument_list|(
name|sc
operator|->
name|sc_udev
operator|->
name|bus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
name|USB_ST_SETUP
case|:
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Error */
if|if
condition|(
name|xfer
operator|->
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* 			 * Do a clear-stall. The "stall_pipe" flag 			 * will get cleared before next callback by 			 * the USB stack. 			 */
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	uhub_explore_sub - subroutine  *  * Return values:  *    0: Success  * Else: A control transaction failed  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|usb_error_t
name|uhub_explore_sub
parameter_list|(
name|struct
name|uhub_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_port
modifier|*
name|up
parameter_list|)
block|{
name|struct
name|usb_bus
modifier|*
name|bus
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|child
decl_stmt|;
name|uint8_t
name|refcount
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|bus
operator|=
name|sc
operator|->
name|sc_udev
operator|->
name|bus
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
comment|/* get driver added refcount from USB bus */
name|refcount
operator|=
name|bus
operator|->
name|driver_added_refcount
expr_stmt|;
comment|/* get device assosiated with the given port */
name|child
operator|=
name|usb_bus_port_get_device
argument_list|(
name|bus
argument_list|,
name|up
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
comment|/* nothing to do */
goto|goto
name|done
goto|;
block|}
comment|/* check if probe and attach should be done */
if|if
condition|(
name|child
operator|->
name|driver_added_refcount
operator|!=
name|refcount
condition|)
block|{
name|child
operator|->
name|driver_added_refcount
operator|=
name|refcount
expr_stmt|;
name|err
operator|=
name|usb_probe_and_attach
argument_list|(
name|child
argument_list|,
name|USB_IFACE_INDEX_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
comment|/* start control transfer, if device mode */
if|if
condition|(
name|child
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
name|usbd_default_transfer_setup
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
comment|/* if a HUB becomes present, do a recursive HUB explore */
if|if
condition|(
name|child
operator|->
name|hub
condition|)
block|{
name|err
operator|=
call|(
name|child
operator|->
name|hub
operator|->
name|explore
call|)
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
name|done
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	uhub_read_port_status - factored out code  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|usb_error_t
name|uhub_read_port_status
parameter_list|(
name|struct
name|uhub_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|portno
parameter_list|)
block|{
name|struct
name|usb_port_status
name|ps
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|err
operator|=
name|usbd_req_get_port_status
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|NULL
argument_list|,
operator|&
name|ps
argument_list|,
name|portno
argument_list|)
expr_stmt|;
comment|/* update status regardless of error */
name|sc
operator|->
name|sc_st
operator|.
name|port_status
operator|=
name|UGETW
argument_list|(
name|ps
operator|.
name|wPortStatus
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_st
operator|.
name|port_change
operator|=
name|UGETW
argument_list|(
name|ps
operator|.
name|wPortChange
argument_list|)
expr_stmt|;
comment|/* debugging print */
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"port %d, wPortStatus=0x%04x, "
literal|"wPortChange=0x%04x, err=%s\n"
argument_list|,
name|portno
argument_list|,
name|sc
operator|->
name|sc_st
operator|.
name|port_status
argument_list|,
name|sc
operator|->
name|sc_st
operator|.
name|port_change
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	uhub_reattach_port  *  * Returns:  *    0: Success  * Else: A control transaction failed  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|usb_error_t
name|uhub_reattach_port
parameter_list|(
name|struct
name|uhub_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|portno
parameter_list|)
block|{
name|struct
name|usb_device
modifier|*
name|child
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|udev
decl_stmt|;
name|enum
name|usb_dev_speed
name|speed
decl_stmt|;
name|enum
name|usb_hc_mode
name|mode
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|uint8_t
name|timeout
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"reattaching port %d\n"
argument_list|,
name|portno
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|timeout
operator|=
literal|0
expr_stmt|;
name|udev
operator|=
name|sc
operator|->
name|sc_udev
expr_stmt|;
name|child
operator|=
name|usb_bus_port_get_device
argument_list|(
name|udev
operator|->
name|bus
argument_list|,
name|udev
operator|->
name|hub
operator|->
name|ports
operator|+
name|portno
operator|-
literal|1
argument_list|)
expr_stmt|;
name|repeat
label|:
comment|/* first clear the port connection change bit */
name|err
operator|=
name|usbd_req_clear_port_feature
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|portno
argument_list|,
name|UHF_C_PORT_CONNECTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* detach any existing devices */
if|if
condition|(
name|child
condition|)
block|{
name|usb_free_device
argument_list|(
name|child
argument_list|,
name|USB_UNCFG_FLAG_FREE_SUBDEV
operator||
name|USB_UNCFG_FLAG_FREE_EP0
argument_list|)
expr_stmt|;
name|child
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* get fresh status */
name|err
operator|=
name|uhub_read_port_status
argument_list|(
name|sc
argument_list|,
name|portno
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* check if nothing is connected to the port */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_st
operator|.
name|port_status
operator|&
name|UPS_CURRENT_CONNECT_STATUS
operator|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* check if there is no power on the port and print a warning */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_st
operator|.
name|port_status
operator|&
name|UPS_PORT_POWER
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"WARNING: strange, connected port %d "
literal|"has no power\n"
argument_list|,
name|portno
argument_list|)
expr_stmt|;
block|}
comment|/* check if the device is in Host Mode */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_st
operator|.
name|port_status
operator|&
name|UPS_PORT_MODE_DEVICE
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Port %d is in Host Mode\n"
argument_list|,
name|portno
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_st
operator|.
name|port_status
operator|&
name|UPS_SUSPEND
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Port %d was still "
literal|"suspended, clearing.\n"
argument_list|,
name|portno
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_req_clear_port_feature
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|NULL
argument_list|,
name|portno
argument_list|,
name|UHF_PORT_SUSPEND
argument_list|)
expr_stmt|;
block|}
comment|/* USB Host Mode */
comment|/* wait for maximum device power up time */
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_PORT_POWERUP_DELAY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reset port, which implies enabling it */
name|err
operator|=
name|usbd_req_reset_port
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|portno
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"port %d reset "
literal|"failed, error=%s\n"
argument_list|,
name|portno
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* get port status again, it might have changed during reset */
name|err
operator|=
name|uhub_read_port_status
argument_list|(
name|sc
argument_list|,
name|portno
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* check if something changed during port reset */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_st
operator|.
name|port_change
operator|&
name|UPS_C_CONNECT_STATUS
operator|)
operator|||
operator|(
operator|!
operator|(
name|sc
operator|->
name|sc_st
operator|.
name|port_status
operator|&
name|UPS_CURRENT_CONNECT_STATUS
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|timeout
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"giving up port reset "
literal|"- device vanished!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|timeout
operator|=
literal|1
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"Port %d is in Device Mode\n"
argument_list|,
name|portno
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Figure out the device speed 	 */
switch|switch
condition|(
name|udev
operator|->
name|speed
condition|)
block|{
case|case
name|USB_SPEED_HIGH
case|:
if|if
condition|(
name|sc
operator|->
name|sc_st
operator|.
name|port_status
operator|&
name|UPS_HIGH_SPEED
condition|)
name|speed
operator|=
name|USB_SPEED_HIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_st
operator|.
name|port_status
operator|&
name|UPS_LOW_SPEED
condition|)
name|speed
operator|=
name|USB_SPEED_LOW
expr_stmt|;
else|else
name|speed
operator|=
name|USB_SPEED_FULL
expr_stmt|;
break|break;
case|case
name|USB_SPEED_FULL
case|:
if|if
condition|(
name|sc
operator|->
name|sc_st
operator|.
name|port_status
operator|&
name|UPS_LOW_SPEED
condition|)
name|speed
operator|=
name|USB_SPEED_LOW
expr_stmt|;
else|else
name|speed
operator|=
name|USB_SPEED_FULL
expr_stmt|;
break|break;
case|case
name|USB_SPEED_LOW
case|:
name|speed
operator|=
name|USB_SPEED_LOW
expr_stmt|;
break|break;
default|default:
comment|/* same speed like parent */
name|speed
operator|=
name|udev
operator|->
name|speed
expr_stmt|;
break|break;
block|}
comment|/* 	 * Figure out the device mode 	 * 	 * NOTE: This part is currently FreeBSD specific. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_st
operator|.
name|port_status
operator|&
name|UPS_PORT_MODE_DEVICE
condition|)
name|mode
operator|=
name|USB_MODE_DEVICE
expr_stmt|;
else|else
name|mode
operator|=
name|USB_MODE_HOST
expr_stmt|;
comment|/* need to create a new child */
name|child
operator|=
name|usb_alloc_device
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|udev
operator|->
name|bus
argument_list|,
name|udev
argument_list|,
name|udev
operator|->
name|depth
operator|+
literal|1
argument_list|,
name|portno
operator|-
literal|1
argument_list|,
name|portno
argument_list|,
name|speed
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"could not allocate new device!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
name|error
label|:
if|if
condition|(
name|child
condition|)
block|{
name|usb_free_device
argument_list|(
name|child
argument_list|,
name|USB_UNCFG_FLAG_FREE_SUBDEV
operator||
name|USB_UNCFG_FLAG_FREE_EP0
argument_list|)
expr_stmt|;
name|child
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_st
operator|.
name|port_status
operator|&
name|UPS_PORT_ENABLED
condition|)
block|{
name|err
operator|=
name|usbd_req_clear_port_feature
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|NULL
argument_list|,
name|portno
argument_list|,
name|UHF_PORT_ENABLE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"device problem (%s), "
literal|"disabling port %d\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|,
name|portno
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	uhub_suspend_resume_port  *  * Returns:  *    0: Success  * Else: A control transaction failed  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|usb_error_t
name|uhub_suspend_resume_port
parameter_list|(
name|struct
name|uhub_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|portno
parameter_list|)
block|{
name|struct
name|usb_device
modifier|*
name|child
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|udev
decl_stmt|;
name|uint8_t
name|is_suspend
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"port %d\n"
argument_list|,
name|portno
argument_list|)
expr_stmt|;
name|udev
operator|=
name|sc
operator|->
name|sc_udev
expr_stmt|;
name|child
operator|=
name|usb_bus_port_get_device
argument_list|(
name|udev
operator|->
name|bus
argument_list|,
name|udev
operator|->
name|hub
operator|->
name|ports
operator|+
name|portno
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* first clear the port suspend change bit */
name|err
operator|=
name|usbd_req_clear_port_feature
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|portno
argument_list|,
name|UHF_C_PORT_SUSPEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"clearing suspend failed.\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* get fresh status */
name|err
operator|=
name|uhub_read_port_status
argument_list|(
name|sc
argument_list|,
name|portno
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"reading port status failed.\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* get current state */
if|if
condition|(
name|sc
operator|->
name|sc_st
operator|.
name|port_status
operator|&
name|UPS_SUSPEND
condition|)
block|{
name|is_suspend
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|is_suspend
operator|=
literal|0
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"suspended=%u\n"
argument_list|,
name|is_suspend
argument_list|)
expr_stmt|;
comment|/* do the suspend or resume */
if|if
condition|(
name|child
condition|)
block|{
comment|/* 		 * This code handle two cases: 1) Host Mode - we can only 		 * receive resume here 2) Device Mode - we can receive 		 * suspend and resume here 		 */
if|if
condition|(
name|is_suspend
operator|==
literal|0
condition|)
name|usb_dev_resume_peer
argument_list|(
name|child
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|child
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
name|usb_dev_suspend_peer
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
name|done
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	uhub_root_interrupt  *  * This function is called when a Root HUB interrupt has  * happened. "ptr" and "len" makes up the Root HUB interrupt  * packet. This function is called having the "bus_mtx" locked.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|uhub_root_intr
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ptr
parameter_list|,
name|uint8_t
name|len
parameter_list|)
block|{
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|usb_needs_explore
argument_list|(
name|bus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	uhub_explore  *  * Returns:  *     0: Success  *  Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|usb_error_t
name|uhub_explore
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb_hub
modifier|*
name|hub
decl_stmt|;
name|struct
name|uhub_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|usb_port
modifier|*
name|up
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|uint8_t
name|portno
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|hub
operator|=
name|udev
operator|->
name|hub
expr_stmt|;
name|sc
operator|=
name|hub
operator|->
name|hubsoftc
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"udev=%p addr=%d\n"
argument_list|,
name|udev
argument_list|,
name|udev
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* ignore hubs that are too deep */
if|if
condition|(
name|udev
operator|->
name|depth
operator|>
name|USB_HUB_MAX_DEPTH
condition|)
block|{
return|return
operator|(
name|USB_ERR_TOO_DEEP
operator|)
return|;
block|}
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|self_suspended
condition|)
block|{
comment|/* need to wait until the child signals resume */
name|DPRINTF
argument_list|(
literal|"Device is suspended!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|hub
operator|->
name|nports
condition|;
name|x
operator|++
control|)
block|{
name|up
operator|=
name|hub
operator|->
name|ports
operator|+
name|x
expr_stmt|;
name|portno
operator|=
name|x
operator|+
literal|1
expr_stmt|;
name|err
operator|=
name|uhub_read_port_status
argument_list|(
name|sc
argument_list|,
name|portno
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* most likely the HUB is gone */
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_st
operator|.
name|port_change
operator|&
name|UPS_C_OVERCURRENT_INDICATOR
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Overcurrent on port %u.\n"
argument_list|,
name|portno
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_req_clear_port_feature
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|portno
argument_list|,
name|UHF_C_PORT_OVER_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* most likely the HUB is gone */
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|UHUB_FLAG_DID_EXPLORE
operator|)
condition|)
block|{
comment|/* 			 * Fake a connect status change so that the 			 * status gets checked initially! 			 */
name|sc
operator|->
name|sc_st
operator|.
name|port_change
operator||=
name|UPS_C_CONNECT_STATUS
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_st
operator|.
name|port_change
operator|&
name|UPS_C_PORT_ENABLED
condition|)
block|{
name|err
operator|=
name|usbd_req_clear_port_feature
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|portno
argument_list|,
name|UHF_C_PORT_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* most likely the HUB is gone */
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_st
operator|.
name|port_change
operator|&
name|UPS_C_CONNECT_STATUS
condition|)
block|{
comment|/* 				 * Ignore the port error if the device 				 * has vanished ! 				 */
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_st
operator|.
name|port_status
operator|&
name|UPS_PORT_ENABLED
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"illegal enable change, "
literal|"port %d\n"
argument_list|,
name|portno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|up
operator|->
name|restartcnt
operator|==
name|USB_RESTART_MAX
condition|)
block|{
comment|/* XXX could try another speed ? */
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"port error, giving up "
literal|"port %d\n"
argument_list|,
name|portno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_st
operator|.
name|port_change
operator||=
name|UPS_C_CONNECT_STATUS
expr_stmt|;
name|up
operator|->
name|restartcnt
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_st
operator|.
name|port_change
operator|&
name|UPS_C_CONNECT_STATUS
condition|)
block|{
name|err
operator|=
name|uhub_reattach_port
argument_list|(
name|sc
argument_list|,
name|portno
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* most likely the HUB is gone */
break|break;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_st
operator|.
name|port_change
operator|&
name|UPS_C_SUSPEND
condition|)
block|{
name|err
operator|=
name|uhub_suspend_resume_port
argument_list|(
name|sc
argument_list|,
name|portno
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* most likely the HUB is gone */
break|break;
block|}
block|}
name|err
operator|=
name|uhub_explore_sub
argument_list|(
name|sc
argument_list|,
name|up
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* no device(s) present */
continue|continue;
block|}
comment|/* explore succeeded - reset restart counter */
name|up
operator|->
name|restartcnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* initial status checked */
name|sc
operator|->
name|sc_flags
operator||=
name|UHUB_FLAG_DID_EXPLORE
expr_stmt|;
comment|/* return success */
return|return
operator|(
name|USB_ERR_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uhub_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * The subclass for USB HUBs is ignored because it is 0 for 	 * some and 1 for others. 	 */
if|if
condition|(
operator|(
name|uaa
operator|->
name|info
operator|.
name|bConfigIndex
operator|==
literal|0
operator|)
operator|&&
operator|(
name|uaa
operator|->
name|info
operator|.
name|bDeviceClass
operator|==
name|UDCLASS_HUB
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uhub_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uhub_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|udev
init|=
name|uaa
operator|->
name|device
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|parent_hub
init|=
name|udev
operator|->
name|parent_hub
decl_stmt|;
name|struct
name|usb_hub
modifier|*
name|hub
decl_stmt|;
name|struct
name|usb_hub_descriptor
name|hubdesc
decl_stmt|;
name|uint16_t
name|pwrdly
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|uint8_t
name|nports
decl_stmt|;
name|uint8_t
name|portno
decl_stmt|;
name|uint8_t
name|removable
decl_stmt|;
name|uint8_t
name|iface_index
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|udev
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|sc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_name
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"depth=%d selfpowered=%d, parent=%p, "
literal|"parent->selfpowered=%d\n"
argument_list|,
name|udev
operator|->
name|depth
argument_list|,
name|udev
operator|->
name|flags
operator|.
name|self_powered
argument_list|,
name|parent_hub
argument_list|,
name|parent_hub
condition|?
name|parent_hub
operator|->
name|flags
operator|.
name|self_powered
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|depth
operator|>
name|USB_HUB_MAX_DEPTH
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"hub depth, %d, exceeded. HUB ignored!\n"
argument_list|,
name|USB_HUB_MAX_DEPTH
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|!
name|udev
operator|->
name|flags
operator|.
name|self_powered
operator|&&
name|parent_hub
operator|&&
operator|(
operator|!
name|parent_hub
operator|->
name|flags
operator|.
name|self_powered
operator|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"bus powered HUB connected to "
literal|"bus powered HUB. HUB ignored!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* get HUB descriptor */
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"getting HUB descriptor\n"
argument_list|)
expr_stmt|;
comment|/* assuming that there is one port */
name|err
operator|=
name|usbd_req_get_hub_descriptor
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
operator|&
name|hubdesc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nports
operator|=
name|hubdesc
operator|.
name|bNbrPorts
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
operator|(
name|nports
operator|>=
literal|8
operator|)
condition|)
block|{
comment|/* get complete HUB descriptor */
name|err
operator|=
name|usbd_req_get_hub_descriptor
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
operator|&
name|hubdesc
argument_list|,
name|nports
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"getting hub descriptor failed,"
literal|"error=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|hubdesc
operator|.
name|bNbrPorts
operator|!=
name|nports
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"number of ports changed!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|nports
operator|==
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"portless HUB!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|hub
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hub
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|hub
operator|->
name|ports
index|[
literal|0
index|]
argument_list|)
operator|*
name|nports
operator|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|hub
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|udev
operator|->
name|hub
operator|=
name|hub
expr_stmt|;
if|#
directive|if
name|USB_HAVE_TT_SUPPORT
comment|/* init FULL-speed ISOCHRONOUS schedule */
name|usbd_fs_isoc_schedule_init_all
argument_list|(
name|hub
operator|->
name|fs_isoc_schedule
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* initialize HUB structure */
name|hub
operator|->
name|hubsoftc
operator|=
name|sc
expr_stmt|;
name|hub
operator|->
name|explore
operator|=
operator|&
name|uhub_explore
expr_stmt|;
name|hub
operator|->
name|nports
operator|=
name|hubdesc
operator|.
name|bNbrPorts
expr_stmt|;
name|hub
operator|->
name|hubudev
operator|=
name|udev
expr_stmt|;
comment|/* if self powered hub, give ports maximum current */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|self_powered
condition|)
block|{
name|hub
operator|->
name|portpower
operator|=
name|USB_MAX_POWER
expr_stmt|;
block|}
else|else
block|{
name|hub
operator|->
name|portpower
operator|=
name|USB_MIN_POWER
expr_stmt|;
block|}
comment|/* set up interrupt pipe */
name|iface_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|parent_hub
operator|==
name|NULL
condition|)
block|{
comment|/* root HUB is special */
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* normal HUB */
name|err
operator|=
name|usbd_transfer_setup
argument_list|(
name|udev
argument_list|,
operator|&
name|iface_index
argument_list|,
name|sc
operator|->
name|sc_xfer
argument_list|,
name|uhub_config
argument_list|,
name|UHUB_N_TRANSFER
argument_list|,
name|sc
argument_list|,
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"cannot setup interrupt transfer, "
literal|"errstr=%s!\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* wait with power off for a while */
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_POWER_DOWN_TIME
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * To have the best chance of success we do things in the exact same 	 * order as Windoze98.  This should not be necessary, but some 	 * devices do not follow the USB specs to the letter. 	 * 	 * These are the events on the bus when a hub is attached: 	 *  Get device and config descriptors (see attach code) 	 *  Get hub descriptor (see above) 	 *  For all ports 	 *     turn on power 	 *     wait for power to become stable 	 * (all below happens in explore code) 	 *  For all ports 	 *     clear C_PORT_CONNECTION 	 *  For all ports 	 *     get port status 	 *     if device connected 	 *        wait 100 ms 	 *        turn on reset 	 *        wait 	 *        clear C_PORT_RESET 	 *        get port status 	 *        proceed with device attachment 	 */
comment|/* XXX should check for none, individual, or ganged power? */
name|removable
operator|=
literal|0
expr_stmt|;
name|pwrdly
operator|=
operator|(
operator|(
name|hubdesc
operator|.
name|bPwrOn2PwrGood
operator|*
name|UHD_PWRON_FACTOR
operator|)
operator|+
name|USB_EXTRA_POWER_UP_TIME
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|nports
condition|;
name|x
operator|++
control|)
block|{
comment|/* set up data structures */
name|struct
name|usb_port
modifier|*
name|up
init|=
name|hub
operator|->
name|ports
operator|+
name|x
decl_stmt|;
name|up
operator|->
name|device_index
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|restartcnt
operator|=
literal|0
expr_stmt|;
name|portno
operator|=
name|x
operator|+
literal|1
expr_stmt|;
comment|/* check if port is removable */
if|if
condition|(
operator|!
name|UHD_NOT_REMOV
argument_list|(
operator|&
name|hubdesc
argument_list|,
name|portno
argument_list|)
condition|)
block|{
name|removable
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
block|{
comment|/* turn the power on */
name|err
operator|=
name|usbd_req_set_port_feature
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|portno
argument_list|,
name|UHF_PORT_POWER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"port %d power on failed, %s\n"
argument_list|,
name|portno
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"turn on port %d power\n"
argument_list|,
name|portno
argument_list|)
expr_stmt|;
comment|/* wait for stable power */
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|pwrdly
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%d port%s with %d "
literal|"removable, %s powered\n"
argument_list|,
name|nports
argument_list|,
operator|(
name|nports
operator|!=
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|removable
argument_list|,
name|udev
operator|->
name|flags
operator|.
name|self_powered
condition|?
literal|"self"
else|:
literal|"bus"
argument_list|)
expr_stmt|;
comment|/* Start the interrupt endpoint, if any */
if|if
condition|(
name|sc
operator|->
name|sc_xfer
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|USB_XFER_LOCK
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|USB_XFER_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Enable automatic power save on all USB HUBs */
name|usbd_set_power_mode
argument_list|(
name|udev
argument_list|,
name|USB_POWER_MODE_SAVE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|UHUB_N_TRANSFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|hub
condition|)
block|{
name|free
argument_list|(
name|udev
operator|->
name|hub
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
name|udev
operator|->
name|hub
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called from process context when the hub is gone.  * Detach all devices on active ports.  */
end_comment

begin_function
specifier|static
name|int
name|uhub_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uhub_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_hub
modifier|*
name|hub
init|=
name|sc
operator|->
name|sc_udev
operator|->
name|hub
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|child
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
comment|/* detach all children first */
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|hub
operator|==
name|NULL
condition|)
block|{
comment|/* must be partially working */
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|hub
operator|->
name|nports
condition|;
name|x
operator|++
control|)
block|{
name|child
operator|=
name|usb_bus_port_get_device
argument_list|(
name|sc
operator|->
name|sc_udev
operator|->
name|bus
argument_list|,
name|hub
operator|->
name|ports
operator|+
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * Subdevices are not freed, because the caller of 		 * uhub_detach() will do that. 		 */
name|usb_free_device
argument_list|(
name|child
argument_list|,
name|USB_UNCFG_FLAG_FREE_EP0
argument_list|)
expr_stmt|;
block|}
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|UHUB_N_TRANSFER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hub
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_udev
operator|->
name|hub
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uhub_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Sub-devices are not suspended here! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uhub_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Sub-devices are not resumed here! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhub_driver_added
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|driver_t
modifier|*
name|driver
parameter_list|)
block|{
name|usb_needs_explore_all
argument_list|()
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|hub_result
block|{
name|struct
name|usb_device
modifier|*
name|udev
decl_stmt|;
name|uint8_t
name|portno
decl_stmt|;
name|uint8_t
name|iface_index
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|uhub_find_iface_index
parameter_list|(
name|struct
name|usb_hub
modifier|*
name|hub
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|hub_result
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|usb_interface
modifier|*
name|iface
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|udev
decl_stmt|;
name|uint8_t
name|nports
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|nports
operator|=
name|hub
operator|->
name|nports
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|nports
condition|;
name|x
operator|++
control|)
block|{
name|udev
operator|=
name|usb_bus_port_get_device
argument_list|(
name|hub
operator|->
name|hubudev
operator|->
name|bus
argument_list|,
name|hub
operator|->
name|ports
operator|+
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|udev
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|USB_IFACE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|iface
operator|=
name|usbd_get_iface
argument_list|(
name|udev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|&&
operator|(
name|iface
operator|->
name|subdev
operator|==
name|child
operator|)
condition|)
block|{
name|res
operator|->
name|iface_index
operator|=
name|i
expr_stmt|;
name|res
operator|->
name|udev
operator|=
name|udev
expr_stmt|;
name|res
operator|->
name|portno
operator|=
name|x
operator|+
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
name|res
operator|->
name|iface_index
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|udev
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|portno
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uhub_child_location_string
parameter_list|(
name|device_t
name|parent
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|uhub_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|struct
name|usb_hub
modifier|*
name|hub
init|=
name|sc
operator|->
name|sc_udev
operator|->
name|hub
decl_stmt|;
name|struct
name|hub_result
name|res
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|uhub_find_iface_index
argument_list|(
name|hub
argument_list|,
name|child
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
operator|.
name|udev
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"device not on hub\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"port=%u interface=%u"
argument_list|,
name|res
operator|.
name|portno
argument_list|,
name|res
operator|.
name|iface_index
argument_list|)
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uhub_child_pnpinfo_string
parameter_list|(
name|device_t
name|parent
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|uhub_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|struct
name|usb_hub
modifier|*
name|hub
init|=
name|sc
operator|->
name|sc_udev
operator|->
name|hub
decl_stmt|;
name|struct
name|usb_interface
modifier|*
name|iface
decl_stmt|;
name|struct
name|hub_result
name|res
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|uhub_find_iface_index
argument_list|(
name|hub
argument_list|,
name|child
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
operator|.
name|udev
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"device not on hub\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|iface
operator|=
name|usbd_get_iface
argument_list|(
name|res
operator|.
name|udev
argument_list|,
name|res
operator|.
name|iface_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|&&
name|iface
operator|->
name|idesc
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"vendor=0x%04x product=0x%04x "
literal|"devclass=0x%02x devsubclass=0x%02x "
literal|"sernum=\"%s\" "
literal|"release=0x%04x "
literal|"intclass=0x%02x intsubclass=0x%02x"
argument_list|,
name|UGETW
argument_list|(
name|res
operator|.
name|udev
operator|->
name|ddesc
operator|.
name|idVendor
argument_list|)
argument_list|,
name|UGETW
argument_list|(
name|res
operator|.
name|udev
operator|->
name|ddesc
operator|.
name|idProduct
argument_list|)
argument_list|,
name|res
operator|.
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceClass
argument_list|,
name|res
operator|.
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceSubClass
argument_list|,
name|res
operator|.
name|udev
operator|->
name|serial
argument_list|,
name|UGETW
argument_list|(
name|res
operator|.
name|udev
operator|->
name|ddesc
operator|.
name|bcdDevice
argument_list|)
argument_list|,
name|iface
operator|->
name|idesc
operator|->
name|bInterfaceClass
argument_list|,
name|iface
operator|->
name|idesc
operator|->
name|bInterfaceSubClass
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|buflen
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The USB Transaction Translator:  * ===============================  *  * When doing LOW- and FULL-speed USB transfers accross a HIGH-speed  * USB HUB, bandwidth must be allocated for ISOCHRONOUS and INTERRUPT  * USB transfers. To utilize bandwidth dynamically the "scatter and  * gather" principle must be applied. This means that bandwidth must  * be divided into equal parts of bandwidth. With regard to USB all  * data is transferred in smaller packets with length  * "wMaxPacketSize". The problem however is that "wMaxPacketSize" is  * not a constant!  *  * The bandwidth scheduler which I have implemented will simply pack  * the USB transfers back to back until there is no more space in the  * schedule. Out of the 8 microframes which the USB 2.0 standard  * provides, only 6 are available for non-HIGH-speed devices. I have  * reserved the first 4 microframes for ISOCHRONOUS transfers. The  * last 2 microframes I have reserved for INTERRUPT transfers. Without  * this division, it is very difficult to allocate and free bandwidth  * dynamically.  *  * NOTE about the Transaction Translator in USB HUBs:  *  * USB HUBs have a very simple Transaction Translator, that will  * simply pipeline all the SPLIT transactions. That means that the  * transactions will be executed in the order they are queued!  *  */
end_comment

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_intr_find_best_slot  *  * Return value:  *   The best Transaction Translation slot for an interrupt endpoint.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|usb_intr_find_best_slot
parameter_list|(
name|usb_size_t
modifier|*
name|ptr
parameter_list|,
name|uint8_t
name|start
parameter_list|,
name|uint8_t
name|end
parameter_list|)
block|{
name|usb_size_t
name|max
init|=
literal|0
operator|-
literal|1
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|uint8_t
name|y
decl_stmt|;
name|y
operator|=
literal|0
expr_stmt|;
comment|/* find the last slot with lesser used bandwidth */
for|for
control|(
name|x
operator|=
name|start
init|;
name|x
operator|<
name|end
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|max
operator|>=
name|ptr
index|[
name|x
index|]
condition|)
block|{
name|max
operator|=
name|ptr
index|[
name|x
index|]
expr_stmt|;
name|y
operator|=
name|x
expr_stmt|;
block|}
block|}
return|return
operator|(
name|y
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_intr_schedule_adjust  *  * This function will update the bandwith usage for the microframe  * having index "slot" by "len" bytes. "len" can be negative.  If the  * "slot" argument is greater or equal to "USB_HS_MICRO_FRAMES_MAX"  * the "slot" argument will be replaced by the slot having least used  * bandwidth.  *  * Returns:  *   The slot on which the bandwidth update was done.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usb_intr_schedule_adjust
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|int16_t
name|len
parameter_list|,
name|uint8_t
name|slot
parameter_list|)
block|{
name|struct
name|usb_bus
modifier|*
name|bus
init|=
name|udev
operator|->
name|bus
decl_stmt|;
name|struct
name|usb_hub
modifier|*
name|hub
decl_stmt|;
name|enum
name|usb_dev_speed
name|speed
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|speed
operator|=
name|usbd_get_speed
argument_list|(
name|udev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|speed
condition|)
block|{
case|case
name|USB_SPEED_LOW
case|:
case|case
name|USB_SPEED_FULL
case|:
if|if
condition|(
name|speed
operator|==
name|USB_SPEED_LOW
condition|)
block|{
name|len
operator|*=
literal|8
expr_stmt|;
block|}
comment|/* 	         * The Host Controller Driver should have 	         * performed checks so that the lookup 	         * below does not result in a NULL pointer 	         * access. 	         */
name|hub
operator|=
name|udev
operator|->
name|parent_hs_hub
operator|->
name|hub
expr_stmt|;
if|if
condition|(
name|slot
operator|>=
name|USB_HS_MICRO_FRAMES_MAX
condition|)
block|{
name|slot
operator|=
name|usb_intr_find_best_slot
argument_list|(
name|hub
operator|->
name|uframe_usage
argument_list|,
name|USB_FS_ISOC_UFRAME_MAX
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
name|hub
operator|->
name|uframe_usage
index|[
name|slot
index|]
operator|+=
name|len
expr_stmt|;
name|bus
operator|->
name|uframe_usage
index|[
name|slot
index|]
operator|+=
name|len
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|slot
operator|>=
name|USB_HS_MICRO_FRAMES_MAX
condition|)
block|{
name|slot
operator|=
name|usb_intr_find_best_slot
argument_list|(
name|bus
operator|->
name|uframe_usage
argument_list|,
literal|0
argument_list|,
name|USB_HS_MICRO_FRAMES_MAX
argument_list|)
expr_stmt|;
block|}
name|bus
operator|->
name|uframe_usage
index|[
name|slot
index|]
operator|+=
name|len
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|slot
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_fs_isoc_schedule_init_sub  *  * This function initialises an USB FULL speed isochronous schedule  * entry.  *------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|USB_HAVE_TT_SUPPORT
end_if

begin_function
specifier|static
name|void
name|usbd_fs_isoc_schedule_init_sub
parameter_list|(
name|struct
name|usb_fs_isoc_schedule
modifier|*
name|fss
parameter_list|)
block|{
name|fss
operator|->
name|total_bytes
operator|=
operator|(
name|USB_FS_ISOC_UFRAME_MAX
operator|*
name|USB_FS_BYTES_PER_HS_UFRAME
operator|)
expr_stmt|;
name|fss
operator|->
name|frame_bytes
operator|=
operator|(
name|USB_FS_BYTES_PER_HS_UFRAME
operator|)
expr_stmt|;
name|fss
operator|->
name|frame_slot
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_fs_isoc_schedule_init_all  *  * This function will reset the complete USB FULL speed isochronous  * bandwidth schedule.  *------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|USB_HAVE_TT_SUPPORT
end_if

begin_function
name|void
name|usbd_fs_isoc_schedule_init_all
parameter_list|(
name|struct
name|usb_fs_isoc_schedule
modifier|*
name|fss
parameter_list|)
block|{
name|struct
name|usb_fs_isoc_schedule
modifier|*
name|fss_end
init|=
name|fss
operator|+
name|USB_ISOC_TIME_MAX
decl_stmt|;
while|while
condition|(
name|fss
operator|!=
name|fss_end
condition|)
block|{
name|usbd_fs_isoc_schedule_init_sub
argument_list|(
name|fss
argument_list|)
expr_stmt|;
name|fss
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_isoc_time_expand  *  * This function will expand the time counter from 7-bit to 16-bit.  *  * Returns:  *   16-bit isochronous time counter.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint16_t
name|usb_isoc_time_expand
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
name|uint16_t
name|isoc_time_curr
parameter_list|)
block|{
name|uint16_t
name|rem
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|rem
operator|=
name|bus
operator|->
name|isoc_time_last
operator|&
operator|(
name|USB_ISOC_TIME_MAX
operator|-
literal|1
operator|)
expr_stmt|;
name|isoc_time_curr
operator|&=
operator|(
name|USB_ISOC_TIME_MAX
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|isoc_time_curr
operator|<
name|rem
condition|)
block|{
comment|/* the time counter wrapped around */
name|bus
operator|->
name|isoc_time_last
operator|+=
name|USB_ISOC_TIME_MAX
expr_stmt|;
block|}
comment|/* update the remainder */
name|bus
operator|->
name|isoc_time_last
operator|&=
operator|~
operator|(
name|USB_ISOC_TIME_MAX
operator|-
literal|1
operator|)
expr_stmt|;
name|bus
operator|->
name|isoc_time_last
operator||=
name|isoc_time_curr
expr_stmt|;
return|return
operator|(
name|bus
operator|->
name|isoc_time_last
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_fs_isoc_schedule_isoc_time_expand  *  * This function does multiple things. First of all it will expand the  * passed isochronous time, which is the return value. Then it will  * store where the current FULL speed isochronous schedule is  * positioned in time and where the end is. See "pp_start" and  * "pp_end" arguments.  *  * Returns:  *   Expanded version of "isoc_time".  *  * NOTE: This function depends on being called regularly with  * intervals less than "USB_ISOC_TIME_MAX".  *------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|USB_HAVE_TT_SUPPORT
end_if

begin_function
name|uint16_t
name|usbd_fs_isoc_schedule_isoc_time_expand
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_fs_isoc_schedule
modifier|*
modifier|*
name|pp_start
parameter_list|,
name|struct
name|usb_fs_isoc_schedule
modifier|*
modifier|*
name|pp_end
parameter_list|,
name|uint16_t
name|isoc_time
parameter_list|)
block|{
name|struct
name|usb_fs_isoc_schedule
modifier|*
name|fss_end
decl_stmt|;
name|struct
name|usb_fs_isoc_schedule
modifier|*
name|fss_a
decl_stmt|;
name|struct
name|usb_fs_isoc_schedule
modifier|*
name|fss_b
decl_stmt|;
name|struct
name|usb_hub
modifier|*
name|hs_hub
decl_stmt|;
name|isoc_time
operator|=
name|usb_isoc_time_expand
argument_list|(
name|udev
operator|->
name|bus
argument_list|,
name|isoc_time
argument_list|)
expr_stmt|;
name|hs_hub
operator|=
name|udev
operator|->
name|parent_hs_hub
operator|->
name|hub
expr_stmt|;
if|if
condition|(
name|hs_hub
operator|!=
name|NULL
condition|)
block|{
name|fss_a
operator|=
name|hs_hub
operator|->
name|fs_isoc_schedule
operator|+
operator|(
name|hs_hub
operator|->
name|isoc_last_time
operator|%
name|USB_ISOC_TIME_MAX
operator|)
expr_stmt|;
name|hs_hub
operator|->
name|isoc_last_time
operator|=
name|isoc_time
expr_stmt|;
name|fss_b
operator|=
name|hs_hub
operator|->
name|fs_isoc_schedule
operator|+
operator|(
name|isoc_time
operator|%
name|USB_ISOC_TIME_MAX
operator|)
expr_stmt|;
name|fss_end
operator|=
name|hs_hub
operator|->
name|fs_isoc_schedule
operator|+
name|USB_ISOC_TIME_MAX
expr_stmt|;
operator|*
name|pp_start
operator|=
name|hs_hub
operator|->
name|fs_isoc_schedule
expr_stmt|;
operator|*
name|pp_end
operator|=
name|fss_end
expr_stmt|;
while|while
condition|(
name|fss_a
operator|!=
name|fss_b
condition|)
block|{
if|if
condition|(
name|fss_a
operator|==
name|fss_end
condition|)
block|{
name|fss_a
operator|=
name|hs_hub
operator|->
name|fs_isoc_schedule
expr_stmt|;
continue|continue;
block|}
name|usbd_fs_isoc_schedule_init_sub
argument_list|(
name|fss_a
argument_list|)
expr_stmt|;
name|fss_a
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|pp_start
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp_end
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|isoc_time
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_fs_isoc_schedule_alloc  *  * This function will allocate bandwidth for an isochronous FULL speed  * transaction in the FULL speed schedule. The microframe slot where  * the transaction should be started is stored in the byte pointed to  * by "pstart". The "len" argument specifies the length of the  * transaction in bytes.  *  * Returns:  *    0: Success  * Else: Error  *------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|USB_HAVE_TT_SUPPORT
end_if

begin_function
name|uint8_t
name|usbd_fs_isoc_schedule_alloc
parameter_list|(
name|struct
name|usb_fs_isoc_schedule
modifier|*
name|fss
parameter_list|,
name|uint8_t
modifier|*
name|pstart
parameter_list|,
name|uint16_t
name|len
parameter_list|)
block|{
name|uint8_t
name|slot
init|=
name|fss
operator|->
name|frame_slot
decl_stmt|;
comment|/* Compute overhead and bit-stuffing */
name|len
operator|+=
literal|8
expr_stmt|;
name|len
operator|*=
literal|7
expr_stmt|;
name|len
operator|/=
literal|6
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|fss
operator|->
name|total_bytes
condition|)
block|{
operator|*
name|pstart
operator|=
literal|0
expr_stmt|;
comment|/* set some dummy value */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* error */
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|fss
operator|->
name|total_bytes
operator|-=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|>=
name|fss
operator|->
name|frame_bytes
condition|)
block|{
name|len
operator|-=
name|fss
operator|->
name|frame_bytes
expr_stmt|;
name|fss
operator|->
name|frame_bytes
operator|=
name|USB_FS_BYTES_PER_HS_UFRAME
expr_stmt|;
name|fss
operator|->
name|frame_slot
operator|++
expr_stmt|;
block|}
name|fss
operator|->
name|frame_bytes
operator|-=
name|len
expr_stmt|;
block|}
operator|*
name|pstart
operator|=
name|slot
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_bus_port_get_device  *  * This function is NULL safe.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb_device
modifier|*
name|usb_bus_port_get_device
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
name|struct
name|usb_port
modifier|*
name|up
parameter_list|)
block|{
if|if
condition|(
operator|(
name|bus
operator|==
name|NULL
operator|)
operator|||
operator|(
name|up
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* be NULL safe */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|up
operator|->
name|device_index
operator|==
literal|0
condition|)
block|{
comment|/* nothing to do */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|bus
operator|->
name|devices
index|[
name|up
operator|->
name|device_index
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_bus_port_set_device  *  * This function is NULL safe.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_bus_port_set_device
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
name|struct
name|usb_port
modifier|*
name|up
parameter_list|,
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|device_index
parameter_list|)
block|{
if|if
condition|(
name|bus
operator|==
name|NULL
condition|)
block|{
comment|/* be NULL safe */
return|return;
block|}
comment|/* 	 * There is only one case where we don't 	 * have an USB port, and that is the Root Hub!          */
if|if
condition|(
name|up
condition|)
block|{
if|if
condition|(
name|udev
condition|)
block|{
name|up
operator|->
name|device_index
operator|=
name|device_index
expr_stmt|;
block|}
else|else
block|{
name|device_index
operator|=
name|up
operator|->
name|device_index
expr_stmt|;
name|up
operator|->
name|device_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Make relationships to our new device 	 */
if|if
condition|(
name|device_index
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|USB_HAVE_UGEN
name|mtx_lock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bus
operator|->
name|devices
index|[
name|device_index
index|]
operator|=
name|udev
expr_stmt|;
if|#
directive|if
name|USB_HAVE_UGEN
name|mtx_unlock
argument_list|(
operator|&
name|usb_ref_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Debug print 	 */
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"bus %p devices[%u] = %p\n"
argument_list|,
name|bus
argument_list|,
name|device_index
argument_list|,
name|udev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_needs_explore  *  * This functions is called when the USB event thread needs to run.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_needs_explore
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
name|uint8_t
name|do_probe
parameter_list|)
block|{
name|uint8_t
name|do_unlock
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"No bus pointer!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|bus
operator|->
name|devices
operator|==
name|NULL
operator|)
operator|||
operator|(
name|bus
operator|->
name|devices
index|[
name|USB_ROOT_HUB_ADDR
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"No root HUB\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|bus
operator|->
name|bus_mtx
argument_list|)
condition|)
block|{
name|do_unlock
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|do_unlock
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|do_probe
condition|)
block|{
name|bus
operator|->
name|do_probe
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|usb_proc_msignal
argument_list|(
operator|&
name|bus
operator|->
name|explore_proc
argument_list|,
operator|&
name|bus
operator|->
name|explore_msg
index|[
literal|0
index|]
argument_list|,
operator|&
name|bus
operator|->
name|explore_msg
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* ignore */
block|}
if|if
condition|(
name|do_unlock
condition|)
block|{
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_needs_explore_all  *  * This function is called whenever a new driver is loaded and will  * cause that all USB busses are re-explored.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_needs_explore_all
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|usb_bus
modifier|*
name|bus
decl_stmt|;
name|devclass_t
name|dc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|max
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|dc
operator|=
name|usb_devclass_ptr
expr_stmt|;
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"no devclass\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Explore all USB busses in parallell. 	 */
name|max
operator|=
name|devclass_get_maxunit
argument_list|(
name|dc
argument_list|)
expr_stmt|;
while|while
condition|(
name|max
operator|>=
literal|0
condition|)
block|{
name|dev
operator|=
name|devclass_get_device
argument_list|(
name|dc
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
name|bus
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
condition|)
block|{
name|usb_needs_explore
argument_list|(
name|bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|max
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_bus_power_update  *  * This function will ensure that all USB devices on the given bus are  * properly suspended or resumed according to the device transfer  * state.  *------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|USB_HAVE_POWERD
end_if

begin_function
name|void
name|usb_bus_power_update
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|)
block|{
name|usb_needs_explore
argument_list|(
name|bus
argument_list|,
literal|0
comment|/* no probe */
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_power_ref  *  * This function will modify the power save reference counts and  * wakeup the USB device associated with the given USB transfer, if  * needed.  *------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|USB_HAVE_POWERD
end_if

begin_function
name|void
name|usbd_transfer_power_ref
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|int
name|val
parameter_list|)
block|{
specifier|static
specifier|const
name|usb_power_mask_t
name|power_mask
index|[
literal|4
index|]
init|=
block|{
index|[
name|UE_CONTROL
index|]
operator|=
name|USB_HW_POWER_CONTROL
block|,
index|[
name|UE_BULK
index|]
operator|=
name|USB_HW_POWER_BULK
block|,
index|[
name|UE_INTERRUPT
index|]
operator|=
name|USB_HW_POWER_INTERRUPT
block|,
index|[
name|UE_ISOCHRONOUS
index|]
operator|=
name|USB_HW_POWER_ISOC
block|, 	}
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|udev
decl_stmt|;
name|uint8_t
name|needs_explore
decl_stmt|;
name|uint8_t
name|needs_hw_power
decl_stmt|;
name|uint8_t
name|xfer_type
decl_stmt|;
name|udev
operator|=
name|xfer
operator|->
name|xroot
operator|->
name|udev
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|device_index
operator|==
name|USB_ROOT_HUB_ADDR
condition|)
block|{
comment|/* no power save for root HUB */
return|return;
block|}
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|xfer_type
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
expr_stmt|;
name|udev
operator|->
name|pwr_save
operator|.
name|last_xfer_time
operator|=
name|ticks
expr_stmt|;
name|udev
operator|->
name|pwr_save
operator|.
name|type_refs
index|[
name|xfer_type
index|]
operator|+=
name|val
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
name|udev
operator|->
name|pwr_save
operator|.
name|read_refs
operator|+=
name|val
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|usb_mode
operator|==
name|USB_MODE_HOST
condition|)
block|{
comment|/* 			 * it is not allowed to suspend during a control 			 * transfer 			 */
name|udev
operator|->
name|pwr_save
operator|.
name|write_refs
operator|+=
name|val
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|USB_GET_DATA_ISREAD
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
name|udev
operator|->
name|pwr_save
operator|.
name|read_refs
operator|+=
name|val
expr_stmt|;
block|}
else|else
block|{
name|udev
operator|->
name|pwr_save
operator|.
name|write_refs
operator|+=
name|val
expr_stmt|;
block|}
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|self_suspended
condition|)
name|needs_explore
operator|=
operator|(
name|udev
operator|->
name|pwr_save
operator|.
name|write_refs
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|udev
operator|->
name|pwr_save
operator|.
name|read_refs
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|usb_peer_can_wakeup
argument_list|(
name|udev
argument_list|)
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
else|else
name|needs_explore
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|udev
operator|->
name|bus
operator|->
name|hw_power_state
operator|&
name|power_mask
index|[
name|xfer_type
index|]
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Adding type %u to power state\n"
argument_list|,
name|xfer_type
argument_list|)
expr_stmt|;
name|udev
operator|->
name|bus
operator|->
name|hw_power_state
operator||=
name|power_mask
index|[
name|xfer_type
index|]
expr_stmt|;
name|needs_hw_power
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|needs_hw_power
operator|=
literal|0
expr_stmt|;
block|}
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_explore
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"update\n"
argument_list|)
expr_stmt|;
name|usb_bus_power_update
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|needs_hw_power
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"needs power\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|set_hw_power
operator|!=
name|NULL
condition|)
block|{
call|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|set_hw_power
call|)
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_bus_powerd  *  * This function implements the USB power daemon and is called  * regularly from the USB explore thread.  *------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|USB_HAVE_POWERD
end_if

begin_function
name|void
name|usb_bus_powerd
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|usb_device
modifier|*
name|udev
decl_stmt|;
name|usb_ticks_t
name|temp
decl_stmt|;
name|usb_ticks_t
name|limit
decl_stmt|;
name|usb_ticks_t
name|mintime
decl_stmt|;
name|usb_size_t
name|type_refs
index|[
literal|5
index|]
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|uint8_t
name|rem_wakeup
decl_stmt|;
name|limit
operator|=
name|usb_power_timeout
expr_stmt|;
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
name|limit
operator|=
name|hz
expr_stmt|;
elseif|else
if|if
condition|(
name|limit
operator|>
literal|255
condition|)
name|limit
operator|=
literal|255
operator|*
name|hz
expr_stmt|;
else|else
name|limit
operator|=
name|limit
operator|*
name|hz
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"bus=%p\n"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/* 	 * The root HUB device is never suspended 	 * and we simply skip it. 	 */
for|for
control|(
name|x
operator|=
name|USB_ROOT_HUB_ADDR
operator|+
literal|1
init|;
name|x
operator|!=
name|bus
operator|->
name|devices_max
condition|;
name|x
operator|++
control|)
block|{
name|udev
operator|=
name|bus
operator|->
name|devices
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
continue|continue;
name|rem_wakeup
operator|=
name|usb_peer_can_wakeup
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|temp
operator|=
name|ticks
operator|-
name|udev
operator|->
name|pwr_save
operator|.
name|last_xfer_time
expr_stmt|;
if|if
condition|(
operator|(
name|udev
operator|->
name|power_mode
operator|==
name|USB_POWER_MODE_ON
operator|)
operator|||
operator|(
name|udev
operator|->
name|pwr_save
operator|.
name|type_refs
index|[
name|UE_ISOCHRONOUS
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|udev
operator|->
name|pwr_save
operator|.
name|write_refs
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|udev
operator|->
name|pwr_save
operator|.
name|read_refs
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rem_wakeup
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* check if we are suspended */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|self_suspended
operator|!=
literal|0
condition|)
block|{
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|usb_dev_resume_peer
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|temp
operator|>=
name|limit
condition|)
block|{
comment|/* check if we are not suspended */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|self_suspended
operator|==
literal|0
condition|)
block|{
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|usb_dev_suspend_peer
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* reset counters */
name|mintime
operator|=
literal|0
operator|-
literal|1
expr_stmt|;
name|type_refs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|type_refs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|type_refs
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|type_refs
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|type_refs
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Re-loop all the devices to get the actual state */
for|for
control|(
name|x
operator|=
name|USB_ROOT_HUB_ADDR
operator|+
literal|1
init|;
name|x
operator|!=
name|bus
operator|->
name|devices_max
condition|;
name|x
operator|++
control|)
block|{
name|udev
operator|=
name|bus
operator|->
name|devices
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
continue|continue;
comment|/* we found a non-Root-Hub USB device */
name|type_refs
index|[
literal|4
index|]
operator|+=
literal|1
expr_stmt|;
comment|/* "last_xfer_time" can be updated by a resume */
name|temp
operator|=
name|ticks
operator|-
name|udev
operator|->
name|pwr_save
operator|.
name|last_xfer_time
expr_stmt|;
comment|/* 		 * Compute minimum time since last transfer for the complete 		 * bus: 		 */
if|if
condition|(
name|temp
operator|<
name|mintime
condition|)
name|mintime
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|self_suspended
operator|==
literal|0
condition|)
block|{
name|type_refs
index|[
literal|0
index|]
operator|+=
name|udev
operator|->
name|pwr_save
operator|.
name|type_refs
index|[
literal|0
index|]
expr_stmt|;
name|type_refs
index|[
literal|1
index|]
operator|+=
name|udev
operator|->
name|pwr_save
operator|.
name|type_refs
index|[
literal|1
index|]
expr_stmt|;
name|type_refs
index|[
literal|2
index|]
operator|+=
name|udev
operator|->
name|pwr_save
operator|.
name|type_refs
index|[
literal|2
index|]
expr_stmt|;
name|type_refs
index|[
literal|3
index|]
operator|+=
name|udev
operator|->
name|pwr_save
operator|.
name|type_refs
index|[
literal|3
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mintime
operator|>=
operator|(
literal|1
operator|*
name|hz
operator|)
condition|)
block|{
comment|/* recompute power masks */
name|DPRINTF
argument_list|(
literal|"Recomputing power masks\n"
argument_list|)
expr_stmt|;
name|bus
operator|->
name|hw_power_state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type_refs
index|[
name|UE_CONTROL
index|]
operator|!=
literal|0
condition|)
name|bus
operator|->
name|hw_power_state
operator||=
name|USB_HW_POWER_CONTROL
expr_stmt|;
if|if
condition|(
name|type_refs
index|[
name|UE_BULK
index|]
operator|!=
literal|0
condition|)
name|bus
operator|->
name|hw_power_state
operator||=
name|USB_HW_POWER_BULK
expr_stmt|;
if|if
condition|(
name|type_refs
index|[
name|UE_INTERRUPT
index|]
operator|!=
literal|0
condition|)
name|bus
operator|->
name|hw_power_state
operator||=
name|USB_HW_POWER_INTERRUPT
expr_stmt|;
if|if
condition|(
name|type_refs
index|[
name|UE_ISOCHRONOUS
index|]
operator|!=
literal|0
condition|)
name|bus
operator|->
name|hw_power_state
operator||=
name|USB_HW_POWER_ISOC
expr_stmt|;
if|if
condition|(
name|type_refs
index|[
literal|4
index|]
operator|!=
literal|0
condition|)
name|bus
operator|->
name|hw_power_state
operator||=
name|USB_HW_POWER_NON_ROOT_HUB
expr_stmt|;
block|}
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|methods
operator|->
name|set_hw_power
operator|!=
name|NULL
condition|)
block|{
comment|/* always update hardware power! */
call|(
name|bus
operator|->
name|methods
operator|->
name|set_hw_power
call|)
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_dev_resume_peer  *  * This function will resume an USB peer and do the required USB  * signalling to get an USB device out of the suspended state.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_dev_resume_peer
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb_bus
modifier|*
name|bus
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* be NULL safe */
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
return|return;
comment|/* check if already resumed */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|self_suspended
operator|==
literal|0
condition|)
return|return;
comment|/* we need a parent HUB to do resume */
if|if
condition|(
name|udev
operator|->
name|parent_hub
operator|==
name|NULL
condition|)
return|return;
name|DPRINTF
argument_list|(
literal|"udev=%p\n"
argument_list|,
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
operator|)
operator|&&
operator|(
name|udev
operator|->
name|flags
operator|.
name|remote_wakeup
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * If the host did not set the remote wakeup feature, we can 		 * not wake it up either! 		 */
name|DPRINTF
argument_list|(
literal|"remote wakeup is not set!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get bus pointer */
name|bus
operator|=
name|udev
operator|->
name|bus
expr_stmt|;
comment|/* resume parent hub first */
name|usb_dev_resume_peer
argument_list|(
name|udev
operator|->
name|parent_hub
argument_list|)
expr_stmt|;
comment|/* resume current port (Valid in Host and Device Mode) */
name|err
operator|=
name|usbd_req_clear_port_feature
argument_list|(
name|udev
operator|->
name|parent_hub
argument_list|,
name|NULL
argument_list|,
name|udev
operator|->
name|port_no
argument_list|,
name|UHF_PORT_SUSPEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Resuming port failed!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* resume settle time */
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_PORT_RESUME_DELAY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|methods
operator|->
name|device_resume
operator|!=
name|NULL
condition|)
block|{
comment|/* resume USB device on the USB controller */
call|(
name|bus
operator|->
name|methods
operator|->
name|device_resume
call|)
argument_list|(
name|udev
argument_list|)
expr_stmt|;
block|}
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/* set that this device is now resumed */
name|udev
operator|->
name|flags
operator|.
name|self_suspended
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|USB_HAVE_POWERD
comment|/* make sure that we don't go into suspend right away */
name|udev
operator|->
name|pwr_save
operator|.
name|last_xfer_time
operator|=
name|ticks
expr_stmt|;
comment|/* make sure the needed power masks are on */
if|if
condition|(
name|udev
operator|->
name|pwr_save
operator|.
name|type_refs
index|[
name|UE_CONTROL
index|]
operator|!=
literal|0
condition|)
name|bus
operator|->
name|hw_power_state
operator||=
name|USB_HW_POWER_CONTROL
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|pwr_save
operator|.
name|type_refs
index|[
name|UE_BULK
index|]
operator|!=
literal|0
condition|)
name|bus
operator|->
name|hw_power_state
operator||=
name|USB_HW_POWER_BULK
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|pwr_save
operator|.
name|type_refs
index|[
name|UE_INTERRUPT
index|]
operator|!=
literal|0
condition|)
name|bus
operator|->
name|hw_power_state
operator||=
name|USB_HW_POWER_INTERRUPT
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|pwr_save
operator|.
name|type_refs
index|[
name|UE_ISOCHRONOUS
index|]
operator|!=
literal|0
condition|)
name|bus
operator|->
name|hw_power_state
operator||=
name|USB_HW_POWER_ISOC
expr_stmt|;
endif|#
directive|endif
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|methods
operator|->
name|set_hw_power
operator|!=
name|NULL
condition|)
block|{
comment|/* always update hardware power! */
call|(
name|bus
operator|->
name|methods
operator|->
name|set_hw_power
call|)
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
name|sx_xlock
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* notify all sub-devices about resume */
name|err
operator|=
name|usb_suspend_resume
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* check if peer has wakeup capability */
if|if
condition|(
name|usb_peer_can_wakeup
argument_list|(
name|udev
argument_list|)
condition|)
block|{
comment|/* clear remote wakeup */
name|err
operator|=
name|usbd_req_clear_device_feature
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|UF_DEVICE_REMOTE_WAKEUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Clearing device "
literal|"remote wakeup failed: %s!\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_dev_suspend_peer  *  * This function will suspend an USB peer and do the required USB  * signalling to get an USB device into the suspended state.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_dev_suspend_peer
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb_device
modifier|*
name|child
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|uint8_t
name|nports
decl_stmt|;
name|repeat
label|:
comment|/* be NULL safe */
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
return|return;
comment|/* check if already suspended */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|self_suspended
condition|)
return|return;
comment|/* we need a parent HUB to do suspend */
if|if
condition|(
name|udev
operator|->
name|parent_hub
operator|==
name|NULL
condition|)
return|return;
name|DPRINTF
argument_list|(
literal|"udev=%p\n"
argument_list|,
name|udev
argument_list|)
expr_stmt|;
comment|/* check if the current device is a HUB */
if|if
condition|(
name|udev
operator|->
name|hub
operator|!=
name|NULL
condition|)
block|{
name|nports
operator|=
name|udev
operator|->
name|hub
operator|->
name|nports
expr_stmt|;
comment|/* check if all devices on the HUB are suspended */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|nports
condition|;
name|x
operator|++
control|)
block|{
name|child
operator|=
name|usb_bus_port_get_device
argument_list|(
name|udev
operator|->
name|bus
argument_list|,
name|udev
operator|->
name|hub
operator|->
name|ports
operator|+
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|child
operator|->
name|flags
operator|.
name|self_suspended
condition|)
continue|continue;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
literal|"Port %u is busy on the HUB!\n"
argument_list|,
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|sx_xlock
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* notify all sub-devices about suspend */
name|err
operator|=
name|usb_suspend_resume
argument_list|(
name|udev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb_peer_can_wakeup
argument_list|(
name|udev
argument_list|)
condition|)
block|{
comment|/* allow device to do remote wakeup */
name|err
operator|=
name|usbd_req_set_device_feature
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|UF_DEVICE_REMOTE_WAKEUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Setting device "
literal|"remote wakeup failed!\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* 	 * Set that this device is suspended. This variable must be set 	 * before calling USB controller suspend callbacks. 	 */
name|udev
operator|->
name|flags
operator|.
name|self_suspended
operator|=
literal|1
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|device_suspend
operator|!=
name|NULL
condition|)
block|{
name|usb_timeout_t
name|temp
decl_stmt|;
comment|/* suspend device on the USB controller */
call|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|device_suspend
call|)
argument_list|(
name|udev
argument_list|)
expr_stmt|;
comment|/* do DMA delay */
name|temp
operator|=
name|usbd_get_dma_delay
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* suspend current port */
name|err
operator|=
name|usbd_req_set_port_feature
argument_list|(
name|udev
operator|->
name|parent_hub
argument_list|,
name|NULL
argument_list|,
name|udev
operator|->
name|port_no
argument_list|,
name|UHF_PORT_SUSPEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Suspending port failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|udev
operator|=
name|udev
operator|->
name|parent_hub
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_set_power_mode  *  * This function will set the power mode, see USB_POWER_MODE_XXX for a  * USB device.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_set_power_mode
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|power_mode
parameter_list|)
block|{
comment|/* filter input argument */
if|if
condition|(
operator|(
name|power_mode
operator|!=
name|USB_POWER_MODE_ON
operator|)
operator|&&
operator|(
name|power_mode
operator|!=
name|USB_POWER_MODE_OFF
operator|)
condition|)
block|{
name|power_mode
operator|=
name|USB_POWER_MODE_SAVE
expr_stmt|;
block|}
name|udev
operator|->
name|power_mode
operator|=
name|power_mode
expr_stmt|;
comment|/* update copy of power mode */
if|#
directive|if
name|USB_HAVE_POWERD
name|usb_bus_power_update
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

