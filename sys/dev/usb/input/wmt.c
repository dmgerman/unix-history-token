begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014-2017 Vladimir Kondratyev<wulf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * MS Windows 7/8/10 compatible USB HID Multi-touch Device driver.  * https://msdn.microsoft.com/en-us/library/windows/hardware/jj151569(v=vs.85).aspx  * https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbhid.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/quirk/usb_quirk.h>
end_include

begin_include
include|#
directive|include
file|<dev/evdev/evdev.h>
end_include

begin_include
include|#
directive|include
file|<dev/evdev/input.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|wmt_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|wmt_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|wmt
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB MSWindows 7/8/10 compatible Multi-touch Device"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_wmt
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|wmt_debug
argument_list|,
literal|1
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|WMT_BSIZE
value|1024
end_define

begin_comment
comment|/* bytes, buffer size */
end_comment

begin_enum
enum|enum
block|{
name|WMT_INTR_DT
block|,
name|WMT_N_TRANSFER
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|WMT_TIP_SWITCH
block|,
define|#
directive|define
name|WMT_SLOT
value|WMT_TIP_SWITCH
name|WMT_WIDTH
block|,
define|#
directive|define
name|WMT_MAJOR
value|WMT_WIDTH
name|WMT_HEIGHT
block|,
define|#
directive|define
name|WMT_MINOR
value|WMT_HEIGHT
name|WMT_ORIENTATION
block|,
name|WMT_X
block|,
name|WMT_Y
block|,
name|WMT_CONTACTID
block|,
name|WMT_PRESSURE
block|,
name|WMT_IN_RANGE
block|,
name|WMT_CONFIDENCE
block|,
name|WMT_TOOL_X
block|,
name|WMT_TOOL_Y
block|,
name|WMT_N_USAGES
block|, }
enum|;
end_enum

begin_define
define|#
directive|define
name|WMT_NO_CODE
value|(ABS_MAX + 10)
end_define

begin_define
define|#
directive|define
name|WMT_NO_USAGE
value|-1
end_define

begin_struct
struct|struct
name|wmt_hid_map_item
block|{
name|char
name|name
index|[
literal|5
index|]
decl_stmt|;
name|int32_t
name|usage
decl_stmt|;
comment|/* HID usage */
name|uint32_t
name|code
decl_stmt|;
comment|/* Evdev event code */
name|bool
name|required
decl_stmt|;
comment|/* Required for MT Digitizers */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|wmt_hid_map_item
name|wmt_hid_map
index|[
name|WMT_N_USAGES
index|]
init|=
block|{
index|[
name|WMT_TIP_SWITCH
index|]
operator|=
block|{
comment|/* WMT_SLOT */
operator|.
name|name
operator|=
literal|"TIP"
block|,
operator|.
name|usage
operator|=
name|HID_USAGE2
argument_list|(
name|HUP_DIGITIZERS
argument_list|,
name|HUD_TIP_SWITCH
argument_list|)
block|,
operator|.
name|code
operator|=
name|ABS_MT_SLOT
block|,
operator|.
name|required
operator|=
name|true
block|, 	}
block|,
index|[
name|WMT_WIDTH
index|]
operator|=
block|{
comment|/* WMT_MAJOR */
operator|.
name|name
operator|=
literal|"WDTH"
block|,
operator|.
name|usage
operator|=
name|HID_USAGE2
argument_list|(
name|HUP_DIGITIZERS
argument_list|,
name|HUD_WIDTH
argument_list|)
block|,
operator|.
name|code
operator|=
name|ABS_MT_TOUCH_MAJOR
block|,
operator|.
name|required
operator|=
name|false
block|, 	}
block|,
index|[
name|WMT_HEIGHT
index|]
operator|=
block|{
comment|/* WMT_MINOR */
operator|.
name|name
operator|=
literal|"HGHT"
block|,
operator|.
name|usage
operator|=
name|HID_USAGE2
argument_list|(
name|HUP_DIGITIZERS
argument_list|,
name|HUD_HEIGHT
argument_list|)
block|,
operator|.
name|code
operator|=
name|ABS_MT_TOUCH_MINOR
block|,
operator|.
name|required
operator|=
name|false
block|, 	}
block|,
index|[
name|WMT_ORIENTATION
index|]
operator|=
block|{
operator|.
name|name
operator|=
literal|"ORIE"
block|,
operator|.
name|usage
operator|=
name|WMT_NO_USAGE
block|,
operator|.
name|code
operator|=
name|ABS_MT_ORIENTATION
block|,
operator|.
name|required
operator|=
name|false
block|, 	}
block|,
index|[
name|WMT_X
index|]
operator|=
block|{
operator|.
name|name
operator|=
literal|"X"
block|,
operator|.
name|usage
operator|=
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_X
argument_list|)
block|,
operator|.
name|code
operator|=
name|ABS_MT_POSITION_X
block|,
operator|.
name|required
operator|=
name|true
block|, 	}
block|,
index|[
name|WMT_Y
index|]
operator|=
block|{
operator|.
name|name
operator|=
literal|"Y"
block|,
operator|.
name|usage
operator|=
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_Y
argument_list|)
block|,
operator|.
name|code
operator|=
name|ABS_MT_POSITION_Y
block|,
operator|.
name|required
operator|=
name|true
block|, 	}
block|,
index|[
name|WMT_CONTACTID
index|]
operator|=
block|{
operator|.
name|name
operator|=
literal|"C_ID"
block|,
operator|.
name|usage
operator|=
name|HID_USAGE2
argument_list|(
name|HUP_DIGITIZERS
argument_list|,
name|HUD_CONTACTID
argument_list|)
block|,
operator|.
name|code
operator|=
name|ABS_MT_TRACKING_ID
block|,
operator|.
name|required
operator|=
name|true
block|, 	}
block|,
index|[
name|WMT_PRESSURE
index|]
operator|=
block|{
operator|.
name|name
operator|=
literal|"PRES"
block|,
operator|.
name|usage
operator|=
name|HID_USAGE2
argument_list|(
name|HUP_DIGITIZERS
argument_list|,
name|HUD_TIP_PRESSURE
argument_list|)
block|,
operator|.
name|code
operator|=
name|ABS_MT_PRESSURE
block|,
operator|.
name|required
operator|=
name|false
block|, 	}
block|,
index|[
name|WMT_IN_RANGE
index|]
operator|=
block|{
operator|.
name|name
operator|=
literal|"RANG"
block|,
operator|.
name|usage
operator|=
name|HID_USAGE2
argument_list|(
name|HUP_DIGITIZERS
argument_list|,
name|HUD_IN_RANGE
argument_list|)
block|,
operator|.
name|code
operator|=
name|ABS_MT_DISTANCE
block|,
operator|.
name|required
operator|=
name|false
block|, 	}
block|,
index|[
name|WMT_CONFIDENCE
index|]
operator|=
block|{
operator|.
name|name
operator|=
literal|"CONF"
block|,
operator|.
name|usage
operator|=
name|HID_USAGE2
argument_list|(
name|HUP_DIGITIZERS
argument_list|,
name|HUD_CONFIDENCE
argument_list|)
block|,
operator|.
name|code
operator|=
name|WMT_NO_CODE
block|,
operator|.
name|required
operator|=
name|false
block|, 	}
block|,
index|[
name|WMT_TOOL_X
index|]
operator|=
block|{
comment|/* Shares HID usage with WMT_X */
operator|.
name|name
operator|=
literal|"TL_X"
block|,
operator|.
name|usage
operator|=
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_X
argument_list|)
block|,
operator|.
name|code
operator|=
name|ABS_MT_TOOL_X
block|,
operator|.
name|required
operator|=
name|false
block|, 	}
block|,
index|[
name|WMT_TOOL_Y
index|]
operator|=
block|{
comment|/* Shares HID usage with WMT_Y */
operator|.
name|name
operator|=
literal|"TL_Y"
block|,
operator|.
name|usage
operator|=
name|HID_USAGE2
argument_list|(
name|HUP_GENERIC_DESKTOP
argument_list|,
name|HUG_Y
argument_list|)
block|,
operator|.
name|code
operator|=
name|ABS_MT_TOOL_Y
block|,
operator|.
name|required
operator|=
name|false
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|wmt_absinfo
block|{
name|int32_t
name|min
decl_stmt|;
name|int32_t
name|max
decl_stmt|;
name|int32_t
name|res
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|wmt_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
name|struct
name|wmt_absinfo
name|ai
index|[
name|WMT_N_USAGES
index|]
decl_stmt|;
name|struct
name|hid_location
name|locs
index|[
name|MAX_MT_SLOTS
index|]
index|[
name|WMT_N_USAGES
index|]
decl_stmt|;
name|struct
name|hid_location
name|nconts_loc
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
index|[
name|WMT_N_TRANSFER
index|]
decl_stmt|;
name|struct
name|evdev_dev
modifier|*
name|evdev
decl_stmt|;
name|uint32_t
name|slot_data
index|[
name|WMT_N_USAGES
index|]
decl_stmt|;
name|uint32_t
name|caps
decl_stmt|;
name|uint32_t
name|isize
decl_stmt|;
name|uint32_t
name|nconts_max
decl_stmt|;
name|uint8_t
name|report_id
decl_stmt|;
name|uint8_t
name|buf
index|[
name|WMT_BSIZE
index|]
name|__aligned
argument_list|(
literal|4
argument_list|)
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|USAGE_SUPPORTED
parameter_list|(
name|caps
parameter_list|,
name|usage
parameter_list|)
value|((caps)& (1<< (usage)))
end_define

begin_define
define|#
directive|define
name|WMT_FOREACH_USAGE
parameter_list|(
name|caps
parameter_list|,
name|usage
parameter_list|)
define|\
value|for ((usage) = 0; (usage)< WMT_N_USAGES; ++(usage))	\ 		if (USAGE_SUPPORTED((caps), (usage)))
end_define

begin_function_decl
specifier|static
name|bool
name|wmt_hid_parse
parameter_list|(
name|struct
name|wmt_softc
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|usb_callback_t
name|wmt_intr_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_probe_t
name|wmt_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|wmt_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|wmt_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|evdev_open_t
name|wmt_ev_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|evdev_close_t
name|wmt_ev_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|evdev_methods
name|wmt_evdev_methods
init|=
block|{
operator|.
name|ev_open
operator|=
operator|&
name|wmt_ev_open
block|,
operator|.
name|ev_close
operator|=
operator|&
name|wmt_ev_close
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|wmt_config
index|[
name|WMT_N_TRANSFER
index|]
init|=
block|{
index|[
name|WMT_INTR_DT
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_INTERRUPT
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|}
block|,
operator|.
name|bufsize
operator|=
name|WMT_BSIZE
block|,
operator|.
name|callback
operator|=
operator|&
name|wmt_intr_callback
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|wmt_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|void
modifier|*
name|d_ptr
decl_stmt|;
name|uint16_t
name|d_len
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bInterfaceClass
operator|!=
name|UICLASS_HID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|usb_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_WMT_IGNORE
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|err
operator|=
name|usbd_req_get_hid_desc
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|NULL
argument_list|,
operator|&
name|d_ptr
argument_list|,
operator|&
name|d_len
argument_list|,
name|M_TEMP
argument_list|,
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|wmt_hid_parse
argument_list|(
name|NULL
argument_list|,
name|d_ptr
argument_list|,
name|d_len
argument_list|)
condition|)
name|err
operator|=
name|BUS_PROBE_DEFAULT
expr_stmt|;
else|else
name|err
operator|=
name|ENXIO
expr_stmt|;
name|free
argument_list|(
name|d_ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wmt_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|wmt_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|void
modifier|*
name|d_ptr
decl_stmt|;
name|uint16_t
name|d_len
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* Get HID descriptor */
name|err
operator|=
name|usbd_req_get_hid_desc
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|NULL
argument_list|,
operator|&
name|d_ptr
argument_list|,
operator|&
name|d_len
argument_list|,
name|M_TEMP
argument_list|,
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"usbd_req_get_hid_desc error=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
literal|"wmt lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Get HID report length */
name|sc
operator|->
name|isize
operator|=
name|hid_report_size
argument_list|(
name|d_ptr
argument_list|,
name|d_len
argument_list|,
name|hid_input
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|isize
operator|<=
literal|0
operator|||
name|sc
operator|->
name|isize
operator|>
name|WMT_BSIZE
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Input size invalid or too large: %d\n"
argument_list|,
name|sc
operator|->
name|isize
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|err
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|,
name|sc
operator|->
name|xfer
argument_list|,
name|wmt_config
argument_list|,
name|WMT_N_TRANSFER
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"usbd_transfer_setup error=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
if|if
condition|(
operator|!
name|wmt_hid_parse
argument_list|(
name|sc
argument_list|,
name|d_ptr
argument_list|,
name|d_len
argument_list|)
condition|)
goto|goto
name|detach
goto|;
name|sc
operator|->
name|evdev
operator|=
name|evdev_alloc
argument_list|()
expr_stmt|;
name|evdev_set_name
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
name|device_get_desc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|evdev_set_phys
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|evdev_set_id
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
name|BUS_USB
argument_list|,
name|uaa
operator|->
name|info
operator|.
name|idVendor
argument_list|,
name|uaa
operator|->
name|info
operator|.
name|idProduct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evdev_set_serial
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
name|usb_get_serial
argument_list|(
name|uaa
operator|->
name|device
argument_list|)
argument_list|)
expr_stmt|;
name|evdev_set_methods
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
name|sc
argument_list|,
operator|&
name|wmt_evdev_methods
argument_list|)
expr_stmt|;
name|evdev_set_flag
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
name|EVDEV_FLAG_MT_STCOMPAT
argument_list|)
expr_stmt|;
name|evdev_support_prop
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
name|INPUT_PROP_DIRECT
argument_list|)
expr_stmt|;
name|evdev_support_event
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
name|EV_SYN
argument_list|)
expr_stmt|;
name|evdev_support_event
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
name|EV_ABS
argument_list|)
expr_stmt|;
name|WMT_FOREACH_USAGE
argument_list|(
argument|sc->caps
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|wmt_hid_map
index|[
name|i
index|]
operator|.
name|code
operator|!=
name|WMT_NO_CODE
condition|)
name|evdev_support_abs
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
name|wmt_hid_map
index|[
name|i
index|]
operator|.
name|code
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|ai
index|[
name|i
index|]
operator|.
name|min
argument_list|,
name|sc
operator|->
name|ai
index|[
name|i
index|]
operator|.
name|max
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|ai
index|[
name|i
index|]
operator|.
name|res
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|evdev_register_mtx
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|detach
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|detach
label|:
name|free
argument_list|(
name|d_ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|wmt_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wmt_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wmt_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|evdev_free
argument_list|(
name|sc
operator|->
name|evdev
argument_list|)
expr_stmt|;
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|xfer
argument_list|,
name|WMT_N_TRANSFER
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wmt_process_report
parameter_list|(
name|struct
name|wmt_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|size_t
name|usage
decl_stmt|;
name|uint32_t
modifier|*
name|slot_data
init|=
name|sc
operator|->
name|slot_data
decl_stmt|;
name|uint32_t
name|cont
decl_stmt|;
name|uint32_t
name|nconts
decl_stmt|;
name|uint32_t
name|width
decl_stmt|;
name|uint32_t
name|height
decl_stmt|;
name|int32_t
name|slot
decl_stmt|;
name|nconts
operator|=
name|hid_get_data_unsigned
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|sc
operator|->
name|nconts_loc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"nconts = %u   "
argument_list|,
operator|(
name|unsigned
operator|)
name|nconts
argument_list|)
expr_stmt|;
if|if
condition|(
name|wmt_debug
operator|>=
literal|6
condition|)
block|{
name|WMT_FOREACH_USAGE
argument_list|(
argument|sc->caps
argument_list|,
argument|usage
argument_list|)
block|{
if|if
condition|(
name|wmt_hid_map
index|[
name|usage
index|]
operator|.
name|usage
operator|!=
name|WMT_NO_USAGE
condition|)
name|printf
argument_list|(
literal|" %-4s"
argument_list|,
name|wmt_hid_map
index|[
name|usage
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|nconts
operator|>
name|sc
operator|->
name|nconts_max
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Contact count overflow %u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|nconts
argument_list|)
expr_stmt|;
name|nconts
operator|=
name|sc
operator|->
name|nconts_max
expr_stmt|;
block|}
comment|/* Use protocol Type B for reporting events */
for|for
control|(
name|cont
operator|=
literal|0
init|;
name|cont
operator|<
name|nconts
condition|;
name|cont
operator|++
control|)
block|{
name|bzero
argument_list|(
name|slot_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|slot_data
argument_list|)
argument_list|)
expr_stmt|;
name|WMT_FOREACH_USAGE
argument_list|(
argument|sc->caps
argument_list|,
argument|usage
argument_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|locs
index|[
name|cont
index|]
index|[
name|usage
index|]
operator|.
name|size
operator|>
literal|0
condition|)
name|slot_data
index|[
name|usage
index|]
operator|=
name|hid_get_data_unsigned
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|sc
operator|->
name|locs
index|[
name|cont
index|]
index|[
name|usage
index|]
argument_list|)
expr_stmt|;
block|}
name|slot
operator|=
name|evdev_get_mt_slot_by_tracking_id
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
name|slot_data
index|[
name|WMT_CONTACTID
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"cont%01x: data = "
argument_list|,
name|cont
argument_list|)
expr_stmt|;
if|if
condition|(
name|wmt_debug
operator|>=
literal|6
condition|)
block|{
name|WMT_FOREACH_USAGE
argument_list|(
argument|sc->caps
argument_list|,
argument|usage
argument_list|)
block|{
if|if
condition|(
name|wmt_hid_map
index|[
name|usage
index|]
operator|.
name|usage
operator|!=
name|WMT_NO_USAGE
condition|)
name|printf
argument_list|(
literal|"%04x "
argument_list|,
name|slot_data
index|[
name|usage
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"slot = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|slot
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|slot
operator|==
operator|-
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Slot overflow for contact_id %u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|slot_data
index|[
name|WMT_CONTACTID
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|slot_data
index|[
name|WMT_TIP_SWITCH
index|]
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|USAGE_SUPPORTED
argument_list|(
name|sc
operator|->
name|caps
argument_list|,
name|WMT_CONFIDENCE
argument_list|)
operator|&&
name|slot_data
index|[
name|WMT_CONFIDENCE
index|]
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* This finger is in proximity of the sensor */
name|slot_data
index|[
name|WMT_SLOT
index|]
operator|=
name|slot
expr_stmt|;
name|slot_data
index|[
name|WMT_IN_RANGE
index|]
operator|=
operator|!
name|slot_data
index|[
name|WMT_IN_RANGE
index|]
expr_stmt|;
comment|/* Divided by two to match visual scale of touch */
name|width
operator|=
name|slot_data
index|[
name|WMT_WIDTH
index|]
operator|>>
literal|1
expr_stmt|;
name|height
operator|=
name|slot_data
index|[
name|WMT_HEIGHT
index|]
operator|>>
literal|1
expr_stmt|;
name|slot_data
index|[
name|WMT_ORIENTATION
index|]
operator|=
name|width
operator|>
name|height
expr_stmt|;
name|slot_data
index|[
name|WMT_MAJOR
index|]
operator|=
name|MAX
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|slot_data
index|[
name|WMT_MINOR
index|]
operator|=
name|MIN
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|WMT_FOREACH_USAGE
argument_list|(
argument|sc->caps
argument_list|,
argument|usage
argument_list|)
if|if
condition|(
name|wmt_hid_map
index|[
name|usage
index|]
operator|.
name|code
operator|!=
name|WMT_NO_CODE
condition|)
name|evdev_push_abs
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
name|wmt_hid_map
index|[
name|usage
index|]
operator|.
name|code
argument_list|,
name|slot_data
index|[
name|usage
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|evdev_push_abs
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
name|ABS_MT_SLOT
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|evdev_push_abs
argument_list|(
name|sc
operator|->
name|evdev
argument_list|,
name|ABS_MT_TRACKING_ID
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|evdev_sync
argument_list|(
name|sc
operator|->
name|evdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wmt_intr_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|wmt_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|sc
operator|->
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"sc=%p actlen=%d\n"
argument_list|,
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
operator|(
name|int
operator|)
name|sc
operator|->
name|isize
operator|||
operator|(
name|len
operator|>
literal|0
operator|&&
name|sc
operator|->
name|report_id
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Limit report length to the maximum */
if|if
condition|(
name|len
operator|>
operator|(
name|int
operator|)
name|sc
operator|->
name|isize
condition|)
name|len
operator|=
name|sc
operator|->
name|isize
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Ignore irrelevant reports */
if|if
condition|(
name|sc
operator|->
name|report_id
operator|&&
operator|*
name|buf
operator|!=
name|sc
operator|->
name|report_id
condition|)
goto|goto
name|tr_ignore
goto|;
comment|/* Make sure we don't process old data */
if|if
condition|(
name|len
operator|<
name|sc
operator|->
name|isize
condition|)
name|bzero
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|sc
operator|->
name|isize
operator|-
name|len
argument_list|)
expr_stmt|;
comment|/* Strip leading "report ID" byte */
if|if
condition|(
name|sc
operator|->
name|report_id
condition|)
block|{
name|len
operator|--
expr_stmt|;
name|buf
operator|++
expr_stmt|;
block|}
name|wmt_process_report
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tr_ignore
label|:
name|DPRINTF
argument_list|(
literal|"Ignored transfer, %d bytes\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|isize
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* Try clear stall first */
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wmt_ev_close
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|void
modifier|*
name|ev_softc
parameter_list|)
block|{
name|struct
name|wmt_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|wmt_softc
operator|*
operator|)
name|ev_softc
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|usbd_transfer_stop
argument_list|(
name|sc
operator|->
name|xfer
index|[
name|WMT_INTR_DT
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wmt_ev_open
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|void
modifier|*
name|ev_softc
parameter_list|)
block|{
name|struct
name|wmt_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|wmt_softc
operator|*
operator|)
name|ev_softc
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|xfer
index|[
name|WMT_INTR_DT
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|wmt_hid_parse
parameter_list|(
name|struct
name|wmt_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|void
modifier|*
name|d_ptr
parameter_list|,
name|uint16_t
name|d_len
parameter_list|)
block|{
name|struct
name|hid_item
name|hi
decl_stmt|;
name|struct
name|hid_data
modifier|*
name|hd
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|cont
init|=
literal|0
decl_stmt|;
name|uint32_t
name|caps
init|=
literal|0
decl_stmt|;
name|int32_t
name|cont_count_max
init|=
literal|0
decl_stmt|;
name|uint8_t
name|report_id
init|=
literal|0
decl_stmt|;
name|bool
name|touch_coll
init|=
name|false
decl_stmt|;
name|bool
name|finger_coll
init|=
name|false
decl_stmt|;
name|bool
name|cont_count_found
init|=
name|false
decl_stmt|;
name|bool
name|scan_time_found
init|=
name|false
decl_stmt|;
define|#
directive|define
name|WMT_HI_ABSOLUTE
parameter_list|(
name|hi
parameter_list|)
define|\
value|(((hi).flags& (HIO_CONST|HIO_VARIABLE|HIO_RELATIVE)) == HIO_VARIABLE)
comment|/* Parse features for maximum contact count */
name|hd
operator|=
name|hid_start_parse
argument_list|(
name|d_ptr
argument_list|,
name|d_len
argument_list|,
literal|1
operator|<<
name|hid_feature
argument_list|)
expr_stmt|;
while|while
condition|(
name|hid_get_item
argument_list|(
name|hd
argument_list|,
operator|&
name|hi
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|hi
operator|.
name|kind
condition|)
block|{
case|case
name|hid_collection
case|:
if|if
condition|(
name|hi
operator|.
name|collevel
operator|==
literal|1
operator|&&
name|hi
operator|.
name|usage
operator|==
name|HID_USAGE2
argument_list|(
name|HUP_DIGITIZERS
argument_list|,
name|HUD_TOUCHSCREEN
argument_list|)
condition|)
name|touch_coll
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|hid_endcollection
case|:
if|if
condition|(
name|hi
operator|.
name|collevel
operator|==
literal|0
operator|&&
name|touch_coll
condition|)
name|touch_coll
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|hid_feature
case|:
if|if
condition|(
name|hi
operator|.
name|collevel
operator|==
literal|1
operator|&&
name|touch_coll
operator|&&
name|WMT_HI_ABSOLUTE
argument_list|(
name|hi
argument_list|)
operator|&&
name|hi
operator|.
name|usage
operator|==
name|HID_USAGE2
argument_list|(
name|HUP_DIGITIZERS
argument_list|,
name|HUD_CONTACT_MAX
argument_list|)
condition|)
name|cont_count_max
operator|=
name|hi
operator|.
name|logical_maximum
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|hid_end_parse
argument_list|(
name|hd
argument_list|)
expr_stmt|;
comment|/* Maximum contact count is required usage */
if|if
condition|(
name|cont_count_max
operator|<
literal|1
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|touch_coll
operator|=
name|false
expr_stmt|;
comment|/* Parse input for other parameters */
name|hd
operator|=
name|hid_start_parse
argument_list|(
name|d_ptr
argument_list|,
name|d_len
argument_list|,
literal|1
operator|<<
name|hid_input
argument_list|)
expr_stmt|;
while|while
condition|(
name|hid_get_item
argument_list|(
name|hd
argument_list|,
operator|&
name|hi
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|hi
operator|.
name|kind
condition|)
block|{
case|case
name|hid_collection
case|:
if|if
condition|(
name|hi
operator|.
name|collevel
operator|==
literal|1
operator|&&
name|hi
operator|.
name|usage
operator|==
name|HID_USAGE2
argument_list|(
name|HUP_DIGITIZERS
argument_list|,
name|HUD_TOUCHSCREEN
argument_list|)
condition|)
name|touch_coll
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|touch_coll
operator|&&
name|hi
operator|.
name|collevel
operator|==
literal|2
operator|&&
operator|(
name|report_id
operator|==
literal|0
operator|||
name|report_id
operator|==
name|hi
operator|.
name|report_ID
operator|)
operator|&&
name|hi
operator|.
name|usage
operator|==
name|HID_USAGE2
argument_list|(
name|HUP_DIGITIZERS
argument_list|,
name|HUD_FINGER
argument_list|)
condition|)
name|finger_coll
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|hid_endcollection
case|:
if|if
condition|(
name|hi
operator|.
name|collevel
operator|==
literal|1
operator|&&
name|finger_coll
condition|)
block|{
name|finger_coll
operator|=
name|false
expr_stmt|;
name|cont
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hi
operator|.
name|collevel
operator|==
literal|0
operator|&&
name|touch_coll
condition|)
name|touch_coll
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|hid_input
case|:
comment|/* 			 * Ensure that all usages are located within the same 			 * report and proper collection. 			 */
if|if
condition|(
name|WMT_HI_ABSOLUTE
argument_list|(
name|hi
argument_list|)
operator|&&
name|touch_coll
operator|&&
operator|(
name|report_id
operator|==
literal|0
operator|||
name|report_id
operator|==
name|hi
operator|.
name|report_ID
operator|)
condition|)
name|report_id
operator|=
name|hi
operator|.
name|report_ID
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|hi
operator|.
name|collevel
operator|==
literal|1
operator|&&
name|hi
operator|.
name|usage
operator|==
name|HID_USAGE2
argument_list|(
name|HUP_DIGITIZERS
argument_list|,
name|HUD_CONTACTCOUNT
argument_list|)
condition|)
block|{
name|cont_count_found
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|nconts_loc
operator|=
name|hi
operator|.
name|loc
expr_stmt|;
break|break;
block|}
comment|/* Scan time is required but clobbered by evdev */
if|if
condition|(
name|hi
operator|.
name|collevel
operator|==
literal|1
operator|&&
name|hi
operator|.
name|usage
operator|==
name|HID_USAGE2
argument_list|(
name|HUP_DIGITIZERS
argument_list|,
name|HUD_SCAN_TIME
argument_list|)
condition|)
block|{
name|scan_time_found
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|finger_coll
operator|||
name|hi
operator|.
name|collevel
operator|!=
literal|2
condition|)
break|break;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|&&
name|cont
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|cont
operator|>=
name|MAX_MT_SLOTS
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Finger %zu ignored\n"
argument_list|,
name|cont
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WMT_N_USAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hi
operator|.
name|usage
operator|==
name|wmt_hid_map
index|[
name|i
index|]
operator|.
name|usage
condition|)
block|{
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|USAGE_SUPPORTED
argument_list|(
name|caps
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
name|caps
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
break|break;
block|}
comment|/* 					 * HUG_X usage is an array mapped to 					 * both ABS_MT_POSITION and ABS_MT_TOOL 					 * events. So don`t stop search if we 					 * already have HUG_X mapping done. 					 */
if|if
condition|(
name|sc
operator|->
name|locs
index|[
name|cont
index|]
index|[
name|i
index|]
operator|.
name|size
condition|)
continue|continue;
name|sc
operator|->
name|locs
index|[
name|cont
index|]
index|[
name|i
index|]
operator|=
name|hi
operator|.
name|loc
expr_stmt|;
comment|/* 					 * Hid parser returns valid logical and 					 * physical sizes for first finger only 					 * at least on ElanTS 0x04f3:0x0012. 					 */
if|if
condition|(
name|cont
operator|>
literal|0
condition|)
break|break;
name|caps
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|sc
operator|->
name|ai
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|wmt_absinfo
operator|)
block|{
operator|.
name|max
operator|=
name|hi
operator|.
name|logical_maximum
block|,
operator|.
name|min
operator|=
name|hi
operator|.
name|logical_minimum
block|,
operator|.
name|res
operator|=
name|hid_item_resolution
argument_list|(
operator|&
name|hi
argument_list|)
block|, 					}
expr_stmt|;
break|break;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
name|hid_end_parse
argument_list|(
name|hd
argument_list|)
expr_stmt|;
comment|/* Check for required HID Usages */
if|if
condition|(
operator|!
name|cont_count_found
operator|||
operator|!
name|scan_time_found
operator|||
name|cont
operator|==
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WMT_N_USAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wmt_hid_map
index|[
name|i
index|]
operator|.
name|required
operator|&&
operator|!
name|USAGE_SUPPORTED
argument_list|(
name|caps
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* Stop probing here */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
comment|/* Cap contact count maximum to MAX_MT_SLOTS */
if|if
condition|(
name|cont_count_max
operator|>
name|MAX_MT_SLOTS
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Hardware reported %d contacts while only %d is "
literal|"supported\n"
argument_list|,
operator|(
name|int
operator|)
name|cont_count_max
argument_list|,
name|MAX_MT_SLOTS
argument_list|)
expr_stmt|;
name|cont_count_max
operator|=
name|MAX_MT_SLOTS
expr_stmt|;
block|}
comment|/* Set number of MT protocol type B slots */
name|sc
operator|->
name|ai
index|[
name|WMT_SLOT
index|]
operator|=
operator|(
expr|struct
name|wmt_absinfo
operator|)
block|{
operator|.
name|min
operator|=
literal|0
block|,
operator|.
name|max
operator|=
name|cont_count_max
operator|-
literal|1
block|,
operator|.
name|res
operator|=
literal|0
block|, 	}
expr_stmt|;
comment|/* Report touch orientation if both width and height are supported */
if|if
condition|(
name|USAGE_SUPPORTED
argument_list|(
name|caps
argument_list|,
name|WMT_WIDTH
argument_list|)
operator|&&
name|USAGE_SUPPORTED
argument_list|(
name|caps
argument_list|,
name|WMT_HEIGHT
argument_list|)
condition|)
block|{
name|caps
operator||=
operator|(
literal|1
operator|<<
name|WMT_ORIENTATION
operator|)
expr_stmt|;
name|sc
operator|->
name|ai
index|[
name|WMT_ORIENTATION
index|]
operator|.
name|max
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|report_id
operator|=
name|report_id
expr_stmt|;
name|sc
operator|->
name|caps
operator|=
name|caps
expr_stmt|;
name|sc
operator|->
name|nconts_max
operator|=
name|cont
expr_stmt|;
comment|/* Announce information about the touch device */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%d contacts and [%s%s%s%s%s]. Report range [%d:%d] - [%d:%d]\n"
argument_list|,
operator|(
name|int
operator|)
name|cont_count_max
argument_list|,
name|USAGE_SUPPORTED
argument_list|(
name|sc
operator|->
name|caps
argument_list|,
name|WMT_IN_RANGE
argument_list|)
condition|?
literal|"R"
else|:
literal|""
argument_list|,
name|USAGE_SUPPORTED
argument_list|(
name|sc
operator|->
name|caps
argument_list|,
name|WMT_CONFIDENCE
argument_list|)
condition|?
literal|"C"
else|:
literal|""
argument_list|,
name|USAGE_SUPPORTED
argument_list|(
name|sc
operator|->
name|caps
argument_list|,
name|WMT_WIDTH
argument_list|)
condition|?
literal|"W"
else|:
literal|""
argument_list|,
name|USAGE_SUPPORTED
argument_list|(
name|sc
operator|->
name|caps
argument_list|,
name|WMT_HEIGHT
argument_list|)
condition|?
literal|"H"
else|:
literal|""
argument_list|,
name|USAGE_SUPPORTED
argument_list|(
name|sc
operator|->
name|caps
argument_list|,
name|WMT_PRESSURE
argument_list|)
condition|?
literal|"P"
else|:
literal|""
argument_list|,
operator|(
name|int
operator|)
name|sc
operator|->
name|ai
index|[
name|WMT_X
index|]
operator|.
name|min
argument_list|,
operator|(
name|int
operator|)
name|sc
operator|->
name|ai
index|[
name|WMT_Y
index|]
operator|.
name|min
argument_list|,
operator|(
name|int
operator|)
name|sc
operator|->
name|ai
index|[
name|WMT_X
index|]
operator|.
name|max
argument_list|,
operator|(
name|int
operator|)
name|sc
operator|->
name|ai
index|[
name|WMT_Y
index|]
operator|.
name|max
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|devclass_t
name|wmt_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|wmt_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|wmt_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|wmt_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|wmt_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|wmt_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"wmt"
block|,
operator|.
name|methods
operator|=
name|wmt_methods
block|,
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|wmt_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|wmt
argument_list|,
name|uhub
argument_list|,
name|wmt_driver
argument_list|,
name|wmt_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|wmt
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|wmt
argument_list|,
name|evdev
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|wmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

