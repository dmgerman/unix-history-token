begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 Rohit Grover  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Some tables, structures, definitions and constant values for the  * touchpad protocol has been copied from Linux's  * "drivers/input/mouse/bcm5974.c" which has the following copyright  * holders under GPLv2. All device specific code in this driver has  * been written from scratch. The decoding algorithm is based on  * output from FreeBSD's usbdump.  *  * Copyright (C) 2008      Henrik Rydberg (rydberg@euromail.se)  * Copyright (C) 2008      Scott Shawcroft (scott.shawcroft@gmail.com)  * Copyright (C) 2001-2004 Greg Kroah-Hartman (greg@kroah.com)  * Copyright (C) 2005      Johannes Berg (johannes@sipsolutions.net)  * Copyright (C) 2005      Stelian Pop (stelian@popies.net)  * Copyright (C) 2005      Frank Arnold (frank@scirocco-5v-turbo.de)  * Copyright (C) 2005      Peter Osterlund (petero2@telia.com)  * Copyright (C) 2005      Michael Hanselmann (linux-kernel@hansmi.ch)  * Copyright (C) 2006      Nicolas Boichat (nicolas@boichat.ch)  */
end_comment

begin_comment
comment|/*  * Author's note: 'atp' supports two distinct families of Apple trackpad  * products: the older Fountain/Geyser and the latest Wellspring trackpads.  * The first version made its appearance with FreeBSD 8 and worked only with  * the Fountain/Geyser hardware. A fork of this driver for Wellspring was  * contributed by Huang Wen Hui. This driver unifies the Wellspring effort  * and also improves upon the original work.  *  * I'm grateful to Stephan Scheunig, Angela Naegele, and Nokia IT-support  * for helping me with access to hardware. Thanks also go to Nokia for  * giving me an opportunity to do this work.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbhid.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|atp_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<sys/mouse.h>
end_include

begin_define
define|#
directive|define
name|ATP_DRIVER_NAME
value|"atp"
end_define

begin_comment
comment|/*  * Driver specific options: the following options may be set by  * `options' statements in the kernel configuration file.  */
end_comment

begin_comment
comment|/* The divisor used to translate sensor reported positions to mickeys. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATP_SCALE_FACTOR
end_ifndef

begin_define
define|#
directive|define
name|ATP_SCALE_FACTOR
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Threshold for small movement noise (in mickeys) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATP_SMALL_MOVEMENT_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|ATP_SMALL_MOVEMENT_THRESHOLD
value|30
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Threshold of instantaneous deltas beyond which movement is considered fast.*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATP_FAST_MOVEMENT_TRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|ATP_FAST_MOVEMENT_TRESHOLD
value|150
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This is the age in microseconds beyond which a touch is considered  * to be a slide; and therefore a tap event isn't registered.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATP_TOUCH_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|ATP_TOUCH_TIMEOUT
value|125000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ATP_IDLENESS_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|ATP_IDLENESS_THRESHOLD
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FG_SENSOR_NOISE_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|FG_SENSOR_NOISE_THRESHOLD
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * A double-tap followed by a single-finger slide is treated as a  * special gesture. The driver responds to this gesture by assuming a  * virtual button-press for the lifetime of the slide. The following  * threshold is the maximum time gap (in microseconds) between the two  * tap events preceding the slide for such a gesture.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATP_DOUBLE_TAP_N_DRAG_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|ATP_DOUBLE_TAP_N_DRAG_THRESHOLD
value|200000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The wait duration in ticks after losing a touch contact before  * zombied strokes are reaped and turned into button events.  */
end_comment

begin_define
define|#
directive|define
name|ATP_ZOMBIE_STROKE_REAP_INTERVAL
value|(hz / 20)
end_define

begin_comment
comment|/* 50 ms */
end_comment

begin_comment
comment|/* The multiplier used to translate sensor reported positions to mickeys. */
end_comment

begin_define
define|#
directive|define
name|FG_SCALE_FACTOR
value|380
end_define

begin_comment
comment|/*  * The movement threshold for a stroke; this is the maximum difference  * in position which will be resolved as a continuation of a stroke  * component.  */
end_comment

begin_define
define|#
directive|define
name|FG_MAX_DELTA_MICKEYS
value|((3 * (FG_SCALE_FACTOR))>> 1)
end_define

begin_comment
comment|/* Distance-squared threshold for matching a finger with a known stroke */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WSP_MAX_ALLOWED_MATCH_DISTANCE_SQ
end_ifndef

begin_define
define|#
directive|define
name|WSP_MAX_ALLOWED_MATCH_DISTANCE_SQ
value|1000000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Ignore pressure spans with cumulative press. below this value. */
end_comment

begin_define
define|#
directive|define
name|FG_PSPAN_MIN_CUM_PRESSURE
value|10
end_define

begin_comment
comment|/* Maximum allowed width for pressure-spans.*/
end_comment

begin_define
define|#
directive|define
name|FG_PSPAN_MAX_WIDTH
value|4
end_define

begin_comment
comment|/* end of driver specific options */
end_comment

begin_comment
comment|/* Tunables */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|atp
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB ATP"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_enum
enum|enum
name|atp_log_level
block|{
name|ATP_LLEVEL_DISABLED
init|=
literal|0
block|,
name|ATP_LLEVEL_ERROR
block|,
name|ATP_LLEVEL_DEBUG
block|,
comment|/* for troubleshooting */
name|ATP_LLEVEL_INFO
block|,
comment|/* for diagnostics */
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|atp_debug
init|=
name|ATP_LLEVEL_ERROR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the default is to only log errors */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_debug
argument_list|,
name|ATP_LLEVEL_ERROR
argument_list|,
literal|"ATP debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USB_DEBUG */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|atp_touch_timeout
init|=
name|ATP_TOUCH_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|touch_timeout
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_touch_timeout
argument_list|,
literal|125000
argument_list|,
literal|"age threshold in microseconds for a touch"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|atp_double_tap_threshold
init|=
name|ATP_DOUBLE_TAP_N_DRAG_THRESHOLD
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|double_tap_threshold
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_double_tap_threshold
argument_list|,
name|ATP_DOUBLE_TAP_N_DRAG_THRESHOLD
argument_list|,
literal|"maximum time in microseconds to allow association between a double-tap and "
literal|"drag gesture"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|atp_mickeys_scale_factor
init|=
name|ATP_SCALE_FACTOR
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|atp_sysctl_scale_factor_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|scale_factor
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_mickeys_scale_factor
argument_list|,
sizeof|sizeof
argument_list|(
name|atp_mickeys_scale_factor
argument_list|)
argument_list|,
name|atp_sysctl_scale_factor_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"movement scale factor"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|atp_small_movement_threshold
init|=
name|ATP_SMALL_MOVEMENT_THRESHOLD
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|small_movement
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_small_movement_threshold
argument_list|,
name|ATP_SMALL_MOVEMENT_THRESHOLD
argument_list|,
literal|"the small movement black-hole for filtering noise"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|atp_tap_minimum
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|tap_minimum
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_tap_minimum
argument_list|,
literal|1
argument_list|,
literal|"Minimum number of taps before detection"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Strokes which accumulate at least this amount of absolute movement  * from the aggregate of their components are considered as  * slides. Unit: mickeys.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|atp_slide_min_movement
init|=
literal|2
operator|*
name|ATP_SMALL_MOVEMENT_THRESHOLD
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|slide_min_movement
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_slide_min_movement
argument_list|,
literal|2
operator|*
name|ATP_SMALL_MOVEMENT_THRESHOLD
argument_list|,
literal|"strokes with at least this amt. of movement are considered slides"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The minimum age of a stroke for it to be considered mature; this  * helps filter movements (noise) from immature strokes. Units: interrupts.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|atp_stroke_maturity_threshold
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|stroke_maturity_threshold
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_stroke_maturity_threshold
argument_list|,
literal|4
argument_list|,
literal|"the minimum age of a stroke for it to be considered mature"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
enum|enum
name|atp_trackpad_family
block|{
name|TRACKPAD_FAMILY_FOUNTAIN_GEYSER
block|,
name|TRACKPAD_FAMILY_WELLSPRING
block|,
name|TRACKPAD_FAMILY_MAX
comment|/* keep this at the tail end of the enumeration */
block|}
name|trackpad_family_t
typedef|;
end_typedef

begin_enum
enum|enum
name|fountain_geyser_product
block|{
name|FOUNTAIN
block|,
name|GEYSER1
block|,
name|GEYSER1_17inch
block|,
name|GEYSER2
block|,
name|GEYSER3
block|,
name|GEYSER4
block|,
name|FOUNTAIN_GEYSER_PRODUCT_MAX
comment|/* keep this at the end */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|wellspring_product
block|{
name|WELLSPRING1
block|,
name|WELLSPRING2
block|,
name|WELLSPRING3
block|,
name|WELLSPRING4
block|,
name|WELLSPRING4A
block|,
name|WELLSPRING5
block|,
name|WELLSPRING6A
block|,
name|WELLSPRING6
block|,
name|WELLSPRING5A
block|,
name|WELLSPRING7
block|,
name|WELLSPRING7A
block|,
name|WELLSPRING8
block|,
name|WELLSPRING_PRODUCT_MAX
comment|/* keep this at the end of the enumeration */
block|}
enum|;
end_enum

begin_comment
comment|/* trackpad header types */
end_comment

begin_enum
enum|enum
name|fountain_geyser_trackpad_type
block|{
name|FG_TRACKPAD_TYPE_GEYSER1
block|,
name|FG_TRACKPAD_TYPE_GEYSER2
block|,
name|FG_TRACKPAD_TYPE_GEYSER3
block|,
name|FG_TRACKPAD_TYPE_GEYSER4
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|wellspring_trackpad_type
block|{
name|WSP_TRACKPAD_TYPE1
block|,
comment|/* plain trackpad */
name|WSP_TRACKPAD_TYPE2
block|,
comment|/* button integrated in trackpad */
name|WSP_TRACKPAD_TYPE3
comment|/* additional header fields since June 2013 */
block|}
enum|;
end_enum

begin_comment
comment|/*  * Trackpad family and product and family are encoded together in the  * driver_info value associated with a trackpad product.  */
end_comment

begin_define
define|#
directive|define
name|N_PROD_BITS
value|8
end_define

begin_comment
comment|/* Number of bits used to encode product */
end_comment

begin_define
define|#
directive|define
name|ENCODE_DRIVER_INFO
parameter_list|(
name|FAMILY
parameter_list|,
name|PROD
parameter_list|)
define|\
value|(((FAMILY)<< N_PROD_BITS) | (PROD))
end_define

begin_define
define|#
directive|define
name|DECODE_FAMILY_FROM_DRIVER_INFO
parameter_list|(
name|INFO
parameter_list|)
value|((INFO)>> N_PROD_BITS)
end_define

begin_define
define|#
directive|define
name|DECODE_PRODUCT_FROM_DRIVER_INFO
parameter_list|(
name|INFO
parameter_list|)
define|\
value|((INFO)& ((1<< N_PROD_BITS) - 1))
end_define

begin_define
define|#
directive|define
name|FG_DRIVER_INFO
parameter_list|(
name|PRODUCT
parameter_list|)
define|\
value|ENCODE_DRIVER_INFO(TRACKPAD_FAMILY_FOUNTAIN_GEYSER, PRODUCT)
end_define

begin_define
define|#
directive|define
name|WELLSPRING_DRIVER_INFO
parameter_list|(
name|PRODUCT
parameter_list|)
define|\
value|ENCODE_DRIVER_INFO(TRACKPAD_FAMILY_WELLSPRING, PRODUCT)
end_define

begin_comment
comment|/*  * The following structure captures the state of a pressure span along  * an axis. Each contact with the touchpad results in separate  * pressure spans along the two axes.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fg_pspan
block|{
name|u_int
name|width
decl_stmt|;
comment|/* in units of sensors */
name|u_int
name|cum
decl_stmt|;
comment|/* cumulative compression (from all sensors) */
name|u_int
name|cog
decl_stmt|;
comment|/* center of gravity */
name|u_int
name|loc
decl_stmt|;
comment|/* location (scaled using the mickeys factor) */
name|boolean_t
name|matched
decl_stmt|;
comment|/* to track pspans as they match against strokes. */
block|}
name|fg_pspan
typedef|;
end_typedef

begin_define
define|#
directive|define
name|FG_MAX_PSPANS_PER_AXIS
value|3
end_define

begin_define
define|#
directive|define
name|FG_MAX_STROKES
value|(2 * FG_MAX_PSPANS_PER_AXIS)
end_define

begin_define
define|#
directive|define
name|WELLSPRING_INTERFACE_INDEX
value|1
end_define

begin_comment
comment|/* trackpad finger data offsets, le16-aligned */
end_comment

begin_define
define|#
directive|define
name|WSP_TYPE1_FINGER_DATA_OFFSET
value|(13 * 2)
end_define

begin_define
define|#
directive|define
name|WSP_TYPE2_FINGER_DATA_OFFSET
value|(15 * 2)
end_define

begin_define
define|#
directive|define
name|WSP_TYPE3_FINGER_DATA_OFFSET
value|(19 * 2)
end_define

begin_comment
comment|/* trackpad button data offsets */
end_comment

begin_define
define|#
directive|define
name|WSP_TYPE2_BUTTON_DATA_OFFSET
value|15
end_define

begin_define
define|#
directive|define
name|WSP_TYPE3_BUTTON_DATA_OFFSET
value|23
end_define

begin_comment
comment|/* list of device capability bits */
end_comment

begin_define
define|#
directive|define
name|HAS_INTEGRATED_BUTTON
value|1
end_define

begin_comment
comment|/* trackpad finger structure - little endian */
end_comment

begin_struct
struct|struct
name|wsp_finger_sensor_data
block|{
name|int16_t
name|origin
decl_stmt|;
comment|/* zero when switching track finger */
name|int16_t
name|abs_x
decl_stmt|;
comment|/* absolute x coordinate */
name|int16_t
name|abs_y
decl_stmt|;
comment|/* absolute y coordinate */
name|int16_t
name|rel_x
decl_stmt|;
comment|/* relative x coordinate */
name|int16_t
name|rel_y
decl_stmt|;
comment|/* relative y coordinate */
name|int16_t
name|tool_major
decl_stmt|;
comment|/* tool area, major axis */
name|int16_t
name|tool_minor
decl_stmt|;
comment|/* tool area, minor axis */
name|int16_t
name|orientation
decl_stmt|;
comment|/* 16384 when point, else 15 bit angle */
name|int16_t
name|touch_major
decl_stmt|;
comment|/* touch area, major axis */
name|int16_t
name|touch_minor
decl_stmt|;
comment|/* touch area, minor axis */
name|int16_t
name|unused
index|[
literal|3
index|]
decl_stmt|;
comment|/* zeros */
name|int16_t
name|multi
decl_stmt|;
comment|/* one finger: varies, more fingers: constant */
block|}
name|__packed
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|wsp_finger
block|{
comment|/* to track fingers as they match against strokes. */
name|boolean_t
name|matched
decl_stmt|;
comment|/* location (scaled using the mickeys factor) */
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
block|}
name|wsp_finger_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|WSP_MAX_FINGERS
value|16
end_define

begin_define
define|#
directive|define
name|WSP_SIZEOF_FINGER_SENSOR_DATA
value|sizeof(struct wsp_finger_sensor_data)
end_define

begin_define
define|#
directive|define
name|WSP_SIZEOF_ALL_FINGER_DATA
value|(WSP_MAX_FINGERS * \ 				       WSP_SIZEOF_FINGER_SENSOR_DATA)
end_define

begin_define
define|#
directive|define
name|WSP_MAX_FINGER_ORIENTATION
value|16384
end_define

begin_define
define|#
directive|define
name|ATP_SENSOR_DATA_BUF_MAX
value|1024
end_define

begin_if
if|#
directive|if
operator|(
name|ATP_SENSOR_DATA_BUF_MAX
operator|<
operator|(
operator|(
name|WSP_MAX_FINGERS
operator|*
literal|14
operator|*
literal|2
operator|)
operator|+
expr|\
name|WSP_TYPE3_FINGER_DATA_OFFSET
operator|)
operator|)
end_if

begin_comment
comment|/* note: 14 * 2 in the above is based on sizeof(struct wsp_finger_sensor_data)*/
end_comment

begin_error
error|#
directive|error
literal|"ATP_SENSOR_DATA_BUF_MAX is too small"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ATP_MAX_STROKES
value|MAX(WSP_MAX_FINGERS, FG_MAX_STROKES)
end_define

begin_define
define|#
directive|define
name|FG_MAX_XSENSORS
value|26
end_define

begin_define
define|#
directive|define
name|FG_MAX_YSENSORS
value|16
end_define

begin_comment
comment|/* device-specific configuration */
end_comment

begin_struct
struct|struct
name|fg_dev_params
block|{
name|u_int
name|data_len
decl_stmt|;
comment|/* for sensor data */
name|u_int
name|n_xsensors
decl_stmt|;
name|u_int
name|n_ysensors
decl_stmt|;
name|enum
name|fountain_geyser_trackpad_type
name|prot
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|wsp_dev_params
block|{
name|uint8_t
name|caps
decl_stmt|;
comment|/* device capability bitmask */
name|uint8_t
name|tp_type
decl_stmt|;
comment|/* type of trackpad interface */
name|uint8_t
name|finger_data_offset
decl_stmt|;
comment|/* offset to trackpad finger data */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|fg_dev_params
name|fg_dev_params
index|[
name|FOUNTAIN_GEYSER_PRODUCT_MAX
index|]
init|=
block|{
index|[
name|FOUNTAIN
index|]
operator|=
block|{
operator|.
name|data_len
operator|=
literal|81
block|,
operator|.
name|n_xsensors
operator|=
literal|16
block|,
operator|.
name|n_ysensors
operator|=
literal|16
block|,
operator|.
name|prot
operator|=
name|FG_TRACKPAD_TYPE_GEYSER1
block|}
block|,
index|[
name|GEYSER1
index|]
operator|=
block|{
operator|.
name|data_len
operator|=
literal|81
block|,
operator|.
name|n_xsensors
operator|=
literal|16
block|,
operator|.
name|n_ysensors
operator|=
literal|16
block|,
operator|.
name|prot
operator|=
name|FG_TRACKPAD_TYPE_GEYSER1
block|}
block|,
index|[
name|GEYSER1_17inch
index|]
operator|=
block|{
operator|.
name|data_len
operator|=
literal|81
block|,
operator|.
name|n_xsensors
operator|=
literal|26
block|,
operator|.
name|n_ysensors
operator|=
literal|16
block|,
operator|.
name|prot
operator|=
name|FG_TRACKPAD_TYPE_GEYSER1
block|}
block|,
index|[
name|GEYSER2
index|]
operator|=
block|{
operator|.
name|data_len
operator|=
literal|64
block|,
operator|.
name|n_xsensors
operator|=
literal|15
block|,
operator|.
name|n_ysensors
operator|=
literal|9
block|,
operator|.
name|prot
operator|=
name|FG_TRACKPAD_TYPE_GEYSER2
block|}
block|,
index|[
name|GEYSER3
index|]
operator|=
block|{
operator|.
name|data_len
operator|=
literal|64
block|,
operator|.
name|n_xsensors
operator|=
literal|20
block|,
operator|.
name|n_ysensors
operator|=
literal|10
block|,
operator|.
name|prot
operator|=
name|FG_TRACKPAD_TYPE_GEYSER3
block|}
block|,
index|[
name|GEYSER4
index|]
operator|=
block|{
operator|.
name|data_len
operator|=
literal|64
block|,
operator|.
name|n_xsensors
operator|=
literal|20
block|,
operator|.
name|n_ysensors
operator|=
literal|10
block|,
operator|.
name|prot
operator|=
name|FG_TRACKPAD_TYPE_GEYSER4
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|STRUCT_USB_HOST_ID
name|fg_devs
index|[]
init|=
block|{
comment|/* PowerBooks Feb 2005, iBooks G4 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x020e
argument_list|,
argument|FG_DRIVER_INFO(FOUNTAIN)
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x020f
argument_list|,
argument|FG_DRIVER_INFO(FOUNTAIN)
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x0210
argument_list|,
argument|FG_DRIVER_INFO(FOUNTAIN)
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x030a
argument_list|,
argument|FG_DRIVER_INFO(FOUNTAIN)
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x030b
argument_list|,
argument|FG_DRIVER_INFO(GEYSER1)
argument_list|)
block|}
block|,
comment|/* PowerBooks Oct 2005 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x0214
argument_list|,
argument|FG_DRIVER_INFO(GEYSER2)
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x0215
argument_list|,
argument|FG_DRIVER_INFO(GEYSER2)
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x0216
argument_list|,
argument|FG_DRIVER_INFO(GEYSER2)
argument_list|)
block|}
block|,
comment|/* Core Duo MacBook& MacBook Pro */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x0217
argument_list|,
argument|FG_DRIVER_INFO(GEYSER3)
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x0218
argument_list|,
argument|FG_DRIVER_INFO(GEYSER3)
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x0219
argument_list|,
argument|FG_DRIVER_INFO(GEYSER3)
argument_list|)
block|}
block|,
comment|/* Core2 Duo MacBook& MacBook Pro */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x021a
argument_list|,
argument|FG_DRIVER_INFO(GEYSER4)
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x021b
argument_list|,
argument|FG_DRIVER_INFO(GEYSER4)
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x021c
argument_list|,
argument|FG_DRIVER_INFO(GEYSER4)
argument_list|)
block|}
block|,
comment|/* Core2 Duo MacBook3,1 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x0229
argument_list|,
argument|FG_DRIVER_INFO(GEYSER4)
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x022a
argument_list|,
argument|FG_DRIVER_INFO(GEYSER4)
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x022b
argument_list|,
argument|FG_DRIVER_INFO(GEYSER4)
argument_list|)
block|}
block|,
comment|/* 17 inch PowerBook */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x020d
argument_list|,
argument|FG_DRIVER_INFO(GEYSER1_17inch)
argument_list|)
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|wsp_dev_params
name|wsp_dev_params
index|[
name|WELLSPRING_PRODUCT_MAX
index|]
init|=
block|{
index|[
name|WELLSPRING1
index|]
operator|=
block|{
operator|.
name|caps
operator|=
literal|0
block|,
operator|.
name|tp_type
operator|=
name|WSP_TRACKPAD_TYPE1
block|,
operator|.
name|finger_data_offset
operator|=
name|WSP_TYPE1_FINGER_DATA_OFFSET
block|, 	}
block|,
index|[
name|WELLSPRING2
index|]
operator|=
block|{
operator|.
name|caps
operator|=
literal|0
block|,
operator|.
name|tp_type
operator|=
name|WSP_TRACKPAD_TYPE1
block|,
operator|.
name|finger_data_offset
operator|=
name|WSP_TYPE1_FINGER_DATA_OFFSET
block|, 	}
block|,
index|[
name|WELLSPRING3
index|]
operator|=
block|{
operator|.
name|caps
operator|=
name|HAS_INTEGRATED_BUTTON
block|,
operator|.
name|tp_type
operator|=
name|WSP_TRACKPAD_TYPE2
block|,
operator|.
name|finger_data_offset
operator|=
name|WSP_TYPE2_FINGER_DATA_OFFSET
block|, 	}
block|,
index|[
name|WELLSPRING4
index|]
operator|=
block|{
operator|.
name|caps
operator|=
name|HAS_INTEGRATED_BUTTON
block|,
operator|.
name|tp_type
operator|=
name|WSP_TRACKPAD_TYPE2
block|,
operator|.
name|finger_data_offset
operator|=
name|WSP_TYPE2_FINGER_DATA_OFFSET
block|, 	}
block|,
index|[
name|WELLSPRING4A
index|]
operator|=
block|{
operator|.
name|caps
operator|=
name|HAS_INTEGRATED_BUTTON
block|,
operator|.
name|tp_type
operator|=
name|WSP_TRACKPAD_TYPE2
block|,
operator|.
name|finger_data_offset
operator|=
name|WSP_TYPE2_FINGER_DATA_OFFSET
block|, 	}
block|,
index|[
name|WELLSPRING5
index|]
operator|=
block|{
operator|.
name|caps
operator|=
name|HAS_INTEGRATED_BUTTON
block|,
operator|.
name|tp_type
operator|=
name|WSP_TRACKPAD_TYPE2
block|,
operator|.
name|finger_data_offset
operator|=
name|WSP_TYPE2_FINGER_DATA_OFFSET
block|, 	}
block|,
index|[
name|WELLSPRING6
index|]
operator|=
block|{
operator|.
name|caps
operator|=
name|HAS_INTEGRATED_BUTTON
block|,
operator|.
name|tp_type
operator|=
name|WSP_TRACKPAD_TYPE2
block|,
operator|.
name|finger_data_offset
operator|=
name|WSP_TYPE2_FINGER_DATA_OFFSET
block|, 	}
block|,
index|[
name|WELLSPRING5A
index|]
operator|=
block|{
operator|.
name|caps
operator|=
name|HAS_INTEGRATED_BUTTON
block|,
operator|.
name|tp_type
operator|=
name|WSP_TRACKPAD_TYPE2
block|,
operator|.
name|finger_data_offset
operator|=
name|WSP_TYPE2_FINGER_DATA_OFFSET
block|, 	}
block|,
index|[
name|WELLSPRING6A
index|]
operator|=
block|{
operator|.
name|caps
operator|=
name|HAS_INTEGRATED_BUTTON
block|,
operator|.
name|tp_type
operator|=
name|WSP_TRACKPAD_TYPE2
block|,
operator|.
name|finger_data_offset
operator|=
name|WSP_TYPE2_FINGER_DATA_OFFSET
block|, 	}
block|,
index|[
name|WELLSPRING7
index|]
operator|=
block|{
operator|.
name|caps
operator|=
name|HAS_INTEGRATED_BUTTON
block|,
operator|.
name|tp_type
operator|=
name|WSP_TRACKPAD_TYPE2
block|,
operator|.
name|finger_data_offset
operator|=
name|WSP_TYPE2_FINGER_DATA_OFFSET
block|, 	}
block|,
index|[
name|WELLSPRING7A
index|]
operator|=
block|{
operator|.
name|caps
operator|=
name|HAS_INTEGRATED_BUTTON
block|,
operator|.
name|tp_type
operator|=
name|WSP_TRACKPAD_TYPE2
block|,
operator|.
name|finger_data_offset
operator|=
name|WSP_TYPE2_FINGER_DATA_OFFSET
block|, 	}
block|,
index|[
name|WELLSPRING8
index|]
operator|=
block|{
operator|.
name|caps
operator|=
name|HAS_INTEGRATED_BUTTON
block|,
operator|.
name|tp_type
operator|=
name|WSP_TRACKPAD_TYPE3
block|,
operator|.
name|finger_data_offset
operator|=
name|WSP_TYPE3_FINGER_DATA_OFFSET
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ATP_DEV
parameter_list|(
name|v
parameter_list|,
name|p
parameter_list|,
name|i
parameter_list|)
value|{ USB_VPI(USB_VENDOR_##v, USB_PRODUCT_##v##_##p, i) }
end_define

begin_comment
comment|/* TODO: STRUCT_USB_HOST_ID */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_device_id
name|wsp_devs
index|[]
init|=
block|{
comment|/* MacbookAir1.1 */
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING_ANSI
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING1
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING_ISO
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING1
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING_JIS
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING1
argument_list|)
argument_list|)
block|,
comment|/* MacbookProPenryn, aka wellspring2 */
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING2_ANSI
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING2
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING2_ISO
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING2
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING2_JIS
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING2
argument_list|)
argument_list|)
block|,
comment|/* Macbook5,1 (unibody), aka wellspring3 */
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING3_ANSI
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING3
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING3_ISO
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING3
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING3_JIS
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING3
argument_list|)
argument_list|)
block|,
comment|/* MacbookAir3,2 (unibody), aka wellspring4 */
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING4_ANSI
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING4
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING4_ISO
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING4
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING4_JIS
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING4
argument_list|)
argument_list|)
block|,
comment|/* MacbookAir3,1 (unibody), aka wellspring4 */
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING4A_ANSI
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING4A
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING4A_ISO
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING4A
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING4A_JIS
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING4A
argument_list|)
argument_list|)
block|,
comment|/* Macbook8 (unibody, March 2011) */
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING5_ANSI
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING5
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING5_ISO
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING5
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING5_JIS
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING5
argument_list|)
argument_list|)
block|,
comment|/* MacbookAir4,1 (unibody, July 2011) */
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING6A_ANSI
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING6A
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING6A_ISO
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING6A
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING6A_JIS
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING6A
argument_list|)
argument_list|)
block|,
comment|/* MacbookAir4,2 (unibody, July 2011) */
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING6_ANSI
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING6
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING6_ISO
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING6
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING6_JIS
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING6
argument_list|)
argument_list|)
block|,
comment|/* Macbook8,2 (unibody) */
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING5A_ANSI
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING5A
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING5A_ISO
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING5A
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING5A_JIS
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING5A
argument_list|)
argument_list|)
block|,
comment|/* MacbookPro10,1 (unibody, June 2012) */
comment|/* MacbookPro11,? (unibody, June 2013) */
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING7_ANSI
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING7
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING7_ISO
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING7
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING7_JIS
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING7
argument_list|)
argument_list|)
block|,
comment|/* MacbookPro10,2 (unibody, October 2012) */
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING7A_ANSI
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING7A
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING7A_ISO
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING7A
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING7A_JIS
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING7A
argument_list|)
argument_list|)
block|,
comment|/* MacbookAir6,2 (unibody, June 2013) */
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING8_ANSI
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING8
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING8_ISO
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING8
argument_list|)
argument_list|)
block|,
name|ATP_DEV
argument_list|(
name|APPLE
argument_list|,
name|WELLSPRING8_JIS
argument_list|,
name|WELLSPRING_DRIVER_INFO
argument_list|(
name|WELLSPRING8
argument_list|)
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
name|atp_stroke_type
block|{
name|ATP_STROKE_TOUCH
block|,
name|ATP_STROKE_SLIDE
block|, }
name|atp_stroke_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
name|atp_axis
block|{
name|X
init|=
literal|0
block|,
name|Y
init|=
literal|1
block|,
name|NUM_AXES
block|}
name|atp_axis
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ATP_FIFO_BUF_SIZE
value|8
end_define

begin_comment
comment|/* bytes */
end_comment

begin_define
define|#
directive|define
name|ATP_FIFO_QUEUE_MAXLEN
value|50
end_define

begin_comment
comment|/* units */
end_comment

begin_enum
enum|enum
block|{
name|ATP_INTR_DT
block|,
name|ATP_RESET
block|,
name|ATP_N_TRANSFER
block|, }
enum|;
end_enum

begin_typedef
typedef|typedef
struct|struct
name|fg_stroke_component
block|{
comment|/* Fields encapsulating the pressure-span. */
name|u_int
name|loc
decl_stmt|;
comment|/* location (scaled) */
name|u_int
name|cum_pressure
decl_stmt|;
comment|/* cumulative compression */
name|u_int
name|max_cum_pressure
decl_stmt|;
comment|/* max cumulative compression */
name|boolean_t
name|matched
decl_stmt|;
comment|/*to track components as they match against pspans.*/
name|int
name|delta_mickeys
decl_stmt|;
comment|/* change in location (un-smoothened movement)*/
block|}
name|fg_stroke_component_t
typedef|;
end_typedef

begin_comment
comment|/*  * The following structure captures a finger contact with the  * touchpad. A stroke comprises two p-span components and some state.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|atp_stroke
block|{
name|TAILQ_ENTRY
argument_list|(
argument|atp_stroke
argument_list|)
name|entry
expr_stmt|;
name|atp_stroke_type
name|type
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
comment|/* the state of this stroke */
define|#
directive|define
name|ATSF_ZOMBIE
value|0x1
name|boolean_t
name|matched
decl_stmt|;
comment|/* to track match against fingers.*/
name|struct
name|timeval
name|ctime
decl_stmt|;
comment|/* create time; for coincident siblings. */
comment|/* 	 * Unit: interrupts; we maintain this value in 	 * addition to 'ctime' in order to avoid the 	 * expensive call to microtime() at every 	 * interrupt. 	 */
name|uint32_t
name|age
decl_stmt|;
comment|/* Location */
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
comment|/* Fields containing information about movement. */
name|int
name|instantaneous_dx
decl_stmt|;
comment|/* curr. change in X location (un-smoothened) */
name|int
name|instantaneous_dy
decl_stmt|;
comment|/* curr. change in Y location (un-smoothened) */
name|int
name|pending_dx
decl_stmt|;
comment|/* cum. of pending short movements */
name|int
name|pending_dy
decl_stmt|;
comment|/* cum. of pending short movements */
name|int
name|movement_dx
decl_stmt|;
comment|/* interpreted smoothened movement */
name|int
name|movement_dy
decl_stmt|;
comment|/* interpreted smoothened movement */
name|int
name|cum_movement_x
decl_stmt|;
comment|/* cum. horizontal movement */
name|int
name|cum_movement_y
decl_stmt|;
comment|/* cum. vertical movement */
comment|/* 	 * The following member is relevant only for fountain-geyser trackpads. 	 * For these, there is the need to track pressure-spans and cumulative 	 * pressures for stroke components. 	 */
name|fg_stroke_component_t
name|components
index|[
name|NUM_AXES
index|]
decl_stmt|;
block|}
name|atp_stroke_t
typedef|;
end_typedef

begin_struct_decl
struct_decl|struct
name|atp_softc
struct_decl|;
end_struct_decl

begin_comment
comment|/* forward declaration */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|sensor_data_interpreter_t
function_decl|)
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|len
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|atp_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|sc_usb_device
decl_stmt|;
name|struct
name|mtx
name|sc_mutex
decl_stmt|;
comment|/* for synchronization */
name|struct
name|usb_fifo_sc
name|sc_fifo
decl_stmt|;
define|#
directive|define
name|MODE_LENGTH
value|8
name|char
name|sc_mode_bytes
index|[
name|MODE_LENGTH
index|]
decl_stmt|;
comment|/* device mode */
name|trackpad_family_t
name|sc_family
decl_stmt|;
specifier|const
name|void
modifier|*
name|sc_params
decl_stmt|;
comment|/* device configuration */
name|sensor_data_interpreter_t
name|sensor_data_interpreter
decl_stmt|;
name|mousehw_t
name|sc_hw
decl_stmt|;
name|mousemode_t
name|sc_mode
decl_stmt|;
name|mousestatus_t
name|sc_status
decl_stmt|;
name|u_int
name|sc_state
decl_stmt|;
define|#
directive|define
name|ATP_ENABLED
value|0x01
define|#
directive|define
name|ATP_ZOMBIES_EXIST
value|0x02
define|#
directive|define
name|ATP_DOUBLE_TAP_DRAG
value|0x04
define|#
directive|define
name|ATP_VALID
value|0x08
name|struct
name|usb_xfer
modifier|*
name|sc_xfer
index|[
name|ATP_N_TRANSFER
index|]
decl_stmt|;
name|u_int
name|sc_pollrate
decl_stmt|;
name|int
name|sc_fflags
decl_stmt|;
name|atp_stroke_t
name|sc_strokes_data
index|[
name|ATP_MAX_STROKES
index|]
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|atp_stroke
argument_list|)
name|sc_stroke_free
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|atp_stroke
argument_list|)
name|sc_stroke_used
expr_stmt|;
name|u_int
name|sc_n_strokes
decl_stmt|;
name|struct
name|callout
name|sc_callout
decl_stmt|;
comment|/* 	 * button status. Set to non-zero if the mouse-button is physically 	 * pressed. This state variable is exposed through softc to allow 	 * reap_sibling_zombies to avoid registering taps while the trackpad 	 * button is pressed.          */
name|uint8_t
name|sc_ibtn
decl_stmt|;
comment|/* 	 * Time when touch zombies were last reaped; useful for detecting 	 * double-touch-n-drag. 	 */
name|struct
name|timeval
name|sc_touch_reap_time
decl_stmt|;
name|u_int
name|sc_idlecount
decl_stmt|;
comment|/* Regarding the data transferred from t-pad in USB INTR packets. */
name|u_int
name|sc_expected_sensor_data_len
decl_stmt|;
name|uint8_t
name|sc_sensor_data
index|[
name|ATP_SENSOR_DATA_BUF_MAX
index|]
name|__aligned
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|int
name|sc_cur_x
index|[
name|FG_MAX_XSENSORS
index|]
decl_stmt|;
comment|/* current sensor readings */
name|int
name|sc_cur_y
index|[
name|FG_MAX_YSENSORS
index|]
decl_stmt|;
name|int
name|sc_base_x
index|[
name|FG_MAX_XSENSORS
index|]
decl_stmt|;
comment|/* base sensor readings */
name|int
name|sc_base_y
index|[
name|FG_MAX_YSENSORS
index|]
decl_stmt|;
name|int
name|sc_pressure_x
index|[
name|FG_MAX_XSENSORS
index|]
decl_stmt|;
comment|/* computed pressures */
name|int
name|sc_pressure_y
index|[
name|FG_MAX_YSENSORS
index|]
decl_stmt|;
name|fg_pspan
name|sc_pspans_x
index|[
name|FG_MAX_PSPANS_PER_AXIS
index|]
decl_stmt|;
name|fg_pspan
name|sc_pspans_y
index|[
name|FG_MAX_PSPANS_PER_AXIS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The last byte of the fountain-geyser sensor data contains status bits; the  * following values define the meanings of these bits.  * (only Geyser 3/4)  */
end_comment

begin_enum
enum|enum
name|geyser34_status_bits
block|{
name|FG_STATUS_BUTTON
init|=
operator|(
name|uint8_t
operator|)
literal|0x01
block|,
comment|/* The button was pressed */
name|FG_STATUS_BASE_UPDATE
init|=
operator|(
name|uint8_t
operator|)
literal|0x04
block|,
comment|/* Data from an untouched pad.*/
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
enum|enum
name|interface_mode
block|{
name|RAW_SENSOR_MODE
init|=
operator|(
name|uint8_t
operator|)
literal|0x01
block|,
name|HID_MODE
init|=
operator|(
name|uint8_t
operator|)
literal|0x08
block|}
name|interface_mode
typedef|;
end_typedef

begin_comment
comment|/*  * function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|usb_fifo_cmd_t
name|atp_start_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_fifo_cmd_t
name|atp_stop_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_fifo_open_t
name|atp_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_fifo_close_t
name|atp_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_fifo_ioctl_t
name|atp_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|usb_fifo_methods
name|atp_fifo_methods
init|=
block|{
operator|.
name|f_open
operator|=
operator|&
name|atp_open
block|,
operator|.
name|f_close
operator|=
operator|&
name|atp_close
block|,
operator|.
name|f_ioctl
operator|=
operator|&
name|atp_ioctl
block|,
operator|.
name|f_start_read
operator|=
operator|&
name|atp_start_read
block|,
operator|.
name|f_stop_read
operator|=
operator|&
name|atp_stop_read
block|,
operator|.
name|basename
index|[
literal|0
index|]
operator|=
name|ATP_DRIVER_NAME
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device initialization and shutdown */
end_comment

begin_function_decl
specifier|static
name|usb_error_t
name|atp_set_device_mode
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|interface_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_reset_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|,
name|usb_error_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atp_enable
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_disable
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* sensor interpretation */
end_comment

begin_function_decl
specifier|static
name|void
name|fg_interpret_sensor_data
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fg_extract_sensor_data
parameter_list|(
specifier|const
name|int8_t
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|atp_axis
parameter_list|,
name|int
modifier|*
parameter_list|,
name|enum
name|fountain_geyser_trackpad_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fg_get_pressures
parameter_list|(
name|int
modifier|*
parameter_list|,
specifier|const
name|int
modifier|*
parameter_list|,
specifier|const
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fg_detect_pspans
parameter_list|(
name|int
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|fg_pspan
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wsp_interpret_sensor_data
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* movement detection */
end_comment

begin_function_decl
specifier|static
name|boolean_t
name|fg_match_stroke_component
parameter_list|(
name|fg_stroke_component_t
modifier|*
parameter_list|,
specifier|const
name|fg_pspan
modifier|*
parameter_list|,
name|atp_stroke_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fg_match_strokes_against_pspans
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|atp_axis
parameter_list|,
name|fg_pspan
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|wsp_match_strokes_against_fingers
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|wsp_finger_t
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|fg_update_strokes
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|fg_pspan
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|fg_pspan
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|wsp_update_strokes
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|wsp_finger_t
index|[
name|WSP_MAX_FINGERS
index|]
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fg_add_stroke
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
specifier|const
name|fg_pspan
modifier|*
parameter_list|,
specifier|const
name|fg_pspan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fg_add_new_strokes
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|fg_pspan
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|fg_pspan
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wsp_add_stroke
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
specifier|const
name|wsp_finger_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_advance_stroke_state
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|atp_stroke_t
modifier|*
parameter_list|,
name|boolean_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|atp_stroke_has_small_movement
parameter_list|(
specifier|const
name|atp_stroke_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_update_pending_mickeys
parameter_list|(
name|atp_stroke_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|atp_compute_stroke_movement
parameter_list|(
name|atp_stroke_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_terminate_stroke
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|atp_stroke_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* tap detection */
end_comment

begin_function_decl
specifier|static
name|boolean_t
name|atp_is_horizontal_scroll
parameter_list|(
specifier|const
name|atp_stroke_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|atp_is_vertical_scroll
parameter_list|(
specifier|const
name|atp_stroke_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_reap_sibling_zombies
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_convert_to_slide
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|atp_stroke_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* updating fifo */
end_comment

begin_function_decl
specifier|static
name|void
name|atp_reset_buf
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_add_to_queue
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Device methods. */
end_comment

begin_decl_stmt
specifier|static
name|device_probe_t
name|atp_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|atp_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|atp_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|atp_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|atp_xfer_config
index|[
name|ATP_N_TRANSFER
index|]
init|=
block|{
index|[
name|ATP_INTR_DT
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_INTERRUPT
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
comment|/* block pipe on failure */
operator|.
name|short_xfer_ok
operator|=
literal|1
block|, 		}
block|,
operator|.
name|bufsize
operator|=
name|ATP_SENSOR_DATA_BUF_MAX
block|,
operator|.
name|callback
operator|=
operator|&
name|atp_intr
block|, 	}
block|,
index|[
name|ATP_RESET
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
operator|+
name|MODE_LENGTH
block|,
operator|.
name|callback
operator|=
operator|&
name|atp_reset_callback
block|,
operator|.
name|interval
operator|=
literal|0
block|,
comment|/* no pre-delay */
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|atp_stroke_t
modifier|*
name|atp_alloc_stroke
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|atp_stroke_t
modifier|*
name|pstroke
decl_stmt|;
name|pstroke
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_stroke_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|pstroke
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_stroke_free
argument_list|,
name|pstroke
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pstroke
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pstroke
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_stroke_used
argument_list|,
name|pstroke
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_n_strokes
operator|++
expr_stmt|;
name|done
label|:
return|return
operator|(
name|pstroke
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_free_stroke
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|atp_stroke_t
modifier|*
name|pstroke
parameter_list|)
block|{
if|if
condition|(
name|pstroke
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|->
name|sc_n_strokes
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_stroke_used
argument_list|,
name|pstroke
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_stroke_free
argument_list|,
name|pstroke
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_init_stroke_pool
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|x
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_stroke_free
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_stroke_used
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_n_strokes
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|sc_strokes_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_strokes_data
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|ATP_MAX_STROKES
condition|;
name|x
operator|++
control|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_stroke_free
argument_list|,
operator|&
name|sc
operator|->
name|sc_strokes_data
index|[
name|x
index|]
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|atp_set_device_mode
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|interface_mode
name|newMode
parameter_list|)
block|{
name|uint8_t
name|mode_value
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|newMode
operator|!=
name|RAW_SENSOR_MODE
operator|)
operator|&&
operator|(
name|newMode
operator|!=
name|HID_MODE
operator|)
condition|)
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
if|if
condition|(
operator|(
name|newMode
operator|==
name|RAW_SENSOR_MODE
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_family
operator|==
name|TRACKPAD_FAMILY_FOUNTAIN_GEYSER
operator|)
condition|)
name|mode_value
operator|=
operator|(
name|uint8_t
operator|)
literal|0x04
expr_stmt|;
else|else
name|mode_value
operator|=
name|newMode
expr_stmt|;
name|err
operator|=
name|usbd_req_get_report
argument_list|(
name|sc
operator|->
name|sc_usb_device
argument_list|,
name|NULL
comment|/* mutex */
argument_list|,
name|sc
operator|->
name|sc_mode_bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_mode_bytes
argument_list|)
argument_list|,
literal|0
comment|/* interface idx */
argument_list|,
literal|0x03
comment|/* type */
argument_list|,
literal|0x00
comment|/* id */
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Failed to read device mode (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_mode_bytes
index|[
literal|0
index|]
operator|==
name|mode_value
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * XXX Need to wait at least 250ms for hardware to get 	 * ready. The device mode handling appears to be handled 	 * asynchronously and we should not issue these commands too 	 * quickly. 	 */
name|pause
argument_list|(
literal|"WHW"
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mode_bytes
index|[
literal|0
index|]
operator|=
name|mode_value
expr_stmt|;
return|return
operator|(
name|usbd_req_set_report
argument_list|(
name|sc
operator|->
name|sc_usb_device
argument_list|,
name|NULL
comment|/* mutex */
argument_list|,
name|sc
operator|->
name|sc_mode_bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_mode_bytes
argument_list|)
argument_list|,
literal|0
comment|/* interface idx */
argument_list|,
literal|0x03
comment|/* type */
argument_list|,
literal|0x00
comment|/* id */
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_reset_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|uint8_t
name|mode_value
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_family
operator|==
name|TRACKPAD_FAMILY_FOUNTAIN_GEYSER
condition|)
name|mode_value
operator|=
literal|0x04
expr_stmt|;
else|else
name|mode_value
operator|=
name|RAW_SENSOR_MODE
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_SETUP
case|:
name|sc
operator|->
name|sc_mode_bytes
index|[
literal|0
index|]
operator|=
name|mode_value
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_CLASS_INTERFACE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_SET_REPORT
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
operator|(
name|uint8_t
operator|)
literal|0x03
comment|/* type */
argument_list|,
operator|(
name|uint8_t
operator|)
literal|0x00
comment|/* id */
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|MODE_LENGTH
argument_list|)
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_mode_bytes
argument_list|,
name|MODE_LENGTH
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|,
name|MODE_LENGTH
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frames
argument_list|(
name|xfer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_ST_TRANSFERRED
case|:
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|atp_enable
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|&
name|ATP_ENABLED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* reset status */
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|sc_status
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_status
argument_list|)
argument_list|)
expr_stmt|;
name|atp_init_stroke_pool
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator||=
name|ATP_ENABLED
expr_stmt|;
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"enabled atp\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_disable
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_state
operator|&=
operator|~
operator|(
name|ATP_ENABLED
operator||
name|ATP_VALID
operator|)
expr_stmt|;
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"disabled atp\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fg_interpret_sensor_data
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|data_len
parameter_list|)
block|{
name|u_int
name|n_xpspans
init|=
literal|0
decl_stmt|;
name|u_int
name|n_ypspans
init|=
literal|0
decl_stmt|;
name|uint8_t
name|status_bits
decl_stmt|;
specifier|const
name|struct
name|fg_dev_params
modifier|*
name|params
init|=
operator|(
specifier|const
expr|struct
name|fg_dev_params
operator|*
operator|)
name|sc
operator|->
name|sc_params
decl_stmt|;
name|fg_extract_sensor_data
argument_list|(
name|sc
operator|->
name|sc_sensor_data
argument_list|,
name|params
operator|->
name|n_xsensors
argument_list|,
name|X
argument_list|,
name|sc
operator|->
name|sc_cur_x
argument_list|,
name|params
operator|->
name|prot
argument_list|)
expr_stmt|;
name|fg_extract_sensor_data
argument_list|(
name|sc
operator|->
name|sc_sensor_data
argument_list|,
name|params
operator|->
name|n_ysensors
argument_list|,
name|Y
argument_list|,
name|sc
operator|->
name|sc_cur_y
argument_list|,
name|params
operator|->
name|prot
argument_list|)
expr_stmt|;
comment|/* 	 * If this is the initial update (from an untouched 	 * pad), we should set the base values for the sensor 	 * data; deltas with respect to these base values can 	 * be used as pressure readings subsequently. 	 */
name|status_bits
operator|=
name|sc
operator|->
name|sc_sensor_data
index|[
name|params
operator|->
name|data_len
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|params
operator|->
name|prot
operator|==
name|FG_TRACKPAD_TYPE_GEYSER3
operator|)
operator|||
operator|(
name|params
operator|->
name|prot
operator|==
name|FG_TRACKPAD_TYPE_GEYSER4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|sc
operator|->
name|sc_state
operator|&
name|ATP_VALID
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|status_bits
operator|&
name|FG_STATUS_BASE_UPDATE
condition|)
block|{
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_base_x
argument_list|,
name|sc
operator|->
name|sc_cur_x
argument_list|,
name|params
operator|->
name|n_xsensors
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|sc_base_x
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_base_y
argument_list|,
name|sc
operator|->
name|sc_cur_y
argument_list|,
name|params
operator|->
name|n_ysensors
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|sc_base_y
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator||=
name|ATP_VALID
expr_stmt|;
return|return;
block|}
block|}
comment|/* Get pressure readings and detect p-spans for both axes. */
name|fg_get_pressures
argument_list|(
name|sc
operator|->
name|sc_pressure_x
argument_list|,
name|sc
operator|->
name|sc_cur_x
argument_list|,
name|sc
operator|->
name|sc_base_x
argument_list|,
name|params
operator|->
name|n_xsensors
argument_list|)
expr_stmt|;
name|fg_detect_pspans
argument_list|(
name|sc
operator|->
name|sc_pressure_x
argument_list|,
name|params
operator|->
name|n_xsensors
argument_list|,
name|FG_MAX_PSPANS_PER_AXIS
argument_list|,
name|sc
operator|->
name|sc_pspans_x
argument_list|,
operator|&
name|n_xpspans
argument_list|)
expr_stmt|;
name|fg_get_pressures
argument_list|(
name|sc
operator|->
name|sc_pressure_y
argument_list|,
name|sc
operator|->
name|sc_cur_y
argument_list|,
name|sc
operator|->
name|sc_base_y
argument_list|,
name|params
operator|->
name|n_ysensors
argument_list|)
expr_stmt|;
name|fg_detect_pspans
argument_list|(
name|sc
operator|->
name|sc_pressure_y
argument_list|,
name|params
operator|->
name|n_ysensors
argument_list|,
name|FG_MAX_PSPANS_PER_AXIS
argument_list|,
name|sc
operator|->
name|sc_pspans_y
argument_list|,
operator|&
name|n_ypspans
argument_list|)
expr_stmt|;
comment|/* Update strokes with new pspans to detect movements. */
if|if
condition|(
name|fg_update_strokes
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_pspans_x
argument_list|,
name|n_xpspans
argument_list|,
name|sc
operator|->
name|sc_pspans_y
argument_list|,
name|n_ypspans
argument_list|)
condition|)
name|sc
operator|->
name|sc_status
operator|.
name|flags
operator||=
name|MOUSE_POSCHANGED
expr_stmt|;
name|sc
operator|->
name|sc_ibtn
operator|=
operator|(
name|status_bits
operator|&
name|FG_STATUS_BUTTON
operator|)
condition|?
name|MOUSE_BUTTON1DOWN
else|:
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|=
name|sc
operator|->
name|sc_ibtn
expr_stmt|;
comment|/* 	 * The Fountain/Geyser device continues to trigger interrupts 	 * at a fast rate even after touchpad activity has 	 * stopped. Upon detecting that the device has remained idle 	 * beyond a threshold, we reinitialize it to silence the 	 * interrupts. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_status
operator|.
name|flags
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_n_strokes
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_idlecount
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_idlecount
operator|>=
name|ATP_IDLENESS_THRESHOLD
condition|)
block|{
comment|/* 			 * Use the last frame before we go idle for 			 * calibration on pads which do not send 			 * calibration frames. 			 */
specifier|const
name|struct
name|fg_dev_params
modifier|*
name|params
init|=
operator|(
specifier|const
expr|struct
name|fg_dev_params
operator|*
operator|)
name|sc
operator|->
name|sc_params
decl_stmt|;
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"idle\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|prot
operator|<
name|FG_TRACKPAD_TYPE_GEYSER3
condition|)
block|{
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_base_x
argument_list|,
name|sc
operator|->
name|sc_cur_x
argument_list|,
name|params
operator|->
name|n_xsensors
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|sc
operator|->
name|sc_base_x
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_base_y
argument_list|,
name|sc
operator|->
name|sc_cur_y
argument_list|,
name|params
operator|->
name|n_ysensors
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|sc
operator|->
name|sc_base_y
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_idlecount
operator|=
literal|0
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|ATP_RESET
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|sc_idlecount
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Interpret the data from the X and Y pressure sensors. This function  * is called separately for the X and Y sensor arrays. The data in the  * USB packet is laid out in the following manner:  *  * sensor_data:  *            --,--,Y1,Y2,--,Y3,Y4,--,Y5,...,Y10, ... X1,X2,--,X3,X4  *  indices:   0  1  2  3  4  5  6  7  8 ...  15  ... 20 21 22 23 24  *  * '--' (in the above) indicates that the value is unimportant.  *  * Information about the above layout was obtained from the  * implementation of the AppleTouch driver in Linux.  *  * parameters:  *   sensor_data  *       raw sensor data from the USB packet.  *   num  *       The number of elements in the array 'arr'.  *   axis  *       Axis of data to fetch  *   arr  *       The array to be initialized with the readings.  *   prot  *       The protocol to use to interpret the data  */
end_comment

begin_function
specifier|static
name|void
name|fg_extract_sensor_data
parameter_list|(
specifier|const
name|int8_t
modifier|*
name|sensor_data
parameter_list|,
name|u_int
name|num
parameter_list|,
name|atp_axis
name|axis
parameter_list|,
name|int
modifier|*
name|arr
parameter_list|,
name|enum
name|fountain_geyser_trackpad_type
name|prot
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|u_int
name|di
decl_stmt|;
comment|/* index into sensor data */
switch|switch
condition|(
name|prot
condition|)
block|{
case|case
name|FG_TRACKPAD_TYPE_GEYSER1
case|:
comment|/* 		 * For Geyser 1, the sensors are laid out in pairs 		 * every 5 bytes. 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|di
operator|=
operator|(
name|axis
operator|==
name|Y
operator|)
condition|?
literal|1
else|:
literal|2
init|;
name|i
operator|<
literal|8
condition|;
name|di
operator|+=
literal|5
operator|,
name|i
operator|++
control|)
block|{
name|arr
index|[
name|i
index|]
operator|=
name|sensor_data
index|[
name|di
index|]
expr_stmt|;
name|arr
index|[
name|i
operator|+
literal|8
index|]
operator|=
name|sensor_data
index|[
name|di
operator|+
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|axis
operator|==
name|X
operator|)
operator|&&
operator|(
name|num
operator|>
literal|16
operator|)
condition|)
name|arr
index|[
name|i
operator|+
literal|16
index|]
operator|=
name|sensor_data
index|[
name|di
operator|+
literal|40
index|]
expr_stmt|;
block|}
break|break;
case|case
name|FG_TRACKPAD_TYPE_GEYSER2
case|:
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|di
operator|=
operator|(
name|axis
operator|==
name|Y
operator|)
condition|?
literal|1
else|:
literal|19
init|;
name|i
operator|<
name|num
condition|;
comment|/* empty */
control|)
block|{
name|arr
index|[
name|i
operator|++
index|]
operator|=
name|sensor_data
index|[
name|di
operator|++
index|]
expr_stmt|;
name|arr
index|[
name|i
operator|++
index|]
operator|=
name|sensor_data
index|[
name|di
operator|++
index|]
expr_stmt|;
name|di
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|FG_TRACKPAD_TYPE_GEYSER3
case|:
case|case
name|FG_TRACKPAD_TYPE_GEYSER4
case|:
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|di
operator|=
operator|(
name|axis
operator|==
name|Y
operator|)
condition|?
literal|2
else|:
literal|20
init|;
name|i
operator|<
name|num
condition|;
comment|/* empty */
control|)
block|{
name|arr
index|[
name|i
operator|++
index|]
operator|=
name|sensor_data
index|[
name|di
operator|++
index|]
expr_stmt|;
name|arr
index|[
name|i
operator|++
index|]
operator|=
name|sensor_data
index|[
name|di
operator|++
index|]
expr_stmt|;
name|di
operator|++
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fg_get_pressures
parameter_list|(
name|int
modifier|*
name|p
parameter_list|,
specifier|const
name|int
modifier|*
name|cur
parameter_list|,
specifier|const
name|int
modifier|*
name|base
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|p
index|[
name|i
index|]
operator|=
name|cur
index|[
name|i
index|]
operator|-
name|base
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
index|[
name|i
index|]
operator|>
literal|127
condition|)
name|p
index|[
name|i
index|]
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
name|p
index|[
name|i
index|]
operator|<
operator|-
literal|127
condition|)
name|p
index|[
name|i
index|]
operator|+=
literal|256
expr_stmt|;
if|if
condition|(
name|p
index|[
name|i
index|]
operator|<
literal|0
condition|)
name|p
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Shave off pressures below the noise-pressure 		 * threshold; this will reduce the contribution from 		 * lower pressure readings. 		 */
if|if
condition|(
operator|(
name|u_int
operator|)
name|p
index|[
name|i
index|]
operator|<=
name|FG_SENSOR_NOISE_THRESHOLD
condition|)
name|p
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* filter away noise */
else|else
name|p
index|[
name|i
index|]
operator|-=
name|FG_SENSOR_NOISE_THRESHOLD
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fg_detect_pspans
parameter_list|(
name|int
modifier|*
name|p
parameter_list|,
name|u_int
name|num_sensors
parameter_list|,
name|u_int
name|max_spans
parameter_list|,
comment|/* max # of pspans permitted */
name|fg_pspan
modifier|*
name|spans
parameter_list|,
comment|/* finger spans */
name|u_int
modifier|*
name|nspans_p
parameter_list|)
comment|/* num spans detected */
block|{
name|u_int
name|i
decl_stmt|;
name|int
name|maxp
decl_stmt|;
comment|/* max pressure seen within a span */
name|u_int
name|num_spans
init|=
literal|0
decl_stmt|;
enum|enum
name|fg_pspan_state
block|{
name|ATP_PSPAN_INACTIVE
block|,
name|ATP_PSPAN_INCREASING
block|,
name|ATP_PSPAN_DECREASING
block|, 	}
name|state
enum|;
comment|/* state of the pressure span */
comment|/* 	 * The following is a simple state machine to track 	 * the phase of the pressure span. 	 */
name|memset
argument_list|(
name|spans
argument_list|,
literal|0
argument_list|,
name|max_spans
operator|*
sizeof|sizeof
argument_list|(
name|fg_pspan
argument_list|)
argument_list|)
expr_stmt|;
name|maxp
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|ATP_PSPAN_INACTIVE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_sensors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|num_spans
operator|>=
name|max_spans
condition|)
break|break;
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|ATP_PSPAN_INACTIVE
condition|)
block|{
comment|/* 				 * There is no pressure information for this 				 * sensor, and we aren't tracking a finger. 				 */
continue|continue;
block|}
else|else
block|{
name|state
operator|=
name|ATP_PSPAN_INACTIVE
expr_stmt|;
name|maxp
operator|=
literal|0
expr_stmt|;
name|num_spans
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ATP_PSPAN_INACTIVE
case|:
name|state
operator|=
name|ATP_PSPAN_INCREASING
expr_stmt|;
name|maxp
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|ATP_PSPAN_INCREASING
case|:
if|if
condition|(
name|p
index|[
name|i
index|]
operator|>
name|maxp
condition|)
name|maxp
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
name|i
index|]
operator|<=
operator|(
name|maxp
operator|>>
literal|1
operator|)
condition|)
name|state
operator|=
name|ATP_PSPAN_DECREASING
expr_stmt|;
break|break;
case|case
name|ATP_PSPAN_DECREASING
case|:
if|if
condition|(
name|p
index|[
name|i
index|]
operator|>
name|p
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
comment|/* 					 * This is the beginning of 					 * another span; change state 					 * to give the appearance that 					 * we're starting from an 					 * inactive span, and then 					 * re-process this reading in 					 * the next iteration. 					 */
name|num_spans
operator|++
expr_stmt|;
name|state
operator|=
name|ATP_PSPAN_INACTIVE
expr_stmt|;
name|maxp
operator|=
literal|0
expr_stmt|;
name|i
operator|--
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* Update the finger span with this reading. */
name|spans
index|[
name|num_spans
index|]
operator|.
name|width
operator|++
expr_stmt|;
name|spans
index|[
name|num_spans
index|]
operator|.
name|cum
operator|+=
name|p
index|[
name|i
index|]
expr_stmt|;
name|spans
index|[
name|num_spans
index|]
operator|.
name|cog
operator|+=
name|p
index|[
name|i
index|]
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|state
operator|!=
name|ATP_PSPAN_INACTIVE
condition|)
name|num_spans
operator|++
expr_stmt|;
comment|/* close the last finger span */
comment|/* post-process the spans */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_spans
condition|;
name|i
operator|++
control|)
block|{
comment|/* filter away unwanted pressure spans */
if|if
condition|(
operator|(
name|spans
index|[
name|i
index|]
operator|.
name|cum
operator|<
name|FG_PSPAN_MIN_CUM_PRESSURE
operator|)
operator|||
operator|(
name|spans
index|[
name|i
index|]
operator|.
name|width
operator|>
name|FG_PSPAN_MAX_WIDTH
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|num_spans
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|spans
index|[
name|i
index|]
argument_list|,
operator|&
name|spans
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|num_spans
operator|-
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|fg_pspan
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
name|num_spans
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* compute this span's representative location */
name|spans
index|[
name|i
index|]
operator|.
name|loc
operator|=
name|spans
index|[
name|i
index|]
operator|.
name|cog
operator|*
name|FG_SCALE_FACTOR
operator|/
name|spans
index|[
name|i
index|]
operator|.
name|cum
expr_stmt|;
name|spans
index|[
name|i
index|]
operator|.
name|matched
operator|=
name|false
expr_stmt|;
comment|/* not yet matched against a stroke */
block|}
operator|*
name|nspans_p
operator|=
name|num_spans
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wsp_interpret_sensor_data
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|data_len
parameter_list|)
block|{
specifier|const
name|struct
name|wsp_dev_params
modifier|*
name|params
init|=
name|sc
operator|->
name|sc_params
decl_stmt|;
name|wsp_finger_t
name|fingers
index|[
name|WSP_MAX_FINGERS
index|]
decl_stmt|;
name|struct
name|wsp_finger_sensor_data
modifier|*
name|source_fingerp
decl_stmt|;
name|u_int
name|n_source_fingers
decl_stmt|;
name|u_int
name|n_fingers
decl_stmt|;
name|u_int
name|i
decl_stmt|;
comment|/* validate sensor data length */
if|if
condition|(
operator|(
name|data_len
operator|<
name|params
operator|->
name|finger_data_offset
operator|)
operator|||
operator|(
operator|(
name|data_len
operator|-
name|params
operator|->
name|finger_data_offset
operator|)
operator|%
name|WSP_SIZEOF_FINGER_SENSOR_DATA
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* compute number of source fingers */
name|n_source_fingers
operator|=
operator|(
name|data_len
operator|-
name|params
operator|->
name|finger_data_offset
operator|)
operator|/
name|WSP_SIZEOF_FINGER_SENSOR_DATA
expr_stmt|;
if|if
condition|(
name|n_source_fingers
operator|>
name|WSP_MAX_FINGERS
condition|)
name|n_source_fingers
operator|=
name|WSP_MAX_FINGERS
expr_stmt|;
comment|/* iterate over the source data collecting useful fingers */
name|n_fingers
operator|=
literal|0
expr_stmt|;
name|source_fingerp
operator|=
operator|(
expr|struct
name|wsp_finger_sensor_data
operator|*
operator|)
operator|(
name|sc
operator|->
name|sc_sensor_data
operator|+
name|params
operator|->
name|finger_data_offset
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_source_fingers
condition|;
name|i
operator|++
operator|,
name|source_fingerp
operator|++
control|)
block|{
comment|/* swap endianness, if any */
if|if
condition|(
name|le16toh
argument_list|(
literal|0x1234
argument_list|)
operator|!=
literal|0x1234
condition|)
block|{
name|source_fingerp
operator|->
name|origin
operator|=
name|le16toh
argument_list|(
operator|(
name|uint16_t
operator|)
name|source_fingerp
operator|->
name|origin
argument_list|)
expr_stmt|;
name|source_fingerp
operator|->
name|abs_x
operator|=
name|le16toh
argument_list|(
operator|(
name|uint16_t
operator|)
name|source_fingerp
operator|->
name|abs_x
argument_list|)
expr_stmt|;
name|source_fingerp
operator|->
name|abs_y
operator|=
name|le16toh
argument_list|(
operator|(
name|uint16_t
operator|)
name|source_fingerp
operator|->
name|abs_y
argument_list|)
expr_stmt|;
name|source_fingerp
operator|->
name|rel_x
operator|=
name|le16toh
argument_list|(
operator|(
name|uint16_t
operator|)
name|source_fingerp
operator|->
name|rel_x
argument_list|)
expr_stmt|;
name|source_fingerp
operator|->
name|rel_y
operator|=
name|le16toh
argument_list|(
operator|(
name|uint16_t
operator|)
name|source_fingerp
operator|->
name|rel_y
argument_list|)
expr_stmt|;
name|source_fingerp
operator|->
name|tool_major
operator|=
name|le16toh
argument_list|(
operator|(
name|uint16_t
operator|)
name|source_fingerp
operator|->
name|tool_major
argument_list|)
expr_stmt|;
name|source_fingerp
operator|->
name|tool_minor
operator|=
name|le16toh
argument_list|(
operator|(
name|uint16_t
operator|)
name|source_fingerp
operator|->
name|tool_minor
argument_list|)
expr_stmt|;
name|source_fingerp
operator|->
name|orientation
operator|=
name|le16toh
argument_list|(
operator|(
name|uint16_t
operator|)
name|source_fingerp
operator|->
name|orientation
argument_list|)
expr_stmt|;
name|source_fingerp
operator|->
name|touch_major
operator|=
name|le16toh
argument_list|(
operator|(
name|uint16_t
operator|)
name|source_fingerp
operator|->
name|touch_major
argument_list|)
expr_stmt|;
name|source_fingerp
operator|->
name|touch_minor
operator|=
name|le16toh
argument_list|(
operator|(
name|uint16_t
operator|)
name|source_fingerp
operator|->
name|touch_minor
argument_list|)
expr_stmt|;
name|source_fingerp
operator|->
name|multi
operator|=
name|le16toh
argument_list|(
operator|(
name|uint16_t
operator|)
name|source_fingerp
operator|->
name|multi
argument_list|)
expr_stmt|;
block|}
comment|/* check for minium threshold */
if|if
condition|(
name|source_fingerp
operator|->
name|touch_major
operator|==
literal|0
condition|)
continue|continue;
name|fingers
index|[
name|n_fingers
index|]
operator|.
name|matched
operator|=
name|false
expr_stmt|;
name|fingers
index|[
name|n_fingers
index|]
operator|.
name|x
operator|=
name|source_fingerp
operator|->
name|abs_x
expr_stmt|;
name|fingers
index|[
name|n_fingers
index|]
operator|.
name|y
operator|=
operator|-
name|source_fingerp
operator|->
name|abs_y
expr_stmt|;
name|n_fingers
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_n_strokes
operator|==
literal|0
operator|)
operator|&&
operator|(
name|n_fingers
operator|==
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
name|wsp_update_strokes
argument_list|(
name|sc
argument_list|,
name|fingers
argument_list|,
name|n_fingers
argument_list|)
condition|)
name|sc
operator|->
name|sc_status
operator|.
name|flags
operator||=
name|MOUSE_POSCHANGED
expr_stmt|;
switch|switch
condition|(
name|params
operator|->
name|tp_type
condition|)
block|{
case|case
name|WSP_TRACKPAD_TYPE2
case|:
name|sc
operator|->
name|sc_ibtn
operator|=
name|sc
operator|->
name|sc_sensor_data
index|[
name|WSP_TYPE2_BUTTON_DATA_OFFSET
index|]
expr_stmt|;
break|break;
case|case
name|WSP_TRACKPAD_TYPE3
case|:
name|sc
operator|->
name|sc_ibtn
operator|=
name|sc
operator|->
name|sc_sensor_data
index|[
name|WSP_TYPE3_BUTTON_DATA_OFFSET
index|]
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|=
name|sc
operator|->
name|sc_ibtn
condition|?
name|MOUSE_BUTTON1DOWN
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Match a pressure-span against a stroke-component. If there is a  * match, update the component's state and return true.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|fg_match_stroke_component
parameter_list|(
name|fg_stroke_component_t
modifier|*
name|component
parameter_list|,
specifier|const
name|fg_pspan
modifier|*
name|pspan
parameter_list|,
name|atp_stroke_type
name|stroke_type
parameter_list|)
block|{
name|int
name|delta_mickeys
decl_stmt|;
name|u_int
name|min_pressure
decl_stmt|;
name|delta_mickeys
operator|=
name|pspan
operator|->
name|loc
operator|-
name|component
operator|->
name|loc
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|delta_mickeys
argument_list|)
operator|>
operator|(
name|int
operator|)
name|FG_MAX_DELTA_MICKEYS
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* the finger span is too far out; no match */
name|component
operator|->
name|loc
operator|=
name|pspan
operator|->
name|loc
expr_stmt|;
comment|/* 	 * A sudden and significant increase in a pspan's cumulative 	 * pressure indicates the incidence of a new finger 	 * contact. This usually revises the pspan's 	 * centre-of-gravity, and hence the location of any/all 	 * matching stroke component(s). But such a change should 	 * *not* be interpreted as a movement. 	 */
if|if
condition|(
name|pspan
operator|->
name|cum
operator|>
operator|(
operator|(
literal|3
operator|*
name|component
operator|->
name|cum_pressure
operator|)
operator|>>
literal|1
operator|)
condition|)
name|delta_mickeys
operator|=
literal|0
expr_stmt|;
name|component
operator|->
name|cum_pressure
operator|=
name|pspan
operator|->
name|cum
expr_stmt|;
if|if
condition|(
name|pspan
operator|->
name|cum
operator|>
name|component
operator|->
name|max_cum_pressure
condition|)
name|component
operator|->
name|max_cum_pressure
operator|=
name|pspan
operator|->
name|cum
expr_stmt|;
comment|/* 	 * Disregard the component's movement if its cumulative 	 * pressure drops below a fraction of the maximum; this 	 * fraction is determined based on the stroke's type. 	 */
if|if
condition|(
name|stroke_type
operator|==
name|ATP_STROKE_TOUCH
condition|)
name|min_pressure
operator|=
operator|(
literal|3
operator|*
name|component
operator|->
name|max_cum_pressure
operator|)
operator|>>
literal|2
expr_stmt|;
else|else
name|min_pressure
operator|=
name|component
operator|->
name|max_cum_pressure
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|component
operator|->
name|cum_pressure
operator|<
name|min_pressure
condition|)
name|delta_mickeys
operator|=
literal|0
expr_stmt|;
name|component
operator|->
name|delta_mickeys
operator|=
name|delta_mickeys
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fg_match_strokes_against_pspans
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|atp_axis
name|axis
parameter_list|,
name|fg_pspan
modifier|*
name|pspans
parameter_list|,
name|u_int
name|n_pspans
parameter_list|,
name|u_int
name|repeat_count
parameter_list|)
block|{
name|atp_stroke_t
modifier|*
name|strokep
decl_stmt|;
name|u_int
name|repeat_index
init|=
literal|0
decl_stmt|;
name|u_int
name|i
decl_stmt|;
comment|/* Determine the index of the multi-span. */
if|if
condition|(
name|repeat_count
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_pspans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pspans
index|[
name|i
index|]
operator|.
name|cum
operator|>
name|pspans
index|[
name|repeat_index
index|]
operator|.
name|cum
condition|)
name|repeat_index
operator|=
name|i
expr_stmt|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|strokep
argument_list|,
argument|&sc->sc_stroke_used
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|strokep
operator|->
name|components
index|[
name|axis
index|]
operator|.
name|matched
condition|)
continue|continue;
comment|/* skip matched components */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_pspans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pspans
index|[
name|i
index|]
operator|.
name|matched
condition|)
continue|continue;
comment|/* skip matched pspans */
if|if
condition|(
name|fg_match_stroke_component
argument_list|(
operator|&
name|strokep
operator|->
name|components
index|[
name|axis
index|]
argument_list|,
operator|&
name|pspans
index|[
name|i
index|]
argument_list|,
name|strokep
operator|->
name|type
argument_list|)
condition|)
block|{
comment|/* There is a match. */
name|strokep
operator|->
name|components
index|[
name|axis
index|]
operator|.
name|matched
operator|=
name|true
expr_stmt|;
comment|/* Take care to repeat at the multi-span. */
if|if
condition|(
operator|(
name|repeat_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|i
operator|==
name|repeat_index
operator|)
condition|)
name|repeat_count
operator|--
expr_stmt|;
else|else
name|pspans
index|[
name|i
index|]
operator|.
name|matched
operator|=
name|true
expr_stmt|;
break|break;
comment|/* skip to the next strokep */
block|}
block|}
comment|/* loop over pspans */
block|}
comment|/* loop over strokes */
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|wsp_match_strokes_against_fingers
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|wsp_finger_t
modifier|*
name|fingers
parameter_list|,
name|u_int
name|n_fingers
parameter_list|)
block|{
name|boolean_t
name|movement
init|=
name|false
decl_stmt|;
name|atp_stroke_t
modifier|*
name|strokep
decl_stmt|;
name|u_int
name|i
decl_stmt|;
comment|/* reset the matched status for all strokes */
name|TAILQ_FOREACH
argument_list|(
argument|strokep
argument_list|,
argument|&sc->sc_stroke_used
argument_list|,
argument|entry
argument_list|)
name|strokep
operator|->
name|matched
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|n_fingers
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|least_distance_sq
init|=
name|WSP_MAX_ALLOWED_MATCH_DISTANCE_SQ
decl_stmt|;
name|atp_stroke_t
modifier|*
name|strokep_best
init|=
name|NULL
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|strokep
argument_list|,
argument|&sc->sc_stroke_used
argument_list|,
argument|entry
argument_list|)
block|{
name|int
name|instantaneous_dx
decl_stmt|;
name|int
name|instantaneous_dy
decl_stmt|;
name|u_int
name|d_squared
decl_stmt|;
if|if
condition|(
name|strokep
operator|->
name|matched
condition|)
continue|continue;
name|instantaneous_dx
operator|=
name|fingers
index|[
name|i
index|]
operator|.
name|x
operator|-
name|strokep
operator|->
name|x
expr_stmt|;
name|instantaneous_dy
operator|=
name|fingers
index|[
name|i
index|]
operator|.
name|y
operator|-
name|strokep
operator|->
name|y
expr_stmt|;
comment|/* skip strokes which are far away */
name|d_squared
operator|=
operator|(
name|instantaneous_dx
operator|*
name|instantaneous_dx
operator|)
operator|+
operator|(
name|instantaneous_dy
operator|*
name|instantaneous_dy
operator|)
expr_stmt|;
if|if
condition|(
name|d_squared
operator|<
name|least_distance_sq
condition|)
block|{
name|least_distance_sq
operator|=
name|d_squared
expr_stmt|;
name|strokep_best
operator|=
name|strokep
expr_stmt|;
block|}
block|}
name|strokep
operator|=
name|strokep_best
expr_stmt|;
if|if
condition|(
name|strokep
operator|!=
name|NULL
condition|)
block|{
name|fingers
index|[
name|i
index|]
operator|.
name|matched
operator|=
name|true
expr_stmt|;
name|strokep
operator|->
name|matched
operator|=
name|true
expr_stmt|;
name|strokep
operator|->
name|instantaneous_dx
operator|=
name|fingers
index|[
name|i
index|]
operator|.
name|x
operator|-
name|strokep
operator|->
name|x
expr_stmt|;
name|strokep
operator|->
name|instantaneous_dy
operator|=
name|fingers
index|[
name|i
index|]
operator|.
name|y
operator|-
name|strokep
operator|->
name|y
expr_stmt|;
name|strokep
operator|->
name|x
operator|=
name|fingers
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|strokep
operator|->
name|y
operator|=
name|fingers
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
name|atp_advance_stroke_state
argument_list|(
name|sc
argument_list|,
name|strokep
argument_list|,
operator|&
name|movement
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|movement
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update strokes by matching against current pressure-spans.  * Return true if any movement is detected.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|fg_update_strokes
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|fg_pspan
modifier|*
name|pspans_x
parameter_list|,
name|u_int
name|n_xpspans
parameter_list|,
name|fg_pspan
modifier|*
name|pspans_y
parameter_list|,
name|u_int
name|n_ypspans
parameter_list|)
block|{
name|atp_stroke_t
modifier|*
name|strokep
decl_stmt|;
name|atp_stroke_t
modifier|*
name|strokep_next
decl_stmt|;
name|boolean_t
name|movement
init|=
name|false
decl_stmt|;
name|u_int
name|repeat_count
init|=
literal|0
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_int
name|j
decl_stmt|;
comment|/* Reset X and Y components of all strokes as unmatched. */
name|TAILQ_FOREACH
argument_list|(
argument|strokep
argument_list|,
argument|&sc->sc_stroke_used
argument_list|,
argument|entry
argument_list|)
block|{
name|strokep
operator|->
name|components
index|[
name|X
index|]
operator|.
name|matched
operator|=
name|false
expr_stmt|;
name|strokep
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|matched
operator|=
name|false
expr_stmt|;
block|}
comment|/* 	 * Usually, the X and Y pspans come in pairs (the common case 	 * being a single pair). It is possible, however, that 	 * multiple contacts resolve to a single pspan along an 	 * axis, as illustrated in the following: 	 * 	 *   F = finger-contact 	 * 	 *                pspan  pspan 	 *        +-----------------------+ 	 *        |         .      .      | 	 *        |         .      .      | 	 *        |         .      .      | 	 *        |         .      .      | 	 *  pspan |.........F......F      | 	 *        |                       | 	 *        |                       | 	 *        |                       | 	 *        +-----------------------+ 	 * 	 * 	 * The above case can be detected by a difference in the 	 * number of X and Y pspans. When this happens, X and Y pspans 	 * aren't easy to pair or match against strokes. 	 * 	 * When X and Y pspans differ in number, the axis with the 	 * smaller number of pspans is regarded as having a repeating 	 * pspan (or a multi-pspan)--in the above illustration, the 	 * Y-axis has a repeating pspan. Our approach is to try to 	 * match the multi-pspan repeatedly against strokes. The 	 * difference between the number of X and Y pspans gives us a 	 * crude repeat_count for matching multi-pspans--i.e. the 	 * multi-pspan along the Y axis (above) has a repeat_count of 1. 	 */
name|repeat_count
operator|=
name|abs
argument_list|(
name|n_xpspans
operator|-
name|n_ypspans
argument_list|)
expr_stmt|;
name|fg_match_strokes_against_pspans
argument_list|(
name|sc
argument_list|,
name|X
argument_list|,
name|pspans_x
argument_list|,
name|n_xpspans
argument_list|,
operator|(
operator|(
operator|(
name|repeat_count
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|n_xpspans
operator|<
name|n_ypspans
operator|)
operator|)
operator|)
condition|?
name|repeat_count
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|fg_match_strokes_against_pspans
argument_list|(
name|sc
argument_list|,
name|Y
argument_list|,
name|pspans_y
argument_list|,
name|n_ypspans
argument_list|,
operator|(
operator|(
operator|(
name|repeat_count
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|n_ypspans
operator|<
name|n_xpspans
operator|)
operator|)
condition|?
name|repeat_count
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Update the state of strokes based on the above pspan matches. */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|strokep
argument_list|,
argument|&sc->sc_stroke_used
argument_list|,
argument|entry
argument_list|,
argument|strokep_next
argument_list|)
block|{
if|if
condition|(
name|strokep
operator|->
name|components
index|[
name|X
index|]
operator|.
name|matched
operator|&&
name|strokep
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|matched
condition|)
block|{
name|strokep
operator|->
name|matched
operator|=
name|true
expr_stmt|;
name|strokep
operator|->
name|instantaneous_dx
operator|=
name|strokep
operator|->
name|components
index|[
name|X
index|]
operator|.
name|delta_mickeys
expr_stmt|;
name|strokep
operator|->
name|instantaneous_dy
operator|=
name|strokep
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|delta_mickeys
expr_stmt|;
name|atp_advance_stroke_state
argument_list|(
name|sc
argument_list|,
name|strokep
argument_list|,
operator|&
name|movement
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * At least one component of this stroke 			 * didn't match against current pspans; 			 * terminate it. 			 */
name|atp_terminate_stroke
argument_list|(
name|sc
argument_list|,
name|strokep
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add new strokes for pairs of unmatched pspans */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_xpspans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pspans_x
index|[
name|i
index|]
operator|.
name|matched
operator|==
name|false
condition|)
break|break;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_ypspans
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pspans_y
index|[
name|j
index|]
operator|.
name|matched
operator|==
name|false
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|i
operator|<
name|n_xpspans
operator|)
operator|&&
operator|(
name|j
operator|<
name|n_ypspans
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|atp_debug
operator|>=
name|ATP_LLEVEL_INFO
condition|)
block|{
name|printf
argument_list|(
literal|"unmatched pspans:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|n_xpspans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pspans_x
index|[
name|i
index|]
operator|.
name|matched
condition|)
continue|continue;
name|printf
argument_list|(
literal|" X:[loc:%u,cum:%u]"
argument_list|,
name|pspans_x
index|[
name|i
index|]
operator|.
name|loc
argument_list|,
name|pspans_x
index|[
name|i
index|]
operator|.
name|cum
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|j
operator|<
name|n_ypspans
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pspans_y
index|[
name|j
index|]
operator|.
name|matched
condition|)
continue|continue;
name|printf
argument_list|(
literal|" Y:[loc:%u,cum:%u]"
argument_list|,
name|pspans_y
index|[
name|j
index|]
operator|.
name|loc
argument_list|,
name|pspans_y
index|[
name|j
index|]
operator|.
name|cum
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USB_DEBUG */
if|if
condition|(
operator|(
name|n_xpspans
operator|==
literal|1
operator|)
operator|&&
operator|(
name|n_ypspans
operator|==
literal|1
operator|)
condition|)
comment|/* The common case of a single pair of new pspans. */
name|fg_add_stroke
argument_list|(
name|sc
argument_list|,
operator|&
name|pspans_x
index|[
literal|0
index|]
argument_list|,
operator|&
name|pspans_y
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|fg_add_new_strokes
argument_list|(
name|sc
argument_list|,
name|pspans_x
argument_list|,
name|n_xpspans
argument_list|,
name|pspans_y
argument_list|,
name|n_ypspans
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|atp_debug
operator|>=
name|ATP_LLEVEL_INFO
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|strokep
argument_list|,
argument|&sc->sc_stroke_used
argument_list|,
argument|entry
argument_list|)
block|{
name|printf
argument_list|(
literal|" %s%clc:%u,dm:%d,cum:%d,max:%d,%c"
literal|",%clc:%u,dm:%d,cum:%d,max:%d,%c"
argument_list|,
operator|(
name|strokep
operator|->
name|flags
operator|&
name|ATSF_ZOMBIE
operator|)
condition|?
literal|"zomb:"
else|:
literal|""
argument_list|,
operator|(
name|strokep
operator|->
name|type
operator|==
name|ATP_STROKE_TOUCH
operator|)
condition|?
literal|'['
else|:
literal|'<'
argument_list|,
name|strokep
operator|->
name|components
index|[
name|X
index|]
operator|.
name|loc
argument_list|,
name|strokep
operator|->
name|components
index|[
name|X
index|]
operator|.
name|delta_mickeys
argument_list|,
name|strokep
operator|->
name|components
index|[
name|X
index|]
operator|.
name|cum_pressure
argument_list|,
name|strokep
operator|->
name|components
index|[
name|X
index|]
operator|.
name|max_cum_pressure
argument_list|,
operator|(
name|strokep
operator|->
name|type
operator|==
name|ATP_STROKE_TOUCH
operator|)
condition|?
literal|']'
else|:
literal|'>'
argument_list|,
operator|(
name|strokep
operator|->
name|type
operator|==
name|ATP_STROKE_TOUCH
operator|)
condition|?
literal|'['
else|:
literal|'<'
argument_list|,
name|strokep
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|loc
argument_list|,
name|strokep
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|delta_mickeys
argument_list|,
name|strokep
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|cum_pressure
argument_list|,
name|strokep
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|max_cum_pressure
argument_list|,
operator|(
name|strokep
operator|->
name|type
operator|==
name|ATP_STROKE_TOUCH
operator|)
condition|?
literal|']'
else|:
literal|'>'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_stroke_used
argument_list|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USB_DEBUG */
return|return
operator|(
name|movement
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update strokes by matching against current pressure-spans.  * Return true if any movement is detected.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|wsp_update_strokes
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|wsp_finger_t
modifier|*
name|fingers
parameter_list|,
name|u_int
name|n_fingers
parameter_list|)
block|{
name|boolean_t
name|movement
init|=
name|false
decl_stmt|;
name|atp_stroke_t
modifier|*
name|strokep_next
decl_stmt|;
name|atp_stroke_t
modifier|*
name|strokep
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_n_strokes
operator|>
literal|0
condition|)
block|{
name|movement
operator|=
name|wsp_match_strokes_against_fingers
argument_list|(
name|sc
argument_list|,
name|fingers
argument_list|,
name|n_fingers
argument_list|)
expr_stmt|;
comment|/* handle zombie strokes */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|strokep
argument_list|,
argument|&sc->sc_stroke_used
argument_list|,
argument|entry
argument_list|,
argument|strokep_next
argument_list|)
block|{
if|if
condition|(
name|strokep
operator|->
name|matched
condition|)
continue|continue;
name|atp_terminate_stroke
argument_list|(
name|sc
argument_list|,
name|strokep
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* initialize unmatched fingers as strokes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|n_fingers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fingers
index|[
name|i
index|]
operator|.
name|matched
condition|)
continue|continue;
name|wsp_add_stroke
argument_list|(
name|sc
argument_list|,
name|fingers
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|movement
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize a stroke using a pressure-span. */
end_comment

begin_function
specifier|static
name|void
name|fg_add_stroke
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|fg_pspan
modifier|*
name|pspan_x
parameter_list|,
specifier|const
name|fg_pspan
modifier|*
name|pspan_y
parameter_list|)
block|{
name|atp_stroke_t
modifier|*
name|strokep
decl_stmt|;
name|strokep
operator|=
name|atp_alloc_stroke
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|strokep
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Strokes begin as potential touches. If a stroke survives 	 * longer than a threshold, or if it records significant 	 * cumulative movement, then it is considered a 'slide'. 	 */
name|strokep
operator|->
name|type
operator|=
name|ATP_STROKE_TOUCH
expr_stmt|;
name|strokep
operator|->
name|matched
operator|=
name|false
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|strokep
operator|->
name|ctime
argument_list|)
expr_stmt|;
name|strokep
operator|->
name|age
operator|=
literal|1
expr_stmt|;
comment|/* number of interrupts */
name|strokep
operator|->
name|x
operator|=
name|pspan_x
operator|->
name|loc
expr_stmt|;
name|strokep
operator|->
name|y
operator|=
name|pspan_y
operator|->
name|loc
expr_stmt|;
name|strokep
operator|->
name|components
index|[
name|X
index|]
operator|.
name|loc
operator|=
name|pspan_x
operator|->
name|loc
expr_stmt|;
name|strokep
operator|->
name|components
index|[
name|X
index|]
operator|.
name|cum_pressure
operator|=
name|pspan_x
operator|->
name|cum
expr_stmt|;
name|strokep
operator|->
name|components
index|[
name|X
index|]
operator|.
name|max_cum_pressure
operator|=
name|pspan_x
operator|->
name|cum
expr_stmt|;
name|strokep
operator|->
name|components
index|[
name|X
index|]
operator|.
name|matched
operator|=
name|true
expr_stmt|;
name|strokep
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|loc
operator|=
name|pspan_y
operator|->
name|loc
expr_stmt|;
name|strokep
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|cum_pressure
operator|=
name|pspan_y
operator|->
name|cum
expr_stmt|;
name|strokep
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|max_cum_pressure
operator|=
name|pspan_y
operator|->
name|cum
expr_stmt|;
name|strokep
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|matched
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_n_strokes
operator|>
literal|1
condition|)
block|{
comment|/* Reset double-tap-n-drag if we have more than one strokes. */
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|ATP_DOUBLE_TAP_DRAG
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"[%u,%u], time: %u,%ld\n"
argument_list|,
name|strokep
operator|->
name|components
index|[
name|X
index|]
operator|.
name|loc
argument_list|,
name|strokep
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|loc
argument_list|,
operator|(
name|u_int
operator|)
name|strokep
operator|->
name|ctime
operator|.
name|tv_sec
argument_list|,
operator|(
name|unsigned
name|long
name|int
operator|)
name|strokep
operator|->
name|ctime
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fg_add_new_strokes
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|fg_pspan
modifier|*
name|pspans_x
parameter_list|,
name|u_int
name|n_xpspans
parameter_list|,
name|fg_pspan
modifier|*
name|pspans_y
parameter_list|,
name|u_int
name|n_ypspans
parameter_list|)
block|{
name|fg_pspan
name|spans
index|[
literal|2
index|]
index|[
name|FG_MAX_PSPANS_PER_AXIS
index|]
decl_stmt|;
name|u_int
name|nspans
index|[
literal|2
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_int
name|j
decl_stmt|;
comment|/* Copy unmatched pspans into the local arrays. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|nspans
index|[
name|X
index|]
operator|=
literal|0
init|;
name|i
operator|<
name|n_xpspans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pspans_x
index|[
name|i
index|]
operator|.
name|matched
operator|==
name|false
condition|)
block|{
name|spans
index|[
name|X
index|]
index|[
name|nspans
index|[
name|X
index|]
index|]
operator|=
name|pspans_x
index|[
name|i
index|]
expr_stmt|;
name|nspans
index|[
name|X
index|]
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|nspans
index|[
name|Y
index|]
operator|=
literal|0
init|;
name|j
operator|<
name|n_ypspans
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pspans_y
index|[
name|j
index|]
operator|.
name|matched
operator|==
name|false
condition|)
block|{
name|spans
index|[
name|Y
index|]
index|[
name|nspans
index|[
name|Y
index|]
index|]
operator|=
name|pspans_y
index|[
name|j
index|]
expr_stmt|;
name|nspans
index|[
name|Y
index|]
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nspans
index|[
name|X
index|]
operator|==
name|nspans
index|[
name|Y
index|]
condition|)
block|{
comment|/* Create new strokes from pairs of unmatched pspans */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|nspans
index|[
name|X
index|]
operator|)
operator|&&
operator|(
name|j
operator|<
name|nspans
index|[
name|Y
index|]
operator|)
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|fg_add_stroke
argument_list|(
name|sc
argument_list|,
operator|&
name|spans
index|[
name|X
index|]
index|[
name|i
index|]
argument_list|,
operator|&
name|spans
index|[
name|Y
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int
name|cum
init|=
literal|0
decl_stmt|;
name|atp_axis
name|repeat_axis
decl_stmt|;
comment|/* axis with multi-pspans */
name|u_int
name|repeat_count
decl_stmt|;
comment|/* repeat count for the multi-pspan*/
name|u_int
name|repeat_index
init|=
literal|0
decl_stmt|;
comment|/* index of the multi-span */
name|repeat_axis
operator|=
operator|(
name|nspans
index|[
name|X
index|]
operator|>
name|nspans
index|[
name|Y
index|]
operator|)
condition|?
name|Y
else|:
name|X
expr_stmt|;
name|repeat_count
operator|=
name|abs
argument_list|(
name|nspans
index|[
name|X
index|]
operator|-
name|nspans
index|[
name|Y
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspans
index|[
name|repeat_axis
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spans
index|[
name|repeat_axis
index|]
index|[
name|i
index|]
operator|.
name|cum
operator|>
name|cum
condition|)
block|{
name|repeat_index
operator|=
name|i
expr_stmt|;
name|cum
operator|=
name|spans
index|[
name|repeat_axis
index|]
index|[
name|i
index|]
operator|.
name|cum
expr_stmt|;
block|}
block|}
comment|/* Create new strokes from pairs of unmatched pspans */
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|i
operator|<
name|nspans
index|[
name|X
index|]
operator|)
operator|&&
operator|(
name|j
operator|<
name|nspans
index|[
name|Y
index|]
operator|)
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|fg_add_stroke
argument_list|(
name|sc
argument_list|,
operator|&
name|spans
index|[
name|X
index|]
index|[
name|i
index|]
argument_list|,
operator|&
name|spans
index|[
name|Y
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
comment|/* Take care to repeat at the multi-pspan. */
if|if
condition|(
name|repeat_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|repeat_axis
operator|==
name|X
operator|)
operator|&&
operator|(
name|repeat_index
operator|==
name|i
operator|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
comment|/* counter loop increment */
name|repeat_count
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|repeat_axis
operator|==
name|Y
operator|)
operator|&&
operator|(
name|repeat_index
operator|==
name|j
operator|)
condition|)
block|{
name|j
operator|--
expr_stmt|;
comment|/* counter loop increment */
name|repeat_count
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Initialize a stroke from an unmatched finger. */
end_comment

begin_function
specifier|static
name|void
name|wsp_add_stroke
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|wsp_finger_t
modifier|*
name|fingerp
parameter_list|)
block|{
name|atp_stroke_t
modifier|*
name|strokep
decl_stmt|;
name|strokep
operator|=
name|atp_alloc_stroke
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|strokep
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Strokes begin as potential touches. If a stroke survives 	 * longer than a threshold, or if it records significant 	 * cumulative movement, then it is considered a 'slide'. 	 */
name|strokep
operator|->
name|type
operator|=
name|ATP_STROKE_TOUCH
expr_stmt|;
name|strokep
operator|->
name|matched
operator|=
name|true
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|strokep
operator|->
name|ctime
argument_list|)
expr_stmt|;
name|strokep
operator|->
name|age
operator|=
literal|1
expr_stmt|;
comment|/* number of interrupts */
name|strokep
operator|->
name|x
operator|=
name|fingerp
operator|->
name|x
expr_stmt|;
name|strokep
operator|->
name|y
operator|=
name|fingerp
operator|->
name|y
expr_stmt|;
comment|/* Reset double-tap-n-drag if we have more than one strokes. */
if|if
condition|(
name|sc
operator|->
name|sc_n_strokes
operator|>
literal|1
condition|)
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|ATP_DOUBLE_TAP_DRAG
expr_stmt|;
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"[%d,%d]\n"
argument_list|,
name|strokep
operator|->
name|x
argument_list|,
name|strokep
operator|->
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_advance_stroke_state
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|atp_stroke_t
modifier|*
name|strokep
parameter_list|,
name|boolean_t
modifier|*
name|movementp
parameter_list|)
block|{
comment|/* Revitalize stroke if it had previously been marked as a zombie. */
if|if
condition|(
name|strokep
operator|->
name|flags
operator|&
name|ATSF_ZOMBIE
condition|)
name|strokep
operator|->
name|flags
operator|&=
operator|~
name|ATSF_ZOMBIE
expr_stmt|;
name|strokep
operator|->
name|age
operator|++
expr_stmt|;
if|if
condition|(
name|strokep
operator|->
name|age
operator|<=
name|atp_stroke_maturity_threshold
condition|)
block|{
comment|/* Avoid noise from immature strokes. */
name|strokep
operator|->
name|instantaneous_dx
operator|=
literal|0
expr_stmt|;
name|strokep
operator|->
name|instantaneous_dy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|atp_compute_stroke_movement
argument_list|(
name|strokep
argument_list|)
condition|)
operator|*
name|movementp
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|strokep
operator|->
name|type
operator|!=
name|ATP_STROKE_TOUCH
condition|)
return|return;
comment|/* Convert touch strokes to slides upon detecting movement or age. */
if|if
condition|(
operator|(
name|abs
argument_list|(
name|strokep
operator|->
name|cum_movement_x
argument_list|)
operator|>
name|atp_slide_min_movement
operator|)
operator|||
operator|(
name|abs
argument_list|(
name|strokep
operator|->
name|cum_movement_y
argument_list|)
operator|>
name|atp_slide_min_movement
operator|)
condition|)
name|atp_convert_to_slide
argument_list|(
name|sc
argument_list|,
name|strokep
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Compute the stroke's age. */
name|struct
name|timeval
name|tdiff
decl_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|tdiff
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|tdiff
argument_list|,
operator|&
name|strokep
operator|->
name|ctime
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|timevalsub
argument_list|(
operator|&
name|tdiff
argument_list|,
operator|&
name|strokep
operator|->
name|ctime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tdiff
operator|.
name|tv_sec
operator|>
operator|(
name|atp_touch_timeout
operator|/
literal|1000000
operator|)
operator|)
operator|||
operator|(
operator|(
name|tdiff
operator|.
name|tv_sec
operator|==
operator|(
name|atp_touch_timeout
operator|/
literal|1000000
operator|)
operator|)
operator|&&
operator|(
name|tdiff
operator|.
name|tv_usec
operator|>=
operator|(
name|atp_touch_timeout
operator|%
literal|1000000
operator|)
operator|)
operator|)
condition|)
name|atp_convert_to_slide
argument_list|(
name|sc
argument_list|,
name|strokep
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|atp_stroke_has_small_movement
parameter_list|(
specifier|const
name|atp_stroke_t
modifier|*
name|strokep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|u_int
operator|)
name|abs
argument_list|(
name|strokep
operator|->
name|instantaneous_dx
argument_list|)
operator|<=
name|atp_small_movement_threshold
operator|)
operator|&&
operator|(
operator|(
name|u_int
operator|)
name|abs
argument_list|(
name|strokep
operator|->
name|instantaneous_dy
argument_list|)
operator|<=
name|atp_small_movement_threshold
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Accumulate instantaneous changes into the stroke's 'pending' bucket; if  * the aggregate exceeds the small_movement_threshold, then retain  * instantaneous changes for later.  */
end_comment

begin_function
specifier|static
name|void
name|atp_update_pending_mickeys
parameter_list|(
name|atp_stroke_t
modifier|*
name|strokep
parameter_list|)
block|{
comment|/* accumulate instantaneous movement */
name|strokep
operator|->
name|pending_dx
operator|+=
name|strokep
operator|->
name|instantaneous_dx
expr_stmt|;
name|strokep
operator|->
name|pending_dy
operator|+=
name|strokep
operator|->
name|instantaneous_dy
expr_stmt|;
define|#
directive|define
name|UPDATE_INSTANTANEOUS_AND_PENDING
parameter_list|(
name|I
parameter_list|,
name|P
parameter_list|)
define|\
value|if (abs((P))<= atp_small_movement_threshold)                   \ 		(I) = 0;
comment|/* clobber small movement */
value|\ 	else {                                                          \ 		if ((I)> 0) {                                          \
comment|/*                                              \ 			 * Round up instantaneous movement to the nearest \ 			 * ceiling. This helps preserve small mickey    \ 			 * movements from being lost in following scaling \ 			 * operation.                                   \ 			 */
value|\ 			(I) = (((I) + (atp_mickeys_scale_factor - 1)) / \ 			       atp_mickeys_scale_factor) *              \ 			      atp_mickeys_scale_factor;                 \ 									\
comment|/*                                              \ 			 * Deduct the rounded mickeys from pending mickeys. \ 			 * Note: we multiply by 2 to offset the previous \ 			 * accumulation of instantaneous movement into  \ 			 * pending.                                     \ 			 */
value|\ 			(P) -= ((I)<< 1);                              \ 									\
comment|/* truncate pending to 0 if it becomes negative. */
value|\ 			(P) = imax((P), 0);                             \ 		} else {                                                \
comment|/*                                              \ 			 * Round down instantaneous movement to the nearest \ 			 * ceiling. This helps preserve small mickey    \ 			 * movements from being lost in following scaling \ 			 * operation.                                   \ 			 */
value|\ 			(I) = (((I) - (atp_mickeys_scale_factor - 1)) / \ 			       atp_mickeys_scale_factor) *              \ 			      atp_mickeys_scale_factor;                 \ 									\
comment|/*                                              \ 			 * Deduct the rounded mickeys from pending mickeys. \ 			 * Note: we multiply by 2 to offset the previous \ 			 * accumulation of instantaneous movement into  \ 			 * pending.                                     \ 			 */
value|\ 			(P) -= ((I)<< 1);                              \ 									\
comment|/* truncate pending to 0 if it becomes positive. */
value|\ 			(P) = imin((P), 0);                             \ 		}                                                       \ 	}
name|UPDATE_INSTANTANEOUS_AND_PENDING
argument_list|(
name|strokep
operator|->
name|instantaneous_dx
argument_list|,
name|strokep
operator|->
name|pending_dx
argument_list|)
expr_stmt|;
name|UPDATE_INSTANTANEOUS_AND_PENDING
argument_list|(
name|strokep
operator|->
name|instantaneous_dy
argument_list|,
name|strokep
operator|->
name|pending_dy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute a smoothened value for the stroke's movement from  * instantaneous changes in the X and Y components.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|atp_compute_stroke_movement
parameter_list|(
name|atp_stroke_t
modifier|*
name|strokep
parameter_list|)
block|{
comment|/* 	 * Short movements are added first to the 'pending' bucket, 	 * and then acted upon only when their aggregate exceeds a 	 * threshold. This has the effect of filtering away movement 	 * noise. 	 */
if|if
condition|(
name|atp_stroke_has_small_movement
argument_list|(
name|strokep
argument_list|)
condition|)
name|atp_update_pending_mickeys
argument_list|(
name|strokep
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* large movement */
comment|/* clear away any pending mickeys if there are large movements*/
name|strokep
operator|->
name|pending_dx
operator|=
literal|0
expr_stmt|;
name|strokep
operator|->
name|pending_dy
operator|=
literal|0
expr_stmt|;
block|}
comment|/* scale movement */
name|strokep
operator|->
name|movement_dx
operator|=
operator|(
name|strokep
operator|->
name|instantaneous_dx
operator|)
operator|/
operator|(
name|int
operator|)
name|atp_mickeys_scale_factor
expr_stmt|;
name|strokep
operator|->
name|movement_dy
operator|=
operator|(
name|strokep
operator|->
name|instantaneous_dy
operator|)
operator|/
operator|(
name|int
operator|)
name|atp_mickeys_scale_factor
expr_stmt|;
if|if
condition|(
operator|(
name|abs
argument_list|(
name|strokep
operator|->
name|instantaneous_dx
argument_list|)
operator|>=
name|ATP_FAST_MOVEMENT_TRESHOLD
operator|)
operator|||
operator|(
name|abs
argument_list|(
name|strokep
operator|->
name|instantaneous_dy
argument_list|)
operator|>=
name|ATP_FAST_MOVEMENT_TRESHOLD
operator|)
condition|)
block|{
name|strokep
operator|->
name|movement_dx
operator|<<=
literal|1
expr_stmt|;
name|strokep
operator|->
name|movement_dy
operator|<<=
literal|1
expr_stmt|;
block|}
name|strokep
operator|->
name|cum_movement_x
operator|+=
name|strokep
operator|->
name|movement_dx
expr_stmt|;
name|strokep
operator|->
name|cum_movement_y
operator|+=
name|strokep
operator|->
name|movement_dy
expr_stmt|;
return|return
operator|(
operator|(
name|strokep
operator|->
name|movement_dx
operator|!=
literal|0
operator|)
operator|||
operator|(
name|strokep
operator|->
name|movement_dy
operator|!=
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Terminate a stroke. Aside from immature strokes, a slide or touch is  * retained as a zombies so as to reap all their termination siblings  * together; this helps establish the number of fingers involved at the  * end of a multi-touch gesture.  */
end_comment

begin_function
specifier|static
name|void
name|atp_terminate_stroke
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|atp_stroke_t
modifier|*
name|strokep
parameter_list|)
block|{
if|if
condition|(
name|strokep
operator|->
name|flags
operator|&
name|ATSF_ZOMBIE
condition|)
return|return;
comment|/* Drop immature strokes rightaway. */
if|if
condition|(
name|strokep
operator|->
name|age
operator|<=
name|atp_stroke_maturity_threshold
condition|)
block|{
name|atp_free_stroke
argument_list|(
name|sc
argument_list|,
name|strokep
argument_list|)
expr_stmt|;
return|return;
block|}
name|strokep
operator|->
name|flags
operator||=
name|ATSF_ZOMBIE
expr_stmt|;
name|sc
operator|->
name|sc_state
operator||=
name|ATP_ZOMBIES_EXIST
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
name|ATP_ZOMBIE_STROKE_REAP_INTERVAL
argument_list|,
name|atp_reap_sibling_zombies
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the double-click-n-drag at the termination of any 	 * slide stroke. 	 */
if|if
condition|(
name|strokep
operator|->
name|type
operator|==
name|ATP_STROKE_SLIDE
condition|)
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|ATP_DOUBLE_TAP_DRAG
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|atp_is_horizontal_scroll
parameter_list|(
specifier|const
name|atp_stroke_t
modifier|*
name|strokep
parameter_list|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|strokep
operator|->
name|cum_movement_x
argument_list|)
operator|<
name|atp_slide_min_movement
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|strokep
operator|->
name|cum_movement_y
operator|==
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
name|abs
argument_list|(
name|strokep
operator|->
name|cum_movement_x
operator|/
name|strokep
operator|->
name|cum_movement_y
argument_list|)
operator|>=
literal|4
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|atp_is_vertical_scroll
parameter_list|(
specifier|const
name|atp_stroke_t
modifier|*
name|strokep
parameter_list|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|strokep
operator|->
name|cum_movement_y
argument_list|)
operator|<
name|atp_slide_min_movement
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|strokep
operator|->
name|cum_movement_x
operator|==
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
name|abs
argument_list|(
name|strokep
operator|->
name|cum_movement_y
operator|/
name|strokep
operator|->
name|cum_movement_x
argument_list|)
operator|>=
literal|4
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_reap_sibling_zombies
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|atp_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|u_int8_t
name|n_touches_reaped
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|n_slides_reaped
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|n_horizontal_scrolls
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|n_vertical_scrolls
init|=
literal|0
decl_stmt|;
name|int
name|horizontal_scroll
init|=
literal|0
decl_stmt|;
name|int
name|vertical_scroll
init|=
literal|0
decl_stmt|;
name|atp_stroke_t
modifier|*
name|strokep
decl_stmt|;
name|atp_stroke_t
modifier|*
name|strokep_next
decl_stmt|;
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|strokep
argument_list|,
argument|&sc->sc_stroke_used
argument_list|,
argument|entry
argument_list|,
argument|strokep_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|strokep
operator|->
name|flags
operator|&
name|ATSF_ZOMBIE
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strokep
operator|->
name|type
operator|==
name|ATP_STROKE_TOUCH
condition|)
block|{
name|n_touches_reaped
operator|++
expr_stmt|;
block|}
else|else
block|{
name|n_slides_reaped
operator|++
expr_stmt|;
if|if
condition|(
name|atp_is_horizontal_scroll
argument_list|(
name|strokep
argument_list|)
condition|)
block|{
name|n_horizontal_scrolls
operator|++
expr_stmt|;
name|horizontal_scroll
operator|+=
name|strokep
operator|->
name|cum_movement_x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atp_is_vertical_scroll
argument_list|(
name|strokep
argument_list|)
condition|)
block|{
name|n_vertical_scrolls
operator|++
expr_stmt|;
name|vertical_scroll
operator|+=
name|strokep
operator|->
name|cum_movement_y
expr_stmt|;
block|}
block|}
name|atp_free_stroke
argument_list|(
name|sc
argument_list|,
name|strokep
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"reaped %u zombies\n"
argument_list|,
name|n_touches_reaped
operator|+
name|n_slides_reaped
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|ATP_ZOMBIES_EXIST
expr_stmt|;
comment|/* No further processing necessary if physical button is depressed. */
if|if
condition|(
name|sc
operator|->
name|sc_ibtn
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|n_touches_reaped
operator|==
literal|0
operator|)
operator|&&
operator|(
name|n_slides_reaped
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* Add a pair of virtual button events (button-down and button-up) if 	 * the physical button isn't pressed. */
if|if
condition|(
name|n_touches_reaped
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|n_touches_reaped
operator|<
name|atp_tap_minimum
condition|)
return|return;
switch|switch
condition|(
name|n_touches_reaped
condition|)
block|{
case|case
literal|1
case|:
name|atp_add_to_queue
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MOUSE_BUTTON1DOWN
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|sc
operator|->
name|sc_touch_reap_time
argument_list|)
expr_stmt|;
comment|/* remember this time */
break|break;
case|case
literal|2
case|:
name|atp_add_to_queue
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MOUSE_BUTTON3DOWN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|atp_add_to_queue
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MOUSE_BUTTON2DOWN
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* we handle taps of only up to 3 fingers */
return|return;
block|}
name|atp_add_to_queue
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* button release */
block|}
elseif|else
if|if
condition|(
operator|(
name|n_slides_reaped
operator|==
literal|2
operator|)
operator|&&
operator|(
name|n_horizontal_scrolls
operator|==
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|horizontal_scroll
operator|<
literal|0
condition|)
name|atp_add_to_queue
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MOUSE_BUTTON4DOWN
argument_list|)
expr_stmt|;
else|else
name|atp_add_to_queue
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MOUSE_BUTTON5DOWN
argument_list|)
expr_stmt|;
name|atp_add_to_queue
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* button release */
block|}
block|}
end_function

begin_comment
comment|/* Switch a given touch stroke to being a slide. */
end_comment

begin_function
specifier|static
name|void
name|atp_convert_to_slide
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|atp_stroke_t
modifier|*
name|strokep
parameter_list|)
block|{
name|strokep
operator|->
name|type
operator|=
name|ATP_STROKE_SLIDE
expr_stmt|;
comment|/* Are we at the beginning of a double-click-n-drag? */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_n_strokes
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|sc
operator|->
name|sc_state
operator|&
name|ATP_ZOMBIES_EXIST
operator|)
operator|==
literal|0
operator|)
operator|&&
name|timevalcmp
argument_list|(
operator|&
name|strokep
operator|->
name|ctime
argument_list|,
operator|&
name|sc
operator|->
name|sc_touch_reap_time
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|struct
name|timeval
name|delta
decl_stmt|;
name|struct
name|timeval
name|window
init|=
block|{
name|atp_double_tap_threshold
operator|/
literal|1000000
block|,
name|atp_double_tap_threshold
operator|%
literal|1000000
block|}
decl_stmt|;
name|delta
operator|=
name|strokep
operator|->
name|ctime
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|sc
operator|->
name|sc_touch_reap_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|window
argument_list|,
operator|<=
argument_list|)
condition|)
name|sc
operator|->
name|sc_state
operator||=
name|ATP_DOUBLE_TAP_DRAG
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|atp_reset_buf
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* reset read queue */
name|usb_fifo_reset
argument_list|(
name|sc
operator|->
name|sc_fifo
operator|.
name|fp
index|[
name|USB_FIFO_RX
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_add_to_queue
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
name|int
name|dz
parameter_list|,
name|uint32_t
name|buttons_in
parameter_list|)
block|{
name|uint32_t
name|buttons_out
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|dx
operator|=
name|imin
argument_list|(
name|dx
argument_list|,
literal|254
argument_list|)
expr_stmt|;
name|dx
operator|=
name|imax
argument_list|(
name|dx
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|dy
operator|=
name|imin
argument_list|(
name|dy
argument_list|,
literal|254
argument_list|)
expr_stmt|;
name|dy
operator|=
name|imax
argument_list|(
name|dy
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|dz
operator|=
name|imin
argument_list|(
name|dz
argument_list|,
literal|126
argument_list|)
expr_stmt|;
name|dz
operator|=
name|imax
argument_list|(
name|dz
argument_list|,
operator|-
literal|128
argument_list|)
expr_stmt|;
name|buttons_out
operator|=
name|MOUSE_MSC_BUTTONS
expr_stmt|;
if|if
condition|(
name|buttons_in
operator|&
name|MOUSE_BUTTON1DOWN
condition|)
name|buttons_out
operator|&=
operator|~
name|MOUSE_MSC_BUTTON1UP
expr_stmt|;
elseif|else
if|if
condition|(
name|buttons_in
operator|&
name|MOUSE_BUTTON2DOWN
condition|)
name|buttons_out
operator|&=
operator|~
name|MOUSE_MSC_BUTTON2UP
expr_stmt|;
elseif|else
if|if
condition|(
name|buttons_in
operator|&
name|MOUSE_BUTTON3DOWN
condition|)
name|buttons_out
operator|&=
operator|~
name|MOUSE_MSC_BUTTON3UP
expr_stmt|;
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"dx=%d, dy=%d, buttons=%x\n"
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|buttons_out
argument_list|)
expr_stmt|;
comment|/* Encode the mouse data in standard format; refer to mouse(4) */
name|buf
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|1
index|]
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
name|buttons_out
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|dx
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|dy
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|dx
operator|-
operator|(
name|dx
operator|>>
literal|1
operator|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|dy
operator|-
operator|(
name|dy
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* Encode extra bytes for level 1 */
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|==
literal|1
condition|)
block|{
name|buf
index|[
literal|5
index|]
operator|=
name|dz
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
name|dz
operator|-
operator|(
name|dz
operator|>>
literal|1
operator|)
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
operator|~
name|buttons_in
operator|)
operator|>>
literal|3
operator|)
operator|&
name|MOUSE_SYS_EXTBUTTONS
operator|)
expr_stmt|;
block|}
name|usb_fifo_put_data_linear
argument_list|(
name|sc
operator|->
name|sc_fifo
operator|.
name|fp
index|[
name|USB_FIFO_RX
index|]
argument_list|,
name|buf
argument_list|,
name|sc
operator|->
name|sc_mode
operator|.
name|packetsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|atp_probe
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|self
argument_list|)
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bInterfaceClass
operator|!=
name|UICLASS_HID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Note: for some reason, the check 	 * (uaa->info.bInterfaceProtocol == UIPROTO_MOUSE) doesn't hold true 	 * for wellspring trackpads, so we've removed it from the common path. 	 */
if|if
condition|(
operator|(
name|usbd_lookup_id_by_uaa
argument_list|(
name|fg_devs
argument_list|,
sizeof|sizeof
argument_list|(
name|fg_devs
argument_list|)
argument_list|,
name|uaa
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|uaa
operator|->
name|info
operator|.
name|bInterfaceProtocol
operator|==
name|UIPROTO_MOUSE
operator|)
condition|?
literal|0
else|:
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|usbd_lookup_id_by_uaa
argument_list|(
name|wsp_devs
argument_list|,
sizeof|sizeof
argument_list|(
name|wsp_devs
argument_list|)
argument_list|,
name|uaa
argument_list|)
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
operator|==
name|WELLSPRING_INTERFACE_INDEX
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|void
modifier|*
name|descriptor_ptr
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|descriptor_len
decl_stmt|;
name|unsigned
name|long
name|di
decl_stmt|;
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"sc=%p\n"
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_usb_device
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
comment|/* Get HID descriptor */
if|if
condition|(
name|usbd_req_get_hid_desc
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|NULL
argument_list|,
operator|&
name|descriptor_ptr
argument_list|,
operator|&
name|descriptor_len
argument_list|,
name|M_TEMP
argument_list|,
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|)
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Get HID report descriptor length */
name|sc
operator|->
name|sc_expected_sensor_data_len
operator|=
name|hid_report_size
argument_list|(
name|descriptor_ptr
argument_list|,
name|descriptor_len
argument_list|,
name|hid_input
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|descriptor_ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_expected_sensor_data_len
operator|<=
literal|0
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_expected_sensor_data_len
operator|>
name|ATP_SENSOR_DATA_BUF_MAX
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"atp_attach: datalength invalid or too large: %d\n"
argument_list|,
name|sc
operator|->
name|sc_expected_sensor_data_len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * By default the touchpad behaves like an HID device, sending 	 * packets with reportID = 2. Such reports contain only 	 * limited information--they encode movement deltas and button 	 * events,--but do not include data from the pressure 	 * sensors. The device input mode can be switched from HID 	 * reports to raw sensor data using vendor-specific USB 	 * control commands. 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|atp_set_device_mode
argument_list|(
name|sc
argument_list|,
name|RAW_SENSOR_MODE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"failed to set mode to 'RAW_SENSOR' (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|,
literal|"atpmtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
name|di
operator|=
name|USB_GET_DRIVER_INFO
argument_list|(
name|uaa
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_family
operator|=
name|DECODE_FAMILY_FROM_DRIVER_INFO
argument_list|(
name|di
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_family
condition|)
block|{
case|case
name|TRACKPAD_FAMILY_FOUNTAIN_GEYSER
case|:
name|sc
operator|->
name|sc_params
operator|=
operator|&
name|fg_dev_params
index|[
name|DECODE_PRODUCT_FROM_DRIVER_INFO
argument_list|(
name|di
argument_list|)
index|]
expr_stmt|;
name|sc
operator|->
name|sensor_data_interpreter
operator|=
name|fg_interpret_sensor_data
expr_stmt|;
break|break;
case|case
name|TRACKPAD_FAMILY_WELLSPRING
case|:
name|sc
operator|->
name|sc_params
operator|=
operator|&
name|wsp_dev_params
index|[
name|DECODE_PRODUCT_FROM_DRIVER_INFO
argument_list|(
name|di
argument_list|)
index|]
expr_stmt|;
name|sc
operator|->
name|sensor_data_interpreter
operator|=
name|wsp_interpret_sensor_data
expr_stmt|;
break|break;
default|default:
goto|goto
name|detach
goto|;
block|}
name|err
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|,
name|sc
operator|->
name|sc_xfer
argument_list|,
name|atp_xfer_config
argument_list|,
name|ATP_N_TRANSFER
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
if|if
condition|(
name|usb_fifo_attach
argument_list|(
name|sc
operator|->
name|sc_usb_device
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|,
operator|&
name|atp_fifo_methods
argument_list|,
operator|&
name|sc
operator|->
name|sc_fifo
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0644
argument_list|)
condition|)
block|{
goto|goto
name|detach
goto|;
block|}
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|buttons
operator|=
literal|3
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|iftype
operator|=
name|MOUSE_IF_USB
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|type
operator|=
name|MOUSE_PAD
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|model
operator|=
name|MOUSE_MODEL_GENERIC
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|hwid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|accelfactor
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ibtn
operator|=
literal|0
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|detach
label|:
name|atp_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atp_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atp_set_device_mode
argument_list|(
name|sc
argument_list|,
name|HID_MODE
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|&
name|ATP_ENABLED
condition|)
name|atp_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
name|usb_fifo_detach
argument_list|(
operator|&
name|sc
operator|->
name|sc_fifo
argument_list|)
expr_stmt|;
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|ATP_N_TRANSFER
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_intr
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|int
name|len
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_sensor_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|sc
operator|->
name|sc_expected_sensor_data_len
condition|)
block|{
comment|/* make sure we don't process old data */
name|memset
argument_list|(
name|sc
operator|->
name|sc_sensor_data
operator|+
name|len
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_expected_sensor_data_len
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_status
operator|.
name|flags
operator|&=
operator|~
operator|(
name|MOUSE_STDBUTTONSCHANGED
operator||
name|MOUSE_POSCHANGED
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|obutton
operator|=
name|sc
operator|->
name|sc_status
operator|.
name|button
expr_stmt|;
call|(
name|sc
operator|->
name|sensor_data_interpreter
call|)
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|!=
literal|0
condition|)
block|{
comment|/* Reset DOUBLE_TAP_N_DRAG if the button is pressed. */
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|ATP_DOUBLE_TAP_DRAG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|&
name|ATP_DOUBLE_TAP_DRAG
condition|)
block|{
comment|/* Assume a button-press with DOUBLE_TAP_N_DRAG. */
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|=
name|MOUSE_BUTTON1DOWN
expr_stmt|;
block|}
name|sc
operator|->
name|sc_status
operator|.
name|flags
operator||=
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|^
name|sc
operator|->
name|sc_status
operator|.
name|obutton
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_status
operator|.
name|flags
operator|&
name|MOUSE_STDBUTTONSCHANGED
condition|)
block|{
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"button %s\n"
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|&
name|MOUSE_BUTTON1DOWN
operator|)
condition|?
literal|"pressed"
else|:
literal|"released"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_status
operator|.
name|flags
operator|&
operator|(
name|MOUSE_POSCHANGED
operator||
name|MOUSE_STDBUTTONSCHANGED
operator|)
condition|)
block|{
name|atp_stroke_t
modifier|*
name|strokep
decl_stmt|;
name|u_int8_t
name|n_movements
init|=
literal|0
decl_stmt|;
name|int
name|dx
init|=
literal|0
decl_stmt|;
name|int
name|dy
init|=
literal|0
decl_stmt|;
name|int
name|dz
init|=
literal|0
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|strokep
argument_list|,
argument|&sc->sc_stroke_used
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|strokep
operator|->
name|flags
operator|&
name|ATSF_ZOMBIE
condition|)
continue|continue;
name|dx
operator|+=
name|strokep
operator|->
name|movement_dx
expr_stmt|;
name|dy
operator|+=
name|strokep
operator|->
name|movement_dy
expr_stmt|;
if|if
condition|(
name|strokep
operator|->
name|movement_dx
operator|||
name|strokep
operator|->
name|movement_dy
condition|)
name|n_movements
operator|++
expr_stmt|;
block|}
comment|/* average movement if multiple strokes record motion.*/
if|if
condition|(
name|n_movements
operator|>
literal|1
condition|)
block|{
name|dx
operator|/=
operator|(
name|int
operator|)
name|n_movements
expr_stmt|;
name|dy
operator|/=
operator|(
name|int
operator|)
name|n_movements
expr_stmt|;
block|}
comment|/* detect multi-finger vertical scrolls */
if|if
condition|(
name|n_movements
operator|>=
literal|2
condition|)
block|{
name|boolean_t
name|all_vertical_scrolls
init|=
name|true
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|strokep
argument_list|,
argument|&sc->sc_stroke_used
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|strokep
operator|->
name|flags
operator|&
name|ATSF_ZOMBIE
condition|)
continue|continue;
if|if
condition|(
operator|!
name|atp_is_vertical_scroll
argument_list|(
name|strokep
argument_list|)
condition|)
name|all_vertical_scrolls
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|all_vertical_scrolls
condition|)
block|{
name|dz
operator|=
name|dy
expr_stmt|;
name|dy
operator|=
name|dx
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_status
operator|.
name|dx
operator|+=
name|dx
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|dy
operator|+=
name|dy
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|dz
operator|+=
name|dz
expr_stmt|;
name|atp_add_to_queue
argument_list|(
name|sc
argument_list|,
name|dx
argument_list|,
operator|-
name|dy
argument_list|,
operator|-
name|dz
argument_list|,
name|sc
operator|->
name|sc_status
operator|.
name|button
argument_list|)
expr_stmt|;
block|}
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
comment|/* check if we can put more data into the FIFO */
if|if
condition|(
name|usb_fifo_put_bytes_max
argument_list|(
name|sc
operator|->
name|sc_fifo
operator|.
name|fp
index|[
name|USB_FIFO_RX
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_expected_sensor_data_len
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Error */
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* try clear stall first */
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|atp_start_read
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|int
name|rate
decl_stmt|;
comment|/* Check if we should override the default polling interval */
name|rate
operator|=
name|sc
operator|->
name|sc_pollrate
expr_stmt|;
comment|/* Range check rate */
if|if
condition|(
name|rate
operator|>
literal|1000
condition|)
name|rate
operator|=
literal|1000
expr_stmt|;
comment|/* Check for set rate */
if|if
condition|(
operator|(
name|rate
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_xfer
index|[
name|ATP_INTR_DT
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* Stop current transfer, if any */
name|usbd_transfer_stop
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|ATP_INTR_DT
index|]
argument_list|)
expr_stmt|;
comment|/* Set new interval */
name|usbd_xfer_set_interval
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|ATP_INTR_DT
index|]
argument_list|,
literal|1000
operator|/
name|rate
argument_list|)
expr_stmt|;
comment|/* Only set pollrate once */
name|sc
operator|->
name|sc_pollrate
operator|=
literal|0
expr_stmt|;
block|}
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|ATP_INTR_DT
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_stop_read
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|usbd_transfer_stop
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|ATP_INTR_DT
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|atp_open
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
comment|/* check for duplicate open, should not happen */
if|if
condition|(
name|sc
operator|->
name|sc_fflags
operator|&
name|fflags
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* check for first open */
if|if
condition|(
name|sc
operator|->
name|sc_fflags
operator|==
literal|0
condition|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|atp_enable
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
if|if
condition|(
name|usb_fifo_alloc_buffer
argument_list|(
name|fifo
argument_list|,
name|ATP_FIFO_BUF_SIZE
argument_list|,
name|ATP_FIFO_QUEUE_MAXLEN
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|sc_fflags
operator||=
operator|(
name|fflags
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_close
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
name|usb_fifo_free_buffer
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fflags
operator|&=
operator|~
operator|(
name|fflags
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_fflags
operator|==
literal|0
condition|)
block|{
name|atp_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|atp_ioctl
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|mousemode_t
name|mode
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOUSE_GETHWINFO
case|:
operator|*
operator|(
name|mousehw_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|sc_hw
expr_stmt|;
break|break;
case|case
name|MOUSE_GETMODE
case|:
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|sc_mode
expr_stmt|;
break|break;
case|case
name|MOUSE_SETMODE
case|:
name|mode
operator|=
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|level
operator|==
operator|-
literal|1
condition|)
comment|/* Don't change the current setting */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mode
operator|.
name|level
operator|<
literal|0
operator|)
operator|||
operator|(
name|mode
operator|.
name|level
operator|>
literal|1
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|=
name|mode
operator|.
name|level
expr_stmt|;
name|sc
operator|->
name|sc_pollrate
operator|=
name|mode
operator|.
name|rate
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|buttons
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|packetsize
operator|=
name|MOUSE_SYS_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_SYS_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_SYS_SYNC
expr_stmt|;
block|}
name|atp_reset_buf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETLEVEL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|sc_mode
operator|.
name|level
expr_stmt|;
break|break;
case|case
name|MOUSE_SETLEVEL
case|:
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|<
literal|0
operator|)
operator|||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|>
literal|1
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|buttons
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|packetsize
operator|=
name|MOUSE_SYS_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_SYS_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_SYS_SYNC
expr_stmt|;
block|}
name|atp_reset_buf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETSTATUS
case|:
block|{
name|mousestatus_t
modifier|*
name|status
init|=
operator|(
name|mousestatus_t
operator|*
operator|)
name|addr
decl_stmt|;
operator|*
name|status
operator|=
name|sc
operator|->
name|sc_status
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|obutton
operator|=
name|sc
operator|->
name|sc_status
operator|.
name|button
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|dx
operator|||
name|status
operator|->
name|dy
operator|||
name|status
operator|->
name|dz
condition|)
name|status
operator|->
name|flags
operator||=
name|MOUSE_POSCHANGED
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|button
operator|!=
name|status
operator|->
name|obutton
condition|)
name|status
operator|->
name|flags
operator||=
name|MOUSE_BUTTONSCHANGED
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atp_sysctl_scale_factor_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|atp_mickeys_scale_factor
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|tmp
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|tmp
operator|==
name|atp_mickeys_scale_factor
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no change */
if|if
condition|(
operator|(
name|tmp
operator|==
literal|0
operator|)
operator|||
operator|(
name|tmp
operator|>
operator|(
literal|10
operator|*
name|ATP_SCALE_FACTOR
operator|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|atp_mickeys_scale_factor
operator|=
name|tmp
expr_stmt|;
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"%s: resetting mickeys_scale_factor to %u\n"
argument_list|,
name|ATP_DRIVER_NAME
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|devclass_t
name|atp_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|atp_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|atp_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|atp_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|atp_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|atp_driver
init|=
block|{
operator|.
name|name
operator|=
name|ATP_DRIVER_NAME
block|,
operator|.
name|methods
operator|=
name|atp_methods
block|,
operator|.
name|size
operator|=
expr|sizeof
operator|(
expr|struct
name|atp_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|atp
argument_list|,
name|uhub
argument_list|,
name|atp_driver
argument_list|,
name|atp_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|atp
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|atp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

