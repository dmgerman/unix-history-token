begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Rohit Grover  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbhid.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|atp_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<sys/mouse.h>
end_include

begin_define
define|#
directive|define
name|ATP_DRIVER_NAME
value|"atp"
end_define

begin_comment
comment|/*  * Driver specific options: the following options may be set by  * `options' statements in the kernel configuration file.  */
end_comment

begin_comment
comment|/* The multiplier used to translate sensor reported positions to mickeys. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATP_SCALE_FACTOR
end_ifndef

begin_define
define|#
directive|define
name|ATP_SCALE_FACTOR
value|48
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This is the age (in microseconds) beyond which a touch is  * considered to be a slide; and therefore a tap event isn't registered.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATP_TOUCH_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|ATP_TOUCH_TIMEOUT
value|125000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * A double-tap followed by a single-finger slide is treated as a  * special gesture. The driver responds to this gesture by assuming a  * virtual button-press for the lifetime of the slide. The following  * threshold is the maximum time gap (in microseconds) between the two  * tap events preceding the slide for such a gesture.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATP_DOUBLE_TAP_N_DRAG_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|ATP_DOUBLE_TAP_N_DRAG_THRESHOLD
value|200000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The device provides us only with pressure readings from an array of  * X and Y sensors; for our algorithms, we need to interpret groups  * (typically pairs) of X and Y readings as being related to a single  * finger stroke. We can relate X and Y readings based on their times  * of incidence. The coincidence window should be at least 10000us  * since it is used against values from getmicrotime(), which has a  * precision of around 10ms.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATP_COINCIDENCE_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|ATP_COINCIDENCE_THRESHOLD
value|40000
end_define

begin_comment
comment|/* unit: microseconds */
end_comment

begin_if
if|#
directive|if
name|ATP_COINCIDENCE_THRESHOLD
operator|>
literal|100000
end_if

begin_error
error|#
directive|error
literal|"ATP_COINCIDENCE_THRESHOLD too large"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifndef ATP_COINCIDENCE_THRESHOLD */
end_comment

begin_comment
comment|/*  * The wait duration (in microseconds) after losing a touch contact  * before zombied strokes are reaped and turned into button events.  */
end_comment

begin_define
define|#
directive|define
name|ATP_ZOMBIE_STROKE_REAP_WINDOW
value|50000
end_define

begin_if
if|#
directive|if
name|ATP_ZOMBIE_STROKE_REAP_WINDOW
operator|>
literal|100000
end_if

begin_error
error|#
directive|error
literal|"ATP_ZOMBIE_STROKE_REAP_WINDOW too large"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* end of driver specific options */
end_comment

begin_comment
comment|/* Tunables */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|atp
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB atp"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_enum
enum|enum
name|atp_log_level
block|{
name|ATP_LLEVEL_DISABLED
init|=
literal|0
block|,
name|ATP_LLEVEL_ERROR
block|,
name|ATP_LLEVEL_DEBUG
block|,
comment|/* for troubleshooting */
name|ATP_LLEVEL_INFO
block|,
comment|/* for diagnostics */
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|atp_debug
init|=
name|ATP_LLEVEL_ERROR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the default is to only log errors */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_debug
argument_list|,
name|ATP_LLEVEL_ERROR
argument_list|,
literal|"ATP debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #if USB_DEBUG */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|atp_touch_timeout
init|=
name|ATP_TOUCH_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|touch_timeout
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_touch_timeout
argument_list|,
literal|125000
argument_list|,
literal|"age threshold (in micros) for a touch"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|atp_double_tap_threshold
init|=
name|ATP_DOUBLE_TAP_N_DRAG_THRESHOLD
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|double_tap_threshold
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_double_tap_threshold
argument_list|,
name|ATP_DOUBLE_TAP_N_DRAG_THRESHOLD
argument_list|,
literal|"maximum time (in micros) between a double-tap"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|atp_mickeys_scale_factor
init|=
name|ATP_SCALE_FACTOR
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|atp_sysctl_scale_factor_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|scale_factor
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_mickeys_scale_factor
argument_list|,
sizeof|sizeof
argument_list|(
name|atp_mickeys_scale_factor
argument_list|)
argument_list|,
name|atp_sysctl_scale_factor_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"movement scale factor"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|atp_small_movement_threshold
init|=
name|ATP_SCALE_FACTOR
operator|>>
literal|3
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|small_movement
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_small_movement_threshold
argument_list|,
name|ATP_SCALE_FACTOR
operator|>>
literal|3
argument_list|,
literal|"the small movement black-hole for filtering noise"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The movement threshold for a stroke; this is the maximum difference  * in position which will be resolved as a continuation of a stroke  * component.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|atp_max_delta_mickeys
init|=
operator|(
operator|(
literal|3
operator|*
name|ATP_SCALE_FACTOR
operator|)
operator|>>
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|max_delta_mickeys
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_max_delta_mickeys
argument_list|,
operator|(
operator|(
literal|3
operator|*
name|ATP_SCALE_FACTOR
operator|)
operator|>>
literal|1
operator|)
argument_list|,
literal|"max. mickeys-delta which will match against an existing stroke"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Strokes which accumulate at least this amount of absolute movement  * from the aggregate of their components are considered as  * slides. Unit: mickeys.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|atp_slide_min_movement
init|=
operator|(
name|ATP_SCALE_FACTOR
operator|>>
literal|3
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|slide_min_movement
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_slide_min_movement
argument_list|,
operator|(
name|ATP_SCALE_FACTOR
operator|>>
literal|3
operator|)
argument_list|,
literal|"strokes with at least this amt. of movement are considered slides"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The minimum age of a stroke for it to be considered mature; this  * helps filter movements (noise) from immature strokes. Units: interrupts.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|atp_stroke_maturity_threshold
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|stroke_maturity_threshold
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_stroke_maturity_threshold
argument_list|,
literal|2
argument_list|,
literal|"the minimum age of a stroke for it to be considered mature"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Accept pressure readings from sensors only if above this value. */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|atp_sensor_noise_threshold
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|sensor_noise_threshold
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_sensor_noise_threshold
argument_list|,
literal|2
argument_list|,
literal|"accept pressure readings from sensors only if above this value"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Ignore pressure spans with cumulative press. below this value. */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|atp_pspan_min_cum_pressure
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|pspan_min_cum_pressure
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_pspan_min_cum_pressure
argument_list|,
literal|10
argument_list|,
literal|"ignore pressure spans with cumulative press. below this value"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Maximum allowed width for pressure-spans.*/
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|atp_pspan_max_width
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_usb_atp
argument_list|,
name|OID_AUTO
argument_list|,
name|pspan_max_width
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|atp_pspan_max_width
argument_list|,
literal|4
argument_list|,
literal|"maximum allowed width (in sensors) for pressure-spans"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Define the various flavours of devices supported by this driver. */
end_comment

begin_enum
enum|enum
block|{
name|ATP_DEV_PARAMS_0
block|,
name|ATP_N_DEV_PARAMS
block|}
enum|;
end_enum

begin_struct
struct|struct
name|atp_dev_params
block|{
name|u_int
name|data_len
decl_stmt|;
comment|/* for sensor data */
name|u_int
name|n_xsensors
decl_stmt|;
name|u_int
name|n_ysensors
decl_stmt|;
block|}
name|atp_dev_params
index|[
name|ATP_N_DEV_PARAMS
index|]
init|=
block|{
index|[
name|ATP_DEV_PARAMS_0
index|]
operator|=
block|{
operator|.
name|data_len
operator|=
literal|64
block|,
operator|.
name|n_xsensors
operator|=
literal|20
block|,
operator|.
name|n_ysensors
operator|=
literal|10
block|}
block|, }
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_device_id
name|atp_devs
index|[]
init|=
block|{
comment|/* Core Duo MacBook& MacBook Pro */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x0217
argument_list|,
argument|ATP_DEV_PARAMS_0
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x0218
argument_list|,
argument|ATP_DEV_PARAMS_0
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x0219
argument_list|,
argument|ATP_DEV_PARAMS_0
argument_list|)
block|}
block|,
comment|/* Core2 Duo MacBook& MacBook Pro */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x021a
argument_list|,
argument|ATP_DEV_PARAMS_0
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x021b
argument_list|,
argument|ATP_DEV_PARAMS_0
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x021c
argument_list|,
argument|ATP_DEV_PARAMS_0
argument_list|)
block|}
block|,
comment|/* Core2 Duo MacBook3,1 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x0229
argument_list|,
argument|ATP_DEV_PARAMS_0
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x022a
argument_list|,
argument|ATP_DEV_PARAMS_0
argument_list|)
block|}
block|,
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_APPLE
argument_list|,
literal|0x022b
argument_list|,
argument|ATP_DEV_PARAMS_0
argument_list|)
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following structure captures the state of a pressure span along  * an axis. Each contact with the touchpad results in separate  * pressure spans along the two axes.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|atp_pspan
block|{
name|u_int
name|width
decl_stmt|;
comment|/* in units of sensors */
name|u_int
name|cum
decl_stmt|;
comment|/* cumulative compression (from all sensors) */
name|u_int
name|cog
decl_stmt|;
comment|/* center of gravity */
name|u_int
name|loc
decl_stmt|;
comment|/* location (scaled using the mickeys factor) */
name|boolean_t
name|matched
decl_stmt|;
comment|/* to track pspans as they match against strokes. */
block|}
name|atp_pspan
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
name|atp_stroke_type
block|{
name|ATP_STROKE_TOUCH
block|,
name|ATP_STROKE_SLIDE
block|, }
name|atp_stroke_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ATP_MAX_PSPANS_PER_AXIS
value|3
end_define

begin_typedef
typedef|typedef
struct|struct
name|atp_stroke_component
block|{
comment|/* Fields encapsulating the pressure-span. */
name|u_int
name|loc
decl_stmt|;
comment|/* location (scaled) */
name|u_int
name|cum_pressure
decl_stmt|;
comment|/* cumulative compression */
name|u_int
name|max_cum_pressure
decl_stmt|;
comment|/* max cumulative compression */
name|boolean_t
name|matched
decl_stmt|;
comment|/*to track components as they match against pspans.*/
comment|/* Fields containing information about movement. */
name|int
name|delta_mickeys
decl_stmt|;
comment|/* change in location (un-smoothened movement)*/
name|int
name|pending
decl_stmt|;
comment|/* cum. of pending short movements */
name|int
name|movement
decl_stmt|;
comment|/* current smoothened movement */
block|}
name|atp_stroke_component
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
name|atp_axis
block|{
name|X
init|=
literal|0
block|,
name|Y
init|=
literal|1
block|}
name|atp_axis
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ATP_MAX_STROKES
value|(2 * ATP_MAX_PSPANS_PER_AXIS)
end_define

begin_comment
comment|/*  * The following structure captures a finger contact with the  * touchpad. A stroke comprises two p-span components and some state.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|atp_stroke
block|{
name|atp_stroke_type
name|type
decl_stmt|;
name|struct
name|timeval
name|ctime
decl_stmt|;
comment|/* create time; for coincident siblings. */
name|u_int
name|age
decl_stmt|;
comment|/* 				     * Unit: interrupts; we maintain 				     * this value in addition to 				     * 'ctime' in order to avoid the 				     * expensive call to microtime() 				     * at every interrupt. 				     */
name|atp_stroke_component
name|components
index|[
literal|2
index|]
decl_stmt|;
name|u_int
name|velocity_squared
decl_stmt|;
comment|/* 						* Average magnitude (squared) 						* of recent velocity. 						*/
name|u_int
name|cum_movement
decl_stmt|;
comment|/* cum. absolute movement so far */
name|uint32_t
name|flags
decl_stmt|;
comment|/* the state of this stroke */
define|#
directive|define
name|ATSF_ZOMBIE
value|0x1
block|}
name|atp_stroke
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ATP_FIFO_BUF_SIZE
value|8
end_define

begin_comment
comment|/* bytes */
end_comment

begin_define
define|#
directive|define
name|ATP_FIFO_QUEUE_MAXLEN
value|50
end_define

begin_comment
comment|/* units */
end_comment

begin_enum
enum|enum
block|{
name|ATP_INTR_DT
block|,
name|ATP_N_TRANSFER
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|atp_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|sc_usb_device
decl_stmt|;
define|#
directive|define
name|MODE_LENGTH
value|8
name|char
name|sc_mode_bytes
index|[
name|MODE_LENGTH
index|]
decl_stmt|;
comment|/* device mode */
name|struct
name|mtx
name|sc_mutex
decl_stmt|;
comment|/* for synchronization */
name|struct
name|usb_xfer
modifier|*
name|sc_xfer
index|[
name|ATP_N_TRANSFER
index|]
decl_stmt|;
name|struct
name|usb_fifo_sc
name|sc_fifo
decl_stmt|;
name|struct
name|atp_dev_params
modifier|*
name|sc_params
decl_stmt|;
name|mousehw_t
name|sc_hw
decl_stmt|;
name|mousemode_t
name|sc_mode
decl_stmt|;
name|u_int
name|sc_pollrate
decl_stmt|;
name|mousestatus_t
name|sc_status
decl_stmt|;
name|u_int
name|sc_state
decl_stmt|;
define|#
directive|define
name|ATP_ENABLED
value|0x01
define|#
directive|define
name|ATP_ZOMBIES_EXIST
value|0x02
define|#
directive|define
name|ATP_DOUBLE_TAP_DRAG
value|0x04
name|u_int
name|sc_left_margin
decl_stmt|;
name|u_int
name|sc_right_margin
decl_stmt|;
name|atp_stroke
name|sc_strokes
index|[
name|ATP_MAX_STROKES
index|]
decl_stmt|;
name|u_int
name|sc_n_strokes
decl_stmt|;
name|int8_t
modifier|*
name|sensor_data
decl_stmt|;
comment|/* from interrupt packet */
name|int
modifier|*
name|base_x
decl_stmt|;
comment|/* base sensor readings */
name|int
modifier|*
name|base_y
decl_stmt|;
name|int
modifier|*
name|cur_x
decl_stmt|;
comment|/* current sensor readings */
name|int
modifier|*
name|cur_y
decl_stmt|;
name|int
modifier|*
name|pressure_x
decl_stmt|;
comment|/* computed pressures */
name|int
modifier|*
name|pressure_y
decl_stmt|;
name|u_int
name|sc_idlecount
decl_stmt|;
comment|/* preceding idle interrupts */
define|#
directive|define
name|ATP_IDLENESS_THRESHOLD
value|10
name|struct
name|timeval
name|sc_reap_time
decl_stmt|;
name|struct
name|timeval
name|sc_reap_ctime
decl_stmt|;
comment|/*ctime of siblings to be reaped*/
block|}
struct|;
end_struct

begin_comment
comment|/*  * The last byte of the sensor data contains status bits; the  * following values define the meanings of these bits.  */
end_comment

begin_enum
enum|enum
name|atp_status_bits
block|{
name|ATP_STATUS_BUTTON
init|=
operator|(
name|uint8_t
operator|)
literal|0x01
block|,
comment|/* The button was pressed */
name|ATP_STATUS_BASE_UPDATE
init|=
operator|(
name|uint8_t
operator|)
literal|0x04
block|,
comment|/* Data from an untouched pad.*/
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
enum|enum
name|interface_mode
block|{
name|RAW_SENSOR_MODE
init|=
operator|(
name|uint8_t
operator|)
literal|0x04
block|,
name|HID_MODE
init|=
operator|(
name|uint8_t
operator|)
literal|0x08
block|}
name|interface_mode
typedef|;
end_typedef

begin_comment
comment|/*  * function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|usb_fifo_cmd_t
name|atp_start_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_fifo_cmd_t
name|atp_stop_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_fifo_open_t
name|atp_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_fifo_close_t
name|atp_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_fifo_ioctl_t
name|atp_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|usb_fifo_methods
name|atp_fifo_methods
init|=
block|{
operator|.
name|f_open
operator|=
operator|&
name|atp_open
block|,
operator|.
name|f_close
operator|=
operator|&
name|atp_close
block|,
operator|.
name|f_ioctl
operator|=
operator|&
name|atp_ioctl
block|,
operator|.
name|f_start_read
operator|=
operator|&
name|atp_start_read
block|,
operator|.
name|f_stop_read
operator|=
operator|&
name|atp_stop_read
block|,
operator|.
name|basename
index|[
literal|0
index|]
operator|=
name|ATP_DRIVER_NAME
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device initialization and shutdown */
end_comment

begin_function_decl
specifier|static
name|usb_error_t
name|atp_req_get_report
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atp_set_device_mode
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|interface_mode
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atp_enable
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_disable
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atp_softc_populate
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_softc_unpopulate
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* sensor interpretation */
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
name|atp_interpret_sensor_data
parameter_list|(
specifier|const
name|int8_t
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|atp_get_pressures
parameter_list|(
name|int
modifier|*
parameter_list|,
specifier|const
name|int
modifier|*
parameter_list|,
specifier|const
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_detect_pspans
parameter_list|(
name|int
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|atp_pspan
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* movement detection */
end_comment

begin_function_decl
specifier|static
name|boolean_t
name|atp_match_stroke_component
parameter_list|(
name|atp_stroke_component
modifier|*
parameter_list|,
specifier|const
name|atp_pspan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_match_strokes_against_pspans
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|atp_axis
parameter_list|,
name|atp_pspan
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|atp_update_strokes
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|atp_pspan
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|atp_pspan
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|atp_add_stroke
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
specifier|const
name|atp_pspan
modifier|*
parameter_list|,
specifier|const
name|atp_pspan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_add_new_strokes
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|atp_pspan
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|atp_pspan
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_advance_stroke_state
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|atp_stroke
modifier|*
parameter_list|,
name|boolean_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_terminate_stroke
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|boolean_t
name|atp_stroke_has_small_movement
parameter_list|(
specifier|const
name|atp_stroke
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|atp_update_pending_mickeys
parameter_list|(
name|atp_stroke_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_compute_smoothening_scale_ratio
parameter_list|(
name|atp_stroke
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|atp_compute_stroke_movement
parameter_list|(
name|atp_stroke
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* tap detection */
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
name|atp_setup_reap_time
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_reap_zombies
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* updating fifo */
end_comment

begin_function_decl
specifier|static
name|void
name|atp_reset_buf
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atp_add_to_queue
parameter_list|(
name|struct
name|atp_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|usb_error_t
name|atp_req_get_report
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_READ_CLASS_INTERFACE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_GET_REPORT
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
operator|(
name|uint8_t
operator|)
literal|0x03
comment|/* type */
argument_list|,
operator|(
name|uint8_t
operator|)
literal|0x00
comment|/* id */
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|MODE_LENGTH
argument_list|)
expr_stmt|;
return|return
operator|(
name|usbd_do_request
argument_list|(
name|udev
argument_list|,
name|NULL
comment|/* mutex */
argument_list|,
operator|&
name|req
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atp_set_device_mode
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|interface_mode
name|mode
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
decl_stmt|;
name|usb_device_request_t
name|req
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|mode
operator|!=
name|RAW_SENSOR_MODE
operator|)
operator|&&
operator|(
name|mode
operator|!=
name|HID_MODE
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mode_bytes
index|[
literal|0
index|]
operator|=
name|mode
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_CLASS_INTERFACE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_SET_REPORT
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
operator|(
name|uint8_t
operator|)
literal|0x03
comment|/* type */
argument_list|,
operator|(
name|uint8_t
operator|)
literal|0x00
comment|/* id */
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|MODE_LENGTH
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_do_request
argument_list|(
name|sc
operator|->
name|sc_usb_device
argument_list|,
name|NULL
argument_list|,
operator|&
name|req
argument_list|,
name|sc
operator|->
name|sc_mode_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atp_enable
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Allocate the dynamic buffers */
if|if
condition|(
name|atp_softc_populate
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atp_softc_unpopulate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* reset status */
name|memset
argument_list|(
name|sc
operator|->
name|sc_strokes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_strokes
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_n_strokes
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|sc_status
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_status
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_idlecount
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_state
operator||=
name|ATP_ENABLED
expr_stmt|;
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"enabled atp\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_disable
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|atp_softc_unpopulate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|ATP_ENABLED
expr_stmt|;
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"disabled atp\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate dynamic memory for some fields in softc. */
end_comment

begin_function
specifier|static
name|int
name|atp_softc_populate
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|atp_dev_params
modifier|*
name|params
init|=
name|sc
operator|->
name|sc_params
decl_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"params uninitialized!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|params
operator|->
name|data_len
condition|)
block|{
name|sc
operator|->
name|sensor_data
operator|=
name|malloc
argument_list|(
name|params
operator|->
name|data_len
operator|*
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sensor_data
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"mem for sensor_data\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
if|if
condition|(
name|params
operator|->
name|n_xsensors
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|base_x
operator|=
name|malloc
argument_list|(
name|params
operator|->
name|n_xsensors
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|sc
operator|->
name|base_x
operator|)
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|base_x
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"mem for sc->base_x\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|cur_x
operator|=
name|malloc
argument_list|(
name|params
operator|->
name|n_xsensors
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|sc
operator|->
name|cur_x
operator|)
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cur_x
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"mem for sc->cur_x\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|pressure_x
operator|=
name|malloc
argument_list|(
name|params
operator|->
name|n_xsensors
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|sc
operator|->
name|pressure_x
operator|)
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pressure_x
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"mem. for pressure_x\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
if|if
condition|(
name|params
operator|->
name|n_ysensors
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|base_y
operator|=
name|malloc
argument_list|(
name|params
operator|->
name|n_ysensors
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|sc
operator|->
name|base_y
operator|)
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|base_y
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"mem for base_y\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|cur_y
operator|=
name|malloc
argument_list|(
name|params
operator|->
name|n_ysensors
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|sc
operator|->
name|cur_y
operator|)
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cur_y
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"mem for cur_y\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|pressure_y
operator|=
name|malloc
argument_list|(
name|params
operator|->
name|n_ysensors
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|sc
operator|->
name|pressure_y
operator|)
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pressure_y
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"mem. for pressure_y\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free dynamic memory allocated for some fields in softc. */
end_comment

begin_function
specifier|static
name|void
name|atp_softc_unpopulate
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|atp_dev_params
modifier|*
name|params
init|=
name|sc
operator|->
name|sc_params
decl_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|params
operator|->
name|n_xsensors
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|base_x
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|base_x
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|sc
operator|->
name|base_x
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|cur_x
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|cur_x
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cur_x
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|pressure_x
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|pressure_x
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pressure_x
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|params
operator|->
name|n_ysensors
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|base_y
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|base_y
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|sc
operator|->
name|base_y
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|cur_y
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|cur_y
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cur_y
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|pressure_y
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|pressure_y
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pressure_y
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sensor_data
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|sensor_data
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sensor_data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Interpret the data from the X and Y pressure sensors. This function  * is called separately for the X and Y sensor arrays. The data in the  * USB packet is laid out in the following manner:  *  * sensor_data:  *            --,--,Y1,Y2,--,Y3,Y4,--,Y5,...,Y10, ... X1,X2,--,X3,X4  *  indices:   0  1  2  3  4  5  6  7  8 ...  15  ... 20 21 22 23 24  *  * '--' (in the above) indicates that the value is unimportant.  *  * Information about the above layout was obtained from the  * implementation of the AppleTouch driver in Linux.  *  * parameters:  *   sensor_data  *       raw sensor data from the USB packet.  *   num  *       The number of elements in the array 'arr'.  *   di_start  *       The index of the first data element to be interpreted for  *       this sensor array--i.e. when called to interpret the Y  *       sensors, di_start passed in as 2, which is the index of Y1 in  *       the raw data.  *   arr  *       The array to be initialized with the readings.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|atp_interpret_sensor_data
parameter_list|(
specifier|const
name|int8_t
modifier|*
name|sensor_data
parameter_list|,
name|u_int
name|num
parameter_list|,
name|u_int
name|di_start
parameter_list|,
name|int
modifier|*
name|arr
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|u_int
name|di
decl_stmt|;
comment|/* index into sensor data */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|di
operator|=
name|di_start
init|;
name|i
operator|<
name|num
condition|;
comment|/* empty */
control|)
block|{
name|arr
index|[
name|i
operator|++
index|]
operator|=
name|sensor_data
index|[
name|di
operator|++
index|]
expr_stmt|;
name|arr
index|[
name|i
operator|++
index|]
operator|=
name|sensor_data
index|[
name|di
operator|++
index|]
expr_stmt|;
name|di
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|atp_get_pressures
parameter_list|(
name|int
modifier|*
name|p
parameter_list|,
specifier|const
name|int
modifier|*
name|cur
parameter_list|,
specifier|const
name|int
modifier|*
name|base
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|p
index|[
name|i
index|]
operator|=
name|cur
index|[
name|i
index|]
operator|-
name|base
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
index|[
name|i
index|]
operator|>
literal|127
condition|)
name|p
index|[
name|i
index|]
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
name|p
index|[
name|i
index|]
operator|<
operator|-
literal|127
condition|)
name|p
index|[
name|i
index|]
operator|+=
literal|256
expr_stmt|;
if|if
condition|(
name|p
index|[
name|i
index|]
operator|<
literal|0
condition|)
name|p
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Shave off pressures below the noise-pressure 		 * threshold; this will reduce the contribution from 		 * lower pressure readings. 		 */
if|if
condition|(
name|p
index|[
name|i
index|]
operator|<=
name|atp_sensor_noise_threshold
condition|)
name|p
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* filter away noise */
else|else
name|p
index|[
name|i
index|]
operator|-=
name|atp_sensor_noise_threshold
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|atp_detect_pspans
parameter_list|(
name|int
modifier|*
name|p
parameter_list|,
name|u_int
name|num_sensors
parameter_list|,
name|u_int
name|max_spans
parameter_list|,
comment|/* max # of pspans permitted */
name|atp_pspan
modifier|*
name|spans
parameter_list|,
comment|/* finger spans */
name|u_int
modifier|*
name|nspans_p
parameter_list|)
comment|/* num spans detected */
block|{
name|u_int
name|i
decl_stmt|;
name|int
name|maxp
decl_stmt|;
comment|/* max pressure seen within a span */
name|u_int
name|num_spans
init|=
literal|0
decl_stmt|;
enum|enum
name|atp_pspan_state
block|{
name|ATP_PSPAN_INACTIVE
block|,
name|ATP_PSPAN_INCREASING
block|,
name|ATP_PSPAN_DECREASING
block|, 	}
name|state
enum|;
comment|/* state of the pressure span */
comment|/* 	 * The following is a simple state machine to track 	 * the phase of the pressure span. 	 */
name|memset
argument_list|(
name|spans
argument_list|,
literal|0
argument_list|,
name|max_spans
operator|*
sizeof|sizeof
argument_list|(
name|atp_pspan
argument_list|)
argument_list|)
expr_stmt|;
name|maxp
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|ATP_PSPAN_INACTIVE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_sensors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|num_spans
operator|>=
name|max_spans
condition|)
break|break;
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|ATP_PSPAN_INACTIVE
condition|)
block|{
comment|/* 				 * There is no pressure information for this 				 * sensor, and we aren't tracking a finger. 				 */
continue|continue;
block|}
else|else
block|{
name|state
operator|=
name|ATP_PSPAN_INACTIVE
expr_stmt|;
name|maxp
operator|=
literal|0
expr_stmt|;
name|num_spans
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ATP_PSPAN_INACTIVE
case|:
name|state
operator|=
name|ATP_PSPAN_INCREASING
expr_stmt|;
name|maxp
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|ATP_PSPAN_INCREASING
case|:
if|if
condition|(
name|p
index|[
name|i
index|]
operator|>
name|maxp
condition|)
name|maxp
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
name|i
index|]
operator|<=
operator|(
name|maxp
operator|>>
literal|1
operator|)
condition|)
name|state
operator|=
name|ATP_PSPAN_DECREASING
expr_stmt|;
break|break;
case|case
name|ATP_PSPAN_DECREASING
case|:
if|if
condition|(
name|p
index|[
name|i
index|]
operator|>
name|p
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
comment|/* 					 * This is the beginning of 					 * another span; change state 					 * to give the appearance that 					 * we're starting from an 					 * inactive span, and then 					 * re-process this reading in 					 * the next iteration. 					 */
name|num_spans
operator|++
expr_stmt|;
name|state
operator|=
name|ATP_PSPAN_INACTIVE
expr_stmt|;
name|maxp
operator|=
literal|0
expr_stmt|;
name|i
operator|--
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* Update the finger span with this reading. */
name|spans
index|[
name|num_spans
index|]
operator|.
name|width
operator|++
expr_stmt|;
name|spans
index|[
name|num_spans
index|]
operator|.
name|cum
operator|+=
name|p
index|[
name|i
index|]
expr_stmt|;
name|spans
index|[
name|num_spans
index|]
operator|.
name|cog
operator|+=
name|p
index|[
name|i
index|]
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|state
operator|!=
name|ATP_PSPAN_INACTIVE
condition|)
name|num_spans
operator|++
expr_stmt|;
comment|/* close the last finger span */
comment|/* post-process the spans */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_spans
condition|;
name|i
operator|++
control|)
block|{
comment|/* filter away unwanted pressure spans */
if|if
condition|(
operator|(
name|spans
index|[
name|i
index|]
operator|.
name|cum
operator|<
name|atp_pspan_min_cum_pressure
operator|)
operator|||
operator|(
name|spans
index|[
name|i
index|]
operator|.
name|width
operator|>
name|atp_pspan_max_width
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|num_spans
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|spans
index|[
name|i
index|]
argument_list|,
operator|&
name|spans
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|num_spans
operator|-
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|atp_pspan
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
name|num_spans
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* compute this span's representative location */
name|spans
index|[
name|i
index|]
operator|.
name|loc
operator|=
name|spans
index|[
name|i
index|]
operator|.
name|cog
operator|*
name|atp_mickeys_scale_factor
operator|/
name|spans
index|[
name|i
index|]
operator|.
name|cum
expr_stmt|;
name|spans
index|[
name|i
index|]
operator|.
name|matched
operator|=
name|FALSE
expr_stmt|;
comment|/* not yet matched against a stroke */
block|}
operator|*
name|nspans_p
operator|=
name|num_spans
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Match a pressure-span against a stroke-component. If there is a  * match, update the component's state and return TRUE.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|atp_match_stroke_component
parameter_list|(
name|atp_stroke_component
modifier|*
name|component
parameter_list|,
specifier|const
name|atp_pspan
modifier|*
name|pspan
parameter_list|)
block|{
name|int
name|delta_mickeys
init|=
name|pspan
operator|->
name|loc
operator|-
name|component
operator|->
name|loc
decl_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|delta_mickeys
argument_list|)
operator|>
name|atp_max_delta_mickeys
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* the finger span is too far out; no match */
name|component
operator|->
name|loc
operator|=
name|pspan
operator|->
name|loc
expr_stmt|;
name|component
operator|->
name|cum_pressure
operator|=
name|pspan
operator|->
name|cum
expr_stmt|;
if|if
condition|(
name|pspan
operator|->
name|cum
operator|>
name|component
operator|->
name|max_cum_pressure
condition|)
name|component
operator|->
name|max_cum_pressure
operator|=
name|pspan
operator|->
name|cum
expr_stmt|;
comment|/* 	 * If the cumulative pressure drops below a quarter of the max, 	 * then disregard the component's movement. 	 */
if|if
condition|(
name|component
operator|->
name|cum_pressure
operator|<
operator|(
name|component
operator|->
name|max_cum_pressure
operator|>>
literal|2
operator|)
condition|)
name|delta_mickeys
operator|=
literal|0
expr_stmt|;
name|component
operator|->
name|delta_mickeys
operator|=
name|delta_mickeys
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_match_strokes_against_pspans
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|atp_axis
name|axis
parameter_list|,
name|atp_pspan
modifier|*
name|pspans
parameter_list|,
name|u_int
name|n_pspans
parameter_list|,
name|u_int
name|repeat_count
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int
name|repeat_index
init|=
literal|0
decl_stmt|;
comment|/* Determine the index of the multi-span. */
if|if
condition|(
name|repeat_count
condition|)
block|{
name|u_int
name|cum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_pspans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pspans
index|[
name|i
index|]
operator|.
name|cum
operator|>
name|cum
condition|)
block|{
name|repeat_index
operator|=
name|i
expr_stmt|;
name|cum
operator|=
name|pspans
index|[
name|i
index|]
operator|.
name|cum
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_n_strokes
condition|;
name|i
operator|++
control|)
block|{
name|atp_stroke
modifier|*
name|stroke
init|=
operator|&
name|sc
operator|->
name|sc_strokes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|stroke
operator|->
name|components
index|[
name|axis
index|]
operator|.
name|matched
condition|)
continue|continue;
comment|/* skip matched components */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_pspans
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pspans
index|[
name|j
index|]
operator|.
name|matched
condition|)
continue|continue;
comment|/* skip matched pspans */
if|if
condition|(
name|atp_match_stroke_component
argument_list|(
operator|&
name|stroke
operator|->
name|components
index|[
name|axis
index|]
argument_list|,
operator|&
name|pspans
index|[
name|j
index|]
argument_list|)
condition|)
block|{
comment|/* There is a match. */
name|stroke
operator|->
name|components
index|[
name|axis
index|]
operator|.
name|matched
operator|=
name|TRUE
expr_stmt|;
comment|/* Take care to repeat at the multi-span. */
if|if
condition|(
operator|(
name|repeat_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|j
operator|==
name|repeat_index
operator|)
condition|)
name|repeat_count
operator|--
expr_stmt|;
else|else
name|pspans
index|[
name|j
index|]
operator|.
name|matched
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/* skip to the next stroke */
block|}
block|}
comment|/* loop over pspans */
block|}
comment|/* loop over strokes */
block|}
end_function

begin_comment
comment|/*  * Update strokes by matching against current pressure-spans.  * Return TRUE if any movement is detected.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|atp_update_strokes
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|atp_pspan
modifier|*
name|pspans_x
parameter_list|,
name|u_int
name|n_xpspans
parameter_list|,
name|atp_pspan
modifier|*
name|pspans_y
parameter_list|,
name|u_int
name|n_ypspans
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|atp_stroke
modifier|*
name|stroke
decl_stmt|;
name|boolean_t
name|movement
init|=
name|FALSE
decl_stmt|;
name|u_int
name|repeat_count
init|=
literal|0
decl_stmt|;
comment|/* Reset X and Y components of all strokes as unmatched. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_n_strokes
condition|;
name|i
operator|++
control|)
block|{
name|stroke
operator|=
operator|&
name|sc
operator|->
name|sc_strokes
index|[
name|i
index|]
expr_stmt|;
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|matched
operator|=
name|FALSE
expr_stmt|;
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|matched
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* 	 * Usually, the X and Y pspans come in pairs (the common case 	 * being a single pair). It is possible, however, that 	 * multiple contacts resolve to a single pspan along an 	 * axis, as illustrated in the following: 	 * 	 *   F = finger-contact 	 * 	 *                pspan  pspan 	 *        +-----------------------+ 	 *        |         .      .      | 	 *        |         .      .      | 	 *        |         .      .      | 	 *        |         .      .      | 	 *  pspan |.........F......F      | 	 *        |                       | 	 *        |                       | 	 *        |                       | 	 *        +-----------------------+ 	 * 	 * 	 * The above case can be detected by a difference in the 	 * number of X and Y pspans. When this happens, X and Y pspans 	 * aren't easy to pair or match against strokes. 	 * 	 * When X and Y pspans differ in number, the axis with the 	 * smaller number of pspans is regarded as having a repeating 	 * pspan (or a multi-pspan)--in the above illustration, the 	 * Y-axis has a repeating pspan. Our approach is to try to 	 * match the multi-pspan repeatedly against strokes. The 	 * difference between the number of X and Y pspans gives us a 	 * crude repeat_count for matching multi-pspans--i.e. the 	 * multi-pspan along the Y axis (above) has a repeat_count of 1. 	 */
name|repeat_count
operator|=
name|abs
argument_list|(
name|n_xpspans
operator|-
name|n_ypspans
argument_list|)
expr_stmt|;
name|atp_match_strokes_against_pspans
argument_list|(
name|sc
argument_list|,
name|X
argument_list|,
name|pspans_x
argument_list|,
name|n_xpspans
argument_list|,
operator|(
operator|(
operator|(
name|repeat_count
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|n_xpspans
operator|<
name|n_ypspans
operator|)
operator|)
operator|)
condition|?
name|repeat_count
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|atp_match_strokes_against_pspans
argument_list|(
name|sc
argument_list|,
name|Y
argument_list|,
name|pspans_y
argument_list|,
name|n_ypspans
argument_list|,
operator|(
operator|(
operator|(
name|repeat_count
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|n_ypspans
operator|<
name|n_xpspans
operator|)
operator|)
condition|?
name|repeat_count
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Update the state of strokes based on the above pspan matches. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_n_strokes
condition|;
name|i
operator|++
control|)
block|{
name|stroke
operator|=
operator|&
name|sc
operator|->
name|sc_strokes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|matched
operator|&&
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|matched
condition|)
block|{
name|atp_advance_stroke_state
argument_list|(
name|sc
argument_list|,
name|stroke
argument_list|,
operator|&
name|movement
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * At least one component of this stroke 			 * didn't match against current pspans; 			 * terminate it. 			 */
name|atp_terminate_stroke
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add new strokes for pairs of unmatched pspans */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_xpspans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pspans_x
index|[
name|i
index|]
operator|.
name|matched
operator|==
name|FALSE
condition|)
break|break;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_ypspans
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pspans_y
index|[
name|j
index|]
operator|.
name|matched
operator|==
name|FALSE
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|i
operator|<
name|n_xpspans
operator|)
operator|&&
operator|(
name|j
operator|<
name|n_ypspans
operator|)
condition|)
block|{
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|atp_debug
operator|>=
name|ATP_LLEVEL_INFO
condition|)
block|{
name|printf
argument_list|(
literal|"unmatched pspans:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|n_xpspans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pspans_x
index|[
name|i
index|]
operator|.
name|matched
condition|)
continue|continue;
name|printf
argument_list|(
literal|" X:[loc:%u,cum:%u]"
argument_list|,
name|pspans_x
index|[
name|i
index|]
operator|.
name|loc
argument_list|,
name|pspans_x
index|[
name|i
index|]
operator|.
name|cum
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|j
operator|<
name|n_ypspans
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pspans_y
index|[
name|j
index|]
operator|.
name|matched
condition|)
continue|continue;
name|printf
argument_list|(
literal|" Y:[loc:%u,cum:%u]"
argument_list|,
name|pspans_y
index|[
name|j
index|]
operator|.
name|loc
argument_list|,
name|pspans_y
index|[
name|j
index|]
operator|.
name|cum
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* #if USB_DEBUG */
if|if
condition|(
operator|(
name|n_xpspans
operator|==
literal|1
operator|)
operator|&&
operator|(
name|n_ypspans
operator|==
literal|1
operator|)
condition|)
comment|/* The common case of a single pair of new pspans. */
name|atp_add_stroke
argument_list|(
name|sc
argument_list|,
operator|&
name|pspans_x
index|[
literal|0
index|]
argument_list|,
operator|&
name|pspans_y
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|atp_add_new_strokes
argument_list|(
name|sc
argument_list|,
name|pspans_x
argument_list|,
name|n_xpspans
argument_list|,
name|pspans_y
argument_list|,
name|n_ypspans
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|atp_debug
operator|>=
name|ATP_LLEVEL_INFO
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_n_strokes
condition|;
name|i
operator|++
control|)
block|{
name|atp_stroke
modifier|*
name|stroke
init|=
operator|&
name|sc
operator|->
name|sc_strokes
index|[
name|i
index|]
decl_stmt|;
name|printf
argument_list|(
literal|" %s%clc:%u,dm:%d,pnd:%d,mv:%d%c"
literal|",%clc:%u,dm:%d,pnd:%d,mv:%d%c"
argument_list|,
operator|(
name|stroke
operator|->
name|flags
operator|&
name|ATSF_ZOMBIE
operator|)
condition|?
literal|"zomb:"
else|:
literal|""
argument_list|,
operator|(
name|stroke
operator|->
name|type
operator|==
name|ATP_STROKE_TOUCH
operator|)
condition|?
literal|'['
else|:
literal|'<'
argument_list|,
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|loc
argument_list|,
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|delta_mickeys
argument_list|,
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|pending
argument_list|,
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|movement
argument_list|,
operator|(
name|stroke
operator|->
name|type
operator|==
name|ATP_STROKE_TOUCH
operator|)
condition|?
literal|']'
else|:
literal|'>'
argument_list|,
operator|(
name|stroke
operator|->
name|type
operator|==
name|ATP_STROKE_TOUCH
operator|)
condition|?
literal|'['
else|:
literal|'<'
argument_list|,
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|loc
argument_list|,
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|delta_mickeys
argument_list|,
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|pending
argument_list|,
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|movement
argument_list|,
operator|(
name|stroke
operator|->
name|type
operator|==
name|ATP_STROKE_TOUCH
operator|)
condition|?
literal|']'
else|:
literal|'>'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_n_strokes
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* #if USB_DEBUG */
return|return
operator|(
name|movement
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize a stroke using a pressure-span. */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|atp_add_stroke
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|atp_pspan
modifier|*
name|pspan_x
parameter_list|,
specifier|const
name|atp_pspan
modifier|*
name|pspan_y
parameter_list|)
block|{
name|atp_stroke
modifier|*
name|stroke
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_n_strokes
operator|>=
name|ATP_MAX_STROKES
condition|)
return|return;
name|stroke
operator|=
operator|&
name|sc
operator|->
name|sc_strokes
index|[
name|sc
operator|->
name|sc_n_strokes
index|]
expr_stmt|;
name|memset
argument_list|(
name|stroke
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|atp_stroke
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Strokes begin as potential touches. If a stroke survives 	 * longer than a threshold, or if it records significant 	 * cumulative movement, then it is considered a 'slide'. 	 */
name|stroke
operator|->
name|type
operator|=
name|ATP_STROKE_TOUCH
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|stroke
operator|->
name|ctime
argument_list|)
expr_stmt|;
name|stroke
operator|->
name|age
operator|=
literal|1
expr_stmt|;
comment|/* Unit: interrupts */
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|loc
operator|=
name|pspan_x
operator|->
name|loc
expr_stmt|;
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|cum_pressure
operator|=
name|pspan_x
operator|->
name|cum
expr_stmt|;
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|max_cum_pressure
operator|=
name|pspan_x
operator|->
name|cum
expr_stmt|;
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|matched
operator|=
name|TRUE
expr_stmt|;
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|loc
operator|=
name|pspan_y
operator|->
name|loc
expr_stmt|;
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|cum_pressure
operator|=
name|pspan_y
operator|->
name|cum
expr_stmt|;
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|max_cum_pressure
operator|=
name|pspan_y
operator|->
name|cum
expr_stmt|;
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|matched
operator|=
name|TRUE
expr_stmt|;
name|sc
operator|->
name|sc_n_strokes
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_n_strokes
operator|>
literal|1
condition|)
block|{
comment|/* Reset double-tap-n-drag if we have more than one strokes. */
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|ATP_DOUBLE_TAP_DRAG
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"[%u,%u], time: %u,%ld\n"
argument_list|,
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|loc
argument_list|,
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|loc
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|stroke
operator|->
name|ctime
operator|.
name|tv_sec
argument_list|,
operator|(
name|unsigned
name|long
name|int
operator|)
name|stroke
operator|->
name|ctime
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_add_new_strokes
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|atp_pspan
modifier|*
name|pspans_x
parameter_list|,
name|u_int
name|n_xpspans
parameter_list|,
name|atp_pspan
modifier|*
name|pspans_y
parameter_list|,
name|u_int
name|n_ypspans
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|atp_pspan
name|spans
index|[
literal|2
index|]
index|[
name|ATP_MAX_PSPANS_PER_AXIS
index|]
decl_stmt|;
name|u_int
name|nspans
index|[
literal|2
index|]
decl_stmt|;
comment|/* Copy unmatched pspans into the local arrays. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|nspans
index|[
name|X
index|]
operator|=
literal|0
init|;
name|i
operator|<
name|n_xpspans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pspans_x
index|[
name|i
index|]
operator|.
name|matched
operator|==
name|FALSE
condition|)
block|{
name|spans
index|[
name|X
index|]
index|[
name|nspans
index|[
name|X
index|]
index|]
operator|=
name|pspans_x
index|[
name|i
index|]
expr_stmt|;
name|nspans
index|[
name|X
index|]
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|nspans
index|[
name|Y
index|]
operator|=
literal|0
init|;
name|j
operator|<
name|n_ypspans
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pspans_y
index|[
name|j
index|]
operator|.
name|matched
operator|==
name|FALSE
condition|)
block|{
name|spans
index|[
name|Y
index|]
index|[
name|nspans
index|[
name|Y
index|]
index|]
operator|=
name|pspans_y
index|[
name|j
index|]
expr_stmt|;
name|nspans
index|[
name|Y
index|]
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nspans
index|[
name|X
index|]
operator|==
name|nspans
index|[
name|Y
index|]
condition|)
block|{
comment|/* Create new strokes from pairs of unmatched pspans */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|nspans
index|[
name|X
index|]
operator|)
operator|&&
operator|(
name|j
operator|<
name|nspans
index|[
name|Y
index|]
operator|)
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|atp_add_stroke
argument_list|(
name|sc
argument_list|,
operator|&
name|spans
index|[
name|X
index|]
index|[
name|i
index|]
argument_list|,
operator|&
name|spans
index|[
name|Y
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int
name|cum
init|=
literal|0
decl_stmt|;
name|atp_axis
name|repeat_axis
decl_stmt|;
comment|/* axis with multi-pspans */
name|u_int
name|repeat_count
decl_stmt|;
comment|/* repeat count for the multi-pspan*/
name|u_int
name|repeat_index
init|=
literal|0
decl_stmt|;
comment|/* index of the multi-span */
name|repeat_axis
operator|=
operator|(
name|nspans
index|[
name|X
index|]
operator|>
name|nspans
index|[
name|Y
index|]
operator|)
condition|?
name|Y
else|:
name|X
expr_stmt|;
name|repeat_count
operator|=
name|abs
argument_list|(
name|nspans
index|[
name|X
index|]
operator|-
name|nspans
index|[
name|Y
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspans
index|[
name|repeat_axis
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spans
index|[
name|repeat_axis
index|]
index|[
name|i
index|]
operator|.
name|cum
operator|>
name|cum
condition|)
block|{
name|repeat_index
operator|=
name|i
expr_stmt|;
name|cum
operator|=
name|spans
index|[
name|repeat_axis
index|]
index|[
name|i
index|]
operator|.
name|cum
expr_stmt|;
block|}
block|}
comment|/* Create new strokes from pairs of unmatched pspans */
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|i
operator|<
name|nspans
index|[
name|X
index|]
operator|)
operator|&&
operator|(
name|j
operator|<
name|nspans
index|[
name|Y
index|]
operator|)
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|atp_add_stroke
argument_list|(
name|sc
argument_list|,
operator|&
name|spans
index|[
name|X
index|]
index|[
name|i
index|]
argument_list|,
operator|&
name|spans
index|[
name|Y
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
comment|/* Take care to repeat at the multi-pspan. */
if|if
condition|(
name|repeat_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|repeat_axis
operator|==
name|X
operator|)
operator|&&
operator|(
name|repeat_index
operator|==
name|i
operator|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
comment|/* counter loop increment */
name|repeat_count
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|repeat_axis
operator|==
name|Y
operator|)
operator|&&
operator|(
name|repeat_index
operator|==
name|j
operator|)
condition|)
block|{
name|j
operator|--
expr_stmt|;
comment|/* counter loop increment */
name|repeat_count
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Advance the state of this stroke--and update the out-parameter  * 'movement' as a side-effect.  */
end_comment

begin_function
name|void
name|atp_advance_stroke_state
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|atp_stroke
modifier|*
name|stroke
parameter_list|,
name|boolean_t
modifier|*
name|movement
parameter_list|)
block|{
name|stroke
operator|->
name|age
operator|++
expr_stmt|;
if|if
condition|(
name|stroke
operator|->
name|age
operator|<=
name|atp_stroke_maturity_threshold
condition|)
block|{
comment|/* Avoid noise from immature strokes. */
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|delta_mickeys
operator|=
literal|0
expr_stmt|;
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|delta_mickeys
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Revitalize stroke if it had previously been marked as a zombie. */
if|if
condition|(
name|stroke
operator|->
name|flags
operator|&
name|ATSF_ZOMBIE
condition|)
name|stroke
operator|->
name|flags
operator|&=
operator|~
name|ATSF_ZOMBIE
expr_stmt|;
if|if
condition|(
name|atp_compute_stroke_movement
argument_list|(
name|stroke
argument_list|)
condition|)
operator|*
name|movement
operator|=
name|TRUE
expr_stmt|;
comment|/* Convert touch strokes to slides upon detecting movement or age. */
if|if
condition|(
name|stroke
operator|->
name|type
operator|==
name|ATP_STROKE_TOUCH
condition|)
block|{
name|struct
name|timeval
name|tdiff
decl_stmt|;
comment|/* Compute the stroke's age. */
name|getmicrotime
argument_list|(
operator|&
name|tdiff
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|tdiff
argument_list|,
operator|&
name|stroke
operator|->
name|ctime
argument_list|,
operator|>
argument_list|)
condition|)
name|timevalsub
argument_list|(
operator|&
name|tdiff
argument_list|,
operator|&
name|stroke
operator|->
name|ctime
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 			 * If we are here, it is because getmicrotime 			 * reported the current time as being behind 			 * the stroke's start time; getmicrotime can 			 * be imprecise. 			 */
name|tdiff
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tdiff
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tdiff
operator|.
name|tv_sec
operator|>
operator|(
name|atp_touch_timeout
operator|/
literal|1000000
operator|)
operator|)
operator|||
operator|(
operator|(
name|tdiff
operator|.
name|tv_sec
operator|==
operator|(
name|atp_touch_timeout
operator|/
literal|1000000
operator|)
operator|)
operator|&&
operator|(
name|tdiff
operator|.
name|tv_usec
operator|>
name|atp_touch_timeout
operator|)
operator|)
operator|||
operator|(
name|stroke
operator|->
name|cum_movement
operator|>=
name|atp_slide_min_movement
operator|)
condition|)
block|{
comment|/* Switch this stroke to being a slide. */
name|stroke
operator|->
name|type
operator|=
name|ATP_STROKE_SLIDE
expr_stmt|;
comment|/* Are we at the beginning of a double-click-n-drag? */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_n_strokes
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|sc
operator|->
name|sc_state
operator|&
name|ATP_ZOMBIES_EXIST
operator|)
operator|==
literal|0
operator|)
operator|&&
name|timevalcmp
argument_list|(
operator|&
name|stroke
operator|->
name|ctime
argument_list|,
operator|&
name|sc
operator|->
name|sc_reap_time
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|struct
name|timeval
name|delta
decl_stmt|;
name|struct
name|timeval
name|window
init|=
block|{
name|atp_double_tap_threshold
operator|/
literal|1000000
block|,
name|atp_double_tap_threshold
operator|%
literal|1000000
block|}
decl_stmt|;
name|delta
operator|=
name|stroke
operator|->
name|ctime
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|sc
operator|->
name|sc_reap_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|window
argument_list|,
operator|<=
argument_list|)
condition|)
name|sc
operator|->
name|sc_state
operator||=
name|ATP_DOUBLE_TAP_DRAG
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Terminate a stroke. While SLIDE strokes are dropped, TOUCH strokes  * are retained as zombies so as to reap all their siblings together;  * this helps establish the number of fingers involved in the tap.  */
end_comment

begin_function
specifier|static
name|void
name|atp_terminate_stroke
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|index
parameter_list|)
comment|/* index of the stroke to be terminated */
block|{
name|atp_stroke
modifier|*
name|s
init|=
operator|&
name|sc
operator|->
name|sc_strokes
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|ATSF_ZOMBIE
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|type
operator|==
name|ATP_STROKE_TOUCH
operator|)
operator|&&
operator|(
name|s
operator|->
name|age
operator|>
name|atp_stroke_maturity_threshold
operator|)
condition|)
block|{
name|s
operator|->
name|flags
operator||=
name|ATSF_ZOMBIE
expr_stmt|;
comment|/* If no zombies exist, then prepare to reap zombies later. */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_state
operator|&
name|ATP_ZOMBIES_EXIST
operator|)
operator|==
literal|0
condition|)
block|{
name|atp_setup_reap_time
argument_list|(
name|sc
argument_list|,
operator|&
name|s
operator|->
name|ctime
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator||=
name|ATP_ZOMBIES_EXIST
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Drop this stroke. */
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|sc_strokes
index|[
name|index
index|]
argument_list|,
operator|&
name|sc
operator|->
name|sc_strokes
index|[
name|index
operator|+
literal|1
index|]
argument_list|,
operator|(
name|sc
operator|->
name|sc_n_strokes
operator|-
name|index
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|atp_stroke
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_n_strokes
operator|--
expr_stmt|;
comment|/* 		 * Reset the double-click-n-drag at the termination of 		 * any slide stroke. 		 */
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|ATP_DOUBLE_TAP_DRAG
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|atp_stroke_has_small_movement
parameter_list|(
specifier|const
name|atp_stroke
modifier|*
name|stroke
parameter_list|)
block|{
return|return
operator|(
operator|(
name|abs
argument_list|(
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|delta_mickeys
argument_list|)
operator|<=
name|atp_small_movement_threshold
operator|)
operator|&&
operator|(
name|abs
argument_list|(
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|delta_mickeys
argument_list|)
operator|<=
name|atp_small_movement_threshold
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Accumulate delta_mickeys into the component's 'pending' bucket; if  * the aggregate exceeds the small_movement_threshold, then retain  * delta_mickeys for later.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|atp_update_pending_mickeys
parameter_list|(
name|atp_stroke_component
modifier|*
name|component
parameter_list|)
block|{
name|component
operator|->
name|pending
operator|+=
name|component
operator|->
name|delta_mickeys
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|component
operator|->
name|pending
argument_list|)
operator|<=
name|atp_small_movement_threshold
condition|)
name|component
operator|->
name|delta_mickeys
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 		 * Penalise pending mickeys for having accumulated 		 * over short deltas. This operation has the effect of 		 * scaling down the cumulative contribution of short 		 * movements. 		 */
name|component
operator|->
name|pending
operator|-=
operator|(
name|component
operator|->
name|delta_mickeys
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|atp_compute_smoothening_scale_ratio
parameter_list|(
name|atp_stroke
modifier|*
name|stroke
parameter_list|,
name|int
modifier|*
name|numerator
parameter_list|,
name|int
modifier|*
name|denominator
parameter_list|)
block|{
name|int
name|dxdt
decl_stmt|;
name|int
name|dydt
decl_stmt|;
name|u_int
name|vel_squared
decl_stmt|;
comment|/* Square of the velocity vector's magnitude. */
name|u_int
name|vel_squared_smooth
decl_stmt|;
comment|/* Table holding (10 * sqrt(x)) for x between 1 and 256. */
specifier|static
name|uint8_t
name|sqrt_table
index|[
literal|256
index|]
init|=
block|{
literal|10
block|,
literal|14
block|,
literal|17
block|,
literal|20
block|,
literal|22
block|,
literal|24
block|,
literal|26
block|,
literal|28
block|,
literal|30
block|,
literal|31
block|,
literal|33
block|,
literal|34
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|50
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|64
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|72
block|,
literal|73
block|,
literal|74
block|,
literal|74
block|,
literal|75
block|,
literal|76
block|,
literal|76
block|,
literal|77
block|,
literal|78
block|,
literal|78
block|,
literal|79
block|,
literal|80
block|,
literal|80
block|,
literal|81
block|,
literal|81
block|,
literal|82
block|,
literal|83
block|,
literal|83
block|,
literal|84
block|,
literal|84
block|,
literal|85
block|,
literal|86
block|,
literal|86
block|,
literal|87
block|,
literal|87
block|,
literal|88
block|,
literal|88
block|,
literal|89
block|,
literal|90
block|,
literal|90
block|,
literal|91
block|,
literal|91
block|,
literal|92
block|,
literal|92
block|,
literal|93
block|,
literal|93
block|,
literal|94
block|,
literal|94
block|,
literal|95
block|,
literal|95
block|,
literal|96
block|,
literal|96
block|,
literal|97
block|,
literal|97
block|,
literal|98
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|101
block|,
literal|101
block|,
literal|102
block|,
literal|102
block|,
literal|103
block|,
literal|103
block|,
literal|104
block|,
literal|104
block|,
literal|105
block|,
literal|105
block|,
literal|106
block|,
literal|106
block|,
literal|107
block|,
literal|107
block|,
literal|108
block|,
literal|108
block|,
literal|109
block|,
literal|109
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|111
block|,
literal|111
block|,
literal|112
block|,
literal|112
block|,
literal|113
block|,
literal|113
block|,
literal|114
block|,
literal|114
block|,
literal|114
block|,
literal|115
block|,
literal|115
block|,
literal|116
block|,
literal|116
block|,
literal|117
block|,
literal|117
block|,
literal|117
block|,
literal|118
block|,
literal|118
block|,
literal|119
block|,
literal|119
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|121
block|,
literal|121
block|,
literal|122
block|,
literal|122
block|,
literal|122
block|,
literal|123
block|,
literal|123
block|,
literal|124
block|,
literal|124
block|,
literal|124
block|,
literal|125
block|,
literal|125
block|,
literal|126
block|,
literal|126
block|,
literal|126
block|,
literal|127
block|,
literal|127
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|129
block|,
literal|129
block|,
literal|130
block|,
literal|130
block|,
literal|130
block|,
literal|131
block|,
literal|131
block|,
literal|131
block|,
literal|132
block|,
literal|132
block|,
literal|133
block|,
literal|133
block|,
literal|133
block|,
literal|134
block|,
literal|134
block|,
literal|134
block|,
literal|135
block|,
literal|135
block|,
literal|136
block|,
literal|136
block|,
literal|136
block|,
literal|137
block|,
literal|137
block|,
literal|137
block|,
literal|138
block|,
literal|138
block|,
literal|138
block|,
literal|139
block|,
literal|139
block|,
literal|140
block|,
literal|140
block|,
literal|140
block|,
literal|141
block|,
literal|141
block|,
literal|141
block|,
literal|142
block|,
literal|142
block|,
literal|142
block|,
literal|143
block|,
literal|143
block|,
literal|143
block|,
literal|144
block|,
literal|144
block|,
literal|144
block|,
literal|145
block|,
literal|145
block|,
literal|145
block|,
literal|146
block|,
literal|146
block|,
literal|146
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|148
block|,
literal|148
block|,
literal|148
block|,
literal|149
block|,
literal|149
block|,
literal|150
block|,
literal|150
block|,
literal|150
block|,
literal|150
block|,
literal|151
block|,
literal|151
block|,
literal|151
block|,
literal|152
block|,
literal|152
block|,
literal|152
block|,
literal|153
block|,
literal|153
block|,
literal|153
block|,
literal|154
block|,
literal|154
block|,
literal|154
block|,
literal|155
block|,
literal|155
block|,
literal|155
block|,
literal|156
block|,
literal|156
block|,
literal|156
block|,
literal|157
block|,
literal|157
block|,
literal|157
block|,
literal|158
block|,
literal|158
block|,
literal|158
block|,
literal|159
block|,
literal|159
block|,
literal|159
block|,
literal|160
block|}
decl_stmt|;
specifier|const
name|u_int
name|N
init|=
sizeof|sizeof
argument_list|(
name|sqrt_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sqrt_table
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|dxdt
operator|=
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|delta_mickeys
expr_stmt|;
name|dydt
operator|=
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|delta_mickeys
expr_stmt|;
operator|*
name|numerator
operator|=
literal|0
operator|,
operator|*
name|denominator
operator|=
literal|0
expr_stmt|;
comment|/* default values. */
comment|/* Compute a smoothened magnitude_squared of the stroke's velocity. */
name|vel_squared
operator|=
name|dxdt
operator|*
name|dxdt
operator|+
name|dydt
operator|*
name|dydt
expr_stmt|;
name|vel_squared_smooth
operator|=
operator|(
literal|3
operator|*
name|stroke
operator|->
name|velocity_squared
operator|+
name|vel_squared
operator|)
operator|>>
literal|2
expr_stmt|;
name|stroke
operator|->
name|velocity_squared
operator|=
name|vel_squared_smooth
expr_stmt|;
comment|/* retained as history */
if|if
condition|(
operator|(
name|vel_squared
operator|==
literal|0
operator|)
operator|||
operator|(
name|vel_squared_smooth
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* returning (numerator == 0) will imply zero movement*/
comment|/* 	 * In order to determine the overall movement scale factor, 	 * we're actually interested in the effect of smoothening upon 	 * the *magnitude* of velocity; i.e. we need to compute the 	 * square-root of (vel_squared_smooth / vel_squared) in the 	 * form of a numerator and denominator. 	 */
comment|/* Keep within the bounds of the square-root table. */
while|while
condition|(
operator|(
name|vel_squared
operator|>
name|N
operator|)
operator|||
operator|(
name|vel_squared_smooth
operator|>
name|N
operator|)
condition|)
block|{
comment|/* Dividing uniformly by 2 won't disturb the final ratio. */
name|vel_squared
operator|>>=
literal|1
expr_stmt|;
name|vel_squared_smooth
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|numerator
operator|=
name|sqrt_table
index|[
name|vel_squared_smooth
operator|-
literal|1
index|]
expr_stmt|;
operator|*
name|denominator
operator|=
name|sqrt_table
index|[
name|vel_squared
operator|-
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute a smoothened value for the stroke's movement from  * delta_mickeys in the X and Y components.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|atp_compute_stroke_movement
parameter_list|(
name|atp_stroke
modifier|*
name|stroke
parameter_list|)
block|{
name|int
name|num
decl_stmt|;
comment|/* numerator of scale ratio */
name|int
name|denom
decl_stmt|;
comment|/* denominator of scale ratio */
comment|/* 	 * Short movements are added first to the 'pending' bucket, 	 * and then acted upon only when their aggregate exceeds a 	 * threshold. This has the effect of filtering away movement 	 * noise. 	 */
if|if
condition|(
name|atp_stroke_has_small_movement
argument_list|(
name|stroke
argument_list|)
condition|)
block|{
name|atp_update_pending_mickeys
argument_list|(
operator|&
name|stroke
operator|->
name|components
index|[
name|X
index|]
argument_list|)
expr_stmt|;
name|atp_update_pending_mickeys
argument_list|(
operator|&
name|stroke
operator|->
name|components
index|[
name|Y
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* large movement */
comment|/* clear away any pending mickeys if there are large movements*/
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|pending
operator|=
literal|0
expr_stmt|;
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|pending
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Get the scale ratio and smoothen movement. */
name|atp_compute_smoothening_scale_ratio
argument_list|(
name|stroke
argument_list|,
operator|&
name|num
argument_list|,
operator|&
name|denom
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|num
operator|==
literal|0
operator|)
operator|||
operator|(
name|denom
operator|==
literal|0
operator|)
condition|)
block|{
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|movement
operator|=
literal|0
expr_stmt|;
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|movement
operator|=
literal|0
expr_stmt|;
name|stroke
operator|->
name|velocity_squared
operator|>>=
literal|1
expr_stmt|;
comment|/* Erode velocity_squared. */
block|}
else|else
block|{
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|movement
operator|=
operator|(
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|delta_mickeys
operator|*
name|num
operator|)
operator|/
name|denom
expr_stmt|;
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|movement
operator|=
operator|(
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|delta_mickeys
operator|*
name|num
operator|)
operator|/
name|denom
expr_stmt|;
name|stroke
operator|->
name|cum_movement
operator|+=
name|abs
argument_list|(
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|movement
argument_list|)
operator|+
name|abs
argument_list|(
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|movement
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|movement
operator|!=
literal|0
operator|)
operator|||
operator|(
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|movement
operator|!=
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|atp_setup_reap_time
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|timeval
name|reap_window
init|=
block|{
name|ATP_ZOMBIE_STROKE_REAP_WINDOW
operator|/
literal|1000000
block|,
name|ATP_ZOMBIE_STROKE_REAP_WINDOW
operator|%
literal|1000000
block|}
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|sc
operator|->
name|sc_reap_time
argument_list|)
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|sc
operator|->
name|sc_reap_time
argument_list|,
operator|&
name|reap_window
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_reap_ctime
operator|=
operator|*
name|tvp
expr_stmt|;
comment|/* ctime to reap */
block|}
end_function

begin_function
specifier|static
name|void
name|atp_reap_zombies
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|u_int
modifier|*
name|n_reaped
parameter_list|,
name|u_int
modifier|*
name|reaped_xlocs
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|atp_stroke
modifier|*
name|stroke
decl_stmt|;
operator|*
name|n_reaped
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_n_strokes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|timeval
name|tdiff
decl_stmt|;
name|stroke
operator|=
operator|&
name|sc
operator|->
name|sc_strokes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|stroke
operator|->
name|flags
operator|&
name|ATSF_ZOMBIE
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Compare this stroke's ctime with the ctime being reaped. */
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|stroke
operator|->
name|ctime
argument_list|,
operator|&
name|sc
operator|->
name|sc_reap_ctime
argument_list|,
operator|>=
argument_list|)
condition|)
block|{
name|tdiff
operator|=
name|stroke
operator|->
name|ctime
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|tdiff
argument_list|,
operator|&
name|sc
operator|->
name|sc_reap_ctime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tdiff
operator|=
name|sc
operator|->
name|sc_reap_ctime
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|tdiff
argument_list|,
operator|&
name|stroke
operator|->
name|ctime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tdiff
operator|.
name|tv_sec
operator|>
operator|(
name|ATP_COINCIDENCE_THRESHOLD
operator|/
literal|1000000
operator|)
operator|)
operator|||
operator|(
operator|(
name|tdiff
operator|.
name|tv_sec
operator|==
operator|(
name|ATP_COINCIDENCE_THRESHOLD
operator|/
literal|1000000
operator|)
operator|)
operator|&&
operator|(
name|tdiff
operator|.
name|tv_usec
operator|>
operator|(
name|ATP_COINCIDENCE_THRESHOLD
operator|%
literal|1000000
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
comment|/* Skip non-siblings. */
block|}
comment|/* 		 * Reap this sibling zombie stroke. 		 */
if|if
condition|(
name|reaped_xlocs
operator|!=
name|NULL
condition|)
name|reaped_xlocs
index|[
operator|*
name|n_reaped
index|]
operator|=
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|loc
expr_stmt|;
comment|/* Erase the stroke from the sc. */
name|memcpy
argument_list|(
operator|&
name|stroke
index|[
name|i
index|]
argument_list|,
operator|&
name|stroke
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|sc
operator|->
name|sc_n_strokes
operator|-
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|atp_stroke
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_n_strokes
operator|--
expr_stmt|;
operator|*
name|n_reaped
operator|+=
literal|1
expr_stmt|;
operator|--
name|i
expr_stmt|;
comment|/* Decr. i to keep it unchanged for the next iteration */
block|}
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"reaped %u zombies\n"
argument_list|,
operator|*
name|n_reaped
argument_list|)
expr_stmt|;
comment|/* There could still be zombies remaining in the system. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_n_strokes
condition|;
name|i
operator|++
control|)
block|{
name|stroke
operator|=
operator|&
name|sc
operator|->
name|sc_strokes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|stroke
operator|->
name|flags
operator|&
name|ATSF_ZOMBIE
condition|)
block|{
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"zombies remain!\n"
argument_list|)
expr_stmt|;
name|atp_setup_reap_time
argument_list|(
name|sc
argument_list|,
operator|&
name|stroke
operator|->
name|ctime
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* If we reach here, then no more zombies remain. */
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|ATP_ZOMBIES_EXIST
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Device methods. */
end_comment

begin_decl_stmt
specifier|static
name|device_probe_t
name|atp_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|atp_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|atp_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|atp_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|atp_config
index|[
name|ATP_N_TRANSFER
index|]
init|=
block|{
index|[
name|ATP_INTR_DT
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_INTERRUPT
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|, 		}
block|,
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use wMaxPacketSize */
operator|.
name|callback
operator|=
operator|&
name|atp_intr
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|atp_probe
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|self
argument_list|)
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|uaa
operator|->
name|info
operator|.
name|bInterfaceClass
operator|!=
name|UICLASS_HID
operator|)
operator|||
operator|(
name|uaa
operator|->
name|info
operator|.
name|bInterfaceProtocol
operator|!=
name|UIPROTO_MOUSE
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|usbd_lookup_id_by_uaa
argument_list|(
name|atp_devs
argument_list|,
sizeof|sizeof
argument_list|(
name|atp_devs
argument_list|)
argument_list|,
name|uaa
argument_list|)
operator|==
literal|0
condition|)
return|return
name|BUS_PROBE_SPECIFIC
return|;
else|else
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
comment|/* ensure that the probe was successful */
if|if
condition|(
name|uaa
operator|->
name|driver_info
operator|>=
name|ATP_N_DEV_PARAMS
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"device probe returned bad id: %lu\n"
argument_list|,
name|uaa
operator|->
name|driver_info
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"sc=%p\n"
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_usb_device
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
comment|/* 	 * By default the touchpad behaves like an HID device, sending 	 * packets with reportID = 2. Such reports contain only 	 * limited information--they encode movement deltas and button 	 * events,--but do not include data from the pressure 	 * sensors. The device input mode can be switched from HID 	 * reports to raw sensor data using vendor-specific USB 	 * control commands; but first the mode must be read. 	 */
name|err
operator|=
name|atp_req_get_report
argument_list|(
name|sc
operator|->
name|sc_usb_device
argument_list|,
name|sc
operator|->
name|sc_mode_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"failed to read device mode (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|atp_set_device_mode
argument_list|(
name|dev
argument_list|,
name|RAW_SENSOR_MODE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"failed to set mode to 'RAW_SENSOR' (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|,
literal|"atpmtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|,
name|sc
operator|->
name|sc_xfer
argument_list|,
name|atp_config
argument_list|,
name|ATP_N_TRANSFER
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
if|if
condition|(
name|usb_fifo_attach
argument_list|(
name|sc
operator|->
name|sc_usb_device
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|,
operator|&
name|atp_fifo_methods
argument_list|,
operator|&
name|sc
operator|->
name|sc_fifo
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|0
operator|-
literal|1
argument_list|,
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0644
argument_list|)
condition|)
block|{
goto|goto
name|detach
goto|;
block|}
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_params
operator|=
operator|&
name|atp_dev_params
index|[
name|uaa
operator|->
name|driver_info
index|]
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|buttons
operator|=
literal|3
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|iftype
operator|=
name|MOUSE_IF_USB
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|type
operator|=
name|MOUSE_PAD
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|model
operator|=
name|MOUSE_MODEL_GENERIC
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|hwid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|accelfactor
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_left_margin
operator|=
name|atp_mickeys_scale_factor
expr_stmt|;
name|sc
operator|->
name|sc_right_margin
operator|=
operator|(
name|sc
operator|->
name|sc_params
operator|->
name|n_xsensors
operator|-
literal|1
operator|)
operator|*
name|atp_mickeys_scale_factor
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|detach
label|:
name|atp_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atp_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|&
name|ATP_ENABLED
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
name|atp_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
block|}
name|usb_fifo_detach
argument_list|(
operator|&
name|sc
operator|->
name|sc_fifo
argument_list|)
expr_stmt|;
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_xfer
argument_list|,
name|ATP_N_TRANSFER
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
name|err
operator|=
name|atp_set_device_mode
argument_list|(
name|dev
argument_list|,
name|HID_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"failed to reset mode to 'HID' (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_intr
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint8_t
name|status_bits
decl_stmt|;
name|atp_pspan
name|pspans_x
index|[
name|ATP_MAX_PSPANS_PER_AXIS
index|]
decl_stmt|;
name|atp_pspan
name|pspans_y
index|[
name|ATP_MAX_PSPANS_PER_AXIS
index|]
decl_stmt|;
name|u_int
name|n_xpspans
init|=
literal|0
decl_stmt|,
name|n_ypspans
init|=
literal|0
decl_stmt|;
name|u_int
name|reaped_xlocs
index|[
name|ATP_MAX_STROKES
index|]
decl_stmt|;
name|u_int
name|tap_fingers
init|=
literal|0
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
if|if
condition|(
name|len
operator|>
name|sc
operator|->
name|sc_params
operator|->
name|data_len
condition|)
block|{
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_ERROR
argument_list|,
literal|"truncating large packet from %u to %u bytes\n"
argument_list|,
name|len
argument_list|,
name|sc
operator|->
name|sc_params
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|len
operator|=
name|sc
operator|->
name|sc_params
operator|->
name|data_len
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|tr_setup
goto|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sensor_data
argument_list|,
name|sc
operator|->
name|sc_params
operator|->
name|data_len
argument_list|)
expr_stmt|;
comment|/* Interpret sensor data */
name|atp_interpret_sensor_data
argument_list|(
name|sc
operator|->
name|sensor_data
argument_list|,
name|sc
operator|->
name|sc_params
operator|->
name|n_xsensors
argument_list|,
literal|20
argument_list|,
name|sc
operator|->
name|cur_x
argument_list|)
expr_stmt|;
name|atp_interpret_sensor_data
argument_list|(
name|sc
operator|->
name|sensor_data
argument_list|,
name|sc
operator|->
name|sc_params
operator|->
name|n_ysensors
argument_list|,
literal|2
argument_list|,
name|sc
operator|->
name|cur_y
argument_list|)
expr_stmt|;
comment|/* 		 * If this is the initial update (from an untouched 		 * pad), we should set the base values for the sensor 		 * data; deltas with respect to these base values can 		 * be used as pressure readings subsequently. 		 */
name|status_bits
operator|=
name|sc
operator|->
name|sensor_data
index|[
name|sc
operator|->
name|sc_params
operator|->
name|data_len
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|status_bits
operator|&
name|ATP_STATUS_BASE_UPDATE
condition|)
block|{
name|memcpy
argument_list|(
name|sc
operator|->
name|base_x
argument_list|,
name|sc
operator|->
name|cur_x
argument_list|,
name|sc
operator|->
name|sc_params
operator|->
name|n_xsensors
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|sc
operator|->
name|base_x
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sc
operator|->
name|base_y
argument_list|,
name|sc
operator|->
name|cur_y
argument_list|,
name|sc
operator|->
name|sc_params
operator|->
name|n_ysensors
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|sc
operator|->
name|base_y
operator|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
comment|/* Get pressure readings and detect p-spans for both axes. */
name|atp_get_pressures
argument_list|(
name|sc
operator|->
name|pressure_x
argument_list|,
name|sc
operator|->
name|cur_x
argument_list|,
name|sc
operator|->
name|base_x
argument_list|,
name|sc
operator|->
name|sc_params
operator|->
name|n_xsensors
argument_list|)
expr_stmt|;
name|atp_detect_pspans
argument_list|(
name|sc
operator|->
name|pressure_x
argument_list|,
name|sc
operator|->
name|sc_params
operator|->
name|n_xsensors
argument_list|,
name|ATP_MAX_PSPANS_PER_AXIS
argument_list|,
name|pspans_x
argument_list|,
operator|&
name|n_xpspans
argument_list|)
expr_stmt|;
name|atp_get_pressures
argument_list|(
name|sc
operator|->
name|pressure_y
argument_list|,
name|sc
operator|->
name|cur_y
argument_list|,
name|sc
operator|->
name|base_y
argument_list|,
name|sc
operator|->
name|sc_params
operator|->
name|n_ysensors
argument_list|)
expr_stmt|;
name|atp_detect_pspans
argument_list|(
name|sc
operator|->
name|pressure_y
argument_list|,
name|sc
operator|->
name|sc_params
operator|->
name|n_ysensors
argument_list|,
name|ATP_MAX_PSPANS_PER_AXIS
argument_list|,
name|pspans_y
argument_list|,
operator|&
name|n_ypspans
argument_list|)
expr_stmt|;
comment|/* Update strokes with new pspans to detect movements. */
name|sc
operator|->
name|sc_status
operator|.
name|flags
operator|&=
operator|~
name|MOUSE_POSCHANGED
expr_stmt|;
if|if
condition|(
name|atp_update_strokes
argument_list|(
name|sc
argument_list|,
name|pspans_x
argument_list|,
name|n_xpspans
argument_list|,
name|pspans_y
argument_list|,
name|n_ypspans
argument_list|)
condition|)
name|sc
operator|->
name|sc_status
operator|.
name|flags
operator||=
name|MOUSE_POSCHANGED
expr_stmt|;
comment|/* Reap zombies if it is time. */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|&
name|ATP_ZOMBIES_EXIST
condition|)
block|{
name|struct
name|timeval
name|now
decl_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|sc
operator|->
name|sc_reap_time
argument_list|,
operator|>=
argument_list|)
condition|)
name|atp_reap_zombies
argument_list|(
name|sc
argument_list|,
operator|&
name|tap_fingers
argument_list|,
name|reaped_xlocs
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_status
operator|.
name|flags
operator|&=
operator|~
name|MOUSE_STDBUTTONSCHANGED
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|obutton
operator|=
name|sc
operator|->
name|sc_status
operator|.
name|button
expr_stmt|;
comment|/* Get the state of the physical buttton. */
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|=
operator|(
name|status_bits
operator|&
name|ATP_STATUS_BUTTON
operator|)
condition|?
name|MOUSE_BUTTON1DOWN
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|!=
literal|0
condition|)
block|{
comment|/* Reset DOUBLE_TAP_N_DRAG if the button is pressed. */
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|ATP_DOUBLE_TAP_DRAG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|&
name|ATP_DOUBLE_TAP_DRAG
condition|)
block|{
comment|/* Assume a button-press with DOUBLE_TAP_N_DRAG. */
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|=
name|MOUSE_BUTTON1DOWN
expr_stmt|;
block|}
name|sc
operator|->
name|sc_status
operator|.
name|flags
operator||=
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|^
name|sc
operator|->
name|sc_status
operator|.
name|obutton
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_status
operator|.
name|flags
operator|&
name|MOUSE_STDBUTTONSCHANGED
condition|)
block|{
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"button %s\n"
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|&
name|MOUSE_BUTTON1DOWN
operator|)
condition|?
literal|"pressed"
else|:
literal|"released"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_status
operator|.
name|obutton
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tap_fingers
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Ignore single-finger taps at the edges. */
if|if
condition|(
operator|(
name|tap_fingers
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|reaped_xlocs
index|[
literal|0
index|]
operator|<=
name|sc
operator|->
name|sc_left_margin
operator|)
operator|||
operator|(
name|reaped_xlocs
index|[
literal|0
index|]
operator|>
name|sc
operator|->
name|sc_right_margin
operator|)
operator|)
condition|)
block|{
name|tap_fingers
operator|=
literal|0
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"tap_fingers: %u\n"
argument_list|,
name|tap_fingers
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_status
operator|.
name|flags
operator|&
operator|(
name|MOUSE_POSCHANGED
operator||
name|MOUSE_STDBUTTONSCHANGED
operator|)
condition|)
block|{
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|u_int
name|n_movements
decl_stmt|;
name|dx
operator|=
literal|0
operator|,
name|dy
operator|=
literal|0
operator|,
name|n_movements
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_n_strokes
condition|;
name|i
operator|++
control|)
block|{
name|atp_stroke
modifier|*
name|stroke
init|=
operator|&
name|sc
operator|->
name|sc_strokes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|movement
operator|)
operator|||
operator|(
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|movement
operator|)
condition|)
block|{
name|dx
operator|+=
name|stroke
operator|->
name|components
index|[
name|X
index|]
operator|.
name|movement
expr_stmt|;
name|dy
operator|+=
name|stroke
operator|->
name|components
index|[
name|Y
index|]
operator|.
name|movement
expr_stmt|;
name|n_movements
operator|++
expr_stmt|;
block|}
block|}
comment|/* 			 * Disregard movement if multiple 			 * strokes record motion. 			 */
if|if
condition|(
name|n_movements
operator|!=
literal|1
condition|)
name|dx
operator|=
literal|0
operator|,
name|dy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|dx
operator|+=
name|dx
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|dy
operator|+=
name|dy
expr_stmt|;
name|atp_add_to_queue
argument_list|(
name|sc
argument_list|,
name|dx
argument_list|,
operator|-
name|dy
argument_list|,
name|sc
operator|->
name|sc_status
operator|.
name|button
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tap_fingers
operator|!=
literal|0
condition|)
block|{
comment|/* Add a pair of events (button-down and button-up). */
switch|switch
condition|(
name|tap_fingers
condition|)
block|{
case|case
literal|1
case|:
name|atp_add_to_queue
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MOUSE_BUTTON1DOWN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|atp_add_to_queue
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MOUSE_BUTTON2DOWN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|atp_add_to_queue
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MOUSE_BUTTON3DOWN
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
comment|/* handle taps of only up to 3 fingers */
block|}
name|atp_add_to_queue
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* button release */
block|}
comment|/* 		 * The device continues to trigger interrupts at a 		 * fast rate even after touchpad activity has 		 * stopped. Upon detecting that the device has 		 * remained idle beyond a threshold, we reinitialize 		 * it to silence the interrupts. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_status
operator|.
name|flags
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_n_strokes
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_idlecount
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_idlecount
operator|>=
name|ATP_IDLENESS_THRESHOLD
condition|)
block|{
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"idle\n"
argument_list|)
expr_stmt|;
name|atp_set_device_mode
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|RAW_SENSOR_MODE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_idlecount
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|sc_idlecount
operator|=
literal|0
expr_stmt|;
block|}
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
comment|/* check if we can put more data into the FIFO */
if|if
condition|(
name|usb_fifo_put_bytes_max
argument_list|(
name|sc
operator|->
name|sc_fifo
operator|.
name|fp
index|[
name|USB_FIFO_RX
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Error */
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* try clear stall first */
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
break|break;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_add_to_queue
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
name|uint32_t
name|buttons_in
parameter_list|)
block|{
name|uint32_t
name|buttons_out
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|dx
operator|=
name|imin
argument_list|(
name|dx
argument_list|,
literal|254
argument_list|)
expr_stmt|;
name|dx
operator|=
name|imax
argument_list|(
name|dx
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|dy
operator|=
name|imin
argument_list|(
name|dy
argument_list|,
literal|254
argument_list|)
expr_stmt|;
name|dy
operator|=
name|imax
argument_list|(
name|dy
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|buttons_out
operator|=
name|MOUSE_MSC_BUTTONS
expr_stmt|;
if|if
condition|(
name|buttons_in
operator|&
name|MOUSE_BUTTON1DOWN
condition|)
name|buttons_out
operator|&=
operator|~
name|MOUSE_MSC_BUTTON1UP
expr_stmt|;
elseif|else
if|if
condition|(
name|buttons_in
operator|&
name|MOUSE_BUTTON2DOWN
condition|)
name|buttons_out
operator|&=
operator|~
name|MOUSE_MSC_BUTTON2UP
expr_stmt|;
elseif|else
if|if
condition|(
name|buttons_in
operator|&
name|MOUSE_BUTTON3DOWN
condition|)
name|buttons_out
operator|&=
operator|~
name|MOUSE_MSC_BUTTON3UP
expr_stmt|;
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"dx=%d, dy=%d, buttons=%x\n"
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|buttons_out
argument_list|)
expr_stmt|;
comment|/* Encode the mouse data in standard format; refer to mouse(4) */
name|buf
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|1
index|]
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
name|buttons_out
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|dx
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|dy
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|dx
operator|-
operator|(
name|dx
operator|>>
literal|1
operator|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|dy
operator|-
operator|(
name|dy
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* Encode extra bytes for level 1 */
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|==
literal|1
condition|)
block|{
name|buf
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* dz */
name|buf
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
comment|/* dz - (dz / 2) */
name|buf
index|[
literal|7
index|]
operator|=
name|MOUSE_SYS_EXTBUTTONS
expr_stmt|;
comment|/* Extra buttons all up. */
block|}
name|usb_fifo_put_data_linear
argument_list|(
name|sc
operator|->
name|sc_fifo
operator|.
name|fp
index|[
name|USB_FIFO_RX
index|]
argument_list|,
name|buf
argument_list|,
name|sc
operator|->
name|sc_mode
operator|.
name|packetsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_reset_buf
parameter_list|(
name|struct
name|atp_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* reset read queue */
name|usb_fifo_reset
argument_list|(
name|sc
operator|->
name|sc_fifo
operator|.
name|fp
index|[
name|USB_FIFO_RX
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_start_read
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|int
name|rate
decl_stmt|;
comment|/* Check if we should override the default polling interval */
name|rate
operator|=
name|sc
operator|->
name|sc_pollrate
expr_stmt|;
comment|/* Range check rate */
if|if
condition|(
name|rate
operator|>
literal|1000
condition|)
name|rate
operator|=
literal|1000
expr_stmt|;
comment|/* Check for set rate */
if|if
condition|(
operator|(
name|rate
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_xfer
index|[
name|ATP_INTR_DT
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* Stop current transfer, if any */
name|usbd_transfer_stop
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|ATP_INTR_DT
index|]
argument_list|)
expr_stmt|;
comment|/* Set new interval */
name|usbd_xfer_set_interval
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|ATP_INTR_DT
index|]
argument_list|,
literal|1000
operator|/
name|rate
argument_list|)
expr_stmt|;
comment|/* Only set pollrate once */
name|sc
operator|->
name|sc_pollrate
operator|=
literal|0
expr_stmt|;
block|}
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|ATP_INTR_DT
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_stop_read
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|usbd_transfer_stop
argument_list|(
name|sc
operator|->
name|sc_xfer
index|[
name|ATP_INTR_DT
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|atp_open
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|&
name|ATP_ENABLED
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|usb_fifo_alloc_buffer
argument_list|(
name|fifo
argument_list|,
name|ATP_FIFO_BUF_SIZE
argument_list|,
name|ATP_FIFO_QUEUE_MAXLEN
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|rc
operator|=
name|atp_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|usb_fifo_free_buffer
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atp_close
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|atp_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|usb_fifo_free_buffer
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|atp_ioctl
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
name|struct
name|atp_softc
modifier|*
name|sc
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|mousemode_t
name|mode
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOUSE_GETHWINFO
case|:
operator|*
operator|(
name|mousehw_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|sc_hw
expr_stmt|;
break|break;
case|case
name|MOUSE_GETMODE
case|:
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|sc_mode
expr_stmt|;
break|break;
case|case
name|MOUSE_SETMODE
case|:
name|mode
operator|=
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|level
operator|==
operator|-
literal|1
condition|)
comment|/* Don't change the current setting */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mode
operator|.
name|level
operator|<
literal|0
operator|)
operator|||
operator|(
name|mode
operator|.
name|level
operator|>
literal|1
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|=
name|mode
operator|.
name|level
expr_stmt|;
name|sc
operator|->
name|sc_pollrate
operator|=
name|mode
operator|.
name|rate
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|buttons
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|packetsize
operator|=
name|MOUSE_SYS_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_SYS_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_SYS_SYNC
expr_stmt|;
block|}
name|atp_reset_buf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETLEVEL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|sc_mode
operator|.
name|level
expr_stmt|;
break|break;
case|case
name|MOUSE_SETLEVEL
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|<
literal|0
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|>
literal|1
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|buttons
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|.
name|level
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|packetsize
operator|=
name|MOUSE_SYS_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_SYS_SYNCMASK
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_SYS_SYNC
expr_stmt|;
block|}
name|atp_reset_buf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETSTATUS
case|:
block|{
name|mousestatus_t
modifier|*
name|status
init|=
operator|(
name|mousestatus_t
operator|*
operator|)
name|addr
decl_stmt|;
operator|*
name|status
operator|=
name|sc
operator|->
name|sc_status
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|obutton
operator|=
name|sc
operator|->
name|sc_status
operator|.
name|button
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|button
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|dx
operator|||
name|status
operator|->
name|dy
operator|||
name|status
operator|->
name|dz
condition|)
name|status
operator|->
name|flags
operator||=
name|MOUSE_POSCHANGED
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|button
operator|!=
name|status
operator|->
name|obutton
condition|)
name|status
operator|->
name|flags
operator||=
name|MOUSE_BUTTONSCHANGED
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
block|}
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atp_sysctl_scale_factor_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int
name|tmp
decl_stmt|;
name|u_int
name|prev_mickeys_scale_factor
decl_stmt|;
name|prev_mickeys_scale_factor
operator|=
name|atp_mickeys_scale_factor
expr_stmt|;
name|tmp
operator|=
name|atp_mickeys_scale_factor
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|tmp
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|tmp
operator|==
name|prev_mickeys_scale_factor
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no change */
name|atp_mickeys_scale_factor
operator|=
name|tmp
expr_stmt|;
name|DPRINTFN
argument_list|(
name|ATP_LLEVEL_INFO
argument_list|,
literal|"%s: resetting mickeys_scale_factor to %u\n"
argument_list|,
name|ATP_DRIVER_NAME
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Update dependent thresholds. */
if|if
condition|(
name|atp_small_movement_threshold
operator|==
operator|(
name|prev_mickeys_scale_factor
operator|>>
literal|3
operator|)
condition|)
name|atp_small_movement_threshold
operator|=
name|atp_mickeys_scale_factor
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
name|atp_max_delta_mickeys
operator|==
operator|(
operator|(
literal|3
operator|*
name|prev_mickeys_scale_factor
operator|)
operator|>>
literal|1
operator|)
condition|)
name|atp_max_delta_mickeys
operator|=
operator|(
operator|(
literal|3
operator|*
name|atp_mickeys_scale_factor
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|atp_slide_min_movement
operator|==
operator|(
name|prev_mickeys_scale_factor
operator|>>
literal|3
operator|)
condition|)
name|atp_slide_min_movement
operator|=
name|atp_mickeys_scale_factor
operator|>>
literal|3
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|atp_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|atp_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|atp_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|atp_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|atp_driver
init|=
block|{
name|ATP_DRIVER_NAME
block|,
name|atp_methods
block|,
expr|sizeof
operator|(
expr|struct
name|atp_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|atp_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|atp
argument_list|,
name|uhub
argument_list|,
name|atp_driver
argument_list|,
name|atp_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|atp
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

