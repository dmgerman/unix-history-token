begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2008 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Thanks to Mentor Graphics for providing a reference driver for this USB chip  * at their homepage.  */
end_comment

begin_comment
comment|/*  * This file contains the driver for the Mentor Graphics Inventra USB  * 2.0 High Speed Dual-Role controller.  *  * NOTE: The current implementation only supports Device Side Mode!  */
end_comment

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|musbotgdebug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_hub.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/musb_otg.h>
end_include

begin_define
define|#
directive|define
name|MUSBOTG_INTR_ENDPT
value|1
end_define

begin_define
define|#
directive|define
name|MUSBOTG_BUS2SC
parameter_list|(
name|bus
parameter_list|)
define|\
value|((struct musbotg_softc *)(((uint8_t *)(bus)) - \    USB_P2U(&(((struct musbotg_softc *)0)->sc_bus))))
end_define

begin_define
define|#
directive|define
name|MUSBOTG_PC2SC
parameter_list|(
name|pc
parameter_list|)
define|\
value|MUSBOTG_BUS2SC(USB_DMATAG_TO_XROOT((pc)->tag_parent)->bus)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|musbotgdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|musbotg
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB musbotg"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_musbotg
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|musbotgdebug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* prototypes */
end_comment

begin_decl_stmt
name|struct
name|usb_bus_methods
name|musbotg_bus_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|musbotg_device_bulk_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|musbotg_device_ctrl_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|musbotg_device_intr_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|musbotg_device_isoc_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|musbotg_cmd_t
name|musbotg_setup_rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|musbotg_cmd_t
name|musbotg_setup_data_rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|musbotg_cmd_t
name|musbotg_setup_data_tx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|musbotg_cmd_t
name|musbotg_setup_status
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|musbotg_cmd_t
name|musbotg_data_rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|musbotg_cmd_t
name|musbotg_data_tx
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|musbotg_device_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|,
name|usb_error_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|musbotg_do_poll
parameter_list|(
name|struct
name|usb_bus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|musbotg_standard_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|musbotg_interrupt_poll
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|musbotg_root_intr
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Here is a configuration that the chip supports.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_hw_ep_profile
name|musbotg_ep_profile
index|[
literal|1
index|]
init|=
block|{
index|[
literal|0
index|]
operator|=
block|{
operator|.
name|max_in_frame_size
operator|=
literal|64
block|,
comment|/* fixed */
operator|.
name|max_out_frame_size
operator|=
literal|64
block|,
comment|/* fixed */
operator|.
name|is_simplex
operator|=
literal|1
block|,
operator|.
name|support_control
operator|=
literal|1
block|, 	}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|musbotg_get_hw_ep_profile
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
specifier|const
name|struct
name|usb_hw_ep_profile
modifier|*
modifier|*
name|ppf
parameter_list|,
name|uint8_t
name|ep_addr
parameter_list|)
block|{
name|struct
name|musbotg_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|MUSBOTG_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep_addr
operator|==
literal|0
condition|)
block|{
comment|/* control endpoint */
operator|*
name|ppf
operator|=
name|musbotg_ep_profile
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ep_addr
operator|<=
name|sc
operator|->
name|sc_ep_max
condition|)
block|{
comment|/* other endpoints */
operator|*
name|ppf
operator|=
name|sc
operator|->
name|sc_hw_ep_profile
operator|+
name|ep_addr
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ppf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_clocks_on
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|clocks_off
operator|&&
name|sc
operator|->
name|sc_flags
operator|.
name|port_powered
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_clocks_on
condition|)
block|{
call|(
name|sc
operator|->
name|sc_clocks_on
call|)
argument_list|(
name|sc
operator|->
name|sc_clocks_arg
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator|.
name|clocks_off
operator|=
literal|0
expr_stmt|;
comment|/* XXX enable Transceiver */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_clocks_off
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_flags
operator|.
name|clocks_off
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* XXX disable Transceiver */
if|if
condition|(
name|sc
operator|->
name|sc_clocks_off
condition|)
block|{
call|(
name|sc
operator|->
name|sc_clocks_off
call|)
argument_list|(
name|sc
operator|->
name|sc_clocks_arg
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator|.
name|clocks_off
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_pull_common
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|on
parameter_list|)
block|{
name|uint8_t
name|temp
decl_stmt|;
name|temp
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_POWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|temp
operator||=
name|MUSB2_MASK_SOFTC
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
name|MUSB2_MASK_SOFTC
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_POWER
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_pull_up
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* pullup D+, if possible */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_flags
operator|.
name|d_pulled_up
operator|&&
name|sc
operator|->
name|sc_flags
operator|.
name|port_powered
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|.
name|d_pulled_up
operator|=
literal|1
expr_stmt|;
name|musbotg_pull_common
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_pull_down
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* pulldown D+, if possible */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|d_pulled_up
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|.
name|d_pulled_up
operator|=
literal|0
expr_stmt|;
name|musbotg_pull_common
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_wakeup_peer
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|temp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
operator|)
condition|)
block|{
return|return;
block|}
name|temp
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_POWER
argument_list|)
expr_stmt|;
name|temp
operator||=
name|MUSB2_MASK_RESUME
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_POWER
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* wait 8 milliseconds */
comment|/* Wait for reset to complete. */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|125
argument_list|)
expr_stmt|;
name|temp
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_POWER
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|MUSB2_MASK_RESUME
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_POWER
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_set_address
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|addr
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"addr=%d\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|&=
literal|0x7F
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_FADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|musbotg_setup_rx
parameter_list|(
name|struct
name|musbotg_td
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|musbotg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|uint16_t
name|count
decl_stmt|;
name|uint8_t
name|csr
decl_stmt|;
comment|/* get pointer to softc */
name|sc
operator|=
name|MUSBOTG_PC2SC
argument_list|(
name|td
operator|->
name|pc
argument_list|)
expr_stmt|;
comment|/* select endpoint 0 */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_EPINDEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* read out FIFO status */
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"csr=0x%02x\n"
argument_list|,
name|csr
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE: If DATAEND is set we should not call the 	 * callback, hence the status stage is not complete. 	 */
if|if
condition|(
name|csr
operator|&
name|MUSB2_MASK_CSR0L_DATAEND
condition|)
block|{
comment|/* do not stall at this point */
name|td
operator|->
name|did_stall
operator|=
literal|1
expr_stmt|;
comment|/* wait for interrupt */
goto|goto
name|not_complete
goto|;
block|}
if|if
condition|(
name|csr
operator|&
name|MUSB2_MASK_CSR0L_SENTSTALL
condition|)
block|{
comment|/* clear SENTSTALL */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get latest status */
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|)
expr_stmt|;
comment|/* update EP0 state */
name|sc
operator|->
name|sc_ep0_busy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|csr
operator|&
name|MUSB2_MASK_CSR0L_SETUPEND
condition|)
block|{
comment|/* clear SETUPEND */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
name|MUSB2_MASK_CSR0L_SETUPEND_CLR
argument_list|)
expr_stmt|;
comment|/* get latest status */
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|)
expr_stmt|;
comment|/* update EP0 state */
name|sc
operator|->
name|sc_ep0_busy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ep0_busy
condition|)
block|{
goto|goto
name|not_complete
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|csr
operator|&
name|MUSB2_MASK_CSR0L_RXPKTRDY
operator|)
condition|)
block|{
goto|goto
name|not_complete
goto|;
block|}
comment|/* clear did stall flag */
name|td
operator|->
name|did_stall
operator|=
literal|0
expr_stmt|;
comment|/* get the packet byte count */
name|count
operator|=
name|MUSB2_READ_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCOUNT
argument_list|)
expr_stmt|;
comment|/* verify data length */
if|if
condition|(
name|count
operator|!=
name|td
operator|->
name|remainder
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Invalid SETUP packet "
literal|"length, %d bytes\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
name|MUSB2_MASK_CSR0L_RXPKTRDY_CLR
argument_list|)
expr_stmt|;
goto|goto
name|not_complete
goto|;
block|}
if|if
condition|(
name|count
operator|!=
sizeof|sizeof
argument_list|(
name|req
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Unsupported SETUP packet "
literal|"length, %d bytes\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
name|MUSB2_MASK_CSR0L_RXPKTRDY_CLR
argument_list|)
expr_stmt|;
goto|goto
name|not_complete
goto|;
block|}
comment|/* receive data */
name|bus_space_read_multi_1
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy data into real buffer */
name|usbd_copy_in
argument_list|(
name|td
operator|->
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|offset
operator|=
sizeof|sizeof
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|td
operator|->
name|remainder
operator|=
literal|0
expr_stmt|;
comment|/* set pending command */
name|sc
operator|->
name|sc_ep0_cmd
operator|=
name|MUSB2_MASK_CSR0L_RXPKTRDY_CLR
expr_stmt|;
comment|/* we need set stall or dataend after this */
name|sc
operator|->
name|sc_ep0_busy
operator|=
literal|1
expr_stmt|;
comment|/* sneak peek the set address */
if|if
condition|(
operator|(
name|req
operator|.
name|bmRequestType
operator|==
name|UT_WRITE_DEVICE
operator|)
operator|&&
operator|(
name|req
operator|.
name|bRequest
operator|==
name|UR_SET_ADDRESS
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_dv_addr
operator|=
name|req
operator|.
name|wValue
index|[
literal|0
index|]
operator|&
literal|0x7F
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_dv_addr
operator|=
literal|0xFF
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
name|not_complete
label|:
comment|/* abort any ongoing transfer */
if|if
condition|(
operator|!
name|td
operator|->
name|did_stall
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"stalling\n"
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
name|MUSB2_MASK_CSR0L_SENDSTALL
argument_list|)
expr_stmt|;
name|td
operator|->
name|did_stall
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
block|}
end_function

begin_comment
comment|/* Control endpoint only data handling functions (RX/TX/SYNC) */
end_comment

begin_function
specifier|static
name|uint8_t
name|musbotg_setup_data_rx
parameter_list|(
name|struct
name|musbotg_td
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|struct
name|musbotg_softc
modifier|*
name|sc
decl_stmt|;
name|uint16_t
name|count
decl_stmt|;
name|uint8_t
name|csr
decl_stmt|;
name|uint8_t
name|got_short
decl_stmt|;
comment|/* get pointer to softc */
name|sc
operator|=
name|MUSBOTG_PC2SC
argument_list|(
name|td
operator|->
name|pc
argument_list|)
expr_stmt|;
comment|/* select endpoint 0 */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_EPINDEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* check if a command is pending */
if|if
condition|(
name|sc
operator|->
name|sc_ep0_cmd
condition|)
block|{
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
name|sc
operator|->
name|sc_ep0_cmd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ep0_cmd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* read out FIFO status */
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"csr=0x%02x\n"
argument_list|,
name|csr
argument_list|)
expr_stmt|;
name|got_short
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|csr
operator|&
operator|(
name|MUSB2_MASK_CSR0L_SETUPEND
operator||
name|MUSB2_MASK_CSR0L_SENTSTALL
operator|)
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|remainder
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We are actually complete and have 			 * received the next SETUP 			 */
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"faking complete\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
block|}
comment|/* 	         * USB Host Aborted the transfer. 	         */
name|td
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
block|}
if|if
condition|(
operator|!
operator|(
name|csr
operator|&
name|MUSB2_MASK_CSR0L_RXPKTRDY
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
block|}
comment|/* get the packet byte count */
name|count
operator|=
name|MUSB2_READ_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCOUNT
argument_list|)
expr_stmt|;
comment|/* verify the packet byte count */
if|if
condition|(
name|count
operator|!=
name|td
operator|->
name|max_frame_size
condition|)
block|{
if|if
condition|(
name|count
operator|<
name|td
operator|->
name|max_frame_size
condition|)
block|{
comment|/* we have a short packet */
name|td
operator|->
name|short_pkt
operator|=
literal|1
expr_stmt|;
name|got_short
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* invalid USB packet */
name|td
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* we are complete */
block|}
block|}
comment|/* verify the packet byte count */
if|if
condition|(
name|count
operator|>
name|td
operator|->
name|remainder
condition|)
block|{
comment|/* invalid USB packet */
name|td
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* we are complete */
block|}
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|temp
decl_stmt|;
name|usbd_get_page
argument_list|(
name|td
operator|->
name|pc
argument_list|,
name|td
operator|->
name|offset
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
comment|/* get correct length */
if|if
condition|(
name|buf_res
operator|.
name|length
operator|>
name|count
condition|)
block|{
name|buf_res
operator|.
name|length
operator|=
name|count
expr_stmt|;
block|}
comment|/* check for unaligned memory address */
if|if
condition|(
name|USB_P2U
argument_list|(
name|buf_res
operator|.
name|buffer
argument_list|)
operator|&
literal|3
condition|)
block|{
name|temp
operator|=
name|count
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
comment|/* receive data 4 bytes at a time */
name|bus_space_read_multi_4
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_bounce_buf
argument_list|,
name|temp
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|count
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
comment|/* receive data 1 byte at a time */
name|bus_space_read_multi_1
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|sc
operator|->
name|sc_bounce_buf
index|[
name|count
operator|/
literal|4
index|]
operator|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|usbd_copy_in
argument_list|(
name|td
operator|->
name|pc
argument_list|,
name|td
operator|->
name|offset
argument_list|,
name|sc
operator|->
name|sc_bounce_buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* update offset and remainder */
name|td
operator|->
name|offset
operator|+=
name|count
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|count
expr_stmt|;
break|break;
block|}
comment|/* check if we can optimise */
if|if
condition|(
name|buf_res
operator|.
name|length
operator|>=
literal|4
condition|)
block|{
comment|/* receive data 4 bytes at a time */
name|bus_space_read_multi_4
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
literal|0
argument_list|)
argument_list|,
name|buf_res
operator|.
name|buffer
argument_list|,
name|buf_res
operator|.
name|length
operator|/
literal|4
argument_list|)
expr_stmt|;
name|temp
operator|=
name|buf_res
operator|.
name|length
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* update counters */
name|count
operator|-=
name|temp
expr_stmt|;
name|td
operator|->
name|offset
operator|+=
name|temp
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|temp
expr_stmt|;
continue|continue;
block|}
comment|/* receive data */
name|bus_space_read_multi_1
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
literal|0
argument_list|)
argument_list|,
name|buf_res
operator|.
name|buffer
argument_list|,
name|buf_res
operator|.
name|length
argument_list|)
expr_stmt|;
comment|/* update counters */
name|count
operator|-=
name|buf_res
operator|.
name|length
expr_stmt|;
name|td
operator|->
name|offset
operator|+=
name|buf_res
operator|.
name|length
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|buf_res
operator|.
name|length
expr_stmt|;
block|}
comment|/* check if we are complete */
if|if
condition|(
operator|(
name|td
operator|->
name|remainder
operator|==
literal|0
operator|)
operator|||
name|got_short
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|short_pkt
condition|)
block|{
comment|/* we are complete */
name|sc
operator|->
name|sc_ep0_cmd
operator|=
name|MUSB2_MASK_CSR0L_RXPKTRDY_CLR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* else need to receive a zero length packet */
block|}
comment|/* write command - need more data */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
name|MUSB2_MASK_CSR0L_RXPKTRDY_CLR
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|musbotg_setup_data_tx
parameter_list|(
name|struct
name|musbotg_td
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|struct
name|musbotg_softc
modifier|*
name|sc
decl_stmt|;
name|uint16_t
name|count
decl_stmt|;
name|uint8_t
name|csr
decl_stmt|;
comment|/* get pointer to softc */
name|sc
operator|=
name|MUSBOTG_PC2SC
argument_list|(
name|td
operator|->
name|pc
argument_list|)
expr_stmt|;
comment|/* select endpoint 0 */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_EPINDEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* check if a command is pending */
if|if
condition|(
name|sc
operator|->
name|sc_ep0_cmd
condition|)
block|{
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
name|sc
operator|->
name|sc_ep0_cmd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ep0_cmd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* read out FIFO status */
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"csr=0x%02x\n"
argument_list|,
name|csr
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
operator|(
name|MUSB2_MASK_CSR0L_SETUPEND
operator||
name|MUSB2_MASK_CSR0L_SENTSTALL
operator|)
condition|)
block|{
comment|/* 	         * The current transfer was aborted 	         * by the USB Host 	         */
name|td
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
block|}
if|if
condition|(
name|csr
operator|&
name|MUSB2_MASK_CSR0L_TXPKTRDY
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
block|}
name|count
operator|=
name|td
operator|->
name|max_frame_size
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|remainder
operator|<
name|count
condition|)
block|{
comment|/* we have a short packet */
name|td
operator|->
name|short_pkt
operator|=
literal|1
expr_stmt|;
name|count
operator|=
name|td
operator|->
name|remainder
expr_stmt|;
block|}
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|temp
decl_stmt|;
name|usbd_get_page
argument_list|(
name|td
operator|->
name|pc
argument_list|,
name|td
operator|->
name|offset
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
comment|/* get correct length */
if|if
condition|(
name|buf_res
operator|.
name|length
operator|>
name|count
condition|)
block|{
name|buf_res
operator|.
name|length
operator|=
name|count
expr_stmt|;
block|}
comment|/* check for unaligned memory address */
if|if
condition|(
name|USB_P2U
argument_list|(
name|buf_res
operator|.
name|buffer
argument_list|)
operator|&
literal|3
condition|)
block|{
name|usbd_copy_out
argument_list|(
name|td
operator|->
name|pc
argument_list|,
name|td
operator|->
name|offset
argument_list|,
name|sc
operator|->
name|sc_bounce_buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|temp
operator|=
name|count
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
comment|/* transmit data 4 bytes at a time */
name|bus_space_write_multi_4
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_bounce_buf
argument_list|,
name|temp
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|count
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
comment|/* receive data 1 byte at a time */
name|bus_space_write_multi_1
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_bounce_buf
index|[
name|count
operator|/
literal|4
index|]
operator|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* update offset and remainder */
name|td
operator|->
name|offset
operator|+=
name|count
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|count
expr_stmt|;
break|break;
block|}
comment|/* check if we can optimise */
if|if
condition|(
name|buf_res
operator|.
name|length
operator|>=
literal|4
condition|)
block|{
comment|/* transmit data 4 bytes at a time */
name|bus_space_write_multi_4
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
literal|0
argument_list|)
argument_list|,
name|buf_res
operator|.
name|buffer
argument_list|,
name|buf_res
operator|.
name|length
operator|/
literal|4
argument_list|)
expr_stmt|;
name|temp
operator|=
name|buf_res
operator|.
name|length
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* update counters */
name|count
operator|-=
name|temp
expr_stmt|;
name|td
operator|->
name|offset
operator|+=
name|temp
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|temp
expr_stmt|;
continue|continue;
block|}
comment|/* transmit data */
name|bus_space_write_multi_1
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
literal|0
argument_list|)
argument_list|,
name|buf_res
operator|.
name|buffer
argument_list|,
name|buf_res
operator|.
name|length
argument_list|)
expr_stmt|;
comment|/* update counters */
name|count
operator|-=
name|buf_res
operator|.
name|length
expr_stmt|;
name|td
operator|->
name|offset
operator|+=
name|buf_res
operator|.
name|length
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|buf_res
operator|.
name|length
expr_stmt|;
block|}
comment|/* check remainder */
if|if
condition|(
name|td
operator|->
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|short_pkt
condition|)
block|{
name|sc
operator|->
name|sc_ep0_cmd
operator|=
name|MUSB2_MASK_CSR0L_TXPKTRDY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
block|}
comment|/* else we need to transmit a short packet */
block|}
comment|/* write command */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
name|MUSB2_MASK_CSR0L_TXPKTRDY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|musbotg_setup_status
parameter_list|(
name|struct
name|musbotg_td
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|musbotg_softc
modifier|*
name|sc
decl_stmt|;
name|uint8_t
name|csr
decl_stmt|;
comment|/* get pointer to softc */
name|sc
operator|=
name|MUSBOTG_PC2SC
argument_list|(
name|td
operator|->
name|pc
argument_list|)
expr_stmt|;
comment|/* select endpoint 0 */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_EPINDEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ep0_busy
condition|)
block|{
name|sc
operator|->
name|sc_ep0_busy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ep0_cmd
operator||=
name|MUSB2_MASK_CSR0L_DATAEND
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
name|sc
operator|->
name|sc_ep0_cmd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ep0_cmd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* read out FIFO status */
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"csr=0x%02x\n"
argument_list|,
name|csr
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|MUSB2_MASK_CSR0L_DATAEND
condition|)
block|{
comment|/* wait for interrupt */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
block|}
if|if
condition|(
name|sc
operator|->
name|sc_dv_addr
operator|!=
literal|0xFF
condition|)
block|{
comment|/* write function address */
name|musbotg_set_address
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_dv_addr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|musbotg_data_rx
parameter_list|(
name|struct
name|musbotg_td
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|struct
name|musbotg_softc
modifier|*
name|sc
decl_stmt|;
name|uint16_t
name|count
decl_stmt|;
name|uint8_t
name|csr
decl_stmt|;
name|uint8_t
name|to
decl_stmt|;
name|uint8_t
name|got_short
decl_stmt|;
name|to
operator|=
literal|8
expr_stmt|;
comment|/* don't loop forever! */
name|got_short
operator|=
literal|0
expr_stmt|;
comment|/* get pointer to softc */
name|sc
operator|=
name|MUSBOTG_PC2SC
argument_list|(
name|td
operator|->
name|pc
argument_list|)
expr_stmt|;
comment|/* select endpoint */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_EPINDEX
argument_list|,
name|td
operator|->
name|ep_no
argument_list|)
expr_stmt|;
name|repeat
label|:
comment|/* read out FIFO status */
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRL
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"csr=0x%02x\n"
argument_list|,
name|csr
argument_list|)
expr_stmt|;
comment|/* clear overrun */
if|if
condition|(
name|csr
operator|&
name|MUSB2_MASK_CSRL_RXOVERRUN
condition|)
block|{
comment|/* make sure we don't clear "RXPKTRDY" */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRL
argument_list|,
name|MUSB2_MASK_CSRL_RXPKTRDY
argument_list|)
expr_stmt|;
block|}
comment|/* check status */
if|if
condition|(
operator|!
operator|(
name|csr
operator|&
name|MUSB2_MASK_CSRL_RXPKTRDY
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
block|}
comment|/* get the packet byte count */
name|count
operator|=
name|MUSB2_READ_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCOUNT
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"count=0x%04x\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * Check for short or invalid packet: 	 */
if|if
condition|(
name|count
operator|!=
name|td
operator|->
name|max_frame_size
condition|)
block|{
if|if
condition|(
name|count
operator|<
name|td
operator|->
name|max_frame_size
condition|)
block|{
comment|/* we have a short packet */
name|td
operator|->
name|short_pkt
operator|=
literal|1
expr_stmt|;
name|got_short
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* invalid USB packet */
name|td
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* we are complete */
block|}
block|}
comment|/* verify the packet byte count */
if|if
condition|(
name|count
operator|>
name|td
operator|->
name|remainder
condition|)
block|{
comment|/* invalid USB packet */
name|td
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* we are complete */
block|}
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|temp
decl_stmt|;
name|usbd_get_page
argument_list|(
name|td
operator|->
name|pc
argument_list|,
name|td
operator|->
name|offset
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
comment|/* get correct length */
if|if
condition|(
name|buf_res
operator|.
name|length
operator|>
name|count
condition|)
block|{
name|buf_res
operator|.
name|length
operator|=
name|count
expr_stmt|;
block|}
comment|/* check for unaligned memory address */
if|if
condition|(
name|USB_P2U
argument_list|(
name|buf_res
operator|.
name|buffer
argument_list|)
operator|&
literal|3
condition|)
block|{
name|temp
operator|=
name|count
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
comment|/* receive data 4 bytes at a time */
name|bus_space_read_multi_4
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_bounce_buf
argument_list|,
name|temp
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|count
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
comment|/* receive data 1 byte at a time */
name|bus_space_read_multi_1
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|,
operator|(
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_bounce_buf
index|[
name|count
operator|/
literal|4
index|]
operator|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|usbd_copy_in
argument_list|(
name|td
operator|->
name|pc
argument_list|,
name|td
operator|->
name|offset
argument_list|,
name|sc
operator|->
name|sc_bounce_buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* update offset and remainder */
name|td
operator|->
name|offset
operator|+=
name|count
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|count
expr_stmt|;
break|break;
block|}
comment|/* check if we can optimise */
if|if
condition|(
name|buf_res
operator|.
name|length
operator|>=
literal|4
condition|)
block|{
comment|/* receive data 4 bytes at a time */
name|bus_space_read_multi_4
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|,
name|buf_res
operator|.
name|buffer
argument_list|,
name|buf_res
operator|.
name|length
operator|/
literal|4
argument_list|)
expr_stmt|;
name|temp
operator|=
name|buf_res
operator|.
name|length
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* update counters */
name|count
operator|-=
name|temp
expr_stmt|;
name|td
operator|->
name|offset
operator|+=
name|temp
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|temp
expr_stmt|;
continue|continue;
block|}
comment|/* receive data */
name|bus_space_read_multi_1
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|,
name|buf_res
operator|.
name|buffer
argument_list|,
name|buf_res
operator|.
name|length
argument_list|)
expr_stmt|;
comment|/* update counters */
name|count
operator|-=
name|buf_res
operator|.
name|length
expr_stmt|;
name|td
operator|->
name|offset
operator|+=
name|buf_res
operator|.
name|length
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|buf_res
operator|.
name|length
expr_stmt|;
block|}
comment|/* clear status bits */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* check if we are complete */
if|if
condition|(
operator|(
name|td
operator|->
name|remainder
operator|==
literal|0
operator|)
operator|||
name|got_short
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|short_pkt
condition|)
block|{
comment|/* we are complete */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* else need to receive a zero length packet */
block|}
if|if
condition|(
operator|--
name|to
condition|)
block|{
goto|goto
name|repeat
goto|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|musbotg_data_tx
parameter_list|(
name|struct
name|musbotg_td
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|struct
name|musbotg_softc
modifier|*
name|sc
decl_stmt|;
name|uint16_t
name|count
decl_stmt|;
name|uint8_t
name|csr
decl_stmt|;
name|uint8_t
name|to
decl_stmt|;
name|to
operator|=
literal|8
expr_stmt|;
comment|/* don't loop forever! */
comment|/* get pointer to softc */
name|sc
operator|=
name|MUSBOTG_PC2SC
argument_list|(
name|td
operator|->
name|pc
argument_list|)
expr_stmt|;
comment|/* select endpoint */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_EPINDEX
argument_list|,
name|td
operator|->
name|ep_no
argument_list|)
expr_stmt|;
name|repeat
label|:
comment|/* read out FIFO status */
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"csr=0x%02x\n"
argument_list|,
name|csr
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
operator|(
name|MUSB2_MASK_CSRL_TXINCOMP
operator||
name|MUSB2_MASK_CSRL_TXUNDERRUN
operator|)
condition|)
block|{
comment|/* clear status bits */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csr
operator|&
name|MUSB2_MASK_CSRL_TXPKTRDY
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
block|}
comment|/* check for short packet */
name|count
operator|=
name|td
operator|->
name|max_frame_size
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|remainder
operator|<
name|count
condition|)
block|{
comment|/* we have a short packet */
name|td
operator|->
name|short_pkt
operator|=
literal|1
expr_stmt|;
name|count
operator|=
name|td
operator|->
name|remainder
expr_stmt|;
block|}
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|temp
decl_stmt|;
name|usbd_get_page
argument_list|(
name|td
operator|->
name|pc
argument_list|,
name|td
operator|->
name|offset
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
comment|/* get correct length */
if|if
condition|(
name|buf_res
operator|.
name|length
operator|>
name|count
condition|)
block|{
name|buf_res
operator|.
name|length
operator|=
name|count
expr_stmt|;
block|}
comment|/* check for unaligned memory address */
if|if
condition|(
name|USB_P2U
argument_list|(
name|buf_res
operator|.
name|buffer
argument_list|)
operator|&
literal|3
condition|)
block|{
name|usbd_copy_out
argument_list|(
name|td
operator|->
name|pc
argument_list|,
name|td
operator|->
name|offset
argument_list|,
name|sc
operator|->
name|sc_bounce_buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|temp
operator|=
name|count
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
comment|/* transmit data 4 bytes at a time */
name|bus_space_write_multi_4
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_bounce_buf
argument_list|,
name|temp
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|count
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
comment|/* receive data 1 byte at a time */
name|bus_space_write_multi_1
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|,
operator|(
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_bounce_buf
index|[
name|count
operator|/
literal|4
index|]
operator|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* update offset and remainder */
name|td
operator|->
name|offset
operator|+=
name|count
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|count
expr_stmt|;
break|break;
block|}
comment|/* check if we can optimise */
if|if
condition|(
name|buf_res
operator|.
name|length
operator|>=
literal|4
condition|)
block|{
comment|/* transmit data 4 bytes at a time */
name|bus_space_write_multi_4
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|,
name|buf_res
operator|.
name|buffer
argument_list|,
name|buf_res
operator|.
name|length
operator|/
literal|4
argument_list|)
expr_stmt|;
name|temp
operator|=
name|buf_res
operator|.
name|length
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* update counters */
name|count
operator|-=
name|temp
expr_stmt|;
name|td
operator|->
name|offset
operator|+=
name|temp
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|temp
expr_stmt|;
continue|continue;
block|}
comment|/* transmit data */
name|bus_space_write_multi_1
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|MUSB2_REG_EPFIFO
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|,
name|buf_res
operator|.
name|buffer
argument_list|,
name|buf_res
operator|.
name|length
argument_list|)
expr_stmt|;
comment|/* update counters */
name|count
operator|-=
name|buf_res
operator|.
name|length
expr_stmt|;
name|td
operator|->
name|offset
operator|+=
name|buf_res
operator|.
name|length
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|buf_res
operator|.
name|length
expr_stmt|;
block|}
comment|/* write command */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
name|MUSB2_MASK_CSRL_TXPKTRDY
argument_list|)
expr_stmt|;
comment|/* check remainder */
if|if
condition|(
name|td
operator|->
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|short_pkt
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
block|}
comment|/* else we need to transmit a short packet */
block|}
if|if
condition|(
operator|--
name|to
condition|)
block|{
goto|goto
name|repeat
goto|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|musbotg_xfer_do_fifo
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|musbotg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|musbotg_td
modifier|*
name|td
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
call|(
name|td
operator|->
name|func
call|)
argument_list|(
name|td
argument_list|)
condition|)
block|{
comment|/* operation in progress */
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|void
operator|*
operator|)
name|td
operator|)
operator|==
name|xfer
operator|->
name|td_transfer_last
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|td
operator|->
name|error
condition|)
block|{
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|remainder
operator|>
literal|0
condition|)
block|{
comment|/* 			 * We had a short transfer. If there is no alternate 			 * next, stop processing ! 			 */
if|if
condition|(
operator|!
name|td
operator|->
name|alt_next
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 		 * Fetch the next transfer descriptor and transfer 		 * some flags to the next transfer descriptor 		 */
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
name|done
label|:
name|sc
operator|=
name|MUSBOTG_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* compute all actual lengths */
name|musbotg_standard_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_interrupt_poll
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|repeat
label|:
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
if|if
condition|(
operator|!
name|musbotg_xfer_do_fifo
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
comment|/* queue has been modified */
goto|goto
name|repeat
goto|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|musbotg_vbus_interrupt
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|is_on
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"vbus = %u\n"
argument_list|,
name|is_on
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_on
condition|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
operator|=
literal|1
expr_stmt|;
comment|/* complete root HUB interrupt endpoint */
name|musbotg_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_bus_reset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_connect
operator|=
literal|1
expr_stmt|;
comment|/* complete root HUB interrupt endpoint */
name|musbotg_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|musbotg_interrupt
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|rx_status
decl_stmt|;
name|uint16_t
name|tx_status
decl_stmt|;
name|uint8_t
name|usb_status
decl_stmt|;
name|uint8_t
name|temp
decl_stmt|;
name|uint8_t
name|to
init|=
literal|2
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|repeat
label|:
comment|/* read all interrupt registers */
name|usb_status
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTUSB
argument_list|)
expr_stmt|;
comment|/* read all FIFO interrupts */
name|rx_status
operator|=
name|MUSB2_READ_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTRX
argument_list|)
expr_stmt|;
name|tx_status
operator|=
name|MUSB2_READ_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTTX
argument_list|)
expr_stmt|;
comment|/* check for any bus state change interrupts */
if|if
condition|(
name|usb_status
operator|&
operator|(
name|MUSB2_MASK_IRESET
operator||
name|MUSB2_MASK_IRESUME
operator||
name|MUSB2_MASK_ISUSP
operator|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"real bus interrupt 0x%08x\n"
argument_list|,
name|usb_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb_status
operator|&
name|MUSB2_MASK_IRESET
condition|)
block|{
comment|/* set correct state */
name|sc
operator|->
name|sc_flags
operator|.
name|status_bus_reset
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_connect
operator|=
literal|1
expr_stmt|;
comment|/* determine line speed */
name|temp
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_POWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|MUSB2_MASK_HSMODE
condition|)
name|sc
operator|->
name|sc_flags
operator|.
name|status_high_speed
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator|.
name|status_high_speed
operator|=
literal|0
expr_stmt|;
comment|/* 			 * After reset all interrupts are on and we need to 			 * turn them off! 			 */
name|temp
operator|=
name|MUSB2_MASK_IRESET
expr_stmt|;
comment|/* disable resume interrupt */
name|temp
operator|&=
operator|~
name|MUSB2_MASK_IRESUME
expr_stmt|;
comment|/* enable suspend interrupt */
name|temp
operator||=
name|MUSB2_MASK_ISUSP
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTUSBE
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* disable TX and RX interrupts */
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTTXE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTRXE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	         * If RXRSM and RXSUSP is set at the same time we interpret 	         * that like RESUME. Resume is set when there is at least 3 	         * milliseconds of inactivity on the USB BUS. 	         */
if|if
condition|(
name|usb_status
operator|&
name|MUSB2_MASK_IRESUME
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTUSBE
argument_list|)
expr_stmt|;
comment|/* disable resume interrupt */
name|temp
operator|&=
operator|~
name|MUSB2_MASK_IRESUME
expr_stmt|;
comment|/* enable suspend interrupt */
name|temp
operator||=
name|MUSB2_MASK_ISUSP
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTUSBE
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|usb_status
operator|&
name|MUSB2_MASK_ISUSP
condition|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTUSBE
argument_list|)
expr_stmt|;
comment|/* disable suspend interrupt */
name|temp
operator|&=
operator|~
name|MUSB2_MASK_ISUSP
expr_stmt|;
comment|/* enable resume interrupt */
name|temp
operator||=
name|MUSB2_MASK_IRESUME
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTUSBE
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* complete root HUB interrupt endpoint */
name|musbotg_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* check for any endpoint interrupts */
if|if
condition|(
name|rx_status
operator|||
name|tx_status
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"real endpoint interrupt "
literal|"rx=0x%04x, tx=0x%04x\n"
argument_list|,
name|rx_status
argument_list|,
name|tx_status
argument_list|)
expr_stmt|;
block|}
comment|/* poll one time regardless of FIFO status */
name|musbotg_interrupt_poll
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|to
condition|)
goto|goto
name|repeat
goto|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_setup_standard_chain_sub
parameter_list|(
name|struct
name|musbotg_std_temp
modifier|*
name|temp
parameter_list|)
block|{
name|struct
name|musbotg_td
modifier|*
name|td
decl_stmt|;
comment|/* get current Transfer Descriptor */
name|td
operator|=
name|temp
operator|->
name|td_next
expr_stmt|;
name|temp
operator|->
name|td
operator|=
name|td
expr_stmt|;
comment|/* prepare for next TD */
name|temp
operator|->
name|td_next
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
comment|/* fill out the Transfer Descriptor */
name|td
operator|->
name|func
operator|=
name|temp
operator|->
name|func
expr_stmt|;
name|td
operator|->
name|pc
operator|=
name|temp
operator|->
name|pc
expr_stmt|;
name|td
operator|->
name|offset
operator|=
name|temp
operator|->
name|offset
expr_stmt|;
name|td
operator|->
name|remainder
operator|=
name|temp
operator|->
name|len
expr_stmt|;
name|td
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|did_stall
operator|=
name|temp
operator|->
name|did_stall
expr_stmt|;
name|td
operator|->
name|short_pkt
operator|=
name|temp
operator|->
name|short_pkt
expr_stmt|;
name|td
operator|->
name|alt_next
operator|=
name|temp
operator|->
name|setup_alt_next
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_setup_standard_chain
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|musbotg_std_temp
name|temp
decl_stmt|;
name|struct
name|musbotg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|musbotg_td
modifier|*
name|td
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|uint8_t
name|ep_no
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
literal|"addr=%d endpt=%d sumlen=%d speed=%d\n"
argument_list|,
name|xfer
operator|->
name|address
argument_list|,
name|UE_GET_ADDR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
argument_list|,
name|xfer
operator|->
name|sumlen
argument_list|,
name|usbd_get_speed
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|max_frame_size
operator|=
name|xfer
operator|->
name|max_frame_size
expr_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_start
index|[
literal|0
index|]
expr_stmt|;
name|xfer
operator|->
name|td_transfer_first
operator|=
name|td
expr_stmt|;
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
comment|/* setup temp */
name|temp
operator|.
name|pc
operator|=
name|NULL
expr_stmt|;
name|temp
operator|.
name|td
operator|=
name|NULL
expr_stmt|;
name|temp
operator|.
name|td_next
operator|=
name|xfer
operator|->
name|td_start
index|[
literal|0
index|]
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
expr_stmt|;
name|temp
operator|.
name|did_stall
operator|=
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_stall
expr_stmt|;
name|sc
operator|=
name|MUSBOTG_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
name|ep_no
operator|=
operator|(
name|xfer
operator|->
name|endpointno
operator|&
name|UE_ADDR
operator|)
expr_stmt|;
comment|/* check if we should prepend a setup message */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
condition|)
block|{
name|temp
operator|.
name|func
operator|=
operator|&
name|musbotg_setup_rx
expr_stmt|;
name|temp
operator|.
name|len
operator|=
name|xfer
operator|->
name|frlengths
index|[
literal|0
index|]
expr_stmt|;
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
literal|0
expr_stmt|;
name|temp
operator|.
name|short_pkt
operator|=
name|temp
operator|.
name|len
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|musbotg_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|endpointno
operator|&
name|UE_DIR_IN
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
name|temp
operator|.
name|func
operator|=
operator|&
name|musbotg_setup_data_tx
expr_stmt|;
else|else
name|temp
operator|.
name|func
operator|=
operator|&
name|musbotg_data_tx
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
name|temp
operator|.
name|func
operator|=
operator|&
name|musbotg_setup_data_rx
expr_stmt|;
else|else
name|temp
operator|.
name|func
operator|=
operator|&
name|musbotg_data_rx
expr_stmt|;
block|}
comment|/* setup "pc" pointer */
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
name|x
expr_stmt|;
block|}
while|while
condition|(
name|x
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
comment|/* DATA0 / DATA1 message */
name|temp
operator|.
name|len
operator|=
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
expr_stmt|;
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|xfer
operator|->
name|nframes
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|temp
operator|.
name|len
operator|==
literal|0
condition|)
block|{
comment|/* make sure that we send an USB packet */
name|temp
operator|.
name|short_pkt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* regular data transfer */
name|temp
operator|.
name|short_pkt
operator|=
operator|(
name|xfer
operator|->
name|flags
operator|.
name|force_short_xfer
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
name|musbotg_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
name|temp
operator|.
name|offset
operator|+=
name|temp
operator|.
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* get next Page Cache pointer */
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
name|x
expr_stmt|;
block|}
block|}
comment|/* check for control transfer */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
comment|/* always setup a valid "pc" pointer for status and sync */
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
literal|0
expr_stmt|;
name|temp
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|short_pkt
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
comment|/* check if we should append a status stage */
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
comment|/* 			 * Send a DATA1 message and invert the current 			 * endpoint direction. 			 */
name|temp
operator|.
name|func
operator|=
operator|&
name|musbotg_setup_status
expr_stmt|;
name|musbotg_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* must have at least one frame! */
name|td
operator|=
name|temp
operator|.
name|td
expr_stmt|;
name|xfer
operator|->
name|td_transfer_last
operator|=
name|td
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
init|=
name|arg
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
literal|"xfer=%p\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* transfer is transferred */
name|musbotg_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_TIMEOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_ep_int_set
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|uint8_t
name|on
parameter_list|)
block|{
name|struct
name|musbotg_softc
modifier|*
name|sc
init|=
name|MUSBOTG_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
name|uint8_t
name|ep_no
init|=
name|xfer
operator|->
name|endpointno
operator|&
name|UE_ADDR
decl_stmt|;
comment|/* 	 * Only enable the endpoint interrupt when we are 	 * actually waiting for data, hence we are dealing 	 * with level triggered interrupts ! 	 */
if|if
condition|(
name|ep_no
operator|==
literal|0
condition|)
block|{
name|temp
operator|=
name|MUSB2_READ_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTTXE
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|temp
operator||=
name|MUSB2_MASK_EPINT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
name|MUSB2_MASK_EPINT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTTXE
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|USB_GET_DATA_ISREAD
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
name|temp
operator|=
name|MUSB2_READ_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTRXE
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|temp
operator||=
name|MUSB2_MASK_EPINT
argument_list|(
name|ep_no
argument_list|)
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
name|MUSB2_MASK_EPINT
argument_list|(
name|ep_no
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTRXE
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|MUSB2_READ_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTTXE
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|temp
operator||=
name|MUSB2_MASK_EPINT
argument_list|(
name|ep_no
argument_list|)
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
name|MUSB2_MASK_EPINT
argument_list|(
name|ep_no
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTTXE
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_start_standard_chain
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* poll one time */
if|if
condition|(
name|musbotg_xfer_do_fifo
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
name|musbotg_ep_int_set
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|14
argument_list|,
literal|"enabled interrupts on endpoint\n"
argument_list|)
expr_stmt|;
comment|/* put transfer on interrupt queue */
name|usbd_transfer_enqueue
argument_list|(
operator|&
name|xfer
operator|->
name|xroot
operator|->
name|bus
operator|->
name|intr_q
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
comment|/* start timeout, if any */
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|!=
literal|0
condition|)
block|{
name|usbd_transfer_timeout_ms
argument_list|(
name|xfer
argument_list|,
operator|&
name|musbotg_timeout
argument_list|,
name|xfer
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_root_intr
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* set port bit */
name|sc
operator|->
name|sc_hub_idata
index|[
literal|0
index|]
operator|=
literal|0x02
expr_stmt|;
comment|/* we only have one port */
name|uhub_root_intr
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|sc
operator|->
name|sc_hub_idata
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|musbotg_standard_done_sub
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|musbotg_td
modifier|*
name|td
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint8_t
name|error
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
do|do
block|{
name|len
operator|=
name|td
operator|->
name|remainder
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
comment|/* 		         * Verify the length and subtract 		         * the remainder from "frlengths[]": 		         */
if|if
condition|(
name|len
operator|>
name|xfer
operator|->
name|frlengths
index|[
name|xfer
operator|->
name|aframes
index|]
condition|)
block|{
name|td
operator|->
name|error
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|xfer
operator|->
name|frlengths
index|[
name|xfer
operator|->
name|aframes
index|]
operator|-=
name|len
expr_stmt|;
block|}
block|}
comment|/* Check for transfer error */
if|if
condition|(
name|td
operator|->
name|error
condition|)
block|{
comment|/* the transfer is finished */
name|error
operator|=
literal|1
expr_stmt|;
name|td
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Check for short transfer */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
condition|)
block|{
comment|/* follow alt next */
if|if
condition|(
name|td
operator|->
name|alt_next
condition|)
block|{
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
block|}
else|else
block|{
name|td
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* the transfer is finished */
name|td
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
comment|/* this USB frame is complete */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/* update transfer cache */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
return|return
operator|(
name|error
condition|?
name|USB_ERR_STALLED
else|:
name|USB_ERR_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_standard_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|usb_error_t
name|err
init|=
literal|0
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|12
argument_list|,
literal|"xfer=%p endpoint=%p transfer done\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|)
expr_stmt|;
comment|/* reset scanner */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|xfer
operator|->
name|td_transfer_first
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
condition|)
block|{
name|err
operator|=
name|musbotg_standard_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|aframes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|td_transfer_cache
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
while|while
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
name|err
operator|=
name|musbotg_standard_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|aframes
operator|++
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|td_transfer_cache
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|&&
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
name|err
operator|=
name|musbotg_standard_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|musbotg_device_done
argument_list|(
name|xfer
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	musbotg_device_done  *  * NOTE: this function can be called more than one time on the  * same USB transfer!  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|musbotg_device_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"xfer=%p, endpoint=%p, error=%d\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
name|musbotg_ep_int_set
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|14
argument_list|,
literal|"disabled interrupts on endpoint\n"
argument_list|)
expr_stmt|;
block|}
comment|/* dequeue transfer and start next transfer */
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_set_stall
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|,
name|uint8_t
modifier|*
name|did_stall
parameter_list|)
block|{
name|struct
name|musbotg_softc
modifier|*
name|sc
decl_stmt|;
name|uint8_t
name|ep_no
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|udev
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"endpoint=%p\n"
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
condition|)
block|{
comment|/* cancel any ongoing transfers */
name|musbotg_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_STALLED
argument_list|)
expr_stmt|;
block|}
comment|/* set FORCESTALL */
name|sc
operator|=
name|MUSBOTG_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|ep_no
operator|=
operator|(
name|ep
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|UE_ADDR
operator|)
expr_stmt|;
comment|/* select endpoint */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_EPINDEX
argument_list|,
name|ep_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|UE_DIR_IN
condition|)
block|{
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
name|MUSB2_MASK_CSRL_TXSENDSTALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRL
argument_list|,
name|MUSB2_MASK_CSRL_RXSENDSTALL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_clear_stall_sub
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|wMaxPacket
parameter_list|,
name|uint8_t
name|ep_no
parameter_list|,
name|uint8_t
name|ep_type
parameter_list|,
name|uint8_t
name|ep_dir
parameter_list|)
block|{
name|uint16_t
name|mps
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
name|uint8_t
name|csr
decl_stmt|;
if|if
condition|(
name|ep_type
operator|==
name|UE_CONTROL
condition|)
block|{
comment|/* clearing stall is not needed */
return|return;
block|}
comment|/* select endpoint */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_EPINDEX
argument_list|,
name|ep_no
argument_list|)
expr_stmt|;
comment|/* compute max frame size */
name|mps
operator|=
name|wMaxPacket
operator|&
literal|0x7FF
expr_stmt|;
switch|switch
condition|(
operator|(
name|wMaxPacket
operator|>>
literal|11
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|1
case|:
name|mps
operator|*=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mps
operator|*=
literal|3
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|ep_dir
operator|==
name|UE_DIR_IN
condition|)
block|{
name|temp
operator|=
literal|0
expr_stmt|;
comment|/* Configure endpoint */
switch|switch
condition|(
name|ep_type
condition|)
block|{
case|case
name|UE_INTERRUPT
case|:
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXMAXP
argument_list|,
name|wMaxPacket
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRH
argument_list|,
name|MUSB2_MASK_CSRH_TXMODE
operator||
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXMAXP
argument_list|,
name|wMaxPacket
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRH
argument_list|,
name|MUSB2_MASK_CSRH_TXMODE
operator||
name|MUSB2_MASK_CSRH_TXISO
operator||
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_BULK
case|:
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXMAXP
argument_list|,
name|wMaxPacket
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRH
argument_list|,
name|MUSB2_MASK_CSRH_TXMODE
operator||
name|temp
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Need to flush twice in case of double bufring */
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|MUSB2_MASK_CSRL_TXFIFONEMPTY
condition|)
block|{
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
name|MUSB2_MASK_CSRL_TXFFLUSH
argument_list|)
expr_stmt|;
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|MUSB2_MASK_CSRL_TXFIFONEMPTY
condition|)
block|{
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
name|MUSB2_MASK_CSRL_TXFFLUSH
argument_list|)
expr_stmt|;
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* reset data toggle */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
name|MUSB2_MASK_CSRL_TXDT_CLR
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|)
expr_stmt|;
comment|/* set double/single buffering */
name|temp
operator|=
name|MUSB2_READ_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXDBDIS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps
operator|<=
operator|(
name|sc
operator|->
name|sc_hw_ep_profile
index|[
name|ep_no
index|]
operator|.
name|max_in_frame_size
operator|/
literal|2
operator|)
condition|)
block|{
comment|/* double buffer */
name|temp
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ep_no
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* single buffer */
name|temp
operator||=
operator|(
literal|1
operator|<<
name|ep_no
operator|)
expr_stmt|;
block|}
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXDBDIS
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* clear sent stall */
if|if
condition|(
name|csr
operator|&
name|MUSB2_MASK_CSRL_TXSENTSTALL
condition|)
block|{
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXCSRL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|temp
operator|=
literal|0
expr_stmt|;
comment|/* Configure endpoint */
switch|switch
condition|(
name|ep_type
condition|)
block|{
case|case
name|UE_INTERRUPT
case|:
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXMAXP
argument_list|,
name|wMaxPacket
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRH
argument_list|,
name|MUSB2_MASK_CSRH_RXNYET
operator||
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXMAXP
argument_list|,
name|wMaxPacket
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRH
argument_list|,
name|MUSB2_MASK_CSRH_RXNYET
operator||
name|MUSB2_MASK_CSRH_RXISO
operator||
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_BULK
case|:
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXMAXP
argument_list|,
name|wMaxPacket
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRH
argument_list|,
name|temp
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Need to flush twice in case of double bufring */
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|MUSB2_MASK_CSRL_RXPKTRDY
condition|)
block|{
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRL
argument_list|,
name|MUSB2_MASK_CSRL_RXFFLUSH
argument_list|)
expr_stmt|;
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|MUSB2_MASK_CSRL_RXPKTRDY
condition|)
block|{
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRL
argument_list|,
name|MUSB2_MASK_CSRL_RXFFLUSH
argument_list|)
expr_stmt|;
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* reset data toggle */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRL
argument_list|,
name|MUSB2_MASK_CSRL_RXDT_CLR
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|csr
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRL
argument_list|)
expr_stmt|;
comment|/* set double/single buffering */
name|temp
operator|=
name|MUSB2_READ_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXDBDIS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps
operator|<=
operator|(
name|sc
operator|->
name|sc_hw_ep_profile
index|[
name|ep_no
index|]
operator|.
name|max_out_frame_size
operator|/
literal|2
operator|)
condition|)
block|{
comment|/* double buffer */
name|temp
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ep_no
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* single buffer */
name|temp
operator||=
operator|(
literal|1
operator|<<
name|ep_no
operator|)
expr_stmt|;
block|}
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXDBDIS
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* clear sent stall */
if|if
condition|(
name|csr
operator|&
name|MUSB2_MASK_CSRL_RXSENTSTALL
condition|)
block|{
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXCSRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_clear_stall
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|musbotg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|usb_endpoint_descriptor
modifier|*
name|ed
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"endpoint=%p\n"
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|udev
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* check mode */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|!=
name|USB_MODE_DEVICE
condition|)
block|{
comment|/* not supported */
return|return;
block|}
comment|/* get softc */
name|sc
operator|=
name|MUSBOTG_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* get endpoint descriptor */
name|ed
operator|=
name|ep
operator|->
name|edesc
expr_stmt|;
comment|/* reset endpoint */
name|musbotg_clear_stall_sub
argument_list|(
name|sc
argument_list|,
name|UGETW
argument_list|(
name|ed
operator|->
name|wMaxPacketSize
argument_list|)
argument_list|,
operator|(
name|ed
operator|->
name|bEndpointAddress
operator|&
name|UE_ADDR
operator|)
argument_list|,
operator|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
argument_list|,
operator|(
name|ed
operator|->
name|bEndpointAddress
operator|&
operator|(
name|UE_DIR_IN
operator||
name|UE_DIR_OUT
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usb_error_t
name|musbotg_init
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_hw_ep_profile
modifier|*
name|pf
decl_stmt|;
name|uint16_t
name|offset
decl_stmt|;
name|uint8_t
name|nrx
decl_stmt|;
name|uint8_t
name|ntx
decl_stmt|;
name|uint8_t
name|temp
decl_stmt|;
name|uint8_t
name|fsize
decl_stmt|;
name|uint8_t
name|frx
decl_stmt|;
name|uint8_t
name|ftx
decl_stmt|;
name|uint8_t
name|dynfifo
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
literal|"start\n"
argument_list|)
expr_stmt|;
comment|/* set up the bus structure */
name|sc
operator|->
name|sc_bus
operator|.
name|usbrev
operator|=
name|USB_REV_2_0
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|methods
operator|=
operator|&
name|musbotg_bus_methods
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* turn on clocks */
if|if
condition|(
name|sc
operator|->
name|sc_clocks_on
condition|)
block|{
call|(
name|sc
operator|->
name|sc_clocks_on
call|)
argument_list|(
name|sc
operator|->
name|sc_clocks_arg
argument_list|)
expr_stmt|;
block|}
comment|/* wait a little for things to stabilise */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
comment|/* disable all interrupts */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTUSBE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTTXE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTRXE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable pullup */
name|musbotg_pull_common
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* wait a little bit (10ms) */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* disable double packet buffering */
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXDBDIS
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXDBDIS
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
comment|/* enable HighSpeed and ISO Update flags */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_POWER
argument_list|,
name|MUSB2_MASK_HSENAB
operator||
name|MUSB2_MASK_ISOUPD
argument_list|)
expr_stmt|;
comment|/* clear Session bit, if set */
name|temp
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_DEVCTL
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|MUSB2_MASK_SESS
expr_stmt|;
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_DEVCTL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"DEVCTL=0x%02x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* disable testmode */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TESTMODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set default value */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_MISC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* select endpoint index 0 */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_EPINDEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* read out number of endpoints */
name|nrx
operator|=
operator|(
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_EPINFO
argument_list|)
operator|/
literal|16
operator|)
expr_stmt|;
name|ntx
operator|=
operator|(
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_EPINFO
argument_list|)
operator|%
literal|16
operator|)
expr_stmt|;
comment|/* these numbers exclude the control endpoint */
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"RX/TX endpoints: %u/%u\n"
argument_list|,
name|nrx
argument_list|,
name|ntx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ep_max
operator|=
operator|(
name|nrx
operator|>
name|ntx
operator|)
condition|?
name|nrx
else|:
name|ntx
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ep_max
operator|==
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"ERROR: Looks like the clocks are off!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* read out configuration data */
name|sc
operator|->
name|sc_conf_data
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_CONFDATA
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"Config Data: 0x%02x\n"
argument_list|,
name|sc
operator|->
name|sc_conf_data
argument_list|)
expr_stmt|;
name|dynfifo
operator|=
operator|(
name|sc
operator|->
name|sc_conf_data
operator|&
name|MUSB2_MASK_CD_DYNFIFOSZ
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|dynfifo
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Dynamic FIFO sizing detected! "
literal|"Assuming 16Kbytes of FIFO RAM\n"
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"HW version: 0x%04x\n"
argument_list|,
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_HWVERS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialise endpoint profiles */
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|temp
operator|=
literal|1
init|;
name|temp
operator|<=
name|sc
operator|->
name|sc_ep_max
condition|;
name|temp
operator|++
control|)
block|{
name|pf
operator|=
name|sc
operator|->
name|sc_hw_ep_profile
operator|+
name|temp
expr_stmt|;
comment|/* select endpoint */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_EPINDEX
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|fsize
operator|=
name|MUSB2_READ_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_FSIZE
argument_list|)
expr_stmt|;
name|frx
operator|=
operator|(
name|fsize
operator|&
name|MUSB2_MASK_RX_FSIZE
operator|)
operator|/
literal|16
expr_stmt|;
empty_stmt|;
name|ftx
operator|=
operator|(
name|fsize
operator|&
name|MUSB2_MASK_TX_FSIZE
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Endpoint %u FIFO size: IN=%u, OUT=%u, DYN=%d\n"
argument_list|,
name|temp
argument_list|,
name|ftx
argument_list|,
name|frx
argument_list|,
name|dynfifo
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynfifo
condition|)
block|{
if|if
condition|(
name|frx
operator|&&
operator|(
name|temp
operator|<=
name|nrx
operator|)
condition|)
block|{
if|if
condition|(
name|temp
operator|<
literal|8
condition|)
block|{
name|frx
operator|=
literal|10
expr_stmt|;
comment|/* 1K */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXFIFOSZ
argument_list|,
name|MUSB2_VAL_FIFOSZ_512
operator||
name|MUSB2_MASK_FIFODB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|frx
operator|=
literal|7
expr_stmt|;
comment|/* 128 bytes */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXFIFOSZ
argument_list|,
name|MUSB2_VAL_FIFOSZ_128
argument_list|)
expr_stmt|;
block|}
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_RXFIFOADD
argument_list|,
name|offset
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|offset
operator|+=
operator|(
literal|1
operator|<<
name|frx
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ftx
operator|&&
operator|(
name|temp
operator|<=
name|ntx
operator|)
condition|)
block|{
if|if
condition|(
name|temp
operator|<
literal|8
condition|)
block|{
name|ftx
operator|=
literal|10
expr_stmt|;
comment|/* 1K */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXFIFOSZ
argument_list|,
name|MUSB2_VAL_FIFOSZ_512
operator||
name|MUSB2_MASK_FIFODB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ftx
operator|=
literal|7
expr_stmt|;
comment|/* 128 bytes */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXFIFOSZ
argument_list|,
name|MUSB2_VAL_FIFOSZ_128
argument_list|)
expr_stmt|;
block|}
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_TXFIFOADD
argument_list|,
name|offset
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|offset
operator|+=
operator|(
literal|1
operator|<<
name|ftx
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|frx
operator|&&
name|ftx
operator|&&
operator|(
name|temp
operator|<=
name|nrx
operator|)
operator|&&
operator|(
name|temp
operator|<=
name|ntx
operator|)
condition|)
block|{
name|pf
operator|->
name|max_in_frame_size
operator|=
literal|1
operator|<<
name|ftx
expr_stmt|;
name|pf
operator|->
name|max_out_frame_size
operator|=
literal|1
operator|<<
name|frx
expr_stmt|;
name|pf
operator|->
name|is_simplex
operator|=
literal|0
expr_stmt|;
comment|/* duplex */
name|pf
operator|->
name|support_multi_buffer
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|support_bulk
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|support_interrupt
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|support_isochronous
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|support_in
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|support_out
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frx
operator|&&
operator|(
name|temp
operator|<=
name|nrx
operator|)
condition|)
block|{
name|pf
operator|->
name|max_out_frame_size
operator|=
literal|1
operator|<<
name|frx
expr_stmt|;
name|pf
operator|->
name|is_simplex
operator|=
literal|1
expr_stmt|;
comment|/* simplex */
name|pf
operator|->
name|support_multi_buffer
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|support_bulk
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|support_interrupt
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|support_isochronous
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|support_out
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ftx
operator|&&
operator|(
name|temp
operator|<=
name|ntx
operator|)
condition|)
block|{
name|pf
operator|->
name|max_in_frame_size
operator|=
literal|1
operator|<<
name|ftx
expr_stmt|;
name|pf
operator|->
name|is_simplex
operator|=
literal|1
expr_stmt|;
comment|/* simplex */
name|pf
operator|->
name|support_multi_buffer
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|support_bulk
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|support_interrupt
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|support_isochronous
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|support_in
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"Dynamic FIFO size = %d bytes\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* turn on default interrupts */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTUSBE
argument_list|,
name|MUSB2_MASK_IRESET
argument_list|)
expr_stmt|;
name|musbotg_clocks_off
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* catch any lost interrupts */
name|musbotg_do_poll
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
name|void
name|musbotg_uninit
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* disable all interrupts */
name|MUSB2_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTUSBE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTTXE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MUSB2_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_INTRXE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|port_powered
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_bus_reset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_connect
operator|=
literal|1
expr_stmt|;
name|musbotg_pull_down
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|musbotg_clocks_off
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|musbotg_suspend
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
name|void
name|musbotg_resume
parameter_list|(
name|struct
name|musbotg_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_do_poll
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|musbotg_softc
modifier|*
name|sc
init|=
name|MUSBOTG_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|musbotg_interrupt_poll
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  * musbotg bulk support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|musbotg_device_bulk_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_device_bulk_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|musbotg_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_device_bulk_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_device_bulk_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/* setup TDs */
name|musbotg_setup_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|musbotg_start_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|musbotg_device_bulk_methods
init|=
block|{
operator|.
name|open
operator|=
name|musbotg_device_bulk_open
block|,
operator|.
name|close
operator|=
name|musbotg_device_bulk_close
block|,
operator|.
name|enter
operator|=
name|musbotg_device_bulk_enter
block|,
operator|.
name|start
operator|=
name|musbotg_device_bulk_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * musbotg control support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|musbotg_device_ctrl_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_device_ctrl_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|musbotg_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_device_ctrl_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_device_ctrl_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/* setup TDs */
name|musbotg_setup_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|musbotg_start_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|musbotg_device_ctrl_methods
init|=
block|{
operator|.
name|open
operator|=
name|musbotg_device_ctrl_open
block|,
operator|.
name|close
operator|=
name|musbotg_device_ctrl_close
block|,
operator|.
name|enter
operator|=
name|musbotg_device_ctrl_enter
block|,
operator|.
name|start
operator|=
name|musbotg_device_ctrl_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * musbotg interrupt support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|musbotg_device_intr_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_device_intr_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|musbotg_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_device_intr_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_device_intr_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/* setup TDs */
name|musbotg_setup_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|musbotg_start_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|musbotg_device_intr_methods
init|=
block|{
operator|.
name|open
operator|=
name|musbotg_device_intr_open
block|,
operator|.
name|close
operator|=
name|musbotg_device_intr_close
block|,
operator|.
name|enter
operator|=
name|musbotg_device_intr_enter
block|,
operator|.
name|start
operator|=
name|musbotg_device_intr_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * musbotg full speed isochronous support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|musbotg_device_isoc_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_device_isoc_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|musbotg_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_device_isoc_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|musbotg_softc
modifier|*
name|sc
init|=
name|MUSBOTG_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|nframes
decl_stmt|;
name|uint32_t
name|fs_frames
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"xfer=%p next=%d nframes=%d\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|,
name|xfer
operator|->
name|nframes
argument_list|)
expr_stmt|;
comment|/* get the current frame index */
name|nframes
operator|=
name|MUSB2_READ_2
argument_list|(
name|sc
argument_list|,
name|MUSB2_REG_FRAME
argument_list|)
expr_stmt|;
comment|/* 	 * check if the frame index is within the window where the frames 	 * will be inserted 	 */
name|temp
operator|=
operator|(
name|nframes
operator|-
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|)
operator|&
name|MUSB2_MASK_FRAME
expr_stmt|;
if|if
condition|(
name|usbd_get_speed
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|)
operator|==
name|USB_SPEED_HIGH
condition|)
block|{
name|fs_frames
operator|=
operator|(
name|xfer
operator|->
name|nframes
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
else|else
block|{
name|fs_frames
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|==
literal|0
operator|)
operator|||
operator|(
name|temp
operator|<
name|fs_frames
operator|)
condition|)
block|{
comment|/* 		 * If there is data underflow or the pipe queue is 		 * empty we schedule the transfer a few frames ahead 		 * of the current frame position. Else two isochronous 		 * transfers might overlap. 		 */
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|=
operator|(
name|nframes
operator|+
literal|3
operator|)
operator|&
name|MUSB2_MASK_FRAME
expr_stmt|;
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|=
literal|1
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"start next=%d\n"
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * compute how many milliseconds the insertion is ahead of the 	 * current frame position: 	 */
name|temp
operator|=
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|-
name|nframes
operator|)
operator|&
name|MUSB2_MASK_FRAME
expr_stmt|;
comment|/* 	 * pre-compute when the isochronous transfer will be finished: 	 */
name|xfer
operator|->
name|isoc_time_complete
operator|=
name|usb_isoc_time_expand
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|nframes
argument_list|)
operator|+
name|temp
operator|+
name|fs_frames
expr_stmt|;
comment|/* compute frame number for next insertion */
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|+=
name|fs_frames
expr_stmt|;
comment|/* setup TDs */
name|musbotg_setup_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_device_isoc_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/* start TD chain */
name|musbotg_start_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|musbotg_device_isoc_methods
init|=
block|{
operator|.
name|open
operator|=
name|musbotg_device_isoc_open
block|,
operator|.
name|close
operator|=
name|musbotg_device_isoc_close
block|,
operator|.
name|enter
operator|=
name|musbotg_device_isoc_enter
block|,
operator|.
name|start
operator|=
name|musbotg_device_isoc_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * musbotg root control support  *------------------------------------------------------------------------*  * Simulate a hardware HUB by handling all the necessary requests.  *------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_device_descriptor
name|musbotg_devd
init|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_DEVICE
block|,
operator|.
name|bcdUSB
operator|=
block|{
literal|0x00
block|,
literal|0x02
block|}
block|,
operator|.
name|bDeviceClass
operator|=
name|UDCLASS_HUB
block|,
operator|.
name|bDeviceSubClass
operator|=
name|UDSUBCLASS_HUB
block|,
operator|.
name|bDeviceProtocol
operator|=
name|UDPROTO_HSHUBSTT
block|,
operator|.
name|bMaxPacketSize
operator|=
literal|64
block|,
operator|.
name|bcdDevice
operator|=
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
operator|.
name|iManufacturer
operator|=
literal|1
block|,
operator|.
name|iProduct
operator|=
literal|2
block|,
operator|.
name|bNumConfigurations
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_device_qualifier
name|musbotg_odevd
init|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_qualifier
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_DEVICE_QUALIFIER
block|,
operator|.
name|bcdUSB
operator|=
block|{
literal|0x00
block|,
literal|0x02
block|}
block|,
operator|.
name|bDeviceClass
operator|=
name|UDCLASS_HUB
block|,
operator|.
name|bDeviceSubClass
operator|=
name|UDSUBCLASS_HUB
block|,
operator|.
name|bDeviceProtocol
operator|=
name|UDPROTO_FSHUB
block|,
operator|.
name|bMaxPacketSize0
operator|=
literal|0
block|,
operator|.
name|bNumConfigurations
operator|=
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|musbotg_config_desc
name|musbotg_confd
init|=
block|{
operator|.
name|confd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_config_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_CONFIG
block|,
operator|.
name|wTotalLength
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|musbotg_confd
argument_list|)
block|,
operator|.
name|bNumInterface
operator|=
literal|1
block|,
operator|.
name|bConfigurationValue
operator|=
literal|1
block|,
operator|.
name|iConfiguration
operator|=
literal|0
block|,
operator|.
name|bmAttributes
operator|=
name|UC_SELF_POWERED
block|,
operator|.
name|bMaxPower
operator|=
literal|0
block|, 	}
block|,
operator|.
name|ifcd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_interface_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_INTERFACE
block|,
operator|.
name|bNumEndpoints
operator|=
literal|1
block|,
operator|.
name|bInterfaceClass
operator|=
name|UICLASS_HUB
block|,
operator|.
name|bInterfaceSubClass
operator|=
name|UISUBCLASS_HUB
block|,
operator|.
name|bInterfaceProtocol
operator|=
name|UIPROTO_HSHUBSTT
block|, 	}
block|,
operator|.
name|endpd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_endpoint_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_ENDPOINT
block|,
operator|.
name|bEndpointAddress
operator|=
operator|(
name|UE_DIR_IN
operator||
name|MUSBOTG_INTR_ENDPT
operator|)
block|,
operator|.
name|bmAttributes
operator|=
name|UE_INTERRUPT
block|,
operator|.
name|wMaxPacketSize
index|[
literal|0
index|]
operator|=
literal|8
block|,
operator|.
name|bInterval
operator|=
literal|255
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_hub_descriptor_min
name|musbotg_hubd
init|=
block|{
operator|.
name|bDescLength
operator|=
sizeof|sizeof
argument_list|(
name|musbotg_hubd
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_HUB
block|,
operator|.
name|bNbrPorts
operator|=
literal|1
block|,
operator|.
name|wHubCharacteristics
index|[
literal|0
index|]
operator|=
operator|(
name|UHD_PWR_NO_SWITCH
operator||
name|UHD_OC_INDIVIDUAL
operator|)
operator|&
literal|0xFF
block|,
operator|.
name|wHubCharacteristics
index|[
literal|1
index|]
operator|=
operator|(
name|UHD_PWR_NO_SWITCH
operator||
name|UHD_OC_INDIVIDUAL
operator|)
operator|>>
literal|16
block|,
operator|.
name|bPwrOn2PwrGood
operator|=
literal|50
block|,
operator|.
name|bHubContrCurrent
operator|=
literal|0
block|,
operator|.
name|DeviceRemovable
operator|=
block|{
literal|0
block|}
block|,
comment|/* port is removable */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STRING_LANG
define|\
value|0x09, 0x04,
end_define

begin_comment
comment|/* American English */
end_comment

begin_define
define|#
directive|define
name|STRING_VENDOR
define|\
value|'M', 0, 'e', 0, 'n', 0, 't', 0, 'o', 0, 'r', 0, ' ', 0, \   'G', 0, 'r', 0, 'a', 0, 'p', 0, 'h', 0, 'i', 0, 'c', 0, 's', 0
end_define

begin_define
define|#
directive|define
name|STRING_PRODUCT
define|\
value|'O', 0, 'T', 0, 'G', 0, ' ', 0, 'R', 0, \   'o', 0, 'o', 0, 't', 0, ' ', 0, 'H', 0, \   'U', 0, 'B', 0,
end_define

begin_expr_stmt
name|USB_MAKE_STRING_DESC
argument_list|(
name|STRING_LANG
argument_list|,
name|musbotg_langtab
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|USB_MAKE_STRING_DESC
argument_list|(
name|STRING_VENDOR
argument_list|,
name|musbotg_vendor
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|USB_MAKE_STRING_DESC
argument_list|(
name|STRING_PRODUCT
argument_list|,
name|musbotg_product
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|usb_error_t
name|musbotg_roothub_exec
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_device_request
modifier|*
name|req
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|pptr
parameter_list|,
name|uint16_t
modifier|*
name|plength
parameter_list|)
block|{
name|struct
name|musbotg_softc
modifier|*
name|sc
init|=
name|MUSBOTG_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
specifier|const
name|void
modifier|*
name|ptr
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|uint16_t
name|value
decl_stmt|;
name|uint16_t
name|index
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* buffer reset */
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_hub_temp
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
expr_stmt|;
name|index
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
expr_stmt|;
comment|/* demultiplex the control request */
switch|switch
condition|(
name|req
operator|->
name|bmRequestType
condition|)
block|{
case|case
name|UT_READ_DEVICE
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_GET_DESCRIPTOR
case|:
goto|goto
name|tr_handle_get_descriptor
goto|;
case|case
name|UR_GET_CONFIG
case|:
goto|goto
name|tr_handle_get_config
goto|;
case|case
name|UR_GET_STATUS
case|:
goto|goto
name|tr_handle_get_status
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_WRITE_DEVICE
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_SET_ADDRESS
case|:
goto|goto
name|tr_handle_set_address
goto|;
case|case
name|UR_SET_CONFIG
case|:
goto|goto
name|tr_handle_set_config
goto|;
case|case
name|UR_CLEAR_FEATURE
case|:
goto|goto
name|tr_valid
goto|;
comment|/* nop */
case|case
name|UR_SET_DESCRIPTOR
case|:
goto|goto
name|tr_valid
goto|;
comment|/* nop */
case|case
name|UR_SET_FEATURE
case|:
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_WRITE_ENDPOINT
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_CLEAR_FEATURE
case|:
switch|switch
condition|(
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
condition|)
block|{
case|case
name|UF_ENDPOINT_HALT
case|:
goto|goto
name|tr_handle_clear_halt
goto|;
case|case
name|UF_DEVICE_REMOTE_WAKEUP
case|:
goto|goto
name|tr_handle_clear_wakeup
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UR_SET_FEATURE
case|:
switch|switch
condition|(
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
condition|)
block|{
case|case
name|UF_ENDPOINT_HALT
case|:
goto|goto
name|tr_handle_set_halt
goto|;
case|case
name|UF_DEVICE_REMOTE_WAKEUP
case|:
goto|goto
name|tr_handle_set_wakeup
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UR_SYNCH_FRAME
case|:
goto|goto
name|tr_valid
goto|;
comment|/* nop */
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_READ_ENDPOINT
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_GET_STATUS
case|:
goto|goto
name|tr_handle_get_ep_status
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_WRITE_INTERFACE
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_SET_INTERFACE
case|:
goto|goto
name|tr_handle_set_interface
goto|;
case|case
name|UR_CLEAR_FEATURE
case|:
goto|goto
name|tr_valid
goto|;
comment|/* nop */
case|case
name|UR_SET_FEATURE
case|:
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_READ_INTERFACE
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_GET_INTERFACE
case|:
goto|goto
name|tr_handle_get_interface
goto|;
case|case
name|UR_GET_STATUS
case|:
goto|goto
name|tr_handle_get_iface_status
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_WRITE_CLASS_INTERFACE
case|:
case|case
name|UT_WRITE_VENDOR_INTERFACE
case|:
comment|/* XXX forward */
break|break;
case|case
name|UT_READ_CLASS_INTERFACE
case|:
case|case
name|UT_READ_VENDOR_INTERFACE
case|:
comment|/* XXX forward */
break|break;
case|case
name|UT_WRITE_CLASS_DEVICE
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_CLEAR_FEATURE
case|:
goto|goto
name|tr_valid
goto|;
case|case
name|UR_SET_DESCRIPTOR
case|:
case|case
name|UR_SET_FEATURE
case|:
break|break;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_WRITE_CLASS_OTHER
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_CLEAR_FEATURE
case|:
goto|goto
name|tr_handle_clear_port_feature
goto|;
case|case
name|UR_SET_FEATURE
case|:
goto|goto
name|tr_handle_set_port_feature
goto|;
case|case
name|UR_CLEAR_TT_BUFFER
case|:
case|case
name|UR_RESET_TT
case|:
case|case
name|UR_STOP_TT
case|:
goto|goto
name|tr_valid
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_READ_CLASS_OTHER
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_GET_TT_STATE
case|:
goto|goto
name|tr_handle_get_tt_state
goto|;
case|case
name|UR_GET_STATUS
case|:
goto|goto
name|tr_handle_get_port_status
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_READ_CLASS_DEVICE
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_GET_DESCRIPTOR
case|:
goto|goto
name|tr_handle_get_class_descriptor
goto|;
case|case
name|UR_GET_STATUS
case|:
goto|goto
name|tr_handle_get_class_status
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
goto|goto
name|tr_valid
goto|;
name|tr_handle_get_descriptor
label|:
switch|switch
condition|(
name|value
operator|>>
literal|8
condition|)
block|{
case|case
name|UDESC_DEVICE
case|:
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|musbotg_devd
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|musbotg_devd
expr_stmt|;
goto|goto
name|tr_valid
goto|;
case|case
name|UDESC_CONFIG
case|:
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|musbotg_confd
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|musbotg_confd
expr_stmt|;
goto|goto
name|tr_valid
goto|;
case|case
name|UDESC_STRING
case|:
switch|switch
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0
case|:
comment|/* Language table */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|musbotg_langtab
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|musbotg_langtab
expr_stmt|;
goto|goto
name|tr_valid
goto|;
case|case
literal|1
case|:
comment|/* Vendor */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|musbotg_vendor
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|musbotg_vendor
expr_stmt|;
goto|goto
name|tr_valid
goto|;
case|case
literal|2
case|:
comment|/* Product */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|musbotg_product
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|musbotg_product
expr_stmt|;
goto|goto
name|tr_valid
goto|;
default|default:
break|break;
block|}
break|break;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
goto|goto
name|tr_stalled
goto|;
name|tr_handle_get_config
label|:
name|len
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_hub_temp
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_conf
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_handle_get_status
label|:
name|len
operator|=
literal|2
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_temp
operator|.
name|wValue
argument_list|,
name|UDS_SELF_POWERED
argument_list|)
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_handle_set_address
label|:
if|if
condition|(
name|value
operator|&
literal|0xFF00
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|sc
operator|->
name|sc_rt_addr
operator|=
name|value
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_handle_set_config
label|:
if|if
condition|(
name|value
operator|>=
literal|2
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|sc
operator|->
name|sc_conf
operator|=
name|value
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_handle_get_interface
label|:
name|len
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_hub_temp
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_handle_get_tt_state
label|:
name|tr_handle_get_class_status
label|:
name|tr_handle_get_iface_status
label|:
name|tr_handle_get_ep_status
label|:
name|len
operator|=
literal|2
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_temp
operator|.
name|wValue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_handle_set_halt
label|:
name|tr_handle_set_interface
label|:
name|tr_handle_set_wakeup
label|:
name|tr_handle_clear_wakeup
label|:
name|tr_handle_clear_halt
label|:
goto|goto
name|tr_valid
goto|;
name|tr_handle_clear_port_feature
label|:
if|if
condition|(
name|index
operator|!=
literal|1
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
literal|"UR_CLEAR_PORT_FEATURE on port %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_SUSPEND
case|:
name|musbotg_wakeup_peer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_ENABLE
case|:
name|sc
operator|->
name|sc_flags
operator|.
name|port_enabled
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UHF_PORT_TEST
case|:
case|case
name|UHF_PORT_INDICATOR
case|:
case|case
name|UHF_C_PORT_ENABLE
case|:
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
case|case
name|UHF_C_PORT_RESET
case|:
comment|/* nops */
break|break;
case|case
name|UHF_PORT_POWER
case|:
name|sc
operator|->
name|sc_flags
operator|.
name|port_powered
operator|=
literal|0
expr_stmt|;
name|musbotg_pull_down
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|musbotg_clocks_off
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONNECTION
case|:
name|sc
operator|->
name|sc_flags
operator|.
name|change_connect
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_SUSPEND
case|:
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
goto|goto
name|tr_valid
goto|;
name|tr_handle_set_port_feature
label|:
if|if
condition|(
name|index
operator|!=
literal|1
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
literal|"UR_SET_PORT_FEATURE\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|sc
operator|->
name|sc_flags
operator|.
name|port_enabled
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
case|case
name|UHF_PORT_RESET
case|:
case|case
name|UHF_PORT_TEST
case|:
case|case
name|UHF_PORT_INDICATOR
case|:
comment|/* nops */
break|break;
case|case
name|UHF_PORT_POWER
case|:
name|sc
operator|->
name|sc_flags
operator|.
name|port_powered
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
goto|goto
name|tr_valid
goto|;
name|tr_handle_get_port_status
label|:
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
literal|"UR_GET_PORT_STATUS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
literal|1
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
condition|)
block|{
name|musbotg_clocks_on
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|musbotg_pull_up
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|musbotg_pull_down
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|musbotg_clocks_off
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Select Device Side Mode */
name|value
operator|=
name|UPS_PORT_MODE_DEVICE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_high_speed
condition|)
block|{
name|value
operator||=
name|UPS_HIGH_SPEED
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|port_powered
condition|)
block|{
name|value
operator||=
name|UPS_PORT_POWER
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|port_enabled
condition|)
block|{
name|value
operator||=
name|UPS_PORT_ENABLED
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
operator|&&
name|sc
operator|->
name|sc_flags
operator|.
name|status_bus_reset
condition|)
block|{
name|value
operator||=
name|UPS_CURRENT_CONNECT_STATUS
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
condition|)
block|{
name|value
operator||=
name|UPS_SUSPEND
expr_stmt|;
block|}
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_temp
operator|.
name|ps
operator|.
name|wPortStatus
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|change_connect
condition|)
block|{
name|value
operator||=
name|UPS_C_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
operator|&&
name|sc
operator|->
name|sc_flags
operator|.
name|status_bus_reset
condition|)
block|{
comment|/* reset EP0 state */
name|sc
operator|->
name|sc_ep0_busy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ep0_cmd
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
condition|)
block|{
name|value
operator||=
name|UPS_C_SUSPEND
expr_stmt|;
block|}
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_temp
operator|.
name|ps
operator|.
name|wPortChange
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_temp
operator|.
name|ps
argument_list|)
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_handle_get_class_descriptor
label|:
if|if
condition|(
name|value
operator|&
literal|0xFF
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|musbotg_hubd
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|musbotg_hubd
argument_list|)
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_stalled
label|:
name|err
operator|=
name|USB_ERR_STALLED
expr_stmt|;
name|tr_valid
label|:
name|done
label|:
operator|*
name|plength
operator|=
name|len
expr_stmt|;
operator|*
name|pptr
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_xfer_setup
parameter_list|(
name|struct
name|usb_setup_params
modifier|*
name|parm
parameter_list|)
block|{
specifier|const
name|struct
name|usb_hw_ep_profile
modifier|*
name|pf
decl_stmt|;
name|struct
name|musbotg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|void
modifier|*
name|last_obj
decl_stmt|;
name|uint32_t
name|ntd
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
name|uint8_t
name|ep_no
decl_stmt|;
name|sc
operator|=
name|MUSBOTG_BUS2SC
argument_list|(
name|parm
operator|->
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|xfer
operator|=
name|parm
operator|->
name|curr_xfer
expr_stmt|;
comment|/* 	 * NOTE: This driver does not use any of the parameters that 	 * are computed from the following values. Just set some 	 * reasonable dummies: 	 */
name|parm
operator|->
name|hc_max_packet_size
operator|=
literal|0x400
expr_stmt|;
name|parm
operator|->
name|hc_max_frame_size
operator|=
literal|0x400
expr_stmt|;
if|if
condition|(
operator|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|musbotg_device_isoc_methods
operator|)
operator|||
operator|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|musbotg_device_intr_methods
operator|)
condition|)
name|parm
operator|->
name|hc_max_packet_count
operator|=
literal|3
expr_stmt|;
else|else
name|parm
operator|->
name|hc_max_packet_count
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* 	 * compute maximum number of TDs 	 */
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|musbotg_device_ctrl_methods
condition|)
block|{
name|ntd
operator|=
name|xfer
operator|->
name|nframes
operator|+
literal|1
comment|/* STATUS */
operator|+
literal|1
comment|/* SYNC */
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|musbotg_device_bulk_methods
condition|)
block|{
name|ntd
operator|=
name|xfer
operator|->
name|nframes
operator|+
literal|1
comment|/* SYNC */
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|musbotg_device_intr_methods
condition|)
block|{
name|ntd
operator|=
name|xfer
operator|->
name|nframes
operator|+
literal|1
comment|/* SYNC */
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|musbotg_device_isoc_methods
condition|)
block|{
name|ntd
operator|=
name|xfer
operator|->
name|nframes
operator|+
literal|1
comment|/* SYNC */
expr_stmt|;
block|}
else|else
block|{
name|ntd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * check if "usbd_transfer_setup_sub" set an error 	 */
if|if
condition|(
name|parm
operator|->
name|err
condition|)
block|{
return|return;
block|}
comment|/* 	 * allocate transfer descriptors 	 */
name|last_obj
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * get profile stuff 	 */
if|if
condition|(
name|ntd
condition|)
block|{
name|ep_no
operator|=
name|xfer
operator|->
name|endpointno
operator|&
name|UE_ADDR
expr_stmt|;
name|musbotg_get_hw_ep_profile
argument_list|(
name|parm
operator|->
name|udev
argument_list|,
operator|&
name|pf
argument_list|,
name|ep_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|==
name|NULL
condition|)
block|{
comment|/* should not happen */
name|parm
operator|->
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|ep_no
operator|=
literal|0
expr_stmt|;
name|pf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* align data */
name|parm
operator|->
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
operator|-
name|parm
operator|->
name|size
index|[
literal|0
index|]
operator|)
operator|&
operator|(
name|USB_HOST_ALIGN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|ntd
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|musbotg_td
modifier|*
name|td
decl_stmt|;
if|if
condition|(
name|parm
operator|->
name|buf
condition|)
block|{
name|td
operator|=
name|USB_ADD_BYTES
argument_list|(
name|parm
operator|->
name|buf
argument_list|,
name|parm
operator|->
name|size
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* init TD */
name|td
operator|->
name|max_frame_size
operator|=
name|xfer
operator|->
name|max_frame_size
expr_stmt|;
name|td
operator|->
name|ep_no
operator|=
name|ep_no
expr_stmt|;
name|td
operator|->
name|obj_next
operator|=
name|last_obj
expr_stmt|;
name|last_obj
operator|=
name|td
expr_stmt|;
block|}
name|parm
operator|->
name|size
index|[
literal|0
index|]
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|td
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|td_start
index|[
literal|0
index|]
operator|=
name|last_obj
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_xfer_unsetup
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|musbotg_ep_init
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint_descriptor
modifier|*
name|edesc
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|musbotg_softc
modifier|*
name|sc
init|=
name|MUSBOTG_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"endpoint=%p, addr=%d, endpt=%d, mode=%d (%d)\n"
argument_list|,
name|ep
argument_list|,
name|udev
operator|->
name|address
argument_list|,
name|edesc
operator|->
name|bEndpointAddress
argument_list|,
name|udev
operator|->
name|flags
operator|.
name|usb_mode
argument_list|,
name|sc
operator|->
name|sc_rt_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|device_index
operator|!=
name|sc
operator|->
name|sc_rt_addr
condition|)
block|{
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|!=
name|USB_MODE_DEVICE
condition|)
block|{
comment|/* not supported */
return|return;
block|}
if|if
condition|(
operator|(
name|udev
operator|->
name|speed
operator|!=
name|USB_SPEED_FULL
operator|)
operator|&&
operator|(
name|udev
operator|->
name|speed
operator|!=
name|USB_SPEED_HIGH
operator|)
condition|)
block|{
comment|/* not supported */
return|return;
block|}
switch|switch
condition|(
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_CONTROL
case|:
name|ep
operator|->
name|methods
operator|=
operator|&
name|musbotg_device_ctrl_methods
expr_stmt|;
break|break;
case|case
name|UE_INTERRUPT
case|:
name|ep
operator|->
name|methods
operator|=
operator|&
name|musbotg_device_intr_methods
expr_stmt|;
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
name|ep
operator|->
name|methods
operator|=
operator|&
name|musbotg_device_isoc_methods
expr_stmt|;
break|break;
case|case
name|UE_BULK
case|:
name|ep
operator|->
name|methods
operator|=
operator|&
name|musbotg_device_bulk_methods
expr_stmt|;
break|break;
default|default:
comment|/* do nothing */
break|break;
block|}
block|}
block|}
end_function

begin_decl_stmt
name|struct
name|usb_bus_methods
name|musbotg_bus_methods
init|=
block|{
operator|.
name|endpoint_init
operator|=
operator|&
name|musbotg_ep_init
block|,
operator|.
name|xfer_setup
operator|=
operator|&
name|musbotg_xfer_setup
block|,
operator|.
name|xfer_unsetup
operator|=
operator|&
name|musbotg_xfer_unsetup
block|,
operator|.
name|get_hw_ep_profile
operator|=
operator|&
name|musbotg_get_hw_ep_profile
block|,
operator|.
name|set_stall
operator|=
operator|&
name|musbotg_set_stall
block|,
operator|.
name|clear_stall
operator|=
operator|&
name|musbotg_clear_stall
block|,
operator|.
name|roothub_exec
operator|=
operator|&
name|musbotg_roothub_exec
block|,
operator|.
name|xfer_poll
operator|=
operator|&
name|musbotg_do_poll
block|, }
decl_stmt|;
end_decl_stmt

end_unit

