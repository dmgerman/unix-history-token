begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Hans Petter Selasky. All rights reserved.  * Copyright (c) 1998 The NetBSD Foundation, Inc. All rights reserved.  * Copyright (c) 1998 Lennart Augustsson. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * USB Open Host Controller driver.  *  * OHCI spec: http://www.compaq.com/productinfo/development/openhci.html  * USB spec:  http://www.usb.org/developers/docs/usbspec.zip  */
end_comment

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|ohcidebug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_hub.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/ohci.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/ohcireg.h>
end_include

begin_define
define|#
directive|define
name|OHCI_BUS2SC
parameter_list|(
name|bus
parameter_list|)
define|\
value|((ohci_softc_t *)(((uint8_t *)(bus)) - \     ((uint8_t *)&(((ohci_softc_t *)0)->sc_bus))))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ohcidebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|ohci
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB ohci"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_ohci
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ohcidebug
argument_list|,
literal|0
argument_list|,
literal|"ohci debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.ohci.debug"
argument_list|,
operator|&
name|ohcidebug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|ohci_dumpregs
parameter_list|(
name|ohci_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ohci_dump_tds
parameter_list|(
name|ohci_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ohci_dump_td
parameter_list|(
name|ohci_td_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ohci_dump_ed
parameter_list|(
name|ohci_ed_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ohci_dump_itd
parameter_list|(
name|ohci_itd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ohci_dump_itds
parameter_list|(
name|ohci_itd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OBARR
parameter_list|(
name|sc
parameter_list|)
value|bus_space_barrier((sc)->sc_io_tag, (sc)->sc_io_hdl, 0, (sc)->sc_io_size, \ 			BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE)
end_define

begin_define
define|#
directive|define
name|OWRITE1
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
define|\
value|do { OBARR(sc); bus_space_write_1((sc)->sc_io_tag, (sc)->sc_io_hdl, (r), (x)); } while (0)
end_define

begin_define
define|#
directive|define
name|OWRITE2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
define|\
value|do { OBARR(sc); bus_space_write_2((sc)->sc_io_tag, (sc)->sc_io_hdl, (r), (x)); } while (0)
end_define

begin_define
define|#
directive|define
name|OWRITE4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
define|\
value|do { OBARR(sc); bus_space_write_4((sc)->sc_io_tag, (sc)->sc_io_hdl, (r), (x)); } while (0)
end_define

begin_define
define|#
directive|define
name|OREAD1
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|(OBARR(sc), bus_space_read_1((sc)->sc_io_tag, (sc)->sc_io_hdl, (r)))
end_define

begin_define
define|#
directive|define
name|OREAD2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|(OBARR(sc), bus_space_read_2((sc)->sc_io_tag, (sc)->sc_io_hdl, (r)))
end_define

begin_define
define|#
directive|define
name|OREAD4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|(OBARR(sc), bus_space_read_4((sc)->sc_io_tag, (sc)->sc_io_hdl, (r)))
end_define

begin_define
define|#
directive|define
name|OHCI_INTR_ENDPT
value|1
end_define

begin_decl_stmt
specifier|extern
name|struct
name|usb_bus_methods
name|ohci_bus_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|usb_pipe_methods
name|ohci_device_bulk_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|usb_pipe_methods
name|ohci_device_ctrl_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|usb_pipe_methods
name|ohci_device_intr_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|usb_pipe_methods
name|ohci_device_isoc_methods
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ohci_do_poll
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ohci_device_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ohci_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ohci_check_transfer
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ohci_root_intr
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|ohci_std_temp
block|{
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|ohci_td_t
modifier|*
name|td
decl_stmt|;
name|ohci_td_t
modifier|*
name|td_next
decl_stmt|;
name|uint32_t
name|average
decl_stmt|;
name|uint32_t
name|td_flags
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint16_t
name|max_frame_size
decl_stmt|;
name|uint8_t
name|shortpkt
decl_stmt|;
name|uint8_t
name|setup_alt_next
decl_stmt|;
name|uint8_t
name|last_frame
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|ohci_hcca
modifier|*
name|ohci_get_hcca
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|hcca_pc
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_hcca_p
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ohci_iterate_hw_softc
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
name|usb_bus_mem_sub_cb_t
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|ohci_softc
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|hcca_pc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|hcca_pg
argument_list|,
sizeof|sizeof
argument_list|(
name|ohci_hcca_t
argument_list|)
argument_list|,
name|OHCI_HCCA_ALIGN
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|ctrl_start_pc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|ctrl_start_pg
argument_list|,
sizeof|sizeof
argument_list|(
name|ohci_ed_t
argument_list|)
argument_list|,
name|OHCI_ED_ALIGN
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|bulk_start_pc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|bulk_start_pg
argument_list|,
sizeof|sizeof
argument_list|(
name|ohci_ed_t
argument_list|)
argument_list|,
name|OHCI_ED_ALIGN
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|isoc_start_pc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|isoc_start_pg
argument_list|,
sizeof|sizeof
argument_list|(
name|ohci_ed_t
argument_list|)
argument_list|,
name|OHCI_ED_ALIGN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|OHCI_NO_EDS
condition|;
name|i
operator|++
control|)
block|{
name|cb
argument_list|(
name|bus
argument_list|,
name|sc
operator|->
name|sc_hw
operator|.
name|intr_start_pc
operator|+
name|i
argument_list|,
name|sc
operator|->
name|sc_hw
operator|.
name|intr_start_pg
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|ohci_ed_t
argument_list|)
argument_list|,
name|OHCI_ED_ALIGN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|ohci_controller_init
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|uint32_t
name|ival
decl_stmt|;
name|uint32_t
name|hcr
decl_stmt|;
name|uint32_t
name|fm
decl_stmt|;
name|uint32_t
name|per
decl_stmt|;
name|uint32_t
name|desca
decl_stmt|;
comment|/* Determine in what context we are running. */
name|ctl
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&
name|OHCI_IR
condition|)
block|{
comment|/* SMM active, request change */
name|DPRINTF
argument_list|(
literal|"SMM active, request owner change\n"
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_OCR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|100
operator|)
operator|&&
operator|(
name|ctl
operator|&
name|OHCI_IR
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctl
operator|&
name|OHCI_IR
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"SMM does not respond, resetting\n"
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_RESET
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"cold started\n"
argument_list|)
expr_stmt|;
name|reset
label|:
comment|/* controller was cold started */
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_BUS_RESET_DELAY
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This reset should not be necessary according to the OHCI spec, but 	 * without it some controllers do not start. 	 */
name|DPRINTF
argument_list|(
literal|"%s: resetting\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_RESET
argument_list|)
expr_stmt|;
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_BUS_RESET_DELAY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we now own the host controller and the bus has been reset */
name|ival
operator|=
name|OHCI_GET_IVAL
argument_list|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_INTERVAL
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_HCR
argument_list|)
expr_stmt|;
comment|/* Reset HC */
comment|/* nominal time for a reset is 10 us */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|hcr
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|)
operator|&
name|OHCI_HCR
expr_stmt|;
if|if
condition|(
operator|!
name|hcr
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|hcr
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"reset timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_IOERROR
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|15
condition|)
block|{
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* The controller is now in SUSPEND state, we have 2ms to finish. */
comment|/* set up HC registers */
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|hcca_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCA
argument_list|,
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|ctrl_start_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL_HEAD_ED
argument_list|,
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|bulk_start_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_BULK_HEAD_ED
argument_list|,
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
comment|/* disable all interrupts and then switch on all desired interrupts */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|,
name|OHCI_ALL_INTRS
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_ENABLE
argument_list|,
name|sc
operator|->
name|sc_eintrs
operator||
name|OHCI_MIE
argument_list|)
expr_stmt|;
comment|/* switch on desired functional features */
name|ctl
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
operator|(
name|OHCI_CBSR_MASK
operator||
name|OHCI_LES
operator||
name|OHCI_HCFS_MASK
operator||
name|OHCI_IR
operator|)
expr_stmt|;
name|ctl
operator||=
name|OHCI_PLE
operator||
name|OHCI_IE
operator||
name|OHCI_CLE
operator||
name|OHCI_BLE
operator||
name|OHCI_RATIO_1_4
operator||
name|OHCI_HCFS_OPERATIONAL
expr_stmt|;
comment|/* And finally start it! */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
comment|/* 	 * The controller is now OPERATIONAL.  Set a some final 	 * registers that should be set earlier, but that the 	 * controller ignores when in the SUSPEND state. 	 */
name|fm
operator|=
operator|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_INTERVAL
argument_list|)
operator|&
name|OHCI_FIT
operator|)
operator|^
name|OHCI_FIT
expr_stmt|;
name|fm
operator||=
name|OHCI_FSMPS
argument_list|(
name|ival
argument_list|)
operator||
name|ival
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_INTERVAL
argument_list|,
name|fm
argument_list|)
expr_stmt|;
name|per
operator|=
name|OHCI_PERIODIC
argument_list|(
name|ival
argument_list|)
expr_stmt|;
comment|/* 90% periodic */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_PERIODIC_START
argument_list|,
name|per
argument_list|)
expr_stmt|;
comment|/* Fiddle the No OverCurrent Protection bit to avoid chip bug. */
name|desca
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|,
name|desca
operator||
name|OHCI_NOCP
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_STATUS
argument_list|,
name|OHCI_LPSC
argument_list|)
expr_stmt|;
comment|/* Enable port power */
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|OHCI_ENABLE_POWER_DELAY
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|,
name|desca
argument_list|)
expr_stmt|;
comment|/* 	 * The AMD756 requires a delay before re-reading the register, 	 * otherwise it will occasionally report 0 ports. 	 */
name|sc
operator|->
name|sc_noport
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|10
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_noport
operator|==
literal|0
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|OHCI_READ_DESC_DELAY
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_noport
operator|=
name|OHCI_GET_NDP
argument_list|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|5
condition|)
block|{
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|USB_ERR_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ohci_ed
modifier|*
name|ohci_init_ed
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|struct
name|ohci_ed
modifier|*
name|ed
decl_stmt|;
name|usbd_get_page
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|ed
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
name|ed
operator|->
name|ed_self
operator|=
name|htole32
argument_list|(
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|ed
operator|->
name|ed_flags
operator|=
name|htole32
argument_list|(
name|OHCI_ED_SKIP
argument_list|)
expr_stmt|;
name|ed
operator|->
name|page_cache
operator|=
name|pc
expr_stmt|;
return|return
operator|(
name|ed
operator|)
return|;
block|}
end_function

begin_function
name|usb_error_t
name|ohci_init
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|bit
decl_stmt|;
name|uint16_t
name|x
decl_stmt|;
name|uint16_t
name|y
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"start\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_eintrs
operator|=
name|OHCI_NORMAL_INTRS
expr_stmt|;
comment|/* 	 * Setup all ED's 	 */
name|sc
operator|->
name|sc_ctrl_p_last
operator|=
name|ohci_init_ed
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|ctrl_start_pc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bulk_p_last
operator|=
name|ohci_init_ed
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|bulk_start_pc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_isoc_p_last
operator|=
name|ohci_init_ed
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|isoc_start_pc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|OHCI_NO_EDS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_intr_p_last
index|[
name|i
index|]
operator|=
name|ohci_init_ed
argument_list|(
name|sc
operator|->
name|sc_hw
operator|.
name|intr_start_pc
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * the QHs are arranged to give poll intervals that are 	 * powers of 2 times 1ms 	 */
name|bit
operator|=
name|OHCI_NO_EDS
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|bit
condition|)
block|{
name|x
operator|=
name|bit
expr_stmt|;
while|while
condition|(
name|x
operator|&
name|bit
condition|)
block|{
name|ohci_ed_t
modifier|*
name|ed_x
decl_stmt|;
name|ohci_ed_t
modifier|*
name|ed_y
decl_stmt|;
name|y
operator|=
operator|(
name|x
operator|^
name|bit
operator|)
operator||
operator|(
name|bit
operator|/
literal|2
operator|)
expr_stmt|;
comment|/* 			 * the next QH has half the poll interval 			 */
name|ed_x
operator|=
name|sc
operator|->
name|sc_intr_p_last
index|[
name|x
index|]
expr_stmt|;
name|ed_y
operator|=
name|sc
operator|->
name|sc_intr_p_last
index|[
name|y
index|]
expr_stmt|;
name|ed_x
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ed_x
operator|->
name|ed_next
operator|=
name|ed_y
operator|->
name|ed_self
expr_stmt|;
name|x
operator|++
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
literal|1
condition|)
block|{
name|ohci_ed_t
modifier|*
name|ed_int
decl_stmt|;
name|ohci_ed_t
modifier|*
name|ed_isc
decl_stmt|;
name|ed_int
operator|=
name|sc
operator|->
name|sc_intr_p_last
index|[
literal|0
index|]
expr_stmt|;
name|ed_isc
operator|=
name|sc
operator|->
name|sc_isoc_p_last
expr_stmt|;
comment|/* the last (1ms) QH */
name|ed_int
operator|->
name|next
operator|=
name|ed_isc
expr_stmt|;
name|ed_int
operator|->
name|ed_next
operator|=
name|ed_isc
operator|->
name|ed_self
expr_stmt|;
block|}
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|hcca_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hcca_p
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
comment|/* 	 * Fill HCCA interrupt table.  The bit reversal is to get 	 * the tree set up properly to spread the interrupts. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|OHCI_NO_INTRS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_hcca_p
operator|->
name|hcca_interrupt_table
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|sc_intr_p_last
index|[
name|i
operator||
operator|(
name|OHCI_NO_EDS
operator|/
literal|2
operator|)
index|]
operator|->
name|ed_self
expr_stmt|;
block|}
comment|/* flush all cache into memory */
name|usb_bus_mem_flush_all
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
operator|&
name|ohci_iterate_hw_softc
argument_list|)
expr_stmt|;
comment|/* set up the bus struct */
name|sc
operator|->
name|sc_bus
operator|.
name|methods
operator|=
operator|&
name|ohci_bus_methods
expr_stmt|;
name|usb_callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_rhsc
argument_list|,
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|15
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|OHCI_NO_EDS
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"ed#%d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sc
operator|->
name|sc_intr_p_last
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"iso "
argument_list|)
expr_stmt|;
name|ohci_dump_ed
argument_list|(
name|sc
operator|->
name|sc_isoc_p_last
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|sc_bus
operator|.
name|usbrev
operator|=
name|USB_REV_1_0
expr_stmt|;
if|if
condition|(
name|ohci_controller_init
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
else|else
block|{
comment|/* catch any lost interrupts */
name|ohci_do_poll
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_NORMAL_COMPLETION
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * shut down the controller when the system is going down  */
end_comment

begin_function
name|void
name|ohci_detach
parameter_list|(
name|struct
name|ohci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|usb_callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_rhsc
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|,
name|OHCI_ALL_INTRS
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_RESET
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* XXX let stray task complete */
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
name|usb_callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_rhsc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NOTE: suspend/resume is called from  * interrupt context and cannot sleep!  */
end_comment

begin_function
name|void
name|ohci_suspend
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ctl
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ohcidebug
operator|>
literal|2
condition|)
block|{
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ctl
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
operator|&
operator|~
name|OHCI_HCFS_MASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_control
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Preserve register values, in case that APM BIOS 		 * does not recover them. 		 */
name|sc
operator|->
name|sc_control
operator|=
name|ctl
expr_stmt|;
name|sc
operator|->
name|sc_intre
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_ENABLE
argument_list|)
expr_stmt|;
block|}
name|ctl
operator||=
name|OHCI_HCFS_SUSPEND
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_RESUME_WAIT
argument_list|)
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ohci_resume
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ctl
decl_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ohcidebug
operator|>
literal|2
condition|)
block|{
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* some broken BIOSes never initialize the Controller chip */
name|ohci_controller_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_intre
condition|)
block|{
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_ENABLE
argument_list|,
name|sc
operator|->
name|sc_intre
operator|&
operator|(
name|OHCI_ALL_INTRS
operator||
name|OHCI_MIE
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_control
condition|)
name|ctl
operator|=
name|sc
operator|->
name|sc_control
expr_stmt|;
else|else
name|ctl
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
name|ctl
operator||=
name|OHCI_HCFS_RESUME
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_RESUME_DELAY
argument_list|)
argument_list|)
expr_stmt|;
name|ctl
operator|=
operator|(
name|ctl
operator|&
operator|~
name|OHCI_HCFS_MASK
operator|)
operator||
name|OHCI_HCFS_OPERATIONAL
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_RESUME_RECOVERY
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_control
operator|=
name|sc
operator|->
name|sc_intre
operator|=
literal|0
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* catch any lost interrupts */
name|ohci_do_poll
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ohci_dumpregs
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ohci_hcca
modifier|*
name|hcca
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\n"
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_REVISION
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"               intrstat=0x%08x intre=0x%08x intrd=0x%08x\n"
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_ENABLE
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\n"
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCA
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_PERIOD_CURRENT_ED
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL_HEAD_ED
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\n"
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL_CURRENT_ED
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_BULK_HEAD_ED
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_BULK_CURRENT_ED
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"               done=0x%08x fmival=0x%08x fmrem=0x%08x\n"
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_DONE_HEAD
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_INTERVAL
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_REMAINING
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\n"
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_FM_NUMBER
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_PERIODIC_START
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_LS_THRESHOLD
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"               desca=0x%08x descb=0x%08x stat=0x%08x\n"
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_B
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"               port1=0x%08x port2=0x%08x\n"
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_PORT_STATUS
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_PORT_STATUS
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|hcca
operator|=
name|ohci_get_hcca
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"         HCCA: frame_number=0x%04x done_head=0x%08x\n"
argument_list|,
name|le32toh
argument_list|(
name|hcca
operator|->
name|hcca_frame_number
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|hcca
operator|->
name|hcca_done_head
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_dump_tds
parameter_list|(
name|ohci_td_t
modifier|*
name|std
parameter_list|)
block|{
for|for
control|(
init|;
name|std
condition|;
name|std
operator|=
name|std
operator|->
name|obj_next
control|)
block|{
if|if
condition|(
name|ohci_dump_td
argument_list|(
name|std
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|ohci_dump_td
parameter_list|(
name|ohci_td_t
modifier|*
name|std
parameter_list|)
block|{
name|uint32_t
name|td_flags
decl_stmt|;
name|uint8_t
name|temp
decl_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|std
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|td_flags
operator|=
name|le32toh
argument_list|(
name|std
operator|->
name|td_flags
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|std
operator|->
name|td_next
operator|==
literal|0
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"TD(%p) at 0x%08x: %s%s%s%s%s delay=%d ec=%d "
literal|"cc=%d\ncbp=0x%08x next=0x%08x be=0x%08x\n"
argument_list|,
name|std
argument_list|,
name|le32toh
argument_list|(
name|std
operator|->
name|td_self
argument_list|)
argument_list|,
operator|(
name|td_flags
operator|&
name|OHCI_TD_R
operator|)
condition|?
literal|"-R"
else|:
literal|""
argument_list|,
operator|(
name|td_flags
operator|&
name|OHCI_TD_OUT
operator|)
condition|?
literal|"-OUT"
else|:
literal|""
argument_list|,
operator|(
name|td_flags
operator|&
name|OHCI_TD_IN
operator|)
condition|?
literal|"-IN"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|td_flags
operator|&
name|OHCI_TD_TOGGLE_MASK
operator|)
operator|==
name|OHCI_TD_TOGGLE_1
operator|)
condition|?
literal|"-TOG1"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|td_flags
operator|&
name|OHCI_TD_TOGGLE_MASK
operator|)
operator|==
name|OHCI_TD_TOGGLE_0
operator|)
condition|?
literal|"-TOG0"
else|:
literal|""
argument_list|,
name|OHCI_TD_GET_DI
argument_list|(
name|td_flags
argument_list|)
argument_list|,
name|OHCI_TD_GET_EC
argument_list|(
name|td_flags
argument_list|)
argument_list|,
name|OHCI_TD_GET_CC
argument_list|(
name|td_flags
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|std
operator|->
name|td_cbp
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|std
operator|->
name|td_next
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|std
operator|->
name|td_be
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|ohci_dump_itd
parameter_list|(
name|ohci_itd_t
modifier|*
name|sitd
parameter_list|)
block|{
name|uint32_t
name|itd_flags
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint8_t
name|temp
decl_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|sitd
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|itd_flags
operator|=
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd_flags
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|sitd
operator|->
name|itd_next
operator|==
literal|0
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"ITD(%p) at 0x%08x: sf=%d di=%d fc=%d cc=%d\n"
literal|"bp0=0x%08x next=0x%08x be=0x%08x\n"
argument_list|,
name|sitd
argument_list|,
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd_self
argument_list|)
argument_list|,
name|OHCI_ITD_GET_SF
argument_list|(
name|itd_flags
argument_list|)
argument_list|,
name|OHCI_ITD_GET_DI
argument_list|(
name|itd_flags
argument_list|)
argument_list|,
name|OHCI_ITD_GET_FC
argument_list|(
name|itd_flags
argument_list|)
argument_list|,
name|OHCI_ITD_GET_CC
argument_list|(
name|itd_flags
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd_bp0
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd_next
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|sitd
operator|->
name|itd_be
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OHCI_ITD_NOFFSET
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"offs[%d]=0x%04x "
argument_list|,
name|i
argument_list|,
operator|(
name|uint32_t
operator|)
name|le16toh
argument_list|(
name|sitd
operator|->
name|itd_offset
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_dump_itds
parameter_list|(
name|ohci_itd_t
modifier|*
name|sitd
parameter_list|)
block|{
for|for
control|(
init|;
name|sitd
condition|;
name|sitd
operator|=
name|sitd
operator|->
name|obj_next
control|)
block|{
if|if
condition|(
name|ohci_dump_itd
argument_list|(
name|sitd
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_dump_ed
parameter_list|(
name|ohci_ed_t
modifier|*
name|sed
parameter_list|)
block|{
name|uint32_t
name|ed_flags
decl_stmt|;
name|uint32_t
name|ed_headp
decl_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|sed
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|ed_flags
operator|=
name|le32toh
argument_list|(
name|sed
operator|->
name|ed_flags
argument_list|)
expr_stmt|;
name|ed_headp
operator|=
name|le32toh
argument_list|(
name|sed
operator|->
name|ed_headp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ED(%p) at 0x%08x: addr=%d endpt=%d maxp=%d flags=%s%s%s%s%s\n"
literal|"tailp=0x%08x headflags=%s%s headp=0x%08x nexted=0x%08x\n"
argument_list|,
name|sed
argument_list|,
name|le32toh
argument_list|(
name|sed
operator|->
name|ed_self
argument_list|)
argument_list|,
name|OHCI_ED_GET_FA
argument_list|(
name|ed_flags
argument_list|)
argument_list|,
name|OHCI_ED_GET_EN
argument_list|(
name|ed_flags
argument_list|)
argument_list|,
name|OHCI_ED_GET_MAXP
argument_list|(
name|ed_flags
argument_list|)
argument_list|,
operator|(
name|ed_flags
operator|&
name|OHCI_ED_DIR_OUT
operator|)
condition|?
literal|"-OUT"
else|:
literal|""
argument_list|,
operator|(
name|ed_flags
operator|&
name|OHCI_ED_DIR_IN
operator|)
condition|?
literal|"-IN"
else|:
literal|""
argument_list|,
operator|(
name|ed_flags
operator|&
name|OHCI_ED_SPEED
operator|)
condition|?
literal|"-LOWSPEED"
else|:
literal|""
argument_list|,
operator|(
name|ed_flags
operator|&
name|OHCI_ED_SKIP
operator|)
condition|?
literal|"-SKIP"
else|:
literal|""
argument_list|,
operator|(
name|ed_flags
operator|&
name|OHCI_ED_FORMAT_ISO
operator|)
condition|?
literal|"-ISO"
else|:
literal|""
argument_list|,
name|le32toh
argument_list|(
name|sed
operator|->
name|ed_tailp
argument_list|)
argument_list|,
operator|(
name|ed_headp
operator|&
name|OHCI_HALTED
operator|)
condition|?
literal|"-HALTED"
else|:
literal|""
argument_list|,
operator|(
name|ed_headp
operator|&
name|OHCI_TOGGLECARRY
operator|)
condition|?
literal|"-CARRY"
else|:
literal|""
argument_list|,
name|le32toh
argument_list|(
name|sed
operator|->
name|ed_headp
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|sed
operator|->
name|ed_next
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ohci_transfer_intr_enqueue
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/* check for early completion */
if|if
condition|(
name|ohci_check_transfer
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* put transfer on interrupt queue */
name|usbd_transfer_enqueue
argument_list|(
operator|&
name|xfer
operator|->
name|xroot
operator|->
name|bus
operator|->
name|intr_q
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
comment|/* start timeout, if any */
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|!=
literal|0
condition|)
block|{
name|usbd_transfer_timeout_ms
argument_list|(
name|xfer
argument_list|,
operator|&
name|ohci_timeout
argument_list|,
name|xfer
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|OHCI_APPEND_QH
parameter_list|(
name|sed
parameter_list|,
name|last
parameter_list|)
value|(last) = _ohci_append_qh(sed,last)
end_define

begin_function
specifier|static
name|ohci_ed_t
modifier|*
name|_ohci_append_qh
parameter_list|(
name|ohci_ed_t
modifier|*
name|sed
parameter_list|,
name|ohci_ed_t
modifier|*
name|last
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"%p to %p\n"
argument_list|,
name|sed
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|sed
operator|->
name|prev
operator|!=
name|NULL
condition|)
block|{
comment|/* should not happen */
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"ED already linked!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|last
operator|)
return|;
block|}
comment|/* (sc->sc_bus.bus_mtx) must be locked */
name|sed
operator|->
name|next
operator|=
name|last
operator|->
name|next
expr_stmt|;
name|sed
operator|->
name|ed_next
operator|=
name|last
operator|->
name|ed_next
expr_stmt|;
name|sed
operator|->
name|ed_tailp
operator|=
literal|0
expr_stmt|;
name|sed
operator|->
name|prev
operator|=
name|last
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|sed
operator|->
name|page_cache
argument_list|)
expr_stmt|;
comment|/* 	 * the last->next->prev is never followed: sed->next->prev = sed; 	 */
name|last
operator|->
name|next
operator|=
name|sed
expr_stmt|;
name|last
operator|->
name|ed_next
operator|=
name|sed
operator|->
name|ed_self
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|last
operator|->
name|page_cache
argument_list|)
expr_stmt|;
return|return
operator|(
name|sed
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OHCI_REMOVE_QH
parameter_list|(
name|sed
parameter_list|,
name|last
parameter_list|)
value|(last) = _ohci_remove_qh(sed,last)
end_define

begin_function
specifier|static
name|ohci_ed_t
modifier|*
name|_ohci_remove_qh
parameter_list|(
name|ohci_ed_t
modifier|*
name|sed
parameter_list|,
name|ohci_ed_t
modifier|*
name|last
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"%p from %p\n"
argument_list|,
name|sed
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* (sc->sc_bus.bus_mtx) must be locked */
comment|/* only remove if not removed from a queue */
if|if
condition|(
name|sed
operator|->
name|prev
condition|)
block|{
name|sed
operator|->
name|prev
operator|->
name|next
operator|=
name|sed
operator|->
name|next
expr_stmt|;
name|sed
operator|->
name|prev
operator|->
name|ed_next
operator|=
name|sed
operator|->
name|ed_next
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|sed
operator|->
name|prev
operator|->
name|page_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|sed
operator|->
name|next
condition|)
block|{
name|sed
operator|->
name|next
operator|->
name|prev
operator|=
name|sed
operator|->
name|prev
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|sed
operator|->
name|next
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
operator|(
operator|(
name|last
operator|==
name|sed
operator|)
condition|?
name|sed
operator|->
name|prev
else|:
name|last
operator|)
expr_stmt|;
name|sed
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|sed
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|last
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_isoc_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uint8_t
name|nframes
decl_stmt|;
name|uint32_t
modifier|*
name|plen
init|=
name|xfer
operator|->
name|frlengths
decl_stmt|;
specifier|volatile
name|uint16_t
modifier|*
name|olen
decl_stmt|;
name|uint16_t
name|len
init|=
literal|0
decl_stmt|;
name|ohci_itd_t
modifier|*
name|td
init|=
name|xfer
operator|->
name|td_transfer_first
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"%s:%d: out of TD's\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|5
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"isoc TD\n"
argument_list|)
expr_stmt|;
name|ohci_dump_itd
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|nframes
operator|=
name|td
operator|->
name|frames
expr_stmt|;
name|olen
operator|=
operator|&
name|td
operator|->
name|itd_offset
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|nframes
operator|>
literal|8
condition|)
block|{
name|nframes
operator|=
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|nframes
operator|--
condition|)
block|{
name|len
operator|=
name|le16toh
argument_list|(
operator|*
name|olen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|>>
literal|12
operator|)
operator|==
name|OHCI_CC_NOT_ACCESSED
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|len
operator|&=
operator|(
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
operator|*
name|plen
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
comment|/* invalid length */
block|}
operator|*
name|plen
operator|=
name|len
expr_stmt|;
name|plen
operator|++
expr_stmt|;
name|olen
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|void
operator|*
operator|)
name|td
operator|)
operator|==
name|xfer
operator|->
name|td_transfer_last
condition|)
block|{
break|break;
block|}
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
block|}
name|xfer
operator|->
name|aframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
name|ohci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_NORMAL_COMPLETION
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ohci_cc_strs
index|[]
init|=
block|{
literal|"NO_ERROR"
block|,
literal|"CRC"
block|,
literal|"BIT_STUFFING"
block|,
literal|"DATA_TOGGLE_MISMATCH"
block|,
literal|"STALL"
block|,
literal|"DEVICE_NOT_RESPONDING"
block|,
literal|"PID_CHECK_FAILURE"
block|,
literal|"UNEXPECTED_PID"
block|,
literal|"DATA_OVERRUN"
block|,
literal|"DATA_UNDERRUN"
block|,
literal|"BUFFER_OVERRUN"
block|,
literal|"BUFFER_UNDERRUN"
block|,
literal|"reserved"
block|,
literal|"reserved"
block|,
literal|"NOT_ACCESSED"
block|,
literal|"NOT_ACCESSED"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|usb_error_t
name|ohci_non_isoc_done_sub
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ohci_td_t
modifier|*
name|td
decl_stmt|;
name|ohci_td_t
modifier|*
name|td_alt_next
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|phy_start
decl_stmt|;
name|uint32_t
name|phy_end
decl_stmt|;
name|uint32_t
name|td_flags
decl_stmt|;
name|uint16_t
name|cc
decl_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
name|td_alt_next
operator|=
name|td
operator|->
name|alt_next
expr_stmt|;
name|td_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
name|xfer
operator|->
name|aframes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|phy_start
operator|=
name|le32toh
argument_list|(
name|td
operator|->
name|td_cbp
argument_list|)
expr_stmt|;
name|td_flags
operator|=
name|le32toh
argument_list|(
name|td
operator|->
name|td_flags
argument_list|)
expr_stmt|;
name|cc
operator|=
name|OHCI_TD_GET_CC
argument_list|(
name|td_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_start
condition|)
block|{
comment|/* 			 * short transfer - compute the number of remaining 			 * bytes in the hardware buffer: 			 */
name|phy_end
operator|=
name|le32toh
argument_list|(
name|td
operator|->
name|td_be
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|OHCI_PAGE
argument_list|(
name|phy_start
operator|^
name|phy_end
argument_list|)
condition|?
operator|(
name|OHCI_PAGE_SIZE
operator|+
literal|1
operator|)
else|:
literal|0x0001
operator|)
expr_stmt|;
name|temp
operator|+=
name|OHCI_PAGE_OFFSET
argument_list|(
name|phy_end
argument_list|)
expr_stmt|;
name|temp
operator|-=
name|OHCI_PAGE_OFFSET
argument_list|(
name|phy_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
name|td
operator|->
name|len
condition|)
block|{
comment|/* guard against corruption */
name|cc
operator|=
name|OHCI_CC_STALL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
comment|/* 				 * Sum up total transfer length 				 * in "frlengths[]": 				 */
name|xfer
operator|->
name|frlengths
index|[
name|xfer
operator|->
name|aframes
index|]
operator|+=
name|td
operator|->
name|len
operator|-
name|temp
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
comment|/* transfer was complete */
name|xfer
operator|->
name|frlengths
index|[
name|xfer
operator|->
name|aframes
index|]
operator|+=
name|td
operator|->
name|len
expr_stmt|;
block|}
block|}
comment|/* Check for last transfer */
if|if
condition|(
operator|(
operator|(
name|void
operator|*
operator|)
name|td
operator|)
operator|==
name|xfer
operator|->
name|td_transfer_last
condition|)
block|{
name|td
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Check transfer status */
if|if
condition|(
name|cc
condition|)
block|{
comment|/* the transfer is finished */
name|td
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Check for short transfer */
if|if
condition|(
name|phy_start
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
condition|)
block|{
comment|/* follow alt next */
name|td
operator|=
name|td
operator|->
name|alt_next
expr_stmt|;
block|}
else|else
block|{
comment|/* the transfer is finished */
name|td
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|alt_next
operator|!=
name|td_alt_next
condition|)
block|{
comment|/* this USB frame is complete */
break|break;
block|}
block|}
comment|/* update transfer cache */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|16
argument_list|,
literal|"error cc=%d (%s)\n"
argument_list|,
name|cc
argument_list|,
name|ohci_cc_strs
index|[
name|cc
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|cc
operator|==
literal|0
operator|)
condition|?
name|USB_ERR_NORMAL_COMPLETION
else|:
operator|(
name|cc
operator|==
name|OHCI_CC_STALL
operator|)
condition|?
name|USB_ERR_STALLED
else|:
name|USB_ERR_IOERROR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_non_isoc_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|usb_error_t
name|err
init|=
literal|0
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p endpoint=%p transfer done\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|10
condition|)
block|{
name|ohci_dump_tds
argument_list|(
name|xfer
operator|->
name|td_transfer_first
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* reset scanner */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|xfer
operator|->
name|td_transfer_first
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
condition|)
block|{
name|err
operator|=
name|ohci_non_isoc_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|aframes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|td_transfer_cache
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
while|while
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
name|err
operator|=
name|ohci_non_isoc_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|aframes
operator|++
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|td_transfer_cache
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|&&
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
name|err
operator|=
name|ohci_non_isoc_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|ohci_device_done
argument_list|(
name|xfer
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ohci_check_transfer_sub  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ohci_check_transfer_sub
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ohci_td_t
modifier|*
name|td
decl_stmt|;
name|ohci_ed_t
modifier|*
name|ed
decl_stmt|;
name|uint32_t
name|phy_start
decl_stmt|;
name|uint32_t
name|td_flags
decl_stmt|;
name|uint32_t
name|td_next
decl_stmt|;
name|uint16_t
name|cc
decl_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|phy_start
operator|=
name|le32toh
argument_list|(
name|td
operator|->
name|td_cbp
argument_list|)
expr_stmt|;
name|td_flags
operator|=
name|le32toh
argument_list|(
name|td
operator|->
name|td_flags
argument_list|)
expr_stmt|;
name|td_next
operator|=
name|le32toh
argument_list|(
name|td
operator|->
name|td_next
argument_list|)
expr_stmt|;
comment|/* Check for last transfer */
if|if
condition|(
operator|(
operator|(
name|void
operator|*
operator|)
name|td
operator|)
operator|==
name|xfer
operator|->
name|td_transfer_last
condition|)
block|{
comment|/* the transfer is finished */
name|td
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Check transfer status */
name|cc
operator|=
name|OHCI_TD_GET_CC
argument_list|(
name|td_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
condition|)
block|{
comment|/* the transfer is finished */
name|td
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* 	         * Check if we reached the last packet 	         * or if there is a short packet: 	         */
if|if
condition|(
operator|(
operator|(
name|td_next
operator|&
operator|(
operator|~
literal|0xF
operator|)
operator|)
operator|==
name|OHCI_TD_NEXT_END
operator|)
operator|||
name|phy_start
condition|)
block|{
comment|/* follow alt next */
name|td
operator|=
name|td
operator|->
name|alt_next
expr_stmt|;
break|break;
block|}
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
block|}
comment|/* update transfer cache */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
if|if
condition|(
name|td
condition|)
block|{
name|ed
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|ed
operator|->
name|ed_headp
operator|=
name|td
operator|->
name|td_self
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|ed
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p following alt next\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure that the OHCI re-scans the schedule by 		 * writing the BLF and CLF bits: 		 */
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|flags
operator|.
name|self_suspended
condition|)
block|{
comment|/* nothing to do */
block|}
elseif|else
if|if
condition|(
name|xfer
operator|->
name|endpoint
operator|->
name|methods
operator|==
operator|&
name|ohci_device_bulk_methods
condition|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_BLF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfer
operator|->
name|endpoint
operator|->
name|methods
operator|==
operator|&
name|ohci_device_ctrl_methods
condition|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_CLF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ohci_check_transfer  *  * Return values:  *    0: USB transfer is not finished  * Else: USB transfer is finished  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ohci_check_transfer
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ohci_ed_t
modifier|*
name|ed
decl_stmt|;
name|uint32_t
name|ed_headp
decl_stmt|;
name|uint32_t
name|ed_tailp
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p checking transfer\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|ed
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|ed
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|ed_headp
operator|=
name|le32toh
argument_list|(
name|ed
operator|->
name|ed_headp
argument_list|)
expr_stmt|;
name|ed_tailp
operator|=
name|le32toh
argument_list|(
name|ed
operator|->
name|ed_tailp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ed_headp
operator|&
name|OHCI_HALTED
operator|)
operator|||
operator|(
operator|(
operator|(
name|ed_headp
operator|^
name|ed_tailp
operator|)
operator|&
operator|(
operator|~
literal|0xF
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|endpoint
operator|->
name|methods
operator|==
operator|&
name|ohci_device_isoc_methods
condition|)
block|{
comment|/* isochronous transfer */
name|ohci_isoc_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
condition|)
block|{
name|ohci_check_transfer_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|td_transfer_cache
condition|)
block|{
comment|/* not finished yet */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* store data-toggle */
if|if
condition|(
name|ed_headp
operator|&
name|OHCI_TOGGLECARRY
condition|)
block|{
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
operator|=
literal|0
expr_stmt|;
block|}
comment|/* non-isochronous transfer */
name|ohci_non_isoc_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p is still active\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_rhsc_enable
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_eintrs
operator||=
name|OHCI_RHSC
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_ENABLE
argument_list|,
name|OHCI_RHSC
argument_list|)
expr_stmt|;
comment|/* acknowledge any RHSC interrupt */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|,
name|OHCI_RHSC
argument_list|)
expr_stmt|;
name|ohci_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_interrupt_poll
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|repeat
label|:
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
comment|/* 		 * check if transfer is transferred 		 */
if|if
condition|(
name|ohci_check_transfer
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
comment|/* queue has been modified */
goto|goto
name|repeat
goto|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ohci_interrupt - OHCI interrupt handler  *  * NOTE: Do not access "sc->sc_bus.bdev" inside the interrupt handler,  * hence the interrupt handler will be setup before "sc->sc_bus.bdev"  * is present !  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|ohci_interrupt
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ohci_hcca
modifier|*
name|hcca
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|done
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|hcca
operator|=
name|ohci_get_hcca
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|16
argument_list|,
literal|"real interrupt\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|15
condition|)
block|{
name|ohci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|done
operator|=
name|le32toh
argument_list|(
name|hcca
operator|->
name|hcca_done_head
argument_list|)
expr_stmt|;
comment|/* 	 * The LSb of done is used to inform the HC Driver that an interrupt 	 * condition exists for both the Done list and for another event 	 * recorded in HcInterruptStatus. On an interrupt from the HC, the 	 * HC Driver checks the HccaDoneHead Value. If this value is 0, then 	 * the interrupt was caused by other than the HccaDoneHead update 	 * and the HcInterruptStatus register needs to be accessed to 	 * determine that exact interrupt cause. If HccaDoneHead is nonzero, 	 * then a Done list update interrupt is indicated and if the LSb of 	 * done is nonzero, then an additional interrupt event is indicated 	 * and HcInterruptStatus should be checked to determine its cause. 	 */
if|if
condition|(
name|done
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|done
operator|&
operator|~
name|OHCI_DONE_INTRS
condition|)
block|{
name|status
operator||=
name|OHCI_WDH
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|&
name|OHCI_DONE_INTRS
condition|)
block|{
name|status
operator||=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
expr_stmt|;
block|}
name|hcca
operator|->
name|hcca_done_head
operator|=
literal|0
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|hcca_pc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|)
operator|&
operator|~
name|OHCI_WDH
expr_stmt|;
block|}
name|status
operator|&=
operator|~
name|OHCI_MIE
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* 		 * nothing to be done (PCI shared 		 * interrupt) 		 */
goto|goto
name|done
goto|;
block|}
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_STATUS
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Acknowledge */
name|status
operator|&=
name|sc
operator|->
name|sc_eintrs
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|status
operator|&
operator|(
name|OHCI_SO
operator||
name|OHCI_RD
operator||
name|OHCI_UE
operator||
name|OHCI_RHSC
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (status& OHCI_SO) {
comment|/* XXX do what */
block|}
endif|#
directive|endif
if|if
condition|(
name|status
operator|&
name|OHCI_RD
condition|)
block|{
name|printf
argument_list|(
literal|"%s: resume detect\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* XXX process resume detect */
block|}
if|if
condition|(
name|status
operator|&
name|OHCI_UE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unrecoverable error, "
literal|"controller halted\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_RESET
argument_list|)
expr_stmt|;
comment|/* XXX what else */
block|}
if|if
condition|(
name|status
operator|&
name|OHCI_RHSC
condition|)
block|{
comment|/* 			 * Disable RHSC interrupt for now, because it will be 			 * on until the port has been reset. 			 */
name|sc
operator|->
name|sc_eintrs
operator|&=
operator|~
name|OHCI_RHSC
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|,
name|OHCI_RHSC
argument_list|)
expr_stmt|;
name|ohci_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* do not allow RHSC interrupts> 1 per second */
name|usb_callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_rhsc
argument_list|,
name|hz
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ohci_rhsc_enable
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|status
operator|&=
operator|~
operator|(
name|OHCI_RHSC
operator||
name|OHCI_WDH
operator||
name|OHCI_SO
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
comment|/* Block unprocessed interrupts. XXX */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_eintrs
operator|&=
operator|~
name|status
expr_stmt|;
name|printf
argument_list|(
literal|"%s: blocking intrs 0x%x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* poll all the USB transfers */
name|ohci_interrupt_poll
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|done
label|:
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * called when a request does not complete  */
end_comment

begin_function
specifier|static
name|void
name|ohci_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
init|=
name|arg
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"xfer=%p\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* transfer is transferred */
name|ohci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_TIMEOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_do_poll
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|ohci_softc
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|ohci_interrupt_poll
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_setup_standard_chain_sub
parameter_list|(
name|struct
name|ohci_std_temp
modifier|*
name|temp
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|ohci_td_t
modifier|*
name|td
decl_stmt|;
name|ohci_td_t
modifier|*
name|td_next
decl_stmt|;
name|ohci_td_t
modifier|*
name|td_alt_next
decl_stmt|;
name|uint32_t
name|buf_offset
decl_stmt|;
name|uint32_t
name|average
decl_stmt|;
name|uint32_t
name|len_old
decl_stmt|;
name|uint8_t
name|shortpkt_old
decl_stmt|;
name|uint8_t
name|precompute
decl_stmt|;
name|td_alt_next
operator|=
name|NULL
expr_stmt|;
name|buf_offset
operator|=
literal|0
expr_stmt|;
name|shortpkt_old
operator|=
name|temp
operator|->
name|shortpkt
expr_stmt|;
name|len_old
operator|=
name|temp
operator|->
name|len
expr_stmt|;
name|precompute
operator|=
literal|1
expr_stmt|;
comment|/* software is used to detect short incoming transfers */
if|if
condition|(
operator|(
name|temp
operator|->
name|td_flags
operator|&
name|htole32
argument_list|(
name|OHCI_TD_DP_MASK
argument_list|)
operator|)
operator|==
name|htole32
argument_list|(
name|OHCI_TD_IN
argument_list|)
condition|)
block|{
name|temp
operator|->
name|td_flags
operator||=
name|htole32
argument_list|(
name|OHCI_TD_R
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|->
name|td_flags
operator|&=
operator|~
name|htole32
argument_list|(
name|OHCI_TD_R
argument_list|)
expr_stmt|;
block|}
name|restart
label|:
name|td
operator|=
name|temp
operator|->
name|td
expr_stmt|;
name|td_next
operator|=
name|temp
operator|->
name|td_next
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|shortpkt
condition|)
block|{
break|break;
block|}
comment|/* send a Zero Length Packet, ZLP, last */
name|temp
operator|->
name|shortpkt
operator|=
literal|1
expr_stmt|;
name|average
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|average
operator|=
name|temp
operator|->
name|average
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|len
operator|<
name|average
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|len
operator|%
name|temp
operator|->
name|max_frame_size
condition|)
block|{
name|temp
operator|->
name|shortpkt
operator|=
literal|1
expr_stmt|;
block|}
name|average
operator|=
name|temp
operator|->
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|td_next
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"%s: out of OHCI transfer descriptors!"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
comment|/* get next TD */
name|td
operator|=
name|td_next
expr_stmt|;
name|td_next
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
comment|/* check if we are pre-computing */
if|if
condition|(
name|precompute
condition|)
block|{
comment|/* update remaining length */
name|temp
operator|->
name|len
operator|-=
name|average
expr_stmt|;
continue|continue;
block|}
comment|/* fill out current TD */
name|td
operator|->
name|td_flags
operator|=
name|temp
operator|->
name|td_flags
expr_stmt|;
comment|/* the next TD uses TOGGLE_CARRY */
name|temp
operator|->
name|td_flags
operator|&=
operator|~
name|htole32
argument_list|(
name|OHCI_TD_TOGGLE_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|average
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The buffer start and end phys addresses should be 			 * 0x0 for a zero length packet. 			 */
name|td
operator|->
name|td_cbp
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_be
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|usbd_get_page
argument_list|(
name|temp
operator|->
name|pc
argument_list|,
name|buf_offset
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_cbp
operator|=
name|htole32
argument_list|(
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|buf_offset
operator|+=
operator|(
name|average
operator|-
literal|1
operator|)
expr_stmt|;
name|usbd_get_page
argument_list|(
name|temp
operator|->
name|pc
argument_list|,
name|buf_offset
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_be
operator|=
name|htole32
argument_list|(
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|buf_offset
operator|++
expr_stmt|;
name|td
operator|->
name|len
operator|=
name|average
expr_stmt|;
comment|/* update remaining length */
name|temp
operator|->
name|len
operator|-=
name|average
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|td_next
operator|==
name|td_alt_next
operator|)
operator|&&
name|temp
operator|->
name|setup_alt_next
condition|)
block|{
comment|/* we need to receive these frames one by one ! */
name|td
operator|->
name|td_flags
operator|&=
name|htole32
argument_list|(
operator|~
name|OHCI_TD_INTR_MASK
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|htole32
argument_list|(
name|OHCI_TD_SET_DI
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_next
operator|=
name|htole32
argument_list|(
name|OHCI_TD_NEXT_END
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|td_next
condition|)
block|{
comment|/* link the current TD with the next one */
name|td
operator|->
name|td_next
operator|=
name|td_next
operator|->
name|td_self
expr_stmt|;
block|}
block|}
name|td
operator|->
name|alt_next
operator|=
name|td_alt_next
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|precompute
condition|)
block|{
name|precompute
operator|=
literal|0
expr_stmt|;
comment|/* setup alt next pointer, if any */
if|if
condition|(
name|temp
operator|->
name|last_frame
condition|)
block|{
comment|/* no alternate next */
name|td_alt_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* we use this field internally */
name|td_alt_next
operator|=
name|td_next
expr_stmt|;
block|}
comment|/* restore */
name|temp
operator|->
name|shortpkt
operator|=
name|shortpkt_old
expr_stmt|;
name|temp
operator|->
name|len
operator|=
name|len_old
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|temp
operator|->
name|td
operator|=
name|td
expr_stmt|;
name|temp
operator|->
name|td_next
operator|=
name|td_next
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_setup_standard_chain
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|ohci_ed_t
modifier|*
modifier|*
name|ed_last
parameter_list|)
block|{
name|struct
name|ohci_std_temp
name|temp
decl_stmt|;
name|struct
name|usb_pipe_methods
modifier|*
name|methods
decl_stmt|;
name|ohci_ed_t
modifier|*
name|ed
decl_stmt|;
name|ohci_td_t
modifier|*
name|td
decl_stmt|;
name|uint32_t
name|ed_flags
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"addr=%d endpt=%d sumlen=%d speed=%d\n"
argument_list|,
name|xfer
operator|->
name|address
argument_list|,
name|UE_GET_ADDR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
argument_list|,
name|xfer
operator|->
name|sumlen
argument_list|,
name|usbd_get_speed
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|average
operator|=
name|xfer
operator|->
name|max_hc_frame_size
expr_stmt|;
name|temp
operator|.
name|max_frame_size
operator|=
name|xfer
operator|->
name|max_frame_size
expr_stmt|;
comment|/* toggle the DMA set we are using */
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
operator|^=
literal|1
expr_stmt|;
comment|/* get next DMA set */
name|td
operator|=
name|xfer
operator|->
name|td_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|xfer
operator|->
name|td_transfer_first
operator|=
name|td
expr_stmt|;
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
name|temp
operator|.
name|td
operator|=
name|NULL
expr_stmt|;
name|temp
operator|.
name|td_next
operator|=
name|td
expr_stmt|;
name|temp
operator|.
name|last_frame
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
expr_stmt|;
name|methods
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|methods
expr_stmt|;
comment|/* check if we should prepend a setup message */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
condition|)
block|{
name|temp
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
name|OHCI_TD_SETUP
operator||
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_TOGGLE_0
operator||
name|OHCI_TD_NOINTR
argument_list|)
expr_stmt|;
name|temp
operator|.
name|len
operator|=
name|xfer
operator|->
name|frlengths
index|[
literal|0
index|]
expr_stmt|;
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
literal|0
expr_stmt|;
name|temp
operator|.
name|shortpkt
operator|=
name|temp
operator|.
name|len
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* check for last frame */
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|==
literal|1
condition|)
block|{
comment|/* no STATUS stage yet, SETUP is last */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|ohci_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
comment|/* 			 * XXX assume that the setup message is 			 * contained within one USB packet: 			 */
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
operator|=
literal|1
expr_stmt|;
block|}
name|x
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
literal|0
expr_stmt|;
block|}
name|temp
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_NOINTR
argument_list|)
expr_stmt|;
comment|/* set data toggle */
if|if
condition|(
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
condition|)
block|{
name|temp
operator|.
name|td_flags
operator||=
name|htole32
argument_list|(
name|OHCI_TD_TOGGLE_1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|.
name|td_flags
operator||=
name|htole32
argument_list|(
name|OHCI_TD_TOGGLE_0
argument_list|)
expr_stmt|;
block|}
comment|/* set endpoint direction */
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
block|{
name|temp
operator|.
name|td_flags
operator||=
name|htole32
argument_list|(
name|OHCI_TD_IN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|.
name|td_flags
operator||=
name|htole32
argument_list|(
name|OHCI_TD_OUT
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|x
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
comment|/* DATA0 / DATA1 message */
name|temp
operator|.
name|len
operator|=
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
expr_stmt|;
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
name|x
expr_stmt|;
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|xfer
operator|->
name|nframes
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
comment|/* no STATUS stage yet, DATA is last */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|temp
operator|.
name|len
operator|==
literal|0
condition|)
block|{
comment|/* make sure that we send an USB packet */
name|temp
operator|.
name|shortpkt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* regular data transfer */
name|temp
operator|.
name|shortpkt
operator|=
operator|(
name|xfer
operator|->
name|flags
operator|.
name|force_short_xfer
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
name|ohci_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* check if we should append a status stage */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|&&
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
comment|/* 		 * Send a DATA1 message and invert the current endpoint 		 * direction. 		 */
comment|/* set endpoint direction and data toggle */
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
block|{
name|temp
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
name|OHCI_TD_OUT
operator||
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_TOGGLE_1
operator||
name|OHCI_TD_SET_DI
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|.
name|td_flags
operator|=
name|htole32
argument_list|(
name|OHCI_TD_IN
operator||
name|OHCI_TD_NOCC
operator||
name|OHCI_TD_TOGGLE_1
operator||
name|OHCI_TD_SET_DI
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|temp
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|pc
operator|=
name|NULL
expr_stmt|;
name|temp
operator|.
name|shortpkt
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
name|ohci_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|td
operator|=
name|temp
operator|.
name|td
expr_stmt|;
comment|/* Ensure that last TD is terminating: */
name|td
operator|->
name|td_next
operator|=
name|htole32
argument_list|(
name|OHCI_TD_NEXT_END
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|htole32
argument_list|(
name|OHCI_TD_INTR_MASK
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|htole32
argument_list|(
name|OHCI_TD_SET_DI
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
comment|/* must have at least one frame! */
name|xfer
operator|->
name|td_transfer_last
operator|=
name|td
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|8
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"nexttog=%d; data before transfer:\n"
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
argument_list|)
expr_stmt|;
name|ohci_dump_tds
argument_list|(
name|xfer
operator|->
name|td_transfer_first
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ed
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|ed_flags
operator|=
operator|(
name|OHCI_ED_SET_FA
argument_list|(
name|xfer
operator|->
name|address
argument_list|)
operator||
name|OHCI_ED_SET_EN
argument_list|(
name|UE_GET_ADDR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
argument_list|)
operator||
name|OHCI_ED_SET_MAXP
argument_list|(
name|xfer
operator|->
name|max_frame_size
argument_list|)
operator|)
expr_stmt|;
name|ed_flags
operator||=
operator|(
name|OHCI_ED_FORMAT_GEN
operator||
name|OHCI_ED_DIR_TD
operator|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|)
block|{
name|ed_flags
operator||=
name|OHCI_ED_SPEED
expr_stmt|;
block|}
name|ed
operator|->
name|ed_flags
operator|=
name|htole32
argument_list|(
name|ed_flags
argument_list|)
expr_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_first
expr_stmt|;
name|ed
operator|->
name|ed_headp
operator|=
name|td
operator|->
name|td_self
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|flags
operator|.
name|self_suspended
operator|==
literal|0
condition|)
block|{
comment|/* the append function will flush the endpoint descriptor */
name|OHCI_APPEND_QH
argument_list|(
name|ed
argument_list|,
operator|*
name|ed_last
argument_list|)
expr_stmt|;
if|if
condition|(
name|methods
operator|==
operator|&
name|ohci_device_bulk_methods
condition|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_BLF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|ohci_device_ctrl_methods
condition|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_CLF
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|usb_pc_cpu_flush
argument_list|(
name|ed
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_root_intr
parameter_list|(
name|ohci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|hstatus
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|m
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* clear any old interrupt data */
name|memset
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|)
argument_list|)
expr_stmt|;
name|hstatus
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_STATUS
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"sc=%p hstatus=0x%08x\n"
argument_list|,
name|sc
argument_list|,
name|hstatus
argument_list|)
expr_stmt|;
comment|/* set bits */
name|m
operator|=
operator|(
name|sc
operator|->
name|sc_noport
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|>
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|)
operator|)
condition|)
block|{
name|m
operator|=
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|)
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
block|{
comment|/* pick out CHANGE bits from the status register */
if|if
condition|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_PORT_STATUS
argument_list|(
name|i
argument_list|)
argument_list|)
operator|>>
literal|16
condition|)
block|{
name|sc
operator|->
name|sc_hub_idata
index|[
name|i
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"port %d changed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|uhub_root_intr
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|sc
operator|->
name|sc_hub_idata
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NOTE: "done" can be run two times in a row,  * from close and from interrupt  */
end_comment

begin_function
specifier|static
name|void
name|ohci_device_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|usb_pipe_methods
modifier|*
name|methods
init|=
name|xfer
operator|->
name|endpoint
operator|->
name|methods
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|ohci_ed_t
modifier|*
name|ed
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"xfer=%p, endpoint=%p, error=%d\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ed
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
if|if
condition|(
name|ed
condition|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|ed
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|ohci_device_bulk_methods
condition|)
block|{
name|OHCI_REMOVE_QH
argument_list|(
name|ed
argument_list|,
name|sc
operator|->
name|sc_bulk_p_last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|ohci_device_ctrl_methods
condition|)
block|{
name|OHCI_REMOVE_QH
argument_list|(
name|ed
argument_list|,
name|sc
operator|->
name|sc_ctrl_p_last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|ohci_device_intr_methods
condition|)
block|{
name|OHCI_REMOVE_QH
argument_list|(
name|ed
argument_list|,
name|sc
operator|->
name|sc_intr_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|ohci_device_isoc_methods
condition|)
block|{
name|OHCI_REMOVE_QH
argument_list|(
name|ed
argument_list|,
name|sc
operator|->
name|sc_isoc_p_last
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|td_transfer_first
operator|=
name|NULL
expr_stmt|;
name|xfer
operator|->
name|td_transfer_last
operator|=
name|NULL
expr_stmt|;
comment|/* dequeue transfer and start next transfer */
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  * ohci bulk support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ohci_device_bulk_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_device_bulk_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ohci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_device_bulk_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_device_bulk_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
comment|/* setup TD's and QH */
name|ohci_setup_standard_chain
argument_list|(
name|xfer
argument_list|,
operator|&
name|sc
operator|->
name|sc_bulk_p_last
argument_list|)
expr_stmt|;
comment|/* put transfer on interrupt queue */
name|ohci_transfer_intr_enqueue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|ohci_device_bulk_methods
init|=
block|{
operator|.
name|open
operator|=
name|ohci_device_bulk_open
block|,
operator|.
name|close
operator|=
name|ohci_device_bulk_close
block|,
operator|.
name|enter
operator|=
name|ohci_device_bulk_enter
block|,
operator|.
name|start
operator|=
name|ohci_device_bulk_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * ohci control support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ohci_device_ctrl_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_device_ctrl_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ohci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_device_ctrl_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_device_ctrl_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
comment|/* setup TD's and QH */
name|ohci_setup_standard_chain
argument_list|(
name|xfer
argument_list|,
operator|&
name|sc
operator|->
name|sc_ctrl_p_last
argument_list|)
expr_stmt|;
comment|/* put transfer on interrupt queue */
name|ohci_transfer_intr_enqueue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|ohci_device_ctrl_methods
init|=
block|{
operator|.
name|open
operator|=
name|ohci_device_ctrl_open
block|,
operator|.
name|close
operator|=
name|ohci_device_ctrl_close
block|,
operator|.
name|enter
operator|=
name|ohci_device_ctrl_enter
block|,
operator|.
name|start
operator|=
name|ohci_device_ctrl_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * ohci interrupt support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ohci_device_intr_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uint16_t
name|best
decl_stmt|;
name|uint16_t
name|bit
decl_stmt|;
name|uint16_t
name|x
decl_stmt|;
name|best
operator|=
literal|0
expr_stmt|;
name|bit
operator|=
name|OHCI_NO_EDS
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|bit
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|interval
operator|>=
name|bit
condition|)
block|{
name|x
operator|=
name|bit
expr_stmt|;
name|best
operator|=
name|bit
expr_stmt|;
while|while
condition|(
name|x
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_intr_stat
index|[
name|x
index|]
operator|<
name|sc
operator|->
name|sc_intr_stat
index|[
name|best
index|]
condition|)
block|{
name|best
operator|=
name|x
expr_stmt|;
block|}
name|x
operator|++
expr_stmt|;
block|}
break|break;
block|}
name|bit
operator|>>=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|sc_intr_stat
index|[
name|best
index|]
operator|++
expr_stmt|;
name|xfer
operator|->
name|qh_pos
operator|=
name|best
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"best=%d interval=%d\n"
argument_list|,
name|best
argument_list|,
name|xfer
operator|->
name|interval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_device_intr_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_intr_stat
index|[
name|xfer
operator|->
name|qh_pos
index|]
operator|--
expr_stmt|;
name|ohci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_device_intr_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_device_intr_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
comment|/* setup TD's and QH */
name|ohci_setup_standard_chain
argument_list|(
name|xfer
argument_list|,
operator|&
name|sc
operator|->
name|sc_intr_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
argument_list|)
expr_stmt|;
comment|/* put transfer on interrupt queue */
name|ohci_transfer_intr_enqueue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|ohci_device_intr_methods
init|=
block|{
operator|.
name|open
operator|=
name|ohci_device_intr_open
block|,
operator|.
name|close
operator|=
name|ohci_device_intr_close
block|,
operator|.
name|enter
operator|=
name|ohci_device_intr_enter
block|,
operator|.
name|start
operator|=
name|ohci_device_intr_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * ohci isochronous support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ohci_device_isoc_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_device_isoc_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/**/
name|ohci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_device_isoc_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|ohci_hcca
modifier|*
name|hcca
decl_stmt|;
name|uint32_t
name|buf_offset
decl_stmt|;
name|uint32_t
name|nframes
decl_stmt|;
name|uint32_t
name|ed_flags
decl_stmt|;
name|uint32_t
modifier|*
name|plen
decl_stmt|;
name|uint16_t
name|itd_offset
index|[
name|OHCI_ITD_NOFFSET
index|]
decl_stmt|;
name|uint16_t
name|length
decl_stmt|;
name|uint8_t
name|ncur
decl_stmt|;
name|ohci_itd_t
modifier|*
name|td
decl_stmt|;
name|ohci_itd_t
modifier|*
name|td_last
init|=
name|NULL
decl_stmt|;
name|ohci_ed_t
modifier|*
name|ed
decl_stmt|;
name|hcca
operator|=
name|ohci_get_hcca
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nframes
operator|=
name|le32toh
argument_list|(
name|hcca
operator|->
name|hcca_frame_number
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"xfer=%p isoc_next=%u nframes=%u hcca_fn=%u\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|,
name|xfer
operator|->
name|nframes
argument_list|,
name|nframes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|nframes
operator|-
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|)
operator|&
literal|0xFFFF
operator|)
operator|<
name|xfer
operator|->
name|nframes
operator|)
operator|||
operator|(
operator|(
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|-
name|nframes
operator|)
operator|&
literal|0xFFFF
operator|)
operator|>=
literal|128
operator|)
condition|)
block|{
comment|/* 		 * If there is data underflow or the pipe queue is empty we 		 * schedule the transfer a few frames ahead of the current 		 * frame position. Else two isochronous transfers might 		 * overlap. 		 */
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|=
operator|(
name|nframes
operator|+
literal|3
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|=
literal|1
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"start next=%d\n"
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * compute how many milliseconds the insertion is ahead of the 	 * current frame position: 	 */
name|buf_offset
operator|=
operator|(
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|-
name|nframes
operator|)
operator|&
literal|0xFFFF
operator|)
expr_stmt|;
comment|/* 	 * pre-compute when the isochronous transfer will be finished: 	 */
name|xfer
operator|->
name|isoc_time_complete
operator|=
operator|(
name|usb_isoc_time_expand
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|nframes
argument_list|)
operator|+
name|buf_offset
operator|+
name|xfer
operator|->
name|nframes
operator|)
expr_stmt|;
comment|/* get the real number of frames */
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
name|buf_offset
operator|=
literal|0
expr_stmt|;
name|plen
operator|=
name|xfer
operator|->
name|frlengths
expr_stmt|;
comment|/* toggle the DMA set we are using */
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
operator|^=
literal|1
expr_stmt|;
comment|/* get next DMA set */
name|td
operator|=
name|xfer
operator|->
name|td_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|xfer
operator|->
name|td_transfer_first
operator|=
name|td
expr_stmt|;
name|ncur
operator|=
literal|0
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nframes
operator|--
condition|)
block|{
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"%s:%d: out of TD's\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|itd_offset
index|[
name|ncur
index|]
operator|=
name|length
expr_stmt|;
name|buf_offset
operator|+=
operator|*
name|plen
expr_stmt|;
name|length
operator|+=
operator|*
name|plen
expr_stmt|;
name|plen
operator|++
expr_stmt|;
name|ncur
operator|++
expr_stmt|;
if|if
condition|(
comment|/* check if the ITD is full */
operator|(
name|ncur
operator|==
name|OHCI_ITD_NOFFSET
operator|)
operator|||
comment|/* check if we have put more than 4K into the ITD */
operator|(
name|length
operator|&
literal|0xF000
operator|)
operator|||
comment|/* check if it is the last frame */
operator|(
name|nframes
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* fill current ITD */
name|td
operator|->
name|itd_flags
operator|=
name|htole32
argument_list|(
name|OHCI_ITD_NOCC
operator||
name|OHCI_ITD_SET_SF
argument_list|(
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|)
operator||
name|OHCI_ITD_NOINTR
operator||
name|OHCI_ITD_SET_FC
argument_list|(
name|ncur
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|frames
operator|=
name|ncur
expr_stmt|;
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|+=
name|ncur
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
comment|/* all zero */
name|td
operator|->
name|itd_bp0
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|itd_be
operator|=
operator|~
literal|0
expr_stmt|;
while|while
condition|(
name|ncur
operator|--
condition|)
block|{
name|td
operator|->
name|itd_offset
index|[
name|ncur
index|]
operator|=
name|htole16
argument_list|(
name|OHCI_ITD_MK_OFFS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|usbd_get_page
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|buf_offset
operator|-
name|length
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|length
operator|=
name|OHCI_PAGE_MASK
argument_list|(
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|buf_res
operator|.
name|physaddr
operator|=
name|OHCI_PAGE
argument_list|(
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|td
operator|->
name|itd_bp0
operator|=
name|htole32
argument_list|(
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|usbd_get_page
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|buf_offset
operator|-
literal|1
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|td
operator|->
name|itd_be
operator|=
name|htole32
argument_list|(
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
while|while
condition|(
name|ncur
operator|--
condition|)
block|{
name|itd_offset
index|[
name|ncur
index|]
operator|+=
name|length
expr_stmt|;
name|itd_offset
index|[
name|ncur
index|]
operator|=
name|OHCI_ITD_MK_OFFS
argument_list|(
name|itd_offset
index|[
name|ncur
index|]
argument_list|)
expr_stmt|;
name|td
operator|->
name|itd_offset
index|[
name|ncur
index|]
operator|=
name|htole16
argument_list|(
name|itd_offset
index|[
name|ncur
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|ncur
operator|=
literal|0
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
name|td_last
operator|=
name|td
expr_stmt|;
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
if|if
condition|(
name|td
condition|)
block|{
comment|/* link the last TD with the next one */
name|td_last
operator|->
name|itd_next
operator|=
name|td
operator|->
name|itd_self
expr_stmt|;
block|}
name|usb_pc_cpu_flush
argument_list|(
name|td_last
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* update the last TD */
name|td_last
operator|->
name|itd_flags
operator|&=
operator|~
name|htole32
argument_list|(
name|OHCI_ITD_NOINTR
argument_list|)
expr_stmt|;
name|td_last
operator|->
name|itd_flags
operator||=
name|htole32
argument_list|(
name|OHCI_ITD_SET_DI
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|td_last
operator|->
name|itd_next
operator|=
literal|0
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td_last
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|td_transfer_last
operator|=
name|td_last
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ohcidebug
operator|>
literal|8
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"data before transfer:\n"
argument_list|)
expr_stmt|;
name|ohci_dump_itds
argument_list|(
name|xfer
operator|->
name|td_transfer_first
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ed
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
name|ed_flags
operator|=
operator|(
name|OHCI_ED_DIR_IN
operator||
name|OHCI_ED_FORMAT_ISO
operator|)
expr_stmt|;
else|else
name|ed_flags
operator|=
operator|(
name|OHCI_ED_DIR_OUT
operator||
name|OHCI_ED_FORMAT_ISO
operator|)
expr_stmt|;
name|ed_flags
operator||=
operator|(
name|OHCI_ED_SET_FA
argument_list|(
name|xfer
operator|->
name|address
argument_list|)
operator||
name|OHCI_ED_SET_EN
argument_list|(
name|UE_GET_ADDR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
argument_list|)
operator||
name|OHCI_ED_SET_MAXP
argument_list|(
name|xfer
operator|->
name|max_frame_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|)
block|{
name|ed_flags
operator||=
name|OHCI_ED_SPEED
expr_stmt|;
block|}
name|ed
operator|->
name|ed_flags
operator|=
name|htole32
argument_list|(
name|ed_flags
argument_list|)
expr_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_first
expr_stmt|;
name|ed
operator|->
name|ed_headp
operator|=
name|td
operator|->
name|itd_self
expr_stmt|;
comment|/* isochronous transfers are not affected by suspend / resume */
comment|/* the append function will flush the endpoint descriptor */
name|OHCI_APPEND_QH
argument_list|(
name|ed
argument_list|,
name|sc
operator|->
name|sc_isoc_p_last
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_device_isoc_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/* put transfer on interrupt queue */
name|ohci_transfer_intr_enqueue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|ohci_device_isoc_methods
init|=
block|{
operator|.
name|open
operator|=
name|ohci_device_isoc_open
block|,
operator|.
name|close
operator|=
name|ohci_device_isoc_close
block|,
operator|.
name|enter
operator|=
name|ohci_device_isoc_enter
block|,
operator|.
name|start
operator|=
name|ohci_device_isoc_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * ohci root control support  *------------------------------------------------------------------------*  * Simulate a hardware hub by handling all the necessary requests.  *------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_device_descriptor
name|ohci_devd
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_descriptor
argument_list|)
block|,
name|UDESC_DEVICE
block|,
comment|/* type */
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* USB version */
name|UDCLASS_HUB
block|,
comment|/* class */
name|UDSUBCLASS_HUB
block|,
comment|/* subclass */
name|UDPROTO_FSHUB
block|,
comment|/* protocol */
literal|64
block|,
comment|/* max packet */
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* device id */
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* string indicies */
literal|1
comment|/* # of configurations */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ohci_config_desc
name|ohci_confd
init|=
block|{
operator|.
name|confd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_config_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_CONFIG
block|,
operator|.
name|wTotalLength
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|ohci_confd
argument_list|)
block|,
operator|.
name|bNumInterface
operator|=
literal|1
block|,
operator|.
name|bConfigurationValue
operator|=
literal|1
block|,
operator|.
name|iConfiguration
operator|=
literal|0
block|,
operator|.
name|bmAttributes
operator|=
name|UC_SELF_POWERED
block|,
operator|.
name|bMaxPower
operator|=
literal|0
block|,
comment|/* max power */
block|}
block|,
operator|.
name|ifcd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_interface_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_INTERFACE
block|,
operator|.
name|bNumEndpoints
operator|=
literal|1
block|,
operator|.
name|bInterfaceClass
operator|=
name|UICLASS_HUB
block|,
operator|.
name|bInterfaceSubClass
operator|=
name|UISUBCLASS_HUB
block|,
operator|.
name|bInterfaceProtocol
operator|=
name|UIPROTO_FSHUB
block|, 	}
block|,
operator|.
name|endpd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_endpoint_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_ENDPOINT
block|,
operator|.
name|bEndpointAddress
operator|=
name|UE_DIR_IN
operator||
name|OHCI_INTR_ENDPT
block|,
operator|.
name|bmAttributes
operator|=
name|UE_INTERRUPT
block|,
operator|.
name|wMaxPacketSize
index|[
literal|0
index|]
operator|=
literal|32
block|,
comment|/* max packet (255 ports) */
operator|.
name|bInterval
operator|=
literal|255
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_hub_descriptor
name|ohci_hubd
init|=
block|{
literal|0
block|,
comment|/* dynamic length */
name|UDESC_HUB
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|usb_error_t
name|ohci_roothub_exec
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_device_request
modifier|*
name|req
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|pptr
parameter_list|,
name|uint16_t
modifier|*
name|plength
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
specifier|const
name|void
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|str_ptr
decl_stmt|;
name|uint32_t
name|port
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|uint16_t
name|value
decl_stmt|;
name|uint16_t
name|index
decl_stmt|;
name|uint8_t
name|l
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* buffer reset */
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
expr_stmt|;
name|index
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"type=0x%02x request=0x%02x wLen=0x%04x "
literal|"wValue=0x%04x wIndex=0x%04x\n"
argument_list|,
name|req
operator|->
name|bmRequestType
argument_list|,
name|req
operator|->
name|bRequest
argument_list|,
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
argument_list|,
name|value
argument_list|,
name|index
argument_list|)
expr_stmt|;
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) | ((y)<< 8))
switch|switch
condition|(
name|C
argument_list|(
name|req
operator|->
name|bRequest
argument_list|,
name|req
operator|->
name|bmRequestType
argument_list|)
condition|)
block|{
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
comment|/* 		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops 		 * for the integrated root hub. 		 */
break|break;
case|case
name|C
argument_list|(
name|UR_GET_CONFIG
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
name|len
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_conf
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
switch|switch
condition|(
name|value
operator|>>
literal|8
condition|)
block|{
case|case
name|UDESC_DEVICE
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ohci_devd
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|ohci_devd
expr_stmt|;
break|break;
case|case
name|UDESC_CONFIG
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ohci_confd
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|ohci_confd
expr_stmt|;
break|break;
case|case
name|UDESC_STRING
case|:
switch|switch
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0
case|:
comment|/* Language table */
name|str_ptr
operator|=
literal|"\001"
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Vendor */
name|str_ptr
operator|=
name|sc
operator|->
name|sc_vendor
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Product */
name|str_ptr
operator|=
literal|"OHCI root HUB"
expr_stmt|;
break|break;
default|default:
name|str_ptr
operator|=
literal|""
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|usb_make_str_desc
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
argument_list|)
argument_list|,
name|str_ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_INTERFACE
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
name|len
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
name|len
operator|=
literal|2
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|stat
operator|.
name|wStatus
argument_list|,
name|UDS_SELF_POWERED
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_ENDPOINT
argument_list|)
case|:
name|len
operator|=
literal|2
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|stat
operator|.
name|wStatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_ADDRESS
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|>=
name|OHCI_MAX_DEVICES
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|sc_addr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_CONFIG
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
operator|(
name|value
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|value
operator|!=
literal|1
operator|)
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|sc_conf
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|C
argument_list|(
name|UR_SET_INTERFACE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SYNCH_FRAME
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
break|break;
comment|/* Hub requests */
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"UR_CLEAR_PORT_FEATURE "
literal|"port=%d feature=%d\n"
argument_list|,
name|index
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|1
operator|)
operator|||
operator|(
name|index
operator|>
name|sc
operator|->
name|sc_noport
operator|)
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|port
operator|=
name|OHCI_RH_PORT_STATUS
argument_list|(
name|index
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_CURRENT_CONNECT_STATUS
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_OVERCURRENT_INDICATOR
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_POWER
case|:
comment|/* Yes, writing to the LOW_SPEED bit clears power. */
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_LOW_SPEED
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONNECTION
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_CONNECT_STATUS
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_ENABLE
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_PORT_ENABLED
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_SUSPEND
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_SUSPEND
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_OVERCURRENT_INDICATOR
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_RESET
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_C_PORT_RESET
operator|<<
literal|16
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_C_PORT_CONNECTION
case|:
case|case
name|UHF_C_PORT_ENABLE
case|:
case|case
name|UHF_C_PORT_SUSPEND
case|:
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
case|case
name|UHF_C_PORT_RESET
case|:
comment|/* enable RHSC interrupt if condition is cleared. */
if|if
condition|(
operator|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|>>
literal|16
operator|)
operator|==
literal|0
condition|)
name|ohci_rhsc_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|v
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_A
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|=
name|ohci_hubd
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|bNbrPorts
operator|=
name|sc
operator|->
name|sc_noport
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|wHubCharacteristics
argument_list|,
operator|(
name|v
operator|&
name|OHCI_NPS
condition|?
name|UHD_PWR_NO_SWITCH
else|:
name|v
operator|&
name|OHCI_PSM
condition|?
name|UHD_PWR_GANGED
else|:
name|UHD_PWR_INDIVIDUAL
operator|)
comment|/* XXX overcurrent */
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|bPwrOn2PwrGood
operator|=
name|OHCI_GET_POTPGT
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_DESCRIPTOR_B
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|sc
operator|->
name|sc_noport
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|&
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|DeviceRemovable
index|[
name|l
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|l
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|v
operator|>>=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|bDescLength
operator|=
literal|8
operator|+
operator|(
operator|(
name|sc
operator|->
name|sc_noport
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
name|len
operator|=
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|bDescLength
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
name|len
operator|=
literal|16
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"get port status i=%d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|1
operator|)
operator|||
operator|(
name|index
operator|>
name|sc
operator|->
name|sc_noport
operator|)
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|v
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_RH_PORT_STATUS
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"port status=0x%04x\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|ps
operator|.
name|wPortStatus
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|ps
operator|.
name|wPortChange
argument_list|,
name|v
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|ps
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
operator|(
name|index
operator|<
literal|1
operator|)
operator|||
operator|(
name|index
operator|>
name|sc
operator|->
name|sc_noport
operator|)
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|port
operator|=
name|OHCI_RH_PORT_STATUS
argument_list|(
name|index
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_PORT_ENABLED
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_SUSPEND
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_RESET
case|:
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"reset port %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
literal|0
init|;
condition|;
name|v
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|<
literal|12
condition|)
block|{
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_PORT_ROOT_RESET_DELAY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|&
name|UPS_RESET
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
name|err
operator|=
name|USB_ERR_TIMEOUT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"ohci port %d reset, status = 0x%04x\n"
argument_list|,
name|index
argument_list|,
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_POWER
case|:
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"set port power %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|UPS_PORT_POWER
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|done
label|:
operator|*
name|plength
operator|=
name|len
expr_stmt|;
operator|*
name|pptr
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_xfer_setup
parameter_list|(
name|struct
name|usb_setup_params
modifier|*
name|parm
parameter_list|)
block|{
name|struct
name|usb_page_search
name|page_info
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|ohci_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|void
modifier|*
name|last_obj
decl_stmt|;
name|uint32_t
name|ntd
decl_stmt|;
name|uint32_t
name|nitd
decl_stmt|;
name|uint32_t
name|nqh
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
name|sc
operator|=
name|OHCI_BUS2SC
argument_list|(
name|parm
operator|->
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|xfer
operator|=
name|parm
operator|->
name|curr_xfer
expr_stmt|;
name|parm
operator|->
name|hc_max_packet_size
operator|=
literal|0x500
expr_stmt|;
name|parm
operator|->
name|hc_max_packet_count
operator|=
literal|1
expr_stmt|;
name|parm
operator|->
name|hc_max_frame_size
operator|=
name|OHCI_PAGE_SIZE
expr_stmt|;
comment|/* 	 * calculate ntd and nqh 	 */
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|ohci_device_ctrl_methods
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|nitd
operator|=
literal|0
expr_stmt|;
name|ntd
operator|=
operator|(
operator|(
literal|2
operator|*
name|xfer
operator|->
name|nframes
operator|)
operator|+
literal|1
comment|/* STATUS */
operator|+
operator|(
name|xfer
operator|->
name|max_data_length
operator|/
name|xfer
operator|->
name|max_hc_frame_size
operator|)
operator|)
expr_stmt|;
name|nqh
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|ohci_device_bulk_methods
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|nitd
operator|=
literal|0
expr_stmt|;
name|ntd
operator|=
operator|(
operator|(
literal|2
operator|*
name|xfer
operator|->
name|nframes
operator|)
operator|+
operator|(
name|xfer
operator|->
name|max_data_length
operator|/
name|xfer
operator|->
name|max_hc_frame_size
operator|)
operator|)
expr_stmt|;
name|nqh
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|ohci_device_intr_methods
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|nitd
operator|=
literal|0
expr_stmt|;
name|ntd
operator|=
operator|(
operator|(
literal|2
operator|*
name|xfer
operator|->
name|nframes
operator|)
operator|+
operator|(
name|xfer
operator|->
name|max_data_length
operator|/
name|xfer
operator|->
name|max_hc_frame_size
operator|)
operator|)
expr_stmt|;
name|nqh
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|ohci_device_isoc_methods
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|nitd
operator|=
operator|(
operator|(
name|xfer
operator|->
name|max_data_length
operator|/
name|OHCI_PAGE_SIZE
operator|)
operator|+
operator|(
operator|(
name|xfer
operator|->
name|nframes
operator|+
name|OHCI_ITD_NOFFSET
operator|-
literal|1
operator|)
operator|/
name|OHCI_ITD_NOFFSET
operator|)
operator|+
literal|1
comment|/* EXTRA */
operator|)
expr_stmt|;
name|ntd
operator|=
literal|0
expr_stmt|;
name|nqh
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|nitd
operator|=
literal|0
expr_stmt|;
name|ntd
operator|=
literal|0
expr_stmt|;
name|nqh
operator|=
literal|0
expr_stmt|;
block|}
name|alloc_dma_set
label|:
if|if
condition|(
name|parm
operator|->
name|err
condition|)
block|{
return|return;
block|}
name|last_obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|usbd_transfer_setup_sub_malloc
argument_list|(
name|parm
argument_list|,
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|ohci_td_t
argument_list|)
argument_list|,
name|OHCI_TD_ALIGN
argument_list|,
name|ntd
argument_list|)
condition|)
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parm
operator|->
name|buf
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|ntd
condition|;
name|n
operator|++
control|)
block|{
name|ohci_td_t
modifier|*
name|td
decl_stmt|;
name|usbd_get_page
argument_list|(
name|pc
operator|+
name|n
argument_list|,
literal|0
argument_list|,
operator|&
name|page_info
argument_list|)
expr_stmt|;
name|td
operator|=
name|page_info
operator|.
name|buffer
expr_stmt|;
comment|/* init TD */
name|td
operator|->
name|td_self
operator|=
name|htole32
argument_list|(
name|page_info
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|td
operator|->
name|obj_next
operator|=
name|last_obj
expr_stmt|;
name|td
operator|->
name|page_cache
operator|=
name|pc
operator|+
name|n
expr_stmt|;
name|last_obj
operator|=
name|td
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|pc
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usbd_transfer_setup_sub_malloc
argument_list|(
name|parm
argument_list|,
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|ohci_itd_t
argument_list|)
argument_list|,
name|OHCI_ITD_ALIGN
argument_list|,
name|nitd
argument_list|)
condition|)
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parm
operator|->
name|buf
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|nitd
condition|;
name|n
operator|++
control|)
block|{
name|ohci_itd_t
modifier|*
name|itd
decl_stmt|;
name|usbd_get_page
argument_list|(
name|pc
operator|+
name|n
argument_list|,
literal|0
argument_list|,
operator|&
name|page_info
argument_list|)
expr_stmt|;
name|itd
operator|=
name|page_info
operator|.
name|buffer
expr_stmt|;
comment|/* init TD */
name|itd
operator|->
name|itd_self
operator|=
name|htole32
argument_list|(
name|page_info
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|itd
operator|->
name|obj_next
operator|=
name|last_obj
expr_stmt|;
name|itd
operator|->
name|page_cache
operator|=
name|pc
operator|+
name|n
expr_stmt|;
name|last_obj
operator|=
name|itd
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|pc
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|xfer
operator|->
name|td_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
operator|=
name|last_obj
expr_stmt|;
name|last_obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|usbd_transfer_setup_sub_malloc
argument_list|(
name|parm
argument_list|,
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|ohci_ed_t
argument_list|)
argument_list|,
name|OHCI_ED_ALIGN
argument_list|,
name|nqh
argument_list|)
condition|)
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parm
operator|->
name|buf
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|nqh
condition|;
name|n
operator|++
control|)
block|{
name|ohci_ed_t
modifier|*
name|ed
decl_stmt|;
name|usbd_get_page
argument_list|(
name|pc
operator|+
name|n
argument_list|,
literal|0
argument_list|,
operator|&
name|page_info
argument_list|)
expr_stmt|;
name|ed
operator|=
name|page_info
operator|.
name|buffer
expr_stmt|;
comment|/* init QH */
name|ed
operator|->
name|ed_self
operator|=
name|htole32
argument_list|(
name|page_info
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|ed
operator|->
name|obj_next
operator|=
name|last_obj
expr_stmt|;
name|ed
operator|->
name|page_cache
operator|=
name|pc
operator|+
name|n
expr_stmt|;
name|last_obj
operator|=
name|ed
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|pc
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
operator|=
name|last_obj
expr_stmt|;
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
operator|=
literal|1
expr_stmt|;
goto|goto
name|alloc_dma_set
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_ep_init
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint_descriptor
modifier|*
name|edesc
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|)
block|{
name|ohci_softc_t
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"endpoint=%p, addr=%d, endpt=%d, mode=%d (%d)\n"
argument_list|,
name|ep
argument_list|,
name|udev
operator|->
name|address
argument_list|,
name|edesc
operator|->
name|bEndpointAddress
argument_list|,
name|udev
operator|->
name|flags
operator|.
name|usb_mode
argument_list|,
name|sc
operator|->
name|sc_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
block|{
comment|/* not supported */
return|return;
block|}
if|if
condition|(
name|udev
operator|->
name|device_index
operator|!=
name|sc
operator|->
name|sc_addr
condition|)
block|{
switch|switch
condition|(
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_CONTROL
case|:
name|ep
operator|->
name|methods
operator|=
operator|&
name|ohci_device_ctrl_methods
expr_stmt|;
break|break;
case|case
name|UE_INTERRUPT
case|:
name|ep
operator|->
name|methods
operator|=
operator|&
name|ohci_device_intr_methods
expr_stmt|;
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
if|if
condition|(
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_FULL
condition|)
block|{
name|ep
operator|->
name|methods
operator|=
operator|&
name|ohci_device_isoc_methods
expr_stmt|;
block|}
break|break;
case|case
name|UE_BULK
case|:
if|if
condition|(
name|udev
operator|->
name|speed
operator|!=
name|USB_SPEED_LOW
condition|)
block|{
name|ep
operator|->
name|methods
operator|=
operator|&
name|ohci_device_bulk_methods
expr_stmt|;
block|}
break|break;
default|default:
comment|/* do nothing */
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_xfer_unsetup
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_get_dma_delay
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
name|uint32_t
modifier|*
name|pus
parameter_list|)
block|{
comment|/* 	 * Wait until hardware has finished any possible use of the 	 * transfer descriptor(s) and QH 	 */
operator|*
name|pus
operator|=
operator|(
literal|1125
operator|)
expr_stmt|;
comment|/* microseconds */
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_device_resume
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|ohci_softc
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|usb_pipe_methods
modifier|*
name|methods
decl_stmt|;
name|ohci_ed_t
modifier|*
name|ed
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|==
name|udev
condition|)
block|{
name|methods
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|methods
expr_stmt|;
name|ed
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
if|if
condition|(
name|methods
operator|==
operator|&
name|ohci_device_bulk_methods
condition|)
block|{
name|OHCI_APPEND_QH
argument_list|(
name|ed
argument_list|,
name|sc
operator|->
name|sc_bulk_p_last
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_BLF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|ohci_device_ctrl_methods
condition|)
block|{
name|OHCI_APPEND_QH
argument_list|(
name|ed
argument_list|,
name|sc
operator|->
name|sc_ctrl_p_last
argument_list|)
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_CLF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|ohci_device_intr_methods
condition|)
block|{
name|OHCI_APPEND_QH
argument_list|(
name|ed
argument_list|,
name|sc
operator|->
name|sc_intr_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_device_suspend
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|ohci_softc
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|usb_pipe_methods
modifier|*
name|methods
decl_stmt|;
name|ohci_ed_t
modifier|*
name|ed
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|==
name|udev
condition|)
block|{
name|methods
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|methods
expr_stmt|;
name|ed
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
if|if
condition|(
name|methods
operator|==
operator|&
name|ohci_device_bulk_methods
condition|)
block|{
name|OHCI_REMOVE_QH
argument_list|(
name|ed
argument_list|,
name|sc
operator|->
name|sc_bulk_p_last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|ohci_device_ctrl_methods
condition|)
block|{
name|OHCI_REMOVE_QH
argument_list|(
name|ed
argument_list|,
name|sc
operator|->
name|sc_ctrl_p_last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|ohci_device_intr_methods
condition|)
block|{
name|OHCI_REMOVE_QH
argument_list|(
name|ed
argument_list|,
name|sc
operator|->
name|sc_intr_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ohci_set_hw_power
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|ohci_softc
modifier|*
name|sc
init|=
name|OHCI_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|flags
operator|=
name|bus
operator|->
name|hw_power_state
expr_stmt|;
name|temp
operator|=
name|OREAD4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|OHCI_PLE
operator||
name|OHCI_IE
operator||
name|OHCI_CLE
operator||
name|OHCI_BLE
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|USB_HW_POWER_CONTROL
condition|)
name|temp
operator||=
name|OHCI_CLE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|USB_HW_POWER_BULK
condition|)
name|temp
operator||=
name|OHCI_BLE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|USB_HW_POWER_INTERRUPT
condition|)
name|temp
operator||=
name|OHCI_PLE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|USB_HW_POWER_ISOC
condition|)
name|temp
operator||=
name|OHCI_IE
operator||
name|OHCI_PLE
expr_stmt|;
name|OWRITE4
argument_list|(
name|sc
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_bus_methods
name|ohci_bus_methods
init|=
block|{
operator|.
name|endpoint_init
operator|=
name|ohci_ep_init
block|,
operator|.
name|xfer_setup
operator|=
name|ohci_xfer_setup
block|,
operator|.
name|xfer_unsetup
operator|=
name|ohci_xfer_unsetup
block|,
operator|.
name|get_dma_delay
operator|=
name|ohci_get_dma_delay
block|,
operator|.
name|device_resume
operator|=
name|ohci_device_resume
block|,
operator|.
name|device_suspend
operator|=
name|ohci_device_suspend
block|,
operator|.
name|set_hw_power
operator|=
name|ohci_set_hw_power
block|,
operator|.
name|roothub_exec
operator|=
name|ohci_roothub_exec
block|,
operator|.
name|xfer_poll
operator|=
name|ohci_do_poll
block|, }
decl_stmt|;
end_decl_stmt

end_unit

